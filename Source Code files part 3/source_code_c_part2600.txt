      /* [out] */ UINT *puArgErr);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Color )( 
            IDXTShadow * This,
            /* [in] */ BSTR bstrColor);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Color )( 
            IDXTShadow * This,
            /* [retval][out] */ BSTR *pbstrColor);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Direction )( 
            IDXTShadow * This,
            /* [retval][out] */ long *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Direction )( 
            IDXTShadow * This,
            /* [in] */ long newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Strength )( 
            IDXTShadow * This,
            /* [retval][out] */ long *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Strength )( 
            IDXTShadow * This,
            /* [in] */ long newVal);
        
        END_INTERFACE
    } IDXTShadowVtbl;

    interface IDXTShadow
    {
        CONST_VTBL struct IDXTShadowVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTShadow_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTShadow_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTShadow_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTShadow_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTShadow_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTShadow_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTShadow_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTShadow_put_Color(This,bstrColor)	\
    (This)->lpVtbl -> put_Color(This,bstrColor)

#define IDXTShadow_get_Color(This,pbstrColor)	\
    (This)->lpVtbl -> get_Color(This,pbstrColor)

#define IDXTShadow_get_Direction(This,pVal)	\
    (This)->lpVtbl -> get_Direction(This,pVal)

#define IDXTShadow_put_Direction(This,newVal)	\
    (This)->lpVtbl -> put_Direction(This,newVal)

#define IDXTShadow_get_Strength(This,pVal)	\
    (This)->lpVtbl -> get_Strength(This,pVal)

#define IDXTShadow_put_Strength(This,newVal)	\
    (This)->lpVtbl -> put_Strength(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTShadow_put_Color_Proxy( 
    IDXTShadow * This,
    /* [in] */ BSTR bstrColor);


void __RPC_STUB IDXTShadow_put_Color_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTShadow_get_Color_Proxy( 
    IDXTShadow * This,
    /* [retval][out] */ BSTR *pbstrColor);


void __RPC_STUB IDXTShadow_get_Color_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTShadow_get_Direction_Proxy( 
    IDXTShadow * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IDXTShadow_get_Direction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTShadow_put_Direction_Proxy( 
    IDXTShadow * This,
    /* [in] */ long newVal);


void __RPC_STUB IDXTShadow_put_Direction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTShadow_get_Strength_Proxy( 
    IDXTShadow * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IDXTShadow_get_Strength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTShadow_put_Strength_Proxy( 
    IDXTShadow * This,
    /* [in] */ long newVal);


void __RPC_STUB IDXTShadow_put_Strength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTShadow_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxtmsft_0339 */
/* [local] */ 

typedef 
enum DISPID_DXTWAVE
    {	DISPID_DXTWAVE_ADD	= 1,
	DISPID_DXTWAVE_FREQ	= DISPID_DXTWAVE_ADD + 1,
	DISPID_DXTWAVE_LIGHTSTRENGTH	= DISPID_DXTWAVE_FREQ + 1,
	DISPID_DXTWAVE_PHASE	= DISPID_DXTWAVE_LIGHTSTRENGTH + 1,
	DISPID_DXTWAVE_STRENGTH	= DISPID_DXTWAVE_PHASE + 1
    } 	DISPID_DXTWAVE;



extern RPC_IF_HANDLE __MIDL_itf_dxtmsft_0339_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtmsft_0339_v0_0_s_ifspec;

#ifndef __IDXTWave_INTERFACE_DEFINED__
#define __IDXTWave_INTERFACE_DEFINED__

/* interface IDXTWave */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTWave;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1D4637E7-383C-11d2-952A-00C04FA34F05")
    IDXTWave : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Add( 
            /* [retval][out] */ VARIANT_BOOL *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Add( 
            /* [in] */ VARIANT_BOOL newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Freq( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Freq( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_LightStrength( 
            /* [retval][out] */ int *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_LightStrength( 
            /* [in] */ int newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Phase( 
            /* [retval][out] */ int *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Phase( 
            /* [in] */ int newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Strength( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Strength( 
            /* [in] */ long newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTWaveVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXTWave * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXTWave * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXTWave * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDXTWave * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDXTWave * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDXTWave * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDXTWave * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Add )( 
            IDXTWave * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Add )( 
            IDXTWave * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Freq )( 
            IDXTWave * This,
            /* [retval][out] */ long *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Freq )( 
            IDXTWave * This,
            /* [in] */ long newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LightStrength )( 
            IDXTWave * This,
            /* [retval][out] */ int *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_LightStrength )( 
            IDXTWave * This,
            /* [in] */ int newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Phase )( 
            IDXTWave * This,
            /* [retval][out] */ int *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Phase )( 
            IDXTWave * This,
            /* [in] */ int newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Strength )( 
            IDXTWave * This,
            /* [retval][out] */ long *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Strength )( 
            IDXTWave * This,
            /* [in] */ long newVal);
        
        END_INTERFACE
    } IDXTWaveVtbl;

    interface IDXTWave
    {
        CONST_VTBL struct IDXTWaveVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTWave_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTWave_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTWave_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTWave_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTWave_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTWave_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTWave_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTWave_get_Add(This,pVal)	\
    (This)->lpVtbl -> get_Add(This,pVal)

#define IDXTWave_put_Add(This,newVal)	\
    (This)->lpVtbl -> put_Add(This,newVal)

#define IDXTWave_get_Freq(This,pVal)	\
    (This)->lpVtbl -> get_Freq(This,pVal)

#define IDXTWave_put_Freq(This,newVal)	\
    (This)->lpVtbl -> put_Freq(This,newVal)

#define IDXTWave_get_LightStrength(This,pVal)	\
    (This)->lpVtbl -> get_LightStrength(This,pVal)

#define IDXTWave_put_LightStrength(This,newVal)	\
    (This)->lpVtbl -> put_LightStrength(This,newVal)

#define IDXTWave_get_Phase(This,pVal)	\
    (This)->lpVtbl -> get_Phase(This,pVal)

#define IDXTWave_put_Phase(This,newVal)	\
    (This)->lpVtbl -> put_Phase(This,newVal)

#define IDXTWave_get_Strength(This,pVal)	\
    (This)->lpVtbl -> get_Strength(This,pVal)

#define IDXTWave_put_Strength(This,newVal)	\
    (This)->lpVtbl -> put_Strength(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTWave_get_Add_Proxy( 
    IDXTWave * This,
    /* [retval][out] */ VARIANT_BOOL *pVal);


void __RPC_STUB IDXTWave_get_Add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTWave_put_Add_Proxy( 
    IDXTWave * This,
    /* [in] */ VARIANT_BOOL newVal);


void __RPC_STUB IDXTWave_put_Add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTWave_get_Freq_Proxy( 
    IDXTWave * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IDXTWave_get_Freq_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTWave_put_Freq_Proxy( 
    IDXTWave * This,
    /* [in] */ long newVal);


void __RPC_STUB IDXTWave_put_Freq_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTWave_get_LightStrength_Proxy( 
    IDXTWave * This,
    /* [retval][out] */ int *pVal);


void __RPC_STUB IDXTWave_get_LightStrength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTWave_put_LightStrength_Proxy( 
    IDXTWave * This,
    /* [in] */ int newVal);


void __RPC_STUB IDXTWave_put_LightStrength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTWave_get_Phase_Proxy( 
    IDXTWave * This,
    /* [retval][out] */ int *pVal);


void __RPC_STUB IDXTWave_get_Phase_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTWave_put_Phase_Proxy( 
    IDXTWave * This,
    /* [in] */ int newVal);


void __RPC_STUB IDXTWave_put_Phase_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTWave_get_Strength_Proxy( 
    IDXTWave * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IDXTWave_get_Strength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTWave_put_Strength_Proxy( 
    IDXTWave * This,
    /* [in] */ long newVal);


void __RPC_STUB IDXTWave_put_Strength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTWave_INTERFACE_DEFINED__ */


#ifndef __IDXTLight_INTERFACE_DEFINED__
#define __IDXTLight_INTERFACE_DEFINED__

/* interface IDXTLight */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTLight;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F9EFBEC1-4302-11D2-952A-00C04FA34F05")
    IDXTLight : public IDispatch
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE addAmbient( 
            int r,
            int g,
            int b,
            int strength) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE addPoint( 
            int x,
            int y,
            int z,
            int r,
            int g,
            int b,
            int strength) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE addCone( 
            int x,
            int y,
            int z,
            int tx,
            int ty,
            int r,
            int g,
            int b,
            int strength,
            int spread) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE moveLight( 
            int lightNum,
            int x,
            int y,
            int z,
            BOOL fAbsolute) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE ChangeStrength( 
            int lightNum,
            int dStrength,
            BOOL fAbsolute) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE ChangeColor( 
            int lightNum,
            int R,
            int G,
            int B,
            BOOL fAbsolute) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Clear( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTLightVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXTLight * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXTLight * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXTLight * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDXTLight * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDXTLight * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDXTLight * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDXTLight * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *addAmbient )( 
            IDXTLight * This,
            int r,
            int g,
            int b,
            int strength);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *addPoint )( 
            IDXTLight * This,
            int x,
            int y,
            int z,
            int r,
            int g,
            int b,
            int strength);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *addCone )( 
            IDXTLight * This,
            int x,
            int y,
            int z,
            int tx,
            int ty,
            int r,
            int g,
            int b,
            int strength,
            int spread);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *moveLight )( 
            IDXTLight * This,
            int lightNum,
            int x,
            int y,
            int z,
            BOOL fAbsolute);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *ChangeStrength )( 
            IDXTLight * This,
            int lightNum,
            int dStrength,
            BOOL fAbsolute);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *ChangeColor )( 
            IDXTLight * This,
            int lightNum,
            int R,
            int G,
            int B,
            BOOL fAbsolute);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Clear )( 
            IDXTLight * This);
        
        END_INTERFACE
    } IDXTLightVtbl;

    interface IDXTLight
    {
        CONST_VTBL struct IDXTLightVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTLight_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTLight_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTLight_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTLight_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTLight_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTLight_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTLight_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTLight_addAmbient(This,r,g,b,strength)	\
    (This)->lpVtbl -> addAmbient(This,r,g,b,strength)

#define IDXTLight_addPoint(This,x,y,z,r,g,b,strength)	\
    (This)->lpVtbl -> addPoint(This,x,y,z,r,g,b,strength)

#define IDXTLight_addCone(This,x,y,z,tx,ty,r,g,b,strength,spread)	\
    (This)->lpVtbl -> addCone(This,x,y,z,tx,ty,r,g,b,strength,spread)

#define IDXTLight_moveLight(This,lightNum,x,y,z,fAbsolute)	\
    (This)->lpVtbl -> moveLight(This,lightNum,x,y,z,fAbsolute)

#define IDXTLight_ChangeStrength(This,lightNum,dStrength,fAbsolute)	\
    (This)->lpVtbl -> ChangeStrength(This,lightNum,dStrength,fAbsolute)

#define IDXTLight_ChangeColor(This,lightNum,R,G,B,fAbsolute)	\
    (This)->lpVtbl -> ChangeColor(This,lightNum,R,G,B,fAbsolute)

#define IDXTLight_Clear(This)	\
    (This)->lpVtbl -> Clear(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id] */ HRESULT STDMETHODCALLTYPE IDXTLight_addAmbient_Proxy( 
    IDXTLight * This,
    int r,
    int g,
    int b,
    int strength);


void __RPC_STUB IDXTLight_addAmbient_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IDXTLight_addPoint_Proxy( 
    IDXTLight * This,
    int x,
    int y,
    int z,
    int r,
    int g,
    int b,
    int strength);


void __RPC_STUB IDXTLight_addPoint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IDXTLight_addCone_Proxy( 
    IDXTLight * This,
    int x,
    int y,
    int z,
    int tx,
    int ty,
    int r,
    int g,
    int b,
    int strength,
    int spread);


void __RPC_STUB IDXTLight_addCone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IDXTLight_moveLight_Proxy( 
    IDXTLight * This,
    int lightNum,
    int x,
    int y,
    int z,
    BOOL fAbsolute);


void __RPC_STUB IDXTLight_moveLight_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IDXTLight_ChangeStrength_Proxy( 
    IDXTLight * This,
    int lightNum,
    int dStrength,
    BOOL fAbsolute);


void __RPC_STUB IDXTLight_ChangeStrength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IDXTLight_ChangeColor_Proxy( 
    IDXTLight * This,
    int lightNum,
    int R,
    int G,
    int B,
    BOOL fAbsolute);


void __RPC_STUB IDXTLight_ChangeColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IDXTLight_Clear_Proxy( 
    IDXTLight * This);


void __RPC_STUB IDXTLight_Clear_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTLight_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxtmsft_0341 */
/* [local] */ 

typedef 
enum DISPID_DXTMOTIONBLUR
    {	DISPID_DXTMOTIONBLUR_ADD	= 1,
	DISPID_DXTMOTIONBLUR_DIRECTION	= DISPID_DXTMOTIONBLUR_ADD + 1,
	DISPID_DXTMOTIONBLUR_STRENGTH	= DISPID_DXTMOTIONBLUR_DIRECTION + 1
    } 	DISPID_DXTMOTIONBLUR;



extern RPC_IF_HANDLE __MIDL_itf_dxtmsft_0341_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtmsft_0341_v0_0_s_ifspec;

#ifndef __IDXTMotionBlur_INTERFACE_DEFINED__
#define __IDXTMotionBlur_INTERFACE_DEFINED__

/* interface IDXTMotionBlur */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTMotionBlur;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("089057BE-D3F5-4A2C-B10A-A5130184A0F7")
    IDXTMotionBlur : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Add( 
            /* [retval][out] */ VARIANT_BOOL *pfAdd) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Add( 
            /* [in] */ VARIANT_BOOL fAdd) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Direction( 
            /* [retval][out] */ short *pnDirection) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Direction( 
            /* [in] */ short nDirection) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Strength( 
            /* [retval][out] */ long *pnStrength) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Strength( 
            /* [in] */ long nStrength) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTMotionBlurVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXTMotionBlur * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXTMotionBlur * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXTMotionBlur * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDXTMotionBlur * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDXTMotionBlur * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDXTMotionBlur * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDXTMotionBlur * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Add )( 
            IDXTMotionBlur * This,
            /* [retval][out] */ VARIANT_BOOL *pfAdd);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Add )( 
            IDXTMotionBlur * This,
            /* [in] */ VARIANT_BOOL fAdd);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Direction )( 
            IDXTMotionBlur * This,
            /* [retval][out] */ short *pnDirection);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Direction )( 
            IDXTMotionBlur * This,
            /* [in] */ short nDirection);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Strength )( 
            IDXTMotionBlur * This,
            /* [retval][out] */ long *pnStrength);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Strength )( 
            IDXTMotionBlur * This,
            /* [in] */ long nStrength);
        
        END_INTERFACE
    } IDXTMotionBlurVtbl;

    interface IDXTMotionBlur
    {
        CONST_VTBL struct IDXTMotionBlurVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTMotionBlur_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTMotionBlur_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTMotionBlur_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTMotionBlur_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTMotionBlur_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTMotionBlur_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTMotionBlur_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTMotionBlur_get_Add(This,pfAdd)	\
    (This)->lpVtbl -> get_Add(This,pfAdd)

#define IDXTMotionBlur_put_Add(This,fAdd)	\
    (This)->lpVtbl -> put_Add(This,fAdd)

#define IDXTMotionBlur_get_Direction(This,pnDirection)	\
    (This)->lpVtbl -> get_Direction(This,pnDirection)

#define IDXTMotionBlur_put_Direction(This,nDirection)	\
    (This)->lpVtbl -> put_Direction(This,nDirection)

#define IDXTMotionBlur_get_Strength(This,pnStrength)	\
    (This)->lpVtbl -> get_Strength(This,pnStrength)

#define IDXTMotionBlur_put_Strength(This,nStrength)	\
    (This)->lpVtbl -> put_Strength(This,nStrength)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTMotionBlur_get_Add_Proxy( 
    IDXTMotionBlur * This,
    /* [retval][out] */ VARIANT_BOOL *pfAdd);


void __RPC_STUB IDXTMotionBlur_get_Add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTMotionBlur_put_Add_Proxy( 
    IDXTMotionBlur * This,
    /* [in] */ VARIANT_BOOL fAdd);


void __RPC_STUB IDXTMotionBlur_put_Add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTMotionBlur_get_Direction_Proxy( 
    IDXTMotionBlur * This,
    /* [retval][out] */ short *pnDirection);


void __RPC_STUB IDXTMotionBlur_get_Direction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTMotionBlur_put_Direction_Proxy( 
    IDXTMotionBlur * This,
    /* [in] */ short nDirection);


void __RPC_STUB IDXTMotionBlur_put_Direction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTMotionBlur_get_Strength_Proxy( 
    IDXTMotionBlur * This,
    /* [retval][out] */ long *pnStrength);


void __RPC_STUB IDXTMotionBlur_get_Strength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTMotionBlur_put_Strength_Proxy( 
    IDXTMotionBlur * This,
    /* [in] */ long nStrength);


void __RPC_STUB IDXTMotionBlur_put_Strength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTMotionBlur_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxtmsft_0342 */
/* [local] */ 

typedef 
enum DISPID_DXTMATRIX
    {	DISPID_DXTMATRIX_M11	= 1,
	DISPID_DXTMATRIX_M12	= DISPID_DXTMATRIX_M11 + 1,
	DISPID_DXTMATRIX_DX	= DISPID_DXTMATRIX_M12 + 1,
	DISPID_DXTMATRIX_M21	= DISPID_DXTMATRIX_DX + 1,
	DISPID_DXTMATRIX_M22	= DISPID_DXTMATRIX_M21 + 1,
	DISPID_DXTMATRIX_DY	= DISPID_DXTMATRIX_M22 + 1,
	DISPID_DXTMATRIX_SIZINGMETHOD	= DISPID_DXTMATRIX_DY + 1,
	DISPID_DXTMATRIX_FILTERTYPE	= DISPID_DXTMATRIX_SIZINGMETHOD + 1
    } 	DISPID_DXTMATRIX;



extern RPC_IF_HANDLE __MIDL_itf_dxtmsft_0342_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtmsft_0342_v0_0_s_ifspec;

#ifndef __IDXTMatrix_INTERFACE_DEFINED__
#define __IDXTMatrix_INTERFACE_DEFINED__

/* interface IDXTMatrix */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTMatrix;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AC66A493-0F0C-4C76-825C-9D68BEDE9188")
    IDXTMatrix : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_M11( 
            /* [retval][out] */ float *pflM11) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_M11( 
            /* [in] */ const float flM11) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_M12( 
            /* [retval][out] */ float *pflM12) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_M12( 
            /* [in] */ const float flM12) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Dx( 
            /* [retval][out] */ float *pfldx) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Dx( 
            /* [in] */ const float fldx) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_M21( 
            /* [retval][out] */ float *pflM21) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_M21( 
            /* [in] */ const float flM21) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_M22( 
            /* [retval][out] */ float *pflM22) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_M22( 
            /* [in] */ const float flM22) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Dy( 
            /* [retval][out] */ float *pfldy) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Dy( 
            /* [in] */ const float fldy) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_SizingMethod( 
            /* [retval][out] */ BSTR *pbstrSizingMethod) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_SizingMethod( 
            /* [in] */ const BSTR bstrSizingMethod) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_FilterType( 
            /* [retval][out] */ BSTR *pbstrFilterType) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_FilterType( 
            /* [in] */ const BSTR bstrFilterType) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTMatrixVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXTMatrix * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXTMatrix * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXTMatrix * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDXTMatrix * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDXTMatrix * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDXTMatrix * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDXTMatrix * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_M11 )( 
            IDXTMatrix * This,
            /* [retval][out] */ float *pflM11);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_M11 )( 
            IDXTMatrix * This,
            /* [in] */ const float flM11);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_M12 )( 
            IDXTMatrix * This,
            /* [retval][out] */ float *pflM12);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_M12 )( 
            IDXTMatrix * This,
            /* [in] */ const float flM12);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Dx )( 
            IDXTMatrix * This,
            /* [retval][out] */ float *pfldx);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Dx )( 
            IDXTMatrix * This,
            /* [in] */ const float fldx);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_M21 )( 
            IDXTMatrix * This,
            /* [retval][out] */ float *pflM21);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_M21 )( 
            IDXTMatrix * This,
            /* [in] */ const float flM21);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_M22 )( 
            IDXTMatrix * This,
            /* [retval][out] */ float *pflM22);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_M22 )( 
            IDXTMatrix * This,
            /* [in] */ const float flM22);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Dy )( 
            IDXTMatrix * This,
            /* [retval][out] */ float *pfldy);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Dy )( 
            IDXTMatrix * This,
            /* [in] */ const float fldy);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SizingMethod )( 
            IDXTMatrix * This,
            /* [retval][out] */ BSTR *pbstrSizingMethod);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_SizingMethod )( 
            IDXTMatrix * This,
            /* [in] */ const BSTR bstrSizingMethod);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FilterType )( 
            IDXTMatrix * This,
            /* [retval][out] */ BSTR *pbstrFilterType);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_FilterType )( 
            IDXTMatrix * This,
            /* [in] */ const BSTR bstrFilterType);
        
        END_INTERFACE
    } IDXTMatrixVtbl;

    interface IDXTMatrix
    {
        CONST_VTBL struct IDXTMatrixVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTMatrix_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTMatrix_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTMatrix_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTMatrix_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTMatrix_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTMatrix_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTMatrix_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTMatrix_get_M11(This,pflM11)	\
    (This)->lpVtbl -> get_M11(This,pflM11)

#define IDXTMatrix_put_M11(This,flM11)	\
    (This)->lpVtbl -> put_M11(This,flM11)

#define IDXTMatrix_get_M12(This,pflM12)	\
    (This)->lpVtbl -> get_M12(This,pflM12)

#define IDXTMatrix_put_M12(This,flM12)	\
    (This)->lpVtbl -> put_M12(This,flM12)

#define IDXTMatrix_get_Dx(This,pfldx)	\
    (This)->lpVtbl -> get_Dx(This,pfldx)

#define IDXTMatrix_put_Dx(This,fldx)	\
    (This)->lpVtbl -> put_Dx(This,fldx)

#define IDXTMatrix_get_M21(This,pflM21)	\
    (This)->lpVtbl -> get_M21(This,pflM21)

#define IDXTMatrix_put_M21(This,flM21)	\
    (This)->lpVtbl -> put_M21(This,flM21)

#define IDXTMatrix_get_M22(This,pflM22)	\
    (This)->lpVtbl -> get_M22(This,pflM22)

#define IDXTMatrix_put_M22(This,flM22)	\
    (This)->lpVtbl -> put_M22(This,flM22)

#define IDXTMatrix_get_Dy(This,pfldy)	\
    (This)->lpVtbl -> get_Dy(This,pfldy)

#define IDXTMatrix_put_Dy(This,fldy)	\
    (This)->lpVtbl -> put_Dy(This,fldy)

#define IDXTMatrix_get_SizingMethod(This,pbstrSizingMethod)	\
    (This)->lpVtbl -> get_SizingMethod(This,pbstrSizingMethod)

#define IDXTMatrix_put_SizingMethod(This,bstrSizingMethod)	\
    (This)->lpVtbl -> put_SizingMethod(This,bstrSizingMethod)

#define IDXTMatrix_get_FilterType(This,pbstrFilterType)	\
    (This)->lpVtbl -> get_FilterType(This,pbstrFilterType)

#define IDXTMatrix_put_FilterType(This,bstrFilterType)	\
    (This)->lpVtbl -> put_FilterType(This,bstrFilterType)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTMatrix_get_M11_Proxy( 
    IDXTMatrix * This,
    /* [retval][out] */ float *pflM11);


void __RPC_STUB IDXTMatrix_get_M11_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTMatrix_put_M11_Proxy( 
    IDXTMatrix * This,
    /* [in] */ const float flM11);


void __RPC_STUB IDXTMatrix_put_M11_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTMatrix_get_M12_Proxy( 
    IDXTMatrix * This,
    /* [retval][out] */ float *pflM12);


void __RPC_STUB IDXTMatrix_get_M12_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTMatrix_put_M12_Proxy( 
    IDXTMatrix * This,
    /* [in] */ const float flM12);


void __RPC_STUB IDXTMatrix_put_M12_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTMatrix_get_Dx_Proxy( 
    IDXTMatrix * This,
    /* [retval][out] */ float *pfldx);


void __RPC_STUB IDXTMatrix_get_Dx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTMatrix_put_Dx_Proxy( 
    IDXTMatrix * This,
    /* [in] */ const float fldx);


void __RPC_STUB IDXTMatrix_put_Dx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTMatrix_get_M21_Proxy( 
    IDXTMatrix * This,
    /* [retval][out] */ float *pflM21);


void __RPC_STUB IDXTMatrix_get_M21_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTMatrix_put_M21_Proxy( 
    IDXTMatrix * This,
    /* [in] */ const float flM21);


void __RPC_STUB IDXTMatrix_put_M21_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTMatrix_get_M22_Proxy( 
    IDXTMatrix * This,
    /* [retval][out] */ float *pflM22);


void __RPC_STUB IDXTMatrix_get_M22_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTMatrix_put_M22_Proxy( 
    IDXTMatrix * This,
    /* [in] */ const float flM22);


void __RPC_STUB IDXTMatrix_put_M22_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTMatrix_get_Dy_Proxy( 
    IDXTMatrix * This,
    /* [retval][out] */ float *pfldy);


void __RPC_STUB IDXTMatrix_get_Dy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTMatrix_put_Dy_Proxy( 
    IDXTMatrix * This,
    /* [in] */ const float fldy);


void __RPC_STUB IDXTMatrix_put_Dy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTMatrix_get_SizingMethod_Proxy( 
    IDXTMatrix * This,
    /* [retval][out] */ BSTR *pbstrSizingMethod);


void __RPC_STUB IDXTMatrix_get_SizingMethod_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTMatrix_put_SizingMethod_Proxy( 
    IDXTMatrix * This,
    /* [in] */ const BSTR bstrSizingMethod);


void __RPC_STUB IDXTMatrix_put_SizingMethod_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTMatrix_get_FilterType_Proxy( 
    IDXTMatrix * This,
    /* [retval][out] */ BSTR *pbstrFilterType);


void __RPC_STUB IDXTMatrix_get_FilterType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTMatrix_put_FilterType_Proxy( 
    IDXTMatrix * This,
    /* [in] */ const BSTR bstrFilterType);


void __RPC_STUB IDXTMatrix_put_FilterType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTMatrix_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxtmsft_0343 */
/* [local] */ 

typedef 
enum DISPID_DXTICMFILTER
    {	DISPID_DXTICMFILTER_COLORSPACE	= 1,
	DISPID_DXTICMFILTER_INTENT	= DISPID_DXTICMFILTER_COLORSPACE + 1
    } 	DISPID_DXTICMFILTER;



extern RPC_IF_HANDLE __MIDL_itf_dxtmsft_0343_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtmsft_0343_v0_0_s_ifspec;

#ifndef __IDXTICMFilter_INTERFACE_DEFINED__
#define __IDXTICMFilter_INTERFACE_DEFINED__

/* interface IDXTICMFilter */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTICMFilter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("734321ED-1E7B-4E1C-BBFA-89C819800E2F")
    IDXTICMFilter : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_ColorSpace( 
            /* [retval][out] */ BSTR *pbstrColorSpace) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_ColorSpace( 
            /* [in] */ BSTR bstrColorSpace) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Intent( 
            /* [retval][out] */ short *pnIntent) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Intent( 
            /* [in] */ short nIntent) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTICMFilterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXTICMFilter * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXTICMFilter * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXTICMFilter * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDXTICMFilter * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDXTICMFilter * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDXTICMFilter * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDXTICMFilter * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ColorSpace )( 
            IDXTICMFilter * This,
            /* [retval][out] */ BSTR *pbstrColorSpace);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ColorSpace )( 
            IDXTICMFilter * This,
            /* [in] */ BSTR bstrColorSpace);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Intent )( 
            IDXTICMFilter * This,
            /* [retval][out] */ short *pnIntent);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Intent )( 
            IDXTICMFilter * This,
            /* [in] */ short nIntent);
        
        END_INTERFACE
    } IDXTICMFilterVtbl;

    interface IDXTICMFilter
    {
        CONST_VTBL struct IDXTICMFilterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTICMFilter_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTICMFilter_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTICMFilter_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTICMFilter_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTICMFilter_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTICMFilter_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTICMFilter_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTICMFilter_get_ColorSpace(This,pbstrColorSpace)	\
    (This)->lpVtbl -> get_ColorSpace(This,pbstrColorSpace)

#define IDXTICMFilter_put_ColorSpace(This,bstrColorSpace)	\
    (This)->lpVtbl -> put_ColorSpace(This,bstrColorSpace)

#define IDXTICMFilter_get_Intent(This,pnIntent)	\
    (This)->lpVtbl -> get_Intent(This,pnIntent)

#define IDXTICMFilter_put_Intent(This,nIntent)	\
    (This)->lpVtbl -> put_Intent(This,nIntent)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTICMFilter_get_ColorSpace_Proxy( 
    IDXTICMFilter * This,
    /* [retval][out] */ BSTR *pbstrColorSpace);


void __RPC_STUB IDXTICMFilter_get_ColorSpace_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTICMFilter_put_ColorSpace_Proxy( 
    IDXTICMFilter * This,
    /* [in] */ BSTR bstrColorSpace);


void __RPC_STUB IDXTICMFilter_put_ColorSpace_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTICMFilter_get_Intent_Proxy( 
    IDXTICMFilter * This,
    /* [retval][out] */ short *pnIntent);


void __RPC_STUB IDXTICMFilter_get_Intent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTICMFilter_put_Intent_Proxy( 
    IDXTICMFilter * This,
    /* [in] */ short nIntent);


void __RPC_STUB IDXTICMFilter_put_Intent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTICMFilter_INTERFACE_DEFINED__ */



#ifndef __DXTMSFTLib_LIBRARY_DEFINED__
#define __DXTMSFTLib_LIBRARY_DEFINED__

/* library DXTMSFTLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_DXTMSFTLib;

EXTERN_C const CLSID CLSID_DXTComposite;

#ifdef __cplusplus

class DECLSPEC_UUID("9A43A844-0831-11D1-817F-0000F87557DB")
DXTComposite;
#endif

EXTERN_C const CLSID CLSID_DXLUTBuilder;

#ifdef __cplusplus

class DECLSPEC_UUID("1E54333B-2A00-11d1-8198-0000F87557DB")
DXLUTBuilder;
#endif

EXTERN_C const CLSID CLSID_DXTGradientD;

#ifdef __cplusplus

class DECLSPEC_UUID("623E2882-FC0E-11d1-9A77-0000F8756A10")
DXTGradientD;
#endif

EXTERN_C const CLSID CLSID_DXTWipe;

#ifdef __cplusplus

class DECLSPEC_UUID("AF279B30-86EB-11D1-81BF-0000F87557DB")
DXTWipe;
#endif

EXTERN_C const CLSID CLSID_DXTGradientWipe;

#ifdef __cplusplus

class DECLSPEC_UUID("B96F67A2-30C2-47E8-BD85-70A2C948B50F")
DXTGradientWipe;
#endif

EXTERN_C const CLSID CLSID_DXTWipePP;

#ifdef __cplusplus

class DECLSPEC_UUID("7FFE4D08-FBFD-11d1-9A77-0000F8756A10")
DXTWipePP;
#endif

EXTERN_C const CLSID CLSID_DXTConvolution;

#ifdef __cplusplus

class DECLSPEC_UUID("2BC0EF29-E6BA-11d1-81DD-0000F87557DB")
DXTConvolution;
#endif

EXTERN_C const CLSID CLSID_CrBlur;

#ifdef __cplusplus

class DECLSPEC_UUID("7312498D-E87A-11d1-81E0-0000F87557DB")
CrBlur;
#endif

EXTERN_C const CLSID CLSID_CrEmboss;

#ifdef __cplusplus

class DECLSPEC_UUID("F515306D-0156-11d2-81EA-0000F87557DB")
CrEmboss;
#endif

EXTERN_C const CLSID CLSID_CrEngrave;

#ifdef __cplusplus

class DECLSPEC_UUID("F515306E-0156-11d2-81EA-0000F87557DB")
CrEngrave;
#endif

EXTERN_C const CLSID CLSID_DXFade;

#ifdef __cplusplus

class DECLSPEC_UUID("16B280C5-EE70-11D1-9066-00C04FD9189D")
DXFade;
#endif

EXTERN_C const CLSID CLSID_FadePP;

#ifdef __cplusplus

class DECLSPEC_UUID("16B280C6-EE70-11D1-9066-00C04FD9189D")
FadePP;
#endif

EXTERN_C const CLSID CLSID_BasicImageEffects;

#ifdef __cplusplus

class DECLSPEC_UUID("16B280C8-EE70-11D1-9066-00C04FD9189D")
BasicImageEffects;
#endif

EXTERN_C const CLSID CLSID_BasicImageEffectsPP;

#ifdef __cplusplus

class DECLSPEC_UUID("16B280C9-EE70-11D1-9066-00C04FD9189D")
BasicImageEffectsPP;
#endif

EXTERN_C const CLSID CLSID_Pixelate;

#ifdef __cplusplus

class DECLSPEC_UUID("4CCEA634-FBE0-11d1-906A-00C04FD9189D")
Pixelate;
#endif

EXTERN_C const CLSID CLSID_PixelatePP;

#ifdef __cplusplus

class DECLSPEC_UUID("4CCEA635-FBE0-11d1-906A-00C04FD9189D")
PixelatePP;
#endif

EXTERN_C const CLSID CLSID_CrBlurPP;

#ifdef __cplusplus

class DECLSPEC_UUID("623E287E-FC0E-11d1-9A77-0000F8756A10")
CrBlurPP;
#endif

EXTERN_C const CLSID CLSID_GradientPP;

#ifdef __cplusplus

class DECLSPEC_UUID("623E2880-FC0E-11d1-9A77-0000F8756A10")
GradientPP;
#endif

EXTERN_C const CLSID CLSID_CompositePP;

#ifdef __cplusplus

class DECLSPEC_UUID("25B33660-FD83-11d1-8ADE-444553540001")
CompositePP;
#endif

EXTERN_C const CLSID CLSID_ConvolvePP;

#ifdef __cplusplus

class DECLSPEC_UUID("25B33661-FD83-11d1-8ADE-444553540001")
ConvolvePP;
#endif

EXTERN_C const CLSID CLSID_LUTBuilderPP;

#ifdef __cplusplus

class DECLSPEC_UUID("25B33662-FD83-11d1-8ADE-444553540001")
LUTBuilderPP;
#endif

EXTERN_C const CLSID CLSID_CrIris;

#ifdef __cplusplus

class DECLSPEC_UUID("3F69F351-0379-11D2-A484-00C04F8EFB69")
CrIris;
#endif

EXTERN_C const CLSID CLSID_DXTIris;

#ifdef __cplusplus

class DECLSPEC_UUID("049F2CE6-D996-4721-897A-DB15CE9EB73D")
DXTIris;
#endif

EXTERN_C const CLSID CLSID_CrIrisPP;

#ifdef __cplusplus

class DECLSPEC_UUID("80DE22C4-0F44-11D2-8B82-00A0C93C09B2")
CrIrisPP;
#endif

EXTERN_C const CLSID CLSID_CrSlide;

#ifdef __cplusplus

class DECLSPEC_UUID("810E402F-056B-11D2-A484-00C04F8EFB69")
CrSlide;
#endif

EXTERN_C const CLSID CLSID_DXTSlide;

#ifdef __cplusplus

class DECLSPEC_UUID("D1C5A1E7-CC47-4E32-BDD2-4B3C5FC50AF5")
DXTSlide;
#endif

EXTERN_C const CLSID CLSID_CrSlidePP;

#ifdef __cplusplus

class DECLSPEC_UUID("CC8CEDE1-1003-11d2-8B82-00A0C93C09B2")
CrSlidePP;
#endif

EXTERN_C const CLSID CLSID_CrRadialWipe;

#ifdef __cplusplus

class DECLSPEC_UUID("424B71AF-0695-11D2-A484-00C04F8EFB69")
CrRadialWipe;
#endif

EXTERN_C const CLSID CLSID_DXTRadialWipe;

#ifdef __cplusplus

class DECLSPEC_UUID("164484A9-35D9-4FB7-9FAB-48273B96AA1D")
DXTRadialWipe;
#endif

EXTERN_C const CLSID CLSID_CrRadialWipePP;

#ifdef __cplusplus

class DECLSPEC_UUID("33D932E0-0F48-11d2-8B82-00A0C93C09B2")
CrRadialWipePP;
#endif

EXTERN_C const CLSID CLSID_CrBarn;

#ifdef __cplusplus

class DECLSPEC_UUID("C3BDF740-0B58-11d2-A484-00C04F8EFB69")
CrBarn;
#endif

EXTERN_C const CLSID CLSID_DXTBarn;

#ifdef __cplusplus

class DECLSPEC_UUID("EC9BA17D-60B5-462B-A6D8-14B89057E22A")
DXTBarn;
#endif

EXTERN_C const CLSID CLSID_CrBarnPP;

#ifdef __cplusplus

class DECLSPEC_UUID("FCAD7436-F151-4110-B97E-32BD607FBDB8")
CrBarnPP;
#endif

EXTERN_C const CLSID CLSID_CrBlinds;

#ifdef __cplusplus

class DECLSPEC_UUID("00C429C0-0BA9-11d2-A484-00C04F8EFB69")
CrBlinds;
#endif

EXTERN_C const CLSID CLSID_DXTBlinds;

#ifdef __cplusplus

class DECLSPEC_UUID("9A4A4A51-FB3A-4F4B-9B57-A2912A289769")
DXTBlinds;
#endif

EXTERN_C const CLSID CLSID_CrBlindPP;

#ifdef __cplusplus

class DECLSPEC_UUID("213052C1-100D-11d2-8B82-00A0C93C09B2")
CrBlindPP;
#endif

EXTERN_C const CLSID CLSID_CrStretch;

#ifdef __cplusplus

class DECLSPEC_UUID("7658F2A2-0A83-11d2-A484-00C04F8EFB69")
CrStretch;
#endif

EXTERN_C const CLSID CLSID_DXTStretch;

#ifdef __cplusplus

class DECLSPEC_UUID("F088DE73-BDD0-4E3C-81F8-6D32F4FE9D28")
DXTStretch;
#endif

EXTERN_C const CLSID CLSID_CrStretchPP;

#ifdef __cplusplus

class DECLSPEC_UUID("15FB95E0-0F77-11d2-8B82-00A0C93C09B2")
CrStretchPP;
#endif

EXTERN_C const CLSID CLSID_CrInset;

#ifdef __cplusplus

class DECLSPEC_UUID("93073C40-0BA5-11d2-A484-00C04F8EFB69")
CrInset;
#endif

EXTERN_C const CLSID CLSID_DXTInset;

#ifdef __cplusplus

class DECLSPEC_UUID("76F363F2-7E9F-4ED7-A6A7-EE30351B6628")
DXTInset;
#endif

EXTERN_C const CLSID CLSID_CrSpiral;

#ifdef __cplusplus

class DECLSPEC_UUID("ACA97E00-0C7D-11d2-A484-00C04F8EFB69")
CrSpiral;
#endif

EXTERN_C const CLSID CLSID_DXTSpiral;

#ifdef __cplusplus

class DECLSPEC_UUID("4A03DCB9-6E17-4A39-8845-4EE7DC5331A5")
DXTSpiral;
#endif

EXTERN_C const CLSID CLSID_CrSpiralPP;

#ifdef __cplusplus

class DECLSPEC_UUID("C6A4FE81-1022-11d2-8B82-00A0C93C09B2")
CrSpiralPP;
#endif

EXTERN_C const CLSID CLSID_CrZigzag;

#ifdef __cplusplus

class DECLSPEC_UUID("E6E73D20-0C8A-11D2-A484-00C04F8EFB69")
CrZigzag;
#endif

EXTERN_C const CLSID CLSID_DXTZigzag;

#ifdef __cplusplus

class DECLSPEC_UUID("23E26328-3928-40F2-95E5-93CAD69016EB")
DXTZigzag;
#endif

EXTERN_C const CLSID CLSID_CrZigzagPP;

#ifdef __cplusplus

class DECLSPEC_UUID("1559A3C1-102B-11d2-8B82-00A0C93C09B2")
CrZigzagPP;
#endif

EXTERN_C const CLSID CLSID_CrWheel;

#ifdef __cplusplus

class DECLSPEC_UUID("5AE1DAE0-1461-11d2-A484-00C04F8EFB69")
CrWheel;
#endif

EXTERN_C const CLSID CLSID_CrWheelPP;

#ifdef __cplusplus

class DECLSPEC_UUID("FA9F6180-1464-11d2-A484-00C04F8EFB69")
CrWheelPP;
#endif

EXTERN_C const CLSID CLSID_DXTChroma;

#ifdef __cplusplus

class DECLSPEC_UUID("421516C1-3CF8-11D2-952A-00C04FA34F05")
DXTChroma;
#endif

EXTERN_C const CLSID CLSID_DXTChromaPP;

#ifdef __cplusplus

class DECLSPEC_UUID("EC7E0760-4C76-11D2-8ADE-00A0C98E6527")
DXTChromaPP;
#endif

EXTERN_C const CLSID CLSID_DXTDropShadow;

#ifdef __cplusplus

class DECLSPEC_UUID("ADC6CB86-424C-11D2-952A-00C04FA34F05")
DXTDropShadow;
#endif

EXTERN_C const CLSID CLSID_DXTDropShadowPP;

#ifdef __cplusplus

class DECLSPEC_UUID("EC7E0761-4C76-11D2-8ADE-00A0C98E6527")
DXTDropShadowPP;
#endif

EXTERN_C const CLSID CLSID_DXTCheckerBoard;

#ifdef __cplusplus

class DECLSPEC_UUID("B3EE7802-8224-4787-A1EA-F0DE16DEABD3")
DXTCheckerBoard;
#endif

EXTERN_C const CLSID CLSID_DXTCheckerBoardPP;

#ifdef __cplusplus

class DECLSPEC_UUID("CBF47525-98D2-45ea-B843-FD213D932B10")
DXTCheckerBoardPP;
#endif

EXTERN_C const CLSID CLSID_DXTRevealTrans;

#ifdef __cplusplus

class DECLSPEC_UUID("E31E87C4-86EA-4940-9B8A-5BD5D179A737")
DXTRevealTrans;
#endif

EXTERN_C const CLSID CLSID_DXTMaskFilter;

#ifdef __cplusplus

class DECLSPEC_UUID("3A04D93B-1EDD-4f3f-A375-A03EC19572C4")
DXTMaskFilter;
#endif

EXTERN_C const CLSID CLSID_DXTRedirect;

#ifdef __cplusplus

class DECLSPEC_UUID("42B07B28-2280-4937-B035-0293FB812781")
DXTRedirect;
#endif

EXTERN_C const CLSID CLSID_DXTAlphaImageLoader;

#ifdef __cplusplus

class DECLSPEC_UUID("0C7EFBDE-0303-4C6F-A4F7-31FA2BE5E397")
DXTAlphaImageLoader;
#endif

EXTERN_C const CLSID CLSID_DXTAlphaImageLoaderPP;

#ifdef __cplusplus

class DECLSPEC_UUID("8C80CE2D-850D-47DA-8ECD-55023562D167")
DXTAlphaImageLoaderPP;
#endif

EXTERN_C const CLSID CLSID_DXTRandomDissolve;

#ifdef __cplusplus

class DECLSPEC_UUID("F7F4A1B6-8E87-452F-A2D7-3077F508DBC0")
DXTRandomDissolve;
#endif

EXTERN_C const CLSID CLSID_DXTRandomBars;

#ifdef __cplusplus

class DECLSPEC_UUID("2E7700B7-27C4-437F-9FBF-1E8BE2817566")
DXTRandomBars;
#endif

EXTERN_C const CLSID CLSID_DXTRandomBarsPP;

#ifdef __cplusplus

class DECLSPEC_UUID("E3E6AE11-7FDC-40C4-AFBF-1DCEA82862CC")
DXTRandomBarsPP;
#endif

EXTERN_C const CLSID CLSID_DXTStrips;

#ifdef __cplusplus

class DECLSPEC_UUID("63A4B1FC-259A-4A5B-8129-A83B8C9E6F4F")
DXTStrips;
#endif

EXTERN_C const CLSID CLSID_DXTStripsPP;

#ifdef __cplusplus

class DECLSPEC_UUID("FEC0B7EE-7AEC-4067-9EE1-FACFB7CE9AF9")
DXTStripsPP;
#endif

EXTERN_C const CLSID CLSID_DXTMetaRoll;

#ifdef __cplusplus

class DECLSPEC_UUID("9C61F46E-0530-11D2-8F98-00C04FB92EB7")
DXTMetaRoll;
#endif

EXTERN_C const CLSID CLSID_DXTMetaRipple;

#ifdef __cplusplus

class DECLSPEC_UUID("AA0D4D03-06A3-11D2-8F98-00C04FB92EB7")
DXTMetaRipple;
#endif

EXTERN_C const CLSID CLSID_DXTMetaPageTurn;

#ifdef __cplusplus

class DECLSPEC_UUID("AA0D4D08-06A3-11D2-8F98-00C04FB92EB7")
DXTMetaPageTurn;
#endif

EXTERN_C const CLSID CLSID_DXTMetaLiquid;

#ifdef __cplusplus

class DECLSPEC_UUID("AA0D4D0A-06A3-11D2-8F98-00C04FB92EB7")
DXTMetaLiquid;
#endif

EXTERN_C const CLSID CLSID_DXTMetaCenterPeel;

#ifdef __cplusplus

class DECLSPEC_UUID("AA0D4D0C-06A3-11D2-8F98-00C04FB92EB7")
DXTMetaCenterPeel;
#endif

EXTERN_C const CLSID CLSID_DXTMetaPeelSmall;

#ifdef __cplusplus

class DECLSPEC_UUID("AA0D4D0E-06A3-11D2-8F98-00C04FB92EB7")
DXTMetaPeelSmall;
#endif

EXTERN_C const CLSID CLSID_DXTMetaPeelPiece;

#ifdef __cplusplus

class DECLSPEC_UUID("AA0D4D10-06A3-11D2-8F98-00C04FB92EB7")
DXTMetaPeelPiece;
#endif

EXTERN_C const CLSID CLSID_DXTMetaPeelSplit;

#ifdef __cplusplus

class DECLSPEC_UUID("AA0D4D12-06A3-11D2-8F98-00C04FB92EB7")
DXTMetaPeelSplit;
#endif

EXTERN_C const CLSID CLSID_DXTMetaWater;

#ifdef __cplusplus

class DECLSPEC_UUID("107045C5-06E0-11D2-8D6D-00C04F8EF8E0")
DXTMetaWater;
#endif

EXTERN_C const CLSID CLSID_DXTMetaLightWipe;

#ifdef __cplusplus

class DECLSPEC_UUID("107045C8-06E0-11D2-8D6D-00C04F8EF8E0")
DXTMetaLightWipe;
#endif

EXTERN_C const CLSID CLSID_DXTMetaRadialScaleWipe;

#ifdef __cplusplus

class DECLSPEC_UUID("107045CA-06E0-11D2-8D6D-00C04F8EF8E0")
DXTMetaRadialScaleWipe;
#endif

EXTERN_C const CLSID CLSID_DXTMetaWhiteOut;

#ifdef __cplusplus

class DECLSPEC_UUID("107045CC-06E0-11D2-8D6D-00C04F8EF8E0")
DXTMetaWhiteOut;
#endif

EXTERN_C const CLSID CLSID_DXTMetaTwister;

#ifdef __cplusplus

class DECLSPEC_UUID("107045CF-06E0-11D2-8D6D-00C04F8EF8E0")
DXTMetaTwister;
#endif

EXTERN_C const CLSID CLSID_DXTMetaBurnFilm;

#ifdef __cplusplus

class DECLSPEC_UUID("107045D1-06E0-11D2-8D6D-00C04F8EF8E0")
DXTMetaBurnFilm;
#endif

EXTERN_C const CLSID CLSID_DXTMetaJaws;

#ifdef __cplusplus

class DECLSPEC_UUID("2A54C904-07AA-11D2-8D6D-00C04F8EF8E0")
DXTMetaJaws;
#endif

EXTERN_C const CLSID CLSID_DXTMetaColorFade;

#ifdef __cplusplus

class DECLSPEC_UUID("2A54C908-07AA-11D2-8D6D-00C04F8EF8E0")
DXTMetaColorFade;
#endif

EXTERN_C const CLSID CLSID_DXTMetaFlowMotion;

#ifdef __cplusplus

class DECLSPEC_UUID("2A54C90B-07AA-11D2-8D6D-00C04F8EF8E0")
DXTMetaFlowMotion;
#endif

EXTERN_C const CLSID CLSID_DXTMetaVacuum;

#ifdef __cplusplus

class DECLSPEC_UUID("2A54C90D-07AA-11D2-8D6D-00C04F8EF8E0")
DXTMetaVacuum;
#endif

EXTERN_C const CLSID CLSID_DXTMetaGriddler;

#ifdef __cplusplus

class DECLSPEC_UUID("2A54C911-07AA-11D2-8D6D-00C04F8EF8E0")
DXTMetaGriddler;
#endif

EXTERN_C const CLSID CLSID_DXTMetaGriddler2;

#ifdef __cplusplus

class DECLSPEC_UUID("2A54C913-07AA-11D2-8D6D-00C04F8EF8E0")
DXTMetaGriddler2;
#endif

EXTERN_C const CLSID CLSID_DXTMetaThreshold;

#ifdef __cplusplus

class DECLSPEC_UUID("2A54C915-07AA-11D2-8D6D-00C04F8EF8E0")
DXTMetaThreshold;
#endif

EXTERN_C const CLSID CLSID_DXTMetaWormHole;

#ifdef __cplusplus

class DECLSPEC_UUID("0E6AE022-0C83-11D2-8CD4-00104BC75D9A")
DXTMetaWormHole;
#endif

EXTERN_C const CLSID CLSID_DXTGlow;

#ifdef __cplusplus

class DECLSPEC_UUID("9F8E6421-3D9B-11D2-952A-00C04FA34F05")
DXTGlow;
#endif

EXTERN_C const CLSID CLSID_DXTShadow;

#ifdef __cplusplus

class DECLSPEC_UUID("E71B4063-3E59-11D2-952A-00C04FA34F05")
DXTShadow;
#endif

EXTERN_C const CLSID CLSID_DXTAlpha;

#ifdef __cplusplus

class DECLSPEC_UUID("ADC6CB82-424C-11D2-952A-00C04FA34F05")
DXTAlpha;
#endif

EXTERN_C const CLSID CLSID_DXTWave;

#ifdef __cplusplus

class DECLSPEC_UUID("ADC6CB88-424C-11D2-952A-00C04FA34F05")
DXTWave;
#endif

EXTERN_C const CLSID CLSID_DXTLight;

#ifdef __cplusplus

class DECLSPEC_UUID("F9EFBEC2-4302-11D2-952A-00C04FA34F05")
DXTLight;
#endif

EXTERN_C const CLSID CLSID_DXTAlphaPP;

#ifdef __cplusplus

class DECLSPEC_UUID("D687A7E0-4BA4-11D2-8ADE-00A0C98E6527")
DXTAlphaPP;
#endif

EXTERN_C const CLSID CLSID_DXTGlowPP;

#ifdef __cplusplus

class DECLSPEC_UUID("EC7E0764-4C76-11D2-8ADE-00A0C98E6527")
DXTGlowPP;
#endif

EXTERN_C const CLSID CLSID_DXTShadowPP;

#ifdef __cplusplus

class DECLSPEC_UUID("EC7E0765-4C76-11D2-8ADE-00A0C98E6527")
DXTShadowPP;
#endif

EXTERN_C const CLSID CLSID_DXTWavePP;

#ifdef __cplusplus

class DECLSPEC_UUID("F12456C0-4C9E-11D2-8ADE-00A0C98E6527")
DXTWavePP;
#endif

EXTERN_C const CLSID CLSID_DXTLightPP;

#ifdef __cplusplus

class DECLSPEC_UUID("694AF25F-124D-11d3-91D5-00C04F8EFB69")
DXTLightPP;
#endif

EXTERN_C const CLSID CLSID_DXTMotionBlur;

#ifdef __cplusplus

class DECLSPEC_UUID("DD13DE77-D3BA-42D4-B5C6-7745FA4E2D4B")
DXTMotionBlur;
#endif

EXTERN_C const CLSID CLSID_DXTMotionBlurPP;

#ifdef __cplusplus

class DECLSPEC_UUID("926433E1-7F8F-4BC6-BEC4-8C126C6B7DC4")
DXTMotionBlurPP;
#endif

EXTERN_C const CLSID CLSID_DXTMatrix;

#ifdef __cplusplus

class DECLSPEC_UUID("4ABF5A06-5568-4834-BEE3-327A6D95A685")
DXTMatrix;
#endif

EXTERN_C const CLSID CLSID_DXTMatrixPP;

#ifdef __cplusplus

class DECLSPEC_UUID("C591103A-B3A8-4D47-A3F7-2AEEE4B8013F")
DXTMatrixPP;
#endif

EXTERN_C const CLSID CLSID_DXTICMFilter;

#ifdef __cplusplus

class DECLSPEC_UUID("A1BFB370-5A9F-4429-BB72-B13E2FEAEDEF")
DXTICMFilter;
#endif

EXTERN_C const CLSID CLSID_DXTICMFilterPP;

#ifdef __cplusplus

class DECLSPEC_UUID("1958FB12-31E6-47E5-AA49-B23D12C853E6")
DXTICMFilterPP;
#endif
#endif /* __DXTMSFTLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  HDC_UserSize(     unsigned long *, unsigned long            , HDC * ); 
unsigned char * __RPC_USER  HDC_UserMarshal(  unsigned long *, unsigned char *, HDC * ); 
unsigned char * __RPC_USER  HDC_UserUnmarshal(unsigned long *, unsigned char *, HDC * ); 
void                      __RPC_USER  HDC_UserFree(     unsigned long *, HDC * ); 

unsigned long             __RPC_USER  LPSAFEARRAY_UserSize(     unsigned long *, unsigned long            , LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserMarshal(  unsigned long *, unsigned char *, LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserUnmarshal(unsigned long *, unsigned char *, LPSAFEARRAY * ); 
void                      __RPC_USER  LPSAFEARRAY_UserFree(     unsigned long *, LPSAFEARRAY * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long *, unsigned long            , VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal(  unsigned long *, unsigned char *, VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal(unsigned long *, unsigned char *, VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long *, VARIANT * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\Dxsurfb.Cpp ===
/*******************************************************************************
* DXSurfB.cpp *
*------------*
*   Description:
*    This module contains the CDXBaseSurface implementaion.
*-------------------------------------------------------------------------------
*  Created By: RAL                                  Date: 02/12/1998
*  Copyright (C) 1998 Microsoft Corporation
*  All Rights Reserved
*
*-------------------------------------------------------------------------------
*  Revisions:
*
*******************************************************************************/
//--- Additional includes
#include <DXTrans.h>
#include "DXSurfB.h"
#include "new.h"

CDXBaseSurface::CDXBaseSurface() :
    m_ulLocks(0),
    m_ulThreadsWaiting(0),
    m_Height(0),
    m_Width(0),
    m_pFreePtr(NULL),
    m_dwStatusFlags(DXSURF_READONLY),
    m_dwAppData(0)
{
    m_hSemaphore = CreateSemaphore(NULL, 0, MAXLONG, NULL);
    m_ulNumInRequired = m_ulMaxInputs = 0;
}

HRESULT CDXBaseSurface::FinalConstruct()
{
    return m_hSemaphore ? S_OK : E_OUTOFMEMORY;
}

void CDXBaseSurface::FinalRelease()
{
    while (m_pFreePtr)
    {
        CDXBaseARGBPtr *pNext = m_pFreePtr->m_pNext;
        DeleteARGBPointer(m_pFreePtr);
        m_pFreePtr = pNext;
    }
    if (m_hSemaphore)
    {
        CloseHandle(m_hSemaphore);
    }
}

STDMETHODIMP CDXBaseSurface::GetGenerationId(ULONG *pGenerationId)
{
    if (DXIsBadWritePtr(pGenerationId, sizeof(*pGenerationId)))
    {
        return E_POINTER;
    }
    Lock();
    OnUpdateGenerationId();
    *pGenerationId = m_dwGenerationId;
    Unlock();
    return S_OK;
}

STDMETHODIMP CDXBaseSurface::IncrementGenerationId(BOOL /*bRefresh */)
{
    Lock();
    m_dwGenerationId++;
    Unlock();
    return S_OK;
}


STDMETHODIMP CDXBaseSurface::GetObjectSize(ULONG *pcbSize)
{
    HRESULT hr = S_OK;
    if (DXIsBadWritePtr(pcbSize, sizeof(*pcbSize)))
    {
        hr = E_POINTER;
    }
    else
    {
	Lock();
        *pcbSize = OnGetObjectSize();
        Unlock();
    }
    return hr;
}

STDMETHODIMP CDXBaseSurface::MapBoundsIn2Out
    (const DXBNDS *pInBounds, ULONG ulNumInBnds, ULONG /*ulOutIndex*/, DXBNDS *pOutBounds)
{
    HRESULT hr = S_OK;
    if (DXIsBadWritePtr(pOutBounds, sizeof(*pOutBounds)))
    {
        hr = E_POINTER;
    }
    else
    {
        Lock();
        new(pOutBounds) CDXDBnds(m_Width, m_Height);
        Unlock();
    }
    return hr;    
}

STDMETHODIMP CDXBaseSurface::InitSurface(IUnknown *pDirectDraw,
                                         const DDSURFACEDESC * pDDSurfaceDesc,
                                         const GUID * pFormatId,
                                         const DXBNDS *pBounds,
                                         DWORD dwFlags)
{
    HRESULT hr = S_OK;
    if (pDDSurfaceDesc || DXIsBadReadPtr(pBounds, sizeof(*pBounds)) || pBounds->eType != DXBT_DISCRETE)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        _EnterCritWith0PtrLocks();
        if (m_Width)
        {
            hr = HRESULT_FROM_WIN32(ERROR_ALREADY_INITIALIZED);
        }
        else
        {
            CDXDBnds *pbnds = (CDXDBnds *)pBounds;
            hr = OnSetSize(pbnds->Width(), pbnds->Height());
        }
        Unlock();
    }
    return hr;
}


STDMETHODIMP CDXBaseSurface::GetPixelFormat(GUID *pFormat, DXSAMPLEFORMATENUM *pSampleFormatEnum)
{
    HRESULT hr = S_OK;
    if (DX_IS_BAD_OPTIONAL_WRITE_PTR(pFormat) ||
        DX_IS_BAD_OPTIONAL_WRITE_PTR(pSampleFormatEnum))
    {
        hr = E_POINTER;
    }
    else
    {
        if (pFormat) *pFormat = SurfaceCLSID();
        if (pSampleFormatEnum) *pSampleFormatEnum = SampleFormatEnum();
    }
    return hr;
}

STDMETHODIMP CDXBaseSurface::GetBounds(DXBNDS* pBounds)
{
    HRESULT hr = S_OK;
    if (DXIsBadWritePtr(pBounds, sizeof(*pBounds)))
    {
        hr = E_POINTER;
    }
    else
    {
        Lock();
        new(pBounds) CDXDBnds(m_Width, m_Height);
        Unlock();
    }
    return hr;    
} 

STDMETHODIMP CDXBaseSurface::GetStatusFlags(DWORD* pdwStatusFlags)
{
    HRESULT hr = S_OK;
    if (DXIsBadWritePtr(pdwStatusFlags, sizeof(*pdwStatusFlags)))
    {
        hr = E_POINTER;
    }
    else
    {
        Lock();
        *pdwStatusFlags = m_dwStatusFlags;
        Unlock();
    }
    return hr;    
} 

STDMETHODIMP CDXBaseSurface::SetStatusFlags(DWORD dwStatusFlags )
{
    _EnterCritWith0PtrLocks();
    // BUGBUG -- Think about this
    m_dwStatusFlags = dwStatusFlags | DXSURF_READONLY;
    m_dwGenerationId++;
    Unlock();
    return S_OK;
} 

STDMETHODIMP CDXBaseSurface::GetDirectDrawSurface(REFIID riid, void **ppSurface)
{
    return E_NOTIMPL;
}

STDMETHODIMP CDXBaseSurface::LockSurface(const DXBNDS *pBounds, ULONG ulTimeOut,
                                         DWORD dwFlags, REFIID riid, void **ppPointer,
                                         DWORD * pGenerationId)
{
    HRESULT hr = S_OK;
    BOOL bMPLockOnly = m_bInMultiThreadWorkProc;

    if (!bMPLockOnly) Lock();
    m_MPWorkProcCrit.Lock();

    if (m_Width == 0)
    {
        hr = E_FAIL;    // BUGBUG -- What code??
    }
    else
    {
        RECT r;
        r.top = r.left = 0;
        r.right = m_Width;
        r.bottom = m_Height;
        if (pBounds)
        {
            if (pBounds->eType != DXBT_DISCRETE)
            {
                hr = DXTERR_INVALID_BOUNDS;
            }
            else
            {
                ((CDXDBnds *)pBounds)->GetXYRect(r);
                if (r.top < 0 || r.left < 0 || (ULONG)r.right > m_Width || (ULONG)r.bottom > m_Height || r.bottom <= r.top || r.right <= r.left)
                {
                    hr = DXTERR_INVALID_BOUNDS;
                }
            }
        }
        if (SUCCEEDED(hr))
        {
            CDXBaseARGBPtr * pPtr = m_pFreePtr;
            if (pPtr)
            {
                m_pFreePtr = pPtr->m_pNext;
            }
            else
            {
                hr = CreateARGBPointer(this, &pPtr);
            }
            if (SUCCEEDED(hr))
            {
                hr = pPtr->InitFromLock(r, ulTimeOut, dwFlags, riid, ppPointer);
                if (pGenerationId)
                {
                    if (DXIsBadWritePtr(pGenerationId, sizeof(*pGenerationId)))
                    {
                        hr = E_POINTER;
                    }
                    else
                    {
                        *pGenerationId = m_dwGenerationId;
                    }
                }
                if (SUCCEEDED(hr))
                {
                    m_ulLocks++;
                }
                else
                {
                    pPtr->m_pNext = m_pFreePtr;
                    m_pFreePtr = pPtr;
                }
            }
        }
    }
    m_MPWorkProcCrit.Unlock();
    if (!bMPLockOnly) Unlock();
    return hr;
}

void CDXBaseSurface::_InternalUnlock(CDXBaseARGBPtr *pPtrToUnlock)
{
    BOOL bMPLockOnly = m_bInMultiThreadWorkProc;

    if (!bMPLockOnly) Lock();
    m_MPWorkProcCrit.Lock();
    pPtrToUnlock->m_pNext = m_pFreePtr;
    m_pFreePtr = pPtrToUnlock;
    m_ulLocks--;
    if ((m_ulLocks == 0) && m_ulThreadsWaiting)
    {
        ReleaseSemaphore(m_hSemaphore, m_ulThreadsWaiting, NULL);
        m_ulThreadsWaiting = 0;
    }
    m_MPWorkProcCrit.Unlock();
    if (!bMPLockOnly) Unlock();

    IUnknown *punkOuter = GetControllingUnknown();
    punkOuter->Release();   // Release pointer's reference to us
                            // which could kill us!  Don't touch
                            // any members after this point.
}

//
//  Picking interface needs to test the appropriate point for hit testing
//
HRESULT CDXBaseSurface::OnSurfacePick(const CDXDBnds & OutPoint, ULONG & ulInputIndex, CDXDVec & InVec)
{
    HRESULT hr;
    IDXARGBReadPtr *pPtr;
    hr = LockSurface(&OutPoint, m_ulLockTimeOut, DXLOCKF_READ, 
                     IID_IDXARGBReadPtr, (void **)&pPtr, NULL);
    if( SUCCEEDED(hr) )
    {
        DXPMSAMPLE val;
        pPtr->UnpackPremult(&val, 1, FALSE);
        pPtr->Release();
        hr = val.Alpha ? DXT_S_HITOUTPUT : S_FALSE;
    }
    else
    {
        if (hr == DXTERR_INVALID_BOUNDS) hr = S_FALSE;
    }
    return hr;
}

/*****************************************************************************
* RegisterSurface (STATIC member function)
*-----------------------------------------------------------------------------
*   Description:
*-----------------------------------------------------------------------------
*   Created By: RAL                                 Date: 12/10/97
*-----------------------------------------------------------------------------
*   Parameters:
*****************************************************************************/
HRESULT CDXBaseSurface::
RegisterSurface(REFCLSID rcid, int ResourceId, ULONG cCatImpl, const CATID * pCatImpl,
                ULONG cCatReq, const CATID * pCatReq, BOOL bRegister)
{
    HRESULT hr = bRegister ? _Module.UpdateRegistryFromResource(ResourceId, bRegister) : S_OK;
    if (SUCCEEDED(hr))
    {
        CComPtr<ICatRegister> pCatRegister;
        HRESULT hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr, NULL, CLSCTX_ALL, IID_ICatRegister, (void **)&pCatRegister);
        if (SUCCEEDED(hr))
        {
            if (bRegister)
            {
                hr = pCatRegister->RegisterClassImplCategories(rcid, cCatImpl, (CATID *)pCatImpl);
                if (SUCCEEDED(hr) && cCatReq && pCatReq) {
                    hr = pCatRegister->RegisterClassReqCategories(rcid, cCatReq, (CATID *)pCatReq);
                }
            } 
            else
            {
                pCatRegister->UnRegisterClassImplCategories(rcid, cCatImpl, (CATID *)pCatImpl);
                if (cCatReq && pCatReq)
                {
                    pCatRegister->UnRegisterClassReqCategories(rcid, cCatReq, (CATID *)pCatReq);
                }
            }
        }
    }
    if ((!bRegister) && SUCCEEDED(hr)) 
    { 
        _Module.UpdateRegistryFromResource(ResourceId, bRegister);
    }
    return hr;
}

//
//  CDXBaseARGBPtr
//
STDMETHODIMP CDXBaseARGBPtr::QueryInterface(REFIID riid, void ** ppv)
{
    if (IsEqualGUID(riid, IID_IUnknown) ||
        IsEqualGUID(riid, IID_IDXARGBReadPtr))
    {
        *ppv = (IDXARGBReadPtr *)this;
        m_ulRefCount++;
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}


ULONG STDMETHODCALLTYPE CDXBaseARGBPtr::AddRef()
{
    return ++m_ulRefCount;
}

ULONG STDMETHODCALLTYPE CDXBaseARGBPtr::Release()
{
    --m_ulRefCount;
    ULONG c = m_ulRefCount;
    if (c == 0)
    {
        m_pSurface->_InternalUnlock(this);  // Don't touch members after this call.
    }
    return c;
}

HRESULT STDMETHODCALLTYPE CDXBaseARGBPtr::GetSurface(REFIID riid, void **ppSurface)
{
    return m_pSurface->GetControllingUnknown()->QueryInterface(riid, ppSurface);
}


DXSAMPLEFORMATENUM STDMETHODCALLTYPE CDXBaseARGBPtr::GetNativeType(DXNATIVETYPEINFO *pInfo)
{
    if (pInfo)
    {
        memset(pInfo, 0, sizeof(pInfo));
    }
    return m_pSurface->SampleFormatEnum();
}


void STDMETHODCALLTYPE CDXBaseARGBPtr::Move(long cSamples)
{
    m_FillInfo.x += cSamples;
    //--- Moving one column past the end is okay
    _ASSERT((long)m_FillInfo.x <= m_LockedRect.right);
}

void STDMETHODCALLTYPE CDXBaseARGBPtr::MoveToRow(ULONG y)
{
    m_FillInfo.x = m_LockedRect.left;
    m_FillInfo.y = y + m_LockedRect.top;
    _ASSERT((long)m_FillInfo.y < m_LockedRect.bottom);
}

void STDMETHODCALLTYPE CDXBaseARGBPtr::MoveToXY(ULONG x, ULONG y)
{
    m_FillInfo.x = x + m_LockedRect.left;
    m_FillInfo.y = y + m_LockedRect.top;
    //--- Moving one column past the end is okay
    _ASSERT((long)m_FillInfo.x <= m_LockedRect.right);
    _ASSERT((long)m_FillInfo.y < m_LockedRect.bottom);
}

ULONG STDMETHODCALLTYPE CDXBaseARGBPtr::MoveAndGetRunInfo(ULONG Row, const DXRUNINFO ** ppInfo)
{
    m_FillInfo.x = m_LockedRect.left;
    m_FillInfo.y = Row + m_LockedRect.top;
    _ASSERT((long)m_FillInfo.y < m_LockedRect.bottom);
    *ppInfo = &m_RunInfo;
    return 1;
}

DXSAMPLE *STDMETHODCALLTYPE CDXBaseARGBPtr::Unpack(DXSAMPLE *pSamples, ULONG cSamples, BOOL bMove)
{
    m_FillInfo.pSamples = pSamples;
    m_FillInfo.cSamples = cSamples;
    m_FillInfo.bPremult = false;
    FillSamples(m_FillInfo);
    if (bMove) m_FillInfo.x += cSamples;
    return pSamples;
}

DXPMSAMPLE *STDMETHODCALLTYPE CDXBaseARGBPtr::UnpackPremult(DXPMSAMPLE *pSamples, ULONG cSamples, BOOL bMove)
{
    m_FillInfo.pSamples = pSamples;
    m_FillInfo.cSamples = cSamples;
    m_FillInfo.bPremult = true;
    FillSamples(m_FillInfo);
    if (bMove) m_FillInfo.x += cSamples;
    return pSamples;
}

void STDMETHODCALLTYPE CDXBaseARGBPtr::UnpackRect(const DXPACKEDRECTDESC *pDesc)
{
    DXPtrFillInfo FillInfo;
    FillInfo.pSamples = pDesc->pSamples;
    FillInfo.cSamples = pDesc->rect.right - pDesc->rect.left;
    FillInfo.x = pDesc->rect.left + m_LockedRect.left;
    FillInfo.bPremult = pDesc->bPremult;
    ULONG YLimit = pDesc->rect.bottom + m_LockedRect.top;
    for (FillInfo.y = pDesc->rect.top + m_LockedRect.top;
         FillInfo.y < YLimit;
         FillInfo.y++)
    {
        FillSamples(FillInfo);
        FillInfo.pSamples += FillInfo.cSamples;
    }
}

HRESULT CDXBaseARGBPtr::InitFromLock(const RECT & rect, ULONG /*ulTimeOut*/, DWORD dwLockFlags, REFIID riid, void ** ppv)
{
    HRESULT hr = S_OK;
    if (dwLockFlags & DXLOCKF_READWRITE)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        m_LockedRect = rect;
        m_RunInfo.Count = rect.right - rect.left;
        if (m_pSurface->SampleFormatEnum() & DXPF_TRANSPARENCY)
        {
            m_RunInfo.Type = DXRUNTYPE_UNKNOWN;
        }
        else
        {
            m_RunInfo.Type = DXRUNTYPE_OPAQUE;
        }
        m_FillInfo.x = rect.left;
        m_FillInfo.y = rect.top;
        hr = QueryInterface(riid, ppv);
        if (SUCCEEDED(hr))
        {
            m_pSurface->GetControllingUnknown()->AddRef();
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\Dxsurfb.h ===
/*******************************************************************************
* DXSurfB.h *
*----------*
*   Description:
*       This is the header file for the CDXBaseSurface implementation. It is
*   used as a base class to implement read-only procedural DXSurfaces.
*-------------------------------------------------------------------------------
*  Created By: RAL                                  Date: 02/12/1998
*  Copyright (C) 1998 Microsoft Corporation
*  All Rights Reserved
*
*-------------------------------------------------------------------------------
*  Revisions:
*
*******************************************************************************/

#ifndef __DXSurfB_H__
#define __DXSurfB_H__

#include "dtbase.h"

class CDXBaseSurface;
class CDXBaseARGBPtr;

class ATL_NO_VTABLE CDXBaseSurface :
    public CDXBaseNTo1, 
    public IDXSurface,
    public IDXSurfaceInit
{
    /*=== ATL Setup ===*/
    public:
        BEGIN_COM_MAP(CDXBaseSurface)
        COM_INTERFACE_ENTRY(IDXSurface)
        COM_INTERFACE_ENTRY(IDXSurfaceInit)
        COM_INTERFACE_ENTRY_CHAIN(CDXBaseNTo1)
        END_COM_MAP()

    DECLARE_GET_CONTROLLING_UNKNOWN()

    /*=== Member Data ===*/
    public:
        ULONG           m_Height;
        ULONG           m_Width;
        DWORD           m_dwStatusFlags;
        HANDLE          m_hSemaphore;
        ULONG           m_ulLocks;
        ULONG           m_ulThreadsWaiting;
        CDXBaseARGBPtr  *m_pFreePtr;
        DWORD_PTR       m_dwAppData;
        CComAutoCriticalSection m_MPWorkProcCrit;   // See comments in LockSurface for details

        CDXBaseSurface();
        HRESULT FinalConstruct();
        void FinalRelease();

        //
        //  IDXBaseObject
        //
        STDMETHODIMP GetGenerationId(ULONG *pGenId);
        STDMETHODIMP IncrementGenerationId(BOOL bRefresh);
        STDMETHODIMP GetObjectSize(ULONG *pulze);

        //
        //  Overridden methods of DXTransform
        //
        STDMETHODIMP MapBoundsIn2Out(const DXBNDS *pInBounds, ULONG ulNumInBnds,
                                     ULONG /*ulOutIndex*/, DXBNDS *pOutBounds );

        //
        //  IDXSurfaceInit
        //
        STDMETHODIMP InitSurface(IUnknown *pDirectDraw,
                                 const DDSURFACEDESC * pDDSurfaceDesc,
                                 const GUID * pFormatId,
                                 const DXBNDS *pBounds,
                                 DWORD dwFlags);
        //
        //  IDXSurface methods
        //
        STDMETHODIMP GetPixelFormat(GUID *pFormat, DXSAMPLEFORMATENUM *pSampleEnum);
        STDMETHODIMP GetBounds(DXBNDS *pBounds);
        STDMETHODIMP GetStatusFlags(DWORD * pdwStatusFlags);
        STDMETHODIMP SetStatusFlags(DWORD dwStatusFlags);
        STDMETHODIMP GetDirectDrawSurface(REFIID riid, void **ppSurface);
        STDMETHODIMP LockSurface(const DXBNDS *pBounds, ULONG ulTimeOut, DWORD dwFlags,
                                 REFIID riid, void **ppPointer, DWORD * pGenerationId);
        STDMETHODIMP SetAppData(DWORD_PTR dwAppData)
        {
            m_dwAppData = dwAppData;
            return S_OK;
        }
        STDMETHODIMP GetAppData(DWORD_PTR *pdwAppData)
        {
            if (DXIsBadWritePtr(pdwAppData, sizeof(*pdwAppData)))
            {
                return E_POINTER;
            }
            *pdwAppData = m_dwAppData;
            return S_OK;
        }


        //
        //  These methods aren't supported by procedural surfaces...
        //
        STDMETHODIMP GetColorKey(DXSAMPLE *pColorKey)
        {
            return E_NOTIMPL;
        }

        STDMETHODIMP SetColorKey(DXSAMPLE pColorKey)
        {
            return E_NOTIMPL;
        }

        STDMETHODIMP LockSurfaceDC(const DXBNDS *pBounds, ULONG ulTimeOut, DWORD dwFlags, IDXDCLock **ppDXLock)
        {
            return E_NOTIMPL;
        }

        //
        //  Surfaces should override this.
        //
        virtual ULONG OnGetObjectSize(void) { return sizeof(*this); }

        //
        //  This work procedure can be overridden by the derived class to improve performance
        //  or execution of the transform by directly producing data in large blocks if desired.
        //
        virtual HRESULT WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL* pbContinueProcessing)
        {
            return DXBitBlt(OutputSurface(), WI.OutputBnds, this, WI.DoBnds, m_dwBltFlags, m_ulLockTimeOut);
        }

        //
        //  Pick interface needs to test procedural surface.
        //
        virtual HRESULT OnSurfacePick(const CDXDBnds & OutPoint, ULONG & ulInputIndex, CDXDVec & InVec);

        //
        //  Helper functions
        //

        //  _EnterCritWith0PtrLocks()
        //
        //  This function is similar to calling Lock() except that it will wait until there
        //  are no pointers to the surface before returning.  This should be used whenever you
        //  are going to change the state of a surface, for example the size or some other
        //  property that the read pointers rely on.
        //
        //  WARNING:  You must be sure that one of the following is true:
        //      1) The objects critical section has NOT been taken prior to calling this function
        //   or 2) There are no pointers to the surface taken prior to calling this function.
        //
        //  Case 2 is useful in nested function calls.  If the outer function has already used this
        //  function to enter the critical section, then it is OK to use it on the inner nested
        //  function.  If the object's lock is taken, but there are outstanding pointers, YOU WILL DEADLOCK!
        //
        inline void _EnterCritWith0PtrLocks(void)
        {
            while (TRUE)
            {
                Lock();
                if (m_ulLocks == 0) break;
                m_ulThreadsWaiting++;
                Unlock();
                WaitForSingleObject(m_hSemaphore, INFINITE);
            }
        }
        //
        //  Virtual functions derived class MUST override
        //
        virtual const GUID & SurfaceCLSID() = 0;
        virtual HRESULT CreateARGBPointer(CDXBaseSurface * pSurface, CDXBaseARGBPtr ** ppPtr) = 0;
        virtual void DeleteARGBPointer(CDXBaseARGBPtr *pPtr) = 0;
    
        //
        //  Class may override this virtual function to return a more accurate enum
        //  for example, no transparency or translucency.
        //
        virtual DXSAMPLEFORMATENUM SampleFormatEnum()
        {
            return (DXSAMPLEFORMATENUM)(DXPF_NONSTANDARD | DXPF_TRANSPARENCY | DXPF_TRANSLUCENCY);
        }

        //
        //  Class may override this virtual function to perform necessary computations
        //  when the size of the surface changes.  The base class will only call this
        //  function from InitSurface.  You may choose to call it from other interfaces
        //  you implement, for example IDXTScaleOutput.
        //
        //  This function will be called with the critical section taken and 0 outstanding
        //  surface pointers (_EnterCritWith0PtrLocks).
        //  
        virtual HRESULT OnSetSize(ULONG Width, ULONG Height)
        {
            if (m_Width != Width || m_Height != Height)
            {
                m_Width = Width;
                m_Height = Height;
                m_dwGenerationId++;
            }
            return S_OK;
        }

        //
        //  Internal functions for base class
        //
        void _InternalUnlock(CDXBaseARGBPtr *pPtrToUnlock);

        //
        //  Static member function for registering surface
        //
        static HRESULT RegisterSurface(REFCLSID rcid, int ResourceId, ULONG cCatImpl, const CATID * pCatImpl,
                                       ULONG cCatReq, const CATID * pCatReq, BOOL bRegister);
};

struct DXPtrFillInfo
{
    DXBASESAMPLE *  pSamples;
    ULONG           cSamples;
    ULONG           x;
    ULONG           y;
    BOOL            bPremult;
};


class CDXBaseARGBPtr : public IDXARGBReadPtr
{
public:
    CDXBaseARGBPtr    * m_pNext;
    CDXBaseSurface    * m_pSurface;
    ULONG               m_ulRefCount;
    DXPtrFillInfo       m_FillInfo;
    RECT                m_LockedRect;
    DXRUNINFO           m_RunInfo;
    
    CDXBaseARGBPtr(CDXBaseSurface *pSurface) :
        m_pSurface(pSurface),
        m_pNext(NULL),
        m_ulRefCount(0) {}

    //
    //  IUnknown
    //
    STDMETHODIMP QueryInterface(REFIID riid, void ** ppv);
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();
    //
    //  IDXARGBReadPtr
    //
    HRESULT STDMETHODCALLTYPE GetSurface(REFIID riid, void **ppSurface);
    DXSAMPLEFORMATENUM STDMETHODCALLTYPE GetNativeType(DXNATIVETYPEINFO *pInfo);
    void STDMETHODCALLTYPE Move(long cSamples);
    void STDMETHODCALLTYPE MoveToRow(ULONG y);
    void STDMETHODCALLTYPE MoveToXY(ULONG x, ULONG y);
    ULONG STDMETHODCALLTYPE MoveAndGetRunInfo(ULONG Row, const DXRUNINFO ** ppInfo);
    DXSAMPLE *STDMETHODCALLTYPE Unpack(DXSAMPLE *pSamples, ULONG cSamples, BOOL bMove);
    DXPMSAMPLE *STDMETHODCALLTYPE UnpackPremult(DXPMSAMPLE *pSamples, ULONG cSamples, BOOL bMove);
    void STDMETHODCALLTYPE UnpackRect(const DXPACKEDRECTDESC *pDesc);

    //
    //  Virtual function derived class MUST override
    //
    virtual void FillSamples(const DXPtrFillInfo & FillInfo) = 0;

    //
    //  Virtual functions derived class MAY want to override (but you will need to call the base class too)
    //
    virtual HRESULT InitFromLock(const RECT & rect, ULONG ulTimeOut, DWORD dwLockFlags, REFIID riid, void ** ppv);
};

//=== Macro Definitions ============================================

#define DECLARE_REGISTER_DX_SURFACE(id)\
    static HRESULT WINAPI UpdateRegistry(BOOL bRegister) \
        { \
            CATID cat[2]; \
            cat[0] = CATID_DXSurface; \
            cat[1] = CATID_DXImageTransform; \
            return RegisterSurface(GetObjectCLSID(), (id), 2, cat, 0, NULL, bRegister); \
        } 

#define DECLARE_REGISTER_DX_AUTHORING_SURFACE(id)\
    static HRESULT WINAPI UpdateRegistry(BOOL bRegister) \
        { \
            CATID cat[3]; \
            cat[0] = CATID_DXSurface; \
            cat[1] = CATID_DXImageTransform; \
            cat[2] = CATID_DXAuthoringTransform; \
            return RegisterSurface(GetObjectCLSID(), (id), 3, cat, 0, NULL, bRegister); \
        } 

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\DxTransGuid.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0328 */
/* Compiler settings for dxtrans.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IDXBaseObject,0x17B59B2B,0x9CC8,0x11d1,0x90,0x53,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXTransformFactory,0x6A950B2B,0xA971,0x11d1,0x81,0xC8,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(IID, IID_IDXTransform,0x30A5FB78,0xE11F,0x11d1,0x90,0x64,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXSurfacePick,0x30A5FB79,0xE11F,0x11d1,0x90,0x64,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXTBindHost,0xD26BCE55,0xE9DC,0x11d1,0x90,0x66,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXTaskManager,0x254DBBC1,0xF922,0x11d0,0x88,0x3A,0x3C,0x8B,0x00,0xC1,0x00,0x00);


MIDL_DEFINE_GUID(IID, IID_IDXSurfaceFactory,0x144946F5,0xC4D4,0x11d1,0x81,0xD1,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(IID, IID_IDXSurfaceModifier,0x9EA3B637,0xC37D,0x11d1,0x90,0x5E,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXSurface,0xB39FD73F,0xE139,0x11d1,0x90,0x65,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXSurfaceInit,0x9EA3B639,0xC37D,0x11d1,0x90,0x5E,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXARGBSurfaceInit,0x9EA3B63A,0xC37D,0x11d1,0x90,0x5E,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXARGBReadPtr,0xEAAAC2D6,0xC290,0x11d1,0x90,0x5D,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXARGBReadWritePtr,0xEAAAC2D7,0xC290,0x11d1,0x90,0x5D,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXDCLock,0x0F619456,0xCF39,0x11d1,0x90,0x5E,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXTScaleOutput,0xB2024B50,0xEE77,0x11d1,0x90,0x66,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXGradient,0xB2024B51,0xEE77,0x11d1,0x90,0x66,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXTScale,0xB39FD742,0xE139,0x11d1,0x90,0x65,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXEffect,0xE31FB81B,0x1335,0x11d1,0x81,0x89,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(IID, IID_IDXLookupTable,0x01BAFC7F,0x9E63,0x11d1,0x90,0x53,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXRawSurface,0x09756C8A,0xD96A,0x11d1,0x90,0x62,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXTFilterCollection,0x22B07B33,0x8BFB,0x49d4,0x9B,0x90,0x09,0x38,0x37,0x0C,0x90,0x19);


MIDL_DEFINE_GUID(IID, IID_IDXTFilterBehavior,0x14D7DDDD,0xACA2,0x4E45,0x95,0x04,0x38,0x08,0xAB,0xEB,0x4F,0x92);


MIDL_DEFINE_GUID(IID, IID_IDXTFilterBehaviorSite,0x909B23C2,0x9018,0x499f,0xA8,0x6D,0x4E,0x7D,0xA9,0x37,0xE9,0x31);


MIDL_DEFINE_GUID(IID, IID_IDXTFilter,0xEDA1D7FF,0x4426,0x407a,0x9E,0xA4,0xDE,0x63,0xA4,0x1C,0x09,0xDA);


MIDL_DEFINE_GUID(IID, IID_IDXTRedirectFilterInit,0xD1A57094,0x21F7,0x4e6c,0x93,0xE5,0xF5,0xF7,0x7F,0x74,0x82,0x93);


MIDL_DEFINE_GUID(IID, LIBID_DXTRANSLib,0x54314D1D,0x35FE,0x11d1,0x81,0xA1,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTransformFactory,0xD1FE6762,0xFC48,0x11D0,0x88,0x3A,0x3C,0x8B,0x00,0xC1,0x00,0x00);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTaskManager,0x4CB26C03,0xFF93,0x11d0,0x81,0x7E,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTScale,0x555278E2,0x05DB,0x11D1,0x88,0x3A,0x3C,0x8B,0x00,0xC1,0x00,0x00);


MIDL_DEFINE_GUID(CLSID, CLSID_DXSurface,0x0E890F83,0x5F79,0x11D1,0x90,0x43,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(CLSID, CLSID_DXSurfaceModifier,0x3E669F1D,0x9C23,0x11d1,0x90,0x53,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(CLSID, CLSID_DXGradient,0xC6365470,0xF667,0x11d1,0x90,0x67,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTFilterBehavior,0x649EEC1E,0xB579,0x4E8C,0xBB,0x3B,0x49,0x97,0xF8,0x42,0x65,0x36);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTFilter,0x385A91BC,0x1E8A,0x4e4a,0xA7,0xA6,0xF4,0xFC,0x1E,0x6C,0xA1,0xBD);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTFilterFactory,0x81397204,0xF51A,0x4571,0x8D,0x7B,0xDC,0x03,0x05,0x21,0xAA,0xBD);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTFilterCollection,0xA7EE7F34,0x3BD1,0x427f,0x92,0x31,0xF9,0x41,0xE9,0xB7,0xE1,0xFE);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AXP64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0328 */
/* Compiler settings for dxtrans.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IDXBaseObject,0x17B59B2B,0x9CC8,0x11d1,0x90,0x53,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXTransformFactory,0x6A950B2B,0xA971,0x11d1,0x81,0xC8,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(IID, IID_IDXTransform,0x30A5FB78,0xE11F,0x11d1,0x90,0x64,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXSurfacePick,0x30A5FB79,0xE11F,0x11d1,0x90,0x64,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXTBindHost,0xD26BCE55,0xE9DC,0x11d1,0x90,0x66,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXTaskManager,0x254DBBC1,0xF922,0x11d0,0x88,0x3A,0x3C,0x8B,0x00,0xC1,0x00,0x00);


MIDL_DEFINE_GUID(IID, IID_IDXSurfaceFactory,0x144946F5,0xC4D4,0x11d1,0x81,0xD1,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(IID, IID_IDXSurfaceModifier,0x9EA3B637,0xC37D,0x11d1,0x90,0x5E,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXSurface,0xB39FD73F,0xE139,0x11d1,0x90,0x65,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXSurfaceInit,0x9EA3B639,0xC37D,0x11d1,0x90,0x5E,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXARGBSurfaceInit,0x9EA3B63A,0xC37D,0x11d1,0x90,0x5E,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXARGBReadPtr,0xEAAAC2D6,0xC290,0x11d1,0x90,0x5D,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXARGBReadWritePtr,0xEAAAC2D7,0xC290,0x11d1,0x90,0x5D,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXDCLock,0x0F619456,0xCF39,0x11d1,0x90,0x5E,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXTScaleOutput,0xB2024B50,0xEE77,0x11d1,0x90,0x66,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXGradient,0xB2024B51,0xEE77,0x11d1,0x90,0x66,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXTScale,0xB39FD742,0xE139,0x11d1,0x90,0x65,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXEffect,0xE31FB81B,0x1335,0x11d1,0x81,0x89,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(IID, IID_IDXLookupTable,0x01BAFC7F,0x9E63,0x11d1,0x90,0x53,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXRawSurface,0x09756C8A,0xD96A,0x11d1,0x90,0x62,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXTFilterCollection,0x22B07B33,0x8BFB,0x49d4,0x9B,0x90,0x09,0x38,0x37,0x0C,0x90,0x19);


MIDL_DEFINE_GUID(IID, IID_IDXTFilterBehavior,0x14D7DDDD,0xACA2,0x4E45,0x95,0x04,0x38,0x08,0xAB,0xEB,0x4F,0x92);


MIDL_DEFINE_GUID(IID, IID_IDXTFilterBehaviorSite,0x909B23C2,0x9018,0x499f,0xA8,0x6D,0x4E,0x7D,0xA9,0x37,0xE9,0x31);


MIDL_DEFINE_GUID(IID, IID_IDXTFilter,0xEDA1D7FF,0x4426,0x407a,0x9E,0xA4,0xDE,0x63,0xA4,0x1C,0x09,0xDA);


MIDL_DEFINE_GUID(IID, IID_IDXTRedirectFilterInit,0xD1A57094,0x21F7,0x4e6c,0x93,0xE5,0xF5,0xF7,0x7F,0x74,0x82,0x93);


MIDL_DEFINE_GUID(IID, LIBID_DXTRANSLib,0x54314D1D,0x35FE,0x11d1,0x81,0xA1,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTransformFactory,0xD1FE6762,0xFC48,0x11D0,0x88,0x3A,0x3C,0x8B,0x00,0xC1,0x00,0x00);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTaskManager,0x4CB26C03,0xFF93,0x11d0,0x81,0x7E,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTScale,0x555278E2,0x05DB,0x11D1,0x88,0x3A,0x3C,0x8B,0x00,0xC1,0x00,0x00);


MIDL_DEFINE_GUID(CLSID, CLSID_DXSurface,0x0E890F83,0x5F79,0x11D1,0x90,0x43,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(CLSID, CLSID_DXSurfaceModifier,0x3E669F1D,0x9C23,0x11d1,0x90,0x53,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(CLSID, CLSID_DXGradient,0xC6365470,0xF667,0x11d1,0x90,0x67,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTFilterBehavior,0x649EEC1E,0xB579,0x4E8C,0xBB,0x3B,0x49,0x97,0xF8,0x42,0x65,0x36);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTFilter,0x385A91BC,0x1E8A,0x4e4a,0xA7,0xA6,0xF4,0xFC,0x1E,0x6C,0xA1,0xBD);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTFilterFactory,0x81397204,0xF51A,0x4571,0x8D,0x7B,0xDC,0x03,0x05,0x21,0xAA,0xBD);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTFilterCollection,0xA7EE7F34,0x3BD1,0x427f,0x92,0x31,0xF9,0x41,0xE9,0xB7,0xE1,0xFE);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AXP64)*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\Dxtmsft3.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0286 */
/* Compiler settings for dxtmsft3.idl:
    Oicf (OptLev=i2), W0, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __dxtmsft3_h__
#define __dxtmsft3_h__

/* Forward Declarations */ 

#ifndef __IExplode_FWD_DEFINED__
#define __IExplode_FWD_DEFINED__
typedef interface IExplode IExplode;
#endif 	/* __IExplode_FWD_DEFINED__ */


#ifndef __ICrShatter_FWD_DEFINED__
#define __ICrShatter_FWD_DEFINED__
typedef interface ICrShatter ICrShatter;
#endif 	/* __ICrShatter_FWD_DEFINED__ */


#ifndef __IDXTBlackHole_FWD_DEFINED__
#define __IDXTBlackHole_FWD_DEFINED__
typedef interface IDXTBlackHole IDXTBlackHole;
#endif 	/* __IDXTBlackHole_FWD_DEFINED__ */


#ifndef __IDXTRoll_FWD_DEFINED__
#define __IDXTRoll_FWD_DEFINED__
typedef interface IDXTRoll IDXTRoll;
#endif 	/* __IDXTRoll_FWD_DEFINED__ */


#ifndef __IDXTSpin_FWD_DEFINED__
#define __IDXTSpin_FWD_DEFINED__
typedef interface IDXTSpin IDXTSpin;
#endif 	/* __IDXTSpin_FWD_DEFINED__ */


#ifndef __IRipple_FWD_DEFINED__
#define __IRipple_FWD_DEFINED__
typedef interface IRipple IRipple;
#endif 	/* __IRipple_FWD_DEFINED__ */


#ifndef __IHeightField_FWD_DEFINED__
#define __IHeightField_FWD_DEFINED__
typedef interface IHeightField IHeightField;
#endif 	/* __IHeightField_FWD_DEFINED__ */


#ifndef __IDXTMetaStream_FWD_DEFINED__
#define __IDXTMetaStream_FWD_DEFINED__
typedef interface IDXTMetaStream IDXTMetaStream;
#endif 	/* __IDXTMetaStream_FWD_DEFINED__ */


#ifndef __IDXTText3D_FWD_DEFINED__
#define __IDXTText3D_FWD_DEFINED__
typedef interface IDXTText3D IDXTText3D;
#endif 	/* __IDXTText3D_FWD_DEFINED__ */


#ifndef __IDXTShapes_FWD_DEFINED__
#define __IDXTShapes_FWD_DEFINED__
typedef interface IDXTShapes IDXTShapes;
#endif 	/* __IDXTShapes_FWD_DEFINED__ */


#ifndef __Explode_FWD_DEFINED__
#define __Explode_FWD_DEFINED__

#ifdef __cplusplus
typedef class Explode Explode;
#else
typedef struct Explode Explode;
#endif /* __cplusplus */

#endif 	/* __Explode_FWD_DEFINED__ */


#ifndef __ExplodeProp_FWD_DEFINED__
#define __ExplodeProp_FWD_DEFINED__

#ifdef __cplusplus
typedef class ExplodeProp ExplodeProp;
#else
typedef struct ExplodeProp ExplodeProp;
#endif /* __cplusplus */

#endif 	/* __ExplodeProp_FWD_DEFINED__ */


#ifndef __Ripple_FWD_DEFINED__
#define __Ripple_FWD_DEFINED__

#ifdef __cplusplus
typedef class Ripple Ripple;
#else
typedef struct Ripple Ripple;
#endif /* __cplusplus */

#endif 	/* __Ripple_FWD_DEFINED__ */


#ifndef __RipProp_FWD_DEFINED__
#define __RipProp_FWD_DEFINED__

#ifdef __cplusplus
typedef class RipProp RipProp;
#else
typedef struct RipProp RipProp;
#endif /* __cplusplus */

#endif 	/* __RipProp_FWD_DEFINED__ */


#ifndef __HeightField_FWD_DEFINED__
#define __HeightField_FWD_DEFINED__

#ifdef __cplusplus
typedef class HeightField HeightField;
#else
typedef struct HeightField HeightField;
#endif /* __cplusplus */

#endif 	/* __HeightField_FWD_DEFINED__ */


#ifndef __HtFieldProp_FWD_DEFINED__
#define __HtFieldProp_FWD_DEFINED__

#ifdef __cplusplus
typedef class HtFieldProp HtFieldProp;
#else
typedef struct HtFieldProp HtFieldProp;
#endif /* __cplusplus */

#endif 	/* __HtFieldProp_FWD_DEFINED__ */


#ifndef __DXTMetaStream_FWD_DEFINED__
#define __DXTMetaStream_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTMetaStream DXTMetaStream;
#else
typedef struct DXTMetaStream DXTMetaStream;
#endif /* __cplusplus */

#endif 	/* __DXTMetaStream_FWD_DEFINED__ */


#ifndef __DXTMetaStreamProp_FWD_DEFINED__
#define __DXTMetaStreamProp_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTMetaStreamProp DXTMetaStreamProp;
#else
typedef struct DXTMetaStreamProp DXTMetaStreamProp;
#endif /* __cplusplus */

#endif 	/* __DXTMetaStreamProp_FWD_DEFINED__ */


#ifndef __DXTText3D_FWD_DEFINED__
#define __DXTText3D_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTText3D DXTText3D;
#else
typedef struct DXTText3D DXTText3D;
#endif /* __cplusplus */

#endif 	/* __DXTText3D_FWD_DEFINED__ */


#ifndef __DXTText3DPP_FWD_DEFINED__
#define __DXTText3DPP_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTText3DPP DXTText3DPP;
#else
typedef struct DXTText3DPP DXTText3DPP;
#endif /* __cplusplus */

#endif 	/* __DXTText3DPP_FWD_DEFINED__ */


#ifndef __CrShatter_FWD_DEFINED__
#define __CrShatter_FWD_DEFINED__

#ifdef __cplusplus
typedef class CrShatter CrShatter;
#else
typedef struct CrShatter CrShatter;
#endif /* __cplusplus */

#endif 	/* __CrShatter_FWD_DEFINED__ */


#ifndef __CrShatterPP_FWD_DEFINED__
#define __CrShatterPP_FWD_DEFINED__

#ifdef __cplusplus
typedef class CrShatterPP CrShatterPP;
#else
typedef struct CrShatterPP CrShatterPP;
#endif /* __cplusplus */

#endif 	/* __CrShatterPP_FWD_DEFINED__ */


#ifndef __DXTBlackHole_FWD_DEFINED__
#define __DXTBlackHole_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTBlackHole DXTBlackHole;
#else
typedef struct DXTBlackHole DXTBlackHole;
#endif /* __cplusplus */

#endif 	/* __DXTBlackHole_FWD_DEFINED__ */


#ifndef __DXTBlackHolePP_FWD_DEFINED__
#define __DXTBlackHolePP_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTBlackHolePP DXTBlackHolePP;
#else
typedef struct DXTBlackHolePP DXTBlackHolePP;
#endif /* __cplusplus */

#endif 	/* __DXTBlackHolePP_FWD_DEFINED__ */


#ifndef __DXTRoll_FWD_DEFINED__
#define __DXTRoll_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTRoll DXTRoll;
#else
typedef struct DXTRoll DXTRoll;
#endif /* __cplusplus */

#endif 	/* __DXTRoll_FWD_DEFINED__ */


#ifndef __DXTRollPP_FWD_DEFINED__
#define __DXTRollPP_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTRollPP DXTRollPP;
#else
typedef struct DXTRollPP DXTRollPP;
#endif /* __cplusplus */

#endif 	/* __DXTRollPP_FWD_DEFINED__ */


#ifndef __DXTSpin_FWD_DEFINED__
#define __DXTSpin_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTSpin DXTSpin;
#else
typedef struct DXTSpin DXTSpin;
#endif /* __cplusplus */

#endif 	/* __DXTSpin_FWD_DEFINED__ */


#ifndef __DXTSpinPP_FWD_DEFINED__
#define __DXTSpinPP_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTSpinPP DXTSpinPP;
#else
typedef struct DXTSpinPP DXTSpinPP;
#endif /* __cplusplus */

#endif 	/* __DXTSpinPP_FWD_DEFINED__ */


#ifndef __DXTShapes_FWD_DEFINED__
#define __DXTShapes_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTShapes DXTShapes;
#else
typedef struct DXTShapes DXTShapes;
#endif /* __cplusplus */

#endif 	/* __DXTShapes_FWD_DEFINED__ */


#ifndef __DXTShapesPP_FWD_DEFINED__
#define __DXTShapesPP_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTShapesPP DXTShapesPP;
#else
typedef struct DXTShapesPP DXTShapesPP;
#endif /* __cplusplus */

#endif 	/* __DXTShapesPP_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"
#include "dxtrans.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_dxtmsft3_0000 */
/* [local] */ 

typedef 
enum EXPLODEDISPID
    {	DISPID_Explode_Tumble	= DISPID_DXE_NEXT_ID,
	DISPID_Explode_MaxRotations	= DISPID_Explode_Tumble + 1,
	DISPID_Explode_FinalVelocity	= DISPID_Explode_MaxRotations + 1,
	DISPID_Explode_PositionJump	= DISPID_Explode_FinalVelocity + 1,
	DISPID_Explode_DecayTime	= DISPID_Explode_PositionJump + 1
    }	EXPLODEDISPID;



extern RPC_IF_HANDLE __MIDL_itf_dxtmsft3_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtmsft3_0000_v0_0_s_ifspec;

#ifndef __IExplode_INTERFACE_DEFINED__
#define __IExplode_INTERFACE_DEFINED__

/* interface IExplode */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IExplode;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("141DBAF0-55FB-11D1-B83E-00A0C933BE86")
    IExplode : public IDXEffect
    {
    public:
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Tumble( 
            /* [in] */ BOOL newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Tumble( 
            /* [retval][out] */ BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_MaxRotations( 
            /* [in] */ LONG newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_MaxRotations( 
            /* [retval][out] */ LONG __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_FinalVelocity( 
            /* [in] */ float newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_FinalVelocity( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_PositionJump( 
            /* [in] */ float newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_PositionJump( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_DecayTime( 
            /* [in] */ float newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_DecayTime( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IExplodeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IExplode __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IExplode __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IExplode __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IExplode __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IExplode __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IExplode __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IExplode __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            IExplode __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            IExplode __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            IExplode __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            IExplode __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            IExplode __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            IExplode __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Tumble )( 
            IExplode __RPC_FAR * This,
            /* [in] */ BOOL newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Tumble )( 
            IExplode __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_MaxRotations )( 
            IExplode __RPC_FAR * This,
            /* [in] */ LONG newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_MaxRotations )( 
            IExplode __RPC_FAR * This,
            /* [retval][out] */ LONG __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_FinalVelocity )( 
            IExplode __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_FinalVelocity )( 
            IExplode __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_PositionJump )( 
            IExplode __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_PositionJump )( 
            IExplode __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_DecayTime )( 
            IExplode __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DecayTime )( 
            IExplode __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        END_INTERFACE
    } IExplodeVtbl;

    interface IExplode
    {
        CONST_VTBL struct IExplodeVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IExplode_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IExplode_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IExplode_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IExplode_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IExplode_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IExplode_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IExplode_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IExplode_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IExplode_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IExplode_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IExplode_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IExplode_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IExplode_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define IExplode_put_Tumble(This,newVal)	\
    (This)->lpVtbl -> put_Tumble(This,newVal)

#define IExplode_get_Tumble(This,pVal)	\
    (This)->lpVtbl -> get_Tumble(This,pVal)

#define IExplode_put_MaxRotations(This,newVal)	\
    (This)->lpVtbl -> put_MaxRotations(This,newVal)

#define IExplode_get_MaxRotations(This,pVal)	\
    (This)->lpVtbl -> get_MaxRotations(This,pVal)

#define IExplode_put_FinalVelocity(This,newVal)	\
    (This)->lpVtbl -> put_FinalVelocity(This,newVal)

#define IExplode_get_FinalVelocity(This,pVal)	\
    (This)->lpVtbl -> get_FinalVelocity(This,pVal)

#define IExplode_put_PositionJump(This,newVal)	\
    (This)->lpVtbl -> put_PositionJump(This,newVal)

#define IExplode_get_PositionJump(This,pVal)	\
    (This)->lpVtbl -> get_PositionJump(This,pVal)

#define IExplode_put_DecayTime(This,newVal)	\
    (This)->lpVtbl -> put_DecayTime(This,newVal)

#define IExplode_get_DecayTime(This,pVal)	\
    (This)->lpVtbl -> get_DecayTime(This,pVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propput] */ HRESULT STDMETHODCALLTYPE IExplode_put_Tumble_Proxy( 
    IExplode __RPC_FAR * This,
    /* [in] */ BOOL newVal);


void __RPC_STUB IExplode_put_Tumble_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IExplode_get_Tumble_Proxy( 
    IExplode __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pVal);


void __RPC_STUB IExplode_get_Tumble_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IExplode_put_MaxRotations_Proxy( 
    IExplode __RPC_FAR * This,
    /* [in] */ LONG newVal);


void __RPC_STUB IExplode_put_MaxRotations_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IExplode_get_MaxRotations_Proxy( 
    IExplode __RPC_FAR * This,
    /* [retval][out] */ LONG __RPC_FAR *pVal);


void __RPC_STUB IExplode_get_MaxRotations_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IExplode_put_FinalVelocity_Proxy( 
    IExplode __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IExplode_put_FinalVelocity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IExplode_get_FinalVelocity_Proxy( 
    IExplode __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB IExplode_get_FinalVelocity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IExplode_put_PositionJump_Proxy( 
    IExplode __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IExplode_put_PositionJump_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IExplode_get_PositionJump_Proxy( 
    IExplode __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB IExplode_get_PositionJump_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IExplode_put_DecayTime_Proxy( 
    IExplode __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IExplode_put_DecayTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IExplode_get_DecayTime_Proxy( 
    IExplode __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB IExplode_get_DecayTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IExplode_INTERFACE_DEFINED__ */


#ifndef __ICrShatter_INTERFACE_DEFINED__
#define __ICrShatter_INTERFACE_DEFINED__

/* interface ICrShatter */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ICrShatter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("63500AE1-0858-11D2-8CE4-00C04F8ECB10")
    ICrShatter : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_seed( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_seed( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_maxShards( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_maxShards( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_depth( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_depth( 
            /* [in] */ float newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_backColor( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_backColor( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_evacuateX( 
            /* [retval][out] */ short __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_evacuateX( 
            /* [in] */ short newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_evacuateY( 
            /* [retval][out] */ short __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_evacuateY( 
            /* [in] */ short newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_evacuateZ( 
            /* [retval][out] */ short __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_evacuateZ( 
            /* [in] */ short newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_evacuateDeltaX( 
            /* [retval][out] */ short __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_evacuateDeltaX( 
            /* [in] */ short newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_evacuateDeltaY( 
            /* [retval][out] */ short __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_evacuateDeltaY( 
            /* [in] */ short newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_evacuateDeltaZ( 
            /* [retval][out] */ short __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_evacuateDeltaZ( 
            /* [in] */ short newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICrShatterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICrShatter __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICrShatter __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICrShatter __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ICrShatter __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ICrShatter __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ICrShatter __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ICrShatter __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            ICrShatter __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            ICrShatter __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            ICrShatter __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            ICrShatter __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            ICrShatter __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            ICrShatter __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_seed )( 
            ICrShatter __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_seed )( 
            ICrShatter __RPC_FAR * This,
            /* [in] */ long newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_maxShards )( 
            ICrShatter __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_maxShards )( 
            ICrShatter __RPC_FAR * This,
            /* [in] */ long newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_depth )( 
            ICrShatter __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_depth )( 
            ICrShatter __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_backColor )( 
            ICrShatter __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_backColor )( 
            ICrShatter __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_evacuateX )( 
            ICrShatter __RPC_FAR * This,
            /* [retval][out] */ short __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_evacuateX )( 
            ICrShatter __RPC_FAR * This,
            /* [in] */ short newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_evacuateY )( 
            ICrShatter __RPC_FAR * This,
            /* [retval][out] */ short __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_evacuateY )( 
            ICrShatter __RPC_FAR * This,
            /* [in] */ short newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_evacuateZ )( 
            ICrShatter __RPC_FAR * This,
            /* [retval][out] */ short __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_evacuateZ )( 
            ICrShatter __RPC_FAR * This,
            /* [in] */ short newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_evacuateDeltaX )( 
            ICrShatter __RPC_FAR * This,
            /* [retval][out] */ short __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_evacuateDeltaX )( 
            ICrShatter __RPC_FAR * This,
            /* [in] */ short newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_evacuateDeltaY )( 
            ICrShatter __RPC_FAR * This,
            /* [retval][out] */ short __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_evacuateDeltaY )( 
            ICrShatter __RPC_FAR * This,
            /* [in] */ short newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_evacuateDeltaZ )( 
            ICrShatter __RPC_FAR * This,
            /* [retval][out] */ short __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_evacuateDeltaZ )( 
            ICrShatter __RPC_FAR * This,
            /* [in] */ short newVal);
        
        END_INTERFACE
    } ICrShatterVtbl;

    interface ICrShatter
    {
        CONST_VTBL struct ICrShatterVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICrShatter_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICrShatter_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICrShatter_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICrShatter_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ICrShatter_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ICrShatter_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ICrShatter_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ICrShatter_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define ICrShatter_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define ICrShatter_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define ICrShatter_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define ICrShatter_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define ICrShatter_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define ICrShatter_get_seed(This,pVal)	\
    (This)->lpVtbl -> get_seed(This,pVal)

#define ICrShatter_put_seed(This,newVal)	\
    (This)->lpVtbl -> put_seed(This,newVal)

#define ICrShatter_get_maxShards(This,pVal)	\
    (This)->lpVtbl -> get_maxShards(This,pVal)

#define ICrShatter_put_maxShards(This,newVal)	\
    (This)->lpVtbl -> put_maxShards(This,newVal)

#define ICrShatter_get_depth(This,pVal)	\
    (This)->lpVtbl -> get_depth(This,pVal)

#define ICrShatter_put_depth(This,newVal)	\
    (This)->lpVtbl -> put_depth(This,newVal)

#define ICrShatter_get_backColor(This,pVal)	\
    (This)->lpVtbl -> get_backColor(This,pVal)

#define ICrShatter_put_backColor(This,newVal)	\
    (This)->lpVtbl -> put_backColor(This,newVal)

#define ICrShatter_get_evacuateX(This,pVal)	\
    (This)->lpVtbl -> get_evacuateX(This,pVal)

#define ICrShatter_put_evacuateX(This,newVal)	\
    (This)->lpVtbl -> put_evacuateX(This,newVal)

#define ICrShatter_get_evacuateY(This,pVal)	\
    (This)->lpVtbl -> get_evacuateY(This,pVal)

#define ICrShatter_put_evacuateY(This,newVal)	\
    (This)->lpVtbl -> put_evacuateY(This,newVal)

#define ICrShatter_get_evacuateZ(This,pVal)	\
    (This)->lpVtbl -> get_evacuateZ(This,pVal)

#define ICrShatter_put_evacuateZ(This,newVal)	\
    (This)->lpVtbl -> put_evacuateZ(This,newVal)

#define ICrShatter_get_evacuateDeltaX(This,pVal)	\
    (This)->lpVtbl -> get_evacuateDeltaX(This,pVal)

#define ICrShatter_put_evacuateDeltaX(This,newVal)	\
    (This)->lpVtbl -> put_evacuateDeltaX(This,newVal)

#define ICrShatter_get_evacuateDeltaY(This,pVal)	\
    (This)->lpVtbl -> get_evacuateDeltaY(This,pVal)

#define ICrShatter_put_evacuateDeltaY(This,newVal)	\
    (This)->lpVtbl -> put_evacuateDeltaY(This,newVal)

#define ICrShatter_get_evacuateDeltaZ(This,pVal)	\
    (This)->lpVtbl -> get_evacuateDeltaZ(This,pVal)

#define ICrShatter_put_evacuateDeltaZ(This,newVal)	\
    (This)->lpVtbl -> put_evacuateDeltaZ(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE ICrShatter_get_seed_Proxy( 
    ICrShatter __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB ICrShatter_get_seed_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ICrShatter_put_seed_Proxy( 
    ICrShatter __RPC_FAR * This,
    /* [in] */ long newVal);


void __RPC_STUB ICrShatter_put_seed_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ICrShatter_get_maxShards_Proxy( 
    ICrShatter __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB ICrShatter_get_maxShards_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ICrShatter_put_maxShards_Proxy( 
    ICrShatter __RPC_FAR * This,
    /* [in] */ long newVal);


void __RPC_STUB ICrShatter_put_maxShards_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ICrShatter_get_depth_Proxy( 
    ICrShatter __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB ICrShatter_get_depth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ICrShatter_put_depth_Proxy( 
    ICrShatter __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB ICrShatter_put_depth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ICrShatter_get_backColor_Proxy( 
    ICrShatter __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB ICrShatter_get_backColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ICrShatter_put_backColor_Proxy( 
    ICrShatter __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB ICrShatter_put_backColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ICrShatter_get_evacuateX_Proxy( 
    ICrShatter __RPC_FAR * This,
    /* [retval][out] */ short __RPC_FAR *pVal);


void __RPC_STUB ICrShatter_get_evacuateX_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ICrShatter_put_evacuateX_Proxy( 
    ICrShatter __RPC_FAR * This,
    /* [in] */ short newVal);


void __RPC_STUB ICrShatter_put_evacuateX_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ICrShatter_get_evacuateY_Proxy( 
    ICrShatter __RPC_FAR * This,
    /* [retval][out] */ short __RPC_FAR *pVal);


void __RPC_STUB ICrShatter_get_evacuateY_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ICrShatter_put_evacuateY_Proxy( 
    ICrShatter __RPC_FAR * This,
    /* [in] */ short newVal);


void __RPC_STUB ICrShatter_put_evacuateY_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ICrShatter_get_evacuateZ_Proxy( 
    ICrShatter __RPC_FAR * This,
    /* [retval][out] */ short __RPC_FAR *pVal);


void __RPC_STUB ICrShatter_get_evacuateZ_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ICrShatter_put_evacuateZ_Proxy( 
    ICrShatter __RPC_FAR * This,
    /* [in] */ short newVal);


void __RPC_STUB ICrShatter_put_evacuateZ_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ICrShatter_get_evacuateDeltaX_Proxy( 
    ICrShatter __RPC_FAR * This,
    /* [retval][out] */ short __RPC_FAR *pVal);


void __RPC_STUB ICrShatter_get_evacuateDeltaX_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ICrShatter_put_evacuateDeltaX_Proxy( 
    ICrShatter __RPC_FAR * This,
    /* [in] */ short newVal);


void __RPC_STUB ICrShatter_put_evacuateDeltaX_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ICrShatter_get_evacuateDeltaY_Proxy( 
    ICrShatter __RPC_FAR * This,
    /* [retval][out] */ short __RPC_FAR *pVal);


void __RPC_STUB ICrShatter_get_evacuateDeltaY_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ICrShatter_put_evacuateDeltaY_Proxy( 
    ICrShatter __RPC_FAR * This,
    /* [in] */ short newVal);


void __RPC_STUB ICrShatter_put_evacuateDeltaY_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ICrShatter_get_evacuateDeltaZ_Proxy( 
    ICrShatter __RPC_FAR * This,
    /* [retval][out] */ short __RPC_FAR *pVal);


void __RPC_STUB ICrShatter_get_evacuateDeltaZ_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ICrShatter_put_evacuateDeltaZ_Proxy( 
    ICrShatter __RPC_FAR * This,
    /* [in] */ short newVal);


void __RPC_STUB ICrShatter_put_evacuateDeltaZ_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICrShatter_INTERFACE_DEFINED__ */


#ifndef __IDXTBlackHole_INTERFACE_DEFINED__
#define __IDXTBlackHole_INTERFACE_DEFINED__

/* interface IDXTBlackHole */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTBlackHole;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C3853C21-3F2E-11D2-9900-0000F803FF7A")
    IDXTBlackHole : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_HoleX( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_HoleX( 
            /* [in] */ float newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_HoleY( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_HoleY( 
            /* [in] */ float newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_HoleZ( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_HoleZ( 
            /* [in] */ float newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_StretchPercent( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_StretchPercent( 
            /* [in] */ float newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_FallX( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_FallX( 
            /* [in] */ float newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_FallY( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_FallY( 
            /* [in] */ float newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_FallZ( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_FallZ( 
            /* [in] */ float newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_SpiralX( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_SpiralX( 
            /* [in] */ float newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_SpiralY( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_SpiralY( 
            /* [in] */ float newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_SpiralZ( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_SpiralZ( 
            /* [in] */ float newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Rotations( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Rotations( 
            /* [in] */ float newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Movement( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Movement( 
            /* [in] */ BSTR newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTBlackHoleVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTBlackHole __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTBlackHole __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTBlackHole __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDXTBlackHole __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDXTBlackHole __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDXTBlackHole __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDXTBlackHole __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            IDXTBlackHole __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            IDXTBlackHole __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            IDXTBlackHole __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            IDXTBlackHole __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            IDXTBlackHole __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            IDXTBlackHole __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_HoleX )( 
            IDXTBlackHole __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_HoleX )( 
            IDXTBlackHole __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_HoleY )( 
            IDXTBlackHole __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_HoleY )( 
            IDXTBlackHole __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_HoleZ )( 
            IDXTBlackHole __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_HoleZ )( 
            IDXTBlackHole __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StretchPercent )( 
            IDXTBlackHole __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_StretchPercent )( 
            IDXTBlackHole __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_FallX )( 
            IDXTBlackHole __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_FallX )( 
            IDXTBlackHole __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_FallY )( 
            IDXTBlackHole __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_FallY )( 
            IDXTBlackHole __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_FallZ )( 
            IDXTBlackHole __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_FallZ )( 
            IDXTBlackHole __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SpiralX )( 
            IDXTBlackHole __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_SpiralX )( 
            IDXTBlackHole __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SpiralY )( 
            IDXTBlackHole __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_SpiralY )( 
            IDXTBlackHole __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SpiralZ )( 
            IDXTBlackHole __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_SpiralZ )( 
            IDXTBlackHole __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Rotations )( 
            IDXTBlackHole __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Rotations )( 
            IDXTBlackHole __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Movement )( 
            IDXTBlackHole __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Movement )( 
            IDXTBlackHole __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        END_INTERFACE
    } IDXTBlackHoleVtbl;

    interface IDXTBlackHole
    {
        CONST_VTBL struct IDXTBlackHoleVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTBlackHole_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTBlackHole_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTBlackHole_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTBlackHole_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTBlackHole_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTBlackHole_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTBlackHole_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTBlackHole_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IDXTBlackHole_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IDXTBlackHole_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IDXTBlackHole_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IDXTBlackHole_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IDXTBlackHole_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define IDXTBlackHole_get_HoleX(This,pVal)	\
    (This)->lpVtbl -> get_HoleX(This,pVal)

#define IDXTBlackHole_put_HoleX(This,newVal)	\
    (This)->lpVtbl -> put_HoleX(This,newVal)

#define IDXTBlackHole_get_HoleY(This,pVal)	\
    (This)->lpVtbl -> get_HoleY(This,pVal)

#define IDXTBlackHole_put_HoleY(This,newVal)	\
    (This)->lpVtbl -> put_HoleY(This,newVal)

#define IDXTBlackHole_get_HoleZ(This,pVal)	\
    (This)->lpVtbl -> get_HoleZ(This,pVal)

#define IDXTBlackHole_put_HoleZ(This,newVal)	\
    (This)->lpVtbl -> put_HoleZ(This,newVal)

#define IDXTBlackHole_get_StretchPercent(This,pVal)	\
    (This)->lpVtbl -> get_StretchPercent(This,pVal)

#define IDXTBlackHole_put_StretchPercent(This,newVal)	\
    (This)->lpVtbl -> put_StretchPercent(This,newVal)

#define IDXTBlackHole_get_FallX(This,pVal)	\
    (This)->lpVtbl -> get_FallX(This,pVal)

#define IDXTBlackHole_put_FallX(This,newVal)	\
    (This)->lpVtbl -> put_FallX(This,newVal)

#define IDXTBlackHole_get_FallY(This,pVal)	\
    (This)->lpVtbl -> get_FallY(This,pVal)

#define IDXTBlackHole_put_FallY(This,newVal)	\
    (This)->lpVtbl -> put_FallY(This,newVal)

#define IDXTBlackHole_get_FallZ(This,pVal)	\
    (This)->lpVtbl -> get_FallZ(This,pVal)

#define IDXTBlackHole_put_FallZ(This,newVal)	\
    (This)->lpVtbl -> put_FallZ(This,newVal)

#define IDXTBlackHole_get_SpiralX(This,pVal)	\
    (This)->lpVtbl -> get_SpiralX(This,pVal)

#define IDXTBlackHole_put_SpiralX(This,newVal)	\
    (This)->lpVtbl -> put_SpiralX(This,newVal)

#define IDXTBlackHole_get_SpiralY(This,pVal)	\
    (This)->lpVtbl -> get_SpiralY(This,pVal)

#define IDXTBlackHole_put_SpiralY(This,newVal)	\
    (This)->lpVtbl -> put_SpiralY(This,newVal)

#define IDXTBlackHole_get_SpiralZ(This,pVal)	\
    (This)->lpVtbl -> get_SpiralZ(This,pVal)

#define IDXTBlackHole_put_SpiralZ(This,newVal)	\
    (This)->lpVtbl -> put_SpiralZ(This,newVal)

#define IDXTBlackHole_get_Rotations(This,pVal)	\
    (This)->lpVtbl -> get_Rotations(This,pVal)

#define IDXTBlackHole_put_Rotations(This,newVal)	\
    (This)->lpVtbl -> put_Rotations(This,newVal)

#define IDXTBlackHole_get_Movement(This,pVal)	\
    (This)->lpVtbl -> get_Movement(This,pVal)

#define IDXTBlackHole_put_Movement(This,newVal)	\
    (This)->lpVtbl -> put_Movement(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTBlackHole_get_HoleX_Proxy( 
    IDXTBlackHole __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB IDXTBlackHole_get_HoleX_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTBlackHole_put_HoleX_Proxy( 
    IDXTBlackHole __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IDXTBlackHole_put_HoleX_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTBlackHole_get_HoleY_Proxy( 
    IDXTBlackHole __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB IDXTBlackHole_get_HoleY_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTBlackHole_put_HoleY_Proxy( 
    IDXTBlackHole __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IDXTBlackHole_put_HoleY_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTBlackHole_get_HoleZ_Proxy( 
    IDXTBlackHole __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB IDXTBlackHole_get_HoleZ_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTBlackHole_put_HoleZ_Proxy( 
    IDXTBlackHole __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IDXTBlackHole_put_HoleZ_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTBlackHole_get_StretchPercent_Proxy( 
    IDXTBlackHole __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB IDXTBlackHole_get_StretchPercent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTBlackHole_put_StretchPercent_Proxy( 
    IDXTBlackHole __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IDXTBlackHole_put_StretchPercent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTBlackHole_get_FallX_Proxy( 
    IDXTBlackHole __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB IDXTBlackHole_get_FallX_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTBlackHole_put_FallX_Proxy( 
    IDXTBlackHole __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IDXTBlackHole_put_FallX_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTBlackHole_get_FallY_Proxy( 
    IDXTBlackHole __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB IDXTBlackHole_get_FallY_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTBlackHole_put_FallY_Proxy( 
    IDXTBlackHole __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IDXTBlackHole_put_FallY_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTBlackHole_get_FallZ_Proxy( 
    IDXTBlackHole __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB IDXTBlackHole_get_FallZ_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTBlackHole_put_FallZ_Proxy( 
    IDXTBlackHole __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IDXTBlackHole_put_FallZ_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTBlackHole_get_SpiralX_Proxy( 
    IDXTBlackHole __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB IDXTBlackHole_get_SpiralX_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTBlackHole_put_SpiralX_Proxy( 
    IDXTBlackHole __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IDXTBlackHole_put_SpiralX_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTBlackHole_get_SpiralY_Proxy( 
    IDXTBlackHole __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB IDXTBlackHole_get_SpiralY_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTBlackHole_put_SpiralY_Proxy( 
    IDXTBlackHole __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IDXTBlackHole_put_SpiralY_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTBlackHole_get_SpiralZ_Proxy( 
    IDXTBlackHole __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB IDXTBlackHole_get_SpiralZ_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTBlackHole_put_SpiralZ_Proxy( 
    IDXTBlackHole __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IDXTBlackHole_put_SpiralZ_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTBlackHole_get_Rotations_Proxy( 
    IDXTBlackHole __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB IDXTBlackHole_get_Rotations_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTBlackHole_put_Rotations_Proxy( 
    IDXTBlackHole __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IDXTBlackHole_put_Rotations_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTBlackHole_get_Movement_Proxy( 
    IDXTBlackHole __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IDXTBlackHole_get_Movement_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTBlackHole_put_Movement_Proxy( 
    IDXTBlackHole __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IDXTBlackHole_put_Movement_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTBlackHole_INTERFACE_DEFINED__ */


#ifndef __IDXTRoll_INTERFACE_DEFINED__
#define __IDXTRoll_INTERFACE_DEFINED__

/* interface IDXTRoll */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTRoll;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("78F30B81-48AA-11D2-9900-0000F803FF7A")
    IDXTRoll : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_DirectionX( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_DirectionX( 
            /* [in] */ float newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_DirectionY( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_DirectionY( 
            /* [in] */ float newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Radius( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Radius( 
            /* [in] */ float newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTRollVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTRoll __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTRoll __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTRoll __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDXTRoll __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDXTRoll __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDXTRoll __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDXTRoll __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            IDXTRoll __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            IDXTRoll __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            IDXTRoll __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            IDXTRoll __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            IDXTRoll __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            IDXTRoll __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DirectionX )( 
            IDXTRoll __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_DirectionX )( 
            IDXTRoll __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DirectionY )( 
            IDXTRoll __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_DirectionY )( 
            IDXTRoll __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Radius )( 
            IDXTRoll __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Radius )( 
            IDXTRoll __RPC_FAR * This,
            /* [in] */ float newVal);
        
        END_INTERFACE
    } IDXTRollVtbl;

    interface IDXTRoll
    {
        CONST_VTBL struct IDXTRollVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTRoll_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTRoll_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTRoll_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTRoll_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTRoll_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTRoll_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTRoll_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTRoll_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IDXTRoll_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IDXTRoll_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IDXTRoll_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IDXTRoll_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IDXTRoll_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define IDXTRoll_get_DirectionX(This,pVal)	\
    (This)->lpVtbl -> get_DirectionX(This,pVal)

#define IDXTRoll_put_DirectionX(This,newVal)	\
    (This)->lpVtbl -> put_DirectionX(This,newVal)

#define IDXTRoll_get_DirectionY(This,pVal)	\
    (This)->lpVtbl -> get_DirectionY(This,pVal)

#define IDXTRoll_put_DirectionY(This,newVal)	\
    (This)->lpVtbl -> put_DirectionY(This,newVal)

#define IDXTRoll_get_Radius(This,pVal)	\
    (This)->lpVtbl -> get_Radius(This,pVal)

#define IDXTRoll_put_Radius(This,newVal)	\
    (This)->lpVtbl -> put_Radius(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTRoll_get_DirectionX_Proxy( 
    IDXTRoll __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB IDXTRoll_get_DirectionX_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTRoll_put_DirectionX_Proxy( 
    IDXTRoll __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IDXTRoll_put_DirectionX_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTRoll_get_DirectionY_Proxy( 
    IDXTRoll __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB IDXTRoll_get_DirectionY_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTRoll_put_DirectionY_Proxy( 
    IDXTRoll __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IDXTRoll_put_DirectionY_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTRoll_get_Radius_Proxy( 
    IDXTRoll __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB IDXTRoll_get_Radius_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTRoll_put_Radius_Proxy( 
    IDXTRoll __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IDXTRoll_put_Radius_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTRoll_INTERFACE_DEFINED__ */


#ifndef __IDXTSpin_INTERFACE_DEFINED__
#define __IDXTSpin_INTERFACE_DEFINED__

/* interface IDXTSpin */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTSpin;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3D2807C1-43DE-11D2-9900-0000F803FF7A")
    IDXTSpin : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_SpinX( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_SpinX( 
            /* [in] */ float newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_SpinY( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_SpinY( 
            /* [in] */ float newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_SpinZ( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_SpinZ( 
            /* [in] */ float newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Flips( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Flips( 
            /* [in] */ long newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTSpinVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTSpin __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTSpin __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTSpin __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDXTSpin __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDXTSpin __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDXTSpin __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDXTSpin __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            IDXTSpin __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            IDXTSpin __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            IDXTSpin __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            IDXTSpin __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            IDXTSpin __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            IDXTSpin __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SpinX )( 
            IDXTSpin __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_SpinX )( 
            IDXTSpin __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SpinY )( 
            IDXTSpin __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_SpinY )( 
            IDXTSpin __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SpinZ )( 
            IDXTSpin __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_SpinZ )( 
            IDXTSpin __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Flips )( 
            IDXTSpin __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Flips )( 
            IDXTSpin __RPC_FAR * This,
            /* [in] */ long newVal);
        
        END_INTERFACE
    } IDXTSpinVtbl;

    interface IDXTSpin
    {
        CONST_VTBL struct IDXTSpinVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTSpin_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTSpin_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTSpin_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTSpin_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTSpin_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTSpin_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTSpin_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTSpin_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IDXTSpin_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IDXTSpin_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IDXTSpin_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IDXTSpin_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IDXTSpin_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define IDXTSpin_get_SpinX(This,pVal)	\
    (This)->lpVtbl -> get_SpinX(This,pVal)

#define IDXTSpin_put_SpinX(This,newVal)	\
    (This)->lpVtbl -> put_SpinX(This,newVal)

#define IDXTSpin_get_SpinY(This,pVal)	\
    (This)->lpVtbl -> get_SpinY(This,pVal)

#define IDXTSpin_put_SpinY(This,newVal)	\
    (This)->lpVtbl -> put_SpinY(This,newVal)

#define IDXTSpin_get_SpinZ(This,pVal)	\
    (This)->lpVtbl -> get_SpinZ(This,pVal)

#define IDXTSpin_put_SpinZ(This,newVal)	\
    (This)->lpVtbl -> put_SpinZ(This,newVal)

#define IDXTSpin_get_Flips(This,pVal)	\
    (This)->lpVtbl -> get_Flips(This,pVal)

#define IDXTSpin_put_Flips(This,newVal)	\
    (This)->lpVtbl -> put_Flips(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTSpin_get_SpinX_Proxy( 
    IDXTSpin __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB IDXTSpin_get_SpinX_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTSpin_put_SpinX_Proxy( 
    IDXTSpin __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IDXTSpin_put_SpinX_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTSpin_get_SpinY_Proxy( 
    IDXTSpin __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB IDXTSpin_get_SpinY_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTSpin_put_SpinY_Proxy( 
    IDXTSpin __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IDXTSpin_put_SpinY_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTSpin_get_SpinZ_Proxy( 
    IDXTSpin __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB IDXTSpin_get_SpinZ_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTSpin_put_SpinZ_Proxy( 
    IDXTSpin __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IDXTSpin_put_SpinZ_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTSpin_get_Flips_Proxy( 
    IDXTSpin __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IDXTSpin_get_Flips_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTSpin_put_Flips_Proxy( 
    IDXTSpin __RPC_FAR * This,
    /* [in] */ long newVal);


void __RPC_STUB IDXTSpin_put_Flips_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTSpin_INTERFACE_DEFINED__ */


#ifndef __IRipple_INTERFACE_DEFINED__
#define __IRipple_INTERFACE_DEFINED__

/* interface IRipple */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IRipple;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6DA4A05E-8E9E-11D1-904E-00C04FD9189D")
    IRipple : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_XOrigin( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_XOrigin( 
            /* [in] */ float newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_YOrigin( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_YOrigin( 
            /* [in] */ float newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Wavelength( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Wavelength( 
            /* [in] */ float newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Amplitude( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Amplitude( 
            /* [in] */ float newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_NumberOfWaves( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_NumberOfWaves( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_MinSteps( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_MinSteps( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_MaxSteps( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_MaxSteps( 
            /* [in] */ long newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRippleVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRipple __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRipple __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRipple __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IRipple __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IRipple __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IRipple __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IRipple __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            IRipple __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            IRipple __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            IRipple __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            IRipple __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            IRipple __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            IRipple __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_XOrigin )( 
            IRipple __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_XOrigin )( 
            IRipple __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_YOrigin )( 
            IRipple __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_YOrigin )( 
            IRipple __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Wavelength )( 
            IRipple __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Wavelength )( 
            IRipple __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Amplitude )( 
            IRipple __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Amplitude )( 
            IRipple __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_NumberOfWaves )( 
            IRipple __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_NumberOfWaves )( 
            IRipple __RPC_FAR * This,
            /* [in] */ long newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_MinSteps )( 
            IRipple __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_MinSteps )( 
            IRipple __RPC_FAR * This,
            /* [in] */ long newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_MaxSteps )( 
            IRipple __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_MaxSteps )( 
            IRipple __RPC_FAR * This,
            /* [in] */ long newVal);
        
        END_INTERFACE
    } IRippleVtbl;

    interface IRipple
    {
        CONST_VTBL struct IRippleVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRipple_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRipple_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRipple_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRipple_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IRipple_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IRipple_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IRipple_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IRipple_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IRipple_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IRipple_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IRipple_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IRipple_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IRipple_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define IRipple_get_XOrigin(This,pVal)	\
    (This)->lpVtbl -> get_XOrigin(This,pVal)

#define IRipple_put_XOrigin(This,newVal)	\
    (This)->lpVtbl -> put_XOrigin(This,newVal)

#define IRipple_get_YOrigin(This,pVal)	\
    (This)->lpVtbl -> get_YOrigin(This,pVal)

#define IRipple_put_YOrigin(This,newVal)	\
    (This)->lpVtbl -> put_YOrigin(This,newVal)

#define IRipple_get_Wavelength(This,pVal)	\
    (This)->lpVtbl -> get_Wavelength(This,pVal)

#define IRipple_put_Wavelength(This,newVal)	\
    (This)->lpVtbl -> put_Wavelength(This,newVal)

#define IRipple_get_Amplitude(This,pVal)	\
    (This)->lpVtbl -> get_Amplitude(This,pVal)

#define IRipple_put_Amplitude(This,newVal)	\
    (This)->lpVtbl -> put_Amplitude(This,newVal)

#define IRipple_get_NumberOfWaves(This,pVal)	\
    (This)->lpVtbl -> get_NumberOfWaves(This,pVal)

#define IRipple_put_NumberOfWaves(This,newVal)	\
    (This)->lpVtbl -> put_NumberOfWaves(This,newVal)

#define IRipple_get_MinSteps(This,pVal)	\
    (This)->lpVtbl -> get_MinSteps(This,pVal)

#define IRipple_put_MinSteps(This,newVal)	\
    (This)->lpVtbl -> put_MinSteps(This,newVal)

#define IRipple_get_MaxSteps(This,pVal)	\
    (This)->lpVtbl -> get_MaxSteps(This,pVal)

#define IRipple_put_MaxSteps(This,newVal)	\
    (This)->lpVtbl -> put_MaxSteps(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IRipple_get_XOrigin_Proxy( 
    IRipple __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB IRipple_get_XOrigin_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IRipple_put_XOrigin_Proxy( 
    IRipple __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IRipple_put_XOrigin_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IRipple_get_YOrigin_Proxy( 
    IRipple __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB IRipple_get_YOrigin_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IRipple_put_YOrigin_Proxy( 
    IRipple __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IRipple_put_YOrigin_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IRipple_get_Wavelength_Proxy( 
    IRipple __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB IRipple_get_Wavelength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IRipple_put_Wavelength_Proxy( 
    IRipple __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IRipple_put_Wavelength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IRipple_get_Amplitude_Proxy( 
    IRipple __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB IRipple_get_Amplitude_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IRipple_put_Amplitude_Proxy( 
    IRipple __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IRipple_put_Amplitude_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IRipple_get_NumberOfWaves_Proxy( 
    IRipple __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IRipple_get_NumberOfWaves_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IRipple_put_NumberOfWaves_Proxy( 
    IRipple __RPC_FAR * This,
    /* [in] */ long newVal);


void __RPC_STUB IRipple_put_NumberOfWaves_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IRipple_get_MinSteps_Proxy( 
    IRipple __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IRipple_get_MinSteps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IRipple_put_MinSteps_Proxy( 
    IRipple __RPC_FAR * This,
    /* [in] */ long newVal);


void __RPC_STUB IRipple_put_MinSteps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IRipple_get_MaxSteps_Proxy( 
    IRipple __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IRipple_get_MaxSteps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IRipple_put_MaxSteps_Proxy( 
    IRipple __RPC_FAR * This,
    /* [in] */ long newVal);


void __RPC_STUB IRipple_put_MaxSteps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRipple_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxtmsft3_0285 */
/* [local] */ 

typedef 
enum HeightFieldDISPID
    {	DISPID_HeightField_Width	= DISPID_DXE_NEXT_ID,
	DISPID_HeightField_Height	= DISPID_HeightField_Width + 1,
	DISPID_HeightField_Depth	= DISPID_HeightField_Height + 1,
	DISPID_HeightField_Samples	= DISPID_HeightField_Depth + 1
    }	HeightFieldDISPID;



extern RPC_IF_HANDLE __MIDL_itf_dxtmsft3_0285_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtmsft3_0285_v0_0_s_ifspec;

#ifndef __IHeightField_INTERFACE_DEFINED__
#define __IHeightField_INTERFACE_DEFINED__

/* interface IHeightField */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IHeightField;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0492170A-B159-11d1-9207-0000F8758E66")
    IHeightField : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Width( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Width( 
            /* [in] */ float newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Height( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Height( 
            /* [in] */ float newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Depth( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Depth( 
            /* [in] */ float newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Samples( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Samples( 
            /* [in] */ long newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHeightFieldVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IHeightField __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IHeightField __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IHeightField __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IHeightField __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IHeightField __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IHeightField __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IHeightField __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            IHeightField __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            IHeightField __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            IHeightField __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            IHeightField __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            IHeightField __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            IHeightField __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Width )( 
            IHeightField __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Width )( 
            IHeightField __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Height )( 
            IHeightField __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Height )( 
            IHeightField __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Depth )( 
            IHeightField __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Depth )( 
            IHeightField __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Samples )( 
            IHeightField __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Samples )( 
            IHeightField __RPC_FAR * This,
            /* [in] */ long newVal);
        
        END_INTERFACE
    } IHeightFieldVtbl;

    interface IHeightField
    {
        CONST_VTBL struct IHeightFieldVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHeightField_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHeightField_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHeightField_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHeightField_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IHeightField_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IHeightField_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IHeightField_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IHeightField_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IHeightField_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IHeightField_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IHeightField_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IHeightField_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IHeightField_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define IHeightField_get_Width(This,pVal)	\
    (This)->lpVtbl -> get_Width(This,pVal)

#define IHeightField_put_Width(This,newVal)	\
    (This)->lpVtbl -> put_Width(This,newVal)

#define IHeightField_get_Height(This,pVal)	\
    (This)->lpVtbl -> get_Height(This,pVal)

#define IHeightField_put_Height(This,newVal)	\
    (This)->lpVtbl -> put_Height(This,newVal)

#define IHeightField_get_Depth(This,pVal)	\
    (This)->lpVtbl -> get_Depth(This,pVal)

#define IHeightField_put_Depth(This,newVal)	\
    (This)->lpVtbl -> put_Depth(This,newVal)

#define IHeightField_get_Samples(This,pVal)	\
    (This)->lpVtbl -> get_Samples(This,pVal)

#define IHeightField_put_Samples(This,newVal)	\
    (This)->lpVtbl -> put_Samples(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IHeightField_get_Width_Proxy( 
    IHeightField __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB IHeightField_get_Width_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IHeightField_put_Width_Proxy( 
    IHeightField __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IHeightField_put_Width_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IHeightField_get_Height_Proxy( 
    IHeightField __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB IHeightField_get_Height_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IHeightField_put_Height_Proxy( 
    IHeightField __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IHeightField_put_Height_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IHeightField_get_Depth_Proxy( 
    IHeightField __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB IHeightField_get_Depth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IHeightField_put_Depth_Proxy( 
    IHeightField __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IHeightField_put_Depth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IHeightField_get_Samples_Proxy( 
    IHeightField __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IHeightField_get_Samples_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IHeightField_put_Samples_Proxy( 
    IHeightField __RPC_FAR * This,
    /* [in] */ long newVal);


void __RPC_STUB IHeightField_put_Samples_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHeightField_INTERFACE_DEFINED__ */


#ifndef __IDXTMetaStream_INTERFACE_DEFINED__
#define __IDXTMetaStream_INTERFACE_DEFINED__

/* interface IDXTMetaStream */
/* [unique][helpstring][local][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTMetaStream;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("48654BC0-E51F-11D1-AA1C-00600895FB99")
    IDXTMetaStream : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_DXTurl( 
            /* [retval][out] */ BSTR __RPC_FAR *pURL) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_DXTurl( 
            /* [in] */ BSTR newURL) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_DXTAutoScale( 
            /* [in] */ VARIANT_BOOL flag) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_DXTAutoScale( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *flag) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_DXTquality( 
            /* [in] */ float flag) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_DXTquality( 
            /* [retval][out] */ float __RPC_FAR *flag) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTMetaStreamVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTMetaStream __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTMetaStream __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTMetaStream __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDXTMetaStream __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDXTMetaStream __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDXTMetaStream __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDXTMetaStream __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DXTurl )( 
            IDXTMetaStream __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pURL);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_DXTurl )( 
            IDXTMetaStream __RPC_FAR * This,
            /* [in] */ BSTR newURL);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_DXTAutoScale )( 
            IDXTMetaStream __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL flag);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DXTAutoScale )( 
            IDXTMetaStream __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *flag);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_DXTquality )( 
            IDXTMetaStream __RPC_FAR * This,
            /* [in] */ float flag);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DXTquality )( 
            IDXTMetaStream __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *flag);
        
        END_INTERFACE
    } IDXTMetaStreamVtbl;

    interface IDXTMetaStream
    {
        CONST_VTBL struct IDXTMetaStreamVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTMetaStream_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTMetaStream_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTMetaStream_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTMetaStream_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTMetaStream_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTMetaStream_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTMetaStream_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTMetaStream_get_DXTurl(This,pURL)	\
    (This)->lpVtbl -> get_DXTurl(This,pURL)

#define IDXTMetaStream_put_DXTurl(This,newURL)	\
    (This)->lpVtbl -> put_DXTurl(This,newURL)

#define IDXTMetaStream_put_DXTAutoScale(This,flag)	\
    (This)->lpVtbl -> put_DXTAutoScale(This,flag)

#define IDXTMetaStream_get_DXTAutoScale(This,flag)	\
    (This)->lpVtbl -> get_DXTAutoScale(This,flag)

#define IDXTMetaStream_put_DXTquality(This,flag)	\
    (This)->lpVtbl -> put_DXTquality(This,flag)

#define IDXTMetaStream_get_DXTquality(This,flag)	\
    (This)->lpVtbl -> get_DXTquality(This,flag)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTMetaStream_get_DXTurl_Proxy( 
    IDXTMetaStream __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pURL);


void __RPC_STUB IDXTMetaStream_get_DXTurl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTMetaStream_put_DXTurl_Proxy( 
    IDXTMetaStream __RPC_FAR * This,
    /* [in] */ BSTR newURL);


void __RPC_STUB IDXTMetaStream_put_DXTurl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTMetaStream_put_DXTAutoScale_Proxy( 
    IDXTMetaStream __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL flag);


void __RPC_STUB IDXTMetaStream_put_DXTAutoScale_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTMetaStream_get_DXTAutoScale_Proxy( 
    IDXTMetaStream __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *flag);


void __RPC_STUB IDXTMetaStream_get_DXTAutoScale_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTMetaStream_put_DXTquality_Proxy( 
    IDXTMetaStream __RPC_FAR * This,
    /* [in] */ float flag);


void __RPC_STUB IDXTMetaStream_put_DXTquality_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTMetaStream_get_DXTquality_Proxy( 
    IDXTMetaStream __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *flag);


void __RPC_STUB IDXTMetaStream_get_DXTquality_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTMetaStream_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxtmsft3_0287 */
/* [local] */ 

typedef 
enum DXTText3DDISPID
    {	DISPID_DXTText3D_String	= DISPID_DXE_NEXT_ID,
	DISPID_DXTText3D_FontFace	= DISPID_DXTText3D_String + 1,
	DISPID_DXTText3D_FontWeight	= DISPID_DXTText3D_FontFace + 1,
	DISPID_DXTText3D_FontStyle	= DISPID_DXTText3D_FontWeight + 1,
	DISPID_DXTText3D_Vertical	= DISPID_DXTText3D_FontStyle + 1,
	DISPID_DXTText3D_ExtrusionType	= DISPID_DXTText3D_Vertical + 1,
	DISPID_DXTText3D_XAlign	= DISPID_DXTText3D_ExtrusionType + 1,
	DISPID_DXTText3D_YAlign	= DISPID_DXTText3D_XAlign + 1,
	DISPID_DXTText3D_ZAlign	= DISPID_DXTText3D_YAlign + 1,
	DISPID_DXTText3D_LetterSpacing	= DISPID_DXTText3D_ZAlign + 1,
	DISPID_DXTText3D_Quality	= DISPID_DXTText3D_LetterSpacing + 1
    }	DXTText3DDISPID;



extern RPC_IF_HANDLE __MIDL_itf_dxtmsft3_0287_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtmsft3_0287_v0_0_s_ifspec;

#ifndef __IDXTText3D_INTERFACE_DEFINED__
#define __IDXTText3D_INTERFACE_DEFINED__

/* interface IDXTText3D */
/* [unique][helpstring][local][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTText3D;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("50C4B592-7E8D-11d2-9B4E-00A0C9697CD0")
    IDXTText3D : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_String( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstr) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_String( 
            /* [in] */ BSTR pbstr) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_FontFace( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstr) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_FontFace( 
            /* [in] */ BSTR pbstr) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_FontWeight( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstr) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_FontWeight( 
            /* [in] */ BSTR pbstr) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_FontStyle( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstr) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_FontStyle( 
            /* [in] */ BSTR pbstr) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Vertical( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *fVertical) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Vertical( 
            /* [in] */ VARIANT_BOOL fVertical) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_ExtrusionType( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstr) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_ExtrusionType( 
            /* [in] */ BSTR pbstr) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_XAlign( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstr) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_XAlign( 
            /* [in] */ BSTR pbstr) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_YAlign( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstr) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_YAlign( 
            /* [in] */ BSTR pbstr) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_ZAlign( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstr) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_ZAlign( 
            /* [in] */ BSTR pbstr) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_LetterSpacing( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvarLetterSpacing) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_LetterSpacing( 
            /* [in] */ VARIANT varLetterSpacing) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Quality( 
            /* [retval][out] */ float __RPC_FAR *pflQuality) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Quality( 
            /* [in] */ float flQuality) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTText3DVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTText3D __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTText3D __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTText3D __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDXTText3D __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDXTText3D __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDXTText3D __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDXTText3D __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_String )( 
            IDXTText3D __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstr);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_String )( 
            IDXTText3D __RPC_FAR * This,
            /* [in] */ BSTR pbstr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_FontFace )( 
            IDXTText3D __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstr);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_FontFace )( 
            IDXTText3D __RPC_FAR * This,
            /* [in] */ BSTR pbstr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_FontWeight )( 
            IDXTText3D __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstr);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_FontWeight )( 
            IDXTText3D __RPC_FAR * This,
            /* [in] */ BSTR pbstr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_FontStyle )( 
            IDXTText3D __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstr);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_FontStyle )( 
            IDXTText3D __RPC_FAR * This,
            /* [in] */ BSTR pbstr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Vertical )( 
            IDXTText3D __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *fVertical);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Vertical )( 
            IDXTText3D __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL fVertical);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ExtrusionType )( 
            IDXTText3D __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstr);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ExtrusionType )( 
            IDXTText3D __RPC_FAR * This,
            /* [in] */ BSTR pbstr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_XAlign )( 
            IDXTText3D __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstr);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_XAlign )( 
            IDXTText3D __RPC_FAR * This,
            /* [in] */ BSTR pbstr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_YAlign )( 
            IDXTText3D __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstr);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_YAlign )( 
            IDXTText3D __RPC_FAR * This,
            /* [in] */ BSTR pbstr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ZAlign )( 
            IDXTText3D __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstr);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ZAlign )( 
            IDXTText3D __RPC_FAR * This,
            /* [in] */ BSTR pbstr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_LetterSpacing )( 
            IDXTText3D __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarLetterSpacing);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_LetterSpacing )( 
            IDXTText3D __RPC_FAR * This,
            /* [in] */ VARIANT varLetterSpacing);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Quality )( 
            IDXTText3D __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pflQuality);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Quality )( 
            IDXTText3D __RPC_FAR * This,
            /* [in] */ float flQuality);
        
        END_INTERFACE
    } IDXTText3DVtbl;

    interface IDXTText3D
    {
        CONST_VTBL struct IDXTText3DVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTText3D_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTText3D_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTText3D_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTText3D_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTText3D_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTText3D_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTText3D_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTText3D_get_String(This,pbstr)	\
    (This)->lpVtbl -> get_String(This,pbstr)

#define IDXTText3D_put_String(This,pbstr)	\
    (This)->lpVtbl -> put_String(This,pbstr)

#define IDXTText3D_get_FontFace(This,pbstr)	\
    (This)->lpVtbl -> get_FontFace(This,pbstr)

#define IDXTText3D_put_FontFace(This,pbstr)	\
    (This)->lpVtbl -> put_FontFace(This,pbstr)

#define IDXTText3D_get_FontWeight(This,pbstr)	\
    (This)->lpVtbl -> get_FontWeight(This,pbstr)

#define IDXTText3D_put_FontWeight(This,pbstr)	\
    (This)->lpVtbl -> put_FontWeight(This,pbstr)

#define IDXTText3D_get_FontStyle(This,pbstr)	\
    (This)->lpVtbl -> get_FontStyle(This,pbstr)

#define IDXTText3D_put_FontStyle(This,pbstr)	\
    (This)->lpVtbl -> put_FontStyle(This,pbstr)

#define IDXTText3D_get_Vertical(This,fVertical)	\
    (This)->lpVtbl -> get_Vertical(This,fVertical)

#define IDXTText3D_put_Vertical(This,fVertical)	\
    (This)->lpVtbl -> put_Vertical(This,fVertical)

#define IDXTText3D_get_ExtrusionType(This,pbstr)	\
    (This)->lpVtbl -> get_ExtrusionType(This,pbstr)

#define IDXTText3D_put_ExtrusionType(This,pbstr)	\
    (This)->lpVtbl -> put_ExtrusionType(This,pbstr)

#define IDXTText3D_get_XAlign(This,pbstr)	\
    (This)->lpVtbl -> get_XAlign(This,pbstr)

#define IDXTText3D_put_XAlign(This,pbstr)	\
    (This)->lpVtbl -> put_XAlign(This,pbstr)

#define IDXTText3D_get_YAlign(This,pbstr)	\
    (This)->lpVtbl -> get_YAlign(This,pbstr)

#define IDXTText3D_put_YAlign(This,pbstr)	\
    (This)->lpVtbl -> put_YAlign(This,pbstr)

#define IDXTText3D_get_ZAlign(This,pbstr)	\
    (This)->lpVtbl -> get_ZAlign(This,pbstr)

#define IDXTText3D_put_ZAlign(This,pbstr)	\
    (This)->lpVtbl -> put_ZAlign(This,pbstr)

#define IDXTText3D_get_LetterSpacing(This,pvarLetterSpacing)	\
    (This)->lpVtbl -> get_LetterSpacing(This,pvarLetterSpacing)

#define IDXTText3D_put_LetterSpacing(This,varLetterSpacing)	\
    (This)->lpVtbl -> put_LetterSpacing(This,varLetterSpacing)

#define IDXTText3D_get_Quality(This,pflQuality)	\
    (This)->lpVtbl -> get_Quality(This,pflQuality)

#define IDXTText3D_put_Quality(This,flQuality)	\
    (This)->lpVtbl -> put_Quality(This,flQuality)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTText3D_get_String_Proxy( 
    IDXTText3D __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstr);


void __RPC_STUB IDXTText3D_get_String_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTText3D_put_String_Proxy( 
    IDXTText3D __RPC_FAR * This,
    /* [in] */ BSTR pbstr);


void __RPC_STUB IDXTText3D_put_String_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTText3D_get_FontFace_Proxy( 
    IDXTText3D __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstr);


void __RPC_STUB IDXTText3D_get_FontFace_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTText3D_put_FontFace_Proxy( 
    IDXTText3D __RPC_FAR * This,
    /* [in] */ BSTR pbstr);


void __RPC_STUB IDXTText3D_put_FontFace_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTText3D_get_FontWeight_Proxy( 
    IDXTText3D __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstr);


void __RPC_STUB IDXTText3D_get_FontWeight_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTText3D_put_FontWeight_Proxy( 
    IDXTText3D __RPC_FAR * This,
    /* [in] */ BSTR pbstr);


void __RPC_STUB IDXTText3D_put_FontWeight_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTText3D_get_FontStyle_Proxy( 
    IDXTText3D __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstr);


void __RPC_STUB IDXTText3D_get_FontStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTText3D_put_FontStyle_Proxy( 
    IDXTText3D __RPC_FAR * This,
    /* [in] */ BSTR pbstr);


void __RPC_STUB IDXTText3D_put_FontStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTText3D_get_Vertical_Proxy( 
    IDXTText3D __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *fVertical);


void __RPC_STUB IDXTText3D_get_Vertical_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTText3D_put_Vertical_Proxy( 
    IDXTText3D __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL fVertical);


void __RPC_STUB IDXTText3D_put_Vertical_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTText3D_get_ExtrusionType_Proxy( 
    IDXTText3D __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstr);


void __RPC_STUB IDXTText3D_get_ExtrusionType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTText3D_put_ExtrusionType_Proxy( 
    IDXTText3D __RPC_FAR * This,
    /* [in] */ BSTR pbstr);


void __RPC_STUB IDXTText3D_put_ExtrusionType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTText3D_get_XAlign_Proxy( 
    IDXTText3D __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstr);


void __RPC_STUB IDXTText3D_get_XAlign_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTText3D_put_XAlign_Proxy( 
    IDXTText3D __RPC_FAR * This,
    /* [in] */ BSTR pbstr);


void __RPC_STUB IDXTText3D_put_XAlign_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTText3D_get_YAlign_Proxy( 
    IDXTText3D __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstr);


void __RPC_STUB IDXTText3D_get_YAlign_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTText3D_put_YAlign_Proxy( 
    IDXTText3D __RPC_FAR * This,
    /* [in] */ BSTR pbstr);


void __RPC_STUB IDXTText3D_put_YAlign_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTText3D_get_ZAlign_Proxy( 
    IDXTText3D __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstr);


void __RPC_STUB IDXTText3D_get_ZAlign_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTText3D_put_ZAlign_Proxy( 
    IDXTText3D __RPC_FAR * This,
    /* [in] */ BSTR pbstr);


void __RPC_STUB IDXTText3D_put_ZAlign_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTText3D_get_LetterSpacing_Proxy( 
    IDXTText3D __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarLetterSpacing);


void __RPC_STUB IDXTText3D_get_LetterSpacing_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTText3D_put_LetterSpacing_Proxy( 
    IDXTText3D __RPC_FAR * This,
    /* [in] */ VARIANT varLetterSpacing);


void __RPC_STUB IDXTText3D_put_LetterSpacing_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTText3D_get_Quality_Proxy( 
    IDXTText3D __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pflQuality);


void __RPC_STUB IDXTText3D_get_Quality_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTText3D_put_Quality_Proxy( 
    IDXTText3D __RPC_FAR * This,
    /* [in] */ float flQuality);


void __RPC_STUB IDXTText3D_put_Quality_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTText3D_INTERFACE_DEFINED__ */


#ifndef __IDXTShapes_INTERFACE_DEFINED__
#define __IDXTShapes_INTERFACE_DEFINED__

/* interface IDXTShapes */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTShapes;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8241F013-84D3-11d2-97E6-0000F803FF7A")
    IDXTShapes : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Shape( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Shape( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_XMinRes( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_XMinRes( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_XMaxRes( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_XMaxRes( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_YMinRes( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_YMinRes( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_YMaxRes( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_YMaxRes( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Color( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Color( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_DoubleSided( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_DoubleSided( 
            /* [in] */ VARIANT_BOOL newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_KeepAspectRatio( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_KeepAspectRatio( 
            /* [in] */ VARIANT_BOOL newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTShapesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTShapes __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTShapes __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTShapes __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDXTShapes __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDXTShapes __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDXTShapes __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDXTShapes __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Shape )( 
            IDXTShapes __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Shape )( 
            IDXTShapes __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_XMinRes )( 
            IDXTShapes __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_XMinRes )( 
            IDXTShapes __RPC_FAR * This,
            /* [in] */ long newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_XMaxRes )( 
            IDXTShapes __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_XMaxRes )( 
            IDXTShapes __RPC_FAR * This,
            /* [in] */ long newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_YMinRes )( 
            IDXTShapes __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_YMinRes )( 
            IDXTShapes __RPC_FAR * This,
            /* [in] */ long newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_YMaxRes )( 
            IDXTShapes __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_YMaxRes )( 
            IDXTShapes __RPC_FAR * This,
            /* [in] */ long newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Color )( 
            IDXTShapes __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Color )( 
            IDXTShapes __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DoubleSided )( 
            IDXTShapes __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_DoubleSided )( 
            IDXTShapes __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_KeepAspectRatio )( 
            IDXTShapes __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_KeepAspectRatio )( 
            IDXTShapes __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        END_INTERFACE
    } IDXTShapesVtbl;

    interface IDXTShapes
    {
        CONST_VTBL struct IDXTShapesVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTShapes_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTShapes_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTShapes_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTShapes_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTShapes_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTShapes_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTShapes_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTShapes_get_Shape(This,pVal)	\
    (This)->lpVtbl -> get_Shape(This,pVal)

#define IDXTShapes_put_Shape(This,newVal)	\
    (This)->lpVtbl -> put_Shape(This,newVal)

#define IDXTShapes_get_XMinRes(This,pVal)	\
    (This)->lpVtbl -> get_XMinRes(This,pVal)

#define IDXTShapes_put_XMinRes(This,newVal)	\
    (This)->lpVtbl -> put_XMinRes(This,newVal)

#define IDXTShapes_get_XMaxRes(This,pVal)	\
    (This)->lpVtbl -> get_XMaxRes(This,pVal)

#define IDXTShapes_put_XMaxRes(This,newVal)	\
    (This)->lpVtbl -> put_XMaxRes(This,newVal)

#define IDXTShapes_get_YMinRes(This,pVal)	\
    (This)->lpVtbl -> get_YMinRes(This,pVal)

#define IDXTShapes_put_YMinRes(This,newVal)	\
    (This)->lpVtbl -> put_YMinRes(This,newVal)

#define IDXTShapes_get_YMaxRes(This,pVal)	\
    (This)->lpVtbl -> get_YMaxRes(This,pVal)

#define IDXTShapes_put_YMaxRes(This,newVal)	\
    (This)->lpVtbl -> put_YMaxRes(This,newVal)

#define IDXTShapes_get_Color(This,pVal)	\
    (This)->lpVtbl -> get_Color(This,pVal)

#define IDXTShapes_put_Color(This,newVal)	\
    (This)->lpVtbl -> put_Color(This,newVal)

#define IDXTShapes_get_DoubleSided(This,pVal)	\
    (This)->lpVtbl -> get_DoubleSided(This,pVal)

#define IDXTShapes_put_DoubleSided(This,newVal)	\
    (This)->lpVtbl -> put_DoubleSided(This,newVal)

#define IDXTShapes_get_KeepAspectRatio(This,pVal)	\
    (This)->lpVtbl -> get_KeepAspectRatio(This,pVal)

#define IDXTShapes_put_KeepAspectRatio(This,newVal)	\
    (This)->lpVtbl -> put_KeepAspectRatio(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTShapes_get_Shape_Proxy( 
    IDXTShapes __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IDXTShapes_get_Shape_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTShapes_put_Shape_Proxy( 
    IDXTShapes __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IDXTShapes_put_Shape_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTShapes_get_XMinRes_Proxy( 
    IDXTShapes __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IDXTShapes_get_XMinRes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTShapes_put_XMinRes_Proxy( 
    IDXTShapes __RPC_FAR * This,
    /* [in] */ long newVal);


void __RPC_STUB IDXTShapes_put_XMinRes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTShapes_get_XMaxRes_Proxy( 
    IDXTShapes __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IDXTShapes_get_XMaxRes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTShapes_put_XMaxRes_Proxy( 
    IDXTShapes __RPC_FAR * This,
    /* [in] */ long newVal);


void __RPC_STUB IDXTShapes_put_XMaxRes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTShapes_get_YMinRes_Proxy( 
    IDXTShapes __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IDXTShapes_get_YMinRes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTShapes_put_YMinRes_Proxy( 
    IDXTShapes __RPC_FAR * This,
    /* [in] */ long newVal);


void __RPC_STUB IDXTShapes_put_YMinRes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTShapes_get_YMaxRes_Proxy( 
    IDXTShapes __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IDXTShapes_get_YMaxRes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTShapes_put_YMaxRes_Proxy( 
    IDXTShapes __RPC_FAR * This,
    /* [in] */ long newVal);


void __RPC_STUB IDXTShapes_put_YMaxRes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTShapes_get_Color_Proxy( 
    IDXTShapes __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IDXTShapes_get_Color_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTShapes_put_Color_Proxy( 
    IDXTShapes __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IDXTShapes_put_Color_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTShapes_get_DoubleSided_Proxy( 
    IDXTShapes __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);


void __RPC_STUB IDXTShapes_get_DoubleSided_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTShapes_put_DoubleSided_Proxy( 
    IDXTShapes __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL newVal);


void __RPC_STUB IDXTShapes_put_DoubleSided_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTShapes_get_KeepAspectRatio_Proxy( 
    IDXTShapes __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);


void __RPC_STUB IDXTShapes_get_KeepAspectRatio_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTShapes_put_KeepAspectRatio_Proxy( 
    IDXTShapes __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL newVal);


void __RPC_STUB IDXTShapes_put_KeepAspectRatio_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTShapes_INTERFACE_DEFINED__ */



#ifndef __DXTMSFT3Lib_LIBRARY_DEFINED__
#define __DXTMSFT3Lib_LIBRARY_DEFINED__

/* library DXTMSFT3Lib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_DXTMSFT3Lib;

EXTERN_C const CLSID CLSID_Explode;

#ifdef __cplusplus

class DECLSPEC_UUID("141DBAF1-55FB-11D1-B83E-00A0C933BE86")
Explode;
#endif

EXTERN_C const CLSID CLSID_ExplodeProp;

#ifdef __cplusplus

class DECLSPEC_UUID("C53059E1-E6E3-11d1-BA12-00C04FB6BD36")
ExplodeProp;
#endif

EXTERN_C const CLSID CLSID_Ripple;

#ifdef __cplusplus

class DECLSPEC_UUID("945F5842-3A8D-11D1-9037-00C04FD9189D")
Ripple;
#endif

EXTERN_C const CLSID CLSID_RipProp;

#ifdef __cplusplus

class DECLSPEC_UUID("945F5843-3A8D-11D1-9037-00C04FD9189D")
RipProp;
#endif

EXTERN_C const CLSID CLSID_HeightField;

#ifdef __cplusplus

class DECLSPEC_UUID("04921709-B159-11d1-9207-0000F8758E66")
HeightField;
#endif

EXTERN_C const CLSID CLSID_HtFieldProp;

#ifdef __cplusplus

class DECLSPEC_UUID("7A8402E3-FBD6-11D1-B5E0-00AA003B6061")
HtFieldProp;
#endif

EXTERN_C const CLSID CLSID_DXTMetaStream;

#ifdef __cplusplus

class DECLSPEC_UUID("60A0C080-E505-11D1-AA1C-00600895FB99")
DXTMetaStream;
#endif

EXTERN_C const CLSID CLSID_DXTMetaStreamProp;

#ifdef __cplusplus

class DECLSPEC_UUID("E3D77340-E505-11D1-AA1C-00600895FB99")
DXTMetaStreamProp;
#endif

EXTERN_C const CLSID CLSID_DXTText3D;

#ifdef __cplusplus

class DECLSPEC_UUID("D56F34F2-7E89-11d2-9B4E-00A0C9697CD0")
DXTText3D;
#endif

EXTERN_C const CLSID CLSID_DXTText3DPP;

#ifdef __cplusplus

class DECLSPEC_UUID("50C4B593-7E8D-11d2-9B4E-00A0C9697CD0")
DXTText3DPP;
#endif

EXTERN_C const CLSID CLSID_CrShatter;

#ifdef __cplusplus

class DECLSPEC_UUID("63500AE2-0858-11D2-8CE4-00C04F8ECB10")
CrShatter;
#endif

EXTERN_C const CLSID CLSID_CrShatterPP;

#ifdef __cplusplus

class DECLSPEC_UUID("99275F01-102E-11d2-8B82-00A0C93C09B2")
CrShatterPP;
#endif

EXTERN_C const CLSID CLSID_DXTBlackHole;

#ifdef __cplusplus

class DECLSPEC_UUID("C3853C22-3F2E-11D2-9900-0000F803FF7A")
DXTBlackHole;
#endif

EXTERN_C const CLSID CLSID_DXTBlackHolePP;

#ifdef __cplusplus

class DECLSPEC_UUID("C3853C23-3F2E-11D2-9900-0000F803FF7A")
DXTBlackHolePP;
#endif

EXTERN_C const CLSID CLSID_DXTRoll;

#ifdef __cplusplus

class DECLSPEC_UUID("78F30B82-48AA-11D2-9900-0000F803FF7A")
DXTRoll;
#endif

EXTERN_C const CLSID CLSID_DXTRollPP;

#ifdef __cplusplus

class DECLSPEC_UUID("78F30B83-48AA-11D2-9900-0000F803FF7A")
DXTRollPP;
#endif

EXTERN_C const CLSID CLSID_DXTSpin;

#ifdef __cplusplus

class DECLSPEC_UUID("3D2807C2-43DE-11D2-9900-0000F803FF7A")
DXTSpin;
#endif

EXTERN_C const CLSID CLSID_DXTSpinPP;

#ifdef __cplusplus

class DECLSPEC_UUID("3D2807C3-43DE-11D2-9900-0000F803FF7A")
DXTSpinPP;
#endif

EXTERN_C const CLSID CLSID_DXTShapes;

#ifdef __cplusplus

class DECLSPEC_UUID("8241F015-84D3-11d2-97E6-0000F803FF7A")
DXTShapes;
#endif

EXTERN_C const CLSID CLSID_DXTShapesPP;

#ifdef __cplusplus

class DECLSPEC_UUID("8241F016-84D3-11d2-97E6-0000F803FF7A")
DXTShapesPP;
#endif
#endif /* __DXTMSFT3Lib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\Dxvector.h ===
/*******************************************************************************
* DXVector.h *
*------------*
*   Description:
*       This is the header file for the vector helper classes.
*
*******************************************************************************/
#ifndef DXVector_h
#define DXVector_h

//=== Constants ====================================================


//=== Class, Struct and Union Definitions ==========================

/*** CDXVec ************
*   This template implements basic vector operations for each of the
*   union types
*/
#define CDXV_C CDXVec<TYPE, eBndType>
#define CDXV_T ((TYPE*)u.D)
#define CDXV_O( OtherVec ) ((TYPE*)OtherVec.u.D)

template<class TYPE, DXBNDTYPE eBndType>
class CDXVec : public DXVEC
{
  /*=== Methods =======*/
  public:
    /*--- Constructors ---*/
    CDXVec() { eType = eBndType; ZeroVector(); }
    CDXVec(BOOL bInit) { eType = eBndType; if (bInit) ZeroVector(); }
    CDXVec( TYPE x, TYPE y, TYPE z, TYPE t )
        { eType = eBndType; CDXV_T[DXB_X] = x; CDXV_T[DXB_Y] = y;
                            CDXV_T[DXB_Z] = z; CDXV_T[DXB_T] = t; }
    CDXVec( const CDXVec& Other ) { memcpy( this, (void *)&Other, sizeof(DXVEC) ); }
    CDXVec( const DXVEC Other ) { memcpy( this, &Other, sizeof(DXVEC) ); }
    operator TYPE *() { return CDXV_T; }
    operator const TYPE *() { return CDXV_T; }

    /*--- operations ---*/
    void ZeroVector( void ) { memset( u.D, 0, sizeof(TYPE) * 4); }

    /*--- operators ---*/
    TYPE&  operator[]( int index ) const { return CDXV_T[index]; }
    TYPE&  operator[]( long index ) const { return CDXV_T[index]; }
    TYPE&  operator[]( USHORT index ) const { return CDXV_T[index]; }
    TYPE&  operator[]( DWORD index ) const { return CDXV_T[index]; }
    CDXV_C operator+(const CDXV_C& v);
    CDXV_C operator-(const CDXV_C& v);
    void   operator=(const CDXV_C& srcVector);
    void   operator+=(const CDXV_C& vOther);
    void   operator-=(const CDXV_C& vOther);
    BOOL   operator==(const CDXV_C& otherVector) const;
    BOOL   operator!=(const CDXV_C& otherVector) const;
};

template<class TYPE, DXBNDTYPE eBndType>
CDXV_C CDXV_C::operator+( const CDXV_C& srcVector )
{
    CDXV_C Result( this );
    CDXV_O( Result )[DXB_X] += CDXV_O( srcVector )[DXB_X];
    CDXV_O( Result )[DXB_Y] += CDXV_O( srcVector )[DXB_Y];
    CDXV_O( Result )[DXB_Z] += CDXV_O( srcVector )[DXB_Z];
    CDXV_O( Result )[DXB_T] += CDXV_O( srcVector )[DXB_T];
    return Result;
} /* CDXVec::operator+ */

template<class TYPE, DXBNDTYPE eBndType>
CDXV_C CDXV_C::operator-( const CDXV_C& srcVector )
{
    CDXV_C Result( this );
    CDXV_O( Result )[DXB_X] -= CDXV_O( srcVector )[DXB_X];
    CDXV_O( Result )[DXB_Y] -= CDXV_O( srcVector )[DXB_Y];
    CDXV_O( Result )[DXB_Z] -= CDXV_O( srcVector )[DXB_Z];
    CDXV_O( Result )[DXB_T] -= CDXV_O( srcVector )[DXB_T];
    return Result;
} /* CDXVec::operator- */

template<class TYPE, DXBNDTYPE eBndType>
void CDXV_C::operator=( const CDXV_C& srcVector )
{
    memcpy( this, &srcVector, sizeof(CDXVec) );
} /* CDXVec::operator= */

template<class TYPE, DXBNDTYPE eBndType>
BOOL CDXV_C::operator==(const CDXV_C& otherVector) const
{
    return !memcmp( this, &otherVector, sizeof(otherVector) );
} /* CDXVec::operator== */

template<class TYPE, DXBNDTYPE eBndType>
BOOL CDXV_C::operator!=(const CDXV_C& otherVector) const
{
    return memcmp( this, &otherVector, sizeof(otherVector) );
} /* CDXVec::operator!= */

template<class TYPE, DXBNDTYPE eBndType>
void CDXV_C::operator+=(const CDXV_C& vOther)
{
    CDXV_T[DXB_X] += CDXV_O( vOther )[DXB_X];
    CDXV_T[DXB_Y] += CDXV_O( vOther )[DXB_Y];
    CDXV_T[DXB_Z] += CDXV_O( vOther )[DXB_Z];
    CDXV_T[DXB_T] += CDXV_O( vOther )[DXB_T];
} /* CDXVec::operator+= */

template<class TYPE, DXBNDTYPE eBndType>
void CDXV_C::operator-=(const CDXVec& vOther)
{
    CDXV_T[DXB_X] -= CDXV_O( vOther )[DXB_X];
    CDXV_T[DXB_Y] -= CDXV_O( vOther )[DXB_Y];
    CDXV_T[DXB_Z] -= CDXV_O( vOther )[DXB_Z];
    CDXV_T[DXB_T] -= CDXV_O( vOther )[DXB_T];
} /* CDXVec::operator-= */

typedef CDXVec<long, DXBT_DISCRETE> CDXDVec;
typedef CDXVec<LONGLONG, DXBT_DISCRETE64> CDXDVec64;
typedef CDXVec<float, DXBT_CONTINUOUS> CDXCVec;
typedef CDXVec<double, DXBT_CONTINUOUS64> CDXCVec64;

#endif  // DXVector_h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\DxtmsftGuid.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0328 */
/* Compiler settings for dxtmsft.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IDXLUTBuilder,0xF4370FC1,0xCADB,0x11D0,0xB5,0x2C,0x00,0xA0,0xC9,0x05,0x43,0x73);


MIDL_DEFINE_GUID(IID, IID_IDXDLUTBuilder,0x73068231,0x35EE,0x11d1,0x81,0xA1,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(IID, IID_IDXTGradientD,0x623E2881,0xFC0E,0x11d1,0x9A,0x77,0x00,0x00,0xF8,0x75,0x6A,0x10);


MIDL_DEFINE_GUID(IID, IID_IDXTConvolution,0x7BA7F8AF,0xE5EA,0x11d1,0x81,0xDD,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(IID, IID_IDXMapper,0x555278E5,0x05DB,0x11D1,0x88,0x3A,0x3C,0x8B,0x00,0xC1,0x00,0x00);


MIDL_DEFINE_GUID(IID, IID_IDXDMapper,0x7FD9088B,0x35ED,0x11d1,0x81,0xA1,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(IID, IID_IDXTComposite,0x9A43A843,0x0831,0x11D1,0x81,0x7F,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(IID, IID_IDXTWipe,0xAF279B2F,0x86EB,0x11D1,0x81,0xBF,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(IID, IID_IDXTWipe2,0xE1FF8091,0x442B,0x4801,0x88,0xB6,0x2B,0x47,0xB1,0x61,0x1F,0xD2);


MIDL_DEFINE_GUID(IID, IID_ICrBlur,0x9F7C7827,0xE87A,0x11d1,0x81,0xE0,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(IID, IID_ICrEngrave,0xE4ACFB7F,0x053E,0x11d2,0x81,0xEA,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(IID, IID_ICrEmboss,0xE4ACFB80,0x053E,0x11d2,0x81,0xEA,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(IID, IID_IDXTFade,0x16B280C4,0xEE70,0x11D1,0x90,0x66,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXBasicImage,0x16B280C7,0xEE70,0x11D1,0x90,0x66,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXPixelate,0xD33E180F,0xFBE9,0x11d1,0x90,0x6A,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_ICrIris,0x3F69F350,0x0379,0x11D2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(IID, IID_ICrIris2,0xF7B06961,0xBA8C,0x4970,0x91,0x8B,0x1C,0x60,0xCB,0x9F,0xF1,0x80);


MIDL_DEFINE_GUID(IID, IID_ICrSlide,0x810E402E,0x056B,0x11D2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(IID, IID_ICrRadialWipe,0x424B71AE,0x0695,0x11D2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(IID, IID_ICrBarn,0x276A2EE0,0x0B5D,0x11D2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(IID, IID_ICrBarn2,0xB66A7A1B,0x8FC6,0x448C,0xA2,0xEB,0x3C,0x55,0x95,0x74,0x78,0xA1);


MIDL_DEFINE_GUID(IID, IID_ICrBlinds,0x5AF5C340,0x0BA9,0x11d2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(IID, IID_ICrBlinds2,0x7059D403,0x599A,0x4264,0x81,0x40,0x64,0x1E,0xB8,0xAE,0x1F,0x64);


MIDL_DEFINE_GUID(IID, IID_ICrInset,0x05C5EE20,0x0BA6,0x11d2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(IID, IID_ICrStretch,0x6684AF00,0x0A87,0x11d2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(IID, IID_IDXTGridSize,0xD6BBE91E,0xFF60,0x11d2,0x8F,0x6E,0x00,0xA0,0xC9,0x69,0x72,0x74);


MIDL_DEFINE_GUID(IID, IID_ICrSpiral,0x0DE527A0,0x0C7E,0x11d2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(IID, IID_ICrZigzag,0x4E5A64A0,0x0C8B,0x11d2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(IID, IID_ICrWheel,0x3943DE80,0x1464,0x11d2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(IID, IID_IDXTChroma,0x1D4637E2,0x383C,0x11d2,0x95,0x2A,0x00,0xC0,0x4F,0xA3,0x4F,0x05);


MIDL_DEFINE_GUID(IID, IID_IDXTDropShadow,0x1D4637E3,0x383C,0x11d2,0x95,0x2A,0x00,0xC0,0x4F,0xA3,0x4F,0x05);


MIDL_DEFINE_GUID(IID, IID_IDXTCheckerBoard,0xAD3C2576,0x117C,0x4510,0x84,0xDD,0xB6,0x68,0x97,0x1D,0xCF,0xD1);


MIDL_DEFINE_GUID(IID, IID_IDXTRevealTrans,0xB8095006,0xA128,0x464B,0x8B,0x2D,0x90,0x58,0x0A,0xEE,0x2B,0x05);


MIDL_DEFINE_GUID(IID, IID_IDXTMask,0xA1067146,0xB063,0x47d7,0xA5,0x4A,0x2C,0x23,0x09,0xE9,0x88,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXTRedirect,0x02F5140B,0x626F,0x4019,0x9C,0x9E,0x2D,0xAA,0x1E,0x93,0xE8,0xFC);


MIDL_DEFINE_GUID(IID, IID_IDXTAlphaImageLoader,0xA5F2D3E8,0x7A7E,0x48E5,0xBC,0x75,0x40,0x79,0x0B,0xE4,0xA9,0x41);


MIDL_DEFINE_GUID(IID, IID_IDXTRandomBars,0x8A6D2022,0x4A8F,0x4EB9,0xBB,0x25,0xAA,0x05,0x20,0x1F,0x9C,0x84);


MIDL_DEFINE_GUID(IID, IID_IDXTStrips,0xA83C9B5C,0xFB11,0x4AF5,0x8F,0x65,0xD0,0x3F,0x15,0x1D,0x3E,0xD5);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaRoll,0x9C61F46D,0x0530,0x11D2,0x8F,0x98,0x00,0xC0,0x4F,0xB9,0x2E,0xB7);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaRipple,0xAA0D4D02,0x06A3,0x11D2,0x8F,0x98,0x00,0xC0,0x4F,0xB9,0x2E,0xB7);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaPageTurn,0xAA0D4D07,0x06A3,0x11D2,0x8F,0x98,0x00,0xC0,0x4F,0xB9,0x2E,0xB7);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaLiquid,0xAA0D4D09,0x06A3,0x11D2,0x8F,0x98,0x00,0xC0,0x4F,0xB9,0x2E,0xB7);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaCenterPeel,0xAA0D4D0B,0x06A3,0x11D2,0x8F,0x98,0x00,0xC0,0x4F,0xB9,0x2E,0xB7);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaPeelSmall,0xAA0D4D0D,0x06A3,0x11D2,0x8F,0x98,0x00,0xC0,0x4F,0xB9,0x2E,0xB7);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaPeelPiece,0xAA0D4D0F,0x06A3,0x11D2,0x8F,0x98,0x00,0xC0,0x4F,0xB9,0x2E,0xB7);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaPeelSplit,0xAA0D4D11,0x06A3,0x11D2,0x8F,0x98,0x00,0xC0,0x4F,0xB9,0x2E,0xB7);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaWater,0x107045C4,0x06E0,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaLightWipe,0x107045C7,0x06E0,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaRadialScaleWipe,0x107045C9,0x06E0,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaWhiteOut,0x107045CB,0x06E0,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaTwister,0x107045CE,0x06E0,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaBurnFilm,0x107045D0,0x06E0,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaJaws,0x2A54C903,0x07AA,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaColorFade,0x2A54C907,0x07AA,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaFlowMotion,0x2A54C90A,0x07AA,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaVacuum,0x2A54C90C,0x07AA,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaGriddler,0x2A54C910,0x07AA,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaGriddler2,0x2A54C912,0x07AA,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaThreshold,0x2A54C914,0x07AA,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaWormHole,0x0E6AE021,0x0C83,0x11D2,0x8C,0xD4,0x00,0x10,0x4B,0xC7,0x5D,0x9A);


MIDL_DEFINE_GUID(IID, IID_IDXTAlpha,0x1D4637E0,0x383C,0x11d2,0x95,0x2A,0x00,0xC0,0x4F,0xA3,0x4F,0x05);


MIDL_DEFINE_GUID(IID, IID_IDXTGlow,0x1D4637E4,0x383C,0x11d2,0x95,0x2A,0x00,0xC0,0x4F,0xA3,0x4F,0x05);


MIDL_DEFINE_GUID(IID, IID_IDXTShadow,0x1D4637E6,0x383C,0x11d2,0x95,0x2A,0x00,0xC0,0x4F,0xA3,0x4F,0x05);


MIDL_DEFINE_GUID(IID, IID_IDXTWave,0x1D4637E7,0x383C,0x11d2,0x95,0x2A,0x00,0xC0,0x4F,0xA3,0x4F,0x05);


MIDL_DEFINE_GUID(IID, IID_IDXTLight,0xF9EFBEC1,0x4302,0x11D2,0x95,0x2A,0x00,0xC0,0x4F,0xA3,0x4F,0x05);


MIDL_DEFINE_GUID(IID, IID_IDXTMotionBlur,0x089057BE,0xD3F5,0x4A2C,0xB1,0x0A,0xA5,0x13,0x01,0x84,0xA0,0xF7);


MIDL_DEFINE_GUID(IID, IID_IDXTMatrix,0xAC66A493,0x0F0C,0x4C76,0x82,0x5C,0x9D,0x68,0xBE,0xDE,0x91,0x88);


MIDL_DEFINE_GUID(IID, IID_IDXTICMFilter,0x734321ED,0x1E7B,0x4E1C,0xBB,0xFA,0x89,0xC8,0x19,0x80,0x0E,0x2F);


MIDL_DEFINE_GUID(IID, LIBID_DXTMSFTLib,0x5E77EB03,0x937C,0x11D1,0xB0,0x47,0x00,0xAA,0x00,0x3B,0x60,0x61);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTComposite,0x9A43A844,0x0831,0x11D1,0x81,0x7F,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(CLSID, CLSID_DXLUTBuilder,0x1E54333B,0x2A00,0x11d1,0x81,0x98,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTGradientD,0x623E2882,0xFC0E,0x11d1,0x9A,0x77,0x00,0x00,0xF8,0x75,0x6A,0x10);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTWipe,0xAF279B30,0x86EB,0x11D1,0x81,0xBF,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTGradientWipe,0xB96F67A2,0x30C2,0x47E8,0xBD,0x85,0x70,0xA2,0xC9,0x48,0xB5,0x0F);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTWipePP,0x7FFE4D08,0xFBFD,0x11d1,0x9A,0x77,0x00,0x00,0xF8,0x75,0x6A,0x10);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTConvolution,0x2BC0EF29,0xE6BA,0x11d1,0x81,0xDD,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(CLSID, CLSID_CrBlur,0x7312498D,0xE87A,0x11d1,0x81,0xE0,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(CLSID, CLSID_CrEmboss,0xF515306D,0x0156,0x11d2,0x81,0xEA,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(CLSID, CLSID_CrEngrave,0xF515306E,0x0156,0x11d2,0x81,0xEA,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(CLSID, CLSID_DXFade,0x16B280C5,0xEE70,0x11D1,0x90,0x66,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(CLSID, CLSID_FadePP,0x16B280C6,0xEE70,0x11D1,0x90,0x66,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(CLSID, CLSID_BasicImageEffects,0x16B280C8,0xEE70,0x11D1,0x90,0x66,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(CLSID, CLSID_BasicImageEffectsPP,0x16B280C9,0xEE70,0x11D1,0x90,0x66,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(CLSID, CLSID_Pixelate,0x4CCEA634,0xFBE0,0x11d1,0x90,0x6A,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(CLSID, CLSID_PixelatePP,0x4CCEA635,0xFBE0,0x11d1,0x90,0x6A,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(CLSID, CLSID_CrBlurPP,0x623E287E,0xFC0E,0x11d1,0x9A,0x77,0x00,0x00,0xF8,0x75,0x6A,0x10);


MIDL_DEFINE_GUID(CLSID, CLSID_GradientPP,0x623E2880,0xFC0E,0x11d1,0x9A,0x77,0x00,0x00,0xF8,0x75,0x6A,0x10);


MIDL_DEFINE_GUID(CLSID, CLSID_CompositePP,0x25B33660,0xFD83,0x11d1,0x8A,0xDE,0x44,0x45,0x53,0x54,0x00,0x01);


MIDL_DEFINE_GUID(CLSID, CLSID_ConvolvePP,0x25B33661,0xFD83,0x11d1,0x8A,0xDE,0x44,0x45,0x53,0x54,0x00,0x01);


MIDL_DEFINE_GUID(CLSID, CLSID_LUTBuilderPP,0x25B33662,0xFD83,0x11d1,0x8A,0xDE,0x44,0x45,0x53,0x54,0x00,0x01);


MIDL_DEFINE_GUID(CLSID, CLSID_CrIris,0x3F69F351,0x0379,0x11D2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTIris,0x049F2CE6,0xD996,0x4721,0x89,0x7A,0xDB,0x15,0xCE,0x9E,0xB7,0x3D);


MIDL_DEFINE_GUID(CLSID, CLSID_CrIrisPP,0x80DE22C4,0x0F44,0x11D2,0x8B,0x82,0x00,0xA0,0xC9,0x3C,0x09,0xB2);


MIDL_DEFINE_GUID(CLSID, CLSID_CrSlide,0x810E402F,0x056B,0x11D2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTSlide,0xD1C5A1E7,0xCC47,0x4E32,0xBD,0xD2,0x4B,0x3C,0x5F,0xC5,0x0A,0xF5);


MIDL_DEFINE_GUID(CLSID, CLSID_CrSlidePP,0xCC8CEDE1,0x1003,0x11d2,0x8B,0x82,0x00,0xA0,0xC9,0x3C,0x09,0xB2);


MIDL_DEFINE_GUID(CLSID, CLSID_CrRadialWipe,0x424B71AF,0x0695,0x11D2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTRadialWipe,0x164484A9,0x35D9,0x4FB7,0x9F,0xAB,0x48,0x27,0x3B,0x96,0xAA,0x1D);


MIDL_DEFINE_GUID(CLSID, CLSID_CrRadialWipePP,0x33D932E0,0x0F48,0x11d2,0x8B,0x82,0x00,0xA0,0xC9,0x3C,0x09,0xB2);


MIDL_DEFINE_GUID(CLSID, CLSID_CrBarn,0xC3BDF740,0x0B58,0x11d2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTBarn,0xEC9BA17D,0x60B5,0x462B,0xA6,0xD8,0x14,0xB8,0x90,0x57,0xE2,0x2A);


MIDL_DEFINE_GUID(CLSID, CLSID_CrBarnPP,0xFCAD7436,0xF151,0x4110,0xB9,0x7E,0x32,0xBD,0x60,0x7F,0xBD,0xB8);


MIDL_DEFINE_GUID(CLSID, CLSID_CrBlinds,0x00C429C0,0x0BA9,0x11d2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTBlinds,0x9A4A4A51,0xFB3A,0x4F4B,0x9B,0x57,0xA2,0x91,0x2A,0x28,0x97,0x69);


MIDL_DEFINE_GUID(CLSID, CLSID_CrBlindPP,0x213052C1,0x100D,0x11d2,0x8B,0x82,0x00,0xA0,0xC9,0x3C,0x09,0xB2);


MIDL_DEFINE_GUID(CLSID, CLSID_CrStretch,0x7658F2A2,0x0A83,0x11d2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTStretch,0xF088DE73,0xBDD0,0x4E3C,0x81,0xF8,0x6D,0x32,0xF4,0xFE,0x9D,0x28);


MIDL_DEFINE_GUID(CLSID, CLSID_CrStretchPP,0x15FB95E0,0x0F77,0x11d2,0x8B,0x82,0x00,0xA0,0xC9,0x3C,0x09,0xB2);


MIDL_DEFINE_GUID(CLSID, CLSID_CrInset,0x93073C40,0x0BA5,0x11d2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTInset,0x76F363F2,0x7E9F,0x4ED7,0xA6,0xA7,0xEE,0x30,0x35,0x1B,0x66,0x28);


MIDL_DEFINE_GUID(CLSID, CLSID_CrSpiral,0xACA97E00,0x0C7D,0x11d2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTSpiral,0x4A03DCB9,0x6E17,0x4A39,0x88,0x45,0x4E,0xE7,0xDC,0x53,0x31,0xA5);


MIDL_DEFINE_GUID(CLSID, CLSID_CrSpiralPP,0xC6A4FE81,0x1022,0x11d2,0x8B,0x82,0x00,0xA0,0xC9,0x3C,0x09,0xB2);


MIDL_DEFINE_GUID(CLSID, CLSID_CrZigzag,0xE6E73D20,0x0C8A,0x11D2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTZigzag,0x23E26328,0x3928,0x40F2,0x95,0xE5,0x93,0xCA,0xD6,0x90,0x16,0xEB);


MIDL_DEFINE_GUID(CLSID, CLSID_CrZigzagPP,0x1559A3C1,0x102B,0x11d2,0x8B,0x82,0x00,0xA0,0xC9,0x3C,0x09,0xB2);


MIDL_DEFINE_GUID(CLSID, CLSID_CrWheel,0x5AE1DAE0,0x1461,0x11d2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(CLSID, CLSID_CrWheelPP,0xFA9F6180,0x1464,0x11d2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTChroma,0x421516C1,0x3CF8,0x11D2,0x95,0x2A,0x00,0xC0,0x4F,0xA3,0x4F,0x05);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTChromaPP,0xEC7E0760,0x4C76,0x11D2,0x8A,0xDE,0x00,0xA0,0xC9,0x8E,0x65,0x27);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTDropShadow,0xADC6CB86,0x424C,0x11D2,0x95,0x2A,0x00,0xC0,0x4F,0xA3,0x4F,0x05);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTDropShadowPP,0xEC7E0761,0x4C76,0x11D2,0x8A,0xDE,0x00,0xA0,0xC9,0x8E,0x65,0x27);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTCheckerBoard,0xB3EE7802,0x8224,0x4787,0xA1,0xEA,0xF0,0xDE,0x16,0xDE,0xAB,0xD3);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTCheckerBoardPP,0xCBF47525,0x98D2,0x45ea,0xB8,0x43,0xFD,0x21,0x3D,0x93,0x2B,0x10);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTRevealTrans,0xE31E87C4,0x86EA,0x4940,0x9B,0x8A,0x5B,0xD5,0xD1,0x79,0xA7,0x37);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMaskFilter,0x3A04D93B,0x1EDD,0x4f3f,0xA3,0x75,0xA0,0x3E,0xC1,0x95,0x72,0xC4);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTRedirect,0x42B07B28,0x2280,0x4937,0xB0,0x35,0x02,0x93,0xFB,0x81,0x27,0x81);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTAlphaImageLoader,0x0C7EFBDE,0x0303,0x4C6F,0xA4,0xF7,0x31,0xFA,0x2B,0xE5,0xE3,0x97);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTAlphaImageLoaderPP,0x8C80CE2D,0x850D,0x47DA,0x8E,0xCD,0x55,0x02,0x35,0x62,0xD1,0x67);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTRandomDissolve,0xF7F4A1B6,0x8E87,0x452F,0xA2,0xD7,0x30,0x77,0xF5,0x08,0xDB,0xC0);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTRandomBars,0x2E7700B7,0x27C4,0x437F,0x9F,0xBF,0x1E,0x8B,0xE2,0x81,0x75,0x66);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTStrips,0x63A4B1FC,0x259A,0x4A5B,0x81,0x29,0xA8,0x3B,0x8C,0x9E,0x6F,0x4F);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTStripsPP,0xFEC0B7EE,0x7AEC,0x4067,0x9E,0xE1,0xFA,0xCF,0xB7,0xCE,0x9A,0xF9);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaRoll,0x9C61F46E,0x0530,0x11D2,0x8F,0x98,0x00,0xC0,0x4F,0xB9,0x2E,0xB7);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaRipple,0xAA0D4D03,0x06A3,0x11D2,0x8F,0x98,0x00,0xC0,0x4F,0xB9,0x2E,0xB7);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaPageTurn,0xAA0D4D08,0x06A3,0x11D2,0x8F,0x98,0x00,0xC0,0x4F,0xB9,0x2E,0xB7);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaLiquid,0xAA0D4D0A,0x06A3,0x11D2,0x8F,0x98,0x00,0xC0,0x4F,0xB9,0x2E,0xB7);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaCenterPeel,0xAA0D4D0C,0x06A3,0x11D2,0x8F,0x98,0x00,0xC0,0x4F,0xB9,0x2E,0xB7);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaPeelSmall,0xAA0D4D0E,0x06A3,0x11D2,0x8F,0x98,0x00,0xC0,0x4F,0xB9,0x2E,0xB7);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaPeelPiece,0xAA0D4D10,0x06A3,0x11D2,0x8F,0x98,0x00,0xC0,0x4F,0xB9,0x2E,0xB7);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaPeelSplit,0xAA0D4D12,0x06A3,0x11D2,0x8F,0x98,0x00,0xC0,0x4F,0xB9,0x2E,0xB7);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaWater,0x107045C5,0x06E0,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaLightWipe,0x107045C8,0x06E0,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaRadialScaleWipe,0x107045CA,0x06E0,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaWhiteOut,0x107045CC,0x06E0,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaTwister,0x107045CF,0x06E0,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaBurnFilm,0x107045D1,0x06E0,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaJaws,0x2A54C904,0x07AA,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaColorFade,0x2A54C908,0x07AA,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaFlowMotion,0x2A54C90B,0x07AA,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaVacuum,0x2A54C90D,0x07AA,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaGriddler,0x2A54C911,0x07AA,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaGriddler2,0x2A54C913,0x07AA,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaThreshold,0x2A54C915,0x07AA,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaWormHole,0x0E6AE022,0x0C83,0x11D2,0x8C,0xD4,0x00,0x10,0x4B,0xC7,0x5D,0x9A);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTGlow,0x9F8E6421,0x3D9B,0x11D2,0x95,0x2A,0x00,0xC0,0x4F,0xA3,0x4F,0x05);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTShadow,0xE71B4063,0x3E59,0x11D2,0x95,0x2A,0x00,0xC0,0x4F,0xA3,0x4F,0x05);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTAlpha,0xADC6CB82,0x424C,0x11D2,0x95,0x2A,0x00,0xC0,0x4F,0xA3,0x4F,0x05);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTWave,0xADC6CB88,0x424C,0x11D2,0x95,0x2A,0x00,0xC0,0x4F,0xA3,0x4F,0x05);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTLight,0xF9EFBEC2,0x4302,0x11D2,0x95,0x2A,0x00,0xC0,0x4F,0xA3,0x4F,0x05);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTAlphaPP,0xD687A7E0,0x4BA4,0x11D2,0x8A,0xDE,0x00,0xA0,0xC9,0x8E,0x65,0x27);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTGlowPP,0xEC7E0764,0x4C76,0x11D2,0x8A,0xDE,0x00,0xA0,0xC9,0x8E,0x65,0x27);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTShadowPP,0xEC7E0765,0x4C76,0x11D2,0x8A,0xDE,0x00,0xA0,0xC9,0x8E,0x65,0x27);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTWavePP,0xF12456C0,0x4C9E,0x11D2,0x8A,0xDE,0x00,0xA0,0xC9,0x8E,0x65,0x27);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTLightPP,0x694AF25F,0x124D,0x11d3,0x91,0xD5,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMotionBlur,0xDD13DE77,0xD3BA,0x42D4,0xB5,0xC6,0x77,0x45,0xFA,0x4E,0x2D,0x4B);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMotionBlurPP,0x926433E1,0x7F8F,0x4BC6,0xBE,0xC4,0x8C,0x12,0x6C,0x6B,0x7D,0xC4);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMatrix,0x4ABF5A06,0x5568,0x4834,0xBE,0xE3,0x32,0x7A,0x6D,0x95,0xA6,0x85);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMatrixPP,0xC591103A,0xB3A8,0x4D47,0xA3,0xF7,0x2A,0xEE,0xE4,0xB8,0x01,0x3F);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTICMFilter,0xA1BFB370,0x5A9F,0x4429,0xBB,0x72,0xB1,0x3E,0x2F,0xEA,0xED,0xEF);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTICMFilterPP,0x1958FB12,0x31E6,0x47E5,0xAA,0x49,0xB2,0x3D,0x12,0xC8,0x53,0xE6);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AXP64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0328 */
/* Compiler settings for dxtmsft.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IDXLUTBuilder,0xF4370FC1,0xCADB,0x11D0,0xB5,0x2C,0x00,0xA0,0xC9,0x05,0x43,0x73);


MIDL_DEFINE_GUID(IID, IID_IDXDLUTBuilder,0x73068231,0x35EE,0x11d1,0x81,0xA1,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(IID, IID_IDXTGradientD,0x623E2881,0xFC0E,0x11d1,0x9A,0x77,0x00,0x00,0xF8,0x75,0x6A,0x10);


MIDL_DEFINE_GUID(IID, IID_IDXTConvolution,0x7BA7F8AF,0xE5EA,0x11d1,0x81,0xDD,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(IID, IID_IDXMapper,0x555278E5,0x05DB,0x11D1,0x88,0x3A,0x3C,0x8B,0x00,0xC1,0x00,0x00);


MIDL_DEFINE_GUID(IID, IID_IDXDMapper,0x7FD9088B,0x35ED,0x11d1,0x81,0xA1,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(IID, IID_IDXTComposite,0x9A43A843,0x0831,0x11D1,0x81,0x7F,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(IID, IID_IDXTWipe,0xAF279B2F,0x86EB,0x11D1,0x81,0xBF,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(IID, IID_IDXTWipe2,0xE1FF8091,0x442B,0x4801,0x88,0xB6,0x2B,0x47,0xB1,0x61,0x1F,0xD2);


MIDL_DEFINE_GUID(IID, IID_ICrBlur,0x9F7C7827,0xE87A,0x11d1,0x81,0xE0,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(IID, IID_ICrEngrave,0xE4ACFB7F,0x053E,0x11d2,0x81,0xEA,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(IID, IID_ICrEmboss,0xE4ACFB80,0x053E,0x11d2,0x81,0xEA,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(IID, IID_IDXTFade,0x16B280C4,0xEE70,0x11D1,0x90,0x66,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXBasicImage,0x16B280C7,0xEE70,0x11D1,0x90,0x66,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXPixelate,0xD33E180F,0xFBE9,0x11d1,0x90,0x6A,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_ICrIris,0x3F69F350,0x0379,0x11D2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(IID, IID_ICrIris2,0xF7B06961,0xBA8C,0x4970,0x91,0x8B,0x1C,0x60,0xCB,0x9F,0xF1,0x80);


MIDL_DEFINE_GUID(IID, IID_ICrSlide,0x810E402E,0x056B,0x11D2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(IID, IID_ICrRadialWipe,0x424B71AE,0x0695,0x11D2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(IID, IID_ICrBarn,0x276A2EE0,0x0B5D,0x11D2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(IID, IID_ICrBarn2,0xB66A7A1B,0x8FC6,0x448C,0xA2,0xEB,0x3C,0x55,0x95,0x74,0x78,0xA1);


MIDL_DEFINE_GUID(IID, IID_ICrBlinds,0x5AF5C340,0x0BA9,0x11d2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(IID, IID_ICrBlinds2,0x7059D403,0x599A,0x4264,0x81,0x40,0x64,0x1E,0xB8,0xAE,0x1F,0x64);


MIDL_DEFINE_GUID(IID, IID_ICrInset,0x05C5EE20,0x0BA6,0x11d2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(IID, IID_ICrStretch,0x6684AF00,0x0A87,0x11d2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(IID, IID_IDXTGridSize,0xD6BBE91E,0xFF60,0x11d2,0x8F,0x6E,0x00,0xA0,0xC9,0x69,0x72,0x74);


MIDL_DEFINE_GUID(IID, IID_ICrSpiral,0x0DE527A0,0x0C7E,0x11d2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(IID, IID_ICrZigzag,0x4E5A64A0,0x0C8B,0x11d2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(IID, IID_ICrWheel,0x3943DE80,0x1464,0x11d2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(IID, IID_IDXTChroma,0x1D4637E2,0x383C,0x11d2,0x95,0x2A,0x00,0xC0,0x4F,0xA3,0x4F,0x05);


MIDL_DEFINE_GUID(IID, IID_IDXTDropShadow,0x1D4637E3,0x383C,0x11d2,0x95,0x2A,0x00,0xC0,0x4F,0xA3,0x4F,0x05);


MIDL_DEFINE_GUID(IID, IID_IDXTCheckerBoard,0xAD3C2576,0x117C,0x4510,0x84,0xDD,0xB6,0x68,0x97,0x1D,0xCF,0xD1);


MIDL_DEFINE_GUID(IID, IID_IDXTRevealTrans,0xB8095006,0xA128,0x464B,0x8B,0x2D,0x90,0x58,0x0A,0xEE,0x2B,0x05);


MIDL_DEFINE_GUID(IID, IID_IDXTMask,0xA1067146,0xB063,0x47d7,0xA5,0x4A,0x2C,0x23,0x09,0xE9,0x88,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXTRedirect,0x02F5140B,0x626F,0x4019,0x9C,0x9E,0x2D,0xAA,0x1E,0x93,0xE8,0xFC);


MIDL_DEFINE_GUID(IID, IID_IDXTAlphaImageLoader,0xA5F2D3E8,0x7A7E,0x48E5,0xBC,0x75,0x40,0x79,0x0B,0xE4,0xA9,0x41);


MIDL_DEFINE_GUID(IID, IID_IDXTRandomBars,0x8A6D2022,0x4A8F,0x4EB9,0xBB,0x25,0xAA,0x05,0x20,0x1F,0x9C,0x84);


MIDL_DEFINE_GUID(IID, IID_IDXTStrips,0xA83C9B5C,0xFB11,0x4AF5,0x8F,0x65,0xD0,0x3F,0x15,0x1D,0x3E,0xD5);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaRoll,0x9C61F46D,0x0530,0x11D2,0x8F,0x98,0x00,0xC0,0x4F,0xB9,0x2E,0xB7);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaRipple,0xAA0D4D02,0x06A3,0x11D2,0x8F,0x98,0x00,0xC0,0x4F,0xB9,0x2E,0xB7);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaPageTurn,0xAA0D4D07,0x06A3,0x11D2,0x8F,0x98,0x00,0xC0,0x4F,0xB9,0x2E,0xB7);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaLiquid,0xAA0D4D09,0x06A3,0x11D2,0x8F,0x98,0x00,0xC0,0x4F,0xB9,0x2E,0xB7);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaCenterPeel,0xAA0D4D0B,0x06A3,0x11D2,0x8F,0x98,0x00,0xC0,0x4F,0xB9,0x2E,0xB7);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaPeelSmall,0xAA0D4D0D,0x06A3,0x11D2,0x8F,0x98,0x00,0xC0,0x4F,0xB9,0x2E,0xB7);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaPeelPiece,0xAA0D4D0F,0x06A3,0x11D2,0x8F,0x98,0x00,0xC0,0x4F,0xB9,0x2E,0xB7);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaPeelSplit,0xAA0D4D11,0x06A3,0x11D2,0x8F,0x98,0x00,0xC0,0x4F,0xB9,0x2E,0xB7);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaWater,0x107045C4,0x06E0,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaLightWipe,0x107045C7,0x06E0,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaRadialScaleWipe,0x107045C9,0x06E0,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaWhiteOut,0x107045CB,0x06E0,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaTwister,0x107045CE,0x06E0,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaBurnFilm,0x107045D0,0x06E0,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaJaws,0x2A54C903,0x07AA,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaColorFade,0x2A54C907,0x07AA,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaFlowMotion,0x2A54C90A,0x07AA,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaVacuum,0x2A54C90C,0x07AA,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaGriddler,0x2A54C910,0x07AA,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaGriddler2,0x2A54C912,0x07AA,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaThreshold,0x2A54C914,0x07AA,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaWormHole,0x0E6AE021,0x0C83,0x11D2,0x8C,0xD4,0x00,0x10,0x4B,0xC7,0x5D,0x9A);


MIDL_DEFINE_GUID(IID, IID_IDXTAlpha,0x1D4637E0,0x383C,0x11d2,0x95,0x2A,0x00,0xC0,0x4F,0xA3,0x4F,0x05);


MIDL_DEFINE_GUID(IID, IID_IDXTGlow,0x1D4637E4,0x383C,0x11d2,0x95,0x2A,0x00,0xC0,0x4F,0xA3,0x4F,0x05);


MIDL_DEFINE_GUID(IID, IID_IDXTShadow,0x1D4637E6,0x383C,0x11d2,0x95,0x2A,0x00,0xC0,0x4F,0xA3,0x4F,0x05);


MIDL_DEFINE_GUID(IID, IID_IDXTWave,0x1D4637E7,0x383C,0x11d2,0x95,0x2A,0x00,0xC0,0x4F,0xA3,0x4F,0x05);


MIDL_DEFINE_GUID(IID, IID_IDXTLight,0xF9EFBEC1,0x4302,0x11D2,0x95,0x2A,0x00,0xC0,0x4F,0xA3,0x4F,0x05);


MIDL_DEFINE_GUID(IID, IID_IDXTMotionBlur,0x089057BE,0xD3F5,0x4A2C,0xB1,0x0A,0xA5,0x13,0x01,0x84,0xA0,0xF7);


MIDL_DEFINE_GUID(IID, IID_IDXTMatrix,0xAC66A493,0x0F0C,0x4C76,0x82,0x5C,0x9D,0x68,0xBE,0xDE,0x91,0x88);


MIDL_DEFINE_GUID(IID, IID_IDXTICMFilter,0x734321ED,0x1E7B,0x4E1C,0xBB,0xFA,0x89,0xC8,0x19,0x80,0x0E,0x2F);


MIDL_DEFINE_GUID(IID, LIBID_DXTMSFTLib,0x5E77EB03,0x937C,0x11D1,0xB0,0x47,0x00,0xAA,0x00,0x3B,0x60,0x61);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTComposite,0x9A43A844,0x0831,0x11D1,0x81,0x7F,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(CLSID, CLSID_DXLUTBuilder,0x1E54333B,0x2A00,0x11d1,0x81,0x98,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTGradientD,0x623E2882,0xFC0E,0x11d1,0x9A,0x77,0x00,0x00,0xF8,0x75,0x6A,0x10);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTWipe,0xAF279B30,0x86EB,0x11D1,0x81,0xBF,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTGradientWipe,0xB96F67A2,0x30C2,0x47E8,0xBD,0x85,0x70,0xA2,0xC9,0x48,0xB5,0x0F);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTWipePP,0x7FFE4D08,0xFBFD,0x11d1,0x9A,0x77,0x00,0x00,0xF8,0x75,0x6A,0x10);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTConvolution,0x2BC0EF29,0xE6BA,0x11d1,0x81,0xDD,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(CLSID, CLSID_CrBlur,0x7312498D,0xE87A,0x11d1,0x81,0xE0,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(CLSID, CLSID_CrEmboss,0xF515306D,0x0156,0x11d2,0x81,0xEA,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(CLSID, CLSID_CrEngrave,0xF515306E,0x0156,0x11d2,0x81,0xEA,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(CLSID, CLSID_DXFade,0x16B280C5,0xEE70,0x11D1,0x90,0x66,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(CLSID, CLSID_FadePP,0x16B280C6,0xEE70,0x11D1,0x90,0x66,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(CLSID, CLSID_BasicImageEffects,0x16B280C8,0xEE70,0x11D1,0x90,0x66,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(CLSID, CLSID_BasicImageEffectsPP,0x16B280C9,0xEE70,0x11D1,0x90,0x66,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(CLSID, CLSID_Pixelate,0x4CCEA634,0xFBE0,0x11d1,0x90,0x6A,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(CLSID, CLSID_PixelatePP,0x4CCEA635,0xFBE0,0x11d1,0x90,0x6A,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(CLSID, CLSID_CrBlurPP,0x623E287E,0xFC0E,0x11d1,0x9A,0x77,0x00,0x00,0xF8,0x75,0x6A,0x10);


MIDL_DEFINE_GUID(CLSID, CLSID_GradientPP,0x623E2880,0xFC0E,0x11d1,0x9A,0x77,0x00,0x00,0xF8,0x75,0x6A,0x10);


MIDL_DEFINE_GUID(CLSID, CLSID_CompositePP,0x25B33660,0xFD83,0x11d1,0x8A,0xDE,0x44,0x45,0x53,0x54,0x00,0x01);


MIDL_DEFINE_GUID(CLSID, CLSID_ConvolvePP,0x25B33661,0xFD83,0x11d1,0x8A,0xDE,0x44,0x45,0x53,0x54,0x00,0x01);


MIDL_DEFINE_GUID(CLSID, CLSID_LUTBuilderPP,0x25B33662,0xFD83,0x11d1,0x8A,0xDE,0x44,0x45,0x53,0x54,0x00,0x01);


MIDL_DEFINE_GUID(CLSID, CLSID_CrIris,0x3F69F351,0x0379,0x11D2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTIris,0x049F2CE6,0xD996,0x4721,0x89,0x7A,0xDB,0x15,0xCE,0x9E,0xB7,0x3D);


MIDL_DEFINE_GUID(CLSID, CLSID_CrIrisPP,0x80DE22C4,0x0F44,0x11D2,0x8B,0x82,0x00,0xA0,0xC9,0x3C,0x09,0xB2);


MIDL_DEFINE_GUID(CLSID, CLSID_CrSlide,0x810E402F,0x056B,0x11D2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTSlide,0xD1C5A1E7,0xCC47,0x4E32,0xBD,0xD2,0x4B,0x3C,0x5F,0xC5,0x0A,0xF5);


MIDL_DEFINE_GUID(CLSID, CLSID_CrSlidePP,0xCC8CEDE1,0x1003,0x11d2,0x8B,0x82,0x00,0xA0,0xC9,0x3C,0x09,0xB2);


MIDL_DEFINE_GUID(CLSID, CLSID_CrRadialWipe,0x424B71AF,0x0695,0x11D2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTRadialWipe,0x164484A9,0x35D9,0x4FB7,0x9F,0xAB,0x48,0x27,0x3B,0x96,0xAA,0x1D);


MIDL_DEFINE_GUID(CLSID, CLSID_CrRadialWipePP,0x33D932E0,0x0F48,0x11d2,0x8B,0x82,0x00,0xA0,0xC9,0x3C,0x09,0xB2);


MIDL_DEFINE_GUID(CLSID, CLSID_CrBarn,0xC3BDF740,0x0B58,0x11d2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTBarn,0xEC9BA17D,0x60B5,0x462B,0xA6,0xD8,0x14,0xB8,0x90,0x57,0xE2,0x2A);


MIDL_DEFINE_GUID(CLSID, CLSID_CrBarnPP,0xFCAD7436,0xF151,0x4110,0xB9,0x7E,0x32,0xBD,0x60,0x7F,0xBD,0xB8);


MIDL_DEFINE_GUID(CLSID, CLSID_CrBlinds,0x00C429C0,0x0BA9,0x11d2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTBlinds,0x9A4A4A51,0xFB3A,0x4F4B,0x9B,0x57,0xA2,0x91,0x2A,0x28,0x97,0x69);


MIDL_DEFINE_GUID(CLSID, CLSID_CrBlindPP,0x213052C1,0x100D,0x11d2,0x8B,0x82,0x00,0xA0,0xC9,0x3C,0x09,0xB2);


MIDL_DEFINE_GUID(CLSID, CLSID_CrStretch,0x7658F2A2,0x0A83,0x11d2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTStretch,0xF088DE73,0xBDD0,0x4E3C,0x81,0xF8,0x6D,0x32,0xF4,0xFE,0x9D,0x28);


MIDL_DEFINE_GUID(CLSID, CLSID_CrStretchPP,0x15FB95E0,0x0F77,0x11d2,0x8B,0x82,0x00,0xA0,0xC9,0x3C,0x09,0xB2);


MIDL_DEFINE_GUID(CLSID, CLSID_CrInset,0x93073C40,0x0BA5,0x11d2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTInset,0x76F363F2,0x7E9F,0x4ED7,0xA6,0xA7,0xEE,0x30,0x35,0x1B,0x66,0x28);


MIDL_DEFINE_GUID(CLSID, CLSID_CrSpiral,0xACA97E00,0x0C7D,0x11d2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTSpiral,0x4A03DCB9,0x6E17,0x4A39,0x88,0x45,0x4E,0xE7,0xDC,0x53,0x31,0xA5);


MIDL_DEFINE_GUID(CLSID, CLSID_CrSpiralPP,0xC6A4FE81,0x1022,0x11d2,0x8B,0x82,0x00,0xA0,0xC9,0x3C,0x09,0xB2);


MIDL_DEFINE_GUID(CLSID, CLSID_CrZigzag,0xE6E73D20,0x0C8A,0x11D2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTZigzag,0x23E26328,0x3928,0x40F2,0x95,0xE5,0x93,0xCA,0xD6,0x90,0x16,0xEB);


MIDL_DEFINE_GUID(CLSID, CLSID_CrZigzagPP,0x1559A3C1,0x102B,0x11d2,0x8B,0x82,0x00,0xA0,0xC9,0x3C,0x09,0xB2);


MIDL_DEFINE_GUID(CLSID, CLSID_CrWheel,0x5AE1DAE0,0x1461,0x11d2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(CLSID, CLSID_CrWheelPP,0xFA9F6180,0x1464,0x11d2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTChroma,0x421516C1,0x3CF8,0x11D2,0x95,0x2A,0x00,0xC0,0x4F,0xA3,0x4F,0x05);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTChromaPP,0xEC7E0760,0x4C76,0x11D2,0x8A,0xDE,0x00,0xA0,0xC9,0x8E,0x65,0x27);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTDropShadow,0xADC6CB86,0x424C,0x11D2,0x95,0x2A,0x00,0xC0,0x4F,0xA3,0x4F,0x05);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTDropShadowPP,0xEC7E0761,0x4C76,0x11D2,0x8A,0xDE,0x00,0xA0,0xC9,0x8E,0x65,0x27);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTCheckerBoard,0xB3EE7802,0x8224,0x4787,0xA1,0xEA,0xF0,0xDE,0x16,0xDE,0xAB,0xD3);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTCheckerBoardPP,0xCBF47525,0x98D2,0x45ea,0xB8,0x43,0xFD,0x21,0x3D,0x93,0x2B,0x10);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTRevealTrans,0xE31E87C4,0x86EA,0x4940,0x9B,0x8A,0x5B,0xD5,0xD1,0x79,0xA7,0x37);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMaskFilter,0x3A04D93B,0x1EDD,0x4f3f,0xA3,0x75,0xA0,0x3E,0xC1,0x95,0x72,0xC4);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTRedirect,0x42B07B28,0x2280,0x4937,0xB0,0x35,0x02,0x93,0xFB,0x81,0x27,0x81);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTAlphaImageLoader,0x0C7EFBDE,0x0303,0x4C6F,0xA4,0xF7,0x31,0xFA,0x2B,0xE5,0xE3,0x97);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTAlphaImageLoaderPP,0x8C80CE2D,0x850D,0x47DA,0x8E,0xCD,0x55,0x02,0x35,0x62,0xD1,0x67);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTRandomDissolve,0xF7F4A1B6,0x8E87,0x452F,0xA2,0xD7,0x30,0x77,0xF5,0x08,0xDB,0xC0);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTRandomBars,0x2E7700B7,0x27C4,0x437F,0x9F,0xBF,0x1E,0x8B,0xE2,0x81,0x75,0x66);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTStrips,0x63A4B1FC,0x259A,0x4A5B,0x81,0x29,0xA8,0x3B,0x8C,0x9E,0x6F,0x4F);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTStripsPP,0xFEC0B7EE,0x7AEC,0x4067,0x9E,0xE1,0xFA,0xCF,0xB7,0xCE,0x9A,0xF9);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaRoll,0x9C61F46E,0x0530,0x11D2,0x8F,0x98,0x00,0xC0,0x4F,0xB9,0x2E,0xB7);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaRipple,0xAA0D4D03,0x06A3,0x11D2,0x8F,0x98,0x00,0xC0,0x4F,0xB9,0x2E,0xB7);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaPageTurn,0xAA0D4D08,0x06A3,0x11D2,0x8F,0x98,0x00,0xC0,0x4F,0xB9,0x2E,0xB7);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaLiquid,0xAA0D4D0A,0x06A3,0x11D2,0x8F,0x98,0x00,0xC0,0x4F,0xB9,0x2E,0xB7);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaCenterPeel,0xAA0D4D0C,0x06A3,0x11D2,0x8F,0x98,0x00,0xC0,0x4F,0xB9,0x2E,0xB7);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaPeelSmall,0xAA0D4D0E,0x06A3,0x11D2,0x8F,0x98,0x00,0xC0,0x4F,0xB9,0x2E,0xB7);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaPeelPiece,0xAA0D4D10,0x06A3,0x11D2,0x8F,0x98,0x00,0xC0,0x4F,0xB9,0x2E,0xB7);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaPeelSplit,0xAA0D4D12,0x06A3,0x11D2,0x8F,0x98,0x00,0xC0,0x4F,0xB9,0x2E,0xB7);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaWater,0x107045C5,0x06E0,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaLightWipe,0x107045C8,0x06E0,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaRadialScaleWipe,0x107045CA,0x06E0,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaWhiteOut,0x107045CC,0x06E0,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaTwister,0x107045CF,0x06E0,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaBurnFilm,0x107045D1,0x06E0,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaJaws,0x2A54C904,0x07AA,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaColorFade,0x2A54C908,0x07AA,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaFlowMotion,0x2A54C90B,0x07AA,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaVacuum,0x2A54C90D,0x07AA,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaGriddler,0x2A54C911,0x07AA,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaGriddler2,0x2A54C913,0x07AA,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaThreshold,0x2A54C915,0x07AA,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaWormHole,0x0E6AE022,0x0C83,0x11D2,0x8C,0xD4,0x00,0x10,0x4B,0xC7,0x5D,0x9A);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTGlow,0x9F8E6421,0x3D9B,0x11D2,0x95,0x2A,0x00,0xC0,0x4F,0xA3,0x4F,0x05);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTShadow,0xE71B4063,0x3E59,0x11D2,0x95,0x2A,0x00,0xC0,0x4F,0xA3,0x4F,0x05);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTAlpha,0xADC6CB82,0x424C,0x11D2,0x95,0x2A,0x00,0xC0,0x4F,0xA3,0x4F,0x05);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTWave,0xADC6CB88,0x424C,0x11D2,0x95,0x2A,0x00,0xC0,0x4F,0xA3,0x4F,0x05);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTLight,0xF9EFBEC2,0x4302,0x11D2,0x95,0x2A,0x00,0xC0,0x4F,0xA3,0x4F,0x05);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTAlphaPP,0xD687A7E0,0x4BA4,0x11D2,0x8A,0xDE,0x00,0xA0,0xC9,0x8E,0x65,0x27);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTGlowPP,0xEC7E0764,0x4C76,0x11D2,0x8A,0xDE,0x00,0xA0,0xC9,0x8E,0x65,0x27);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTShadowPP,0xEC7E0765,0x4C76,0x11D2,0x8A,0xDE,0x00,0xA0,0xC9,0x8E,0x65,0x27);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTWavePP,0xF12456C0,0x4C9E,0x11D2,0x8A,0xDE,0x00,0xA0,0xC9,0x8E,0x65,0x27);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTLightPP,0x694AF25F,0x124D,0x11d3,0x91,0xD5,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMotionBlur,0xDD13DE77,0xD3BA,0x42D4,0xB5,0xC6,0x77,0x45,0xFA,0x4E,0x2D,0x4B);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMotionBlurPP,0x926433E1,0x7F8F,0x4BC6,0xBE,0xC4,0x8C,0x12,0x6C,0x6B,0x7D,0xC4);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMatrix,0x4ABF5A06,0x5568,0x4834,0xBE,0xE3,0x32,0x7A,0x6D,0x95,0xA6,0x85);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMatrixPP,0xC591103A,0xB3A8,0x4D47,0xA3,0xF7,0x2A,0xEE,0xE4,0xB8,0x01,0x3F);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTICMFilter,0xA1BFB370,0x5A9F,0x4429,0xBB,0x72,0xB1,0x3E,0x2F,0xEA,0xED,0xEF);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTICMFilterPP,0x1958FB12,0x31E6,0x47E5,0xAA,0x49,0xB2,0x3D,0x12,0xC8,0x53,0xE6);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AXP64)*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\dxtrans.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0334 */
/* Compiler settings for dxtrans.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __dxtrans_h__
#define __dxtrans_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IDXBaseObject_FWD_DEFINED__
#define __IDXBaseObject_FWD_DEFINED__
typedef interface IDXBaseObject IDXBaseObject;
#endif 	/* __IDXBaseObject_FWD_DEFINED__ */


#ifndef __IDXTransformFactory_FWD_DEFINED__
#define __IDXTransformFactory_FWD_DEFINED__
typedef interface IDXTransformFactory IDXTransformFactory;
#endif 	/* __IDXTransformFactory_FWD_DEFINED__ */


#ifndef __IDXTransform_FWD_DEFINED__
#define __IDXTransform_FWD_DEFINED__
typedef interface IDXTransform IDXTransform;
#endif 	/* __IDXTransform_FWD_DEFINED__ */


#ifndef __IDXSurfacePick_FWD_DEFINED__
#define __IDXSurfacePick_FWD_DEFINED__
typedef interface IDXSurfacePick IDXSurfacePick;
#endif 	/* __IDXSurfacePick_FWD_DEFINED__ */


#ifndef __IDXTBindHost_FWD_DEFINED__
#define __IDXTBindHost_FWD_DEFINED__
typedef interface IDXTBindHost IDXTBindHost;
#endif 	/* __IDXTBindHost_FWD_DEFINED__ */


#ifndef __IDXTaskManager_FWD_DEFINED__
#define __IDXTaskManager_FWD_DEFINED__
typedef interface IDXTaskManager IDXTaskManager;
#endif 	/* __IDXTaskManager_FWD_DEFINED__ */


#ifndef __IDXSurfaceFactory_FWD_DEFINED__
#define __IDXSurfaceFactory_FWD_DEFINED__
typedef interface IDXSurfaceFactory IDXSurfaceFactory;
#endif 	/* __IDXSurfaceFactory_FWD_DEFINED__ */


#ifndef __IDXSurfaceModifier_FWD_DEFINED__
#define __IDXSurfaceModifier_FWD_DEFINED__
typedef interface IDXSurfaceModifier IDXSurfaceModifier;
#endif 	/* __IDXSurfaceModifier_FWD_DEFINED__ */


#ifndef __IDXSurface_FWD_DEFINED__
#define __IDXSurface_FWD_DEFINED__
typedef interface IDXSurface IDXSurface;
#endif 	/* __IDXSurface_FWD_DEFINED__ */


#ifndef __IDXSurfaceInit_FWD_DEFINED__
#define __IDXSurfaceInit_FWD_DEFINED__
typedef interface IDXSurfaceInit IDXSurfaceInit;
#endif 	/* __IDXSurfaceInit_FWD_DEFINED__ */


#ifndef __IDXARGBSurfaceInit_FWD_DEFINED__
#define __IDXARGBSurfaceInit_FWD_DEFINED__
typedef interface IDXARGBSurfaceInit IDXARGBSurfaceInit;
#endif 	/* __IDXARGBSurfaceInit_FWD_DEFINED__ */


#ifndef __IDXARGBReadPtr_FWD_DEFINED__
#define __IDXARGBReadPtr_FWD_DEFINED__
typedef interface IDXARGBReadPtr IDXARGBReadPtr;
#endif 	/* __IDXARGBReadPtr_FWD_DEFINED__ */


#ifndef __IDXARGBReadWritePtr_FWD_DEFINED__
#define __IDXARGBReadWritePtr_FWD_DEFINED__
typedef interface IDXARGBReadWritePtr IDXARGBReadWritePtr;
#endif 	/* __IDXARGBReadWritePtr_FWD_DEFINED__ */


#ifndef __IDXDCLock_FWD_DEFINED__
#define __IDXDCLock_FWD_DEFINED__
typedef interface IDXDCLock IDXDCLock;
#endif 	/* __IDXDCLock_FWD_DEFINED__ */


#ifndef __IDXTScaleOutput_FWD_DEFINED__
#define __IDXTScaleOutput_FWD_DEFINED__
typedef interface IDXTScaleOutput IDXTScaleOutput;
#endif 	/* __IDXTScaleOutput_FWD_DEFINED__ */


#ifndef __IDXGradient_FWD_DEFINED__
#define __IDXGradient_FWD_DEFINED__
typedef interface IDXGradient IDXGradient;
#endif 	/* __IDXGradient_FWD_DEFINED__ */


#ifndef __IDXTScale_FWD_DEFINED__
#define __IDXTScale_FWD_DEFINED__
typedef interface IDXTScale IDXTScale;
#endif 	/* __IDXTScale_FWD_DEFINED__ */


#ifndef __IDXEffect_FWD_DEFINED__
#define __IDXEffect_FWD_DEFINED__
typedef interface IDXEffect IDXEffect;
#endif 	/* __IDXEffect_FWD_DEFINED__ */


#ifndef __IDXLookupTable_FWD_DEFINED__
#define __IDXLookupTable_FWD_DEFINED__
typedef interface IDXLookupTable IDXLookupTable;
#endif 	/* __IDXLookupTable_FWD_DEFINED__ */


#ifndef __IDXRawSurface_FWD_DEFINED__
#define __IDXRawSurface_FWD_DEFINED__
typedef interface IDXRawSurface IDXRawSurface;
#endif 	/* __IDXRawSurface_FWD_DEFINED__ */


#ifndef __IHTMLDXTransform_FWD_DEFINED__
#define __IHTMLDXTransform_FWD_DEFINED__
typedef interface IHTMLDXTransform IHTMLDXTransform;
#endif 	/* __IHTMLDXTransform_FWD_DEFINED__ */


#ifndef __DXTransformFactory_FWD_DEFINED__
#define __DXTransformFactory_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTransformFactory DXTransformFactory;
#else
typedef struct DXTransformFactory DXTransformFactory;
#endif /* __cplusplus */

#endif 	/* __DXTransformFactory_FWD_DEFINED__ */


#ifndef __DXTaskManager_FWD_DEFINED__
#define __DXTaskManager_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTaskManager DXTaskManager;
#else
typedef struct DXTaskManager DXTaskManager;
#endif /* __cplusplus */

#endif 	/* __DXTaskManager_FWD_DEFINED__ */


#ifndef __DXTScale_FWD_DEFINED__
#define __DXTScale_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTScale DXTScale;
#else
typedef struct DXTScale DXTScale;
#endif /* __cplusplus */

#endif 	/* __DXTScale_FWD_DEFINED__ */


#ifndef __DXSurface_FWD_DEFINED__
#define __DXSurface_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXSurface DXSurface;
#else
typedef struct DXSurface DXSurface;
#endif /* __cplusplus */

#endif 	/* __DXSurface_FWD_DEFINED__ */


#ifndef __DXSurfaceModifier_FWD_DEFINED__
#define __DXSurfaceModifier_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXSurfaceModifier DXSurfaceModifier;
#else
typedef struct DXSurfaceModifier DXSurfaceModifier;
#endif /* __cplusplus */

#endif 	/* __DXSurfaceModifier_FWD_DEFINED__ */


#ifndef __DXGradient_FWD_DEFINED__
#define __DXGradient_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXGradient DXGradient;
#else
typedef struct DXGradient DXGradient;
#endif /* __cplusplus */

#endif 	/* __DXGradient_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"
#include "comcat.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_dxtrans_0000 */
/* [local] */ 

#include <servprov.h>
#include <ddraw.h>
#include <d3d.h>
#include <d3drm.h>
#include <urlmon.h>
#if 0
// Bogus definition used to make MIDL compiler happy
typedef void DDSURFACEDESC;

typedef void D3DRMBOX;

typedef void D3DVECTOR;

typedef void D3DRMMATRIX4D;

typedef void *LPSECURITY_ATTRIBUTES;

#endif
#ifdef _DXTRANSIMPL
    #define _DXTRANS_IMPL_EXT _declspec(dllexport)
#else
    #define _DXTRANS_IMPL_EXT _declspec(dllimport)
#endif
















//
//   All GUIDs for DXTransform are declared in DXTGUID.C in the SDK include directory
//
EXTERN_C const GUID DDPF_RGB1;
EXTERN_C const GUID DDPF_RGB2;
EXTERN_C const GUID DDPF_RGB4;
EXTERN_C const GUID DDPF_RGB8;
EXTERN_C const GUID DDPF_RGB332;
EXTERN_C const GUID DDPF_ARGB4444;
EXTERN_C const GUID DDPF_RGB565;
EXTERN_C const GUID DDPF_BGR565;
EXTERN_C const GUID DDPF_RGB555;
EXTERN_C const GUID DDPF_ARGB1555;
EXTERN_C const GUID DDPF_RGB24;
EXTERN_C const GUID DDPF_BGR24;
EXTERN_C const GUID DDPF_RGB32;
EXTERN_C const GUID DDPF_BGR32;
EXTERN_C const GUID DDPF_ABGR32;
EXTERN_C const GUID DDPF_ARGB32;
EXTERN_C const GUID DDPF_PMARGB32;
EXTERN_C const GUID DDPF_A1;
EXTERN_C const GUID DDPF_A2;
EXTERN_C const GUID DDPF_A4;
EXTERN_C const GUID DDPF_A8;
EXTERN_C const GUID DDPF_Z8;
EXTERN_C const GUID DDPF_Z16;
EXTERN_C const GUID DDPF_Z24;
EXTERN_C const GUID DDPF_Z32;
//
//   Component categories
//
EXTERN_C const GUID CATID_DXImageTransform;
EXTERN_C const GUID CATID_DX3DTransform;
EXTERN_C const GUID CATID_DXAuthoringTransform;
EXTERN_C const GUID CATID_DXSurface;
//
//   Service IDs
//
EXTERN_C const GUID SID_SDirectDraw;
EXTERN_C const GUID SID_SDirect3DRM;
#define SID_SDXTaskManager CLSID_DXTaskManager
#define SID_SDXSurfaceFactory IID_IDXSurfaceFactory
#define SID_SDXTransformFactory IID_IDXTransformFactory


extern RPC_IF_HANDLE __MIDL_itf_dxtrans_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtrans_0000_v0_0_s_ifspec;

#ifndef __IDXBaseObject_INTERFACE_DEFINED__
#define __IDXBaseObject_INTERFACE_DEFINED__

/* interface IDXBaseObject */
/* [object][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IDXBaseObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("17B59B2B-9CC8-11d1-9053-00C04FD9189D")
    IDXBaseObject : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetGenerationId( 
            /* [out] */ ULONG *pID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IncrementGenerationId( 
            /* [in] */ BOOL bRefresh) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetObjectSize( 
            /* [out] */ ULONG *pcbSize) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXBaseObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXBaseObject * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXBaseObject * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXBaseObject * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetGenerationId )( 
            IDXBaseObject * This,
            /* [out] */ ULONG *pID);
        
        HRESULT ( STDMETHODCALLTYPE *IncrementGenerationId )( 
            IDXBaseObject * This,
            /* [in] */ BOOL bRefresh);
        
        HRESULT ( STDMETHODCALLTYPE *GetObjectSize )( 
            IDXBaseObject * This,
            /* [out] */ ULONG *pcbSize);
        
        END_INTERFACE
    } IDXBaseObjectVtbl;

    interface IDXBaseObject
    {
        CONST_VTBL struct IDXBaseObjectVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXBaseObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXBaseObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXBaseObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXBaseObject_GetGenerationId(This,pID)	\
    (This)->lpVtbl -> GetGenerationId(This,pID)

#define IDXBaseObject_IncrementGenerationId(This,bRefresh)	\
    (This)->lpVtbl -> IncrementGenerationId(This,bRefresh)

#define IDXBaseObject_GetObjectSize(This,pcbSize)	\
    (This)->lpVtbl -> GetObjectSize(This,pcbSize)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXBaseObject_GetGenerationId_Proxy( 
    IDXBaseObject * This,
    /* [out] */ ULONG *pID);


void __RPC_STUB IDXBaseObject_GetGenerationId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXBaseObject_IncrementGenerationId_Proxy( 
    IDXBaseObject * This,
    /* [in] */ BOOL bRefresh);


void __RPC_STUB IDXBaseObject_IncrementGenerationId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXBaseObject_GetObjectSize_Proxy( 
    IDXBaseObject * This,
    /* [out] */ ULONG *pcbSize);


void __RPC_STUB IDXBaseObject_GetObjectSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXBaseObject_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxtrans_0253 */
/* [local] */ 

typedef 
enum DXBNDID
    {	DXB_X	= 0,
	DXB_Y	= 1,
	DXB_Z	= 2,
	DXB_T	= 3
    } 	DXBNDID;

typedef 
enum DXBNDTYPE
    {	DXBT_DISCRETE	= 0,
	DXBT_DISCRETE64	= DXBT_DISCRETE + 1,
	DXBT_CONTINUOUS	= DXBT_DISCRETE64 + 1,
	DXBT_CONTINUOUS64	= DXBT_CONTINUOUS + 1
    } 	DXBNDTYPE;

typedef struct DXDBND
    {
    long Min;
    long Max;
    } 	DXDBND;

typedef DXDBND DXDBNDS[ 4 ];

typedef struct DXDBND64
    {
    LONGLONG Min;
    LONGLONG Max;
    } 	DXDBND64;

typedef DXDBND64 DXDBNDS64[ 4 ];

typedef struct DXCBND
    {
    float Min;
    float Max;
    } 	DXCBND;

typedef DXCBND DXCBNDS[ 4 ];

typedef struct DXCBND64
    {
    double Min;
    double Max;
    } 	DXCBND64;

typedef DXCBND64 DXCBNDS64[ 4 ];

typedef struct DXBNDS
    {
    DXBNDTYPE eType;
    /* [switch_is] */ /* [switch_type] */ union __MIDL___MIDL_itf_dxtrans_0253_0001
        {
        /* [case()] */ DXDBND D[ 4 ];
        /* [case()] */ DXDBND64 LD[ 4 ];
        /* [case()] */ DXCBND C[ 4 ];
        /* [case()] */ DXCBND64 LC[ 4 ];
        } 	u;
    } 	DXBNDS;

typedef long DXDVEC[ 4 ];

typedef LONGLONG DXDVEC64[ 4 ];

typedef float DXCVEC[ 4 ];

typedef double DXCVEC64[ 4 ];

typedef struct DXVEC
    {
    DXBNDTYPE eType;
    /* [switch_is] */ /* [switch_type] */ union __MIDL___MIDL_itf_dxtrans_0253_0002
        {
        /* [case()] */ long D[ 4 ];
        /* [case()] */ LONGLONG LD[ 4 ];
        /* [case()] */ float C[ 4 ];
        /* [case()] */ double LC[ 4 ];
        } 	u;
    } 	DXVEC;



extern RPC_IF_HANDLE __MIDL_itf_dxtrans_0253_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtrans_0253_v0_0_s_ifspec;

#ifndef __IDXTransformFactory_INTERFACE_DEFINED__
#define __IDXTransformFactory_INTERFACE_DEFINED__

/* interface IDXTransformFactory */
/* [object][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IDXTransformFactory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6A950B2B-A971-11d1-81C8-0000F87557DB")
    IDXTransformFactory : public IServiceProvider
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetService( 
            /* [in] */ REFGUID guidService,
            /* [in] */ IUnknown *pUnkService,
            /* [in] */ BOOL bWeakReference) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateTransform( 
            /* [size_is][in] */ IUnknown **punkInputs,
            /* [in] */ ULONG ulNumInputs,
            /* [size_is][in] */ IUnknown **punkOutputs,
            /* [in] */ ULONG ulNumOutputs,
            /* [in] */ IPropertyBag *pInitProps,
            /* [in] */ IErrorLog *pErrLog,
            /* [in] */ REFCLSID TransCLSID,
            /* [in] */ REFIID TransIID,
            /* [iid_is][out] */ void **ppTransform) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InitializeTransform( 
            /* [in] */ IDXTransform *pTransform,
            /* [size_is][in] */ IUnknown **punkInputs,
            /* [in] */ ULONG ulNumInputs,
            /* [size_is][in] */ IUnknown **punkOutputs,
            /* [in] */ ULONG ulNumOutputs,
            /* [in] */ IPropertyBag *pInitProps,
            /* [in] */ IErrorLog *pErrLog) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTransformFactoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXTransformFactory * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXTransformFactory * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXTransformFactory * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *QueryService )( 
            IDXTransformFactory * This,
            /* [in] */ REFGUID guidService,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppvObject);
        
        HRESULT ( STDMETHODCALLTYPE *SetService )( 
            IDXTransformFactory * This,
            /* [in] */ REFGUID guidService,
            /* [in] */ IUnknown *pUnkService,
            /* [in] */ BOOL bWeakReference);
        
        HRESULT ( STDMETHODCALLTYPE *CreateTransform )( 
            IDXTransformFactory * This,
            /* [size_is][in] */ IUnknown **punkInputs,
            /* [in] */ ULONG ulNumInputs,
            /* [size_is][in] */ IUnknown **punkOutputs,
            /* [in] */ ULONG ulNumOutputs,
            /* [in] */ IPropertyBag *pInitProps,
            /* [in] */ IErrorLog *pErrLog,
            /* [in] */ REFCLSID TransCLSID,
            /* [in] */ REFIID TransIID,
            /* [iid_is][out] */ void **ppTransform);
        
        HRESULT ( STDMETHODCALLTYPE *InitializeTransform )( 
            IDXTransformFactory * This,
            /* [in] */ IDXTransform *pTransform,
            /* [size_is][in] */ IUnknown **punkInputs,
            /* [in] */ ULONG ulNumInputs,
            /* [size_is][in] */ IUnknown **punkOutputs,
            /* [in] */ ULONG ulNumOutputs,
            /* [in] */ IPropertyBag *pInitProps,
            /* [in] */ IErrorLog *pErrLog);
        
        END_INTERFACE
    } IDXTransformFactoryVtbl;

    interface IDXTransformFactory
    {
        CONST_VTBL struct IDXTransformFactoryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTransformFactory_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTransformFactory_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTransformFactory_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTransformFactory_QueryService(This,guidService,riid,ppvObject)	\
    (This)->lpVtbl -> QueryService(This,guidService,riid,ppvObject)


#define IDXTransformFactory_SetService(This,guidService,pUnkService,bWeakReference)	\
    (This)->lpVtbl -> SetService(This,guidService,pUnkService,bWeakReference)

#define IDXTransformFactory_CreateTransform(This,punkInputs,ulNumInputs,punkOutputs,ulNumOutputs,pInitProps,pErrLog,TransCLSID,TransIID,ppTransform)	\
    (This)->lpVtbl -> CreateTransform(This,punkInputs,ulNumInputs,punkOutputs,ulNumOutputs,pInitProps,pErrLog,TransCLSID,TransIID,ppTransform)

#define IDXTransformFactory_InitializeTransform(This,pTransform,punkInputs,ulNumInputs,punkOutputs,ulNumOutputs,pInitProps,pErrLog)	\
    (This)->lpVtbl -> InitializeTransform(This,pTransform,punkInputs,ulNumInputs,punkOutputs,ulNumOutputs,pInitProps,pErrLog)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXTransformFactory_SetService_Proxy( 
    IDXTransformFactory * This,
    /* [in] */ REFGUID guidService,
    /* [in] */ IUnknown *pUnkService,
    /* [in] */ BOOL bWeakReference);


void __RPC_STUB IDXTransformFactory_SetService_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTransformFactory_CreateTransform_Proxy( 
    IDXTransformFactory * This,
    /* [size_is][in] */ IUnknown **punkInputs,
    /* [in] */ ULONG ulNumInputs,
    /* [size_is][in] */ IUnknown **punkOutputs,
    /* [in] */ ULONG ulNumOutputs,
    /* [in] */ IPropertyBag *pInitProps,
    /* [in] */ IErrorLog *pErrLog,
    /* [in] */ REFCLSID TransCLSID,
    /* [in] */ REFIID TransIID,
    /* [iid_is][out] */ void **ppTransform);


void __RPC_STUB IDXTransformFactory_CreateTransform_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTransformFactory_InitializeTransform_Proxy( 
    IDXTransformFactory * This,
    /* [in] */ IDXTransform *pTransform,
    /* [size_is][in] */ IUnknown **punkInputs,
    /* [in] */ ULONG ulNumInputs,
    /* [size_is][in] */ IUnknown **punkOutputs,
    /* [in] */ ULONG ulNumOutputs,
    /* [in] */ IPropertyBag *pInitProps,
    /* [in] */ IErrorLog *pErrLog);


void __RPC_STUB IDXTransformFactory_InitializeTransform_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTransformFactory_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxtrans_0254 */
/* [local] */ 

typedef 
enum DXTMISCFLAGS
    {	DXTMF_BLEND_WITH_OUTPUT	= 1L << 0,
	DXTMF_DITHER_OUTPUT	= 1L << 1,
	DXTMF_OPTION_MASK	= 0xffff,
	DXTMF_VALID_OPTIONS	= DXTMF_BLEND_WITH_OUTPUT | DXTMF_DITHER_OUTPUT,
	DXTMF_BLEND_SUPPORTED	= 1L << 16,
	DXTMF_DITHER_SUPPORTED	= 1L << 17,
	DXTMF_INPLACE_OPERATION	= 1L << 24,
	DXTMF_BOUNDS_SUPPORTED	= 1L << 25,
	DXTMF_PLACEMENT_SUPPORTED	= 1L << 26,
	DXTMF_QUALITY_SUPPORTED	= 1L << 27,
	DXTMF_OPAQUE_RESULT	= 1L << 28
    } 	DXTMISCFLAGS;

typedef 
enum DXINOUTINFOFLAGS
    {	DXINOUTF_OPTIONAL	= 1L << 0
    } 	DXINOUTINFOFLAGS;



extern RPC_IF_HANDLE __MIDL_itf_dxtrans_0254_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtrans_0254_v0_0_s_ifspec;

#ifndef __IDXTransform_INTERFACE_DEFINED__
#define __IDXTransform_INTERFACE_DEFINED__

/* interface IDXTransform */
/* [object][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IDXTransform;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("30A5FB78-E11F-11d1-9064-00C04FD9189D")
    IDXTransform : public IDXBaseObject
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Setup( 
            /* [size_is][in] */ IUnknown *const *punkInputs,
            /* [in] */ ULONG ulNumInputs,
            /* [size_is][in] */ IUnknown *const *punkOutputs,
            /* [in] */ ULONG ulNumOutputs,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Execute( 
            /* [in] */ const GUID *pRequestID,
            /* [in] */ const DXBNDS *pClipBnds,
            /* [in] */ const DXVEC *pPlacement) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MapBoundsIn2Out( 
            /* [in] */ const DXBNDS *pInBounds,
            /* [in] */ ULONG ulNumInBnds,
            /* [in] */ ULONG ulOutIndex,
            /* [out] */ DXBNDS *pOutBounds) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MapBoundsOut2In( 
            /* [in] */ ULONG ulOutIndex,
            /* [in] */ const DXBNDS *pOutBounds,
            /* [in] */ ULONG ulInIndex,
            /* [out] */ DXBNDS *pInBounds) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMiscFlags( 
            /* [in] */ DWORD dwMiscFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMiscFlags( 
            /* [out] */ DWORD *pdwMiscFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInOutInfo( 
            /* [in] */ BOOL bIsOutput,
            /* [in] */ ULONG ulIndex,
            /* [out] */ DWORD *pdwFlags,
            /* [size_is][out] */ GUID *pIDs,
            /* [out][in] */ ULONG *pcIDs,
            /* [out] */ IUnknown **ppUnkCurrentObject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetQuality( 
            /* [in] */ float fQuality) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetQuality( 
            /* [out] */ float *fQuality) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTransformVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXTransform * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXTransform * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXTransform * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetGenerationId )( 
            IDXTransform * This,
            /* [out] */ ULONG *pID);
        
        HRESULT ( STDMETHODCALLTYPE *IncrementGenerationId )( 
            IDXTransform * This,
            /* [in] */ BOOL bRefresh);
        
        HRESULT ( STDMETHODCALLTYPE *GetObjectSize )( 
            IDXTransform * This,
            /* [out] */ ULONG *pcbSize);
        
        HRESULT ( STDMETHODCALLTYPE *Setup )( 
            IDXTransform * This,
            /* [size_is][in] */ IUnknown *const *punkInputs,
            /* [in] */ ULONG ulNumInputs,
            /* [size_is][in] */ IUnknown *const *punkOutputs,
            /* [in] */ ULONG ulNumOutputs,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *Execute )( 
            IDXTransform * This,
            /* [in] */ const GUID *pRequestID,
            /* [in] */ const DXBNDS *pClipBnds,
            /* [in] */ const DXVEC *pPlacement);
        
        HRESULT ( STDMETHODCALLTYPE *MapBoundsIn2Out )( 
            IDXTransform * This,
            /* [in] */ const DXBNDS *pInBounds,
            /* [in] */ ULONG ulNumInBnds,
            /* [in] */ ULONG ulOutIndex,
            /* [out] */ DXBNDS *pOutBounds);
        
        HRESULT ( STDMETHODCALLTYPE *MapBoundsOut2In )( 
            IDXTransform * This,
            /* [in] */ ULONG ulOutIndex,
            /* [in] */ const DXBNDS *pOutBounds,
            /* [in] */ ULONG ulInIndex,
            /* [out] */ DXBNDS *pInBounds);
        
        HRESULT ( STDMETHODCALLTYPE *SetMiscFlags )( 
            IDXTransform * This,
            /* [in] */ DWORD dwMiscFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetMiscFlags )( 
            IDXTransform * This,
            /* [out] */ DWORD *pdwMiscFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetInOutInfo )( 
            IDXTransform * This,
            /* [in] */ BOOL bIsOutput,
            /* [in] */ ULONG ulIndex,
            /* [out] */ DWORD *pdwFlags,
            /* [size_is][out] */ GUID *pIDs,
            /* [out][in] */ ULONG *pcIDs,
            /* [out] */ IUnknown **ppUnkCurrentObject);
        
        HRESULT ( STDMETHODCALLTYPE *SetQuality )( 
            IDXTransform * This,
            /* [in] */ float fQuality);
        
        HRESULT ( STDMETHODCALLTYPE *GetQuality )( 
            IDXTransform * This,
            /* [out] */ float *fQuality);
        
        END_INTERFACE
    } IDXTransformVtbl;

    interface IDXTransform
    {
        CONST_VTBL struct IDXTransformVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTransform_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTransform_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTransform_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTransform_GetGenerationId(This,pID)	\
    (This)->lpVtbl -> GetGenerationId(This,pID)

#define IDXTransform_IncrementGenerationId(This,bRefresh)	\
    (This)->lpVtbl -> IncrementGenerationId(This,bRefresh)

#define IDXTransform_GetObjectSize(This,pcbSize)	\
    (This)->lpVtbl -> GetObjectSize(This,pcbSize)


#define IDXTransform_Setup(This,punkInputs,ulNumInputs,punkOutputs,ulNumOutputs,dwFlags)	\
    (This)->lpVtbl -> Setup(This,punkInputs,ulNumInputs,punkOutputs,ulNumOutputs,dwFlags)

#define IDXTransform_Execute(This,pRequestID,pClipBnds,pPlacement)	\
    (This)->lpVtbl -> Execute(This,pRequestID,pClipBnds,pPlacement)

#define IDXTransform_MapBoundsIn2Out(This,pInBounds,ulNumInBnds,ulOutIndex,pOutBounds)	\
    (This)->lpVtbl -> MapBoundsIn2Out(This,pInBounds,ulNumInBnds,ulOutIndex,pOutBounds)

#define IDXTransform_MapBoundsOut2In(This,ulOutIndex,pOutBounds,ulInIndex,pInBounds)	\
    (This)->lpVtbl -> MapBoundsOut2In(This,ulOutIndex,pOutBounds,ulInIndex,pInBounds)

#define IDXTransform_SetMiscFlags(This,dwMiscFlags)	\
    (This)->lpVtbl -> SetMiscFlags(This,dwMiscFlags)

#define IDXTransform_GetMiscFlags(This,pdwMiscFlags)	\
    (This)->lpVtbl -> GetMiscFlags(This,pdwMiscFlags)

#define IDXTransform_GetInOutInfo(This,bIsOutput,ulIndex,pdwFlags,pIDs,pcIDs,ppUnkCurrentObject)	\
    (This)->lpVtbl -> GetInOutInfo(This,bIsOutput,ulIndex,pdwFlags,pIDs,pcIDs,ppUnkCurrentObject)

#define IDXTransform_SetQuality(This,fQuality)	\
    (This)->lpVtbl -> SetQuality(This,fQuality)

#define IDXTransform_GetQuality(This,fQuality)	\
    (This)->lpVtbl -> GetQuality(This,fQuality)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXTransform_Setup_Proxy( 
    IDXTransform * This,
    /* [size_is][in] */ IUnknown *const *punkInputs,
    /* [in] */ ULONG ulNumInputs,
    /* [size_is][in] */ IUnknown *const *punkOutputs,
    /* [in] */ ULONG ulNumOutputs,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IDXTransform_Setup_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTransform_Execute_Proxy( 
    IDXTransform * This,
    /* [in] */ const GUID *pRequestID,
    /* [in] */ const DXBNDS *pClipBnds,
    /* [in] */ const DXVEC *pPlacement);


void __RPC_STUB IDXTransform_Execute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTransform_MapBoundsIn2Out_Proxy( 
    IDXTransform * This,
    /* [in] */ const DXBNDS *pInBounds,
    /* [in] */ ULONG ulNumInBnds,
    /* [in] */ ULONG ulOutIndex,
    /* [out] */ DXBNDS *pOutBounds);


void __RPC_STUB IDXTransform_MapBoundsIn2Out_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTransform_MapBoundsOut2In_Proxy( 
    IDXTransform * This,
    /* [in] */ ULONG ulOutIndex,
    /* [in] */ const DXBNDS *pOutBounds,
    /* [in] */ ULONG ulInIndex,
    /* [out] */ DXBNDS *pInBounds);


void __RPC_STUB IDXTransform_MapBoundsOut2In_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTransform_SetMiscFlags_Proxy( 
    IDXTransform * This,
    /* [in] */ DWORD dwMiscFlags);


void __RPC_STUB IDXTransform_SetMiscFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTransform_GetMiscFlags_Proxy( 
    IDXTransform * This,
    /* [out] */ DWORD *pdwMiscFlags);


void __RPC_STUB IDXTransform_GetMiscFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTransform_GetInOutInfo_Proxy( 
    IDXTransform * This,
    /* [in] */ BOOL bIsOutput,
    /* [in] */ ULONG ulIndex,
    /* [out] */ DWORD *pdwFlags,
    /* [size_is][out] */ GUID *pIDs,
    /* [out][in] */ ULONG *pcIDs,
    /* [out] */ IUnknown **ppUnkCurrentObject);


void __RPC_STUB IDXTransform_GetInOutInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTransform_SetQuality_Proxy( 
    IDXTransform * This,
    /* [in] */ float fQuality);


void __RPC_STUB IDXTransform_SetQuality_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTransform_GetQuality_Proxy( 
    IDXTransform * This,
    /* [out] */ float *fQuality);


void __RPC_STUB IDXTransform_GetQuality_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTransform_INTERFACE_DEFINED__ */


#ifndef __IDXSurfacePick_INTERFACE_DEFINED__
#define __IDXSurfacePick_INTERFACE_DEFINED__

/* interface IDXSurfacePick */
/* [object][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IDXSurfacePick;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("30A5FB79-E11F-11d1-9064-00C04FD9189D")
    IDXSurfacePick : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE PointPick( 
            /* [in] */ const DXVEC *pPoint,
            /* [out] */ ULONG *pulInputSurfaceIndex,
            /* [out] */ DXVEC *pInputPoint) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXSurfacePickVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXSurfacePick * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXSurfacePick * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXSurfacePick * This);
        
        HRESULT ( STDMETHODCALLTYPE *PointPick )( 
            IDXSurfacePick * This,
            /* [in] */ const DXVEC *pPoint,
            /* [out] */ ULONG *pulInputSurfaceIndex,
            /* [out] */ DXVEC *pInputPoint);
        
        END_INTERFACE
    } IDXSurfacePickVtbl;

    interface IDXSurfacePick
    {
        CONST_VTBL struct IDXSurfacePickVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXSurfacePick_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXSurfacePick_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXSurfacePick_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXSurfacePick_PointPick(This,pPoint,pulInputSurfaceIndex,pInputPoint)	\
    (This)->lpVtbl -> PointPick(This,pPoint,pulInputSurfaceIndex,pInputPoint)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXSurfacePick_PointPick_Proxy( 
    IDXSurfacePick * This,
    /* [in] */ const DXVEC *pPoint,
    /* [out] */ ULONG *pulInputSurfaceIndex,
    /* [out] */ DXVEC *pInputPoint);


void __RPC_STUB IDXSurfacePick_PointPick_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXSurfacePick_INTERFACE_DEFINED__ */


#ifndef __IDXTBindHost_INTERFACE_DEFINED__
#define __IDXTBindHost_INTERFACE_DEFINED__

/* interface IDXTBindHost */
/* [object][local][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IDXTBindHost;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D26BCE55-E9DC-11d1-9066-00C04FD9189D")
    IDXTBindHost : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetBindHost( 
            /* [in] */ IBindHost *pBindHost) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTBindHostVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXTBindHost * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXTBindHost * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXTBindHost * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetBindHost )( 
            IDXTBindHost * This,
            /* [in] */ IBindHost *pBindHost);
        
        END_INTERFACE
    } IDXTBindHostVtbl;

    interface IDXTBindHost
    {
        CONST_VTBL struct IDXTBindHostVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTBindHost_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTBindHost_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTBindHost_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTBindHost_SetBindHost(This,pBindHost)	\
    (This)->lpVtbl -> SetBindHost(This,pBindHost)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXTBindHost_SetBindHost_Proxy( 
    IDXTBindHost * This,
    /* [in] */ IBindHost *pBindHost);


void __RPC_STUB IDXTBindHost_SetBindHost_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTBindHost_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxtrans_0257 */
/* [local] */ 

typedef void __stdcall __stdcall DXTASKPROC( 
    void *pTaskData,
    BOOL *pbContinueProcessing);

typedef DXTASKPROC *PFNDXTASKPROC;

typedef void __stdcall __stdcall DXAPCPROC( 
    DWORD dwData);

typedef DXAPCPROC *PFNDXAPCPROC;

#ifdef __cplusplus
typedef struct DXTMTASKINFO
{
    PFNDXTASKPROC pfnTaskProc;       // Pointer to function to execute
    PVOID         pTaskData;         // Pointer to argument data
    PFNDXAPCPROC  pfnCompletionAPC;  // Pointer to completion APC proc
    DWORD         dwCompletionData;  // Pointer to APC proc data
    const GUID*   pRequestID;        // Used to identify groups of tasks
} DXTMTASKINFO;
#else
typedef struct DXTMTASKINFO
    {
    PVOID pfnTaskProc;
    PVOID pTaskData;
    PVOID pfnCompletionAPC;
    DWORD dwCompletionData;
    const GUID *pRequestID;
    } 	DXTMTASKINFO;

#endif


extern RPC_IF_HANDLE __MIDL_itf_dxtrans_0257_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtrans_0257_v0_0_s_ifspec;

#ifndef __IDXTaskManager_INTERFACE_DEFINED__
#define __IDXTaskManager_INTERFACE_DEFINED__

/* interface IDXTaskManager */
/* [object][unique][helpstring][uuid][local] */ 


EXTERN_C const IID IID_IDXTaskManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("254DBBC1-F922-11d0-883A-3C8B00C10000")
    IDXTaskManager : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE QueryNumProcessors( 
            /* [out] */ ULONG *pulNumProc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetThreadPoolSize( 
            /* [in] */ ULONG ulNumThreads) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetThreadPoolSize( 
            /* [out] */ ULONG *pulNumThreads) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetConcurrencyLimit( 
            /* [in] */ ULONG ulNumThreads) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConcurrencyLimit( 
            /* [out] */ ULONG *pulNumThreads) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ScheduleTasks( 
            /* [in] */ DXTMTASKINFO TaskInfo[  ],
            /* [in] */ HANDLE Events[  ],
            /* [out] */ DWORD TaskIDs[  ],
            /* [in] */ ULONG ulNumTasks,
            /* [in] */ ULONG ulWaitPeriod) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TerminateTasks( 
            /* [in] */ DWORD TaskIDs[  ],
            /* [in] */ ULONG ulCount,
            /* [in] */ ULONG ulTimeOut) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TerminateRequest( 
            /* [in] */ REFIID RequestID,
            /* [in] */ ULONG ulTimeOut) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTaskManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXTaskManager * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXTaskManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXTaskManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *QueryNumProcessors )( 
            IDXTaskManager * This,
            /* [out] */ ULONG *pulNumProc);
        
        HRESULT ( STDMETHODCALLTYPE *SetThreadPoolSize )( 
            IDXTaskManager * This,
            /* [in] */ ULONG ulNumThreads);
        
        HRESULT ( STDMETHODCALLTYPE *GetThreadPoolSize )( 
            IDXTaskManager * This,
            /* [out] */ ULONG *pulNumThreads);
        
        HRESULT ( STDMETHODCALLTYPE *SetConcurrencyLimit )( 
            IDXTaskManager * This,
            /* [in] */ ULONG ulNumThreads);
        
        HRESULT ( STDMETHODCALLTYPE *GetConcurrencyLimit )( 
            IDXTaskManager * This,
            /* [out] */ ULONG *pulNumThreads);
        
        HRESULT ( STDMETHODCALLTYPE *ScheduleTasks )( 
            IDXTaskManager * This,
            /* [in] */ DXTMTASKINFO TaskInfo[  ],
            /* [in] */ HANDLE Events[  ],
            /* [out] */ DWORD TaskIDs[  ],
            /* [in] */ ULONG ulNumTasks,
            /* [in] */ ULONG ulWaitPeriod);
        
        HRESULT ( STDMETHODCALLTYPE *TerminateTasks )( 
            IDXTaskManager * This,
            /* [in] */ DWORD TaskIDs[  ],
            /* [in] */ ULONG ulCount,
            /* [in] */ ULONG ulTimeOut);
        
        HRESULT ( STDMETHODCALLTYPE *TerminateRequest )( 
            IDXTaskManager * This,
            /* [in] */ REFIID RequestID,
            /* [in] */ ULONG ulTimeOut);
        
        END_INTERFACE
    } IDXTaskManagerVtbl;

    interface IDXTaskManager
    {
        CONST_VTBL struct IDXTaskManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTaskManager_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTaskManager_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTaskManager_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTaskManager_QueryNumProcessors(This,pulNumProc)	\
    (This)->lpVtbl -> QueryNumProcessors(This,pulNumProc)

#define IDXTaskManager_SetThreadPoolSize(This,ulNumThreads)	\
    (This)->lpVtbl -> SetThreadPoolSize(This,ulNumThreads)

#define IDXTaskManager_GetThreadPoolSize(This,pulNumThreads)	\
    (This)->lpVtbl -> GetThreadPoolSize(This,pulNumThreads)

#define IDXTaskManager_SetConcurrencyLimit(This,ulNumThreads)	\
    (This)->lpVtbl -> SetConcurrencyLimit(This,ulNumThreads)

#define IDXTaskManager_GetConcurrencyLimit(This,pulNumThreads)	\
    (This)->lpVtbl -> GetConcurrencyLimit(This,pulNumThreads)

#define IDXTaskManager_ScheduleTasks(This,TaskInfo,Events,TaskIDs,ulNumTasks,ulWaitPeriod)	\
    (This)->lpVtbl -> ScheduleTasks(This,TaskInfo,Events,TaskIDs,ulNumTasks,ulWaitPeriod)

#define IDXTaskManager_TerminateTasks(This,TaskIDs,ulCount,ulTimeOut)	\
    (This)->lpVtbl -> TerminateTasks(This,TaskIDs,ulCount,ulTimeOut)

#define IDXTaskManager_TerminateRequest(This,RequestID,ulTimeOut)	\
    (This)->lpVtbl -> TerminateRequest(This,RequestID,ulTimeOut)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXTaskManager_QueryNumProcessors_Proxy( 
    IDXTaskManager * This,
    /* [out] */ ULONG *pulNumProc);


void __RPC_STUB IDXTaskManager_QueryNumProcessors_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTaskManager_SetThreadPoolSize_Proxy( 
    IDXTaskManager * This,
    /* [in] */ ULONG ulNumThreads);


void __RPC_STUB IDXTaskManager_SetThreadPoolSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTaskManager_GetThreadPoolSize_Proxy( 
    IDXTaskManager * This,
    /* [out] */ ULONG *pulNumThreads);


void __RPC_STUB IDXTaskManager_GetThreadPoolSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTaskManager_SetConcurrencyLimit_Proxy( 
    IDXTaskManager * This,
    /* [in] */ ULONG ulNumThreads);


void __RPC_STUB IDXTaskManager_SetConcurrencyLimit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTaskManager_GetConcurrencyLimit_Proxy( 
    IDXTaskManager * This,
    /* [out] */ ULONG *pulNumThreads);


void __RPC_STUB IDXTaskManager_GetConcurrencyLimit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTaskManager_ScheduleTasks_Proxy( 
    IDXTaskManager * This,
    /* [in] */ DXTMTASKINFO TaskInfo[  ],
    /* [in] */ HANDLE Events[  ],
    /* [out] */ DWORD TaskIDs[  ],
    /* [in] */ ULONG ulNumTasks,
    /* [in] */ ULONG ulWaitPeriod);


void __RPC_STUB IDXTaskManager_ScheduleTasks_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTaskManager_TerminateTasks_Proxy( 
    IDXTaskManager * This,
    /* [in] */ DWORD TaskIDs[  ],
    /* [in] */ ULONG ulCount,
    /* [in] */ ULONG ulTimeOut);


void __RPC_STUB IDXTaskManager_TerminateTasks_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTaskManager_TerminateRequest_Proxy( 
    IDXTaskManager * This,
    /* [in] */ REFIID RequestID,
    /* [in] */ ULONG ulTimeOut);


void __RPC_STUB IDXTaskManager_TerminateRequest_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTaskManager_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxtrans_0258 */
/* [local] */ 

#ifdef __cplusplus
/////////////////////////////////////////////////////

class DXBASESAMPLE;
class DXSAMPLE;
class DXPMSAMPLE;

/////////////////////////////////////////////////////

class DXBASESAMPLE
{
public:
    BYTE Blue;
    BYTE Green;
    BYTE Red;
    BYTE Alpha;
    DXBASESAMPLE() {}
    DXBASESAMPLE(const BYTE alpha, const BYTE red, const BYTE green, const BYTE blue) :
        Alpha(alpha),
        Red(red),
        Green(green),
        Blue(blue) {}
    DXBASESAMPLE(const DWORD val) { *this = (*(DXBASESAMPLE *)&val); }
    operator DWORD () const {return *((DWORD *)this); }
    DWORD operator=(const DWORD val) { return *this = *((DXBASESAMPLE *)&val); }
}; // DXBASESAMPLE

/////////////////////////////////////////////////////

class DXSAMPLE : public DXBASESAMPLE
{
public:
    DXSAMPLE() {}
    DXSAMPLE(const BYTE alpha, const BYTE red, const BYTE green, const BYTE blue) :
         DXBASESAMPLE(alpha, red, green, blue) {}
    DXSAMPLE(const DWORD val) { *this = (*(DXSAMPLE *)&val); }
    operator DWORD () const {return *((DWORD *)this); }
    DWORD operator=(const DWORD val) { return *this = *((DXSAMPLE *)&val); }
    operator DXPMSAMPLE() const;
}; // DXSAMPLE

/////////////////////////////////////////////////////

class DXPMSAMPLE : public DXBASESAMPLE
{
public:
    DXPMSAMPLE() {}
    DXPMSAMPLE(const BYTE alpha, const BYTE red, const BYTE green, const BYTE blue) :
         DXBASESAMPLE(alpha, red, green, blue) {}
    DXPMSAMPLE(const DWORD val) { *this = (*(DXPMSAMPLE *)&val); }
    operator DWORD () const {return *((DWORD *)this); }
    DWORD operator=(const DWORD val) { return *this = *((DXPMSAMPLE *)&val); }
    operator DXSAMPLE() const;
}; // DXPMSAMPLE

//
// The following cast operators are to prevent a direct assignment of a DXSAMPLE to a DXPMSAMPLE
//
inline DXSAMPLE::operator DXPMSAMPLE() const { return *((DXPMSAMPLE *)this); }
inline DXPMSAMPLE::operator DXSAMPLE() const { return *((DXSAMPLE *)this); }
#else // !__cplusplus
typedef struct DXBASESAMPLE
    {
    BYTE Blue;
    BYTE Green;
    BYTE Red;
    BYTE Alpha;
    } 	DXBASESAMPLE;

typedef struct DXSAMPLE
    {
    BYTE Blue;
    BYTE Green;
    BYTE Red;
    BYTE Alpha;
    } 	DXSAMPLE;

typedef struct DXPMSAMPLE
    {
    BYTE Blue;
    BYTE Green;
    BYTE Red;
    BYTE Alpha;
    } 	DXPMSAMPLE;

#endif // !__cplusplus
typedef 
enum DXRUNTYPE
    {	DXRUNTYPE_CLEAR	= 0,
	DXRUNTYPE_OPAQUE	= 1,
	DXRUNTYPE_TRANS	= 2,
	DXRUNTYPE_UNKNOWN	= 3
    } 	DXRUNTYPE;

#define	DX_MAX_RUN_INFO_COUNT	( 128 )

// Ignore the definition used by MIDL for TLB generation
#if 0
typedef struct DXRUNINFO
    {
    ULONG Bitfields;
    } 	DXRUNINFO;

#endif // 0
typedef struct DXRUNINFO
{
    ULONG   Type  : 2;   // Type
    ULONG   Count : 30;  // Number of samples in run
} DXRUNINFO;
typedef 
enum DXSFCREATE
    {	DXSF_FORMAT_IS_CLSID	= 1L << 0,
	DXSF_NO_LAZY_DDRAW_LOCK	= 1L << 1
    } 	DXSFCREATE;

typedef 
enum DXBLTOPTIONS
    {	DXBOF_DO_OVER	= 1L << 0,
	DXBOF_DITHER	= 1L << 1
    } 	DXBLTOPTIONS;



extern RPC_IF_HANDLE __MIDL_itf_dxtrans_0258_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtrans_0258_v0_0_s_ifspec;

#ifndef __IDXSurfaceFactory_INTERFACE_DEFINED__
#define __IDXSurfaceFactory_INTERFACE_DEFINED__

/* interface IDXSurfaceFactory */
/* [object][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IDXSurfaceFactory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("144946F5-C4D4-11d1-81D1-0000F87557DB")
    IDXSurfaceFactory : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE CreateSurface( 
            /* [in] */ IUnknown *pDirectDraw,
            /* [in] */ const DDSURFACEDESC *pDDSurfaceDesc,
            /* [in] */ const GUID *pFormatID,
            /* [in] */ const DXBNDS *pBounds,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IUnknown *punkOuter,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppDXSurface) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateFromDDSurface( 
            /* [in] */ IUnknown *pDDrawSurface,
            /* [in] */ const GUID *pFormatID,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IUnknown *punkOuter,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppDXSurface) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE LoadImage( 
            /* [in] */ const LPWSTR pszFileName,
            /* [in] */ IUnknown *pDirectDraw,
            /* [in] */ const DDSURFACEDESC *pDDSurfaceDesc,
            /* [in] */ const GUID *pFormatID,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppDXSurface) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE LoadImageFromStream( 
            /* [in] */ IStream *pStream,
            /* [in] */ IUnknown *pDirectDraw,
            /* [in] */ const DDSURFACEDESC *pDDSurfaceDesc,
            /* [in] */ const GUID *pFormatID,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppDXSurface) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE CopySurfaceToNewFormat( 
            /* [in] */ IDXSurface *pSrc,
            /* [in] */ IUnknown *pDirectDraw,
            /* [in] */ const DDSURFACEDESC *pDDSurfaceDesc,
            /* [in] */ const GUID *pDestFormatID,
            /* [out] */ IDXSurface **ppNewSurface) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE CreateD3DRMTexture( 
            /* [in] */ IDXSurface *pSrc,
            /* [in] */ IUnknown *pDirectDraw,
            /* [in] */ IUnknown *pD3DRM3,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppTexture3) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BitBlt( 
            /* [in] */ IDXSurface *pDest,
            /* [in] */ const DXVEC *pPlacement,
            /* [in] */ IDXSurface *pSrc,
            /* [in] */ const DXBNDS *pClipBounds,
            /* [in] */ DWORD dwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXSurfaceFactoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXSurfaceFactory * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXSurfaceFactory * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXSurfaceFactory * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *CreateSurface )( 
            IDXSurfaceFactory * This,
            /* [in] */ IUnknown *pDirectDraw,
            /* [in] */ const DDSURFACEDESC *pDDSurfaceDesc,
            /* [in] */ const GUID *pFormatID,
            /* [in] */ const DXBNDS *pBounds,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IUnknown *punkOuter,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppDXSurface);
        
        HRESULT ( STDMETHODCALLTYPE *CreateFromDDSurface )( 
            IDXSurfaceFactory * This,
            /* [in] */ IUnknown *pDDrawSurface,
            /* [in] */ const GUID *pFormatID,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IUnknown *punkOuter,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppDXSurface);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *LoadImage )( 
            IDXSurfaceFactory * This,
            /* [in] */ const LPWSTR pszFileName,
            /* [in] */ IUnknown *pDirectDraw,
            /* [in] */ const DDSURFACEDESC *pDDSurfaceDesc,
            /* [in] */ const GUID *pFormatID,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppDXSurface);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *LoadImageFromStream )( 
            IDXSurfaceFactory * This,
            /* [in] */ IStream *pStream,
            /* [in] */ IUnknown *pDirectDraw,
            /* [in] */ const DDSURFACEDESC *pDDSurfaceDesc,
            /* [in] */ const GUID *pFormatID,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppDXSurface);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *CopySurfaceToNewFormat )( 
            IDXSurfaceFactory * This,
            /* [in] */ IDXSurface *pSrc,
            /* [in] */ IUnknown *pDirectDraw,
            /* [in] */ const DDSURFACEDESC *pDDSurfaceDesc,
            /* [in] */ const GUID *pDestFormatID,
            /* [out] */ IDXSurface **ppNewSurface);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *CreateD3DRMTexture )( 
            IDXSurfaceFactory * This,
            /* [in] */ IDXSurface *pSrc,
            /* [in] */ IUnknown *pDirectDraw,
            /* [in] */ IUnknown *pD3DRM3,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppTexture3);
        
        HRESULT ( STDMETHODCALLTYPE *BitBlt )( 
            IDXSurfaceFactory * This,
            /* [in] */ IDXSurface *pDest,
            /* [in] */ const DXVEC *pPlacement,
            /* [in] */ IDXSurface *pSrc,
            /* [in] */ const DXBNDS *pClipBounds,
            /* [in] */ DWORD dwFlags);
        
        END_INTERFACE
    } IDXSurfaceFactoryVtbl;

    interface IDXSurfaceFactory
    {
        CONST_VTBL struct IDXSurfaceFactoryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXSurfaceFactory_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXSurfaceFactory_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXSurfaceFactory_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXSurfaceFactory_CreateSurface(This,pDirectDraw,pDDSurfaceDesc,pFormatID,pBounds,dwFlags,punkOuter,riid,ppDXSurface)	\
    (This)->lpVtbl -> CreateSurface(This,pDirectDraw,pDDSurfaceDesc,pFormatID,pBounds,dwFlags,punkOuter,riid,ppDXSurface)

#define IDXSurfaceFactory_CreateFromDDSurface(This,pDDrawSurface,pFormatID,dwFlags,punkOuter,riid,ppDXSurface)	\
    (This)->lpVtbl -> CreateFromDDSurface(This,pDDrawSurface,pFormatID,dwFlags,punkOuter,riid,ppDXSurface)

#define IDXSurfaceFactory_LoadImage(This,pszFileName,pDirectDraw,pDDSurfaceDesc,pFormatID,riid,ppDXSurface)	\
    (This)->lpVtbl -> LoadImage(This,pszFileName,pDirectDraw,pDDSurfaceDesc,pFormatID,riid,ppDXSurface)

#define IDXSurfaceFactory_LoadImageFromStream(This,pStream,pDirectDraw,pDDSurfaceDesc,pFormatID,riid,ppDXSurface)	\
    (This)->lpVtbl -> LoadImageFromStream(This,pStream,pDirectDraw,pDDSurfaceDesc,pFormatID,riid,ppDXSurface)

#define IDXSurfaceFactory_CopySurfaceToNewFormat(This,pSrc,pDirectDraw,pDDSurfaceDesc,pDestFormatID,ppNewSurface)	\
    (This)->lpVtbl -> CopySurfaceToNewFormat(This,pSrc,pDirectDraw,pDDSurfaceDesc,pDestFormatID,ppNewSurface)

#define IDXSurfaceFactory_CreateD3DRMTexture(This,pSrc,pDirectDraw,pD3DRM3,riid,ppTexture3)	\
    (This)->lpVtbl -> CreateD3DRMTexture(This,pSrc,pDirectDraw,pD3DRM3,riid,ppTexture3)

#define IDXSurfaceFactory_BitBlt(This,pDest,pPlacement,pSrc,pClipBounds,dwFlags)	\
    (This)->lpVtbl -> BitBlt(This,pDest,pPlacement,pSrc,pClipBounds,dwFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [local] */ HRESULT STDMETHODCALLTYPE IDXSurfaceFactory_CreateSurface_Proxy( 
    IDXSurfaceFactory * This,
    /* [in] */ IUnknown *pDirectDraw,
    /* [in] */ const DDSURFACEDESC *pDDSurfaceDesc,
    /* [in] */ const GUID *pFormatID,
    /* [in] */ const DXBNDS *pBounds,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IUnknown *punkOuter,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ void **ppDXSurface);


void __RPC_STUB IDXSurfaceFactory_CreateSurface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXSurfaceFactory_CreateFromDDSurface_Proxy( 
    IDXSurfaceFactory * This,
    /* [in] */ IUnknown *pDDrawSurface,
    /* [in] */ const GUID *pFormatID,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IUnknown *punkOuter,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ void **ppDXSurface);


void __RPC_STUB IDXSurfaceFactory_CreateFromDDSurface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [local] */ HRESULT STDMETHODCALLTYPE IDXSurfaceFactory_LoadImage_Proxy( 
    IDXSurfaceFactory * This,
    /* [in] */ const LPWSTR pszFileName,
    /* [in] */ IUnknown *pDirectDraw,
    /* [in] */ const DDSURFACEDESC *pDDSurfaceDesc,
    /* [in] */ const GUID *pFormatID,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ void **ppDXSurface);


void __RPC_STUB IDXSurfaceFactory_LoadImage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [local] */ HRESULT STDMETHODCALLTYPE IDXSurfaceFactory_LoadImageFromStream_Proxy( 
    IDXSurfaceFactory * This,
    /* [in] */ IStream *pStream,
    /* [in] */ IUnknown *pDirectDraw,
    /* [in] */ const DDSURFACEDESC *pDDSurfaceDesc,
    /* [in] */ const GUID *pFormatID,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ void **ppDXSurface);


void __RPC_STUB IDXSurfaceFactory_LoadImageFromStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [local] */ HRESULT STDMETHODCALLTYPE IDXSurfaceFactory_CopySurfaceToNewFormat_Proxy( 
    IDXSurfaceFactory * This,
    /* [in] */ IDXSurface *pSrc,
    /* [in] */ IUnknown *pDirectDraw,
    /* [in] */ const DDSURFACEDESC *pDDSurfaceDesc,
    /* [in] */ const GUID *pDestFormatID,
    /* [out] */ IDXSurface **ppNewSurface);


void __RPC_STUB IDXSurfaceFactory_CopySurfaceToNewFormat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [local] */ HRESULT STDMETHODCALLTYPE IDXSurfaceFactory_CreateD3DRMTexture_Proxy( 
    IDXSurfaceFactory * This,
    /* [in] */ IDXSurface *pSrc,
    /* [in] */ IUnknown *pDirectDraw,
    /* [in] */ IUnknown *pD3DRM3,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ void **ppTexture3);


void __RPC_STUB IDXSurfaceFactory_CreateD3DRMTexture_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXSurfaceFactory_BitBlt_Proxy( 
    IDXSurfaceFactory * This,
    /* [in] */ IDXSurface *pDest,
    /* [in] */ const DXVEC *pPlacement,
    /* [in] */ IDXSurface *pSrc,
    /* [in] */ const DXBNDS *pClipBounds,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IDXSurfaceFactory_BitBlt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXSurfaceFactory_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxtrans_0259 */
/* [local] */ 

typedef 
enum DXSURFMODCOMPOP
    {	DXSURFMOD_COMP_OVER	= 0,
	DXSURFMOD_COMP_ALPHA_MASK	= 1,
	DXSURFMOD_COMP_MAX_VALID	= 1
    } 	DXSURFMODCOMPOP;



extern RPC_IF_HANDLE __MIDL_itf_dxtrans_0259_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtrans_0259_v0_0_s_ifspec;

#ifndef __IDXSurfaceModifier_INTERFACE_DEFINED__
#define __IDXSurfaceModifier_INTERFACE_DEFINED__

/* interface IDXSurfaceModifier */
/* [object][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IDXSurfaceModifier;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9EA3B637-C37D-11d1-905E-00C04FD9189D")
    IDXSurfaceModifier : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetFillColor( 
            /* [in] */ DXSAMPLE Color) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFillColor( 
            /* [out] */ DXSAMPLE *pColor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBounds( 
            /* [in] */ const DXBNDS *pBounds) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBackground( 
            /* [in] */ IDXSurface *pSurface) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBackground( 
            /* [out] */ IDXSurface **ppSurface) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCompositeOperation( 
            /* [in] */ DXSURFMODCOMPOP CompOp) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCompositeOperation( 
            /* [out] */ DXSURFMODCOMPOP *pCompOp) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetForeground( 
            /* [in] */ IDXSurface *pSurface,
            /* [in] */ BOOL bTile,
            /* [in] */ const POINT *pOrigin) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetForeground( 
            /* [out] */ IDXSurface **ppSurface,
            /* [out] */ BOOL *pbTile,
            /* [out] */ POINT *pOrigin) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOpacity( 
            /* [in] */ float Opacity) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOpacity( 
            /* [out] */ float *pOpacity) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLookup( 
            /* [in] */ IDXLookupTable *pLookupTable) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLookup( 
            /* [out] */ IDXLookupTable **ppLookupTable) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXSurfaceModifierVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXSurfaceModifier * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXSurfaceModifier * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXSurfaceModifier * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetFillColor )( 
            IDXSurfaceModifier * This,
            /* [in] */ DXSAMPLE Color);
        
        HRESULT ( STDMETHODCALLTYPE *GetFillColor )( 
            IDXSurfaceModifier * This,
            /* [out] */ DXSAMPLE *pColor);
        
        HRESULT ( STDMETHODCALLTYPE *SetBounds )( 
            IDXSurfaceModifier * This,
            /* [in] */ const DXBNDS *pBounds);
        
        HRESULT ( STDMETHODCALLTYPE *SetBackground )( 
            IDXSurfaceModifier * This,
            /* [in] */ IDXSurface *pSurface);
        
        HRESULT ( STDMETHODCALLTYPE *GetBackground )( 
            IDXSurfaceModifier * This,
            /* [out] */ IDXSurface **ppSurface);
        
        HRESULT ( STDMETHODCALLTYPE *SetCompositeOperation )( 
            IDXSurfaceModifier * This,
            /* [in] */ DXSURFMODCOMPOP CompOp);
        
        HRESULT ( STDMETHODCALLTYPE *GetCompositeOperation )( 
            IDXSurfaceModifier * This,
            /* [out] */ DXSURFMODCOMPOP *pCompOp);
        
        HRESULT ( STDMETHODCALLTYPE *SetForeground )( 
            IDXSurfaceModifier * This,
            /* [in] */ IDXSurface *pSurface,
            /* [in] */ BOOL bTile,
            /* [in] */ const POINT *pOrigin);
        
        HRESULT ( STDMETHODCALLTYPE *GetForeground )( 
            IDXSurfaceModifier * This,
            /* [out] */ IDXSurface **ppSurface,
            /* [out] */ BOOL *pbTile,
            /* [out] */ POINT *pOrigin);
        
        HRESULT ( STDMETHODCALLTYPE *SetOpacity )( 
            IDXSurfaceModifier * This,
            /* [in] */ float Opacity);
        
        HRESULT ( STDMETHODCALLTYPE *GetOpacity )( 
            IDXSurfaceModifier * This,
            /* [out] */ float *pOpacity);
        
        HRESULT ( STDMETHODCALLTYPE *SetLookup )( 
            IDXSurfaceModifier * This,
            /* [in] */ IDXLookupTable *pLookupTable);
        
        HRESULT ( STDMETHODCALLTYPE *GetLookup )( 
            IDXSurfaceModifier * This,
            /* [out] */ IDXLookupTable **ppLookupTable);
        
        END_INTERFACE
    } IDXSurfaceModifierVtbl;

    interface IDXSurfaceModifier
    {
        CONST_VTBL struct IDXSurfaceModifierVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXSurfaceModifier_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXSurfaceModifier_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXSurfaceModifier_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXSurfaceModifier_SetFillColor(This,Color)	\
    (This)->lpVtbl -> SetFillColor(This,Color)

#define IDXSurfaceModifier_GetFillColor(This,pColor)	\
    (This)->lpVtbl -> GetFillColor(This,pColor)

#define IDXSurfaceModifier_SetBounds(This,pBounds)	\
    (This)->lpVtbl -> SetBounds(This,pBounds)

#define IDXSurfaceModifier_SetBackground(This,pSurface)	\
    (This)->lpVtbl -> SetBackground(This,pSurface)

#define IDXSurfaceModifier_GetBackground(This,ppSurface)	\
    (This)->lpVtbl -> GetBackground(This,ppSurface)

#define IDXSurfaceModifier_SetCompositeOperation(This,CompOp)	\
    (This)->lpVtbl -> SetCompositeOperation(This,CompOp)

#define IDXSurfaceModifier_GetCompositeOperation(This,pCompOp)	\
    (This)->lpVtbl -> GetCompositeOperation(This,pCompOp)

#define IDXSurfaceModifier_SetForeground(This,pSurface,bTile,pOrigin)	\
    (This)->lpVtbl -> SetForeground(This,pSurface,bTile,pOrigin)

#define IDXSurfaceModifier_GetForeground(This,ppSurface,pbTile,pOrigin)	\
    (This)->lpVtbl -> GetForeground(This,ppSurface,pbTile,pOrigin)

#define IDXSurfaceModifier_SetOpacity(This,Opacity)	\
    (This)->lpVtbl -> SetOpacity(This,Opacity)

#define IDXSurfaceModifier_GetOpacity(This,pOpacity)	\
    (This)->lpVtbl -> GetOpacity(This,pOpacity)

#define IDXSurfaceModifier_SetLookup(This,pLookupTable)	\
    (This)->lpVtbl -> SetLookup(This,pLookupTable)

#define IDXSurfaceModifier_GetLookup(This,ppLookupTable)	\
    (This)->lpVtbl -> GetLookup(This,ppLookupTable)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXSurfaceModifier_SetFillColor_Proxy( 
    IDXSurfaceModifier * This,
    /* [in] */ DXSAMPLE Color);


void __RPC_STUB IDXSurfaceModifier_SetFillColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXSurfaceModifier_GetFillColor_Proxy( 
    IDXSurfaceModifier * This,
    /* [out] */ DXSAMPLE *pColor);


void __RPC_STUB IDXSurfaceModifier_GetFillColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXSurfaceModifier_SetBounds_Proxy( 
    IDXSurfaceModifier * This,
    /* [in] */ const DXBNDS *pBounds);


void __RPC_STUB IDXSurfaceModifier_SetBounds_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXSurfaceModifier_SetBackground_Proxy( 
    IDXSurfaceModifier * This,
    /* [in] */ IDXSurface *pSurface);


void __RPC_STUB IDXSurfaceModifier_SetBackground_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXSurfaceModifier_GetBackground_Proxy( 
    IDXSurfaceModifier * This,
    /* [out] */ IDXSurface **ppSurface);


void __RPC_STUB IDXSurfaceModifier_GetBackground_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXSurfaceModifier_SetCompositeOperation_Proxy( 
    IDXSurfaceModifier * This,
    /* [in] */ DXSURFMODCOMPOP CompOp);


void __RPC_STUB IDXSurfaceModifier_SetCompositeOperation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXSurfaceModifier_GetCompositeOperation_Proxy( 
    IDXSurfaceModifier * This,
    /* [out] */ DXSURFMODCOMPOP *pCompOp);


void __RPC_STUB IDXSurfaceModifier_GetCompositeOperation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXSurfaceModifier_SetForeground_Proxy( 
    IDXSurfaceModifier * This,
    /* [in] */ IDXSurface *pSurface,
    /* [in] */ BOOL bTile,
    /* [in] */ const POINT *pOrigin);


void __RPC_STUB IDXSurfaceModifier_SetForeground_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXSurfaceModifier_GetForeground_Proxy( 
    IDXSurfaceModifier * This,
    /* [out] */ IDXSurface **ppSurface,
    /* [out] */ BOOL *pbTile,
    /* [out] */ POINT *pOrigin);


void __RPC_STUB IDXSurfaceModifier_GetForeground_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXSurfaceModifier_SetOpacity_Proxy( 
    IDXSurfaceModifier * This,
    /* [in] */ float Opacity);


void __RPC_STUB IDXSurfaceModifier_SetOpacity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXSurfaceModifier_GetOpacity_Proxy( 
    IDXSurfaceModifier * This,
    /* [out] */ float *pOpacity);


void __RPC_STUB IDXSurfaceModifier_GetOpacity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXSurfaceModifier_SetLookup_Proxy( 
    IDXSurfaceModifier * This,
    /* [in] */ IDXLookupTable *pLookupTable);


void __RPC_STUB IDXSurfaceModifier_SetLookup_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXSurfaceModifier_GetLookup_Proxy( 
    IDXSurfaceModifier * This,
    /* [out] */ IDXLookupTable **ppLookupTable);


void __RPC_STUB IDXSurfaceModifier_GetLookup_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXSurfaceModifier_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxtrans_0260 */
/* [local] */ 

typedef 
enum DXSAMPLEFORMATENUM
    {	DXPF_FLAGSMASK	= 0xffff0000,
	DXPF_NONPREMULT	= 0x10000,
	DXPF_TRANSPARENCY	= 0x20000,
	DXPF_TRANSLUCENCY	= 0x40000,
	DXPF_2BITERROR	= 0x200000,
	DXPF_3BITERROR	= 0x300000,
	DXPF_4BITERROR	= 0x400000,
	DXPF_5BITERROR	= 0x500000,
	DXPF_ERRORMASK	= 0x700000,
	DXPF_NONSTANDARD	= 0,
	DXPF_PMARGB32	= 1 | DXPF_TRANSPARENCY | DXPF_TRANSLUCENCY,
	DXPF_ARGB32	= 2 | DXPF_NONPREMULT | DXPF_TRANSPARENCY | DXPF_TRANSLUCENCY,
	DXPF_ARGB4444	= 3 | DXPF_NONPREMULT | DXPF_TRANSPARENCY | DXPF_TRANSLUCENCY | DXPF_4BITERROR,
	DXPF_A8	= 4 | DXPF_TRANSPARENCY | DXPF_TRANSLUCENCY,
	DXPF_RGB32	= 5,
	DXPF_RGB24	= 6,
	DXPF_RGB565	= 7 | DXPF_3BITERROR,
	DXPF_RGB555	= 8 | DXPF_3BITERROR,
	DXPF_RGB8	= 9 | DXPF_5BITERROR,
	DXPF_ARGB1555	= 10 | DXPF_TRANSPARENCY | DXPF_3BITERROR,
	DXPF_RGB32_CK	= DXPF_RGB32 | DXPF_TRANSPARENCY,
	DXPF_RGB24_CK	= DXPF_RGB24 | DXPF_TRANSPARENCY,
	DXPF_RGB555_CK	= DXPF_RGB555 | DXPF_TRANSPARENCY,
	DXPF_RGB565_CK	= DXPF_RGB565 | DXPF_TRANSPARENCY,
	DXPF_RGB8_CK	= DXPF_RGB8 | DXPF_TRANSPARENCY
    } 	DXSAMPLEFORMATENUM;

typedef 
enum DXLOCKSURF
    {	DXLOCKF_READ	= 0,
	DXLOCKF_READWRITE	= 1 << 0,
	DXLOCKF_EXISTINGINFOONLY	= 1 << 1,
	DXLOCKF_WANTRUNINFO	= 1 << 2,
	DXLOCKF_NONPREMULT	= 1 << 16,
	DXLOCKF_VALIDFLAGS	= DXLOCKF_READWRITE | DXLOCKF_EXISTINGINFOONLY | DXLOCKF_WANTRUNINFO | DXLOCKF_NONPREMULT
    } 	DXLOCKSURF;

typedef 
enum DXSURFSTATUS
    {	DXSURF_TRANSIENT	= 1 << 0,
	DXSURF_READONLY	= 1 << 1,
	DXSURF_VALIDFLAGS	= DXSURF_TRANSIENT | DXSURF_READONLY
    } 	DXSURFSTATUS;



extern RPC_IF_HANDLE __MIDL_itf_dxtrans_0260_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtrans_0260_v0_0_s_ifspec;

#ifndef __IDXSurface_INTERFACE_DEFINED__
#define __IDXSurface_INTERFACE_DEFINED__

/* interface IDXSurface */
/* [object][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IDXSurface;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B39FD73F-E139-11d1-9065-00C04FD9189D")
    IDXSurface : public IDXBaseObject
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPixelFormat( 
            /* [out] */ GUID *pFormatID,
            /* [out] */ DXSAMPLEFORMATENUM *pSampleFormatEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBounds( 
            /* [out] */ DXBNDS *pBounds) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStatusFlags( 
            /* [out] */ DWORD *pdwStatusFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStatusFlags( 
            /* [in] */ DWORD dwStatusFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LockSurface( 
            /* [in] */ const DXBNDS *pBounds,
            /* [in] */ ULONG ulTimeOut,
            /* [in] */ DWORD dwFlags,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppPointer,
            /* [out] */ ULONG *pulGenerationId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDirectDrawSurface( 
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppSurface) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetColorKey( 
            DXSAMPLE *pColorKey) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetColorKey( 
            DXSAMPLE ColorKey) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LockSurfaceDC( 
            /* [in] */ const DXBNDS *pBounds,
            /* [in] */ ULONG ulTimeOut,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDXDCLock **ppDCLock) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAppData( 
            DWORD_PTR dwAppData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAppData( 
            DWORD_PTR *pdwAppData) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXSurfaceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXSurface * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXSurface * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXSurface * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetGenerationId )( 
            IDXSurface * This,
            /* [out] */ ULONG *pID);
        
        HRESULT ( STDMETHODCALLTYPE *IncrementGenerationId )( 
            IDXSurface * This,
            /* [in] */ BOOL bRefresh);
        
        HRESULT ( STDMETHODCALLTYPE *GetObjectSize )( 
            IDXSurface * This,
            /* [out] */ ULONG *pcbSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetPixelFormat )( 
            IDXSurface * This,
            /* [out] */ GUID *pFormatID,
            /* [out] */ DXSAMPLEFORMATENUM *pSampleFormatEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetBounds )( 
            IDXSurface * This,
            /* [out] */ DXBNDS *pBounds);
        
        HRESULT ( STDMETHODCALLTYPE *GetStatusFlags )( 
            IDXSurface * This,
            /* [out] */ DWORD *pdwStatusFlags);
        
        HRESULT ( STDMETHODCALLTYPE *SetStatusFlags )( 
            IDXSurface * This,
            /* [in] */ DWORD dwStatusFlags);
        
        HRESULT ( STDMETHODCALLTYPE *LockSurface )( 
            IDXSurface * This,
            /* [in] */ const DXBNDS *pBounds,
            /* [in] */ ULONG ulTimeOut,
            /* [in] */ DWORD dwFlags,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppPointer,
            /* [out] */ ULONG *pulGenerationId);
        
        HRESULT ( STDMETHODCALLTYPE *GetDirectDrawSurface )( 
            IDXSurface * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppSurface);
        
        HRESULT ( STDMETHODCALLTYPE *GetColorKey )( 
            IDXSurface * This,
            DXSAMPLE *pColorKey);
        
        HRESULT ( STDMETHODCALLTYPE *SetColorKey )( 
            IDXSurface * This,
            DXSAMPLE ColorKey);
        
        HRESULT ( STDMETHODCALLTYPE *LockSurfaceDC )( 
            IDXSurface * This,
            /* [in] */ const DXBNDS *pBounds,
            /* [in] */ ULONG ulTimeOut,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDXDCLock **ppDCLock);
        
        HRESULT ( STDMETHODCALLTYPE *SetAppData )( 
            IDXSurface * This,
            DWORD_PTR dwAppData);
        
        HRESULT ( STDMETHODCALLTYPE *GetAppData )( 
            IDXSurface * This,
            DWORD_PTR *pdwAppData);
        
        END_INTERFACE
    } IDXSurfaceVtbl;

    interface IDXSurface
    {
        CONST_VTBL struct IDXSurfaceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXSurface_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXSurface_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXSurface_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXSurface_GetGenerationId(This,pID)	\
    (This)->lpVtbl -> GetGenerationId(This,pID)

#define IDXSurface_IncrementGenerationId(This,bRefresh)	\
    (This)->lpVtbl -> IncrementGenerationId(This,bRefresh)

#define IDXSurface_GetObjectSize(This,pcbSize)	\
    (This)->lpVtbl -> GetObjectSize(This,pcbSize)


#define IDXSurface_GetPixelFormat(This,pFormatID,pSampleFormatEnum)	\
    (This)->lpVtbl -> GetPixelFormat(This,pFormatID,pSampleFormatEnum)

#define IDXSurface_GetBounds(This,pBounds)	\
    (This)->lpVtbl -> GetBounds(This,pBounds)

#define IDXSurface_GetStatusFlags(This,pdwStatusFlags)	\
    (This)->lpVtbl -> GetStatusFlags(This,pdwStatusFlags)

#define IDXSurface_SetStatusFlags(This,dwStatusFlags)	\
    (This)->lpVtbl -> SetStatusFlags(This,dwStatusFlags)

#define IDXSurface_LockSurface(This,pBounds,ulTimeOut,dwFlags,riid,ppPointer,pulGenerationId)	\
    (This)->lpVtbl -> LockSurface(This,pBounds,ulTimeOut,dwFlags,riid,ppPointer,pulGenerationId)

#define IDXSurface_GetDirectDrawSurface(This,riid,ppSurface)	\
    (This)->lpVtbl -> GetDirectDrawSurface(This,riid,ppSurface)

#define IDXSurface_GetColorKey(This,pColorKey)	\
    (This)->lpVtbl -> GetColorKey(This,pColorKey)

#define IDXSurface_SetColorKey(This,ColorKey)	\
    (This)->lpVtbl -> SetColorKey(This,ColorKey)

#define IDXSurface_LockSurfaceDC(This,pBounds,ulTimeOut,dwFlags,ppDCLock)	\
    (This)->lpVtbl -> LockSurfaceDC(This,pBounds,ulTimeOut,dwFlags,ppDCLock)

#define IDXSurface_SetAppData(This,dwAppData)	\
    (This)->lpVtbl -> SetAppData(This,dwAppData)

#define IDXSurface_GetAppData(This,pdwAppData)	\
    (This)->lpVtbl -> GetAppData(This,pdwAppData)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXSurface_GetPixelFormat_Proxy( 
    IDXSurface * This,
    /* [out] */ GUID *pFormatID,
    /* [out] */ DXSAMPLEFORMATENUM *pSampleFormatEnum);


void __RPC_STUB IDXSurface_GetPixelFormat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXSurface_GetBounds_Proxy( 
    IDXSurface * This,
    /* [out] */ DXBNDS *pBounds);


void __RPC_STUB IDXSurface_GetBounds_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXSurface_GetStatusFlags_Proxy( 
    IDXSurface * This,
    /* [out] */ DWORD *pdwStatusFlags);


void __RPC_STUB IDXSurface_GetStatusFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXSurface_SetStatusFlags_Proxy( 
    IDXSurface * This,
    /* [in] */ DWORD dwStatusFlags);


void __RPC_STUB IDXSurface_SetStatusFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXSurface_LockSurface_Proxy( 
    IDXSurface * This,
    /* [in] */ const DXBNDS *pBounds,
    /* [in] */ ULONG ulTimeOut,
    /* [in] */ DWORD dwFlags,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ void **ppPointer,
    /* [out] */ ULONG *pulGenerationId);


void __RPC_STUB IDXSurface_LockSurface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXSurface_GetDirectDrawSurface_Proxy( 
    IDXSurface * This,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ void **ppSurface);


void __RPC_STUB IDXSurface_GetDirectDrawSurface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXSurface_GetColorKey_Proxy( 
    IDXSurface * This,
    DXSAMPLE *pColorKey);


void __RPC_STUB IDXSurface_GetColorKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXSurface_SetColorKey_Proxy( 
    IDXSurface * This,
    DXSAMPLE ColorKey);


void __RPC_STUB IDXSurface_SetColorKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXSurface_LockSurfaceDC_Proxy( 
    IDXSurface * This,
    /* [in] */ const DXBNDS *pBounds,
    /* [in] */ ULONG ulTimeOut,
    /* [in] */ DWORD dwFlags,
    /* [out] */ IDXDCLock **ppDCLock);


void __RPC_STUB IDXSurface_LockSurfaceDC_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXSurface_SetAppData_Proxy( 
    IDXSurface * This,
    DWORD_PTR dwAppData);


void __RPC_STUB IDXSurface_SetAppData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXSurface_GetAppData_Proxy( 
    IDXSurface * This,
    DWORD_PTR *pdwAppData);


void __RPC_STUB IDXSurface_GetAppData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXSurface_INTERFACE_DEFINED__ */


#ifndef __IDXSurfaceInit_INTERFACE_DEFINED__
#define __IDXSurfaceInit_INTERFACE_DEFINED__

/* interface IDXSurfaceInit */
/* [object][local][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IDXSurfaceInit;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9EA3B639-C37D-11d1-905E-00C04FD9189D")
    IDXSurfaceInit : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InitSurface( 
            /* [in] */ IUnknown *pDirectDraw,
            /* [in] */ const DDSURFACEDESC *pDDSurfaceDesc,
            /* [in] */ const GUID *pFormatID,
            /* [in] */ const DXBNDS *pBounds,
            /* [in] */ DWORD dwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXSurfaceInitVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXSurfaceInit * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXSurfaceInit * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXSurfaceInit * This);
        
        HRESULT ( STDMETHODCALLTYPE *InitSurface )( 
            IDXSurfaceInit * This,
            /* [in] */ IUnknown *pDirectDraw,
            /* [in] */ const DDSURFACEDESC *pDDSurfaceDesc,
            /* [in] */ const GUID *pFormatID,
            /* [in] */ const DXBNDS *pBounds,
            /* [in] */ DWORD dwFlags);
        
        END_INTERFACE
    } IDXSurfaceInitVtbl;

    interface IDXSurfaceInit
    {
        CONST_VTBL struct IDXSurfaceInitVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXSurfaceInit_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXSurfaceInit_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXSurfaceInit_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXSurfaceInit_InitSurface(This,pDirectDraw,pDDSurfaceDesc,pFormatID,pBounds,dwFlags)	\
    (This)->lpVtbl -> InitSurface(This,pDirectDraw,pDDSurfaceDesc,pFormatID,pBounds,dwFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXSurfaceInit_InitSurface_Proxy( 
    IDXSurfaceInit * This,
    /* [in] */ IUnknown *pDirectDraw,
    /* [in] */ const DDSURFACEDESC *pDDSurfaceDesc,
    /* [in] */ const GUID *pFormatID,
    /* [in] */ const DXBNDS *pBounds,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IDXSurfaceInit_InitSurface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXSurfaceInit_INTERFACE_DEFINED__ */


#ifndef __IDXARGBSurfaceInit_INTERFACE_DEFINED__
#define __IDXARGBSurfaceInit_INTERFACE_DEFINED__

/* interface IDXARGBSurfaceInit */
/* [object][local][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IDXARGBSurfaceInit;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9EA3B63A-C37D-11d1-905E-00C04FD9189D")
    IDXARGBSurfaceInit : public IDXSurfaceInit
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InitFromDDSurface( 
            /* [in] */ IUnknown *pDDrawSurface,
            /* [in] */ const GUID *pFormatID,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InitFromRawSurface( 
            /* [in] */ IDXRawSurface *pRawSurface) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXARGBSurfaceInitVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXARGBSurfaceInit * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXARGBSurfaceInit * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXARGBSurfaceInit * This);
        
        HRESULT ( STDMETHODCALLTYPE *InitSurface )( 
            IDXARGBSurfaceInit * This,
            /* [in] */ IUnknown *pDirectDraw,
            /* [in] */ const DDSURFACEDESC *pDDSurfaceDesc,
            /* [in] */ const GUID *pFormatID,
            /* [in] */ const DXBNDS *pBounds,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *InitFromDDSurface )( 
            IDXARGBSurfaceInit * This,
            /* [in] */ IUnknown *pDDrawSurface,
            /* [in] */ const GUID *pFormatID,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *InitFromRawSurface )( 
            IDXARGBSurfaceInit * This,
            /* [in] */ IDXRawSurface *pRawSurface);
        
        END_INTERFACE
    } IDXARGBSurfaceInitVtbl;

    interface IDXARGBSurfaceInit
    {
        CONST_VTBL struct IDXARGBSurfaceInitVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXARGBSurfaceInit_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXARGBSurfaceInit_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXARGBSurfaceInit_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXARGBSurfaceInit_InitSurface(This,pDirectDraw,pDDSurfaceDesc,pFormatID,pBounds,dwFlags)	\
    (This)->lpVtbl -> InitSurface(This,pDirectDraw,pDDSurfaceDesc,pFormatID,pBounds,dwFlags)


#define IDXARGBSurfaceInit_InitFromDDSurface(This,pDDrawSurface,pFormatID,dwFlags)	\
    (This)->lpVtbl -> InitFromDDSurface(This,pDDrawSurface,pFormatID,dwFlags)

#define IDXARGBSurfaceInit_InitFromRawSurface(This,pRawSurface)	\
    (This)->lpVtbl -> InitFromRawSurface(This,pRawSurface)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXARGBSurfaceInit_InitFromDDSurface_Proxy( 
    IDXARGBSurfaceInit * This,
    /* [in] */ IUnknown *pDDrawSurface,
    /* [in] */ const GUID *pFormatID,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IDXARGBSurfaceInit_InitFromDDSurface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXARGBSurfaceInit_InitFromRawSurface_Proxy( 
    IDXARGBSurfaceInit * This,
    /* [in] */ IDXRawSurface *pRawSurface);


void __RPC_STUB IDXARGBSurfaceInit_InitFromRawSurface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXARGBSurfaceInit_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxtrans_0263 */
/* [local] */ 

typedef struct tagDXNATIVETYPEINFO
    {
    BYTE *pCurrentData;
    BYTE *pFirstByte;
    long lPitch;
    DWORD dwColorKey;
    } 	DXNATIVETYPEINFO;

typedef struct tagDXPACKEDRECTDESC
    {
    DXBASESAMPLE *pSamples;
    BOOL bPremult;
    RECT rect;
    long lRowPadding;
    } 	DXPACKEDRECTDESC;

typedef struct tagDXOVERSAMPLEDESC
    {
    POINT p;
    DXPMSAMPLE Color;
    } 	DXOVERSAMPLEDESC;



extern RPC_IF_HANDLE __MIDL_itf_dxtrans_0263_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtrans_0263_v0_0_s_ifspec;

#ifndef __IDXARGBReadPtr_INTERFACE_DEFINED__
#define __IDXARGBReadPtr_INTERFACE_DEFINED__

/* interface IDXARGBReadPtr */
/* [object][local][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IDXARGBReadPtr;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("EAAAC2D6-C290-11d1-905D-00C04FD9189D")
    IDXARGBReadPtr : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSurface( 
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppSurface) = 0;
        
        virtual DXSAMPLEFORMATENUM STDMETHODCALLTYPE GetNativeType( 
            /* [out] */ DXNATIVETYPEINFO *pInfo) = 0;
        
        virtual void STDMETHODCALLTYPE Move( 
            /* [in] */ long cSamples) = 0;
        
        virtual void STDMETHODCALLTYPE MoveToRow( 
            /* [in] */ ULONG y) = 0;
        
        virtual void STDMETHODCALLTYPE MoveToXY( 
            /* [in] */ ULONG x,
            /* [in] */ ULONG y) = 0;
        
        virtual ULONG STDMETHODCALLTYPE MoveAndGetRunInfo( 
            /* [in] */ ULONG Row,
            /* [out] */ const DXRUNINFO **ppInfo) = 0;
        
        virtual DXSAMPLE *STDMETHODCALLTYPE Unpack( 
            /* [in] */ DXSAMPLE *pSamples,
            /* [in] */ ULONG cSamples,
            /* [in] */ BOOL bMove) = 0;
        
        virtual DXPMSAMPLE *STDMETHODCALLTYPE UnpackPremult( 
            /* [in] */ DXPMSAMPLE *pSamples,
            /* [in] */ ULONG cSamples,
            /* [in] */ BOOL bMove) = 0;
        
        virtual void STDMETHODCALLTYPE UnpackRect( 
            /* [in] */ const DXPACKEDRECTDESC *pRectDesc) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXARGBReadPtrVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXARGBReadPtr * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXARGBReadPtr * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXARGBReadPtr * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetSurface )( 
            IDXARGBReadPtr * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppSurface);
        
        DXSAMPLEFORMATENUM ( STDMETHODCALLTYPE *GetNativeType )( 
            IDXARGBReadPtr * This,
            /* [out] */ DXNATIVETYPEINFO *pInfo);
        
        void ( STDMETHODCALLTYPE *Move )( 
            IDXARGBReadPtr * This,
            /* [in] */ long cSamples);
        
        void ( STDMETHODCALLTYPE *MoveToRow )( 
            IDXARGBReadPtr * This,
            /* [in] */ ULONG y);
        
        void ( STDMETHODCALLTYPE *MoveToXY )( 
            IDXARGBReadPtr * This,
            /* [in] */ ULONG x,
            /* [in] */ ULONG y);
        
        ULONG ( STDMETHODCALLTYPE *MoveAndGetRunInfo )( 
            IDXARGBReadPtr * This,
            /* [in] */ ULONG Row,
            /* [out] */ const DXRUNINFO **ppInfo);
        
        DXSAMPLE *( STDMETHODCALLTYPE *Unpack )( 
            IDXARGBReadPtr * This,
            /* [in] */ DXSAMPLE *pSamples,
            /* [in] */ ULONG cSamples,
            /* [in] */ BOOL bMove);
        
        DXPMSAMPLE *( STDMETHODCALLTYPE *UnpackPremult )( 
            IDXARGBReadPtr * This,
            /* [in] */ DXPMSAMPLE *pSamples,
            /* [in] */ ULONG cSamples,
            /* [in] */ BOOL bMove);
        
        void ( STDMETHODCALLTYPE *UnpackRect )( 
            IDXARGBReadPtr * This,
            /* [in] */ const DXPACKEDRECTDESC *pRectDesc);
        
        END_INTERFACE
    } IDXARGBReadPtrVtbl;

    interface IDXARGBReadPtr
    {
        CONST_VTBL struct IDXARGBReadPtrVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXARGBReadPtr_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXARGBReadPtr_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXARGBReadPtr_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXARGBReadPtr_GetSurface(This,riid,ppSurface)	\
    (This)->lpVtbl -> GetSurface(This,riid,ppSurface)

#define IDXARGBReadPtr_GetNativeType(This,pInfo)	\
    (This)->lpVtbl -> GetNativeType(This,pInfo)

#define IDXARGBReadPtr_Move(This,cSamples)	\
    (This)->lpVtbl -> Move(This,cSamples)

#define IDXARGBReadPtr_MoveToRow(This,y)	\
    (This)->lpVtbl -> MoveToRow(This,y)

#define IDXARGBReadPtr_MoveToXY(This,x,y)	\
    (This)->lpVtbl -> MoveToXY(This,x,y)

#define IDXARGBReadPtr_MoveAndGetRunInfo(This,Row,ppInfo)	\
    (This)->lpVtbl -> MoveAndGetRunInfo(This,Row,ppInfo)

#define IDXARGBReadPtr_Unpack(This,pSamples,cSamples,bMove)	\
    (This)->lpVtbl -> Unpack(This,pSamples,cSamples,bMove)

#define IDXARGBReadPtr_UnpackPremult(This,pSamples,cSamples,bMove)	\
    (This)->lpVtbl -> UnpackPremult(This,pSamples,cSamples,bMove)

#define IDXARGBReadPtr_UnpackRect(This,pRectDesc)	\
    (This)->lpVtbl -> UnpackRect(This,pRectDesc)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXARGBReadPtr_GetSurface_Proxy( 
    IDXARGBReadPtr * This,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ void **ppSurface);


void __RPC_STUB IDXARGBReadPtr_GetSurface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


DXSAMPLEFORMATENUM STDMETHODCALLTYPE IDXARGBReadPtr_GetNativeType_Proxy( 
    IDXARGBReadPtr * This,
    /* [out] */ DXNATIVETYPEINFO *pInfo);


void __RPC_STUB IDXARGBReadPtr_GetNativeType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void STDMETHODCALLTYPE IDXARGBReadPtr_Move_Proxy( 
    IDXARGBReadPtr * This,
    /* [in] */ long cSamples);


void __RPC_STUB IDXARGBReadPtr_Move_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void STDMETHODCALLTYPE IDXARGBReadPtr_MoveToRow_Proxy( 
    IDXARGBReadPtr * This,
    /* [in] */ ULONG y);


void __RPC_STUB IDXARGBReadPtr_MoveToRow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void STDMETHODCALLTYPE IDXARGBReadPtr_MoveToXY_Proxy( 
    IDXARGBReadPtr * This,
    /* [in] */ ULONG x,
    /* [in] */ ULONG y);


void __RPC_STUB IDXARGBReadPtr_MoveToXY_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


ULONG STDMETHODCALLTYPE IDXARGBReadPtr_MoveAndGetRunInfo_Proxy( 
    IDXARGBReadPtr * This,
    /* [in] */ ULONG Row,
    /* [out] */ const DXRUNINFO **ppInfo);


void __RPC_STUB IDXARGBReadPtr_MoveAndGetRunInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


DXSAMPLE *STDMETHODCALLTYPE IDXARGBReadPtr_Unpack_Proxy( 
    IDXARGBReadPtr * This,
    /* [in] */ DXSAMPLE *pSamples,
    /* [in] */ ULONG cSamples,
    /* [in] */ BOOL bMove);


void __RPC_STUB IDXARGBReadPtr_Unpack_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


DXPMSAMPLE *STDMETHODCALLTYPE IDXARGBReadPtr_UnpackPremult_Proxy( 
    IDXARGBReadPtr * This,
    /* [in] */ DXPMSAMPLE *pSamples,
    /* [in] */ ULONG cSamples,
    /* [in] */ BOOL bMove);


void __RPC_STUB IDXARGBReadPtr_UnpackPremult_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void STDMETHODCALLTYPE IDXARGBReadPtr_UnpackRect_Proxy( 
    IDXARGBReadPtr * This,
    /* [in] */ const DXPACKEDRECTDESC *pRectDesc);


void __RPC_STUB IDXARGBReadPtr_UnpackRect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXARGBReadPtr_INTERFACE_DEFINED__ */


#ifndef __IDXARGBReadWritePtr_INTERFACE_DEFINED__
#define __IDXARGBReadWritePtr_INTERFACE_DEFINED__

/* interface IDXARGBReadWritePtr */
/* [object][local][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IDXARGBReadWritePtr;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("EAAAC2D7-C290-11d1-905D-00C04FD9189D")
    IDXARGBReadWritePtr : public IDXARGBReadPtr
    {
    public:
        virtual void STDMETHODCALLTYPE PackAndMove( 
            /* [in] */ const DXSAMPLE *pSamples,
            /* [in] */ ULONG cSamples) = 0;
        
        virtual void STDMETHODCALLTYPE PackPremultAndMove( 
            /* [in] */ const DXPMSAMPLE *pSamples,
            /* [in] */ ULONG cSamples) = 0;
        
        virtual void STDMETHODCALLTYPE PackRect( 
            /* [in] */ const DXPACKEDRECTDESC *pRectDesc) = 0;
        
        virtual void STDMETHODCALLTYPE CopyAndMoveBoth( 
            /* [in] */ DXBASESAMPLE *pScratchBuffer,
            /* [in] */ IDXARGBReadPtr *pSrc,
            /* [in] */ ULONG cSamples,
            /* [in] */ BOOL bIsOpaque) = 0;
        
        virtual void STDMETHODCALLTYPE CopyRect( 
            /* [in] */ DXBASESAMPLE *pScratchBuffer,
            /* [in] */ const RECT *pDestRect,
            /* [in] */ IDXARGBReadPtr *pSrc,
            /* [in] */ const POINT *pSrcOrigin,
            /* [in] */ BOOL bIsOpaque) = 0;
        
        virtual void STDMETHODCALLTYPE FillAndMove( 
            /* [in] */ DXBASESAMPLE *pScratchBuffer,
            /* [in] */ DXPMSAMPLE SampVal,
            /* [in] */ ULONG cSamples,
            /* [in] */ BOOL bDoOver) = 0;
        
        virtual void STDMETHODCALLTYPE FillRect( 
            /* [in] */ const RECT *pRect,
            /* [in] */ DXPMSAMPLE SampVal,
            /* [in] */ BOOL bDoOver) = 0;
        
        virtual void STDMETHODCALLTYPE OverSample( 
            /* [in] */ const DXOVERSAMPLEDESC *pOverDesc) = 0;
        
        virtual void STDMETHODCALLTYPE OverArrayAndMove( 
            /* [in] */ DXBASESAMPLE *pScratchBuffer,
            /* [in] */ const DXPMSAMPLE *pSrc,
            /* [in] */ ULONG cSamples) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXARGBReadWritePtrVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXARGBReadWritePtr * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXARGBReadWritePtr * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXARGBReadWritePtr * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetSurface )( 
            IDXARGBReadWritePtr * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppSurface);
        
        DXSAMPLEFORMATENUM ( STDMETHODCALLTYPE *GetNativeType )( 
            IDXARGBReadWritePtr * This,
            /* [out] */ DXNATIVETYPEINFO *pInfo);
        
        void ( STDMETHODCALLTYPE *Move )( 
            IDXARGBReadWritePtr * This,
            /* [in] */ long cSamples);
        
        void ( STDMETHODCALLTYPE *MoveToRow )( 
            IDXARGBReadWritePtr * This,
            /* [in] */ ULONG y);
        
        void ( STDMETHODCALLTYPE *MoveToXY )( 
            IDXARGBReadWritePtr * This,
            /* [in] */ ULONG x,
            /* [in] */ ULONG y);
        
        ULONG ( STDMETHODCALLTYPE *MoveAndGetRunInfo )( 
            IDXARGBReadWritePtr * This,
            /* [in] */ ULONG Row,
            /* [out] */ const DXRUNINFO **ppInfo);
        
        DXSAMPLE *( STDMETHODCALLTYPE *Unpack )( 
            IDXARGBReadWritePtr * This,
            /* [in] */ DXSAMPLE *pSamples,
            /* [in] */ ULONG cSamples,
            /* [in] */ BOOL bMove);
        
        DXPMSAMPLE *( STDMETHODCALLTYPE *UnpackPremult )( 
            IDXARGBReadWritePtr * This,
            /* [in] */ DXPMSAMPLE *pSamples,
            /* [in] */ ULONG cSamples,
            /* [in] */ BOOL bMove);
        
        void ( STDMETHODCALLTYPE *UnpackRect )( 
            IDXARGBReadWritePtr * This,
            /* [in] */ const DXPACKEDRECTDESC *pRectDesc);
        
        void ( STDMETHODCALLTYPE *PackAndMove )( 
            IDXARGBReadWritePtr * This,
            /* [in] */ const DXSAMPLE *pSamples,
            /* [in] */ ULONG cSamples);
        
        void ( STDMETHODCALLTYPE *PackPremultAndMove )( 
            IDXARGBReadWritePtr * This,
            /* [in] */ const DXPMSAMPLE *pSamples,
            /* [in] */ ULONG cSamples);
        
        void ( STDMETHODCALLTYPE *PackRect )( 
            IDXARGBReadWritePtr * This,
            /* [in] */ const DXPACKEDRECTDESC *pRectDesc);
        
        void ( STDMETHODCALLTYPE *CopyAndMoveBoth )( 
            IDXARGBReadWritePtr * This,
            /* [in] */ DXBASESAMPLE *pScratchBuffer,
            /* [in] */ IDXARGBReadPtr *pSrc,
            /* [in] */ ULONG cSamples,
            /* [in] */ BOOL bIsOpaque);
        
        void ( STDMETHODCALLTYPE *CopyRect )( 
            IDXARGBReadWritePtr * This,
            /* [in] */ DXBASESAMPLE *pScratchBuffer,
            /* [in] */ const RECT *pDestRect,
            /* [in] */ IDXARGBReadPtr *pSrc,
            /* [in] */ const POINT *pSrcOrigin,
            /* [in] */ BOOL bIsOpaque);
        
        void ( STDMETHODCALLTYPE *FillAndMove )( 
            IDXARGBReadWritePtr * This,
            /* [in] */ DXBASESAMPLE *pScratchBuffer,
            /* [in] */ DXPMSAMPLE SampVal,
            /* [in] */ ULONG cSamples,
            /* [in] */ BOOL bDoOver);
        
        void ( STDMETHODCALLTYPE *FillRect )( 
            IDXARGBReadWritePtr * This,
            /* [in] */ const RECT *pRect,
            /* [in] */ DXPMSAMPLE SampVal,
            /* [in] */ BOOL bDoOver);
        
        void ( STDMETHODCALLTYPE *OverSample )( 
            IDXARGBReadWritePtr * This,
            /* [in] */ const DXOVERSAMPLEDESC *pOverDesc);
        
        void ( STDMETHODCALLTYPE *OverArrayAndMove )( 
            IDXARGBReadWritePtr * This,
            /* [in] */ DXBASESAMPLE *pScratchBuffer,
            /* [in] */ const DXPMSAMPLE *pSrc,
            /* [in] */ ULONG cSamples);
        
        END_INTERFACE
    } IDXARGBReadWritePtrVtbl;

    interface IDXARGBReadWritePtr
    {
        CONST_VTBL struct IDXARGBReadWritePtrVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXARGBReadWritePtr_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXARGBReadWritePtr_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXARGBReadWritePtr_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXARGBReadWritePtr_GetSurface(This,riid,ppSurface)	\
    (This)->lpVtbl -> GetSurface(This,riid,ppSurface)

#define IDXARGBReadWritePtr_GetNativeType(This,pInfo)	\
    (This)->lpVtbl -> GetNativeType(This,pInfo)

#define IDXARGBReadWritePtr_Move(This,cSamples)	\
    (This)->lpVtbl -> Move(This,cSamples)

#define IDXARGBReadWritePtr_MoveToRow(This,y)	\
    (This)->lpVtbl -> MoveToRow(This,y)

#define IDXARGBReadWritePtr_MoveToXY(This,x,y)	\
    (This)->lpVtbl -> MoveToXY(This,x,y)

#define IDXARGBReadWritePtr_MoveAndGetRunInfo(This,Row,ppInfo)	\
    (This)->lpVtbl -> MoveAndGetRunInfo(This,Row,ppInfo)

#define IDXARGBReadWritePtr_Unpack(This,pSamples,cSamples,bMove)	\
    (This)->lpVtbl -> Unpack(This,pSamples,cSamples,bMove)

#define IDXARGBReadWritePtr_UnpackPremult(This,pSamples,cSamples,bMove)	\
    (This)->lpVtbl -> UnpackPremult(This,pSamples,cSamples,bMove)

#define IDXARGBReadWritePtr_UnpackRect(This,pRectDesc)	\
    (This)->lpVtbl -> UnpackRect(This,pRectDesc)


#define IDXARGBReadWritePtr_PackAndMove(This,pSamples,cSamples)	\
    (This)->lpVtbl -> PackAndMove(This,pSamples,cSamples)

#define IDXARGBReadWritePtr_PackPremultAndMove(This,pSamples,cSamples)	\
    (This)->lpVtbl -> PackPremultAndMove(This,pSamples,cSamples)

#define IDXARGBReadWritePtr_PackRect(This,pRectDesc)	\
    (This)->lpVtbl -> PackRect(This,pRectDesc)

#define IDXARGBReadWritePtr_CopyAndMoveBoth(This,pScratchBuffer,pSrc,cSamples,bIsOpaque)	\
    (This)->lpVtbl -> CopyAndMoveBoth(This,pScratchBuffer,pSrc,cSamples,bIsOpaque)

#define IDXARGBReadWritePtr_CopyRect(This,pScratchBuffer,pDestRect,pSrc,pSrcOrigin,bIsOpaque)	\
    (This)->lpVtbl -> CopyRect(This,pScratchBuffer,pDestRect,pSrc,pSrcOrigin,bIsOpaque)

#define IDXARGBReadWritePtr_FillAndMove(This,pScratchBuffer,SampVal,cSamples,bDoOver)	\
    (This)->lpVtbl -> FillAndMove(This,pScratchBuffer,SampVal,cSamples,bDoOver)

#define IDXARGBReadWritePtr_FillRect(This,pRect,SampVal,bDoOver)	\
    (This)->lpVtbl -> FillRect(This,pRect,SampVal,bDoOver)

#define IDXARGBReadWritePtr_OverSample(This,pOverDesc)	\
    (This)->lpVtbl -> OverSample(This,pOverDesc)

#define IDXARGBReadWritePtr_OverArrayAndMove(This,pScratchBuffer,pSrc,cSamples)	\
    (This)->lpVtbl -> OverArrayAndMove(This,pScratchBuffer,pSrc,cSamples)

#endif /* COBJMACROS */


#endif 	/* C style interface */



void STDMETHODCALLTYPE IDXARGBReadWritePtr_PackAndMove_Proxy( 
    IDXARGBReadWritePtr * This,
    /* [in] */ const DXSAMPLE *pSamples,
    /* [in] */ ULONG cSamples);


void __RPC_STUB IDXARGBReadWritePtr_PackAndMove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void STDMETHODCALLTYPE IDXARGBReadWritePtr_PackPremultAndMove_Proxy( 
    IDXARGBReadWritePtr * This,
    /* [in] */ const DXPMSAMPLE *pSamples,
    /* [in] */ ULONG cSamples);


void __RPC_STUB IDXARGBReadWritePtr_PackPremultAndMove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void STDMETHODCALLTYPE IDXARGBReadWritePtr_PackRect_Proxy( 
    IDXARGBReadWritePtr * This,
    /* [in] */ const DXPACKEDRECTDESC *pRectDesc);


void __RPC_STUB IDXARGBReadWritePtr_PackRect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void STDMETHODCALLTYPE IDXARGBReadWritePtr_CopyAndMoveBoth_Proxy( 
    IDXARGBReadWritePtr * This,
    /* [in] */ DXBASESAMPLE *pScratchBuffer,
    /* [in] */ IDXARGBReadPtr *pSrc,
    /* [in] */ ULONG cSamples,
    /* [in] */ BOOL bIsOpaque);


void __RPC_STUB IDXARGBReadWritePtr_CopyAndMoveBoth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void STDMETHODCALLTYPE IDXARGBReadWritePtr_CopyRect_Proxy( 
    IDXARGBReadWritePtr * This,
    /* [in] */ DXBASESAMPLE *pScratchBuffer,
    /* [in] */ const RECT *pDestRect,
    /* [in] */ IDXARGBReadPtr *pSrc,
    /* [in] */ const POINT *pSrcOrigin,
    /* [in] */ BOOL bIsOpaque);


void __RPC_STUB IDXARGBReadWritePtr_CopyRect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void STDMETHODCALLTYPE IDXARGBReadWritePtr_FillAndMove_Proxy( 
    IDXARGBReadWritePtr * This,
    /* [in] */ DXBASESAMPLE *pScratchBuffer,
    /* [in] */ DXPMSAMPLE SampVal,
    /* [in] */ ULONG cSamples,
    /* [in] */ BOOL bDoOver);


void __RPC_STUB IDXARGBReadWritePtr_FillAndMove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void STDMETHODCALLTYPE IDXARGBReadWritePtr_FillRect_Proxy( 
    IDXARGBReadWritePtr * This,
    /* [in] */ const RECT *pRect,
    /* [in] */ DXPMSAMPLE SampVal,
    /* [in] */ BOOL bDoOver);


void __RPC_STUB IDXARGBReadWritePtr_FillRect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void STDMETHODCALLTYPE IDXARGBReadWritePtr_OverSample_Proxy( 
    IDXARGBReadWritePtr * This,
    /* [in] */ const DXOVERSAMPLEDESC *pOverDesc);


void __RPC_STUB IDXARGBReadWritePtr_OverSample_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void STDMETHODCALLTYPE IDXARGBReadWritePtr_OverArrayAndMove_Proxy( 
    IDXARGBReadWritePtr * This,
    /* [in] */ DXBASESAMPLE *pScratchBuffer,
    /* [in] */ const DXPMSAMPLE *pSrc,
    /* [in] */ ULONG cSamples);


void __RPC_STUB IDXARGBReadWritePtr_OverArrayAndMove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXARGBReadWritePtr_INTERFACE_DEFINED__ */


#ifndef __IDXDCLock_INTERFACE_DEFINED__
#define __IDXDCLock_INTERFACE_DEFINED__

/* interface IDXDCLock */
/* [object][local][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IDXDCLock;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0F619456-CF39-11d1-905E-00C04FD9189D")
    IDXDCLock : public IUnknown
    {
    public:
        virtual HDC STDMETHODCALLTYPE GetDC( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXDCLockVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXDCLock * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXDCLock * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXDCLock * This);
        
        HDC ( STDMETHODCALLTYPE *GetDC )( 
            IDXDCLock * This);
        
        END_INTERFACE
    } IDXDCLockVtbl;

    interface IDXDCLock
    {
        CONST_VTBL struct IDXDCLockVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXDCLock_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXDCLock_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXDCLock_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXDCLock_GetDC(This)	\
    (This)->lpVtbl -> GetDC(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HDC STDMETHODCALLTYPE IDXDCLock_GetDC_Proxy( 
    IDXDCLock * This);


void __RPC_STUB IDXDCLock_GetDC_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXDCLock_INTERFACE_DEFINED__ */


#ifndef __IDXTScaleOutput_INTERFACE_DEFINED__
#define __IDXTScaleOutput_INTERFACE_DEFINED__

/* interface IDXTScaleOutput */
/* [object][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IDXTScaleOutput;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B2024B50-EE77-11d1-9066-00C04FD9189D")
    IDXTScaleOutput : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetOutputSize( 
            /* [in] */ const SIZE OutSize,
            /* [in] */ BOOL bMaintainAspect) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTScaleOutputVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXTScaleOutput * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXTScaleOutput * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXTScaleOutput * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetOutputSize )( 
            IDXTScaleOutput * This,
            /* [in] */ const SIZE OutSize,
            /* [in] */ BOOL bMaintainAspect);
        
        END_INTERFACE
    } IDXTScaleOutputVtbl;

    interface IDXTScaleOutput
    {
        CONST_VTBL struct IDXTScaleOutputVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTScaleOutput_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTScaleOutput_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTScaleOutput_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTScaleOutput_SetOutputSize(This,OutSize,bMaintainAspect)	\
    (This)->lpVtbl -> SetOutputSize(This,OutSize,bMaintainAspect)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXTScaleOutput_SetOutputSize_Proxy( 
    IDXTScaleOutput * This,
    /* [in] */ const SIZE OutSize,
    /* [in] */ BOOL bMaintainAspect);


void __RPC_STUB IDXTScaleOutput_SetOutputSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTScaleOutput_INTERFACE_DEFINED__ */


#ifndef __IDXGradient_INTERFACE_DEFINED__
#define __IDXGradient_INTERFACE_DEFINED__

/* interface IDXGradient */
/* [object][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IDXGradient;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B2024B51-EE77-11d1-9066-00C04FD9189D")
    IDXGradient : public IDXTScaleOutput
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetGradient( 
            DXSAMPLE StartColor,
            DXSAMPLE EndColor,
            BOOL bHorizontal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOutputSize( 
            /* [out] */ SIZE *pOutSize) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXGradientVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXGradient * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXGradient * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXGradient * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetOutputSize )( 
            IDXGradient * This,
            /* [in] */ const SIZE OutSize,
            /* [in] */ BOOL bMaintainAspect);
        
        HRESULT ( STDMETHODCALLTYPE *SetGradient )( 
            IDXGradient * This,
            DXSAMPLE StartColor,
            DXSAMPLE EndColor,
            BOOL bHorizontal);
        
        HRESULT ( STDMETHODCALLTYPE *GetOutputSize )( 
            IDXGradient * This,
            /* [out] */ SIZE *pOutSize);
        
        END_INTERFACE
    } IDXGradientVtbl;

    interface IDXGradient
    {
        CONST_VTBL struct IDXGradientVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXGradient_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXGradient_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXGradient_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXGradient_SetOutputSize(This,OutSize,bMaintainAspect)	\
    (This)->lpVtbl -> SetOutputSize(This,OutSize,bMaintainAspect)


#define IDXGradient_SetGradient(This,StartColor,EndColor,bHorizontal)	\
    (This)->lpVtbl -> SetGradient(This,StartColor,EndColor,bHorizontal)

#define IDXGradient_GetOutputSize(This,pOutSize)	\
    (This)->lpVtbl -> GetOutputSize(This,pOutSize)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXGradient_SetGradient_Proxy( 
    IDXGradient * This,
    DXSAMPLE StartColor,
    DXSAMPLE EndColor,
    BOOL bHorizontal);


void __RPC_STUB IDXGradient_SetGradient_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXGradient_GetOutputSize_Proxy( 
    IDXGradient * This,
    /* [out] */ SIZE *pOutSize);


void __RPC_STUB IDXGradient_GetOutputSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXGradient_INTERFACE_DEFINED__ */


#ifndef __IDXTScale_INTERFACE_DEFINED__
#define __IDXTScale_INTERFACE_DEFINED__

/* interface IDXTScale */
/* [object][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IDXTScale;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B39FD742-E139-11d1-9065-00C04FD9189D")
    IDXTScale : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetScales( 
            /* [in] */ float Scales[ 2 ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetScales( 
            /* [out] */ float Scales[ 2 ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ScaleFitToSize( 
            /* [out][in] */ DXBNDS *pClipBounds,
            /* [in] */ SIZE FitToSize,
            /* [in] */ BOOL bMaintainAspect) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTScaleVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXTScale * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXTScale * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXTScale * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetScales )( 
            IDXTScale * This,
            /* [in] */ float Scales[ 2 ]);
        
        HRESULT ( STDMETHODCALLTYPE *GetScales )( 
            IDXTScale * This,
            /* [out] */ float Scales[ 2 ]);
        
        HRESULT ( STDMETHODCALLTYPE *ScaleFitToSize )( 
            IDXTScale * This,
            /* [out][in] */ DXBNDS *pClipBounds,
            /* [in] */ SIZE FitToSize,
            /* [in] */ BOOL bMaintainAspect);
        
        END_INTERFACE
    } IDXTScaleVtbl;

    interface IDXTScale
    {
        CONST_VTBL struct IDXTScaleVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTScale_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTScale_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTScale_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTScale_SetScales(This,Scales)	\
    (This)->lpVtbl -> SetScales(This,Scales)

#define IDXTScale_GetScales(This,Scales)	\
    (This)->lpVtbl -> GetScales(This,Scales)

#define IDXTScale_ScaleFitToSize(This,pClipBounds,FitToSize,bMaintainAspect)	\
    (This)->lpVtbl -> ScaleFitToSize(This,pClipBounds,FitToSize,bMaintainAspect)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXTScale_SetScales_Proxy( 
    IDXTScale * This,
    /* [in] */ float Scales[ 2 ]);


void __RPC_STUB IDXTScale_SetScales_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTScale_GetScales_Proxy( 
    IDXTScale * This,
    /* [out] */ float Scales[ 2 ]);


void __RPC_STUB IDXTScale_GetScales_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTScale_ScaleFitToSize_Proxy( 
    IDXTScale * This,
    /* [out][in] */ DXBNDS *pClipBounds,
    /* [in] */ SIZE FitToSize,
    /* [in] */ BOOL bMaintainAspect);


void __RPC_STUB IDXTScale_ScaleFitToSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTScale_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxtrans_0269 */
/* [local] */ 

typedef 
enum DISPIDDXEFFECT
    {	DISPID_DXECAPABILITIES	= 10000,
	DISPID_DXEPROGRESS	= DISPID_DXECAPABILITIES + 1,
	DISPID_DXESTEP	= DISPID_DXEPROGRESS + 1,
	DISPID_DXEDURATION	= DISPID_DXESTEP + 1,
	DISPID_DXE_NEXT_ID	= DISPID_DXEDURATION + 1
    } 	DISPIDDXBOUNDEDEFFECT;

typedef 
enum DXEFFECTTYPE
    {	DXTET_PERIODIC	= 1 << 0,
	DXTET_MORPH	= 1 << 1
    } 	DXEFFECTTYPE;



extern RPC_IF_HANDLE __MIDL_itf_dxtrans_0269_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtrans_0269_v0_0_s_ifspec;

#ifndef __IDXEffect_INTERFACE_DEFINED__
#define __IDXEffect_INTERFACE_DEFINED__

/* interface IDXEffect */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXEffect;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E31FB81B-1335-11d1-8189-0000F87557DB")
    IDXEffect : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Capabilities( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Progress( 
            /* [retval][out] */ float *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Progress( 
            /* [in] */ float newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_StepResolution( 
            /* [retval][out] */ float *pVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Duration( 
            /* [retval][out] */ float *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Duration( 
            /* [in] */ float newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXEffectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXEffect * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXEffect * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXEffect * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDXEffect * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDXEffect * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDXEffect * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDXEffect * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Capabilities )( 
            IDXEffect * This,
            /* [retval][out] */ long *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Progress )( 
            IDXEffect * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Progress )( 
            IDXEffect * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StepResolution )( 
            IDXEffect * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Duration )( 
            IDXEffect * This,
            /* [retval][out] */ float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Duration )( 
            IDXEffect * This,
            /* [in] */ float newVal);
        
        END_INTERFACE
    } IDXEffectVtbl;

    interface IDXEffect
    {
        CONST_VTBL struct IDXEffectVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXEffect_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXEffect_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXEffect_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXEffect_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXEffect_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXEffect_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXEffect_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXEffect_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IDXEffect_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IDXEffect_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IDXEffect_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IDXEffect_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IDXEffect_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXEffect_get_Capabilities_Proxy( 
    IDXEffect * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IDXEffect_get_Capabilities_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXEffect_get_Progress_Proxy( 
    IDXEffect * This,
    /* [retval][out] */ float *pVal);


void __RPC_STUB IDXEffect_get_Progress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXEffect_put_Progress_Proxy( 
    IDXEffect * This,
    /* [in] */ float newVal);


void __RPC_STUB IDXEffect_put_Progress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXEffect_get_StepResolution_Proxy( 
    IDXEffect * This,
    /* [retval][out] */ float *pVal);


void __RPC_STUB IDXEffect_get_StepResolution_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXEffect_get_Duration_Proxy( 
    IDXEffect * This,
    /* [retval][out] */ float *pVal);


void __RPC_STUB IDXEffect_get_Duration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXEffect_put_Duration_Proxy( 
    IDXEffect * This,
    /* [in] */ float newVal);


void __RPC_STUB IDXEffect_put_Duration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXEffect_INTERFACE_DEFINED__ */


#ifndef __IDXLookupTable_INTERFACE_DEFINED__
#define __IDXLookupTable_INTERFACE_DEFINED__

/* interface IDXLookupTable */
/* [object][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IDXLookupTable;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("01BAFC7F-9E63-11d1-9053-00C04FD9189D")
    IDXLookupTable : public IDXBaseObject
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetTables( 
            /* [out] */ BYTE RedLUT[ 256 ],
            /* [out] */ BYTE GreenLUT[ 256 ],
            /* [out] */ BYTE BlueLUT[ 256 ],
            /* [out] */ BYTE AlphaLUT[ 256 ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsChannelIdentity( 
            /* [out] */ DXBASESAMPLE *pSampleBools) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIndexValues( 
            /* [in] */ ULONG Index,
            /* [out] */ DXBASESAMPLE *pSample) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ApplyTables( 
            /* [out][in] */ DXSAMPLE *pSamples,
            /* [in] */ ULONG cSamples) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXLookupTableVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXLookupTable * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXLookupTable * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXLookupTable * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetGenerationId )( 
            IDXLookupTable * This,
            /* [out] */ ULONG *pID);
        
        HRESULT ( STDMETHODCALLTYPE *IncrementGenerationId )( 
            IDXLookupTable * This,
            /* [in] */ BOOL bRefresh);
        
        HRESULT ( STDMETHODCALLTYPE *GetObjectSize )( 
            IDXLookupTable * This,
            /* [out] */ ULONG *pcbSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetTables )( 
            IDXLookupTable * This,
            /* [out] */ BYTE RedLUT[ 256 ],
            /* [out] */ BYTE GreenLUT[ 256 ],
            /* [out] */ BYTE BlueLUT[ 256 ],
            /* [out] */ BYTE AlphaLUT[ 256 ]);
        
        HRESULT ( STDMETHODCALLTYPE *IsChannelIdentity )( 
            IDXLookupTable * This,
            /* [out] */ DXBASESAMPLE *pSampleBools);
        
        HRESULT ( STDMETHODCALLTYPE *GetIndexValues )( 
            IDXLookupTable * This,
            /* [in] */ ULONG Index,
            /* [out] */ DXBASESAMPLE *pSample);
        
        HRESULT ( STDMETHODCALLTYPE *ApplyTables )( 
            IDXLookupTable * This,
            /* [out][in] */ DXSAMPLE *pSamples,
            /* [in] */ ULONG cSamples);
        
        END_INTERFACE
    } IDXLookupTableVtbl;

    interface IDXLookupTable
    {
        CONST_VTBL struct IDXLookupTableVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXLookupTable_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXLookupTable_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXLookupTable_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXLookupTable_GetGenerationId(This,pID)	\
    (This)->lpVtbl -> GetGenerationId(This,pID)

#define IDXLookupTable_IncrementGenerationId(This,bRefresh)	\
    (This)->lpVtbl -> IncrementGenerationId(This,bRefresh)

#define IDXLookupTable_GetObjectSize(This,pcbSize)	\
    (This)->lpVtbl -> GetObjectSize(This,pcbSize)


#define IDXLookupTable_GetTables(This,RedLUT,GreenLUT,BlueLUT,AlphaLUT)	\
    (This)->lpVtbl -> GetTables(This,RedLUT,GreenLUT,BlueLUT,AlphaLUT)

#define IDXLookupTable_IsChannelIdentity(This,pSampleBools)	\
    (This)->lpVtbl -> IsChannelIdentity(This,pSampleBools)

#define IDXLookupTable_GetIndexValues(This,Index,pSample)	\
    (This)->lpVtbl -> GetIndexValues(This,Index,pSample)

#define IDXLookupTable_ApplyTables(This,pSamples,cSamples)	\
    (This)->lpVtbl -> ApplyTables(This,pSamples,cSamples)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXLookupTable_GetTables_Proxy( 
    IDXLookupTable * This,
    /* [out] */ BYTE RedLUT[ 256 ],
    /* [out] */ BYTE GreenLUT[ 256 ],
    /* [out] */ BYTE BlueLUT[ 256 ],
    /* [out] */ BYTE AlphaLUT[ 256 ]);


void __RPC_STUB IDXLookupTable_GetTables_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXLookupTable_IsChannelIdentity_Proxy( 
    IDXLookupTable * This,
    /* [out] */ DXBASESAMPLE *pSampleBools);


void __RPC_STUB IDXLookupTable_IsChannelIdentity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXLookupTable_GetIndexValues_Proxy( 
    IDXLookupTable * This,
    /* [in] */ ULONG Index,
    /* [out] */ DXBASESAMPLE *pSample);


void __RPC_STUB IDXLookupTable_GetIndexValues_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXLookupTable_ApplyTables_Proxy( 
    IDXLookupTable * This,
    /* [out][in] */ DXSAMPLE *pSamples,
    /* [in] */ ULONG cSamples);


void __RPC_STUB IDXLookupTable_ApplyTables_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXLookupTable_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxtrans_0271 */
/* [local] */ 

typedef struct DXRAWSURFACEINFO
    {
    BYTE *pFirstByte;
    long lPitch;
    ULONG Width;
    ULONG Height;
    const GUID *pPixelFormat;
    HDC hdc;
    DWORD dwColorKey;
    DXBASESAMPLE *pPalette;
    } 	DXRAWSURFACEINFO;



extern RPC_IF_HANDLE __MIDL_itf_dxtrans_0271_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtrans_0271_v0_0_s_ifspec;

#ifndef __IDXRawSurface_INTERFACE_DEFINED__
#define __IDXRawSurface_INTERFACE_DEFINED__

/* interface IDXRawSurface */
/* [object][local][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IDXRawSurface;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("09756C8A-D96A-11d1-9062-00C04FD9189D")
    IDXRawSurface : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSurfaceInfo( 
            DXRAWSURFACEINFO *pSurfaceInfo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXRawSurfaceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXRawSurface * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXRawSurface * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXRawSurface * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetSurfaceInfo )( 
            IDXRawSurface * This,
            DXRAWSURFACEINFO *pSurfaceInfo);
        
        END_INTERFACE
    } IDXRawSurfaceVtbl;

    interface IDXRawSurface
    {
        CONST_VTBL struct IDXRawSurfaceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXRawSurface_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXRawSurface_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXRawSurface_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXRawSurface_GetSurfaceInfo(This,pSurfaceInfo)	\
    (This)->lpVtbl -> GetSurfaceInfo(This,pSurfaceInfo)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXRawSurface_GetSurfaceInfo_Proxy( 
    IDXRawSurface * This,
    DXRAWSURFACEINFO *pSurfaceInfo);


void __RPC_STUB IDXRawSurface_GetSurfaceInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXRawSurface_INTERFACE_DEFINED__ */


#ifndef __IHTMLDXTransform_INTERFACE_DEFINED__
#define __IHTMLDXTransform_INTERFACE_DEFINED__

/* interface IHTMLDXTransform */
/* [object][local][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IHTMLDXTransform;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("30E2AB7D-4FDD-4159-B7EA-DC722BF4ADE5")
    IHTMLDXTransform : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetHostUrl( 
            BSTR bstrHostUrl) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHTMLDXTransformVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHTMLDXTransform * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHTMLDXTransform * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHTMLDXTransform * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetHostUrl )( 
            IHTMLDXTransform * This,
            BSTR bstrHostUrl);
        
        END_INTERFACE
    } IHTMLDXTransformVtbl;

    interface IHTMLDXTransform
    {
        CONST_VTBL struct IHTMLDXTransformVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHTMLDXTransform_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHTMLDXTransform_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHTMLDXTransform_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHTMLDXTransform_SetHostUrl(This,bstrHostUrl)	\
    (This)->lpVtbl -> SetHostUrl(This,bstrHostUrl)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IHTMLDXTransform_SetHostUrl_Proxy( 
    IHTMLDXTransform * This,
    BSTR bstrHostUrl);


void __RPC_STUB IHTMLDXTransform_SetHostUrl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHTMLDXTransform_INTERFACE_DEFINED__ */



#ifndef __DXTRANSLib_LIBRARY_DEFINED__
#define __DXTRANSLib_LIBRARY_DEFINED__

/* library DXTRANSLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_DXTRANSLib;

EXTERN_C const CLSID CLSID_DXTransformFactory;

#ifdef __cplusplus

class DECLSPEC_UUID("D1FE6762-FC48-11D0-883A-3C8B00C10000")
DXTransformFactory;
#endif

EXTERN_C const CLSID CLSID_DXTaskManager;

#ifdef __cplusplus

class DECLSPEC_UUID("4CB26C03-FF93-11d0-817E-0000F87557DB")
DXTaskManager;
#endif

EXTERN_C const CLSID CLSID_DXTScale;

#ifdef __cplusplus

class DECLSPEC_UUID("555278E2-05DB-11D1-883A-3C8B00C10000")
DXTScale;
#endif

EXTERN_C const CLSID CLSID_DXSurface;

#ifdef __cplusplus

class DECLSPEC_UUID("0E890F83-5F79-11D1-9043-00C04FD9189D")
DXSurface;
#endif

EXTERN_C const CLSID CLSID_DXSurfaceModifier;

#ifdef __cplusplus

class DECLSPEC_UUID("3E669F1D-9C23-11d1-9053-00C04FD9189D")
DXSurfaceModifier;
#endif

EXTERN_C const CLSID CLSID_DXGradient;

#ifdef __cplusplus

class DECLSPEC_UUID("C6365470-F667-11d1-9067-00C04FD9189D")
DXGradient;
#endif
#endif /* __DXTRANSLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\Dxtmsft3Guid.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0334 */
/* Compiler settings for dxtmsft3.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IExplode,0x141DBAF0,0x55FB,0x11D1,0xB8,0x3E,0x00,0xA0,0xC9,0x33,0xBE,0x86);


MIDL_DEFINE_GUID(IID, IID_ICrShatter,0x63500AE1,0x0858,0x11D2,0x8C,0xE4,0x00,0xC0,0x4F,0x8E,0xCB,0x10);


MIDL_DEFINE_GUID(IID, IID_IDXTBlackHole,0xC3853C21,0x3F2E,0x11D2,0x99,0x00,0x00,0x00,0xF8,0x03,0xFF,0x7A);


MIDL_DEFINE_GUID(IID, IID_IDXTRoll,0x78F30B81,0x48AA,0x11D2,0x99,0x00,0x00,0x00,0xF8,0x03,0xFF,0x7A);


MIDL_DEFINE_GUID(IID, IID_IDXTSpin,0x3D2807C1,0x43DE,0x11D2,0x99,0x00,0x00,0x00,0xF8,0x03,0xFF,0x7A);


MIDL_DEFINE_GUID(IID, IID_IRipple,0x6DA4A05E,0x8E9E,0x11D1,0x90,0x4E,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IHeightField,0x0492170A,0xB159,0x11d1,0x92,0x07,0x00,0x00,0xF8,0x75,0x8E,0x66);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaStream,0x48654BC0,0xE51F,0x11D1,0xAA,0x1C,0x00,0x60,0x08,0x95,0xFB,0x99);


MIDL_DEFINE_GUID(IID, IID_IDXTText3D,0x50C4B592,0x7E8D,0x11d2,0x9B,0x4E,0x00,0xA0,0xC9,0x69,0x7C,0xD0);


MIDL_DEFINE_GUID(IID, IID_IDXTShapes,0x8241F013,0x84D3,0x11d2,0x97,0xE6,0x00,0x00,0xF8,0x03,0xFF,0x7A);


MIDL_DEFINE_GUID(IID, LIBID_DXTMSFT3Lib,0xE4BBA4C0,0x69B7,0x11d2,0x83,0x2D,0x00,0x00,0xF8,0x1F,0x59,0x95);


MIDL_DEFINE_GUID(CLSID, CLSID_Explode,0x141DBAF1,0x55FB,0x11D1,0xB8,0x3E,0x00,0xA0,0xC9,0x33,0xBE,0x86);


MIDL_DEFINE_GUID(CLSID, CLSID_ExplodeProp,0xC53059E1,0xE6E3,0x11d1,0xBA,0x12,0x00,0xC0,0x4F,0xB6,0xBD,0x36);


MIDL_DEFINE_GUID(CLSID, CLSID_Ripple,0x945F5842,0x3A8D,0x11D1,0x90,0x37,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(CLSID, CLSID_RipProp,0x945F5843,0x3A8D,0x11D1,0x90,0x37,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(CLSID, CLSID_HeightField,0x04921709,0xB159,0x11d1,0x92,0x07,0x00,0x00,0xF8,0x75,0x8E,0x66);


MIDL_DEFINE_GUID(CLSID, CLSID_HtFieldProp,0x7A8402E3,0xFBD6,0x11D1,0xB5,0xE0,0x00,0xAA,0x00,0x3B,0x60,0x61);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaStream,0x60A0C080,0xE505,0x11D1,0xAA,0x1C,0x00,0x60,0x08,0x95,0xFB,0x99);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaStreamProp,0xE3D77340,0xE505,0x11D1,0xAA,0x1C,0x00,0x60,0x08,0x95,0xFB,0x99);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTText3D,0xD56F34F2,0x7E89,0x11d2,0x9B,0x4E,0x00,0xA0,0xC9,0x69,0x7C,0xD0);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTText3DPP,0x50C4B593,0x7E8D,0x11d2,0x9B,0x4E,0x00,0xA0,0xC9,0x69,0x7C,0xD0);


MIDL_DEFINE_GUID(CLSID, CLSID_CrShatter,0x63500AE2,0x0858,0x11D2,0x8C,0xE4,0x00,0xC0,0x4F,0x8E,0xCB,0x10);


MIDL_DEFINE_GUID(CLSID, CLSID_CrShatterPP,0x99275F01,0x102E,0x11d2,0x8B,0x82,0x00,0xA0,0xC9,0x3C,0x09,0xB2);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTBlackHole,0xC3853C22,0x3F2E,0x11D2,0x99,0x00,0x00,0x00,0xF8,0x03,0xFF,0x7A);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTBlackHolePP,0xC3853C23,0x3F2E,0x11D2,0x99,0x00,0x00,0x00,0xF8,0x03,0xFF,0x7A);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTRoll,0x78F30B82,0x48AA,0x11D2,0x99,0x00,0x00,0x00,0xF8,0x03,0xFF,0x7A);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTRollPP,0x78F30B83,0x48AA,0x11D2,0x99,0x00,0x00,0x00,0xF8,0x03,0xFF,0x7A);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTSpin,0x3D2807C2,0x43DE,0x11D2,0x99,0x00,0x00,0x00,0xF8,0x03,0xFF,0x7A);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTSpinPP,0x3D2807C3,0x43DE,0x11D2,0x99,0x00,0x00,0x00,0xF8,0x03,0xFF,0x7A);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTShapes,0x8241F015,0x84D3,0x11d2,0x97,0xE6,0x00,0x00,0xF8,0x03,0xFF,0x7A);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTShapesPP,0x8241F016,0x84D3,0x11d2,0x97,0xE6,0x00,0x00,0xF8,0x03,0xFF,0x7A);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AXP64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0334 */
/* Compiler settings for dxtmsft3.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IExplode,0x141DBAF0,0x55FB,0x11D1,0xB8,0x3E,0x00,0xA0,0xC9,0x33,0xBE,0x86);


MIDL_DEFINE_GUID(IID, IID_ICrShatter,0x63500AE1,0x0858,0x11D2,0x8C,0xE4,0x00,0xC0,0x4F,0x8E,0xCB,0x10);


MIDL_DEFINE_GUID(IID, IID_IDXTBlackHole,0xC3853C21,0x3F2E,0x11D2,0x99,0x00,0x00,0x00,0xF8,0x03,0xFF,0x7A);


MIDL_DEFINE_GUID(IID, IID_IDXTRoll,0x78F30B81,0x48AA,0x11D2,0x99,0x00,0x00,0x00,0xF8,0x03,0xFF,0x7A);


MIDL_DEFINE_GUID(IID, IID_IDXTSpin,0x3D2807C1,0x43DE,0x11D2,0x99,0x00,0x00,0x00,0xF8,0x03,0xFF,0x7A);


MIDL_DEFINE_GUID(IID, IID_IRipple,0x6DA4A05E,0x8E9E,0x11D1,0x90,0x4E,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IHeightField,0x0492170A,0xB159,0x11d1,0x92,0x07,0x00,0x00,0xF8,0x75,0x8E,0x66);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaStream,0x48654BC0,0xE51F,0x11D1,0xAA,0x1C,0x00,0x60,0x08,0x95,0xFB,0x99);


MIDL_DEFINE_GUID(IID, IID_IDXTText3D,0x50C4B592,0x7E8D,0x11d2,0x9B,0x4E,0x00,0xA0,0xC9,0x69,0x7C,0xD0);


MIDL_DEFINE_GUID(IID, IID_IDXTShapes,0x8241F013,0x84D3,0x11d2,0x97,0xE6,0x00,0x00,0xF8,0x03,0xFF,0x7A);


MIDL_DEFINE_GUID(IID, LIBID_DXTMSFT3Lib,0xE4BBA4C0,0x69B7,0x11d2,0x83,0x2D,0x00,0x00,0xF8,0x1F,0x59,0x95);


MIDL_DEFINE_GUID(CLSID, CLSID_Explode,0x141DBAF1,0x55FB,0x11D1,0xB8,0x3E,0x00,0xA0,0xC9,0x33,0xBE,0x86);


MIDL_DEFINE_GUID(CLSID, CLSID_ExplodeProp,0xC53059E1,0xE6E3,0x11d1,0xBA,0x12,0x00,0xC0,0x4F,0xB6,0xBD,0x36);


MIDL_DEFINE_GUID(CLSID, CLSID_Ripple,0x945F5842,0x3A8D,0x11D1,0x90,0x37,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(CLSID, CLSID_RipProp,0x945F5843,0x3A8D,0x11D1,0x90,0x37,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(CLSID, CLSID_HeightField,0x04921709,0xB159,0x11d1,0x92,0x07,0x00,0x00,0xF8,0x75,0x8E,0x66);


MIDL_DEFINE_GUID(CLSID, CLSID_HtFieldProp,0x7A8402E3,0xFBD6,0x11D1,0xB5,0xE0,0x00,0xAA,0x00,0x3B,0x60,0x61);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaStream,0x60A0C080,0xE505,0x11D1,0xAA,0x1C,0x00,0x60,0x08,0x95,0xFB,0x99);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaStreamProp,0xE3D77340,0xE505,0x11D1,0xAA,0x1C,0x00,0x60,0x08,0x95,0xFB,0x99);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTText3D,0xD56F34F2,0x7E89,0x11d2,0x9B,0x4E,0x00,0xA0,0xC9,0x69,0x7C,0xD0);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTText3DPP,0x50C4B593,0x7E8D,0x11d2,0x9B,0x4E,0x00,0xA0,0xC9,0x69,0x7C,0xD0);


MIDL_DEFINE_GUID(CLSID, CLSID_CrShatter,0x63500AE2,0x0858,0x11D2,0x8C,0xE4,0x00,0xC0,0x4F,0x8E,0xCB,0x10);


MIDL_DEFINE_GUID(CLSID, CLSID_CrShatterPP,0x99275F01,0x102E,0x11d2,0x8B,0x82,0x00,0xA0,0xC9,0x3C,0x09,0xB2);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTBlackHole,0xC3853C22,0x3F2E,0x11D2,0x99,0x00,0x00,0x00,0xF8,0x03,0xFF,0x7A);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTBlackHolePP,0xC3853C23,0x3F2E,0x11D2,0x99,0x00,0x00,0x00,0xF8,0x03,0xFF,0x7A);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTRoll,0x78F30B82,0x48AA,0x11D2,0x99,0x00,0x00,0x00,0xF8,0x03,0xFF,0x7A);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTRollPP,0x78F30B83,0x48AA,0x11D2,0x99,0x00,0x00,0x00,0xF8,0x03,0xFF,0x7A);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTSpin,0x3D2807C2,0x43DE,0x11D2,0x99,0x00,0x00,0x00,0xF8,0x03,0xFF,0x7A);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTSpinPP,0x3D2807C3,0x43DE,0x11D2,0x99,0x00,0x00,0x00,0xF8,0x03,0xFF,0x7A);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTShapes,0x8241F015,0x84D3,0x11d2,0x97,0xE6,0x00,0x00,0xF8,0x03,0xFF,0x7A);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTShapesPP,0x8241F016,0x84D3,0x11d2,0x97,0xE6,0x00,0x00,0xF8,0x03,0xFF,0x7A);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AXP64)*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\dxva.h ===
//------------------------------------------------------------------------------
// File: DXVA.h
//
// Desc: DirectX Video Acceleration header file.
//
// Copyright (c) 1999 - 2000, Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------------------------


#ifndef __DIRECTX_VA__
#define __DIRECTX_VA__

#ifdef __cplusplus
extern "C" {
#endif

DEFINE_GUID(DXVA_ModeNone,    0x1b81be00, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA_ModeH261_A,  0x1b81be01, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA_ModeH261_B,  0x1b81be02, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA_ModeH263_A,  0x1b81be03, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA_ModeH263_B,  0x1b81be04, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA_ModeH263_C,  0x1b81be05, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA_ModeH263_D,  0x1b81be06, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA_ModeH263_E,  0x1b81be07, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA_ModeH263_F,  0x1b81be08, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA_ModeMPEG1_A, 0x1b81be09, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA_ModeMPEG2_A, 0x1b81be0A, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA_ModeMPEG2_B, 0x1b81be0B, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA_ModeMPEG2_C, 0x1b81be0C, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA_ModeMPEG2_D, 0x1b81be0D, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);

DEFINE_GUID(DXVA_NoEncrypt,   0x1b81beD0, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA_EncryptProt1, 0x1b81beD1, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);

#define DXVA_RESTRICTED_MODE_UNRESTRICTED        0xFFFF
#define DXVA_RESTRICTED_MODE_H261_A              1
#define DXVA_RESTRICTED_MODE_H261_B              2
#define DXVA_RESTRICTED_MODE_H263_A              3
#define DXVA_RESTRICTED_MODE_H263_B              4
#define DXVA_RESTRICTED_MODE_H263_C              5
#define DXVA_RESTRICTED_MODE_H263_D              6
#define DXVA_RESTRICTED_MODE_H263_E              7
#define DXVA_RESTRICTED_MODE_H263_F              8
#define DXVA_RESTRICTED_MODE_MPEG1_A             9
#define DXVA_RESTRICTED_MODE_MPEG2_A             0xA
#define DXVA_RESTRICTED_MODE_MPEG2_B             0xB
#define DXVA_RESTRICTED_MODE_MPEG2_C             0xC
#define DXVA_RESTRICTED_MODE_MPEG2_D             0xD

#define DXVA_COMPBUFFER_TYPE_THAT_IS_NOT_USED    0
#define DXVA_PICTURE_DECODE_BUFFER               1
#define DXVA_MACROBLOCK_CONTROL_BUFFER           2
#define DXVA_RESIDUAL_DIFFERENCE_BUFFER          3
#define DXVA_DEBLOCKING_CONTROL_BUFFER           4
#define DXVA_INVERSE_QUANTIZATION_MATRIX_BUFFER  5
#define DXVA_SLICE_CONTROL_BUFFER                6
#define DXVA_BITSTREAM_DATA_BUFFER               7
#define DXVA_AYUV_BUFFER                         8
#define DXVA_IA44_SURFACE_BUFFER                 9
#define DXVA_DPXD_SURFACE_BUFFER                10
#define DXVA_HIGHLIGHT_BUFFER                   11
#define DXVA_DCCMD_SURFACE_BUFFER               12
#define DXVA_ALPHA_BLEND_COMBINATION_BUFFER     13
#define DXVA_PICTURE_RESAMPLE_BUFFER            14
#define DXVA_READ_BACK_BUFFER                   15

#define DXVA_NUM_TYPES_COMP_BUFFERS             16

/* values for bDXVA_Func */
#define DXVA_PICTURE_DECODING_FUNCTION        1
#define DXVA_ALPHA_BLEND_DATA_LOAD_FUNCTION   2
#define DXVA_ALPHA_BLEND_COMBINATION_FUNCTION 3
#define DXVA_PICTURE_RESAMPLE_FUNCTION        4

/* values returned from Execute command in absence of read-back */
#define DXVA_EXECUTE_RETURN_OK                  0
#define DXVA_EXECUTE_RETURN_DATA_ERROR_MINOR    1
#define DXVA_EXECUTE_RETURN_DATA_ERROR_SIGNIF   2
#define DXVA_EXECUTE_RETURN_DATA_ERROR_SEVERE   3
#define DXVA_EXECUTE_RETURN_OTHER_ERROR_SEVERE  4


#pragma pack(push, BeforeDXVApacking, 1)


typedef struct _DXVA_ConnectMode {
  GUID guidMode;
  WORD wRestrictedMode;
} DXVA_ConnectMode, *LPDXVA_ConnectMode;


typedef DWORD DXVA_ConfigQueryOrReplyFunc, *LPDXVA_ConfigQueryOrReplyFunc;

#define DXVA_QUERYORREPLYFUNCFLAG_DECODER_PROBE_QUERY     0xFFFFF1
#define DXVA_QUERYORREPLYFUNCFLAG_DECODER_LOCK_QUERY      0xFFFFF5
#define DXVA_QUERYORREPLYFUNCFLAG_ACCEL_PROBE_OK_COPY     0xFFFFF8
#define DXVA_QUERYORREPLYFUNCFLAG_ACCEL_PROBE_OK_PLUS     0xFFFFF9
#define DXVA_QUERYORREPLYFUNCFLAG_ACCEL_LOCK_OK_COPY      0xFFFFFC
#define DXVA_QUERYORREPLYFUNCFLAG_ACCEL_PROBE_FALSE_PLUS  0xFFFFFB
#define DXVA_QUERYORREPLYFUNCFLAG_ACCEL_LOCK_FALSE_PLUS   0xFFFFFF

#define readDXVA_QueryOrReplyFuncFlag(ptr)        ((*(ptr)) >> 8)

#define readDXVA_QueryOrReplyFuncFlag_ACCEL(ptr)  (((*(ptr)) >> 11) & 1)
#define readDXVA_QueryOrReplyFuncFlag_LOCK(ptr)   (((*(ptr)) >> 10) & 1)
#define readDXVA_QueryOrReplyFuncFlag_BAD(ptr)    (((*(ptr)) >>  9) & 1)
#define readDXVA_QueryOrReplyFuncFlag_PLUS(ptr)   (((*(ptr)) >>  8) & 1)

#define readDXVA_QueryOrReplyFuncFunc(ptr)        ((*(ptr)) & 0xFF)

#define writeDXVA_QueryOrReplyFunc(ptr, flg, fnc) ((*(ptr)) = ((flg) << 8) | (fnc))

#define setDXVA_QueryOrReplyFuncFlag(ptr, flg) ((*(ptr)) |= ((flg) << 8))
#define setDXVA_QueryOrReplyFuncFunc(ptr, fnc) ((*(ptr)) |= (fnc));

typedef DWORD DXVA_EncryptProtocolFunc, *LPDXVA_EncryptProtocolFunc;

#define DXVA_ENCRYPTPROTOCOLFUNCFLAG_HOST    0xFFFF00
#define DXVA_ENCRYPTPROTOCOLFUNCFLAG_ACCEL   0xFFFF08

#define readDXVA_EncryptProtocolFuncFlag(ptr)        ((*(ptr)) >> 8)
#define readDXVA_EncryptProtocolFuncFlag_ACCEL(ptr)  (((*(ptr)) >> 11) & 1)

#define readDXVA_EncryptProtocolFuncFunc(ptr)        ((*(ptr)) & 0xFF)

#define writeDXVA_EncryptProtocolFunc(ptr, flg, fnc) ((*(ptr)) = ((flg) << 8) | (fnc))

#define setDXVA_EncryptProtocolFuncFlag(ptr, flg) ((*(ptr)) |= ((flg) << 8))
#define setDXVA_EncryptProtocolFuncFunc(ptr, fnc) ((*(ptr)) |= (fnc));

typedef struct _DXVA_EncryptProtocolHeader {
  DXVA_EncryptProtocolFunc dwFunction;
  DWORD ReservedBits[3];
  GUID  guidEncryptProtocol;
} DXVA_EncryptProtocolHeader, *LPDXVA_EncryptProtocolHeader;

typedef struct _DXVA_ConfigPictureDecode {

  // Operation Indicated
  DXVA_ConfigQueryOrReplyFunc dwFunction;

  // Alignment
  DWORD dwReservedBits[3];

  // Encryption GUIDs
  GUID guidConfigBitstreamEncryption;
  GUID guidConfigMBcontrolEncryption;
  GUID guidConfigResidDiffEncryption;

  // Bitstream Processing Indicator
  BYTE bConfigBitstreamRaw;

  // Macroblock Control Config
  BYTE bConfigMBcontrolRasterOrder;

  // Host Resid Diff Config
  BYTE bConfigResidDiffHost;
  BYTE bConfigSpatialResid8;
  BYTE bConfigResid8Subtraction;
  BYTE bConfigSpatialHost8or9Clipping;
  BYTE bConfigSpatialResidInterleaved;
  BYTE bConfigIntraResidUnsigned;

  // Accelerator Resid Diff Config
  BYTE bConfigResidDiffAccelerator;
  BYTE bConfigHostInverseScan;
  BYTE bConfigSpecificIDCT;
  BYTE bConfig4GroupedCoefs;
} DXVA_ConfigPictureDecode, *LPDXVA_ConfigPictureDecode;


/* Picture Decoding Parameters */

typedef struct _DXVA_PictureParameters {

  WORD wDecodedPictureIndex;
  WORD wDeblockedPictureIndex;

  WORD wForwardRefPictureIndex;
  WORD wBackwardRefPictureIndex;

  WORD wPicWidthInMBminus1;
  WORD wPicHeightInMBminus1;

  BYTE bMacroblockWidthMinus1;
  BYTE bMacroblockHeightMinus1;

  BYTE bBlockWidthMinus1;
  BYTE bBlockHeightMinus1;

  BYTE bBPPminus1;

  BYTE bPicStructure;
  BYTE bSecondField;
  BYTE bPicIntra;
  BYTE bPicBackwardPrediction;

  BYTE bBidirectionalAveragingMode;
  BYTE bMVprecisionAndChromaRelation;
  BYTE bChromaFormat;

  BYTE bPicScanFixed;
  BYTE bPicScanMethod;
  BYTE bPicReadbackRequests;

  BYTE bRcontrol;
  BYTE bPicSpatialResid8;
  BYTE bPicOverflowBlocks;
  BYTE bPicExtrapolation;

  BYTE bPicDeblocked;
  BYTE bPicDeblockConfined;
  BYTE bPic4MVallowed;
  BYTE bPicOBMC;
  BYTE bPicBinPB;
  BYTE bMV_RPS;

  BYTE bReservedBits;

  WORD wBitstreamFcodes;
  WORD wBitstreamPCEelements;
  BYTE bBitstreamConcealmentNeed;
  BYTE bBitstreamConcealmentMethod;

} DXVA_PictureParameters, *LPDXVA_PictureParameters;


/* Picture Resampling */

typedef struct _DXVA_PicResample {

  WORD  wPicResampleSourcePicIndex;
  WORD  wPicResampleDestPicIndex;

  WORD  wPicResampleRcontrol;
  BYTE  bPicResampleExtrapWidth;
  BYTE  bPicResampleExtrapHeight;

  DWORD dwPicResampleSourceWidth;
  DWORD dwPicResampleSourceHeight;

  DWORD dwPicResampleDestWidth;
  DWORD dwPicResampleDestHeight;

  DWORD dwPicResampleFullDestWidth;
  DWORD dwPicResampleFullDestHeight;

} DXVA_PicResample, *LPDXVA_PicResample;


#define DXVA_CHROMA_FORMAT_420 1
#define DXVA_CHROMA_FORMAT_422 2
#define DXVA_CHROMA_FORMAT_444 3

#define DXVA_PICTURE_STRUCTURE_TOP_FIELD    1
#define DXVA_PICTURE_STRUCTURE_BOTTOM_FIELD 2
#define DXVA_PICTURE_STRUCTURE_FRAME        3

#define DXVA_BIDIRECTIONAL_AVERAGING_MPEG2_ROUND 0
#define DXVA_BIDIRECTIONAL_AVERAGING_H263_TRUNC  1

#define DXVA_MV_PRECISION_AND_CHROMA_RELATION_MPEG2  0
#define DXVA_MV_PRECISION_AND_CHROMA_RELATION_H263   1
#define DXVA_MV_PRECISION_AND_CHROMA_RELATION_H261   2

#define DXVA_SCAN_METHOD_ZIG_ZAG              0
#define DXVA_SCAN_METHOD_ALTERNATE_VERTICAL   1
#define DXVA_SCAN_METHOD_ALTERNATE_HORIZONTAL 2
#define DXVA_SCAN_METHOD_ARBITRARY            3

#define DXVA_BITSTREAM_CONCEALMENT_NEED_UNLIKELY 0
#define DXVA_BITSTREAM_CONCEALMENT_NEED_MILD     1
#define DXVA_BITSTREAM_CONCEALMENT_NEED_LIKELY   2
#define DXVA_BITSTREAM_CONCEALMENT_NEED_SEVERE   3

#define DXVA_BITSTREAM_CONCEALMENT_METHOD_UNSPECIFIED 0
#define DXVA_BITSTREAM_CONCEALMENT_METHOD_INTRA       1
#define DXVA_BITSTREAM_CONCEALMENT_METHOD_FORWARD     2
#define DXVA_BITSTREAM_CONCEALMENT_METHOD_BACKWARD    3


/* Buffer Description Data */

typedef struct _DXVA_BufferDescription {
  DWORD dwTypeIndex;
  DWORD dwBufferIndex;
  DWORD dwDataOffset;
  DWORD dwDataSize;
  DWORD dwFirstMBaddress;
  DWORD dwNumMBsInBuffer;
  DWORD dwWidth;
  DWORD dwHeight;
  DWORD dwStride;
  DWORD dwReservedBits;
} DXVA_BufferDescription, *LPDXVA_BufferDescription;


/* Off-Host IDCT Coefficient Data Structures */

typedef struct _DXVA_TCoef4Group {
  BYTE  TCoefIDX[4];
  SHORT TCoefValue[4];
} DXVA_TCoef4Group, *LPDXVA_TCoef4Group;

typedef struct _DXVA_TCoefSingle {
  WORD  wIndexWithEOB;
  SHORT TCoefValue;
} DXVA_TCoefSingle, *LPDXVA_TCoefSingle;

/* Macros for Reading EOB and Index Values */

#define readDXVA_TCoefSingleIDX(ptr) ((ptr)->wIndexWithEOB >> 1)
#define readDXVA_TCoefSingleEOB(ptr) ((ptr)->wIndexWithEOB & 1)

/* Macro for Writing EOB and Index Values */

#define writeDXVA_TCoefSingleIndexWithEOB(ptr, idx, eob) ((ptr)->wIndexWithEOB = ((idx) << 1) | (eob))
#define setDXVA_TCoefSingleIDX(ptr, idx) ((ptr)->wIndexWithEOB |= ((idx) << 1))
#define setDXVA_TCoefSingleEOB(ptr)      ((ptr)->wIndexWithEOB |= 1)

/* Spatial-Domain Residual Difference Blocks */

#define DXVA_USUAL_BLOCK_WIDTH   8
#define DXVA_USUAL_BLOCK_HEIGHT  8
#define DXVA_USUAL_BLOCK_SIZE   (DXVA_USUAL_BLOCK_WIDTH * DXVA_USUAL_BLOCK_HEIGHT)

typedef SHORT       DXVA_Sample16[DXVA_USUAL_BLOCK_SIZE];
typedef signed char DXVA_Sample8 [DXVA_USUAL_BLOCK_SIZE];

/* Deblocking Filter Control Structure */

typedef BYTE DXVA_DeblockingEdgeControl;

typedef DXVA_DeblockingEdgeControl * LPDXVA_DeblockingEdgeControl;

/* Macros for Reading STRENGTH and FilterOn */

#define readDXVA_EdgeFilterStrength(ptr) ((*(ptr)) >> 1)
#define readDXVA_EdgeFilterOn(ptr)       ((*(ptr)) & 1)

/* Macro for Writing STRENGTH and FilterOn */

#define writeDXVA_DeblockingEdgeControl(ptr, str, fon) ((*(ptr)) = ((str) << 1) | (fon))
#define setDXVA_EdgeFilterStrength(ptr, str)           ((*(ptr)) |= ((str) << 1))
#define setDXVA_EdgeFilterOn(ptr)                      ((*(ptr)) |= 1)


/* Macroblock Control Command Data Structures */

typedef struct _DXVA_MVvalue {
  SHORT horz, vert;
} DXVA_MVvalue, *LPDXVA_MVvalue;


/* Inverse Quantization Matrices */

typedef struct _DXVA_QmatrixData {
  BYTE bNewQmatrix[4]; /* intra Y, inter Y, intra chroma, inter chroma */
  WORD Qmatrix[4][DXVA_USUAL_BLOCK_WIDTH * DXVA_USUAL_BLOCK_HEIGHT];
} DXVA_QmatrixData, *LPDXVA_QmatrixData;


/* Slice Control Buffer Data */

typedef struct _DXVA_SliceInfo {
  WORD  wHorizontalPosition;
  WORD  wVerticalPosition;
  DWORD dwSliceBitsInBuffer;
  DWORD dwSliceDataLocation;
  BYTE  bStartCodeBitOffset;
  BYTE  bReservedBits;
  WORD  wMBbitOffset;
  WORD  wNumberMBsInSlice;
  WORD  wQuantizerScaleCode;
  WORD  wBadSliceChopping;
} DXVA_SliceInfo, *LPDXVA_SliceInfo;


#define DXVA_NumMV_OBMC_off_BinPBwith4MV_off    4
#define DXVA_NumMV_OBMC_off_BinPBwith4MV_on  (4+1)
#define DXVA_NumMV_OBMC_on__BinPB_off         (10)
#define DXVA_NumMV_OBMC_on__BinPB_on          (11) /* not current standards */

#define DXVA_NumBlocksPerMB_420 (4+2+0)
#define DXVA_NumBlocksPerMB_422 (4+2+2)
#define DXVA_NumBlocksPerMB_444 (4+4+4)

/* Basic form for I pictures */
/* Host Residual Differences */
typedef struct _DXVA_MBctrl_I_HostResidDiff_1 {
  WORD  wMBaddress;
  WORD  wMBtype;
  DWORD dwMB_SNL;
  WORD  wPatternCode;
  WORD  wPC_Overflow; /* zero if not overflow format */
  DWORD dwReservedBits2;
} DXVA_MBctrl_I_HostResidDiff_1;

/* Basic form for I pictures */
/* Off-Host IDCT, 4:2:0 sampling */
typedef struct _DXVA_MBctrl_I_OffHostIDCT_1 {
  WORD  wMBaddress;
  WORD  wMBtype;
  DWORD dwMB_SNL;
  WORD  wPatternCode;
  BYTE  bNumCoef[DXVA_NumBlocksPerMB_420];
} DXVA_MBctrl_I_OffHostIDCT_1;

/* Basic form for P and B pictures */
/* Should also be used for concealment MVs in MPEG-2 I pictures */
/* Without OBMC, without BinPB and 4MV together, without MV RPS */
/* Host Residual Differences */
typedef struct _DXVA_MBctrl_P_HostResidDiff_1 {
  WORD         wMBaddress;
  WORD         wMBtype;
  DWORD        dwMB_SNL;
  WORD         wPatternCode;
  WORD         wPC_Overflow; /* zero if not overflow format */
  DWORD        dwReservedBits2;
  DXVA_MVvalue MVector[DXVA_NumMV_OBMC_off_BinPBwith4MV_off];
} DXVA_MBctrl_P_HostResidDiff_1;

/* Basic form for P and B pictures */
/* Without OBMC, without BinPB and 4MV together, without MV RPS */
/* Off-Host IDCT, 4:2:0 sampling */
typedef struct _DXVA_MBctrl_P_OffHostIDCT_1 {
  WORD         wMBaddress;
  WORD         wMBtype;
  DWORD        dwMB_SNL;
  WORD         wPatternCode;
  BYTE         bNumCoef[DXVA_NumBlocksPerMB_420];
  DXVA_MVvalue MVector[DXVA_NumMV_OBMC_off_BinPBwith4MV_off];
} DXVA_MBctrl_P_OffHostIDCT_1;

/* How to load alpha blending graphic data */
typedef struct _DXVA_ConfigAlphaLoad {

  // Operation Indicated
  DXVA_ConfigQueryOrReplyFunc dwFunction;

  // Alignment
  DWORD dwReservedBits[3];

  BYTE  bConfigDataType;
} DXVA_ConfigAlphaLoad, *LPDXVA_ConfigAlphaLoad;

#define DXVA_CONFIG_DATA_TYPE_IA44  0
#define DXVA_CONFIG_DATA_TYPE_AI44  1
#define DXVA_CONFIG_DATA_TYPE_DPXD  2
#define DXVA_CONFIG_DATA_TYPE_AYUV  3


/* How to combine alpha blending graphic data */
typedef struct _DXVA_ConfigAlphaCombine {

  // Operation Indicated
  DXVA_ConfigQueryOrReplyFunc dwFunction;

  // Alignment
  DWORD dwReservedBits[3];

  BYTE  bConfigBlendType;
  BYTE  bConfigPictureResizing;
  BYTE  bConfigOnlyUsePicDestRectArea;
  BYTE  bConfigGraphicResizing;
  BYTE  bConfigWholePlaneAlpha;

} DXVA_ConfigAlphaCombine, *LPDXVA_ConfigAlphaCombine;

#define DXVA_CONFIG_BLEND_TYPE_FRONT_BUFFER   0
#define DXVA_CONFIG_BLEND_TYPE_BACK_HARDWARE  1


/* AYUV sample for 16-entry YUV palette or graphic surface */

typedef struct _DXVA_AYUVsample {
  BYTE bSampleAlpha8, bY_Value, bCbValue, bCrValue;
} DXVA_AYUVsample, *LPDXVA_AYUVsample;

/* Macros for IA44 alpha blending surface samples */

typedef BYTE DXVA_IA44sample, *LPDXVA_IA44sample;

#define readDXVA_IA44index(ptr) (((*(ptr)) & 0xF0) >> 4)
#define readDXVA_IA44alpha(ptr)  ((*(ptr)) & 0x0F)

#define writeDXVA_IA44(ptr, idx, alpha) ((*(ptr)) = (((idx) << 4) | (alpha)))

#define setDXVA_IA44index(ptr, idx)    ((*(ptr)) |= ((idx) << 4))
#define setDXVA_IA44alpha(ptr, alpha)  ((*(ptr)) |= (alpha))

/* Macros for AI44 alpha blending surface samples */

typedef BYTE DXVA_AI44sample, *LPDXVA_AI44sample;

#define readDXVA_AI44index(ptr)  ((*(ptr)) & 0x0F)
#define readDXVA_AI44alpha(ptr) (((*(ptr)) & 0xF0) >> 4)

#define writeDXVA_AI44(ptr, idx, alpha) ((*(ptr)) = (((alpha) << 4) | (idx)))

#define setDXVA_AI44index(ptr, idx)    ((*(ptr)) |= (idx))
#define setDXVA_AI44alpha(ptr, alpha)  ((*(ptr)) |= ((alpha) << 4))


/* Highlight data structure */

typedef struct _DXVA_Highlight {
  WORD wHighlightActive;
  WORD wHighlightIndices;
  WORD wHighlightAlphas;
  RECT HighlightRect;
} DXVA_Highlight, *LPDXVA_Highlight;

typedef BYTE DXVA_DPXD,  *LPDXVA_DPXD;
typedef WORD DXVA_DCCMD, *LPDXVA_DCCMD;

/* Alpha blend combination */

typedef struct _DXVA_BlendCombination {
  WORD wPictureSourceIndex;
  WORD wBlendedDestinationIndex;
  RECT PictureSourceRect16thPel;
  RECT PictureDestinationRect;
  RECT GraphicSourceRect;
  RECT GraphicDestinationRect;
  WORD wBlendDelay;
  BYTE bBlendOn;
  BYTE bWholePlaneAlpha;
  DXVA_AYUVsample OutsideYUVcolor;
} DXVA_BlendCombination, *LPDXVA_BlendCombination;


/* Encryption Protocol #1 Data Structure */

#define DXVA_MAX_URIsize  1024

typedef struct _DXVA_EncryptProt1Data_Sign512_Accel512 {
  DXVA_EncryptProtocolHeader header;

  DWORD  dwSigningModulusSize;  /* equal to 64 */
  BYTE   SigningModulusValue[64];
  DWORD  dwSigningExponentSize; /* equal to 64 */
  BYTE   SigningExponentValue[64];

  DWORD  dwAccelModulusSize;    /* equal to 64 */
  BYTE   AccelModulusValue[64];
  DWORD  dwAccelExponentSize;   /* equal to 64 */
  BYTE   AccelExponentValue[64];

  DWORD  dwEncryptionFrequency;

  DWORD  dwURIsize;
  WCHAR  URIstring[DXVA_MAX_URIsize];

  BYTE   Signature[64];
} DXVA_EncryptProt1Data_Sign512_Accel512,
  *LPDXVA_EncryptProt1Data_Sign512_Accel512;


#pragma pack(push, 16)


typedef DXVA_MBctrl_I_HostResidDiff_1 *
       LPDXVA_MBctrl_I_HostResidDiff_1;

typedef DXVA_MBctrl_I_OffHostIDCT_1 *
       LPDXVA_MBctrl_I_OffHostIDCT_1;

typedef DXVA_MBctrl_P_HostResidDiff_1 *
       LPDXVA_MBctrl_P_HostResidDiff_1;

typedef DXVA_MBctrl_P_OffHostIDCT_1 *
       LPDXVA_MBctrl_P_OffHostIDCT_1;


#pragma pack(pop)

/*
 * Other forms of pictures are constructed in the obvious way
 * from the above by adjusting the number of residual difference
 * blocks, the number of motion vectors per macroblock, etc.
 */

#define readDXVA_MBskipsFollowing(ptr)       (((ptr)->dwMB_SNL & 0xFF000000) >> 24)
#define readDXVA_MBdataLocation(ptr)         (((ptr)->dwMB_SNL & 0x00FFFFFF))

#define writeDXVA_MB_SNL(ptr, skips, dloc)   ((ptr)->dwMB_SNL = (((skips) << 24) | (dloc)))
#define setDXVA_MBskipsFollowing(ptr, skips) ((ptr)->dwMB_SNL |= ((skips) << 24))
#define setDXVA_MBdataLocation(ptr, dloc)    ((ptr)->dwMB_SNL |= (dloc))

#define readDXVA_MvertFieldSel_3(ptr)    (((ptr)->wMBtype & 0x8000) >> 15)
#define readDXVA_MvertFieldSel_2(ptr)    (((ptr)->wMBtype & 0x4000) >> 14)
#define readDXVA_MvertFieldSel_1(ptr)    (((ptr)->wMBtype & 0x2000) >> 13)
#define readDXVA_MvertFieldSel_0(ptr)    (((ptr)->wMBtype & 0x1000) >> 12)
#define readDXVA_ReservedBits(ptr)       (((ptr)->wMBtype & 0x0800) >> 11)
#define readDXVA_HostResidDiff(ptr)      (((ptr)->wMBtype & 0x0400) >> 10)
#define readDXVA_MotionType(ptr)         (((ptr)->wMBtype & 0x0300) >>  8)
#define readDXVA_MBscanMethod(ptr)       (((ptr)->wMBtype & 0x00C0) >>  6)
#define readDXVA_FieldResidual(ptr)      (((ptr)->wMBtype & 0x0020) >>  5)
#define readDXVA_H261LoopFilter(ptr)     (((ptr)->wMBtype & 0x0010) >>  4)
#define readDXVA_Motion4MV(ptr)          (((ptr)->wMBtype & 0x0008) >>  3)
#define readDXVA_MotionBackward(ptr)     (((ptr)->wMBtype & 0x0004) >>  2)
#define readDXVA_MotionForward(ptr)      (((ptr)->wMBtype & 0x0002) >>  1)
#define readDXVA_IntraMacroblock(ptr)    (((ptr)->wMBtype & 0x0001))

#define setDXVA_MvertFieldSel_3(ptr)     ((ptr)->wMBtype |= 0x8000)
#define setDXVA_MvertFieldSel_2(ptr)     ((ptr)->wMBtype |= 0x4000)
#define setDXVA_MvertFieldSel_1(ptr)     ((ptr)->wMBtype |= 0x2000)
#define setDXVA_MvertFieldSel_0(ptr)     ((ptr)->wMBtype |= 0x1000)
#define setDXVA_ReservedBits(ptr)        ((ptr)->wMBtype |= 0x0800)
#define setDXVA_HostResidDiff(ptr)       ((ptr)->wMBtype |= 0x0400)
#define setDXVA_MotionType(ptr, value)   ((ptr)->wMBtype |= ((value) << 8))
#define setDXVA_MBscanMethod(ptr, value) ((ptr)->wMBtype |= ((value) << 6))
#define setDXVA_FieldResidual(ptr)       ((ptr)->wMBtype |= 0x0020)
#define setDXVA_H261LoopFilter(ptr)      ((ptr)->wMBtype |= 0x0010)
#define setDXVA_Motion4MV(ptr)           ((ptr)->wMBtype |= 0x0008)
#define setDXVA_MotionBackward(ptr)      ((ptr)->wMBtype |= 0x0004)
#define setDXVA_MotionForward(ptr)       ((ptr)->wMBtype |= 0x0002)
#define setDXVA_IntraMacroblock(ptr)     ((ptr)->wMBtype |= 0x0001)

#define readDXVA_Y___0coded(ptr)        (((ptr)->wPatternCode & 0x0800) >> 11)
#define readDXVA_Y___1coded(ptr)        (((ptr)->wPatternCode & 0x0400) >> 10)
#define readDXVA_Y___2coded(ptr)        (((ptr)->wPatternCode & 0x0200) >>  9)
#define readDXVA_Y___3coded(ptr)        (((ptr)->wPatternCode & 0x0100) >>  8)
#define readDXVA_Cb__4coded(ptr)        (((ptr)->wPatternCode & 0x0080) >>  7)
#define readDXVA_Cr__5coded(ptr)        (((ptr)->wPatternCode & 0x0040) >>  6)
#define readDXVA_Cb__6coded(ptr)        (((ptr)->wPatternCode & 0x0020) >>  5)
#define readDXVA_Cr__7coded(ptr)        (((ptr)->wPatternCode & 0x0010) >>  4)
#define readDXVA_Cb__8coded(ptr)        (((ptr)->wPatternCode & 0x0008) >>  3)
#define readDXVA_Cb__9coded(ptr)        (((ptr)->wPatternCode & 0x0004) >>  2)
#define readDXVA_Cr_10coded(ptr)        (((ptr)->wPatternCode & 0x0002) >>  1)
#define readDXVA_Cr_11coded(ptr)        (((ptr)->wPatternCode & 0x0001))

#define readDXVA_Y___0oflow(ptr)        (((ptr)->wPC_Overflow & 0x0800) >> 11)
#define readDXVA_Y___1oflow(ptr)        (((ptr)->wPC_Overflow & 0x0400) >> 10)
#define readDXVA_Y___2oflow(ptr)        (((ptr)->wPC_Overflow & 0x0200) >>  9)
#define readDXVA_Y___3oflow(ptr)        (((ptr)->wPC_Overflow & 0x0100) >>  8)
#define readDXVA_Cb__4oflow(ptr)        (((ptr)->wPC_Overflow & 0x0080) >>  7)
#define readDXVA_Cr__5oflow(ptr)        (((ptr)->wPC_Overflow & 0x0040) >>  6)
#define readDXVA_Cb__6oflow(ptr)        (((ptr)->wPC_Overflow & 0x0020) >>  5)
#define readDXVA_Cr__7oflow(ptr)        (((ptr)->wPC_Overflow & 0x0010) >>  4)
#define readDXVA_Cb__8oflow(ptr)        (((ptr)->wPC_Overflow & 0x0008) >>  3)
#define readDXVA_Cb__9oflow(ptr)        (((ptr)->wPC_Overflow & 0x0004) >>  2)
#define readDXVA_Cr_10oflow(ptr)        (((ptr)->wPC_Overflow & 0x0002) >>  1)
#define readDXVA_Cr_11oflow(ptr)        (((ptr)->wPC_Overflow & 0x0001))

#pragma pack(pop, BeforeDXVApacking)

#ifdef __cplusplus
}
#endif

#endif /* __DIRECTX_VA__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\edbback.h ===
/*
 *	EDBBACK.H
 *
 *	Microsoft Exchange Information Store
 *	Copyright (C) 1992-1995, Microsoft Corporation
 *	
 *	Contains declarations of additional definitions and interfaces
 *	for the Exchange Online backup Server APIs.
 */

#ifndef	_MDBBACK_
#define	_MDBBACK_

//
//	Useful types.
//

typedef	DWORD ERR;

typedef	LONG HRESULT;

#ifndef	EDBBACK_BUILD
#define	EDBBACK_API	__declspec(dllimport) _stdcall
#else
#define	EDBBACK_API
#endif

#ifdef	__cplusplus
extern "C" {
#endif

#define	BACKUP_WITH_UUID

HRESULT
EDBBACK_API
HrBackupRegisterW(
    UUID *puuidService,
    WCHAR * wszEndpointAnnotation
    );
HRESULT
EDBBACK_API
HrBackupRegisterA(
    UUID *puuidService,
    char * szEndpointAnnotation
    );

#ifdef	UNICODE
#define	HrBackupRegister HrBackupRegisterW
#else
#define	HrBackupRegister HrBackupRegisterA
#endif

HRESULT
EDBBACK_API
HrBackupUnregister(
    );

ERR
EDBBACK_API
ErrRestoreRegisterW(
	WCHAR * wszEndpointAnnotation,
	WCHAR * wszRestoreDll,
	char * szPerformRestore,
	char * szQueryDatabaseLocations
	);

ERR
EDBBACK_API
ErrRestoreRegisterA(
	char * szEndpointAnnotation,
	char * szRestoreDll,
	char * szPerformRestore,
	char * szQueryDatabaseLocations
	);

#ifdef	UNICODE
#define	ErrRestoreRegister ErrRestoreRegisterW
#else
#define	ErrRestoreRegister ErrRestoreRegisterA
#endif

ERR
EDBBACK_API
ErrRestoreUnregisterW(
	WCHAR * szEndpointAnnotation
	);

ERR
EDBBACK_API
ErrRestoreUnregisterA(
	char * szEndpointAnnotation
	);

#ifdef	UNICODE
#define	ErrRestoreUnregister ErrRestoreUnregisterW
#else
#define	ErrRestoreUnregister ErrRestoreUnregisterA
#endif

ERR
EDBBACK_API
ErrRecoverAfterRestoreW(
	WCHAR * szParametersRoot,
	WCHAR * wszAnnotation
	);

ERR
EDBBACK_API
ErrRecoverAfterRestoreA(
	char * szParametersRoot,
	char * szAnnotation
	);

#ifdef	UNICODE
#define	ErrRecoverAfterRestore ErrRecoverAfterRestoreW
#else
#define	ErrRecoverAfterRestore ErrRecoverAfterRestoreA
#endif



#ifdef	__cplusplus
}
#endif

#endif	// _MDBBACK_

=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\edbbcli.h ===
/*
 *	EDBBCLI.H
 *
 *	Microsoft Exchange Information Store
 *	Copyright (C) 1986-1996, Microsoft Corporation
 *	
 *	Contains declarations of additional definitions and interfaces
 *	for the Exchange Online Backup Client APIs.
 */

#ifndef	_EDBBCLI_
#define	_EDBBCLI_
#ifdef	__cplusplus
extern "C" {
#endif

#ifdef	MIDL_PASS
#define	RPC_STRING [string]
#else
#define	RPC_STRING
typedef unsigned short WCHAR;
#endif

#define	EDBBACK_MDB_SERVER	"Exchange MDB Database"
#define	EDBBACK_DS_SERVER	"Exchange DS Database"

#ifndef	EDBBACK_BUILD
#define	EDBBACK_API	__declspec(dllimport) _stdcall
#else
#define	EDBBACK_API
#endif

typedef	DWORD ERR;

typedef	LONG HRESULT;
typedef	LONG C;
typedef TCHAR BFT;

//
//	Type of backup passed into HrBackupPrepare()
//

#define	BACKUP_TYPE_FULL			0x01
#define	BACKUP_TYPE_LOGS_ONLY		0x02

//
//	Set the current log number to this value to disable incremental or
//	differential backup.
//
#define	BACKUP_DISABLE_INCREMENTAL	0xffffffff

//
//	Backup/Restore file types
//
//
//	Please note that these file types are binary values, even though they are text (or wchar) typed.
//
//	The code in the backup API's rely on the fact that values 0-256 in 8 bit ascii map to the values 0-256 in unicode.
//

//
//	If the BFT_DIRECTORY bit is set on the backup file type, it indicates that the path specified is a directory,
//	otherwise it is a file name.
//

#define	BFT_DIRECTORY			0x80

//
//	If the BFT_DATABASE bit is set on the backup file type, it indicates that the file goes into the database directory.
//

#define BFT_DATABASE_DIRECTORY	0x40

//
//	If the BFT_LOG bit is set on the backup file type, it indicates that the file goes into the log	directory.
//

#define	BFT_LOG_DIRECTORY		0x20

//
//	Database logs.
//

#define	BFT_LOG						(BFT)(TEXT('\x01') | BFT_LOG_DIRECTORY)
#define	BFT_LOG_DIR					(BFT)(TEXT('\x02') | BFT_DIRECTORY)

//
//	Checkpoint file.
//

#define	BFT_CHECKPOINT_DIR			(BFT)(TEXT('\x03') | BFT_DIRECTORY)

//
//	Database types.
//
#define	BFT_MDB_PRIVATE_DATABASE	(BFT)(TEXT('\x05') | BFT_DATABASE_DIRECTORY)
#define	BFT_MDB_PUBLIC_DATABASE		(BFT)(TEXT('\x06') | BFT_DATABASE_DIRECTORY)
#define	BFT_DSA_DATABASE			(BFT)(TEXT('\x07') | BFT_DATABASE_DIRECTORY)

//
//	JET patch files
//
//
//	

#define	BFT_PATCH_FILE				(BFT)(TEXT('\x08') | BFT_LOG_DIRECTORY)

//
//	Catch all for unknown file types.
//

#define	BFT_UNKNOWN					(BFT)(TEXT('\x0f'))

#include <edbmsg.h>

typedef void *HBC;

typedef struct tagEDB_RSTMAPA
{
	RPC_STRING char		*szDatabaseName;
	RPC_STRING char		*szNewDatabaseName;
} EDB_RSTMAPA, *PEDB_RSTMAPA;			/* restore map */

//	required for Exchange unicode support.
//	UNDONE: NYI
#define	UNICODE_RSTMAP

typedef struct tagEDB_RSTMAPW {
	RPC_STRING WCHAR *wszDatabaseName;
	RPC_STRING WCHAR *wszNewDatabaseName;
} EDB_RSTMAPW, *PEDB_RSTMAPW;

#ifdef UNICODE
#define EDB_RSTMAP EDB_RSTMAPW
#define PEDB_RSTMAP PEDB_RSTMAPW
#else
#define EDB_RSTMAP EDB_RSTMAPA
#define PEDB_RSTMAP PEDB_RSTMAPA
#endif


HRESULT
EDBBACK_API
HrBackupPrepareA(
	IN char * szBackupServer,
	IN char * szBackupAnnotation,
	IN unsigned long grbit,
	IN unsigned long btBackupType,
	OUT HBC *hbcBackupContext
	);

HRESULT
EDBBACK_API
HrBackupPrepareW(
	IN WCHAR * wszBackupServer,
	IN WCHAR * wszBackupAnnotation,
	IN unsigned long grbit,
	IN unsigned long btBackupType,
	OUT HBC *hbcBackupContext
	);

#ifdef	UNICODE
#define	HrBackupPrepare HrBackupPrepareW
#else
#define	HrBackupPrepare HrBackupPrepareA
#endif


HRESULT
EDBBACK_API
HrBackupGetDatabaseNamesA(
	IN HBC pvBackupContext,
	OUT LPSTR *ppszAttachmentInformation,
	OUT LPDWORD pcbSize
	);

HRESULT
EDBBACK_API
HrBackupGetDatabaseNamesW(
	IN HBC pvBackupContext,
	OUT LPWSTR *ppszAttachmentInformation,
	OUT LPDWORD pcbSize
	);

#ifdef	UNICODE
#define	HrBackupGetDatabaseNames HrBackupGetDatabaseNamesW
#else
#define	HrBackupGetDatabaseNames HrBackupGetDatabaseNamesA
#endif

HRESULT
EDBBACK_API
HrBackupOpenFileW(
	IN HBC pvBackupContext,
	IN WCHAR * wszAttachmentName,
	IN DWORD cbReadHintSize,
	OUT LARGE_INTEGER *pliFileSize
	);

HRESULT
EDBBACK_API
HrBackupOpenFileA(
	IN HBC pvBackupContext,
	IN char * szAttachmentName,
	IN DWORD cbReadHintSize,
	OUT LARGE_INTEGER *pliFileSize
	);

#ifdef	UNICODE
#define	HrBackupOpenFile HrBackupOpenFileW
#else
#define HrBackupOpenFile HrBackupOpenFileA
#endif


HRESULT
EDBBACK_API
HrBackupRead(
	IN HBC pvBackupContext,
	IN PVOID pvBuffer,
	IN DWORD cbBuffer,
	OUT PDWORD pcbRead
	);

HRESULT
EDBBACK_API
HrBackupClose(
	IN HBC pvBackupContext
	);

HRESULT
EDBBACK_API
HrBackupGetBackupLogsA(
	IN HBC pvBackupContext,
	IN LPSTR *szBackupLogFile,
	IN PDWORD pcbSize
	);

HRESULT
EDBBACK_API
HrBackupGetBackupLogsW(
	IN HBC pvBackupContext,
	IN LPWSTR *szBackupLogFile,
	IN PDWORD pcbSize
	);

#ifdef	UNICODE
#define	HrBackupGetBackupLogs HrBackupGetBackupLogsW
#else
#define	HrBackupGetBackupLogs HrBackupGetBackupLogsA
#endif

HRESULT
EDBBACK_API
HrBackupTruncateLogs(
	IN HBC pvBackupContext
	);


HRESULT
EDBBACK_API
HrBackupEnd(
	IN HBC pvBackupContext
	);


VOID
EDBBACK_API
BackupFree(
	IN PVOID pvBuffer
	);


HRESULT
EDBBACK_API
HrRestoreGetDatabaseLocationsA(
	IN HBC hbcBackupContext,
	OUT LPSTR *ppszDatabaseLocationList,
	OUT LPDWORD pcbSize
	);

HRESULT
EDBBACK_API
HrRestoreGetDatabaseLocationsW(
	IN HBC pvBackupContext,
	OUT LPWSTR *ppszDatabaseLocationList,
	OUT LPDWORD pcbSize
	);

#ifdef	UNICODE
#define	HrRestoreGetDatabaseLocations HrRestoreGetDatabaseLocationsW
#else
#define	HrRestoreGetDatabaseLocations HrRestoreGetDatabaseLocationsA
#endif

HRESULT
EDBBACK_API
HrRestorePrepareA(
	char * szServerName,
	char * szServiceAnnotation,
	HBC *phbcBackupContext
	);

HRESULT
EDBBACK_API
HrRestorePrepareW(
	WCHAR * szServerName,
	WCHAR * szServiceAnnotation,
	HBC *phbcBackupContext
	);

#ifdef	UNICODE
#define	HrRestorePrepare HrRestorePrepareW
#else
#define	HrRestorePrepare HrRestorePrepareA
#endif

//
//	HrRestoreRegister will register a restore
//	operation.  It will interlock all subsequent
//	restore operations, and will prevent the restore target
//	from starting until the call to HrRestoreRegisterComplete.
//

HRESULT
EDBBACK_API
HrRestoreRegisterA(
	IN HBC hbcRestoreContext,
	IN char * szCheckpointFilePath,
	IN char * szLogPath,
	IN EDB_RSTMAPA rgrstmap[],
	IN C crstmap,
	IN char * szBackupLogPath,
	IN ULONG genLow,
	IN ULONG genHigh
	);

HRESULT
EDBBACK_API
HrRestoreRegisterW(
	IN HBC hbcRestoreContext,
	IN WCHAR * wszCheckpointFilePath,
	IN WCHAR * wszLogPath,
	IN EDB_RSTMAPW rgrstmap[],
	IN C crstmap,
	IN WCHAR * wszBackupLogPath,
	IN ULONG genLow,
	IN ULONG genHigh
	);

#ifdef	UNICODE
#define	HrRestoreRegister HrRestoreRegisterW
#else
#define	HrRestoreRegister HrRestoreRegisterA
#endif

//
//	HrRestoreRegisterComplete will complete a restore
//	operation.  It will allow further subsequent
//	restore operations, and will allow the restore target
//	to start if hrRestoreState is success.
//
//	If hrRestoreState is NOT hrNone, this will
//	prevent the restore target from restarting.
//

HRESULT
EDBBACK_API
HrRestoreRegisterComplete(
	HBC hbcRestoreContext,
	HRESULT hrRestoreState
	);

HRESULT
EDBBACK_API
HrRestoreEnd(
	HBC hbcRestoreContext
	);

HRESULT
EDBBACK_API
HrSetCurrentBackupLogW(
	WCHAR *wszServerName,
	WCHAR * wszBackupAnnotation,
	DWORD dwCurrentLog
	);

HRESULT
EDBBACK_API
HrSetCurrentBackupLogA(
	CHAR * szServerName,
	CHAR * szBackupAnnotation,
	DWORD dwCurrentLog
	);

#ifdef	UNICODE
#define	HrSetCurrentBackupLog HrSetCurrentBackupLogW
#else
#define	HrSetCurrentBackupLog HrSetCurrentBackupLogA
#endif

#ifdef	__cplusplus
}
#endif

#endif	// _EDBBCLI_

=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\edkafx.h ===
// edkafx.h : #include file for standard EDK system include files,
//            These are used frequently, but are changed infrequently
// Copyright 1986 - 1998 Microsoft Corporation.  All Rights Reserved.

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions

#define _INC_WINDOWSX       // This keeps "WindowsX.h" from being included.
#define _MAPINLS_H_         // This keeps "MAPInls.h" from being included.
#include <edk.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\edkcode.h ===
// --edkcode.h------------------------------------------------------------------
//
//  EDK function ec = codes.
// 
// Copyright 1986 - 1998 Microsoft Corporation.  All Rights Reserved.
// -----------------------------------------------------------------------------

#ifndef _EDKCODE_H
#define _EDKCODE_H

#include <winerror.h>

// Every HRESULT is built from a serverity value, a facility
// value and an error code value.

#define FACILITY_EDK    11          // EDK facility value

// Pairs of EDK error codes and the HRESULTs built from them.
// EDK functions always return HRESULTs.  Console applications
// return exit codes via the _nEcFromHr function.

#define EC_EDK_E_NOT_FOUND          0x0001
#define EDK_E_NOT_FOUND \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_EDK, EC_EDK_E_NOT_FOUND)

#define EC_EDK_E_SHUTDOWN_SERVICE   0x0002
#define EDK_E_SHUTDOWN_SERVICE \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_EDK, EC_EDK_E_SHUTDOWN_SERVICE)

#define EC_EDK_E_ALREADY_EXISTS     0x0003
#define EDK_E_ALREADY_EXISTS \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_EDK, EC_EDK_E_ALREADY_EXISTS)

#define EC_EDK_E_END_OF_FILE        0x0004
#define EDK_E_END_OF_FILE \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_EDK, EC_EDK_E_END_OF_FILE)

#define EC_EDK_E_AMBIGUOUS          0x0005
#define EDK_E_AMBIGUOUS \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_EDK, EC_EDK_E_AMBIGUOUS)

#define EC_EDK_E_PARSE              0x0006
#define EDK_E_PARSE \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_EDK, EC_EDK_E_PARSE)

// maximum EDK exit code
#define MAX_EDK_ERROR_CODE          10

// exit codes for approved OLE and Win32 HRESULTs.
#define EC_EDK_E_FAIL               1 + MAX_EDK_ERROR_CODE
#define EC_EDK_E_OUTOFMEMORY        2 + MAX_EDK_ERROR_CODE
#define EC_EDK_E_INVALIDARG         3 + MAX_EDK_ERROR_CODE
#define EC_EDK_E_NOTIMPL            4 + MAX_EDK_ERROR_CODE
#define EC_EDK_E_NOINTERFACE        5 + MAX_EDK_ERROR_CODE
#define EC_EDK_E_ACCESSDENIED		6 + MAX_EDK_ERROR_CODE

// Unknown EDK exit code (HRESULT does not correspond to one of the "valid" EDK HRESULTs above)
#define EC_EDK_E_UNKNOWN            10 + MAX_EDK_ERROR_CODE

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\edkguid.h ===
/*
 *  EDKGUID.H
 *
 *  Microsoft Exchange Messaging Service
 *  Copyright (C) 1986-1996, Microsoft Corporation
 *  
 *  Contains declarations of GUID's for additional interfaces
 *  offered by Microsoft Exchange Messaging Service.
 */

#ifndef EDKGUID_INCLUDED
#define EDKGUID_INCLUDED

DEFINE_GUID(IID_IExchangeManageStore, 0x559d10b0,0xa772,0x11cd,0x9b,0xc8,0x00,0xaa,0x00,0x2f,0xc4,0x5a);
DEFINE_GUID(IID_IExchangeModifyTable, 0x2d734cb0,0x53fd,0x101b,0xb1,0x9d,0x08,0x00,0x2b,0x30,0x56,0xe3);
DEFINE_GUID(IID_IExchangeRuleAction,  0x74bba840,0xc93a,0x11ce,0x95,0x81,0x00,0xaa,0x00,0x57,0x42,0xf7);
DEFINE_GUID(IID_IExchangeFastTransfer, 0xff7db070,0xa88a,0x11cd,0x9b,0xc8,0x00,0xaa,0x00,0x2f,0xc4,0x5a);

DEFINE_GUID(IID_IExchangeExportChanges, 0xa3ea9cc0,0xd1b2,0x11cd,0x80,0xfc,0x00,0xaa,0x00,0x4b,0xba,0x0b);
DEFINE_GUID(IID_IExchangeImportHierarchyChanges, 0x85a66cf0,0xd0e0,0x11cd,0x80,0xfc,0x00,0xaa,0x00,0x4b,0xba,0x0b);
DEFINE_GUID(IID_IExchangeImportContentsChanges, 0xf75abfa0,0xd0e0,0x11cd,0x80,0xfc,0x00,0xaa,0x00,0x4b,0xba,0x0b);

DEFINE_GUID(IID_IExchangeFavorites, 0xcf4f3bc0,0xec66,0x11ce,0xb3,0x1c,0x00,0xaa,0x00,0x57,0x4c,0xc6);

/*
	The following interface GUID is the start of a range of IID's
	Each IID specifies a different CPID.  The IID corresponding to
	cpid 932 would be defined by 
		DEFINE_GUID(IID_IExchangeMessageCpid0, 932, 0x1ae9, 0x11cf,	0x84, 0xe0, 0x00, 0xaa, 0x00, 0x6b, 04f, 0xae);  
*/

DEFINE_GUID(IID_IExchangeMessageCpid0, 0x0, 0x1ae9,0x11cf, 0x84, 0xe0, 0x00, 0xaa, 0x00, 0x6b, 0x4f, 0xae);  

#endif  //EDKGUID_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\edkcfg.h ===
// --edkcfg.h-------------------------------------------------------------------
// 
//  EDK Gateway Configuration Routines
//
// Copyright 1986 - 1998 Microsoft Corporation.  All Rights Reserved.
//
// -----------------------------------------------------------------------------

#ifndef _EDKCFG_H_
#define _EDKCFG_H_

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

//
// Type Definitions
//

//$--ADVISECALLBACK-------------------------------------------------------------
//  Function type for routine to be called when a binary blob changes.
// -----------------------------------------------------------------------------
typedef HRESULT (ADVISECALLBACK) (
    LPVOID              lpvUserContext, 
    LPWSTR              lpwszOwnerTag, 
    ULONG               cProps, 
    LPSPropValue        lpProps);

typedef ADVISECALLBACK *LPADVISECALLBACK;

//$--ADVISENOTIFY---------------------------------------------------------------
//  Object attached to an ADVISEOBJ, which represents a single blob and the 
//  callback routine to call when it is modified.
// -----------------------------------------------------------------------------
typedef struct _AdviseNotify {
    struct _AdviseNotify * lpNext;
    LPSTR              lpszOwnerTag;
    LPWSTR              lpwszOwnerTag;
    LPBYTE              lpbBlob;
    ULONG               cbBlob;
    LPADVISECALLBACK    lpfnCallback;
    LPVOID              lpvUserContext;
    BOOL                fFirstTime;
} ADVISENOTIFY, *LPADVISENOTIFY;

//$--ADVISEOBJ------------------------------------------------------------------
//  Object representing a MAPI session whose extension data is being monitored.
// -----------------------------------------------------------------------------
typedef struct {
    LPMAPISESSION       lpSession;
    LPMAPIPROP          lpCurrentObject;
    ULONG               nPollInterval;
    ULONG               ulUSNChangedPropTag;
    ULONG               ulExtensionDataPropTag;
    CRITICAL_SECTION    csCriticalSection;
    HANDLE              hPollThreadStop;
    HANDLE              hPollThread;
    ULONG               ulPollThreadID;
    ULONG               ulUSNChanged;
    LPSPropValue        lpExtensionData;
    LPADVISENOTIFY      lpNotifyList;
} ADVISEOBJ, *LPADVISEOBJ;

//
// Function Prototypes
//

//$--HrCfgCreateAdviseObj-------------------------------------------------------
//  Begin monitoring of a MAPI session for changes to extension data.
//  This routine should be called once to create an advise object for a MAPI 
//  session that is being monitored.  Then, HrCfgAdvise() should be called 
//  once for each extension data section that is being monitored.
//  If nPollInterval == 0 then no monitoring thread is created, and the user 
//  must do polling manually by calling HrCfgPollAdviseObj().
// -----------------------------------------------------------------------------
HRESULT HrCfgCreateAdviseObj(               // RETURNS: HRESULT
    IN  LPMAPISESSION       lpSession,      // MAPI session to monitor
    IN  ULONG               nPollInterval,  // milliseconds between polling
    OUT LPADVISEOBJ *       lppAdviseObj);  // created advise object

//$--HrCfgPollAdviseObj---------------------------------------------------------
//  Checks an advise object against what is stored in the DSA.  Calls the 
//  notification routines if there are any changes.
// -----------------------------------------------------------------------------
HRESULT HrCfgPollAdviseObj(                 // RETURNS: HRESULT
    IN  LPADVISEOBJ     lpAdviseObj);       // advise object to poll

//$--HrCfgDestroyAdviseObj------------------------------------------------------
//  End monitoring of a MAPI session.  This routine calls HrCfgUnadvise() for 
//  any extension data sections that are actively being monitored.
// -----------------------------------------------------------------------------
HRESULT HrCfgDestroyAdviseObj(              // RETURNS: HRESULT
    IN  LPADVISEOBJ         lpAdviseObj);   // advise object to destroy

//$--HrCfgAdvise----------------------------------------------------------------
//  Begin monitoring of an extension data section.  When the extension data 
//  changes, the specified callback routine is called.  Note: The callback 
//  routine will be called once from hrCfgAdvise() to set the initial extension 
//  data values.
// -----------------------------------------------------------------------------
HRESULT HrCfgAdvise(                        // RETURNS: HRESULT
    IN  LPADVISEOBJ         lpAdviseObj,    // advise object
    IN  LPSTR               lpszSection,    // name of extension data section
    IN  LPADVISECALLBACK    lpfnCallback,   // function to call on changes
    IN  LPVOID              lpvUserContext); // user-defined context

//$--HrCfgUnadvise--------------------------------------------------------------
//  End monitoring of an extension data section.
// -----------------------------------------------------------------------------
HRESULT HrCfgUnadvise(                      // RETURNS: HRESULT
    IN  LPADVISEOBJ         lpAdviseObj,    // advise object
    IN  LPSTR               lpszSection);   // name of extension data section

//$--HrCfgPackData--------------------------------------------------------------
//  Take a configuration name and a set of MAPI properties and pack them into 
//  a binary buffer suitable to be saved in the directory information tree for 
//  the gateway or other object.
// -----------------------------------------------------------------------------
HRESULT HrCfgPackDataA(					    // RETURN: HRESULT
	IN	LPSTR			lpszOwnerTag,		// name of configuration (or NULL)
	IN	ULONG			cProps,				// number of MAPI properties
	IN	LPSPropValue	lpProps,			// MAPI properties for this config.
	OUT	ULONG *			lpcbConfigData,		// size of resulting binary struct.
	OUT	LPBYTE *		lppbConfigData);	// resulting binary structure

HRESULT HrCfgPackDataW(					    // RETURN: HRESULT
	IN	LPWSTR			lpwszOwnerTag,	    // name of configuration (or NULL)
	IN	ULONG			cProps,				// number of MAPI properties
	IN	LPSPropValue	lpProps,			// MAPI properties for this config.
	OUT	ULONG *			lpcbConfigData,		// size of resulting binary struct.
	OUT	LPBYTE *		lppbConfigData);	// resulting binary structure

#ifdef UNICODE
#define HrCfgPackData HrCfgPackDataW
#else
#define HrCfgPackData HrCfgPackDataA
#endif

//$--HrCfgUnpackData------------------------------------------------------------
//  Take a packed binary buffer and unpack it to yield a configuration name, 
//  number of properties, and an array of MAPI properties.  If the number of 
//  properties is zero then NULL is returned for the array of properties.
// -----------------------------------------------------------------------------
HRESULT HrCfgUnpackDataA(					// RETURNS: HRESULT
	IN	ULONG			cbConfigData,		// size of of binary structure
	IN	LPBYTE			lpbConfigData,		// pointer to binary structure
	OUT	LPSTR *		    lppszOwnerTag,      // name of configuration (or NULL)
	OUT	ULONG *			lpcProps,			// number of MAPI properties
	OUT	LPSPropValue *	lppProps);			// MAPI properties for this config.

HRESULT HrCfgUnpackDataW(					// RETURNS: HRESULT
	IN	ULONG			cbConfigData,		// size of of binary structure
	IN	LPBYTE			lpbConfigData,		// pointer to binary structure
	OUT	LPWSTR *		lppwszOwnerTag,     // name of configuration (or NULL)
	OUT	ULONG *			lpcProps,			// number of MAPI properties
	OUT	LPSPropValue *	lppProps);			// MAPI properties for this config.

#ifdef UNICODE
#define HrCfgUnpackData HrCfgUnpackDataW
#else
#define HrCfgUnpackData HrCfgUnpackDataA
#endif

//$--HrOpenSiteContainer-----------------------------------------------------------------
//  Takes a pointer to a MAPI session and returns an IMAPIProp interface for 
//  the current site object.
// -----------------------------------------------------------------------------
HRESULT HrOpenSiteContainer(							// RETURNS: HRESULT
	IN	LPMAPISESSION	lpSession,			// MAPI session
	OUT	LPMAPIPROP *	lppSite);           // current site

//$--HrOpenSiteContainerAddressing-------------------------------------------------------
//  Takes a pointer to a MAPI session and returns an IMAPIProp interface for 
//  the current site addressing object.
// -----------------------------------------------------------------------------
HRESULT HrOpenSiteContainerAddressing(               // RETURNS: HRESULT
	IN	LPMAPISESSION	lpSession,          // MAPI session
	OUT	LPMAPIPROP *	lppSiteAddressing); // current site addressing

//$--HrOpenSessionObject--------------------------------------------------------
//  Takes a pointer to a MAPI session and returns an IMAPIProp interface for 
//  the current object that the session is logged in as.
// -----------------------------------------------------------------------------
HRESULT HrOpenSessionObject(				// RETURNS: HRESULT
	IN	LPMAPISESSION	lpSession,			// MAPI session
	OUT	LPMAPIPROP *	lppCurrentObject);	// current object

//$--HrCfgPropertyTagFromNameId----------------------------------------------------
//  Takes a pointer to an IMAPIProp interface and a name ID, and returns the 
//  MAPI property tag that represents the given name ID for that interface.
// -----------------------------------------------------------------------------
HRESULT HrCfgPropertyTagFromNameId(			// RETURNS: HRESULT
	IN	LPMAPIPROP		lpMAPIProp,			// IMAPIProp interface
    IN  LONG            lNameID,            // Name ID
	OUT	ULONG *			lpulPropTag);		// MAPI property tag of name ID

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\edbmsg.h ===
/*
 *	EDBMSG.H
 *
 *	Microsoft Exchange Information Store
 *	Copyright (C) 1986-1996, Microsoft Corporation
 *	
 *	Contains declarations of additional properties and interfaces
 *	offered by Microsoft Exchange Information Store
 */

#ifndef _EDBMSG_
#define _EDBMSG_

//
//	SUCCESS
//
//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//
#define FACILITY_SYSTEM                  0x0
#define FACILITY_EDB                     0x800
#define FACILITY_BACKUP                  0x7FF


//
// Define the severity codes
//
#define STATUS_SEVERITY_WARNING          0x2
#define STATUS_SEVERITY_SUCCESS          0x0
#define STATUS_SEVERITY_INFORMATIONAL    0x1
#define STATUS_SEVERITY_ERROR            0x3


//
// MessageId: hrNone
//
// MessageText:
//
//  The operation was successful
//
#define hrNone                           ((HRESULT)0x00000000L)

//
//	ERRORS
//
//
// MessageId: hrNyi
//
// MessageText:
//
//  The function is not yet implemented
//
#define hrNyi                            ((HRESULT)0xC0000001L)

//
//	Backup errors
//
//
// MessageId: hrInvalidParam
//
// MessageText:
//
//  The parameter is not valid.
//
#define hrInvalidParam                   ((HRESULT)0xC7FF0001L)

//
// MessageId: hrError
//
// MessageText:
//
//  An internal error has occurred.
//
#define hrError                          ((HRESULT)0xC7FF0002L)

//
// MessageId: hrInvalidHandle
//
// MessageText:
//
//  The handle is not valid.
//
#define hrInvalidHandle                  ((HRESULT)0xC7FF0003L)

//
// MessageId: hrRestoreInProgress
//
// MessageText:
//
//  The Restore process is already in progress.
//
#define hrRestoreInProgress              ((HRESULT)0xC7FF0004L)

//
// MessageId: hrAlreadyOpen
//
// MessageText:
//
//  The file specified is already open.
//
#define hrAlreadyOpen                    ((HRESULT)0xC7FF0005L)

//
// MessageId: hrInvalidRecips
//
// MessageText:
//
//  The recipients are invalid.
//
#define hrInvalidRecips                  ((HRESULT)0xC7FF0006L)

//
// MessageId: hrCouldNotConnect
//
// MessageText:
//
//  Unable to perform the backup. Either you are not connected to the specified backup server
//  or the service you are trying to backup is not running.
//
#define hrCouldNotConnect                ((HRESULT)0xC7FF0007L)

//
// MessageId: hrRestoreMapExists
//
// MessageText:
//
//  A restore map already exists for the specified component.  You can only specify
//  a restore map when performing a full restore.
//
#define hrRestoreMapExists               ((HRESULT)0xC7FF0008L)

//
// MessageId: hrIncrementalBackupDisabled
//
// MessageText:
//
//  Another application has modified the specified Microsoft Exchange database such that any
//  subsequent backups will fail. You must perform a full backup to fix this problem.
//
#define hrIncrementalBackupDisabled      ((HRESULT)0xC7FF0009L)

//
// MessageId: hrLogFileNotFound
//
// MessageText:
//
//  Unable to perform an incremental backup because a required Microsoft Exchange database log file could not be found.
//
#define hrLogFileNotFound                ((HRESULT)0xC7FF000AL)

//
// MessageId: hrCircularLogging
//
// MessageText:
//
//  The Microsoft Exchange component specified is configured to use circular database logs.
//  It cannot be backed up without a full backup.
//
#define hrCircularLogging                ((HRESULT)0xC7FF000BL)

//
// MessageId: hrNoFullRestore
//
// MessageText:
//
//  The databases have not been restored to this machine. You cannot restore an incremental backup
//  until a full backup has been restored.
//
#define hrNoFullRestore                  ((HRESULT)0xC7FF000CL)

//
// MessageId: hrCommunicationError
//
// MessageText:
//
//  A communications error occurred while attempting to perform a local backup.
//
#define hrCommunicationError             ((HRESULT)0xC7FF000DL)

//
// MessageId: hrFullBackupNotTaken
//
// MessageText:
//
//  You must perform a full backup before you can perform an incremental backup.
//
#define hrFullBackupNotTaken             ((HRESULT)0xC7FF000EL)

#define	hrAlreadyListening	((HRESULT)RPC_S_ALREADY_LISTENING)
//
//	ERRORS
//
//
// SYSTEM errors
//
//
// MessageId: hrFileClose
//
// MessageText:
//
//  Unable to close the DOS file
//
#define hrFileClose                      ((HRESULT)0xC8000066L)

//
// MessageId: hrOutOfThreads
//
// MessageText:
//
//  Unable to start a thread because there are none available.
//
#define hrOutOfThreads                   ((HRESULT)0xC8000067L)

//
// MessageId: hrTooManyIO
//
// MessageText:
//
//  The system is busy because there are too many I/Os.
//
#define hrTooManyIO                      ((HRESULT)0xC8000069L)

//
//	BUFFER MANAGER errors
//
//
// MessageId: hrBFNotSynchronous
//
// MessageText:
//
//  The buffer page has been evicted.
//
#define hrBFNotSynchronous               ((HRESULT)0x880000C8L)

//
// MessageId: hrBFPageNotFound
//
// MessageText:
//
//  Unable to find the page.
//
#define hrBFPageNotFound                 ((HRESULT)0x880000C9L)

//
// MessageId: hrBFInUse
//
// MessageText:
//
//  Unable to abandon the buffer.
//
#define hrBFInUse                        ((HRESULT)0xC80000CAL)

//
//	DIRECTORY MANAGER errors
//
//
// MessageId: hrPMRecDeleted
//
// MessageText:
//
//  The record has been deleted.
//
#define hrPMRecDeleted                   ((HRESULT)0xC800012EL)

//
// MessageId: hrRemainingVersions
//
// MessageText:
//
//  There is idle work remaining.
//
#define hrRemainingVersions              ((HRESULT)0x88000141L)

//
//	RECORD MANAGER errors
//
//
// MessageId: hrFLDKeyTooBig
//
// MessageText:
//
//  The key was truncated because it is more than 255 bytes.
//
#define hrFLDKeyTooBig                   ((HRESULT)0x88000190L)

//
// MessageId: hrFLDTooManySegments
//
// MessageText:
//
//  There are too many key segments.
//
#define hrFLDTooManySegments             ((HRESULT)0xC8000191L)

//
// MessageId: hrFLDNullKey
//
// MessageText:
//
//  The key is NULL.
//
#define hrFLDNullKey                     ((HRESULT)0x88000192L)

//
//	LOGGING/RECOVERY errors
//
//
// MessageId: hrLogFileCorrupt
//
// MessageText:
//
//  The log file is damaged.
//
#define hrLogFileCorrupt                 ((HRESULT)0xC80001F5L)

//
// MessageId: hrNoBackupDirectory
//
// MessageText:
//
//  No backup directory was given.
//
#define hrNoBackupDirectory              ((HRESULT)0xC80001F7L)

//
// MessageId: hrBackupDirectoryNotEmpty
//
// MessageText:
//
//  The backup directory is not empty.
//
#define hrBackupDirectoryNotEmpty        ((HRESULT)0xC80001F8L)

//
// MessageId: hrBackupInProgress
//
// MessageText:
//
//  Backup is already active.
//
#define hrBackupInProgress               ((HRESULT)0xC80001F9L)

//
// MessageId: hrMissingPreviousLogFile
//
// MessageText:
//
//  A log file for the checkpoint is missing.
//
#define hrMissingPreviousLogFile         ((HRESULT)0xC80001FDL)

//
// MessageId: hrLogWriteFail
//
// MessageText:
//
//  Unable to write to the log file.
//
#define hrLogWriteFail                   ((HRESULT)0xC80001FEL)

//
// MessageId: hrBadLogVersion
//
// MessageText:
//
//  The version of the log file is not compatible with the version of the Microsoft Exchange Server database (EDB).
//
#define hrBadLogVersion                  ((HRESULT)0xC8000202L)

//
// MessageId: hrInvalidLogSequence
//
// MessageText:
//
//  The time stamp in the next log does not match what was expected.
//
#define hrInvalidLogSequence             ((HRESULT)0xC8000203L)

//
// MessageId: hrLoggingDisabled
//
// MessageText:
//
//  The log is not active.
//
#define hrLoggingDisabled                ((HRESULT)0xC8000204L)

//
// MessageId: hrLogBufferTooSmall
//
// MessageText:
//
//  The log buffer is too small to be recovered.
//
#define hrLogBufferTooSmall              ((HRESULT)0xC8000205L)

//
// MessageId: hrLogSequenceEnd
//
// MessageText:
//
//  The maximum number of log files has been exceeded.
//
#define hrLogSequenceEnd                 ((HRESULT)0xC8000207L)

//
// MessageId: hrNoBackup
//
// MessageText:
//
//  There is no backup in progress.
//
#define hrNoBackup                       ((HRESULT)0xC8000208L)

//
// MessageId: hrInvalidBackupSequence
//
// MessageText:
//
//  The backup call is out of sequence.
//
#define hrInvalidBackupSequence          ((HRESULT)0xC8000209L)

//
// MessageId: hrBackupNotAllowedYet
//
// MessageText:
//
//  Unable to perform a backup now.
//
#define hrBackupNotAllowedYet            ((HRESULT)0xC800020BL)

//
// MessageId: hrDeleteBackupFileFail
//
// MessageText:
//
//  Unable to delete the backup file.
//
#define hrDeleteBackupFileFail           ((HRESULT)0xC800020CL)

//
// MessageId: hrMakeBackupDirectoryFail
//
// MessageText:
//
//  Unable to make a backup temporary directory.
//
#define hrMakeBackupDirectoryFail        ((HRESULT)0xC800020DL)

//
// MessageId: hrInvalidBackup
//
// MessageText:
//
//  An incremental backup cannot be performed when circular logging is enabled.
//
#define hrInvalidBackup                  ((HRESULT)0xC800020EL)

//
// MessageId: hrRecoveredWithErrors
//
// MessageText:
//
//  Errors were encountered during the repair process.
//
#define hrRecoveredWithErrors            ((HRESULT)0xC800020FL)

//
// MessageId: hrMissingLogFile
//
// MessageText:
//
//  The current log file is missing.
//
#define hrMissingLogFile                 ((HRESULT)0xC8000210L)

//
// MessageId: hrLogDiskFull
//
// MessageText:
//
//  The log disk is full.
//
#define hrLogDiskFull                    ((HRESULT)0xC8000211L)

//
// MessageId: hrBadLogSignature
//
// MessageText:
//
//  A log file is damaged.
//
#define hrBadLogSignature                ((HRESULT)0xC8000212L)

//
// MessageId: hrBadDbSignature
//
// MessageText:
//
//  A database file is damaged.
//
#define hrBadDbSignature                 ((HRESULT)0xC8000213L)

//
// MessageId: hrBadCheckpointSignature
//
// MessageText:
//
//  A checkpoint file is damaged.
//
#define hrBadCheckpointSignature         ((HRESULT)0xC8000214L)

//
// MessageId: hrCheckpointCorrupt
//
// MessageText:
//
//  A checkpoint file either could not be found or is damaged.
//
#define hrCheckpointCorrupt              ((HRESULT)0xC8000215L)

//
// MessageId: hrDatabaseInconsistent
//
// MessageText:
//
//  The database is damaged.
//
#define hrDatabaseInconsistent           ((HRESULT)0xC8000226L)

//
// MessageId: hrConsistentTimeMismatch
//
// MessageText:
//
//  There is a mismatch in the database's last consistent time.
//
#define hrConsistentTimeMismatch         ((HRESULT)0xC8000227L)

//
// MessageId: hrPatchFileMismatch
//
// MessageText:
//
//  The patch file is not generated from this backup.
//
#define hrPatchFileMismatch              ((HRESULT)0xC8000228L)

//
// MessageId: hrRestoreLogTooLow
//
// MessageText:
//
//  The starting log number is too low for the restore.
//
#define hrRestoreLogTooLow               ((HRESULT)0xC8000229L)

//
// MessageId: hrRestoreLogTooHigh
//
// MessageText:
//
//  The starting log number is too high for the restore.
//
#define hrRestoreLogTooHigh              ((HRESULT)0xC800022AL)

//
// MessageId: hrGivenLogFileHasBadSignature
//
// MessageText:
//
//  The log file downloaded from the tape is damaged.
//
#define hrGivenLogFileHasBadSignature    ((HRESULT)0xC800022BL)

//
// MessageId: hrGivenLogFileIsNotContiguous
//
// MessageText:
//
//  Unable to find a mandatory log file after the tape was downloaded.
//
#define hrGivenLogFileIsNotContiguous    ((HRESULT)0xC800022CL)

//
// MessageId: hrMissingRestoreLogFiles
//
// MessageText:
//
//  The data is not fully restored because some log files are missing.
//
#define hrMissingRestoreLogFiles         ((HRESULT)0xC800022DL)

//
// MessageId: hrExistingLogFileHasBadSignature
//
// MessageText:
//
//  The log file in the log file path is damaged.
//
#define hrExistingLogFileHasBadSignature ((HRESULT)0x8800022EL)

//
// MessageId: hrExistingLogFileIsNotContiguous
//
// MessageText:
//
//  Unable to find a mandatory log file in the log file path.
//
#define hrExistingLogFileIsNotContiguous ((HRESULT)0x8800022FL)

//
// MessageId: hrMissingFullBackup
//
// MessageText:
//
//  The database missed a previous full backup before the incremental backup.
//
#define hrMissingFullBackup              ((HRESULT)0xC8000230L)

//
// MessageId: hrBadBackupDatabaseSize
//
// MessageText:
//
//  The backup database size must be a multiple of 4K (4096 bytes).
//
#define hrBadBackupDatabaseSize          ((HRESULT)0xC8000231L)

//
// MessageId: hrTermInProgress
//
// MessageText:
//
//  The database is being shut down.
//
#define hrTermInProgress                 ((HRESULT)0xC80003E8L)

//
// MessageId: hrFeatureNotAvailable
//
// MessageText:
//
//  The feature is not available.
//
#define hrFeatureNotAvailable            ((HRESULT)0xC80003E9L)

//
// MessageId: hrInvalidName
//
// MessageText:
//
//  The name is not valid.
//
#define hrInvalidName                    ((HRESULT)0xC80003EAL)

//
// MessageId: hrInvalidParameter
//
// MessageText:
//
//  The parameter is not valid.
//
#define hrInvalidParameter               ((HRESULT)0xC80003EBL)

//
// MessageId: hrColumnNull
//
// MessageText:
//
//  The value of the column is null.
//
#define hrColumnNull                     ((HRESULT)0x880003ECL)

//
// MessageId: hrBufferTruncated
//
// MessageText:
//
//  The buffer is too small for data.
//
#define hrBufferTruncated                ((HRESULT)0x880003EEL)

//
// MessageId: hrDatabaseAttached
//
// MessageText:
//
//  The database is already attached.
//
#define hrDatabaseAttached               ((HRESULT)0x880003EFL)

//
// MessageId: hrInvalidDatabaseId
//
// MessageText:
//
//  The database ID is not valid.
//
#define hrInvalidDatabaseId              ((HRESULT)0xC80003F2L)

//
// MessageId: hrOutOfMemory
//
// MessageText:
//
//  The computer is out of memory.
//
#define hrOutOfMemory                    ((HRESULT)0xC80003F3L)

//
// MessageId: hrOutOfDatabaseSpace
//
// MessageText:
//
//  The database has reached the maximum size of 16 GB.
//
#define hrOutOfDatabaseSpace             ((HRESULT)0xC80003F4L)

//
// MessageId: hrOutOfCursors
//
// MessageText:
//
//  Out of table cursors.
//
#define hrOutOfCursors                   ((HRESULT)0xC80003F5L)

//
// MessageId: hrOutOfBuffers
//
// MessageText:
//
//  Out of database page buffers.
//
#define hrOutOfBuffers                   ((HRESULT)0xC80003F6L)

//
// MessageId: hrTooManyIndexes
//
// MessageText:
//
//  There are too many indexes.
//
#define hrTooManyIndexes                 ((HRESULT)0xC80003F7L)

//
// MessageId: hrTooManyKeys
//
// MessageText:
//
//  There are too many columns in an index.
//
#define hrTooManyKeys                    ((HRESULT)0xC80003F8L)

//
// MessageId: hrRecordDeleted
//
// MessageText:
//
//  The record has been deleted.
//
#define hrRecordDeleted                  ((HRESULT)0xC80003F9L)

//
// MessageId: hrReadVerifyFailure
//
// MessageText:
//
//  A read verification error occurred.
//
#define hrReadVerifyFailure              ((HRESULT)0xC80003FAL)

//
// MessageId: hrOutOfFileHandles
//
// MessageText:
//
//  Out of file handles.
//
#define hrOutOfFileHandles               ((HRESULT)0xC80003FCL)

//
// MessageId: hrDiskIO
//
// MessageText:
//
//  A disk I/O error occurred.
//
#define hrDiskIO                         ((HRESULT)0xC80003FEL)

//
// MessageId: hrInvalidPath
//
// MessageText:
//
//  The path to the file is not valid.
//
#define hrInvalidPath                    ((HRESULT)0xC80003FFL)

//
// MessageId: hrRecordTooBig
//
// MessageText:
//
//  The record has exceeded the maximum size.
//
#define hrRecordTooBig                   ((HRESULT)0xC8000402L)

//
// MessageId: hrTooManyOpenDatabases
//
// MessageText:
//
//  There are too many open databases.
//
#define hrTooManyOpenDatabases           ((HRESULT)0xC8000403L)

//
// MessageId: hrInvalidDatabase
//
// MessageText:
//
//  The file is not a database file.
//
#define hrInvalidDatabase                ((HRESULT)0xC8000404L)

//
// MessageId: hrNotInitialized
//
// MessageText:
//
//  The database was not yet called.
//
#define hrNotInitialized                 ((HRESULT)0xC8000405L)

//
// MessageId: hrAlreadyInitialized
//
// MessageText:
//
//  The database was already called.
//
#define hrAlreadyInitialized             ((HRESULT)0xC8000406L)

//
// MessageId: hrFileAccessDenied
//
// MessageText:
//
//  Unable to access the file.
//
#define hrFileAccessDenied               ((HRESULT)0xC8000408L)

//
// MessageId: hrBufferTooSmall
//
// MessageText:
//
//  The buffer is too small.
//
#define hrBufferTooSmall                 ((HRESULT)0xC800040EL)

//
// MessageId: hrSeekNotEqual
//
// MessageText:
//
//  Either SeekLE or SeekGE did not find an exact match.
//
#define hrSeekNotEqual                   ((HRESULT)0x8800040FL)

//
// MessageId: hrTooManyColumns
//
// MessageText:
//
//  There are too many columns defined.
//
#define hrTooManyColumns                 ((HRESULT)0xC8000410L)

//
// MessageId: hrContainerNotEmpty
//
// MessageText:
//
//  The container is not empty.
//
#define hrContainerNotEmpty              ((HRESULT)0xC8000413L)

//
// MessageId: hrInvalidFilename
//
// MessageText:
//
//  The filename is not valid.
//
#define hrInvalidFilename                ((HRESULT)0xC8000414L)

//
// MessageId: hrInvalidBookmark
//
// MessageText:
//
//  The bookmark is not valid.
//
#define hrInvalidBookmark                ((HRESULT)0xC8000415L)

//
// MessageId: hrColumnInUse
//
// MessageText:
//
//  The column is used in an index.
//
#define hrColumnInUse                    ((HRESULT)0xC8000416L)

//
// MessageId: hrInvalidBufferSize
//
// MessageText:
//
//  The data buffer does not match the column size.
//
#define hrInvalidBufferSize              ((HRESULT)0xC8000417L)

//
// MessageId: hrColumnNotUpdatable
//
// MessageText:
//
//  Unable to set the column value.
//
#define hrColumnNotUpdatable             ((HRESULT)0xC8000418L)

//
// MessageId: hrIndexInUse
//
// MessageText:
//
//  The index is in use.
//
#define hrIndexInUse                     ((HRESULT)0xC800041BL)

//
// MessageId: hrNullKeyDisallowed
//
// MessageText:
//
//  Null keys are not allowed on an index.
//
#define hrNullKeyDisallowed              ((HRESULT)0xC800041DL)

//
// MessageId: hrNotInTransaction
//
// MessageText:
//
//  The operation must be within a transaction.
//
#define hrNotInTransaction               ((HRESULT)0xC800041EL)

//
// MessageId: hrNoIdleActivity
//
// MessageText:
//
//  No idle activity occured.
//
#define hrNoIdleActivity                 ((HRESULT)0x88000422L)

//
// MessageId: hrTooManyActiveUsers
//
// MessageText:
//
//  There are too many active database users.
//
#define hrTooManyActiveUsers             ((HRESULT)0xC8000423L)

//
// MessageId: hrInvalidCountry
//
// MessageText:
//
//  The country code is either not known or is not valid.
//
#define hrInvalidCountry                 ((HRESULT)0xC8000425L)

//
// MessageId: hrInvalidLanguageId
//
// MessageText:
//
//  The language ID is either not known or is not valid.
//
#define hrInvalidLanguageId              ((HRESULT)0xC8000426L)

//
// MessageId: hrInvalidCodePage
//
// MessageText:
//
//  The code page is either not known or is not valid.
//
#define hrInvalidCodePage                ((HRESULT)0xC8000427L)

//
// MessageId: hrNoWriteLock
//
// MessageText:
//
//  There is no write lock at transaction level 0.
//
#define hrNoWriteLock                    ((HRESULT)0x8800042BL)

//
// MessageId: hrColumnSetNull
//
// MessageText:
//
//  The column value is set to null.
//
#define hrColumnSetNull                  ((HRESULT)0x8800042CL)

//
// MessageId: hrVersionStoreOutOfMemory
//
// MessageText:
//
//   lMaxVerPages exceeded (XJET only)
//
#define hrVersionStoreOutOfMemory        ((HRESULT)0xC800042DL)

//
// MessageId: hrCurrencyStackOutOfMemory
//
// MessageText:
//
//  Out of cursors.
//
#define hrCurrencyStackOutOfMemory       ((HRESULT)0xC800042EL)

//
// MessageId: hrOutOfSessions
//
// MessageText:
//
//  Out of sessions.
//
#define hrOutOfSessions                  ((HRESULT)0xC800044DL)

//
// MessageId: hrWriteConflict
//
// MessageText:
//
//  The write lock failed due to an outstanding write lock.
//
#define hrWriteConflict                  ((HRESULT)0xC800044EL)

//
// MessageId: hrTransTooDeep
//
// MessageText:
//
//  The transactions are nested too deeply.
//
#define hrTransTooDeep                   ((HRESULT)0xC800044FL)

//
// MessageId: hrInvalidSesid
//
// MessageText:
//
//  The session handle is not valid.
//
#define hrInvalidSesid                   ((HRESULT)0xC8000450L)

//
// MessageId: hrSessionWriteConflict
//
// MessageText:
//
//  Another session has a private version of the page.
//
#define hrSessionWriteConflict           ((HRESULT)0xC8000453L)

//
// MessageId: hrInTransaction
//
// MessageText:
//
//  The operation is not allowed within a transaction.
//
#define hrInTransaction                  ((HRESULT)0xC8000454L)

//
// MessageId: hrDatabaseDuplicate
//
// MessageText:
//
//  The database already exists.
//
#define hrDatabaseDuplicate              ((HRESULT)0xC80004B1L)

//
// MessageId: hrDatabaseInUse
//
// MessageText:
//
//  The database is in use.
//
#define hrDatabaseInUse                  ((HRESULT)0xC80004B2L)

//
// MessageId: hrDatabaseNotFound
//
// MessageText:
//
//  The database does not exist.
//
#define hrDatabaseNotFound               ((HRESULT)0xC80004B3L)

//
// MessageId: hrDatabaseInvalidName
//
// MessageText:
//
//  The database name is not valid.
//
#define hrDatabaseInvalidName            ((HRESULT)0xC80004B4L)

//
// MessageId: hrDatabaseInvalidPages
//
// MessageText:
//
//  The number of pages is not valid.
//
#define hrDatabaseInvalidPages           ((HRESULT)0xC80004B5L)

//
// MessageId: hrDatabaseCorrupted
//
// MessageText:
//
//  The database file is either damaged or cannot be found.
//
#define hrDatabaseCorrupted              ((HRESULT)0xC80004B6L)

//
// MessageId: hrDatabaseLocked
//
// MessageText:
//
//  The database is locked.
//
#define hrDatabaseLocked                 ((HRESULT)0xC80004B7L)

//
// MessageId: hrTableEmpty
//
// MessageText:
//
//  An empty table was opened.
//
#define hrTableEmpty                     ((HRESULT)0x88000515L)

//
// MessageId: hrTableLocked
//
// MessageText:
//
//  The table is locked.
//
#define hrTableLocked                    ((HRESULT)0xC8000516L)

//
// MessageId: hrTableDuplicate
//
// MessageText:
//
//  The table already exists.
//
#define hrTableDuplicate                 ((HRESULT)0xC8000517L)

//
// MessageId: hrTableInUse
//
// MessageText:
//
//  Unable to lock the table because it is already in use.
//
#define hrTableInUse                     ((HRESULT)0xC8000518L)

//
// MessageId: hrObjectNotFound
//
// MessageText:
//
//  The table or object does not exist.
//
#define hrObjectNotFound                 ((HRESULT)0xC8000519L)

//
// MessageId: hrCannotRename
//
// MessageText:
//
//  Unable to rename the temporary file.
//
#define hrCannotRename                   ((HRESULT)0xC800051AL)

//
// MessageId: hrDensityInvalid
//
// MessageText:
//
//  The file/index density is not valid.
//
#define hrDensityInvalid                 ((HRESULT)0xC800051BL)

//
// MessageId: hrTableNotEmpty
//
// MessageText:
//
//  Unable to define the clustered index.
//
#define hrTableNotEmpty                  ((HRESULT)0xC800051CL)

//
// MessageId: hrInvalidTableId
//
// MessageText:
//
//  The table ID is not valid.
//
#define hrInvalidTableId                 ((HRESULT)0xC800051EL)

//
// MessageId: hrTooManyOpenTables
//
// MessageText:
//
//  Unable to open any more tables.
//
#define hrTooManyOpenTables              ((HRESULT)0xC800051FL)

//
// MessageId: hrIllegalOperation
//
// MessageText:
//
//  The operation is not supported on tables.
//
#define hrIllegalOperation               ((HRESULT)0xC8000520L)

//
// MessageId: hrObjectDuplicate
//
// MessageText:
//
//  The table or object name is already being used.
//
#define hrObjectDuplicate                ((HRESULT)0xC8000522L)

//
// MessageId: hrInvalidObject
//
// MessageText:
//
//  The object is not valid for operation.
//
#define hrInvalidObject                  ((HRESULT)0xC8000524L)

//
// MessageId: hrIndexCantBuild
//
// MessageText:
//
//  Unable to build a clustered index.
//
#define hrIndexCantBuild                 ((HRESULT)0xC8000579L)

//
// MessageId: hrIndexHasPrimary
//
// MessageText:
//
//  The primary index is already defined.
//
#define hrIndexHasPrimary                ((HRESULT)0xC800057AL)

//
// MessageId: hrIndexDuplicate
//
// MessageText:
//
//  The index is already defined.
//
#define hrIndexDuplicate                 ((HRESULT)0xC800057BL)

//
// MessageId: hrIndexNotFound
//
// MessageText:
//
//  The index does not exist.
//
#define hrIndexNotFound                  ((HRESULT)0xC800057CL)

//
// MessageId: hrIndexMustStay
//
// MessageText:
//
//  Unable to delete a clustered index.
//
#define hrIndexMustStay                  ((HRESULT)0xC800057DL)

//
// MessageId: hrIndexInvalidDef
//
// MessageText:
//
//  The index definition is illegal.
//
#define hrIndexInvalidDef                ((HRESULT)0xC800057EL)

//
// MessageId: hrIndexHasClustered
//
// MessageText:
//
//  The clustered index is already defined.
//
#define hrIndexHasClustered              ((HRESULT)0xC8000580L)

//
// MessageId: hrCreateIndexFailed
//
// MessageText:
//
//  Unable to create the index because an error occurred while creating a table.
//
#define hrCreateIndexFailed              ((HRESULT)0x88000581L)

//
// MessageId: hrTooManyOpenIndexes
//
// MessageText:
//
//  Out of index description blocks.
//
#define hrTooManyOpenIndexes             ((HRESULT)0xC8000582L)

//
// MessageId: hrColumnLong
//
// MessageText:
//
//  The column value is too long.
//
#define hrColumnLong                     ((HRESULT)0xC80005DDL)

//
// MessageId: hrColumnDoesNotFit
//
// MessageText:
//
//  The field will not fit in the record.
//
#define hrColumnDoesNotFit               ((HRESULT)0xC80005DFL)

//
// MessageId: hrNullInvalid
//
// MessageText:
//
//  The value cannot be null.
//
#define hrNullInvalid                    ((HRESULT)0xC80005E0L)

//
// MessageId: hrColumnIndexed
//
// MessageText:
//
//  Unable to delete because the column is indexed.
//
#define hrColumnIndexed                  ((HRESULT)0xC80005E1L)

//
// MessageId: hrColumnTooBig
//
// MessageText:
//
//  The length of the field exceeds the maximum length of 255 bytes.
//
#define hrColumnTooBig                   ((HRESULT)0xC80005E2L)

//
// MessageId: hrColumnNotFound
//
// MessageText:
//
//  Unable to find the column.
//
#define hrColumnNotFound                 ((HRESULT)0xC80005E3L)

//
// MessageId: hrColumnDuplicate
//
// MessageText:
//
//  The field is already defined.
//
#define hrColumnDuplicate                ((HRESULT)0xC80005E4L)

//
// MessageId: hrColumn2ndSysMaint
//
// MessageText:
//
//  Only one auto-increment or version column is allowed per table.
//
#define hrColumn2ndSysMaint              ((HRESULT)0xC80005E6L)

//
// MessageId: hrInvalidColumnType
//
// MessageText:
//
//  The column data type is not valid.
//
#define hrInvalidColumnType              ((HRESULT)0xC80005E7L)

//
// MessageId: hrColumnMaxTruncated
//
// MessageText:
//
//  The column was truncated because it exceeded the maximum length of 255 bytes.
//
#define hrColumnMaxTruncated             ((HRESULT)0x880005E8L)

//
// MessageId: hrColumnCannotIndex
//
// MessageText:
//
//  Unable to index a long value column.
//
#define hrColumnCannotIndex              ((HRESULT)0xC80005E9L)

//
// MessageId: hrTaggedNotNULL
//
// MessageText:
//
//  Tagged columns cannot be null.
//
#define hrTaggedNotNULL                  ((HRESULT)0xC80005EAL)

//
// MessageId: hrNoCurrentIndex
//
// MessageText:
//
//  The entry is not valid without a current index.
//
#define hrNoCurrentIndex                 ((HRESULT)0xC80005EBL)

//
// MessageId: hrKeyIsMade
//
// MessageText:
//
//  The key is completely made.
//
#define hrKeyIsMade                      ((HRESULT)0xC80005ECL)

//
// MessageId: hrBadColumnId
//
// MessageText:
//
//  The column ID is not correct.
//
#define hrBadColumnId                    ((HRESULT)0xC80005EDL)

//
// MessageId: hrBadItagSequence
//
// MessageText:
//
//  There is a bad instance identifier for a multivalued column.
//
#define hrBadItagSequence                ((HRESULT)0xC80005EEL)

//
// MessageId: hrCannotBeTagged
//
// MessageText:
//
//  AutoIncrement and Version cannot be multivalued.
//
#define hrCannotBeTagged                 ((HRESULT)0xC80005F1L)

//
// MessageId: hrRecordNotFound
//
// MessageText:
//
//  Unable to find the key.
//
#define hrRecordNotFound                 ((HRESULT)0xC8000641L)

//
// MessageId: hrNoCurrentRecord
//
// MessageText:
//
//  The currency is not on a record.
//
#define hrNoCurrentRecord                ((HRESULT)0xC8000643L)

//
// MessageId: hrRecordClusteredChanged
//
// MessageText:
//
//  A clustered key cannot be changed.
//
#define hrRecordClusteredChanged         ((HRESULT)0xC8000644L)

//
// MessageId: hrKeyDuplicate
//
// MessageText:
//
//  The key already exists.
//
#define hrKeyDuplicate                   ((HRESULT)0xC8000645L)

//
// MessageId: hrAlreadyPrepared
//
// MessageText:
//
//  The current entry has already been copied or cleared.
//
#define hrAlreadyPrepared                ((HRESULT)0xC8000647L)

//
// MessageId: hrKeyNotMade
//
// MessageText:
//
//  No key was made.
//
#define hrKeyNotMade                     ((HRESULT)0xC8000648L)

//
// MessageId: hrUpdateNotPrepared
//
// MessageText:
//
//  Update was not prepared.
//
#define hrUpdateNotPrepared              ((HRESULT)0xC8000649L)

//
// MessageId: hrwrnDataHasChanged
//
// MessageText:
//
//  Data has changed.
//
#define hrwrnDataHasChanged              ((HRESULT)0x8800064AL)

//
// MessageId: hrerrDataHasChanged
//
// MessageText:
//
//  The operation was abandoned because data has changed.
//
#define hrerrDataHasChanged              ((HRESULT)0xC800064BL)

//
// MessageId: hrKeyChanged
//
// MessageText:
//
//  Moved to a new key.
//
#define hrKeyChanged                     ((HRESULT)0x88000652L)

//
// MessageId: hrTooManySorts
//
// MessageText:
//
//  There are too many sort processes.
//
#define hrTooManySorts                   ((HRESULT)0xC80006A5L)

//
// MessageId: hrInvalidOnSort
//
// MessageText:
//
//  An operation that is not valid occurred in the sort.
//
#define hrInvalidOnSort                  ((HRESULT)0xC80006A6L)

//
// MessageId: hrTempFileOpenError
//
// MessageText:
//
//  Unable to open the temporary file.
//
#define hrTempFileOpenError              ((HRESULT)0xC800070BL)

//
// MessageId: hrTooManyAttachedDatabases
//
// MessageText:
//
//  There are too many databases open.
//
#define hrTooManyAttachedDatabases       ((HRESULT)0xC800070DL)

//
// MessageId: hrDiskFull
//
// MessageText:
//
//  The disk is full.
//
#define hrDiskFull                       ((HRESULT)0xC8000710L)

//
// MessageId: hrPermissionDenied
//
// MessageText:
//
//  Permission is denied.
//
#define hrPermissionDenied               ((HRESULT)0xC8000711L)

//
// MessageId: hrFileNotFound
//
// MessageText:
//
//  Unable to find the file.
//
#define hrFileNotFound                   ((HRESULT)0xC8000713L)

//
// MessageId: hrFileOpenReadOnly
//
// MessageText:
//
//  The database file is read only.
//
#define hrFileOpenReadOnly               ((HRESULT)0x88000715L)

//
// MessageId: hrAfterInitialization
//
// MessageText:
//
//  Unable to restore after initialization.
//
#define hrAfterInitialization            ((HRESULT)0xC800073AL)

//
// MessageId: hrLogCorrupted
//
// MessageText:
//
//  The database log files are damaged.
//
#define hrLogCorrupted                   ((HRESULT)0xC800073CL)

//
// MessageId: hrInvalidOperation
//
// MessageText:
//
//  The operation is not valid.
//
#define hrInvalidOperation               ((HRESULT)0xC8000772L)

//
// MessageId: hrAccessDenied
//
// MessageText:
//
//  Access is denied.
//
#define hrAccessDenied                   ((HRESULT)0xC8000773L)

#endif	// _EDBMSG_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\edkevent.h ===
// --edkevent.h-----------------------------------------------------------------
//
// Header file for module containing event logging functions.
//
// Copyright 1986 - 1998 Microsoft Corporation.  All Rights Reserved.
// -----------------------------------------------------------------------------

#if !defined(_EDKEVENT_H)
#define _EDKEVENT_H

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

//$--EDKEVENTCOUNT--------------------------------------------------------------
//  Structure to hold the counts of the number of each type of event that has 
//  been logged.
// -----------------------------------------------------------------------------
typedef struct _EDKEventCount {
	DWORD	cError;
	DWORD	cWarning;
	DWORD	cInformation;
} EDKEVENTCOUNT, *LPEDKEVENTCOUNT;


//$--HrEventOpenLog----------------------------------------------------------
//  Initialize event logging for the EDK.
// -----------------------------------------------------------------------------
HRESULT HrEventOpenLog(				// RETURNS: HRESULT
	IN LPSTR pszApplicationName,		// name of this application
	IN LPSTR pszExecutableName,		    // name of executable
    IN LPSTR pszEventMessageFile,       // name of event message file
    IN LPSTR pszParameterMessageFile,   // name of parameter message file
    IN LPSTR pszCategoryMessageFile,    // name of category message file
	OUT LPHANDLE phEventSourceOut);		// [returns event logging handle]

//$--HrEventUseExisting---------------------------------------------------
//  Initialize event logging for the EDK by connecting to an already open 
//  event log handle.  This allows EventLogMsg() to log events to a handle 
//  that was opened elsewhere.  Calling HrEventCloseLog() after calling 
//  this routine will do internal cleanup but will not close the event log 
//  handle.  One example of where this routine is useful is within a DLL 
//  that is called by EDK code in which event logging has already been 
//  initialized.
// -----------------------------------------------------------------------------
HRESULT HrEventUseExisting(		// RETURNS: HRESULT
	IN HANDLE hExistingEventSource);		// previously opened event log handle


//$--EventLogMsg----------------------------------------------------------------
//
//  EventLogMsgA -- byte string version
//  EventLogMsgW -- word string version
//
//  Log an event to the event log, and optionally, log the original error(s) 
//  that caused the event.  It has the following parameters:
//
//   DWORD    dwEvent
//   DWORD    cStrings
//  [LPSTR   pszString1]
//  [LPSTR   pszString2]
//  [...................]
//  [LPSTR   pszStringN]
//   DWORD    cErrorCodes
//  [DWORD    dwErrorCode1]
//  [DWORD    dwErrorCode2]
//  [.....................]
//  [DWORD    dwErrorCodeN]
//
//  Each of the above strings and error codes are used as parameters to the 
//  message in the order they appear.  This means that in event messages, 
//  all of the  error message replacement parameters must have higher numbers 
//  than all of the string replacement parameters.  For example:
//
//      EventLogMsg(
//          MYAPP_CANNOT_COPY_FILE, 
//          2, pszSourceFile, pszDestFile, 
//          1, dwError);
//
//  And the message would be defined as:
//
//      MessageId=
//      Severity=Error
//      Facility=Application
//      SymbolicName=MYAPP_CANNOT_COPY_FILE
//      Language=English
//      Cannot copy file from %1 to %2 due to the following error:%n%3.
//      .
//
//  Note: This routine preserves the last error value returned by 
//        GetLastError().
//
// -----------------------------------------------------------------------------

//$--EventLogMsgA---------------------------------------------------------------
//  Byte string version of EventLogMsg().
//
//  IMPORTANT!!! The error code count [and error code list] is REQUIRED after 
//  the text string count [and text string list].  Failure to include the 
//  error code argument(s) may cause unexpected results.
// -----------------------------------------------------------------------------
VOID EventLogMsgA(						// RETURNS: nothing
	IN DWORD dwEvent,					// error code of event to log
	IN DWORD cStrings,					// number of text string parameters
	IN ...								// text string parameters
//	IN DWORD cErrors,					// number of error code parameters
//	IN ...								// error code parameters
);

//$--EventLogMsgW---------------------------------------------------------------
//  Word string version of EventLogMsg().
//
//  IMPORTANT!!! The error code count [and error code list] is REQUIRED after 
//  the text string count [and text string list].  Failure to include the 
//  error code argument(s) may cause unexpected results.
// -----------------------------------------------------------------------------
VOID EventLogMsgW(						// RETURNS: nothing
	IN DWORD dwEvent,					// error code of event to log
	IN DWORD cStrings,					// number of text string parameters
	IN ...								// text string parameters
//	IN DWORD cErrors,					// number of error code parameters
//	IN ...								// error code parameters
);

#ifdef UNICODE
#define EventLogMsg  EventLogMsgW
#else
#define EventLogMsg  EventLogMsgA
#endif // !UNICODE


//$--HrEventGetCounts--------------------------------------------------------
//  Returns the number of Error, Warning, and Information events logged (by the 
//  current executable).
// -----------------------------------------------------------------------------
HRESULT HrEventGetCounts(			// RETURNS: HRESULT
	OUT LPEDKEVENTCOUNT lpsEventCount);	// structure to return event counts


//$--HrEventCloseLog---------------------------------------------------------
//  Shut down event logging for the EDK.
// -----------------------------------------------------------------------------
HRESULT HrEventCloseLog();			// RETURNS: HRESULT

// $--HrEventGetHandle------------------------------------------------------
//
// DESCRIPTION: Retrieve event handle for this executable.
//
// OUTPUT:  phEventLog   --  event log handle pointer
//
// RETURNS: HRESULT --  NOERROR if successful,
//                      E_INVALIDARG if bad input,
//                      E_FAIL otherwise.
//
// Notes:  
//
// 1) The event handle returned will be NULL if there is
// no open event log.
//
// 2) DLLs may not call this function to retrieve the event handle
// which their parent executable set.  If the parent executable sets
// an event handle, then it must pass the event handle to the DLL.
//
// ----------------------------------------------------------------------------
HRESULT HrEventGetHandle(
        IN HANDLE * phEventLog);       // event log handle pointer

#ifdef __cplusplus
}   // end extern "C"
#endif // __cplusplus

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\edk.h ===
// --edk.h----------------------------------------------------------------------
// 
//  Master include file for Microsoft Exchange SDK
// 
// Copyright 1986 - 1998 Microsoft Corporation.  All Rights Reserved.
// -----------------------------------------------------------------------------

#ifndef __EDK_H__
#define __EDK_H__

//==============================================================================
//  VERSION INFORMATION
//==============================================================================

#define EDK_MAJOR_VERSION       1                   // major header version
#define EDK_MINOR_VERSION       0                   // minor header version
#define EDK_VERSION_NUMBER      ((EDK_MAJOR_VERSION<<8)|EDK_MINOR_VERSION)
#define EDK_VERSION_STR         "1.00.00\0"

//==============================================================================
// By default, the VC++ Workbench creates a make file with _DEBUG or NDEBUG.  
// We need to define DEBUG or SHIP to work with all the header files.
//==============================================================================

#if !defined(DEBUG) && !defined(SHIP)
    #ifdef _DEBUG
        #define DEBUG
        #define TEST
    #else   // NDEBUG should be defined
        #define SHIP
    #endif
#endif

//==============================================================================
//  NON-RESOURCE
//==============================================================================

#ifndef RC_INVOKED      // skip rest of file

#pragma warning(disable:4100 4103 4115 4200 4201 4204 4211 4214 4505 4514 4611 4706 4710)

#define _INC_OLE
#define INC_RPC
#define INC_OLE2

#ifdef UNICODE
#ifndef _UNICODE
#define _UNICODE
#endif
#endif

#if defined(_M_IX86)
#define _EXCHANGE_MACHINE_TYPE "i386"
#elif  defined(_M_ALPHA)
#define _EXCHANGE_MACHINE_TYPE "ALPHA"
#elif  defined(_M_MRX000)
#define _EXCHANGE_MACHINE_TYPE "MIPS"
#elif  defined(_M_PPC)
#define _EXCHANGE_MACHINE_TYPE "PPC"
#endif

#include <windows.h>
#include <windowsx.h>

#pragma warning(disable:4103)
#include <objbase.h>
#pragma warning(disable:4103)

#ifdef EXTERN_C
#undef EXTERN_C
#endif

#ifdef __cplusplus
    #define EXTERN_C    extern "C"
#else
    #define EXTERN_C    extern
#endif

EXTERN_C const IID IID_IExchangeManageStore;
EXTERN_C const IID IID_IExchangeModifyTable;
EXTERN_C const IID IID_IExchangeConfigureXfer;
EXTERN_C const IID IID_IExchangeXferBuffer;
EXTERN_C const IID IID_IExchangeExportChanges;
EXTERN_C const IID IID_IExchangeImportHierarchyChanges;
EXTERN_C const IID IID_IExchangeImportContentsChanges;
EXTERN_C const IID LIBID_aclcls;
EXTERN_C const IID IID_IExchangeFolderACLs;
EXTERN_C const IID LIBID_rulecls;
EXTERN_C const IID IID_IExchangeFolderRules;
EXTERN_C const IID IID_IEDKVirtualStreamOnProperty;
EXTERN_C const IID IID_IExchangeRuleAction;
EXTERN_C const IID IID_IExchangeFastTransfer;
EXTERN_C const IID IID_IExchangeFavorites;
EXTERN_C const IID IID_IExchangeMessageCpid0;
EXTERN_C const IID IID_IExchangeRuleExtCallback;
EXTERN_C const IID IID_IExchangeRuleExt;

#ifdef EDK_USES_IID
#define INITGUID

#include <initguid.h>

#pragma warning(disable:4200)
#include <edkguid.h>
#include <aclsid.h>
#include <rclsid.h>
#include <vsopcsid.h>
#pragma warning(disable:4200)

#define USES_IID_IUnknown
#define USES_IID_IMessage
#define USES_IID_IStream
#define USES_IID_IClassFactory
#define USES_IID_IPersistMessage
#define USES_IID_IMAPIForm
#define USES_IID_IMAPIProp
#define USES_IID_IMAPIPropData
#define USES_IID_IMAPIFolder
#define USES_IID_IABContainer
#define USES_IID_IAddrBook
#define USES_IID_IMAPIFormInfo
#define USES_IID_IMailUser
#define USES_IID_IAttachment
#define USES_IID_IDistList
#define USES_IID_IMAPIStatus
#define USES_IID_IMAPISession
#define USES_IID_IMsgStore
#define USES_IID_IProfSect
#define USES_IID_IMAPIContainer
#define USES_IID_IMAPITable
#define USES_PS_MAPI
#define USES_PS_PUBLIC_STRINGS
#endif

#include <assert.h>
#include <conio.h>
#include <ctl3d.h>
#include <ctype.h>
#include <fcntl.h>
#include <io.h>
#include <limits.h>
#include <malloc.h>

#define _MAPINLS_H_

#pragma warning(disable:4200)
#include <mapidefs.h>
#pragma warning(disable:4200)

#ifdef DEBUG
#ifdef MAPI_DEFERRED_ERRORS
#undef MAPI_DEFERRED_ERRORS
#endif
#define MAPI_DEFERRED_ERRORS    0
#endif

#include <mapicode.h>
#include <mapiform.h>
#include <mapiguid.h>
#include <mapispi.h>
#include <mapitags.h>
#include <mapiutil.h>
#include <mapival.h>
#include <mapiwin.h>
#include <mapix.h>
#include <rtflib.h>

#include <memory.h>

#pragma warning(disable:4200)
#include <edkmdb.h>
#pragma warning(disable:4200)

#pragma warning(disable:4200)
#include <_entryid.h>
#pragma warning(disable:4200)

#include <process.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <tchar.h>

#pragma warning(disable:4200)
#include <tnef.h>
#pragma warning(disable:4200)

#include <wchar.h>
#include <winbase.h>
#include <winperf.h>


#pragma warning(disable:4200)
#include <imessage.h>
#pragma warning(disable:4200)

#include <emsabtag.h>

//==============================================================================
// EDK include files.  See end of file for more include files that need to be
// included after macro definitions.
//==============================================================================

#include "edkmsg.h"

#include "edkcode.h"
#include "edkdebug.h"

#include "edkmapi.h"
#include "addrlkup.h"
#include "edktrack.h"
#include "convstrc.h"
#include "convcwrp.h"
#include "edkevent.h"
#include "exchinst.h"
#include "monitor.h"
#include "gwreport.h"
#include "stats.h"
#include "stattype.h"
#include "winwrap.h"
#include "mblogon.h"
#include "edkutils.h"
#include "newpst.h"
#include "aclcls.h"
#include "rulecls.h"
#include "proptag.h"
#include "edkcfg.h"
#include "vsof.h"
#include "vsop.h"

//==============================================================================
//  MACROS
//==============================================================================

#ifdef __cplusplus
#ifdef FBadUnknown
#undef FBadUnknown
#endif
#define FBadUnknown( lpObj ) ((lpObj) == NULL)
#endif

// convenient macros for manipulating 64-bit integers to 32-bit integers
#define LOWPART_DWORDLONG		((DWORDLONG) 0x00000000FFFFFFFF)
#define HIGHPART_DWORDLONG		((DWORDLONG) 0xFFFFFFFF00000000)

#define MAKEDWORDLONG(lo,hi)	( (DWORDLONG) ( ( (hi) << 32 ) | (lo) ) )
#define LOWDWORD(x)				( (DWORD) ( (x) & LOWPART_DWORDLONG ) )
#define HIDWORD(x)				( (DWORD) ( ( (x) & HIGHPART_DWORDLONG ) >> 32 ) )

#define LOWPART_LONGLONG		((LONGLONG) 0x00000000FFFFFFFF)
#define HIGHPART_LONGLONG		((LONGLONG) 0xFFFFFFFF00000000)

#define LOWLONG(x)				( (DWORD) ( (x) & LOWPART_LONGLONG ) )
#define HILONG(x)				( (LONG) ( ( (x) & HIGHPART_LONGLONG ) >> 32 ) )

// definition of the Exchange address type.
#define EXCHANGE_ADDRTYPE	"EX"

#define MAX_ULONG (ULONG) ~0L   // All bits on.

#define EDK_MAX_QUERY_ROWS 1024

#define VALID_OBJ_TYPE(x) (((x) >= ((ULONG)0x00000001)) && \
			   ((x) <= ((ULONG)0x0000000B)))

#define VALID_PROP_ID(x)  ((PROP_ID((x)) != 0x0000) && (PROP_ID((x)) != 0xFFFF))

#define CbNewSPropValue(_centries) \
    ((_centries)*sizeof(SPropValue))

#define CbNewFlagList(_cflag) \
	(offsetof(FlagList,ulFlag) + (_cflag)*sizeof(ULONG))

#define OLECALL(x)  (x)->lpVtbl

#define ULOLERELEASE(x) \
{                                    \
	if((x) != NULL)                  \
	{                                \
	    OLECALL((x))->Release((x));  \
	}                                \
	(x) = NULL;                      \
}

#define VALID_BOOL(x)   (((x) == TRUE) || ((x) == FALSE))

#define VALID_EDK_CONTAINER(x) \
    ((((ULONG)(x)) == ((ULONG)EDK_FOLDER)) || \
    (((ULONG)(x)) == ((ULONG)EDK_PUBLIC_FOLDER)) || \
    (((ULONG)(x)) == ((ULONG)EDK_DIRECTORY)))

// Returns count of elements in any array.
#define ARRAY_CNT( array)    (sizeof( array) / sizeof(array[0]))

#if !defined(__cplusplus) || defined(CINTERFACE)
#define MAPICALL(x)     (x)->lpVtbl
#else
#define MAPICALL(x)     (x)
#endif

#ifdef  MAX_ALIGN
#undef  MAX_ALIGN
#endif
#define MAX_ALIGN    16

//$--cbStrLen@------------------------------------------------
//  Returns total number of bytes (including NULL) used by 
//  a string.  Useful for string allocations...
// -----------------------------------------------------------
#define cbStrLenA(sz)   ((lstrlenA((sz)) + 1) * sizeof(CHAR))

#if defined(_M_IX86)
#define cbStrLenW(sz)   ((lstrlenW((sz)) + 1) * sizeof(WCHAR))
#else
// lstrlenW can return 0 for UNALIGNED UNICODE strings on non-IX86 platforms
__inline static size_t cbStrLenW(
    IN UNALIGNED const WCHAR *wsz)
{
    size_t cbWsz = 0;

    for(; *wsz; wsz++)
        cbWsz += sizeof( WCHAR);

    return( cbWsz + sizeof( WCHAR));
}
#endif

#ifdef UNICODE
#define cbStrLen    cbStrLenW
#else 
#define cbStrLen    cbStrLenA
#endif

// Block transfer size for streams and files
#define EDK_CBTRANSFER  4096

#define ULRELEASE(x) \
{                    \
	UlRelease((x));  \
	(x) = NULL;      \
}

#define MAPIFREEBUFFER(x) \
{                         \
    MAPIFreeBuffer((x));  \
	(x) = NULL;           \
}

#define FREEPADRLIST(x) \
{                       \
    FreePadrlist((x));  \
	(x) = NULL;         \
}

#define FREEPROWS(x)    \
{                       \
    FreeProws((x));     \
	(x) = NULL;         \
}

#define FREE(x) { if((x) != NULL) { free((void *)(x)); (x) = NULL; } }

#define LOCALFREE(x) { if((x) != NULL) {LocalFree((void *)(x)); (x) = NULL;} }

#define GLOBALFREE(x) { if((x) != NULL) {GlobalFree((void *)(x)); (x) = NULL;} }

#define DLLIMPORT __declspec( dllimport )
#define DLLEXPORT __declspec( dllexport )

#define STRNCPY(dst,src) lstrcpyn((dst), (src), (sizeof(dst)/sizeof(TCHAR))-1)

#define STRNCAT(dst,src) _tcsncat((dst), (src), (sizeof(dst)/sizeof(TCHAR))-1)

#define FREEHSCM(h)                         \
{                                           \
    if ((h) != NULL)                        \
	{                                       \
        if(CloseServiceHandle(h) == FALSE)  \
        {                                   \
            HRESULT _hr = HR_LOG(E_FAIL);   \
        }                                   \
		(h) = NULL;                         \
	}                                       \
}

#define CLOSEHANDLE(h)                                  \
{                                                       \
    if(((h) != NULL) && ((h) != INVALID_HANDLE_VALUE))  \
    {                                                   \
        if(CloseHandle((h)) == FALSE)                   \
        {                                               \
            HRESULT _hr = HR_LOG(E_FAIL);               \
        }                                               \
        (h) = NULL;                                     \
    }                                                   \
}

#define REGCLOSEKEY(h)                                  \
{                                                       \
	if((h) != NULL && (h) != INVALID_HANDLE_VALUE)      \
	{                                                   \
		if(RegCloseKey((h)) != ERROR_SUCCESS)           \
        {                                               \
            HRESULT _hr = HR_LOG(E_FAIL);               \
        }                                               \
		(h) = NULL;                                     \
	}                                                   \
}

//==============================================================================
// EDK include files that depend upon above macros.
//==============================================================================

#ifdef __cplusplus  // C++ classes
    #include "EdkUtCPP.H"
#endif

//==============================================================================

#endif  // RC_INVOKED
#endif  // __EDK_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\edevdefs.h ===
//------------------------------------------------------------------------------
// File: EDevDefs.h
//
// Desc: External Device (such as a VCR) control interface parameter and
//       value definitions.  
//
//       Note:  new constants added:  ED_BASE+800L -> ED_BASE+811L
//
// Copyright (c) 1992 - 2000, Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------------------------


#ifndef __EDEVDEFS__
#define __EDEVDEFS__


#define ED_BASE		        		0x1000L

// this is used to tell the device communications object which
// physical communications port to use.
#define DEV_PORT_SIM	1
#define DEV_PORT_COM1	2	// standard serial ports
#define DEV_PORT_COM2	3
#define DEV_PORT_COM3	4
#define DEV_PORT_COM4	5
#define DEV_PORT_DIAQ	6	// Diaquest driver
#define DEV_PORT_ARTI	7	// ARTI driver
#define DEV_PORT_1394	8	// IEEE 1394 Bus
#define DEV_PORT_USB	9	// Universal Serial Bus
#define DEV_PORT_MIN	DEV_PORT_SIM
#define DEV_PORT_MAX	DEV_PORT_USB


//	IAMExtDevice Capability Items:  unless otherwise specified, these items return 
//	   OATRUE or OAFALSE.  All return values are in pdwValue unless otherwise specified:

#define ED_DEVCAP_CAN_RECORD			ED_BASE+1L
#define ED_DEVCAP_CAN_RECORD_STROBE		ED_BASE+2L	// for multitrack devices: 
													// switches currently recording tracks off 
													// and selected non-recording tracks into record
#define ED_DEVCAP_HAS_AUDIO			ED_BASE+3L
#define ED_DEVCAP_HAS_VIDEO			ED_BASE+4L
#define ED_DEVCAP_USES_FILES		ED_BASE+5L
#define ED_DEVCAP_CAN_SAVE			ED_BASE+6L

#define ED_DEVCAP_DEVICE_TYPE		ED_BASE+7L	// returns one of the following:
#define ED_DEVTYPE_VCR				ED_BASE+8L
#define ED_DEVTYPE_LASERDISK		ED_BASE+9L
#define ED_DEVTYPE_ATR 				ED_BASE+10L
#define ED_DEVTYPE_DDR				ED_BASE+11L
#define ED_DEVTYPE_ROUTER 			ED_BASE+12L
#define ED_DEVTYPE_KEYER 			ED_BASE+13L
#define ED_DEVTYPE_MIXER_VIDEO 		ED_BASE+14L
#define ED_DEVTYPE_DVE 				ED_BASE+15L
#define ED_DEVTYPE_WIPEGEN 			ED_BASE+16L
#define ED_DEVTYPE_MIXER_AUDIO 		ED_BASE+17L
#define ED_DEVTYPE_CG 				ED_BASE+18L
#define ED_DEVTYPE_TBC 				ED_BASE+19L
#define ED_DEVTYPE_TCG 				ED_BASE+20L
#define ED_DEVTYPE_GPI 				ED_BASE+21L
#define ED_DEVTYPE_JOYSTICK 		ED_BASE+22L
#define ED_DEVTYPE_KEYBOARD			ED_BASE+23L

// returns mfr-specific ID from external device.
#define ED_DEVCAP_EXTERNAL_DEVICE_ID	ED_BASE+24L

#define ED_DEVCAP_TIMECODE_READ		ED_BASE+25L
#define ED_DEVCAP_TIMECODE_WRITE	ED_BASE+26L
//	used for seekable non-timecode enabled devices
#define ED_DEVCAP_CTLTRK_READ		ED_BASE+27L
//	used for seekable non-timecode enabled devices
#define ED_DEVCAP_INDEX_READ		ED_BASE+28L

// returns device preroll time in current time format
#define ED_DEVCAP_PREROLL			ED_BASE+29L
// returns device postroll time in current time format
#define ED_DEVCAP_POSTROLL			ED_BASE+30L

// returns indication of devices synchronization accuracy.
#define ED_DEVCAP_SYNC_ACCURACY		ED_BASE+31L	// returns one of the following:
#define ED_SYNCACC_PRECISE			ED_BASE+32L
#define ED_SYNCACC_FRAME			ED_BASE+33L
#define ED_SYNCACC_ROUGH			ED_BASE+34L

// returns devices normal framerate.
#define ED_DEVCAP_NORMAL_RATE	ED_BASE+35L	// returns one of the following:
#define ED_RATE_24				ED_BASE+36L
#define ED_RATE_25				ED_BASE+37L
#define ED_RATE_2997			ED_BASE+38L
#define ED_RATE_30				ED_BASE+39L

#define ED_DEVCAP_CAN_PREVIEW	ED_BASE+40L
#define ED_DEVCAP_CAN_MONITOR_SOURCES	ED_BASE+41L

// indicates implementation allows testing of methods/parameters by
// setting the hi bit of a parm that makes sense - see individual methods
// for details.
#define ED_DEVCAP_CAN_TEST			ED_BASE+42L
	
// indicates device accepts video as an input.
#define ED_DEVCAP_VIDEO_INPUTS		ED_BASE+43L

// indicates device accepts audio as an input.
#define ED_DEVCAP_AUDIO_INPUTS		ED_BASE+44L

#define ED_DEVCAP_NEEDS_CALIBRATING	ED_BASE+45L

#define ED_DEVCAP_SEEK_TYPE			ED_BASE+46L	// returns one of the following:
#define ED_SEEK_PERFECT				ED_BASE+47L	// indicates device can execute seek 
												// within 1 video frames without signal 
												//	break (like a DDR)
#define ED_SEEK_FAST				ED_BASE+48L	// indicates device can move pretty quick 
												//  with short break in signal
#define ED_SEEK_SLOW				ED_BASE+49L	// seeks like a tape transport

#define ED_POWER_ON					ED_BASE+50L
#define ED_POWER_OFF				ED_BASE+51L
#define ED_POWER_STANDBY			ED_BASE+52L

#define ED_ACTIVE					ED_BASE+53L
#define ED_INACTIVE 				ED_BASE+54L
#define ED_ALL						ED_BASE+55L
#define ED_TEST						ED_BASE+56L

//	IAMExtTransport Capability Items:  unless otherwise specified, these items return 
//	   OATRUE or OAFALSE.  All return values are in pdwValue unless otherwise specified:

#define ED_TRANSCAP_CAN_EJECT			ED_BASE+100L
#define ED_TRANSCAP_CAN_BUMP_PLAY		ED_BASE+101L	// variable speed for synchronizing
#define ED_TRANSCAP_CAN_PLAY_BACKWARDS	ED_BASE+102L	// servo locked for use during an edit
#define ED_TRANSCAP_CAN_SET_EE			ED_BASE+103L	// show devices input on its output
#define ED_TRANSCAP_CAN_SET_PB			ED_BASE+104L	// show media playback on devices output
#define ED_TRANSCAP_CAN_DELAY_VIDEO_IN	ED_BASE+105L	// transport can do delayed-in video edits
#define ED_TRANSCAP_CAN_DELAY_VIDEO_OUT	ED_BASE+106L	// transport can do delayed-out video edits
#define ED_TRANSCAP_CAN_DELAY_AUDIO_IN	ED_BASE+107L	// transport can do delayed-in audio edits
#define ED_TRANSCAP_CAN_DELAY_AUDIO_OUT	ED_BASE+108L	// transport can do delayed-out audio edits
#define ED_TRANSCAP_FWD_VARIABLE_MAX	ED_BASE+109L	// max forward speed (multiple of play speed) 
														//  in pdblValue
#define ED_TRANSCAP_FWD_VARIABLE_MIN	ED_BASE+800L	// min forward speed (multiple of play speed) 
														//  in pdblValue
#define ED_TRANSCAP_REV_VARIABLE_MAX	ED_BASE+110L	// max reverse speed (multiple of play speed) in
														//  pdblValue
#define ED_TRANSCAP_REV_VARIABLE_MIN	ED_BASE+801L	// min reverse speed (multiple of play speed)
														//  in pdblValue
#define ED_TRANSCAP_FWD_SHUTTLE_MAX		ED_BASE+802L	// max forward speed in Shuttle mode (multiple
														//  of play speed) in pdblValue
#define ED_TRANSCAP_FWD_SHUTTLE_MIN		ED_BASE+803L	// min forward speed in Shuttle mode (multiple
														//  of play speed) in pdblValue
#define ED_TRANSCAP_REV_SHUTTLE_MAX		ED_BASE+804L	// max reverse speed in Shuttle mode (multiple
														//  of play speed) in pdblValue
#define ED_TRANSCAP_REV_SHUTTLE_MIN		ED_BASE+805L	// min reverse speed in Shuttle mode (multiple
														//  of play speed) in pdblValue
#define ED_TRANSCAP_NUM_AUDIO_TRACKS	ED_BASE+111L	// returns number of audio tracks
#define ED_TRANSCAP_LTC_TRACK			ED_BASE+112L	// returns track number of LTC timecode track.
														//  ED_ALL means no dedicated timecode track
#define ED_TRANSCAP_NEEDS_TBC			ED_BASE+113L	// devices output not stable
#define ED_TRANSCAP_NEEDS_CUEING		ED_BASE+114L	// device must be cued prior to performing edit
#define ED_TRANSCAP_CAN_INSERT			ED_BASE+115L
#define ED_TRANSCAP_CAN_ASSEMBLE		ED_BASE+116L
#define ED_TRANSCAP_FIELD_STEP			ED_BASE+117L	// device responds to Frame Advance command by 
														//  advancing one field
#define ED_TRANSCAP_CLOCK_INC_RATE		ED_BASE+118L	// VISCA command - keep for compatibility
#define ED_TRANSCAP_CAN_DETECT_LENGTH	ED_BASE+119L
#define ED_TRANSCAP_CAN_FREEZE			ED_BASE+120L
#define ED_TRANSCAP_HAS_TUNER			ED_BASE+121L
#define ED_TRANSCAP_HAS_TIMER			ED_BASE+122L
#define ED_TRANSCAP_HAS_CLOCK			ED_BASE+123L
#define ED_TRANSCAP_MULTIPLE_EDITS		ED_BASE+806L	// OATRUE means device/filter can support
														//  multiple edit events
#define ED_TRANSCAP_IS_MASTER			ED_BASE+807L	// OATRUE means device is the master clock
														//  for synchronizing (this sets timecode-to-
														//  reference clock offset for editing)
#define ED_TRANSCAP_HAS_DT				ED_BASE+814L	// OATRUE means device has Dynamic Tracking

//	IAMExtTransport Media States
#define ED_MEDIA_SPIN_UP			ED_BASE+130L
#define ED_MEDIA_SPIN_DOWN			ED_BASE+131L
#define ED_MEDIA_UNLOAD				ED_BASE+132L

//	IAMExtTransport Modes
#define	ED_MODE_PLAY				ED_BASE+200L
#define	ED_MODE_STOP				ED_BASE+201L
#define	ED_MODE_FREEZE				ED_BASE+202L	// really "pause"
#define	ED_MODE_THAW				ED_BASE+203L
#define	ED_MODE_FF					ED_BASE+204L
#define	ED_MODE_REW					ED_BASE+205L
#define	ED_MODE_RECORD				ED_BASE+206L
#define	ED_MODE_RECORD_STROBE		ED_BASE+207L
#define ED_MODE_RECORD_FREEZE		ED_BASE+808L	// never "put", only "get"
#define	ED_MODE_STEP				ED_BASE+208L	// same as "jog"
#define	ED_MODE_STEP_FWD			ED_BASE+208L	// same as ED_MODE_STEP
#define	ED_MODE_STEP_REV			ED_BASE+809L
#define	ED_MODE_SHUTTLE				ED_BASE+209L
#define	ED_MODE_EDIT_CUE			ED_BASE+210L
#define ED_MODE_VAR_SPEED			ED_BASE+211L
#define ED_MODE_PERFORM				ED_BASE+212L	// returned status only
#define	ED_MODE_LINK_ON				ED_BASE+280L
#define	ED_MODE_LINK_OFF			ED_BASE+281L
#define ED_MODE_NOTIFY_ENABLE		ED_BASE+810L
#define ED_MODE_NOTIFY_DISABLE		ED_BASE+811L
#define ED_MODE_SHOT_SEARCH			ED_BASE+812L

//	IAMTimecodeReader/Generator/Display defines
//
// Timecode Generator Mode params and values:
//
#define ED_TCG_TIMECODE_TYPE		ED_BASE+400L	// can be one of the following:
#define ED_TCG_SMPTE_LTC			ED_BASE+401L
#define ED_TCG_SMPTE_VITC			ED_BASE+402L
#define ED_TCG_MIDI_QF				ED_BASE+403L
#define ED_TCG_MIDI_FULL			ED_BASE+404L

#define ED_TCG_FRAMERATE			ED_BASE+405L	// can be one of the following:
#define ED_FORMAT_SMPTE_30			ED_BASE+406L
#define ED_FORMAT_SMPTE_30DROP		ED_BASE+407L
#define ED_FORMAT_SMPTE_25			ED_BASE+408L
#define ED_FORMAT_SMPTE_24			ED_BASE+409L

#define ED_TCG_SYNC_SOURCE			ED_BASE+410L	// can be one of the following:
#define ED_TCG_VIDEO				ED_BASE+411L
#define ED_TCG_READER				ED_BASE+412L
#define ED_TCG_FREE					ED_BASE+413L

#define ED_TCG_REFERENCE_SOURCE		ED_BASE+414L	// can have one these values:
													//	ED_TCG_FREE || ED_TCG_READER 
													//	(for regen/jamsync)

// TimeCodeReader Mode params and values:
#define ED_TCR_SOURCE			ED_BASE+416L	// can be one of the following:
// ED_TCG (already defined)
#define ED_TCR_LTC				ED_BASE+417L
#define ED_TCR_VITC				ED_BASE+418L
#define ED_TCR_CT				ED_BASE+419L	// Control Track
#define ED_TCR_FTC				ED_BASE+420L	// File TimeCode - for file-based devices
												//  that wish they were transports
// ED_MODE_NOTIFY_ENABLE can be OATRUE or OAFALSE (defined in transport mode
//  section of this file).  
#define ED_TCR_LAST_VALUE		ED_BASE+421L	// for notification mode - 
												//  successive calls to GetTimecode
												//  return the last read value
// TimeCode Display Mode params and values:
//
#define ED_TCD_SOURCE			ED_BASE+422L	// can be one of the following:
#define ED_TCR					ED_BASE+423L
#define ED_TCG					ED_BASE+424L

#define ED_TCD_SIZE				ED_BASE+425L	// can be one of the following:
#define ED_SMALL				ED_BASE+426L
#define ED_MED					ED_BASE+427L
#define ED_LARGE				ED_BASE+428L

#define ED_TCD_POSITION			ED_BASE+429L	// can be one of the following:
#define ED_TOP					0x0001
#define ED_MIDDLE				0x0002
#define ED_BOTTOM				0x0004			// ord  with
#define ED_LEFT					0x0100
#define ED_CENTER				0x0200
#define ED_RIGHT				0x0400

#define ED_TCD_INTENSITY		ED_BASE+436L	// can be one of the following:
#define ED_HIGH					ED_BASE+437L
#define ED_LOW					ED_BASE+438L

#define ED_TCD_TRANSPARENCY		ED_BASE+439L	// 0-4, 0 is opaque

#define ED_TCD_INVERT			ED_BASE+440L	// OATRUE=black on white
												// OAFALSE=white on black
//	IAMExtTransport defines
//
// Transport status, params and values
//

// IAMExtTransport Status items and and values:
#define ED_MODE					ED_BASE+500L	// see ED_MODE_xxx values above
#define	ED_ERROR				ED_BASE+501L
#define	ED_LOCAL				ED_BASE+502L
#define	ED_RECORD_INHIBIT		ED_BASE+503L
#define	ED_SERVO_LOCK			ED_BASE+504L
#define	ED_MEDIA_PRESENT		ED_BASE+505L
#define	ED_MEDIA_LENGTH			ED_BASE+506L
#define	ED_MEDIA_SIZE			ED_BASE+507L
#define	ED_MEDIA_TRACK_COUNT	ED_BASE+508L
#define	ED_MEDIA_TRACK_LENGTH	ED_BASE+509L
#define	ED_MEDIA_SIDE			ED_BASE+510L

#define	ED_MEDIA_TYPE			ED_BASE+511L	// can be one of the following:
#define	ED_MEDIA_VHS			ED_BASE+512L
#define	ED_MEDIA_SVHS			ED_BASE+513L
#define	ED_MEDIA_HI8			ED_BASE+514L
#define	ED_MEDIA_UMATIC			ED_BASE+515L
#define	ED_MEDIA_DVC			ED_BASE+516L
#define	ED_MEDIA_1_INCH			ED_BASE+517L
#define	ED_MEDIA_D1				ED_BASE+518L
#define	ED_MEDIA_D2				ED_BASE+519L
#define	ED_MEDIA_D3				ED_BASE+520L
#define	ED_MEDIA_D5				ED_BASE+521L
#define	ED_MEDIA_DBETA			ED_BASE+522L
#define	ED_MEDIA_BETA			ED_BASE+523L
#define	ED_MEDIA_8MM			ED_BASE+524L
#define	ED_MEDIA_DDR			ED_BASE+525L
#define	ED_MEDIA_SX				ED_BASE+813L
#define	ED_MEDIA_OTHER			ED_BASE+526L
#define	ED_MEDIA_CLV			ED_BASE+527L
#define	ED_MEDIA_CAV			ED_BASE+528L
#define ED_MEDIA_POSITION		ED_BASE+529L

#define ED_LINK_MODE			ED_BASE+530L	// OATRUE if transport controls
							 					// are linked to graph's RUN, 
							 					// STOP, and PAUSE methods

// IAMExtTransport Basic Parms
#define	ED_TRANSBASIC_TIME_FORMAT	ED_BASE+540L	// can be one of the following:
#define	ED_FORMAT_MILLISECONDS		ED_BASE+541L
#define	ED_FORMAT_FRAMES			ED_BASE+542L
#define ED_FORMAT_REFERENCE_TIME	ED_BASE+543L

#define	ED_FORMAT_HMSF				ED_BASE+547L
#define	ED_FORMAT_TMSF				ED_BASE+548L

#define	ED_TRANSBASIC_TIME_REFERENCE	ED_BASE+549L	// can be one of the following:
#define	ED_TIMEREF_TIMECODE			ED_BASE+550L
#define	ED_TIMEREF_CONTROL_TRACK	ED_BASE+551L
#define	ED_TIMEREF_INDEX			ED_BASE+552L

#define	ED_TRANSBASIC_SUPERIMPOSE		ED_BASE+553L	// enable/disable onscreen display
#define	ED_TRANSBASIC_END_STOP_ACTION	ED_BASE+554L	// can be one of: ED_MODE_STOP |
														//	ED_MODE_REWIND | ED_MODE_FREEZE
#define	ED_TRANSBASIC_RECORD_FORMAT	ED_BASE+555L	// can be one of the following:
#define	ED_RECORD_FORMAT_SP			ED_BASE+556L
#define	ED_RECORD_FORMAT_LP			ED_BASE+557L
#define	ED_RECORD_FORMAT_EP			ED_BASE+558L

#define	ED_TRANSBASIC_STEP_COUNT	ED_BASE+559L
#define	ED_TRANSBASIC_STEP_UNIT		ED_BASE+560L	// can be one of the following:
#define	ED_STEP_FIELD				ED_BASE+561L
#define	ED_STEP_FRAME				ED_BASE+562L
#define	ED_STEP_3_2					ED_BASE+563L

#define	ED_TRANSBASIC_PREROLL		ED_BASE+564L
#define	ED_TRANSBASIC_RECPREROLL	ED_BASE+565L
#define	ED_TRANSBASIC_POSTROLL		ED_BASE+566L
#define	ED_TRANSBASIC_EDIT_DELAY	ED_BASE+567L
#define	ED_TRANSBASIC_PLAYTC_DELAY	ED_BASE+568L
#define	ED_TRANSBASIC_RECTC_DELAY	ED_BASE+569L
#define ED_TRANSBASIC_EDIT_FIELD	ED_BASE+570L
#define	ED_TRANSBASIC_FRAME_SERVO	ED_BASE+571L
#define	ED_TRANSBASIC_CF_SERVO		ED_BASE+572L
#define	ED_TRANSBASIC_SERVO_REF		ED_BASE+573L	// can be one of the following:
#define	ED_REF_EXTERNAL				ED_BASE+574L
#define	ED_REF_INPUT				ED_BASE+575L
#define	ED_REF_INTERNAL				ED_BASE+576L
#define	ED_REF_AUTO					ED_BASE+577L

#define	ED_TRANSBASIC_WARN_GL		ED_BASE+578L
#define	ED_TRANSBASIC_SET_TRACKING	ED_BASE+579L	// can be one of the following:
#define	ED_TRACKING_PLUS			ED_BASE+580L
#define	ED_TRACKING_MINUS			ED_BASE+581L
#define	ED_TRACKING_RESET			ED_BASE+582L

#define	ED_TRANSBASIC_SET_FREEZE_TIMEOUT	ED_BASE+583L
#define	ED_TRANSBASIC_VOLUME_NAME		ED_BASE+584L
#define	ED_TRANSBASIC_BALLISTIC_1		ED_BASE+585L	// space for proprietary data
#define	ED_TRANSBASIC_BALLISTIC_2		ED_BASE+586L
#define	ED_TRANSBASIC_BALLISTIC_3		ED_BASE+587L
#define	ED_TRANSBASIC_BALLISTIC_4		ED_BASE+588L
#define	ED_TRANSBASIC_BALLISTIC_5		ED_BASE+589L
#define	ED_TRANSBASIC_BALLISTIC_6		ED_BASE+590L
#define	ED_TRANSBASIC_BALLISTIC_7		ED_BASE+591L
#define	ED_TRANSBASIC_BALLISTIC_8		ED_BASE+592L
#define	ED_TRANSBASIC_BALLISTIC_9		ED_BASE+593L
#define	ED_TRANSBASIC_BALLISTIC_10		ED_BASE+594L
#define	ED_TRANSBASIC_BALLISTIC_11		ED_BASE+595L
#define	ED_TRANSBASIC_BALLISTIC_12		ED_BASE+596L
#define	ED_TRANSBASIC_BALLISTIC_13		ED_BASE+597L
#define	ED_TRANSBASIC_BALLISTIC_14		ED_BASE+598L
#define	ED_TRANSBASIC_BALLISTIC_15		ED_BASE+599L
#define	ED_TRANSBASIC_BALLISTIC_16		ED_BASE+600L
#define	ED_TRANSBASIC_BALLISTIC_17		ED_BASE+601L
#define	ED_TRANSBASIC_BALLISTIC_18		ED_BASE+602L
#define	ED_TRANSBASIC_BALLISTIC_19		ED_BASE+603L
#define	ED_TRANSBASIC_BALLISTIC_20		ED_BASE+604L

// consumer VCR items
#define	ED_TRANSBASIC_SETCLOCK			ED_BASE+605L
#define	ED_TRANSBASIC_SET_COUNTER_FORMAT	ED_BASE+606L	// uses time format flags
#define	ED_TRANSBASIC_SET_COUNTER_VALUE	ED_BASE+607L

#define	ED_TRANSBASIC_SETTUNER_CH_UP	ED_BASE+608L
#define	ED_TRANSBASIC_SETTUNER_CH_DN	ED_BASE+609L
#define	ED_TRANSBASIC_SETTUNER_SK_UP	ED_BASE+610L
#define	ED_TRANSBASIC_SETTUNER_SK_DN	ED_BASE+611L
#define	ED_TRANSBASIC_SETTUNER_CH		ED_BASE+612L
#define	ED_TRANSBASIC_SETTUNER_NUM		ED_BASE+613L

#define	ED_TRANSBASIC_SETTIMER_EVENT	ED_BASE+614L
#define	ED_TRANSBASIC_SETTIMER_STARTDAY	ED_BASE+615L
#define	ED_TRANSBASIC_SETTIMER_STARTTIME	ED_BASE+616L
#define	ED_TRANSBASIC_SETTIMER_STOPDAY	ED_BASE+617L
#define	ED_TRANSBASIC_SETTIMER_STOPTIME	ED_BASE+618L

// IAMExtTransport video parameters
#define	ED_TRANSVIDEO_SET_OUTPUT	ED_BASE+630L	// can be one of the following:
#define	ED_E2E						ED_BASE+631L
#define	ED_PLAYBACK					ED_BASE+632L
#define	ED_OFF						ED_BASE+633L

#define	ED_TRANSVIDEO_SET_SOURCE	ED_BASE+634L

// IAMExtTransport audio parameters
#define	ED_TRANSAUDIO_ENABLE_OUTPUT	ED_BASE+640L	// can be the following:
#define	ED_AUDIO_ALL				0x10000000	//	or any of the following OR'd together
#define ED_AUDIO_1					0x0000001L
#define ED_AUDIO_2					0x0000002L
#define ED_AUDIO_3					0x0000004L
#define ED_AUDIO_4					0x0000008L
#define ED_AUDIO_5					0x0000010L
#define ED_AUDIO_6					0x0000020L
#define ED_AUDIO_7					0x0000040L
#define ED_AUDIO_8					0x0000080L
#define ED_AUDIO_9					0x0000100L
#define ED_AUDIO_10					0x0000200L
#define ED_AUDIO_11					0x0000400L
#define ED_AUDIO_12					0x0000800L
#define ED_AUDIO_13					0x0001000L
#define ED_AUDIO_14					0x0002000L
#define ED_AUDIO_15					0x0004000L
#define ED_AUDIO_16					0x0008000L
#define ED_AUDIO_17					0x0010000L
#define ED_AUDIO_18					0x0020000L
#define ED_AUDIO_19					0x0040000L
#define ED_AUDIO_20					0x0080000L
#define ED_AUDIO_21					0x0100000L
#define ED_AUDIO_22					0x0200000L
#define ED_AUDIO_23					0x0400000L
#define ED_AUDIO_24					0x0800000L
#define ED_VIDEO					0x2000000L	// for Edit props below

#define	ED_TRANSAUDIO_ENABLE_RECORD		ED_BASE+642L
#define	ED_TRANSAUDIO_ENABLE_SELSYNC	ED_BASE+643L
#define	ED_TRANSAUDIO_SET_SOURCE		ED_BASE+644L
#define	ED_TRANSAUDIO_SET_MONITOR		ED_BASE+645L


// Edit Property Set-related defs

// The following values reflect (and control) the state of an 
// edit property set
#define ED_INVALID		ED_BASE+652L
#define ED_EXECUTING	ED_BASE+653L
#define ED_REGISTER		ED_BASE+654L
#define ED_DELETE		ED_BASE+655L

// Edit property set parameters and values
#define ED_EDIT_HEVENT	ED_BASE+656L	// event handle to signal event 
										// completion
#define ED_EDIT_TEST	ED_BASE+657L	// returns OAFALSE if filter thinks
										//  edit can be done, OATRUE if not
#define ED_EDIT_IMMEDIATE	ED_BASE+658L	// OATRUE means start put the 
										// device into edit mode (editing
										// "on the fly") immediately upon
										//  execution of Mode(ED_MODE_EDIT_CUE)
#define ED_EDIT_MODE	ED_BASE+659L
// can be one of the following values:
#define ED_EDIT_MODE_ASSEMBLE		ED_BASE+660L
#define ED_EDIT_MODE_INSERT			ED_BASE+661L
#define ED_EDIT_MODE_CRASH_RECORD	ED_BASE+662L
#define ED_EDIT_MODE_BOOKMARK_TIME	ED_BASE+663L		// these two are for
#define ED_EDIT_MODE_BOOKMARK_CHAPTER	ED_BASE+664L	// laserdisks

#define ED_EDIT_MASTER	ED_BASE+666L	// OATRUE causes device 
										//  not to synchronize

#define ED_EDIT_TRACK		ED_BASE+667L
// can be one of the following possible OR'd values:
//	ED_VIDEO, ED_AUDIO_1 thru ED_AUDIO_24 (or ED_AUDIO_ALL)

#define ED_EDIT_SRC_INPOINT		ED_BASE+668L	// in current time format
#define ED_EDIT_SRC_OUTPOINT	ED_BASE+669L	// in current time format
#define ED_EDIT_REC_INPOINT		ED_BASE+670L	// in current time format
#define ED_EDIT_REC_OUTPOINT	ED_BASE+671L	// in current time format

#define ED_EDIT_REHEARSE_MODE	ED_BASE+672L
// can be one of the following possible values:
#define ED_EDIT_BVB		ED_BASE+673L	// means rehearse the edit with 
										//  "black-video-black"
#define ED_EDIT_VBV		ED_BASE+674L
#define ED_EDIT_VVV		ED_BASE+675L
#define ED_EDIT_PERFORM	ED_BASE+676L	// means perform the edit with no 
										//  rehearsal.

// Set this property to OATRUE to kill the edit if in progress
#define ED_EDIT_ABORT	ED_BASE+677L
// how long to wait for edit to complete
#define ED_EDIT_TIMEOUT	ED_BASE+678L		// in current time format

// This property causes the device to seek to a point specified by
// ED_EDIT_SEEK_MODE (see below).  NOTE: Only one event at a time can seek.
#define ED_EDIT_SEEK		ED_BASE+679L	// OATRUE means do it now.  
#define ED_EDIT_SEEK_MODE	ED_BASE+680L
//possible values:
#define ED_EDIT_SEEK_EDIT_IN	ED_BASE+681L	// seek to edit's inpoint
#define ED_EDIT_SEEK_EDIT_OUT	ED_BASE+682L	// seek to edit's outpoint
#define ED_EDIT_SEEK_PREROLL	ED_BASE+683L	// seek to edit's 
												//  inpoint-preroll
#define ED_EDIT_SEEK_PREROLL_CT	ED_BASE+684L	// seek to preroll point 
							// using control track (used for tapes with 
							// discontinuoustimecode before edit point: seek
							// to inpoint using timecode, then backup to 
							// preroll point using control track)
#define ED_EDIT_SEEK_BOOKMARK	ED_BASE+685L	// seek to bookmark (just like 
												//  timecode search)
// This property is used for multiple-VCR systems where each machine must
//  cue to a different location relative to the graph's reference clock.  The
//  basic idea is that an edit event is setup with an ED_EDIT_OFFSET property
//  that tells the VCR what offset to maintain between it's timecode (converted
//	to reference clock units) and the reference clock.
#define ED_EDIT_OFFSET	ED_BASE+686L		// in current time format

#define ED_EDIT_PREREAD	ED_BASE+815L		// OATRUE means device supports
											//  pre-read (recorder can also be
											//  player

//
// Some error codes:
// 
// device could be in local mode
#define ED_ERR_DEVICE_NOT_READY		ED_BASE+700L

#endif // __EDEVDEFS__

// eof edevdefs.h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\edkmapi.h ===
// --edkmapi.h------------------------------------------------------------------
// 
//  Header file for module containing MAPI utility functions.
// 
// Copyright 1986 - 1998 Microsoft Corporation.  All Rights Reserved.
// -----------------------------------------------------------------------------
#ifndef _EDKMAPI_H
#define _EDKMAPI_H

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

// Flags for HrMAPIOpenCachedProp().
#define EDK_CACHE_READ  0x00000001L
#define EDK_CACHE_WRITE 0x00000002L

#define MODRECIP_EMPTY  (MODRECIP_ADD|MODRECIP_REMOVE)

/* Values of PR_NDR_REASON_CODE */

#define MAPI_REASON(_code)	((LONG) _code)

#define MAPI_REASON_TRANSFER_FAILED           MAPI_REASON( 0 )
#define MAPI_REASON_TRANSFER_IMPOSSIBLE       MAPI_REASON( 1 )
#define MAPI_REASON_CONVERSION_NOT_PERFORMED  MAPI_REASON( 2 )
#define MAPI_REASON_PHYSICAL_RENDITN_NOT_DONE MAPI_REASON( 3 )
#define MAPI_REASON_PHYSICAL_DELIV_NOT_DONE   MAPI_REASON( 4 )
#define MAPI_REASON_RESTRICTED_DELIVERY       MAPI_REASON( 5 )
#define MAPI_REASON_DIRECTORY_OPERATN_FAILED  MAPI_REASON( 6 )

#define CbSPropValue(_centries) \
	((_centries)*sizeof(SPropValue))

#define CbNewADRENTRY(_centries) \
	(offsetof(ADRENTRY,rgPropVals) + (_centries)*sizeof(LPSPropValue))
#define CbADRENTRY(_lpadrentry) \
	(offsetof(ADRENTRY,rgPropVals) + (UINT)(_lpadrentry)->cValues*sizeof(LPSPropValue))

#define VALID_RECIP_TYPE(ulRecipType) \
    (((ulRecipType & (~MAPI_SUBMITTED)) == MAPI_ORIG) ||            \
                ((ulRecipType & (~MAPI_SUBMITTED)) == MAPI_TO) ||   \
                ((ulRecipType & (~MAPI_SUBMITTED)) == MAPI_CC) ||   \
                ((ulRecipType & (~MAPI_SUBMITTED)) == MAPI_BCC))

#define VALID_RELOP_T(x)  \
    (((((ULONG)(x)) >= 0) && (((ULONG)(x)) < ((ULONG)RELOP_RE))) ? TRUE : FALSE)

#define VALID_ATTACH_METHOD(x)  \
    (((((ULONG)(x)) >= ((ULONG)NO_ATTACHMENT)) && \
    (((ULONG)(x)) < ((ULONG)ATTACH_OLE))) ? TRUE : FALSE)

//$--MSG_T----------------------------------------------------------------------
//  Type of message.
// -----------------------------------------------------------------------------
typedef enum _msg
{
    MSG_ENVELOPE = 0,                   // message envelope
    MSG_CONTENT,                        // message contents
    MSG_LAST                            // all values are less than this
} MSG_T;

#define VALID_MSG_T(x)  \
    (((((ULONG)(x)) >= 0) && (((ULONG)(x)) < ((ULONG)MSG_LAST))) ? TRUE : FALSE)

//$--MD_ACTION_T----------------------------------------------------------------
//  Type defining possible actions taken by an MD.
// -----------------------------------------------------------------------------
typedef enum _md_action
{
    MD_AC_EXPANDED = -2,                // Distribution list expanded
    MD_AC_REDIRECTED,                   // Recipient address changed
    MD_AC_RELAYED,                      // Normal action of a relay MTAE
    MD_AC_REROUTED,                     // Previous attempt to route message
    MD_AC_LAST                          // All values are less than this
} MD_ACTION_T;

#define VALID_MD_ACTION(x)  \
    ((((LONG)(x)) >= ((LONG)-2)) && (((LONG)(x)) < ((LONG)MD_AC_LAST)))

#define CbNewTRACEINFO(_centries) \
    (offsetof(TRACEINFO,rgtraceentry) + (_centries)*sizeof(TRACEENTRY))

#define CbTRACEINFO(_lptraceinfo) \
    (offsetof(TRACEINFO,rgtraceentry) + \
    ((_lptraceinfo)->cEntries*sizeof(TRACEENTRY)))

#define CbNewINTTRACEINFO(_centries) \
    (offsetof(INTTRACEINFO,rgIntTraceEntry) + (_centries)*sizeof(INTTRACEENTRY))

#define CbINTTRACEINFO(_lptraceinfo) \
    (offsetof(INTTRACEINFO,rgIntTraceEntry) + \
    ((_lptraceinfo)->cEntries*sizeof(INTTRACEENTRY)))

//******************************************************************************
//
// EDKMAPI.C function prototypes
//
//******************************************************************************

//$--HrMAPIGetFirstSRowSet------------------------------------------------------
//  Gets the first SRowSet from a table
// -----------------------------------------------------------------------------
HRESULT HrMAPIGetFirstSRowSet(           // RETURNS: return code
    IN LPMAPITABLE  lpTable,            // pointer to table address variable
    IN ULONG cRows,                     // count of number of rows in SRowSet
    IN LPSPropTagArray rgPropTags,      // array of property tags
    OUT LPSRowSet FAR *lppRows);        // pointer to address variable for
                                        // SRowSet

//$--HrMAPIGetNextSRowSet-------------------------------------------------------
//  Gets the next SRowSet from a table
// -----------------------------------------------------------------------------
HRESULT HrMAPIGetNextSRowSet(            // RETURNS: return code
    IN LPMAPITABLE lpTable,             // pointer to table
    IN ULONG cRows,                     // count of number of rows in SRowSet
    IN LPSPropTagArray rgPropTags,      // array of property tags
    OUT LPSRowSet FAR *lppRows);        // pointer to address variable for
                                        // SRowSet

//$--HrMAPICreateEntryList------------------------------------------------------
//  Creates an ENTRYLIST. 
// -----------------------------------------------------------------------------
HRESULT HrMAPICreateEntryList(           // RETURNS: return code
    IN ULONG cbeid,                     // count of bytes in Entry ID
    IN LPENTRYID lpeid,                 // pointer to Entry ID
    OUT LPENTRYLIST FAR *lppEntryList); // pointer to address variable of Entry
                                        // list

//$--HrMAPIAppendEntryList------------------------------------------------------
//  Appends to an ENTRYLIST.
// -----------------------------------------------------------------------------
HRESULT HrMAPIAppendEntryList(           // RETURNS: return code
    IN ULONG cbeid,                     // count of bytes in Entry ID
    IN LPENTRYID lpeid,                 // pointer to Entry ID
    OUT LPENTRYLIST FAR lpEntryList);   // pointer to address variable of Entry
                                        // list

//$--HrMAPIDestroyEntryList-----------------------------------------------------
//  Frees an ENTRYLIST. 
// -----------------------------------------------------------------------------
HRESULT HrMAPIDestroyEntryList(               // RETURNS: return code
    IN OUT LPENTRYLIST FAR *lppEntryList);// pointer to address variable of Entry
                                          // list

//$--HrMAPIWriteStreamToFile----------------------------------------------------
//  Write stream to a file given a file handle.
// -----------------------------------------------------------------------------
HRESULT HrMAPIWriteStreamToFile(        // RETURNS: return code
    IN LPSTREAM lpStream,               // Pointer to stream
    OUT HANDLE hFile);                  // Handle to file

//$--HrMAPIWriteFileToStream----------------------------------------------------
//  Write file to a stream given a stream pointer.
// -----------------------------------------------------------------------------
HRESULT HrMAPIWriteFileToStream(        // RETURNS: return code
    IN HANDLE hFile,                    // Handle to file
    OUT LPSTREAM lpStream);             // Pointer to stream

//$--HrMAPIWriteAttachmentToFile------------------------------------------------
//  Write the identified message attachment to a file.
// -----------------------------------------------------------------------------
HRESULT HrMAPIWriteAttachmentToFile(   // RETURNS: return code
    IN LPMESSAGE pMessage,              // Message containing the attachments
    IN ULONG iAttach,                   // Attachment identifier
    OUT HANDLE  hFile);                 // Handle to file

//$--HrMAPIGotoSRow-------------------------------------------------------------
//  Goto the specified SRow in an SRowSet.
//------------------------------------------------------------------------------
HRESULT HrMAPIGotoSRow(                  // RETURNS: return code
    IN LPSRowSet FAR lpRows,            // pointer to SRowSet
    IN ULONG ulRow,                     // index of SRow in SRowSet
    OUT LPSRow *lppRow);                // pointer to SRow

//$--HrMAPIGotoFirstSRow--------------------------------------------------------
//  Goto the first SRow in an SRowSet.
//------------------------------------------------------------------------------
HRESULT HrMAPIGotoFirstSRow(             // RETURNS: return code
    IN LPSRowSet FAR lpRows,            // pointer to SRowSet
    OUT ULONG *lpulRow,                 // index of SRow in SRowSet
    OUT LPSRow *lppRow);                // pointer to SRow

//$--HrMAPIGotoNextSRow---------------------------------------------------------
//  Goto the next SRow in an SRowSet.
//------------------------------------------------------------------------------
HRESULT HrMAPIGotoNextSRow(              // RETURNS: return code
    IN LPSRowSet FAR lpRows,            // pointer to SRowSet
    IN OUT ULONG *lpulRow,              // index of SRow in SRowSet
    OUT LPSRow *lppRow);                // pointer to SRow

//$--HrMAPIWriteStreamToMemory--------------------------------------------------
//  Reads a given number of bytes from a stream to a block of memory.
// -----------------------------------------------------------------------------
HRESULT HrMAPIWriteStreamToMemory(        // RETURNS: return code
    IN LPSTREAM lpStream,               // pointer to stream
    IN ULONG cBytes,                    // count of bytes in memory
    IN LPBYTE lpbBytes,                 // pointer to memory
    OUT ULONG *lpcBytesRead);           // count of bytes read from stream

//$--HrMAPIWriteMemoryToStream--------------------------------------------------
//  Writes a given number of bytes from a block of memory to a stream
// -----------------------------------------------------------------------------
HRESULT HrMAPIWriteMemoryToStream(       // RETURNS: return code
    IN LPSTREAM lpStream,               // pointer to stream
    IN ULONG cBytes,                    // count of bytes in memory
    IN LPBYTE lpbBytes,                 // pointer to memory
    OUT ULONG *lpcBytesWritten);        // count of bytes written from stream

//$--HrMAPISetStreamSize--------------------------------------------------------
//  Sets the size of the given stream.
// -----------------------------------------------------------------------------
HRESULT HrMAPISetStreamSize(             // RETURNS: return code
    IN LPSTREAM lpStream,               // pointer to stream
    IN ULONG cBytes);                   // count of bytes in stream

//******************************************************************************
//
// IADDRESS.C function prototypes
//
//******************************************************************************

//$--HrMAPICreateAddressList----------------------------------------------------
//  Create an address list.
// -----------------------------------------------------------------------------
HRESULT HrMAPICreateAddressList(             // RETURNS: return code
    IN ULONG cProps,                        // count of values in address list
                                            // entry
    IN LPSPropValue lpPropValues,           // pointer to address list entry
    OUT LPADRLIST *lppAdrList);             // pointer to address list pointer

//$--HrMAPIAppendAddressList----------------------------------------------------
//  Append to an address list.
// -----------------------------------------------------------------------------
HRESULT HrMAPIAppendAddressList(             // RETURNS: return code
    IN ULONG cProps,                        // count of values in address list
                                            // entry
    IN LPSPropValue lpPropValues,           // pointer to address list entry
    IN OUT LPADRLIST *lppAdrList);          // pointer to address list pointer

//$--HrMAPICreateSizedAddressList-----------------------------------------------
//  Create a sized address list.
// -----------------------------------------------------------------------------
HRESULT HrMAPICreateSizedAddressList(        // RETURNS: return code
    IN ULONG cEntries,                      // count of entries in address list
    OUT LPADRLIST *lppAdrList);             // pointer to address list pointer

//$--HrMAPISetAddressList-------------------------------------------------------
//  Set an address list.
// -----------------------------------------------------------------------------
HRESULT HrMAPISetAddressList(                // RETURNS: return code
    IN ULONG iEntry,                        // index of address list entry
    IN ULONG cProps,                        // count of values in address list
                                            // entry
    IN LPSPropValue lpPropValues,           // pointer to address list entry
    IN OUT LPADRLIST lpAdrList);            // pointer to address list pointer

//******************************************************************************
//
// IFOLDER.C function prototypes
//
//******************************************************************************

//$--HrMAPIFindInbox------------------------------------------------------------
//  Find IPM inbox folder.
// -----------------------------------------------------------------------------
HRESULT HrMAPIFindInbox(              // RETURNS: return code
    IN LPMDB lpMdb,                     // pointer to message store
    OUT ULONG *lpcbeid,                 // count of bytes in entry ID
    OUT LPENTRYID *lppeid);             // Entry ID of IPM inbox

//$--HrMAPIFindOutbox-----------------------------------------------------------
//  Find IPM outbox folder.
// -----------------------------------------------------------------------------
HRESULT HrMAPIFindOutbox(             // RETURNS: return code
    IN LPMDB lpMdb,                     // pointer to message store
    OUT ULONG *lpcbeid,                 // count of bytes in entry ID
    OUT LPENTRYID *lppeid);             // Entry ID of IPM outbox

//$--HrMAPIFindIPMSubtree-------------------------------------------------------
//  Find IPM subtree folder.
// -----------------------------------------------------------------------------
HRESULT HrMAPIFindIPMSubtree(            // RETURNS: return code
    IN LPMDB lpMdb,                     // pointer to message store
    OUT ULONG *lpcbeid,                 // count of bytes in entry ID
    OUT LPENTRYID *lppeid);             // entry ID of IPM subtree

//$--HrGWFindMtsOutFolder-------------------------------------------------------
//  Find MTS-OUT folder.
// -----------------------------------------------------------------------------
HRESULT HrGWFindMtsOutFolder(                // RETURNS: return code
    IN LPMDB lpMdb,                     // pointer to message store
    OUT ULONG *lpcbeid,                 // count of bytes in entry ID
    OUT LPENTRYID *lppeid);             // entry ID of MTS-OUT

//$--HrGWFindMtsInFolder--------------------------------------------------------
//  Find MTS-IN folder.
// -----------------------------------------------------------------------------
HRESULT HrGWFindMtsInFolder(                 // RETURNS: return code
    IN LPMDB lpMdb,                     // pointer to message store
    OUT ULONG *lpcbeid,                 // count of bytes in entry ID
    OUT LPENTRYID *lppeid);             // entry ID of MTS-IN

//$--HrFindExchangePublicStore--------------------------------------------------
//  Find public store root folder.
// -----------------------------------------------------------------------------
HRESULT HrFindExchangePublicStore(           // RETURNS: return code
    IN LPMDB lpMdb,                     // pointer to message store
    OUT ULONG *lpcbeid,                 // count of bytes in entry ID
    OUT LPENTRYID *lppeid);             // entry ID of public store

//$--HrMAPIFindFolder@----------------------------------------------------------
//  Find a folder by name.
// -----------------------------------------------------------------------------
HRESULT HrMAPIFindFolderW(         // RETURNS: return code
    IN LPMAPIFOLDER lpFolder,           // pointer to folder
    IN LPCWSTR lpszName,                // name of folder to find
    OUT ULONG *lpcbeid,                 // pointer to count of bytes in entry ID
    OUT LPENTRYID *lppeid);             // pointer to entry ID pointer

HRESULT HrMAPIFindFolderA(         // RETURNS: return code
    IN LPMAPIFOLDER lpFolder,           // pointer to folder
    IN LPCSTR lpszName,                 // name of folder to find
    OUT ULONG *lpcbeid,                 // pointer to count of bytes in entry ID
    OUT LPENTRYID *lppeid);             // pointer to entry ID pointer

#ifdef UNICODE
#define HrMAPIFindFolder   HrMAPIFindFolderW
#else
#define HrMAPIFindFolder   HrMAPIFindFolderA
#endif

//$--HrMAPIFindSubfolderEx@-----------------------------------------------------
//  Find a folder by name.
// -----------------------------------------------------------------------------
HRESULT HrMAPIFindSubfolderExW(
    IN LPMAPIFOLDER lpRootFolder,       // open root folder
    IN WCHAR chSep,                     // folder path separator
    IN LPCWSTR lpszName,                // folder path
    OUT ULONG *lpcbeid,                 // pointer to count of bytes in entry ID
    OUT LPENTRYID *lppeid);             // pointer to entry ID pointer

HRESULT HrMAPIFindSubfolderExA(
    IN LPMAPIFOLDER lpFolder,           // open root folder
    IN CHAR chSep,                      // folder path separator
    IN LPCSTR lpszName,                 // folder path
    OUT ULONG *lpcbeid,                 // pointer to count of bytes in entry ID
    OUT LPENTRYID *lppeid);             // pointer to entry ID pointer

#ifdef UNICODE
#define HrMAPIFindSubfolderEx   HrMAPIFindSubfolderExW
#else
#define HrMAPIFindSubfolderEx   HrMAPIFindSubfolderExA
#endif

//$--HrMAPIFindFolderEx@--------------------------------------------------------
//  Finds an arbitrarily nested folder in the indicated store given its 
//  path name.
//------------------------------------------------------------------------------
HRESULT HrMAPIFindFolderExW(
    IN LPMDB lpMdb,                     // Open message store
    IN WCHAR  chSep,                    // folder path separator character
    IN LPCWSTR lpszFolderPath,          // folder path
    OUT ULONG *lpcbeid,                 // pointer to count of bytes in entry ID
    OUT LPENTRYID *lppeid);             // pointer to entry ID pointer

HRESULT HrMAPIFindFolderExA(
    IN LPMDB lpMdb,                     // Open message store
    IN CHAR  chSep,                     // folder path separator character
    IN LPCSTR lpszFolderPath,           // folder path
    OUT ULONG *lpcbeid,                 // pointer to count of bytes in entry ID
    OUT LPENTRYID *lppeid);             // pointer to entry ID pointer

#ifdef UNICODE
#define HrMAPIFindFolderEx HrMAPIFindFolderExW
#else
#define HrMAPIFindFolderEx HrMAPIFindFolderExA
#endif

//$--HrMAPIOpenFolderEx@--------------------------------------------------------
//  Opens an arbitrarily nested folder in the indicated store given its 
//  path name.
//------------------------------------------------------------------------------
HRESULT HrMAPIOpenFolderExW(
    IN LPMDB lpMdb,                     // Open message store
    IN WCHAR chSep,                     // folder path separator character
    IN LPCWSTR lpszFolderPath,          // folder path
    OUT LPMAPIFOLDER * lppFolder);      // pointer to folder opened

HRESULT HrMAPIOpenFolderExA(
    IN LPMDB lpMdb,                     // Open message store
    IN CHAR chSep,                      // folder path separator character
    IN LPCSTR lpszFolderPath,           // folder path
    OUT LPMAPIFOLDER * lppFolder);      // pointer to folder opened

#ifdef UNICODE
#define HrMAPIOpenFolderEx HrMAPIOpenFolderExW
#else
#define HrMAPIOpenFolderEx HrMAPIOpenFolderExA
#endif

//$--HrMAPIOpenSubfolderEx@-----------------------------------------------------
//  Opens an arbitrarily nested folder in the indicated folder given its 
//  path name.
//------------------------------------------------------------------------------
HRESULT HrMAPIOpenSubfolderExW(
    IN LPMAPIFOLDER lpRootFolder,       // open root folder
    IN WCHAR chSep,                     // folder path separator character
    IN LPCWSTR lpszFolderPath,          // folder path
    OUT LPMAPIFOLDER * lppFolder);      // pointer to folder opened

HRESULT HrMAPIOpenSubfolderExA(
    IN LPMAPIFOLDER lpRootFolder,       // open root folder
    IN CHAR chSep,                      // folder path separator character
    IN LPCSTR lpszFolderPath,           // folder path
    OUT LPMAPIFOLDER * lppFolder);      // pointer to folder opened

#ifdef UNICODE
#define HrMAPIOpenSubfolderEx HrMAPIOpenSubfolderExW
#else
#define HrMAPIOpenSubfolderEx HrMAPIOpenSubfolderExA
#endif

//$--HrOpenExchangePublicFolders------------------------------------------------
//  Opens the root of the public folder hierarchy in the public message store.
//------------------------------------------------------------------------------
HRESULT HrOpenExchangePublicFolders(
    IN LPMDB lpPubStore,
    OUT LPMAPIFOLDER *lppRootFolder);

//******************************************************************************
//
// IMESSAGE.C function prototypes
//
//******************************************************************************

//$--HrMAPIFindMsgByProp--------------------------------------------------------
//  Find the entry ID of a message given a property.
// -----------------------------------------------------------------------------
HRESULT HrMAPIFindMsgByProp(         // RETURNS: return code
    IN LPMAPIFOLDER lpFolder,       // pointer to folder
    IN LPSPropValue lpSPropValue,   // property value
    OUT LPENTRYLIST *lppMsgList);   // list of matching messages

//$--HrMAPIMoveMessage----------------------------------------------------------
//  Move one message from one folder to another.
// -----------------------------------------------------------------------------
HRESULT HrMAPIMoveMessage(            // RETURNS: return code
    IN LPMAPIFOLDER lpSrcFolder,        // pointer to source folder
    IN LPMAPIFOLDER lpDstFolder,        // pointer to destination folder
    IN ULONG cbeid,                     // count of bytes in entry ID
    IN LPENTRYID lpeid);                // pointer to entry ID

//$--HrMAPICopyMessage----------------------------------------------------------
//  Copy one message from one folder to another.
// -----------------------------------------------------------------------------
HRESULT HrMAPICopyMessage(            // RETURNS: return code
    IN LPMAPIFOLDER lpSrcFolder,        // pointer to source folder
    IN LPMAPIFOLDER lpDstFolder,        // pointer to destination folder
    IN ULONG cbeid,                     // count of bytes in entry ID
    IN LPENTRYID lpeid);                // pointer to entry ID

//$--HrMAPIDeleteMessage--------------------------------------------------------
//  Delete one message from one folder to another.
// -----------------------------------------------------------------------------
HRESULT HrMAPIDeleteMessage(          // RETURNS: return code
    IN LPMAPIFOLDER lpFolder,           // pointer to folder
    IN ULONG cbeid,                     // count of bytes in entry ID
    IN LPENTRYID lpeid);                // pointer to entry ID

//******************************************************************************
//
// IPROP.C function prototypes
//
//******************************************************************************

//$--HrMAPIOpenCachedProp-------------------------------------------------------
//
//  DESCRIPTION: Create a new (local) IPropData object in which the original
//  object properties are cached.  The local cached can be created for
//  reading (for use with GetProp calls) for for writing (for use with
//  SetProp calls).  The purpose of this function and HrMAPICloseCachedProp
//  is to reduce the number of remote procedure calls made by code
//  which performs many GetProp or SetProp calls on an object.
//
//  INPUT:  lpObj   --  property object to cache
//          lpPropList  --  list of properties to cache (for reading)
//                          defaults to all properties if NULL.
//          ulFlags --  read OR write access flag (EDK_CACHE_READ
//                      or EDK_CACHE_WRITE)
//          
//  OUTPUT: lppCachedObj    --  cached property object
//
//  RETURNS:    HRESULT --  NOERROR if successful,
//                          E_INVALIDARG if bad input
//                          E_FAIL otherwise.
//
//  NOTE:   This function creates a cached object for reading only
//          or for writing only.  It does not support and object
//          for both reading and writing.
//
// -----------------------------------------------------------------------------
HRESULT HrMAPIOpenCachedProp(            // RETURNS: return code
    IN LPMAPIPROP lpObj,                // source object
    IN LPSPropTagArray lpPropList,      // list of properties to cache
    IN ULONG ulFlags,                   // open for reading only or for writing only
	OUT LPPROPDATA FAR * lppCachedObj); // cached version of source object

//$--HrMAPICloseCachedProp------------------------------------------------------
//
//  DESCRIPTION: If object was created as a write cache,
//               copy properties in local cached object
//               back to original remote object.
//
//  INPUT:  lpCachedObj --  cached property object
//          lpOriginalObj   --  original property object
//          ulFlags --  read cache or write cache flag (EDK_CACHE_READ
//                      or EDK_CACHE_WRITE)
//
//  OUTPUT: lppProblems --  set to the property problem array returned
//          by if there were problems setting properties on the original
//          object
//
//  NOTES:  lppProblems:  It may be set, even though overall call
//          is successful.  This is because all of the SetProps have been "deferred" on the
//          original object until this call, the user will need to evaluate
//          the contents of the lppProblems buffer pointer based on which
//          properties he/or she actually tried to set.  
//
//  RETURNS:    HRESULT --  NOERROR if successful,
//                          E_INVALIDARG if bad input
//                          E_FAIL otherwise
//
//                          lppProblems will only be valid if return code
//                          is NOERROR.
//
// -----------------------------------------------------------------------------
HRESULT HrMAPICloseCachedProp(           // RETURNS: return code
    IN LPPROPDATA lpCachedObj,          // cached property object
    IN LPMAPIPROP lpOriginalObj,        // original object
    IN ULONG ulFlags,                   // cache type (EDK_CACHE_READ or EDK_CACHE_WRITE)
    OUT LPSPropProblemArray FAR * lppProblems); // pointer to property problems array if problems setting properties

//$--HrMAPIGetPropString--------------------------------------------------------
//  Get a string property. 
// -----------------------------------------------------------------------------
HRESULT HrMAPIGetPropString(             // RETURNS: return code
    IN LPMAPIPROP lpObj,                // pointer to object
    IN ULONG ulPropTag,                 // property tag
    OUT ULONG *lpcbProp,                // count of bytes in property
    OUT LPVOID *lppvProp);              // pointer to property address variable

//$--HrMAPISetPropString--------------------------------------------------------
//  Set a string property. 
// -----------------------------------------------------------------------------
HRESULT HrMAPISetPropString(             // RETURNS: return code
    IN LPMAPIPROP lpObj,                // pointer to object
    IN ULONG ulPropTag,                 // property tag
    IN LPVOID lpvProp);                 // pointer to property

//$--HrMAPIGetPropBinary--------------------------------------------------------
//  Get a binary property.
// -----------------------------------------------------------------------------
HRESULT HrMAPIGetPropBinary(             // RETURNS: return code
    IN LPMAPIPROP lpObj,                // pointer to object
    IN ULONG ulPropTag,                 // property tag
    OUT ULONG *lpcbProp,                // count of bytes in property
    OUT LPVOID *lppvProp);              // pointer to property address variable

//$--HrMAPISetPropBinary--------------------------------------------------------
//  Set a binary property.
// -----------------------------------------------------------------------------
HRESULT HrMAPISetPropBinary(             // RETURNS: return code
    IN LPMAPIPROP lpObj,                // pointer to object
    IN ULONG ulPropTag,                 // property tag
    IN ULONG cbProp,                    // count of bytes in property
    IN LPVOID lpvProp);                 // pointer to property

//$--HrMAPIGetPropBoolean-------------------------------------------------------
//  Get a boolean property.
// -----------------------------------------------------------------------------
HRESULT HrMAPIGetPropBoolean(            // RETURNS: return code
    IN LPMAPIPROP lpObj,                // pointer to object
    IN ULONG ulPropTag,                 // property tag
    OUT BOOL *lpfProp);                 // pointer to property variable

//$--HrMAPISetPropBoolean-------------------------------------------------------
//  Set a boolean property.
// -----------------------------------------------------------------------------
HRESULT HrMAPISetPropBoolean(            // RETURNS: return code
    IN LPMAPIPROP lpObj,                // pointer to object
    IN ULONG ulPropTag,                 // property tag
    IN BOOL fProp);                     // property

//$--HrMAPIGetPropLong----------------------------------------------------------
//  Get a long property.
// -----------------------------------------------------------------------------
HRESULT HrMAPIGetPropLong(               // RETURNS: return code
    IN LPMAPIPROP lpObj,                // pointer to object
    IN ULONG ulPropTag,                 // property tag
    OUT ULONG *lpulProp);               // pointer to property variable

//$--HrMAPISetPropLong----------------------------------------------------------
//  Set a long property.
// -----------------------------------------------------------------------------
HRESULT HrMAPISetPropLong(               // RETURNS: return code
    IN LPMAPIPROP lpObj,                // pointer to object
    IN ULONG ulPropTag,                 // property tag
    IN ULONG ulProp);                   // property

//$--HrMAPIGetPropSystime-------------------------------------------------------
//  Get a systime property.
// -----------------------------------------------------------------------------
HRESULT HrMAPIGetPropSystime(            // RETURNS: return code
    IN LPMAPIPROP lpObj,                // pointer to object
    IN ULONG ulPropTag,                 // property tag
    OUT LPFILETIME lpSystime);          // pointer to property variable

//$--HrMAPISetPropSystime-------------------------------------------------------
//  Set a systime property.
// -----------------------------------------------------------------------------
HRESULT HrMAPISetPropSystime(            // RETURNS: return code
    IN LPMAPIPROP lpObj,                // pointer to object
    IN ULONG ulPropTag,                 // property tag
    IN LPFILETIME lpSystime);           // pointer to property

//$--HrMAPIGetPropToFile--------------------------------------------------------
//  Get a property and put in a given file.
// -----------------------------------------------------------------------------
HRESULT HrMAPIGetPropToFile(             // RETURNS: return code
    IN LPMAPIPROP lpObj,                // pointer to object
    IN ULONG ulPropTag,                 // property tag
    IN LPSTR lpszFilename,             // pointer to destination file name
    OUT ULONG *lpcbProp);               // pointer to count of bytes address
                                        // variable

//$--HrMAPISetPropFromFile------------------------------------------------------
//  Set a property from a given file.
// -----------------------------------------------------------------------------
HRESULT HrMAPISetPropFromFile(          // RETURNS: return code
    IN LPMAPIPROP lpObj,                // pointer to object
    IN ULONG ulPropTag,                 // property tag
    IN LPSTR lpszFilename,              // pointer to source file name
    OUT ULONG *lpcbProp);               // pointer to count of bytes address
                                        // variable

//$--HrMAPIOpenStreamOnProperty-------------------------------------------------
//  Open a stream on a given property.
// -----------------------------------------------------------------------------
HRESULT HrMAPIOpenStreamOnProperty(     // RETURNS: return code
    IN LPMAPIPROP lpObj,                // pointer to object
    IN ULONG ulPropTag,                 // property tag
    IN ULONG ulFlags,                   // flags (MAPI_CREATE and/or MAPI_MODIFY)
    OUT LPSTREAM *lppStream);           // pointer to stream address variable

//$--HrMAPIAppendSPropValues----------------------------------------------------
//  Append one set of SPropValue's to another.
// -----------------------------------------------------------------------------
HRESULT HrMAPIAppendSPropValues(        // RETURNS: return code
    IN ULONG cHeadProps,                // count of property values in head
    IN LPSPropValue lpHeadProps,        // pointer to property values in
                                        // head
    IN ULONG cTailProps,                // count of property values in tail
    IN LPSPropValue lpTailProps,        // pointer to property values in
                                        // tail
    OUT ULONG *lpcNewProps,             // pointer to count of property
                                        // values
    OUT LPSPropValue *lppNewProps);     // pointer to property values 

//$--HrMAPIMoveOneProp----------------------------------------------------------
//  Move one property from a source object to a destination object.
// -----------------------------------------------------------------------------
HRESULT HrMAPIMoveOneProp(               // RETURNS: return code
    IN LPMAPIPROP lpSrcObj,             // pointer to source object
    IN ULONG ulSrcPropTag,              // source property tag
    IN ULONG ulDstPropTag,              // destination property tag
    IN BOOL IsMust,                     // TRUE if a required property
    IN BOOL IsReplace,                  // TRUE if existing destination
                                        // property can be replaced
    IN OUT LPMAPIPROP lpDstObj);        // pointer to destination object

//******************************************************************************
//
// ISTORE.C function prototypes
//
//******************************************************************************


// $--HrMAPIFindStore-----------------------------------------------------------
// Find an MDB store based on a string.
//-----------------------------------------------------------------------------
HRESULT HrMAPIFindStoreW(
	IN	LPMAPISESSION	lpSession,  // MAPI session ptr
	IN	LPCWSTR			lpszStore,  // store name
	OUT	ULONG FAR *		lpcbentryid,// ptr to # bytes in entry ID
	OUT	LPENTRYID FAR *	lppentryid);// ptr to entry ID buffer

HRESULT HrMAPIFindStoreA(
	IN	LPMAPISESSION	lpSession,  // MAPI session ptr
	IN	LPCSTR			lpszStore,  // store name
	OUT	ULONG FAR *		lpcbentryid,// ptr to # bytes in entry ID
	OUT	LPENTRYID FAR *	lppentryid);// ptr to entry ID buffer

#ifdef UNICODE
#define HrMAPIFindStore  HrMAPIFindStoreW
#else
#define HrMAPIFindStore  HrMAPIFindStoreA
#endif

//$--HrMAPIFindDefaultMsgStore--------------------------------------------------
//  Get the entry ID of the default message store.
// -----------------------------------------------------------------------------
HRESULT HrMAPIFindDefaultMsgStore(    // RETURNS: return code
    IN LPMAPISESSION lplhSession,   // session pointer
    OUT ULONG *lpcbeid,             // count of bytes in entry ID
    OUT LPENTRYID *lppeid);         // entry ID of default store

//$--FIsPublicStore-------------------------------------------------------------
//  Returns TRUE if the MDB is a public store.
// -----------------------------------------------------------------------------
BOOL FIsPublicStore(
    IN LPMDB lpmdb);                // pointer to message store

//$--_HrOpenStoreFromGuid-------------------------------------------------------
//  Helper function to encapsulate the nuts and bolts of opening stores by GUID.
//  Used by HrOpenExchangePublicStore(), and HrOpenExchangePrivateStore().
//------------------------------------------------------------------------------
HRESULT _HrOpenStoreFromGuid(
    IN  LPMAPISESSION,
    IN  LPGUID,
    OUT LPMDB *);

//$--HrOpenExchangePublicStore--------------------------------------------------
//  Locates the public store provider (first matching if there are multiple)
//  and returns a pointer to it.
//------------------------------------------------------------------------------
__inline HRESULT HrOpenExchangePublicStore(
    IN LPMAPISESSION lphSession,    // open session handle
    OUT LPMDB * lppMDB)             // ptr to store opened
{
    return( _HrOpenStoreFromGuid( lphSession,
        (LPGUID)pbExchangeProviderPublicGuid,
        lppMDB));
}

//$--HrOpenExchangePrivateStore--------------------------------------------------
//  Locates the primary user store provider (first matching if there are multiple)
//  and returns a pointer to it.
//------------------------------------------------------------------------------
__inline HRESULT HrOpenExchangePrivateStore(
    IN LPMAPISESSION lphSession,    // open session handle
    OUT LPMDB * lppMDB)             // ptr to store opened
{
    return( _HrOpenStoreFromGuid( lphSession,
        (LPGUID)pbExchangeProviderPrimaryUserGuid,
        lppMDB));
}

//******************************************************************************
//
// ITRACE.C function prototypes
//
//******************************************************************************

//$--HrTraceGetEntryListSize----------------------------------------------------
//  Get the size of the hop trace information in bytes.
// -----------------------------------------------------------------------------
HRESULT HrTraceGetEntryListSize(      // RETURNS: return code
    IN LPTRACEINFO lpTraceInfo,         // Pointer to hop trace address variable
    OUT ULONG      *lpcbTraceInfo);     // Count of bytes in hop trace list

//$--HrTraceGetEntryList--------------------------------------------------------
//  Get the hop trace information for a given message.
// -----------------------------------------------------------------------------
HRESULT HrTraceGetEntryList(         // RETURNS: return code
    IN LPMESSAGE   lpMessage,           // Pointer to message.
    OUT LPTRACEINFO *lppTraceInfo);     // Pointer to hop trace address variable

//$--HrTraceSetEntryList--------------------------------------------------------
//  Set the hop trace information for a given message.
// -----------------------------------------------------------------------------
HRESULT HrTraceSetEntryList(         // RETURNS: return code
    IN LPMESSAGE   lpMessage,           // Pointer to message.
    IN LPTRACEINFO lpTraceInfo);        // Pointer to hop trace address variable

//$--HrTraceCopyEntry-----------------------------------------------------------
//  Copy trace entry information to a trace entry structure.
// -----------------------------------------------------------------------------
HRESULT HrTraceCopyEntry(            // RETURNS: return code
    IN LONG     lAction,                // The routing action the tracing site
                                        // took.
    IN FILETIME ftArrivalTime,          // The time at which the communique
                                        // entered the tracing site.
    IN FILETIME ftDeferredTime,         // The time are which the tracing site
                                        // released the message.
    IN LPSTR    lpszADMDName,           // ADMD Name
    IN LPSTR    lpszCountryName,        // Country Name
    IN LPSTR    lpszPRMDId,             // PRMD Identifier
    IN LPSTR    lpszAttADMDName,        // Attempted ADMD Name
    IN LPSTR    lpszAttCountryName,     // Attempted Country Name
    IN LPSTR    lpszAttPRMDId,          // Attempted PRMD Identifier
    OUT LPTRACEENTRY lpTraceEntry);     // Pointer to trace entry address
                                        // variable.

//$--HrTraceCreateEntryList-----------------------------------------------------
//  Create a hop trace information list.
// -----------------------------------------------------------------------------
HRESULT HrTraceCreateEntryList(      // RETURNS: return code
    IN LONG     lAction,                // The routing action the tracing site
                                        // took.
    IN FILETIME ftArrivalTime,          // The time at which the communique
                                        // entered the tracing site.
    IN FILETIME ftDeferredTime,         // The time are which the tracing site
                                        // released the message.
    IN LPSTR    lpszADMDName,           // ADMD Name
    IN LPSTR    lpszCountryName,        // Country Name
    IN LPSTR    lpszPRMDId,             // PRMD Identifier
    IN LPSTR    lpszAttADMDName,        // Attempted ADMD Name
    IN LPSTR    lpszAttCountryName,     // Attempted Country Name
    IN LPSTR    lpszAttPRMDId,          // Attempted PRMD Identifier
    OUT LPTRACEINFO *lppTraceInfo);     // Pointer to hop trace address variable

//$--HrTraceAppendEntryList-----------------------------------------------------
//  Append to an existing hop trace information list.
// -----------------------------------------------------------------------------
HRESULT HrTraceAppendEntryList(      // RETURNS: return code
    IN LONG     lAction,                // The routing action the tracing site
                                        // took.
    IN FILETIME ftArrivalTime,          // The time at which the communique
                                        // entered the tracing site.
    IN FILETIME ftDeferredTime,         // The time are which the tracing site
                                        // released the message.
    IN LPSTR    lpszADMDName,           // ADMD Name
    IN LPSTR    lpszCountryName,        // Country Name
    IN LPSTR    lpszPRMDId,             // PRMD Identifier
    IN LPSTR    lpszAttADMDName,        // Attempted ADMD Name
    IN LPSTR    lpszAttCountryName,     // Attempted Country Name
    IN LPSTR    lpszAttPRMDId,          // Attempted PRMD Identifier
    IN OUT LPTRACEINFO *lppTraceInfo);  // Pointer to hop trace address variable

//$--HrTraceGotoEntry-----------------------------------------------------------
//  Goto the specified TRACEENTRY in a TRACEINFO
// -----------------------------------------------------------------------------
HRESULT HrTraceGotoEntry(            // RETURNS: return code
    IN LPTRACEINFO lpTraceInfo,         // pointer to TRACEINFO
    IN ULONG ulIndex,                   // index of TRACEENTRY in TRACEINFO
    OUT LPTRACEENTRY *lppTraceEntry);   // pointer to TRACEENTRY

//$--HrTraceGotoFirstEntry------------------------------------------------------
//  Goto the first TRACEENTRY in a TRACEINFO
// -----------------------------------------------------------------------------
HRESULT HrTraceGotoFirstEntry(       // RETURNS: return code
    IN LPTRACEINFO lpTraceInfo,         // pointer to TRACEINFO
    OUT ULONG *lpulIndex,               // index of TRACEENTRY in TRACEINFO
    OUT LPTRACEENTRY *lppTraceEntry);   // pointer to TRACEENTRY

//$--HrTraceGotoNextEntry-------------------------------------------------------
//  Goto the next TRACEENTRY in a TRACEINFO
// -----------------------------------------------------------------------------
HRESULT HrTraceGotoNextEntry(        // RETURNS: return code
    IN LPTRACEINFO lpTraceInfo,         // pointer to TRACEINFO
    IN OUT ULONG *lpulIndex,            // index of TRACEENTRY in TRACEINFO
    OUT LPTRACEENTRY *lppTraceEntry);   // pointer to TRACEENTRY

//$--HrTraceOpenEntry-----------------------------------------------------------
//  Open a TRACEENTRY.
// -----------------------------------------------------------------------------
HRESULT HrTraceOpenEntry(            // RETURNS: return code
    IN LPTRACEENTRY lpTraceEntry,       // pointer to TRACEENTRY
    OUT LONG     *plAction,             // The routing action the tracing site
                                        // took.
    OUT FILETIME *pftArrivalTime,       // The time at which the communique
                                        // entered the tracing site.
    OUT FILETIME *pftDeferredTime,      // The time are which the tracing site
                                        // released the message.
    OUT LPSTR    *lppszADMDName,        // ADMD Name
    OUT LPSTR    *lppszCountryName,     // Country Name
    OUT LPSTR    *lppszPRMDId,          // PRMD Identifier
    OUT LPSTR    *lppszAttADMDName,     // Attempted ADMD Name
    OUT LPSTR    *lppszAttCountryName,  // Attempted Country Name
    OUT LPSTR    *lppszAttPRMDId);      // Attempted PRMD Identifier

//$--HrTraceSetInfo-------------------------------------------------------------
//  Set the trace-info on a message.
// -----------------------------------------------------------------------------
HRESULT HrTraceSetInfo(              // RETURNS: return code
    IN LONG lAction,                    // pointer to action
    IN FILETIME *lpftArrivalTime,       // pointer to arrival time
    IN FILETIME *lpftDeferredTime,      // pointer to deferred time
    IN LPSTR lpszCountry,              // pointer to country
    IN LPSTR lpszADMD,                 // pointer to ADMD
    IN LPSTR lpszPRMD,                 // pointer to PRMD
    IN OUT LPMESSAGE lpMessage);        // pointer to message

//$--HrTraceUpdateInfo----------------------------------------------------------
//  Update the trace-info on a message.
// -----------------------------------------------------------------------------
HRESULT HrTraceUpdateInfo(              // RETURNS: return code
    IN LONG lAction,                    // pointer to action
    IN FILETIME *lpftArrivalTime,       // pointer to arrival time
    IN FILETIME *lpftDeferredTime,      // pointer to deferred time
    IN LPSTR lpszCountry,               // pointer to country
    IN LPSTR lpszADMD,                  // pointer to ADMD
    IN LPSTR lpszPRMD,                  // pointer to PRMD
    IN OUT LPMESSAGE lpMessage);        // pointer to message

//$--HrInternalTraceCopyEntry---------------------------------------------------
//  Copy internal trace entry information to an internal trace entry structure.
// -----------------------------------------------------------------------------
HRESULT HrInternalTraceCopyEntry(       // RETURNS: return code
    IN LONG     lAction,                // The routing action the tracing site
                                        // took.
    IN FILETIME ftArrivalTime,          // The time at which the communique
                                        // entered the tracing site.
    IN FILETIME ftDeferredTime,         // The time are which the tracing site
                                        // released the message.
    IN LPSTR    lpszADMDName,           // ADMD Name
    IN LPSTR    lpszCountryName,        // Country Name
    IN LPSTR    lpszPRMDId,             // PRMD Identifier
    IN LPSTR    lpszMTAName,            // MTA Name
    IN LPSTR    lpszAttADMDName,        // Attempted ADMD Name
    IN LPSTR    lpszAttCountryName,     // Attempted Country Name
    IN LPSTR    lpszAttPRMDId,          // Attempted PRMD Identifier
    IN LPSTR    lpszAttMTAName,         // Attempted MTA Name
    OUT PINTTRACEENTRY lpTraceEntry);   // Pointer to trace entry address
                                        // variable.

//$--HrInternalTraceCreateEntryList---------------------------------------------
//  Create an internal hop trace information list.
// -----------------------------------------------------------------------------
HRESULT HrInternalTraceCreateEntryList( // RETURNS: return code
    IN LONG     lAction,                // The routing action the tracing site
                                        // took.
    IN FILETIME ftArrivalTime,          // The time at which the communique
                                        // entered the tracing site.
    IN FILETIME ftDeferredTime,         // The time are which the tracing site
                                        // released the message.
    IN LPSTR    lpszADMDName,           // ADMD Name
    IN LPSTR    lpszCountryName,        // Country Name
    IN LPSTR    lpszPRMDId,             // PRMD Identifier
    IN LPSTR    lpszMTAName,            // MTA Name
    IN LPSTR    lpszAttADMDName,        // Attempted ADMD Name
    IN LPSTR    lpszAttCountryName,     // Attempted Country Name
    IN LPSTR    lpszAttPRMDId,          // Attempted PRMD Identifier
    IN LPSTR    lpszAttMTAName,         // Attempted MTA Name
    OUT PINTTRACEINFO *lppTraceInfo);   // Pointer to hop trace address variable

//$--HrInternalTraceAppendEntryList---------------------------------------------
//  Append to an existing internal hop trace information list.
// -----------------------------------------------------------------------------
HRESULT HrInternalTraceAppendEntryList( // RETURNS: return code
    IN LONG     lAction,                // The routing action the tracing site
                                        // took.
    IN FILETIME ftArrivalTime,          // The time at which the communique
                                        // entered the tracing site.
    IN FILETIME ftDeferredTime,         // The time are which the tracing site
                                        // released the message.
    IN LPSTR    lpszADMDName,           // ADMD Name
    IN LPSTR    lpszCountryName,        // Country Name
    IN LPSTR    lpszPRMDId,             // PRMD Identifier
    IN LPSTR    lpszMTAName,            // MTA Name
    IN LPSTR    lpszAttADMDName,        // Attempted ADMD Name
    IN LPSTR    lpszAttCountryName,     // Attempted Country Name
    IN LPSTR    lpszAttPRMDId,          // Attempted PRMD Identifier
    IN LPSTR    lpszAttMTAName,         // Attempted MTA Name
    IN OUT PINTTRACEINFO *lppTraceInfo);// Pointer to hop trace address variable

#ifdef __cplusplus
}
#endif // __cplusplus

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\edkdebug.h ===
// --edkdebug.h-----------------------------------------------------------------
//
//  Functions to log debugging information in DEBUG builds.
// 
// Copyright 1986 - 1998 Microsoft Corporation.  All Rights Reserved.
// -----------------------------------------------------------------------------
#if !defined(_EDKDEBUG_H)
#define _EDKDEBUG_H

#include <stdio.h>
#include <stdarg.h>

// Default prefix for EDK debug log files.  By default, these files
// will be written to the temporary directory.  The name and path of the
// log files, can, however, be overriden by setting the EDK_DEBUG_FILE
// environment variable.
#define EDK_LOG_FILE_PREFIX		"edk"
#define EDK_LOG_FILE_SUFFIX		"log"

//$--DebugLevel-----------------------------------------------------------------
//  Available levels of debug.
// -----------------------------------------------------------------------------
typedef enum __DEBUGLEVEL
{
    D_PUBLIC = 0,   // log interface functions
    D_PRIVATE,      // log implementation functions
    D_ERROR,        // log errors
    D_WARNING,      // log warnings
    D_STATUS,       // log status
    D_ACTION,       // log starting/completed action
    D_OTHER,        // log other information
    D_LAST          // all debug levels are less than this 
} DEBUGLEVEL;

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

//------------------------------------------------------------------------------
//
// EDKLOG.C Functions
//
//------------------------------------------------------------------------------

//$--_WriteDebugString----------------------------------------------------------
//
//  Write a string to the debugger output window.
//  
// -----------------------------------------------------------------------------
void _WriteDebugString(                 // RETURNS: nothing
    IN LPSTR lpszFormat,                // format string
    ...);                               // arguments

//$--_StatusShowAssert----------------------------------------------------------
//
//  Status of the assert prompt.
//  
// -----------------------------------------------------------------------------
BOOL _StatusShowAssert(             // RETURNS: TRUE if assert prompt
    void);                          // no arguments

//$--_StatusDebugFile-----------------------------------------------------------
//
//  Status of the debug log file.
//  
// -----------------------------------------------------------------------------
BOOL _StatusDebugFile(              // RETURNS: nothing
    void);                          // no arguments

//$--_StatusDebugLevel----------------------------------------------------------
//
//  Status of the debug level.
//  
// -----------------------------------------------------------------------------
BOOL _StatusDebugLevel(             // RETURNS: nothing
    IN DEBUGLEVEL level);           // debug level

//$--_LockDebugFile-------------------------------------------------------------
//
//  Lock the debug log file.
//  
// -----------------------------------------------------------------------------
void _LockDebugFile(                // RETURNS: nothing
    void);                          // no arguments

//$--_UnlockDebugFile-----------------------------------------------------------
//
//  Unlock the debug log file.
//  
// -----------------------------------------------------------------------------
void _UnlockDebugFile(              // RETURNS: nothing
    void);                          // no arguments

//$--_WriteDebugFile------------------------------------------------------------
//
//  Write to the debug log file.
//  
// -----------------------------------------------------------------------------
void _WriteDebugFile(               // RETURNS: nothing
    IN LPSTR lpszFormat,            // format string
    ...);                           // arguments

//$--_InitDebugFile-------------------------------------------------------------
//
//  Initialize the debug log file.
//  
// -----------------------------------------------------------------------------
void _InitDebugFile(                // RETURNS: nothing
    void);                          // no arguments


//------------------------------------------------------------------------------
//
// EDKDEBUG.C Functions
//
//------------------------------------------------------------------------------

//$--_Assert--------------------------------------------------------------------
//  
//  Write to the debug log file and/or evaluate assertion.
//  
// -----------------------------------------------------------------------------
void _Assert(                   // RETURNS: nothing
    IN LPSTR lpszTag,           // tag name
    IN LPSTR lpszFile,          // source file name
    IN ULONG ulLine,            // source line number
    IN DEBUGLEVEL Level,        // assertion level
    IN BOOL fValue,             // assertion value
    IN LPSTR lpszFormat,        // format string
    ...);                       // arguments

//------------------------------------------------------------------------------
//
// MEMORY.C Functions
//
//------------------------------------------------------------------------------

#ifndef _PRIVATE_EDKDEBUG_H

//$--_DebugHeapCheck------------------------------------------------------------
//  Writes an entry in the debug log. This function is only called in
//  DEBUG builds through the DebugHeapCheck() macro.
// -----------------------------------------------------------------------------
void _DebugHeapCheck(                   // RETURNS: return code
    IN ULONG ulLine,                    // line number
    IN LPSTR lpszFile);                 // file name

//$--_DebugDumpHeap-------------------------------------------------------------
//  Writes an entry in the debug log. This function is only called in
//  DEBUG builds through the DebugDumpHeap() macro.
// -----------------------------------------------------------------------------
void _DebugDumpHeap(                    // RETURNS: nothing
    IN ULONG ulLine,                    // line number
    IN LPSTR lpszFile);                 // file name

//$--EDKDBG_MAPIAllocateBuffer--------------------------------------------------
//  Wrapper for MAPIAllocateBuffer().
// -----------------------------------------------------------------------------
SCODE EDKDBG_MAPIAllocateBuffer(        // RETURNS: status code
    IN  ULONG ulLine,                   // line number
    IN  LPSTR lpszFile,                 // file name
    IN  ULONG ulSize,                   // size of memory block
    OUT LPVOID *lppv);                  // pointer to memory block address
                                        // variable

//$--EDKDBG_MAPIAllocateMore----------------------------------------------------
//  Wrapper for MAPIAllocateMore().
// -----------------------------------------------------------------------------
SCODE EDKDBG_MAPIAllocateMore(          // RETURNS: status code
    IN  ULONG ulLine,                   // line number
    IN  LPSTR lpszFile,                 // file name
    IN  ULONG ulSize,                   // size of memory block
    IN  LPVOID lpvOriginal,             // pointer to original memory block
    OUT LPVOID *lppvData);              // pointer to memory block address
                                        // variable

//$--EDKDBG_MAPIFreeBuffer------------------------------------------------------
//  Wrapper for MAPIFreeBuffer().
// -----------------------------------------------------------------------------
SCODE EDKDBG_MAPIFreeBuffer(            // RETURNS: status code
    IN ULONG ulLine,                    // line number
    IN LPSTR lpszFile,                  // file name
    IN LPVOID lpv);                     // pointer to memory block

//$--EDKDBG_malloc--------------------------------------------------------------
//  Wrapper for malloc().
// -----------------------------------------------------------------------------
LPVOID EDKDBG_malloc(                   // RETURNS: pointer to memory block
    IN ULONG ulLine,                    // line number
    IN LPSTR lpszFile,                  // file name
    IN ULONG ulSize);                   // size of memory block

//$--EDKDBG_calloc--------------------------------------------------------------
//  Wrapper for calloc().
// -----------------------------------------------------------------------------
LPVOID EDKDBG_calloc(                   // RETURNS: pointer to memory block
    IN ULONG ulLine,                    // line number
    IN LPSTR lpszFile,                  // file name
    IN ULONG ulNum,                     // number of elements
    IN ULONG ulSize);                   // size of element

//$--EDKDBG_realloc-------------------------------------------------------------
//  Wrapper for realloc().
// -----------------------------------------------------------------------------
LPVOID EDKDBG_realloc(                  // RETURNS: pointer to memory block
    IN ULONG ulLine,                    // line number
    IN LPSTR lpszFile,                  // file name
    IN LPVOID lpvBlock,                 // pointer to memory block
    IN ULONG ulSize);                   // new size of memory block

//$--EDKDBG_strdup--------------------------------------------------------------
//  Wrapper for strdup().
// -----------------------------------------------------------------------------
char* EDKDBG_strdup(                    // RETURNS: pointer to allocated string
    IN ULONG ulLine,                    // line number
    IN LPSTR lpszFile,                  // file name
    IN const char *lpsz);               // pointer to string

//$--EDKDBG_wcsdup--------------------------------------------------------------
//  Wrapper for wcsdup().
// -----------------------------------------------------------------------------
wchar_t* EDKDBG_wcsdup(                 // RETURNS: pointer to allocated string
    IN ULONG ulLine,                    // line number
    IN LPSTR lpszFile,                  // file name
    IN const wchar_t *lpsz);            // pointer to string

//$--EDKDBG_free----------------------------------------------------------------
//  Wrapper for free().
// -----------------------------------------------------------------------------
void EDKDBG_free(                       // RETURNS: nothing
    IN ULONG ulLine,                    // line number
    IN LPSTR lpszFile,                  // file name
    IN LPVOID lpv);                     // pointer to memory block

//$--EDKDBG_GlobalAlloc---------------------------------------------------------
//  Wrapper for GlobalAlloc().
// -----------------------------------------------------------------------------
HGLOBAL EDKDBG_GlobalAlloc(             // RETURNS: pointer to memory block
    IN ULONG ulLine,                    // line number
    IN LPSTR lpszFile,                  // file name
    IN UINT  fuFlags,                   // allocation flags
    IN DWORD dwSize);                   // size of memory block

//$--EDKDBG_GlobalReAlloc-------------------------------------------------------
//  Wrapper for GlobalReAlloc().
// -----------------------------------------------------------------------------
HGLOBAL EDKDBG_GlobalReAlloc(           // RETURNS: pointer to memory block
    IN ULONG ulLine,                    // line number
    IN LPSTR lpszFile,                  // file name
    IN HGLOBAL hglb,                    // pointer to memory block
    IN DWORD cbBytes,                   // new size of memory block
    IN UINT  fuFlags);                  // allocation flags

//$--EDKDBG_GlobalFree----------------------------------------------------------
//  Wrapper for GlobalFree().
// -----------------------------------------------------------------------------
HGLOBAL EDKDBG_GlobalFree(              // RETURNS: nothing
    IN ULONG ulLine,                    // line number
    IN LPSTR lpszFile,                  // file name
    IN HGLOBAL hglb);                   // pointer to memory block

//$--EDKDBG_LocalAlloc---------------------------------------------------------
//  Wrapper for LocalAlloc().
// -----------------------------------------------------------------------------
HGLOBAL EDKDBG_LocalAlloc(              // RETURNS: pointer to memory block
    IN ULONG ulLine,                    // line number
    IN LPSTR lpszFile,                  // file name
    IN UINT  fuFlags,                   // allocation flags
    IN DWORD dwSize);                   // size of memory block

//$--EDKDBG_LocalReAlloc-------------------------------------------------------
//  Wrapper for LocalReAlloc().
// -----------------------------------------------------------------------------
HGLOBAL EDKDBG_LocalReAlloc(            // RETURNS: pointer to memory block
    IN ULONG ulLine,                    // line number
    IN LPSTR lpszFile,                  // file name
    IN HLOCAL hgbl,                     // pointer to memory block
    IN DWORD cbBytes,                   // new size of memory block
    IN UINT  fuFlags);                  // allocation flags

//$--EDKDBG_LocalFree----------------------------------------------------------
//  Wrapper for LocalFree().
// -----------------------------------------------------------------------------
HGLOBAL EDKDBG_LocalFree(               // RETURNS: nothing
    IN ULONG ulLine,                    // line number
    IN LPSTR lpszFile,                  // file name
    IN HGLOBAL hgbl);                   // pointer to memory block

//$--EDKDBG_HrLog---------------------------------------------------------------
//  Log an HRESULT (and the last Win32 error) to the debug log.
// -----------------------------------------------------------------------------
HRESULT EDKDBG_HrLog(                   // RETURNS: HRESULT
    IN LPSTR lpszFile,                  // file name
    IN ULONG ulLine,                    // line number
    IN HRESULT hr,                      // function return code
    IN DWORD dwLastError);              // last Win32 error

//$--EDKDBG_HrFailed------------------------------------------------------------
//  Log an HRESULT (and the last Win32 error) to the debug log.
// -----------------------------------------------------------------------------
BOOL EDKDBG_HrFailed(                   // RETURNS: HRESULT
    IN LPSTR lpszFile,                  // file name
    IN ULONG ulLine,                    // line number
    IN HRESULT hr,                      // function return code
    IN DWORD dwLastError);              // last Win32 error

#define _QUOTE(x) # x
#define QUOTE(x) _QUOTE(x)

// Use __FILE__LINE__ as a string containing "File.x(line#)" for example:
//     #pragma message( __FILE__LINE__ "Remove this line after testing.")
// The above example will display the file name and line number in the build window
// in such a way as to allow you to double click on it to go to the line.
#define __FILE__LINE__ __FILE__ "(" QUOTE(__LINE__) ") : "


#define TEST_STRING_PTR(x)        \
    (((x) != NULL) && (!IsBadStringPtr((x), (INFINITE))))
#define TEST_STRINGA_PTR(x)       \
    (((x) != NULL) && (!IsBadStringPtrA(x, (INFINITE))))
#define TEST_STRINGW_PTR(x)       \
    (((x) != NULL) && (!IsBadStringPtrW(x, (INFINITE))))
#define TEST_READ_PTR(x, y)    \
    (((x) != NULL) && (!IsBadReadPtr((x),(y))))
#define TEST_WRITE_PTR(x, y)   \
    (((x) != NULL) && (!IsBadWritePtr((x),(y))))
#define TEST_FUNCTION_PTR(x)   \
    (((x) != NULL) && (!IsBadCodePtr((x))))

#define TEST_STRING_PTR_OR_NULL(x)        \
    (((x) == NULL) || (!IsBadStringPtr((x), (INFINITE))))
#define TEST_STRINGA_PTR_OR_NULL(x)        \
    (((x) == NULL) || (!IsBadStringPtrA((x), (INFINITE))))
#define TEST_STRINGW_PTR_OR_NULL(x)        \
    (((x) == NULL) || (!IsBadStringPtrW((x), (INFINITE))))
#define TEST_READ_PTR_OR_NULL(x, y)    \
    (((x) == NULL) || (!IsBadReadPtr((x),(y))))
#define TEST_WRITE_PTR_OR_NULL(x, y)   \
    (((x) == NULL) || (!IsBadWritePtr((x),(y))))
#define TEST_FUNCTION_PTR_OR_NULL(x)   \
    (((x) == NULL) || (!IsBadCodePtr((x))))
#define TEST_IUNKNOWN_PTR(x) \
    (((x) != NULL) && !FBadUnknown((x)))

#ifdef DEBUG

#define HR_LOG(_hr) EDKDBG_HrLog(__FILE__, __LINE__, (_hr), GetLastError())

#ifdef FAILED
#undef FAILED
#endif
#define FAILED(_hr) EDKDBG_HrFailed(__FILE__, __LINE__, (_hr), GetLastError())

#ifdef SUCCEEDED
#undef SUCCEEDED
#endif
#define SUCCEEDED(_hr) (!EDKDBG_HrFailed(__FILE__, __LINE__, (_hr), GetLastError()))

#ifdef HR_FAILED
#undef HR_FAILED
#endif
#define HR_FAILED(_hr) FAILED(_hr)

#ifdef HR_SUCCEEDED
#undef HR_SUCCEEDED
#endif
#define HR_SUCCEEDED(_hr) SUCCEEDED(_hr)

#define RETURN(_hr) return(EDKDBG_HrLog(__FILE__, __LINE__, (_hr), GetLastError()))

#define DEBUGPUBLIC(x) \
    { _Assert("DEBUG", __FILE__, __LINE__, D_PUBLIC, TRUE, "%s\n", (x)); }

#define DEBUGPRIVATE(x) \
    { _Assert("DEBUG", __FILE__, __LINE__, D_PRIVATE, TRUE, "%s\n", (x)); }

#define DEBUGACTION(x) \
    { _Assert("DEBUG", __FILE__, __LINE__, D_ACTION, TRUE, "%s\n", (x)); }


#define MODULE_ERROR(x) \
    { _Assert("ASSERT", __FILE__, __LINE__, D_ERROR, FALSE, "%s\n", (x)); }

#define MODULE_WARNING(x) \
    { _Assert("ASSERT", __FILE__, __LINE__, D_WARNING, FALSE, "%s\n", (x)); }

#define MODULE_STATUS(x) \
    { _Assert("ASSERT", __FILE__, __LINE__, D_STATUS, FALSE, "%s\n", (x)); }

#define MODULE_ERROR1(x, y) \
    { _Assert("ASSERT", __FILE__, __LINE__, D_ERROR, FALSE, (x"\n"), (y)); }

#define MODULE_ERROR2(x, y, z) \
    { _Assert("ASSERT", __FILE__, __LINE__, D_ERROR, FALSE, (x"\n"), (y), (z)); }

#define MODULE_WARNING1(x, y) \
    { _Assert("ASSERT", __FILE__, __LINE__, D_WARNING, FALSE, (x"\n"), (y)); }

#define MODULE_WARNING2(x, y, z) \
    { _Assert("ASSERT", __FILE__, __LINE__, D_WARNING, FALSE, (x"\n"), (y), (z)); }

#define MODULE_STATUS1(x, y) \
    { _Assert("ASSERT", __FILE__, __LINE__, D_STATUS, FALSE, (x"\n"), (y)); }

#define MODULE_STATUS2(x, y, z) \
    { _Assert("ASSERT", __FILE__, __LINE__, D_STATUS, FALSE, (x"\n"), (y), (z)); }


#define ASSERTERROR(x, y) \
    { _Assert("ASSERT", __FILE__, __LINE__, D_ERROR, (x), (y"\n")); }

#define ASSERTWARNING(x, y) \
    { _Assert("ASSERT", __FILE__, __LINE__, D_WARNING, (x), (y"\n")); }

#define ASSERT_STRING_PTR(x, y)     ASSERTERROR(TEST_STRING_PTR(x), y)
#define ASSERT_STRINGA_PTR(x, y)    ASSERTERROR(TEST_STRINGA_PTR(x), y)
#define ASSERT_STRINGW_PTR(x, y)    ASSERTERROR(TEST_STRINGW_PTR(x), y)
#define ASSERT_READ_PTR(x, y, z)    ASSERTERROR(TEST_READ_PTR(x, y), z)
#define ASSERT_WRITE_PTR(x, y, z)   ASSERTERROR(TEST_WRITE_PTR(x, y), z)
#define ASSERT_FUNCTION_PTR(x, y)   ASSERTERROR(TEST_FUNCTION_PTR(x), y)

#define ASSERT_IUNKNOWN_PTR(x, y)   ASSERTERROR(TEST_IUNKNOWN_PTR(x), y)

#define ASSERT_STRING_PTR_OR_NULL(x, y)   \
    ASSERTERROR(TEST_STRING_PTR_OR_NULL(x), y)
#define ASSERT_STRINGA_PTR_OR_NULL(x, y)  \
    ASSERTERROR(TEST_STRINGA_PTR_OR_NULL(x), y)
#define ASSERT_STRINGW_PTR_OR_NULL(x, y)  \
    ASSERTERROR(TEST_STRINGW_PTR_OR_NULL(x), y)
#define ASSERT_READ_PTR_OR_NULL(x, y, z)  \
    ASSERTERROR(TEST_READ_PTR_OR_NULL(x, y), z)
#define ASSERT_WRITE_PTR_OR_NULL(x, y, z) \
    ASSERTERROR(TEST_WRITE_PTR_OR_NULL(x, y), z)
#define ASSERT_FUNCTION_PTR_OR_NULL(x, y) \
    ASSERTERROR(TEST_FUNCTION_PTR_OR_NULL(x), y)

#define OUTPUTDEBUGSTRING(_sz) \
    OutputDebugString("error: " __FILE__ ", " QUOTE(__LINE__) ", " _sz "\n");

#else

#define HR_LOG(_hr)                         (_hr)

#define RETURN(_hr)                         return((_hr))

#define DEBUGPUBLIC(x)                      ((void)0)

#define DEBUGPRIVATE(x)                     ((void)0)

#define DEBUGACTION(x)                      ((void)0)


#define MODULE_ERROR(x)                     ((void)0)

#define MODULE_WARNING(x)                   ((void)0)

#define MODULE_STATUS(x)                    ((void)0)

#define MODULE_ERROR1(x, y)                 ((void)0)

#define MODULE_ERROR2(x, y, z)              ((void)0)

#define MODULE_WARNING1(x, y)               ((void)0)

#define MODULE_WARNING2(x, y, z)            ((void)0)

#define MODULE_STATUS1(x, y)                ((void)0)

#define MODULE_STATUS2(x, y, z)             ((void)0)


#define ASSERTERROR(x, y)                   ((void)0)

#define ASSERTWARNING(x, y)                 ((void)0)

#define ASSERT_STRING_PTR(x, y)             ((void)0)

#define ASSERT_STRINGA_PTR(x, y)            ((void)0)

#define ASSERT_STRINGW_PTR(x, y)            ((void)0)

#define ASSERT_READ_PTR(x, y, z)            ((void)0)

#define ASSERT_WRITE_PTR(x, y, z)           ((void)0)

#define ASSERT_FUNCTION_PTR(x, y)           ((void)0)

#define ASSERT_IUNKNOWN_PTR(x, y)           ((void)0)

#define ASSERT_STRING_PTR_OR_NULL(x, y)     ((void)0)

#define ASSERT_STRINGA_PTR_OR_NULL(x, y)    ((void)0)
                                            
#define ASSERT_STRINGW_PTR_OR_NULL(x, y)    ((void)0)

#define ASSERT_READ_PTR_OR_NULL(x, y, z)    ((void)0)

#define ASSERT_WRITE_PTR_OR_NULL(x, y, z)   ((void)0)

#define ASSERT_FUNCTION_PTR_OR_NULL(x, y)   ((void)0)

#define OUTPUTDEBUGSTRING(x)                ((void)0)

#endif

//
// Memory allocation function wrappers
//

#ifndef _PRIVATE_MEMORY_H

#ifdef DEBUG

#define DEBUG_HEAP_CHECK    _DebugHeapCheck(__LINE__,__FILE__)

#define DEBUG_DUMP_HEAP     _DebugDumpHeap(__LINE__,__FILE__)

#define MAPIAllocateBuffer(x, y)    \
    EDKDBG_MAPIAllocateBuffer(__LINE__,__FILE__,(x),(y))

#define MAPIAllocateMore(x, y, z)   \
    EDKDBG_MAPIAllocateMore(__LINE__,__FILE__,(x),(y),(z))

#define MAPIFreeBuffer(x)           \
    EDKDBG_MAPIFreeBuffer(__LINE__,__FILE__,(x))

#define malloc(x)                   \
    EDKDBG_malloc(__LINE__,__FILE__,(x))

#define calloc(x, y)                \
    EDKDBG_calloc(__LINE__,__FILE__,(x),(y))

#define realloc(x, y)                \
    EDKDBG_realloc(__LINE__,__FILE__,(x),(y))

#define GlobalAlloc(x, y)            \
    EDKDBG_GlobalAlloc(__LINE__,__FILE__,(x),(y))

#define GlobalReAlloc(x, y, z)       \
    EDKDBG_GlobalReAlloc(__LINE__,__FILE__,(x),(y),(z))

#ifdef GlobalDiscard
#undef GlobalDiscard
#endif
#define GlobalDiscard(x)             \
    EDKDBG_GlobalReAlloc(__LINE__,__FILE__,(x),0,GMEM_MOVEABLE)

#define GlobalFree(x)                \
    EDKDBG_GlobalFree(__LINE__,__FILE__,(x))

#define LocalAlloc(x, y)            \
    EDKDBG_LocalAlloc(__LINE__,__FILE__,(x),(y))

#define LocalReAlloc(x, y, z)       \
    EDKDBG_LocalReAlloc(__LINE__,__FILE__,(x),(y),(z))

#ifdef LocalDiscard
#undef LocalDiscard
#endif
#define LocalDiscard(x)             \
    EDKDBG_LocalReAlloc(__LINE__,__FILE__,(x),0,GMEM_MOVEABLE)

#define LocalFree(x)                \
    EDKDBG_LocalFree(__LINE__,__FILE__,(x))

#ifdef strdup
#undef strdup
#endif
#define strdup(x)                    \
    EDKDBG_strdup(__LINE__,__FILE__,(x))

#define _strdup(x)                   \
    EDKDBG_strdup(__LINE__,__FILE__,(x))

#define _wcsdup(x)                   \
    EDKDBG_wcsdup(__LINE__,__FILE__,(x))

#define free(x)                     \
    EDKDBG_free(__LINE__,__FILE__,(x))

#else

#define DEBUG_HEAP_CHECK              ((void)0)

#define DEBUG_DUMP_HEAP               ((void)0)

#endif

#endif // _PRIVATE_MEMORY_H


//------------------------------------------------------------------------------
//
// Inline parameter checking functions
//
//------------------------------------------------------------------------------

//$--CHK_main-------------------------------------------------------------------
//  Check the parameters for main() functions.
// -----------------------------------------------------------------------------
__inline static HRESULT CHK_main(		// RETURNS: HRESULT
	IN int argc,						// number of arguments on command line
	IN char *argv[])					// array of command line arguments
{
	HRESULT		hr		= NOERROR;
	int			i		= 0;

	if (argc < 0)
	{
		hr = HR_LOG(E_INVALIDARG);
		goto cleanup;
	}

	for (i = 0; i < argc; i++)
	{
		if (!TEST_STRINGA_PTR(argv[i]))
		{
			hr = HR_LOG(E_INVALIDARG);
			goto cleanup;
		}
	}

cleanup:
	return(hr);
}


#endif // _PRIVATE_EDKDEBUG_H

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\eh.h ===
/***
*eh.h - User include file for exception handling.
*
*       Copyright (c) 1993-1997, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       User include file for exception handling.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_EH
#define _INC_EH

#if     !defined(_WIN32) && !defined(_MAC)
#error ERROR: Only Mac or Win32 targets supported!
#endif


#ifdef  _MSC_VER
// Currently, all MS C compilers for Win32 platforms default to 8 byte
// alignment.
#pragma pack(push,8)
#endif  // _MSC_VER

#ifndef __cplusplus
#error "eh.h is only for C++!"
#endif


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */

/* Define _CRTAPI1 (for compatibility with the NT SDK) */

#ifndef _CRTAPI1
#if	_MSC_VER >= 800 && _M_IX86 >= 300
#define _CRTAPI1 __cdecl
#else
#define _CRTAPI1
#endif
#endif

typedef void (__cdecl *terminate_function)();
typedef void (__cdecl *unexpected_function)();
typedef void (__cdecl *terminate_handler)();
typedef void (__cdecl *unexpected_handler)();

#ifndef _MAC
struct _EXCEPTION_POINTERS;
typedef void (__cdecl *_se_translator_function)(unsigned int, struct _EXCEPTION_POINTERS*);
#endif

#if     _MSC_VER >= 1200
_CRTIMP __declspec(noreturn) void __cdecl terminate(void);
_CRTIMP __declspec(noreturn) void __cdecl unexpected(void);
#else
_CRTIMP void __cdecl terminate(void);
_CRTIMP void __cdecl unexpected(void);
#endif

_CRTIMP terminate_function __cdecl set_terminate(terminate_function);
_CRTIMP unexpected_function __cdecl set_unexpected(unexpected_function);
#ifndef _MAC
_CRTIMP _se_translator_function __cdecl _set_se_translator(_se_translator_function);
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  // _MSC_VER

#endif  // _INC_EH
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\edkutils.h ===
// --edkutils.h-----------------------------------------------------------------
//  EDK utility functions.
//
//  Copyright 1986 - 1998 Microsoft Corporation.  All Rights Reserved.
// -----------------------------------------------------------------------------

#ifndef _EDKUTILS_H_
#define _EDKUTILS_H_

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

#define EXCHANGE_DS     1
#define EXCHANGE_IS     2
#define EXCHANGE_MTA    3
#define EXCHANGE_SA     4

//$--_HrWriteFile-------------------------------------------------------------
//  Transfer contents from a given memory location & length to an open file.
// -----------------------------------------------------------------------------
HRESULT _HrWriteFile(                   // RETURNS: return code
    IN HANDLE hFile,                    // file handle
    IN ULONG cbmem,                     // count of bytes of memory
    IN LPBYTE lpbmem);                  // pointer to memory

//$--HrCreateDirEntryId------------------------------------------------------
//  Create a directory entry ID given the address of the object
// -----------------------------------------------------------------------------
HRESULT HrCreateDirEntryId(          // RETURNS: return code
    IN LPSTR lpszAddress,               // pointer to address
    OUT ULONG *lpcbeid,                 // count of bytes in entry ID
    OUT LPENTRYID *lppeid);             // pointer to entry ID

//$--_HrMemoryToFile----------------------------------------------------------
//  Transfer contents from a given memory location & length to a given file.
// -----------------------------------------------------------------------------
HRESULT _HrMemoryToFile(              // RETURNS: return code
    IN ULONG cbmem,                     // count of bytes of memory
    IN LPBYTE lpbmem,                   // pointer to memory
    IN LPSTR lpszFilename);             // pointer to destination file name

//$--_HrFileToMemory----------------------------------------------------------
//  Transfer contents from a given file to memory.
// -----------------------------------------------------------------------------
HRESULT _HrFileToMemory(              // RETURNS: return code
    IN LPSTR lpszFilename,              // pointer to source file name
    OUT ULONG *lpcbmem,                 // pointer to count of bytes of memory
                                        // variable
    OUT LPBYTE *lppbmem);               // pointer to bytes of memory address
                                        // variable

//$--HrGetMailboxDN----------------------------------------------------------
//  Retrieves mailbox distinguished name from current session object.
//  Example output: /O=Enterprise/OU=Site/CN=Recipients/CN=MailboxName
// -----------------------------------------------------------------------------
HRESULT HrGetMailboxDN(
    IN  LPMAPISESSION lphSession,       // current session handle
    OUT LPSTR*  ppszMailboxDN);         // distinguished name of mailbox.

//$--HrGetServerDN----------------------------------------------------------
//  Retrieves server distinguished name from current session object.
//  Example output: /O=Enterprise/OU=Site/CN=Configuration/CN=Servers/CN=ServerName
// -----------------------------------------------------------------------------
HRESULT HrGetServerDN(
    IN  LPMAPISESSION lphSession,       // current session handle
    OUT LPSTR*  ppszServerDN);          // distinguished name of server. 

//$--_HrFindArrayValue--------------------------------------------------------
// Scan through an array of string pointers searching for a value string that
// matches up to the length of the value string.  Case INSENSITIVE.
//
// OUTPUT:  pnIndex will contain the index into the array of the match.  It will
//          contain ~0 if no match was found.  
//
// RETURNS: NOERROR
//          EDK_E_NOT_FOUND if match was not found.
//          EDK_E_AMBIGUOUS if more than one match found.
//          E_INVALIDARG
// -----------------------------------------------------------------------------
HRESULT _HrFindArrayValue(// RETURNS: return code
    IN  LPSTR  pszValue,    // string value to find.
    IN  LPSTR* rgpszArray,  // array of strings containing known values.
    IN  ULONG  nArraySize,  // number of known values.
    OUT ULONG* pnIndex);    // index of known value, ~0 if no match found.

//$--_HrExpandCommandLineArgument---------------------------------------------
//  Expands abbreviated command line flags of the form -FLAG=VALUE (or
//  /FLAG=VALUE) to their full text forms returning the index of the  
//  matching flag and a pointer to the data part of the flag (ie the 
//  part after the equals sign).  The caller passes an array of known 
//  flag names, and the function tries to make an unambiguous match 
//  with one of the names.  In this way users can be offered the 
//  convenience of entering /V=Foo, instead of
//  /VERY-LONG-AND-CLUMSY-NAME=Foo (assuming no other flag begins with
//  V, otherwise the user might have to enter more letters).
//
//  The comparison is not case sensitive; the flag names /BLUTO and
//  -bluto are not distinguished, and /b might match on either of them.
//
//  To maintain greater compatibility with other Microsoft NT and DOS
//  command line applications, the ":" character may be substituted 
//  for the "=".  So /FLAG:VALUE or -FLAG:VALUE are also valid.
// -----------------------------------------------------------------------------

HRESULT _HrExpandCommandLineArgument(
    IN  LPSTR  pszArg,          // flag user entered
    IN  LPSTR* rgpszArgArray,   // array of known flag names (w/o leading dashes)
    IN  ULONG  nArraySize,      // number of known flags
    OUT ULONG* pnFlagIndex,     // index of known flag, -1 if no match found.
	OUT LPSTR* ppszFlagName,	// known flag name
    OUT LPSTR* ppszArgData);    // user data for flag

//$--_nEcFromHr---------------------------------------------------------------
//  Convert an HRESULT to an exit code suitable for return
//  from a console application.
//
//  NOTE:
//
//      EDK HRESULTS get converted to their "code" (current 1 - 4).
//      Any successful HRESULT converts to zero.
//      Any EDK "approved" Win32 or OLE HRESULT gets converted
//      to its EDK exit code (currently 101 - 105).
//      Any non-EDK approved HRESULT gets converted to the negative
//      of its "code" (e.g. -8).
//-----------------------------------------------------------------------------
INT _nEcFromHr(                       // RETURNS: INT
    IN HRESULT hr);                     // HRESULT to convert to exit code

//$--HrIdentifyRegistryRootKey--------------------------------------------------
//  Checks that a fully qualified key name begins with one of the four
//	predefined NT Registry keys: HKEY_LOCAL_MACHINE, HKEY_CLASSES_ROOT,
//	HKEY_CURRENT_USER, or HKEY_USERS.  The output from this function
//	can be passed to registry functions like RegOpenKeyEx().
//
//  NOTE:
//
//	    Successful completion.  hkKey is the Registry key handle,
//	    pszSubKey points to the remainder of the subkey string.  Note
//	    that it is legitimate for pszSubKey to be NULL, meaning that
//	    the user is trying to access values in the root of one of the
//	    predefined registry keys.
// -----------------------------------------------------------------------------
HRESULT HrIdentifyRegistryRootKey(  // RETURNS: return code
    IN  LPSTR pszKey,               // pointer to fully qualified key name
    OUT HKEY *phkKeyHandle,         // pointer to key handle
    OUT LPSTR *ppszSubKey);         // pointer to subkey section

//$--_HrReadRegistrySZ--------------------------------------------------------
//  Read a string from the registry.
// -----------------------------------------------------------------------------
HRESULT _HrReadRegistrySZ(		    // RETURNS: return code
	IN HKEY hRegistryKey,				// registry key to read value from
	IN LPSTR lpszValueName,		    	// name of value to read
	OUT LPSTR lpszBuffer,				// buffer to read value into
	IN OUT DWORD *lpcbBufferSize);		// size of buffer to read value into

//$--_HrReadRegistryDWORD-----------------------------------------------------
//  Read a DWORD integer from the registry.
// -----------------------------------------------------------------------------
HRESULT _HrReadRegistryDWORD(			// RETURNS: return code
	IN HKEY hRegistryKey,				// registry key to read value from
	IN LPSTR lpszValueName,			    // name of value to read
	OUT LPDWORD lpdwBuffer);			// address of DWORD to read value into

//$--_HrWriteRegistrySZ-------------------------------------------------------
//  Write a string to the registry.
// -----------------------------------------------------------------------------
HRESULT _HrWriteRegistrySZ(			// RETURNS: return code
	IN HKEY hRegistryKey,				// registry key to write value to
	IN LPSTR lpszValueName,		    	// name of value to write
	IN LPCSTR lpszValue);				// string value to write

//$--_HrWriteRegistryDWORD----------------------------------------------------
//  Write a DWORD integer to the registry.
// -----------------------------------------------------------------------------
HRESULT _HrWriteRegistryDWORD(		// RETURNS: return code
	IN HKEY hRegistryKey,				// registry key to write value to
	IN LPSTR lpszValueName,			    // name of value to write
	IN DWORD dwValue);					// DWORD value to write

//$--_HrInputCommandLinePassword---------------------------------------------------------
//  Input password and echo *'s.
// -----------------------------------------------------------------------------
HRESULT _HrInputCommandLinePassword(				// RETURNS: return code
	IN DWORD dwFlags,					// reserved--must be zero
	IN DWORD cbLength,		  		    // size of the buffer in bytes
	OUT LPSTR pszBuffer);				// buffer to write string into

//$--HrStrAToStrW---------------------------------------------------------------
//  Convert a byte string to a word string.  The resulting string is placed in 
//  a buffer allocated using MAPIAllocateBuffer.
// -----------------------------------------------------------------------------
HRESULT HrStrAToStrW(                   // RETURNS: return code
    IN  LPCSTR          lpszSource,     // source string
    OUT LPWSTR *        lppwszDest);    // destination string

//$--HrStrWToStrA---------------------------------------------------------------
//  Convert a word string to a byte string.  The resulting string is placed in 
//  a buffer allocated using MAPIAllocateBuffer.
// -----------------------------------------------------------------------------
HRESULT HrStrWToStrA(                   // RETURNS: return code
    IN  LPCWSTR         lpwszSource,    // source string
    OUT LPSTR *         lppszDest);     // destination string

//$--HrStrAToStrA---------------------------------------------------------------
//  Create an allocated copy of a byte string using MAPIAllocateBuffer.
//  This is useful for creating macros involving TCHAR strings.
// -----------------------------------------------------------------------------
HRESULT HrStrAToStrA(                   // RETURNS: return code
    IN  LPCSTR          lpszSource,     // source string
    OUT LPSTR *         lppszDest);     // destination string

//$--HrStrWToStrW---------------------------------------------------------------
//  Create an allocated copy of a word string using MAPIAllocateBuffer.
//  This is useful for creating macros involving TCHAR strings.
// -----------------------------------------------------------------------------
HRESULT HrStrWToStrW(                   // RETURNS: return code
    IN  LPCWSTR         lpwszSource,    // source string
    OUT LPWSTR *        lppwszDest);    // destination string

//$--HrStr*ToStr*---------------------------------------------------------------
//  Macros that implement string conversion for TCHAR strings.
// -----------------------------------------------------------------------------

#ifdef UNICODE

#define HrStrToStr(Source,Dest)     HrStrWToStrW(Source,Dest)
#define HrStrToStrA(Source,Dest)    HrStrWToStrA(Source,Dest)
#define HrStrToStrW(Source,Dest)    HrStrWToStrW(Source,Dest)
#define HrStrAToStr(Soruce,Dest)    HrStrAToStrW(Source,Dest)
#define HrStrWToStr(Source,Dest)    HrStrWToStrW(Source,Dest)

#else // UNICODE

#define HrStrToStr(Source,Dest)     HrStrAToStrA(Source,Dest)
#define HrStrToStrA(Source,Dest)    HrStrAToStrA(Source,Dest)
#define HrStrToStrW(Source,Dest)    HrStrAToStrW(Source,Dest)
#define HrStrAToStr(Soruce,Dest)    HrStrAToStrA(Source,Dest)
#define HrStrWToStr(Source,Dest)    HrStrWToStrA(Source,Dest)

#endif // UNICODE

//$--HrGetServiceStatus------------------------------------------------------
//  Get the current state of a service on a given machine.
// -----------------------------------------------------------------------------
HRESULT HrGetServiceStatus(          // RETURNS: return code
    IN LPSTR lpszMachineName,           // machine name
    IN LPSTR lpszServiceName ,          // service name
    OUT DWORD *lpdwCurrentState);       // current state

//$--HrGetExchangeStatus-----------------------------------------------------
//  Get the current state of the Exchange server on a given machine.
// -----------------------------------------------------------------------------
HRESULT HrGetExchangeStatus(         // RETURNS: return code
    IN LPSTR lpszMachineName,           // machine name
    OUT DWORD *lpdwService,             // service
    OUT DWORD *lpdwCurrentState);       // current state

//$--HrGetExchangeServiceStatus----------------------------------------------
//  Get the current state of an Exchange service on a given machine.
// -----------------------------------------------------------------------------
HRESULT HrGetExchangeServiceStatus(  // RETURNS: return code
    IN LPSTR lpszMachineName,           // machine name
    IN  DWORD dwService,                // service
    OUT DWORD *lpdwCurrentState);       // current state

//$--FMachineExists---------------------------------------------------------
//  Returns TRUE if the computer exists.
// -----------------------------------------------------------------------------
BOOL FMachineExists(                // RETURNS: TRUE/FALSE
    IN LPSTR  lpszComputerName);        // address of name of remote computer 

//$--_HrFindFile--------------------------------------------------------------
//  Find a file in a directory subtree.
// -----------------------------------------------------------------------------
HRESULT _HrFindFile(                  // RETURNS: return code
    IN LPSTR lpszInPathName,            // starting path name
    IN LPSTR lpszInFileName,            // file name
    OUT LPSTR lpszOutPathName);         // path name where file first found

//$--GetSystemEnvironmentVariable-----------------------------------------------
//  Gets a system environment variable.
// -----------------------------------------------------------------------------
DWORD GetSystemEnvironmentVariable(     // RETURNS: size of value
    IN LPSTR  lpszName,                 // environment variable name 
    OUT LPSTR  lpszValue,               // buffer for variable value 
    OUT DWORD  cchValue);               // size of buffer, in characters 

//$--SetSystemEnvironmentVariable-----------------------------------------------
//  Sets a system environment variable permanently.
// -----------------------------------------------------------------------------
BOOL SetSystemEnvironmentVariable(      // RETURNS: TRUE/FALSE
    IN LPCSTR  lpszName,                // environment variable name  
    IN LPCSTR  lpszValue);              // new value for variable 

//$--GetUserEnvironmentVariable-------------------------------------------------
//  Gets a user environment variable.
// -----------------------------------------------------------------------------
DWORD GetUserEnvironmentVariable(       // RETURNS: size of value
    IN LPSTR  lpszName,                 // environment variable name 
    OUT LPSTR  lpszValue,               // buffer for variable value 
    OUT DWORD  cchValue);               // size of buffer, in characters 

//$--SetUserEnvironmentVariable-------------------------------------------------
//  Sets a user environment variable permanently.
// -----------------------------------------------------------------------------
BOOL SetUserEnvironmentVariable(        // RETURNS: TRUE/FALSE
    IN LPCSTR  lpszName,                // environment variable name  
    IN LPCSTR  lpszValue);              // new value for variable 

//$--HrTextToRTFCompressed---------------------------------------------------
//  Convert plain ANSI text to its RTF compressed equivalent for a message.
// -----------------------------------------------------------------------------
HRESULT HrTextToRTFCompressed(       // RETURNS: return code
    IN ULONG cchText,                   // # of characters of text
    IN LPSTREAM lpText,                 // plain text stream pointer
	IN ULONG cAttachments,	            // # of message attachments
	IN ULONG * rgiRendering,            // attachment rendering positions
    IN LPMESSAGE lpMsg,                 // message pointer
	IN ULONG cpid);                     // code page for the text stream

//$--HrRTFCompressedToText---------------------------------------------------
//  Convert message's compressed RTF to its ANSI equivalent.
// -----------------------------------------------------------------------------
HRESULT HrRTFCompressedToText(       // RETURNS: return code
            IN LPMESSAGE lpMsg,         // MAPI message pointer
            IN LPSTREAM pText,          // stream to copy ANSI text to
			IN ULONG cpid,				// code page for  the text stream
            OUT ULONG * pcb);           // # bytes copied to stream

//$--HrStrTokAll@---------------------------------------------------------------
//  Splits string lpsz at token separators and points elements of array
//  *lpppsz to string components.
//------------------------------------------------------------------------------
HRESULT HrStrTokAllW(                   // RETURNS: return code
    IN LPCWSTR lpsz,                    // separated string
    IN LPCWSTR lpszEOT,                 // pointer to string containing separators
    OUT ULONG * lpcpsz,                 // count of string pointers
    OUT LPWSTR ** lpppsz);              // pointer to list of strings

HRESULT HrStrTokAllA(                   // RETURNS: return code
    IN LPCSTR lpsz,                     // separated string
    IN LPCSTR lpszEOT,                  // pointer to string containing separators
    OUT ULONG * lpcpsz,                 // count of string pointers
    OUT LPSTR ** lpppsz);               // pointer to list of strings

#ifdef UNICODE
#define HrStrTokAll HrStrTokAllW
#else
#define HrStrTokAll HrStrTokAllA
#endif

//$--HrCreateProfileName-----------------------------------------------------
//  Create a unique profile name.
// -----------------------------------------------------------------------------
HRESULT HrCreateProfileName(         // RETURNS: return code
    IN  LPSTR lpszPrefix,               // prefix of profile name
    IN  ULONG  cBufferSize,             // size of buffer in bytes
    IN OUT LPSTR lpszBuffer);           // buffer

//$--HrGetFileVersionInfo----------------------------------------------------
//  Get the file version information.
// -----------------------------------------------------------------------------
HRESULT HrGetFileVersionInfo(        // RETURNS: return code
    IN  LPSTR lpszFileName,             // file name
    OUT LPVOID *lppVersionInfo);        // file version information

//$--_GetFileNameFromFullPath--------------------------------------------------
//  Return a pointer to the file name.
// -----------------------------------------------------------------------------
LPSTR _GetFileNameFromFullPath(       // RETURNS: file name
    IN LPSTR lpszFullPath);            // full path name

//$--HrCreateDirEntryIdEx-------------------------------------------------------
//  Create a directory entry ID given the address of the object
//  in the directory.
// -----------------------------------------------------------------------------
HRESULT HrCreateDirEntryIdEx(			// RETURNS: HRESULT
	IN	LPADRBOOK	lpAdrBook,			// address book (directory) to look in
	IN	LPSTR		lpszDN,				// object distinguished name
	OUT	ULONG *		lpcbEntryID,		// count of bytes in entry ID
	OUT	LPENTRYID * lppEntryID);	    // pointer to entry ID

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\edksetup.h ===
// --edksetup.h-----------------------------------------------------------------
// 
// Copyright 1986 - 1998 Microsoft Corporation.  All Rights Reserved.
// -----------------------------------------------------------------------------
#if !defined(_EDKSETUP_H)
#define _EDkSETUP_H

#include <windows.h>

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

#include "msdetect.h"
#include "msregdb.h"
#include "msshared.h"
#include "setupapi.h"

//$--HrSendProgManCommand----------------------------------------------------
//  Send one or more commands to the program manager.
// -----------------------------------------------------------------------------
HRESULT HrSendProgManCommand(    // RETURNS: return code
    LPDWORD lpIdInst,               // pointer to instance ID
    LPSTR lpszCommand);             // pointer to command string

//$--HrGetProgManGroups------------------------------------------------------
//  Get the names of all the program groups.
// -----------------------------------------------------------------------------
HRESULT HrGetProgManGroups(      // RETURNS: return code
    LPDWORD lpIdInst,               // pointer to instance ID
    LPSTR *lppszGroups);            // pointer to groups string address variable

//$--AppendSlash----------------------------------------------------------------
//  This function will append a backslash to a string if one does not
//  already exist.
// -----------------------------------------------------------------------------
void AppendSlash(                       // RETURNS: nothing
    IN OUT LPSTR sz1);                  // string

//$--RemoveTrailingSlash--------------------------------------------------------
//  This function will remove a trailing slash from a string if it exists.
//  It will NOT remove trailing slash from "X:\".
// -----------------------------------------------------------------------------
void RemoveTrailingSlash(               // RETURNS: nothing
    IN OUT LPSTR sz1);                  // string

//$--ShowMessageBox-------------------------------------------------------------
//  This displays a localizable message built by the message compiler in a
//  message box.
// -----------------------------------------------------------------------------
int ShowMessageBox(             // RETURNS: message box result
	IN LPCVOID lpSource,        // source of message resource (NULL = embedded)
	IN DWORD dwMessageID,       // message ID
	IN LPSTR lpszTitle,         // title
	IN DWORD dwMsgBoxFlags,     // message box flags
	IN DWORD dwLanguageID,      // language ID
	IN ...);                    // arguments required for the message resource

//$--ExtractPath----------------------------------------------------------------
//  This routine will give the path portion of a file name.
// -----------------------------------------------------------------------------
void ExtractPath(                       // RETURNS: nothing
	IN  CHAR *pszPathName,              // full path name
	OUT	CHAR *pszPath);                 // path name

//$--FEnumFiles-----------------------------------------------------------------
//  This function provides a wrapper for the FindFirstFile() and FindNextFile()
//  functions. Given a search string [Drive:][PATH\\]SearchPattern this 
//  function will place file names (one per call) in pszFileName. When there
//  are no more files that match the search string it will return FALSE. It
//  will filter out the . and .. directories. This function is generally used
//  like this:
//
//      hEnumFile = NULL;
//	    while(fEnumFiles(&hEnumFile, szSearchString, szFileName, &fDir))
//      {
//	        if(fDir) ProcessDir(szFileName);
//	        else     ProcessFile(szFileName);
//		}
//
// -----------------------------------------------------------------------------
BOOL FEnumFiles(                    // RETURNS: TRUE if a file/dir was found
	IN     CHAR   *pszSearchString, // directory & search pattern
	IN OUT HANDLE *phScan,          // a pointer to EnumFiles instance handle 
    OUT    CHAR   *pszFileName,     // current file name
    OUT    BOOL   *pfDir);          // TRUE if a directory was found

//$--DwConnectNetworkShare------------------------------------------------------
//  Connect a local drive letter to a network disk resource.
// -----------------------------------------------------------------------------
DWORD DwConnectNetworkShare(            // RETURNS: return code
	IN  LPSTR lpszUNCName,              // UNC path to network share
	OUT LPSTR lpszDriveLetter);         // drive letter

//$--FGetServiceDirectory-------------------------------------------------------
//  Given a service name, gives the directory to the executable image.
// -----------------------------------------------------------------------------
BOOL FGetServiceDirectory(              // RETURNS: TRUE/FALSE
	IN  LPSTR lpszServiceName,          // service name
	OUT LPSTR lpszServiceDir);          // service directory

//$--FServiceExists-------------------------------------------------------------
//  Ask the Service Control Manager if a particular service exists.
// -----------------------------------------------------------------------------
BOOL FServiceExists(                    // RETURNS: TRUE/FALSE
	IN LPSTR lpszServiceName);          // service

//$--FServiceRunning------------------------------------------------------------
//  Ask the Service Control Manager if a particular service is running. If the
//  service is running, this function will attempt to stop it before returning.
// -----------------------------------------------------------------------------
BOOL FServiceRunning(                   // RETURNS: TRUE/FALSE
	IN LPSTR lpszServiceName);          // service

//$--FDirEmpty------------------------------------------------------------------
//  Checks to see if a given directory is empty.
// -----------------------------------------------------------------------------
BOOL FDirEmpty(                         // RETURNS: TRUE/FALSE
	IN LPSTR lpszDirName);              // directory name

//$--EDKDeleteNode--------------------------------------------------------------
//  This deletes a directory and files and directories contained within.
//  NOTE: This is a recursive function.
// -----------------------------------------------------------------------------
void EDKDeleteNode(                     // RETURNS: nothing
    IN LPSTR lpszDirName);              // directory name

//$--FNetworkAvailable----------------------------------------------------------
//  Checks to see that a network is available
// -----------------------------------------------------------------------------
BOOL FNetworkAvailable(                 // RETURNS: TRUE/FALSE
    void);                              // nothing

//$--FRegisterEventLog----------------------------------------------------------
//  This function registers an application with the event log.
// -----------------------------------------------------------------------------
BOOL FRegisterEventLog(                 // RETURNS: TRUE/FALSE
	IN LPSTR lpszServer,		        // server name
	IN LPSTR lpszApplicationName,       // application name
	IN LPSTR lpszMessageDllName,        // message DLL path name
	IN DWORD dwTypesSupported);         // events supported

//$--FDeregisterEventLog--------------------------------------------------------
//  This function deregisters an application with the Event Log.
// -----------------------------------------------------------------------------
BOOL FDeregisterEventLog(               // RETURNS: TRUE/FALSE
    IN LPSTR lpszServer,                // server name
    IN LPSTR lpszApplicationName);      // application Name 

//$--EscapeBackSlashes----------------------------------------------------------
//  This function copies a string, but doubles the number of backslashes.
// -----------------------------------------------------------------------------
void EscapeBackSlashes(                 // RETURNS: nothing
    IN  LPSTR lpszSrcStr,               // source string
	OUT LPSTR lpszDestStr);             // destination string

//$--FLoadCounters--------------------------------------------------------------
//  Loads the counters by creating a LODCTR.EXE process.	
// -----------------------------------------------------------------------------
BOOL FLoadCounters(                     // RETURNS: TRUE/FALSE
    IN LPSTR lpszFileName);             // INI file name

//$--FUnloadCounters------------------------------------------------------------
//  Unloads the counters by creating a UNLODCTR.EXE process.	
// -----------------------------------------------------------------------------
BOOL FUnloadCounters(                   // RETURNS: TRUE/FALSE
    IN LPSTR lpszClassName);            // service class name

//$--FGetDomainAccountName------------------------------------------------------
//  This function gets the current user's domain acount name.
// -----------------------------------------------------------------------------
BOOL FGetDomainAccountName(             // RETURNS: TRUE/FALSE
    IN OUT DWORD *lpdwDomainSize,       // domain name buffer size
    IN OUT DWORD *lpdwAccountSize,      // account name buffer size
    OUT LPSTR lpszDomainName,           // domain name
    OUT LPSTR lpszAccountName);         // account name

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\edkutcpp.h ===
// EdkUtCpp.h-------------------------------------------------------------------
// Declares a class that supplies a list of id's and strings which can 
// be found by ID.
//
// Copyright 1986 - 1998 Microsoft Corporation.  All Rights Reserved.
// -----------------------------------------------------------------------------

#ifndef _EDKUTCPP_H_
#define _EDKUTCPP_H_

// -----------------------------------------------------------------------------
// Use this structure to create your list.
// -----------------------------------------------------------------------------

typedef struct _IDList
{
    ULONG   ulID;
    LPSTR   pszValue;
} IDList, *PIDList;

// -----------------------------------------------------------------------------

class CIDList
{
public:    
    // CONSTRUCTOR: Use ARRAY_CNT( IDListArray) to pass nCnt.
    CIDList( 
        PIDList pIDList,    // Pointer to array of IDList.
        UINT nCnt);         // Number of items in the list.

    // Find an ID in the pIDList and return it's string.
    const LPSTR Find(   // Returns the string found or a not found message string.
        ULONG ulID);    // ID to search for.

protected:    
    PIDList m_pIDList;        // Contains a ptr to the ID List array.
    UINT    m_nCnt;           // Number of items in the array.
    char    m_chNotFound[30]; // Will contain the last id not found message. The 
                              // largest value will be "(ID: 0x012345678 not found)".
};

// -----------------------------------------------------------------------------

#endif //_EDKUTCPP_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\edkmdb.h ===
/*
 *	EDKMDB.H
 *
 *	Microsoft Exchange Information Store
 *	Copyright (C) 1986-1996, Microsoft Corporation
 *
 *	Contains declarations of additional properties and interfaces
 *	offered by Microsoft Exchange Information Store
 */

#ifndef	EDKMDB_INCLUDED
#define	EDKMDB_INCLUDED

/*
 *	WARNING: Many of the property id values contained within this
 *  file are subject to change.  For best results please use the
 *	literals declared here instead of the numerical values.
 */

#define pidExchangeXmitReservedMin		0x3FE0
#define pidExchangeNonXmitReservedMin	0x65E0
#define	pidProfileMin					0x6600
#define	pidStoreMin						0x6618
#define	pidFolderMin					0x6638
#define	pidMessageReadOnlyMin			0x6640
#define	pidMessageWriteableMin			0x6658
#define	pidAttachReadOnlyMin			0x666C
#define	pidSpecialMin					0x6670
#define	pidAdminMin						0x6690
#define pidSecureProfileMin				PROP_ID_SECURE_MIN

/*------------------------------------------------------------------------
 *
 *	PROFILE properties
 *
 *	These are used in profiles which contain the Exchange Messaging
 *	Service.  These profiles contain a "global section" used to store
 *	common data, plus individual sections for the transport provider,
 *	one store provider for the user, one store provider for the public
 *	store, and one store provider for each additional mailbox the user
 *	has delegate access to.
 *
 *-----------------------------------------------------------------------*/

/* GUID of the global section */

#define	pbGlobalProfileSectionGuid	"\x13\xDB\xB0\xC8\xAA\x05\x10\x1A\x9B\xB0\x00\xAA\x00\x2F\xC4\x5A"


/* Properties in the global section */

#define	PR_PROFILE_VERSION				PROP_TAG( PT_LONG, pidProfileMin+0x00)
#define	PR_PROFILE_CONFIG_FLAGS			PROP_TAG( PT_LONG, pidProfileMin+0x01)
#define	PR_PROFILE_HOME_SERVER			PROP_TAG( PT_STRING8, pidProfileMin+0x02)
#define	PR_PROFILE_HOME_SERVER_DN		PROP_TAG( PT_STRING8, pidProfileMin+0x12)
#define	PR_PROFILE_HOME_SERVER_ADDRS	PROP_TAG( PT_MV_STRING8, pidProfileMin+0x13)
#define	PR_PROFILE_USER					PROP_TAG( PT_STRING8, pidProfileMin+0x03)
#define	PR_PROFILE_CONNECT_FLAGS		PROP_TAG( PT_LONG, pidProfileMin+0x04)
#define PR_PROFILE_TRANSPORT_FLAGS		PROP_TAG( PT_LONG, pidProfileMin+0x05)
#define	PR_PROFILE_UI_STATE				PROP_TAG( PT_LONG, pidProfileMin+0x06)
#define	PR_PROFILE_UNRESOLVED_NAME		PROP_TAG( PT_STRING8, pidProfileMin+0x07)
#define	PR_PROFILE_UNRESOLVED_SERVER	PROP_TAG( PT_STRING8, pidProfileMin+0x08)
#define PR_PROFILE_BINDING_ORDER		PROP_TAG( PT_STRING8, pidProfileMin+0x09)
#define PR_PROFILE_MAX_RESTRICT			PROP_TAG( PT_LONG, pidProfileMin+0x0D)
#define	PR_PROFILE_AB_FILES_PATH		PROP_TAG( PT_STRING8, pidProfileMin+0xE)
#define PR_PROFILE_OFFLINE_STORE_PATH	PROP_TAG( PT_STRING8, pidProfileMin+0x10)
#define PR_PROFILE_OFFLINE_INFO			PROP_TAG( PT_BINARY, pidProfileMin+0x11)
#define PR_PROFILE_ADDR_INFO			PROP_TAG( PT_BINARY, pidSpecialMin+0x17)
#define PR_PROFILE_OPTIONS_DATA			PROP_TAG( PT_BINARY, pidSpecialMin+0x19)
#define PR_PROFILE_SECURE_MAILBOX		PROP_TAG( PT_BINARY, pidSecureProfileMin + 0)
#define PR_DISABLE_WINSOCK				PROP_TAG( PT_LONG, pidProfileMin+0x18)

/* Properties passed through the Service Entry to the OST */
#define PR_OST_ENCRYPTION				PROP_TAG(PT_LONG, 0x6702)

/* Values for PR_OST_ENCRYPTION */
#define OSTF_NO_ENCRYPTION              ((DWORD)0x80000000)
#define OSTF_COMPRESSABLE_ENCRYPTION    ((DWORD)0x40000000)
#define OSTF_BEST_ENCRYPTION            ((DWORD)0x20000000)

/* Properties in each profile section */

#define	PR_PROFILE_OPEN_FLAGS			PROP_TAG( PT_LONG, pidProfileMin+0x09)
#define	PR_PROFILE_TYPE					PROP_TAG( PT_LONG, pidProfileMin+0x0A)
#define	PR_PROFILE_MAILBOX				PROP_TAG( PT_STRING8, pidProfileMin+0x0B)
#define	PR_PROFILE_SERVER				PROP_TAG( PT_STRING8, pidProfileMin+0x0C)
#define	PR_PROFILE_SERVER_DN			PROP_TAG( PT_STRING8, pidProfileMin+0x14)

/* Properties in the Public Folders section */

#define PR_PROFILE_FAVFLD_DISPLAY_NAME	PROP_TAG(PT_STRING8, pidProfileMin+0x0F)
#define PR_PROFILE_FAVFLD_COMMENT		PROP_TAG(PT_STRING8, pidProfileMin+0x15)
#define PR_PROFILE_ALLPUB_DISPLAY_NAME	PROP_TAG(PT_STRING8, pidProfileMin+0x16)
#define PR_PROFILE_ALLPUB_COMMENT		PROP_TAG(PT_STRING8, pidProfileMin+0x17)

// Current value for PR_PROFILE_VERSION
#define	PROFILE_VERSION						((ULONG)0x501)

// Bit values for PR_PROFILE_CONFIG_FLAGS

#define	CONFIG_SERVICE						((ULONG)1)
#define	CONFIG_SHOW_STARTUP_UI				((ULONG)2)
#define	CONFIG_SHOW_CONNECT_UI				((ULONG)4)
#define	CONFIG_PROMPT_FOR_CREDENTIALS		((ULONG)8)

// Bit values for PR_PROFILE_CONNECT_FLAGS

#define	CONNECT_USE_ADMIN_PRIVILEGE			((ULONG)1)
#define	CONNECT_NO_RPC_ENCRYPTION			((ULONG)2)

// Bit values for PR_PROFILE_TRANSPORT_FLAGS

#define	TRANSPORT_DOWNLOAD					((ULONG)1)
#define TRANSPORT_UPLOAD					((ULONG)2)

// Bit values for PR_PROFILE_OPEN_FLAGS

#define	OPENSTORE_USE_ADMIN_PRIVILEGE		((ULONG)1)
#define OPENSTORE_PUBLIC					((ULONG)2)
#define	OPENSTORE_HOME_LOGON				((ULONG)4)
#define OPENSTORE_TAKE_OWNERSHIP			((ULONG)8)
#define OPENSTORE_OVERRIDE_HOME_MDB			((ULONG)16)
#define OPENSTORE_TRANSPORT					((ULONG)32)
#define OPENSTORE_REMOTE_TRANSPORT			((ULONG)64)

// Values for PR_PROFILE_TYPE

#define	PROFILE_PRIMARY_USER				((ULONG)1)
#define	PROFILE_DELEGATE					((ULONG)2)
#define	PROFILE_PUBLIC_STORE				((ULONG)3)
#define	PROFILE_SUBSCRIPTION				((ULONG)4)


/*------------------------------------------------------------------------
 *
 *	MDB object properties
 *
 *-----------------------------------------------------------------------*/

/* PR_MDB_PROVIDER GUID in stores table */

#define pbExchangeProviderPrimaryUserGuid	"\x54\x94\xA1\xC0\x29\x7F\x10\x1B\xA5\x87\x08\x00\x2B\x2A\x25\x17"
#define pbExchangeProviderDelegateGuid		"\x9e\xb4\x77\x00\x74\xe4\x11\xce\x8c\x5e\x00\xaa\x00\x42\x54\xe2"
#define pbExchangeProviderPublicGuid		"\x78\xb2\xfa\x70\xaf\xf7\x11\xcd\x9b\xc8\x00\xaa\x00\x2f\xc4\x5a"
#define pbExchangeProviderXportGuid			"\xa9\x06\x40\xe0\xd6\x93\x11\xcd\xaf\x95\x00\xaa\x00\x4a\x35\xc3"

// All properties in this section are readonly

// Identity of store
	// All stores
#define	PR_USER_ENTRYID					PROP_TAG( PT_BINARY, pidStoreMin+0x01)
#define	PR_USER_NAME					PROP_TAG( PT_STRING8, pidStoreMin+0x02)

	// All mailbox stores
#define	PR_MAILBOX_OWNER_ENTRYID		PROP_TAG( PT_BINARY, pidStoreMin+0x03)
#define	PR_MAILBOX_OWNER_NAME			PROP_TAG( PT_STRING8, pidStoreMin+0x04)
#define PR_OOF_STATE					PROP_TAG( PT_BOOLEAN, pidStoreMin+0x05)

	// Public stores -- name of hierarchy server
#define	PR_HIERARCHY_SERVER				PROP_TAG( PT_TSTRING, pidStoreMin+0x1B)

// Entryids of special folders
	// All mailbox stores
#define	PR_SCHEDULE_FOLDER_ENTRYID		PROP_TAG( PT_BINARY, pidStoreMin+0x06)

	// All mailbox and gateway stores
#define PR_IPM_DAF_ENTRYID				PROP_TAG( PT_BINARY, pidStoreMin+0x07)

	// Public store
#define	PR_NON_IPM_SUBTREE_ENTRYID				PROP_TAG( PT_BINARY, pidStoreMin+0x08)
#define	PR_EFORMS_REGISTRY_ENTRYID				PROP_TAG( PT_BINARY, pidStoreMin+0x09)
#define	PR_SPLUS_FREE_BUSY_ENTRYID				PROP_TAG( PT_BINARY, pidStoreMin+0x0A)
#define	PR_OFFLINE_ADDRBOOK_ENTRYID				PROP_TAG( PT_BINARY, pidStoreMin+0x0B)
#define	PR_EFORMS_FOR_LOCALE_ENTRYID			PROP_TAG( PT_BINARY, pidStoreMin+0x0C)
#define	PR_FREE_BUSY_FOR_LOCAL_SITE_ENTRYID		PROP_TAG( PT_BINARY, pidStoreMin+0x0D)
#define	PR_ADDRBOOK_FOR_LOCAL_SITE_ENTRYID		PROP_TAG( PT_BINARY, pidStoreMin+0x0E)
#define	PR_OFFLINE_MESSAGE_ENTRYID				PROP_TAG( PT_BINARY, pidStoreMin+0x0F)
#define PR_IPM_FAVORITES_ENTRYID				PROP_TAG( PT_BINARY, pidStoreMin+0x18)
#define PR_IPM_PUBLIC_FOLDERS_ENTRYID			PROP_TAG( PT_BINARY, pidStoreMin+0x19)

	// Gateway stores
#define	PR_GW_MTSIN_ENTRYID				PROP_TAG( PT_BINARY, pidStoreMin+0x10)
#define	PR_GW_MTSOUT_ENTRYID			PROP_TAG( PT_BINARY, pidStoreMin+0x11)
#define	PR_TRANSFER_ENABLED				PROP_TAG( PT_BOOLEAN, pidStoreMin+0x12)

// This property is preinitialized to 256 bytes of zeros
// GetProp on this property is guaranteed to RPC.  May be used
// to determine line speed of connection to server.
#define	PR_TEST_LINE_SPEED				PROP_TAG( PT_BINARY, pidStoreMin+0x13)

// Used with OpenProperty to get interface, also on folders
#define	PR_HIERARCHY_SYNCHRONIZER		PROP_TAG( PT_OBJECT, pidStoreMin+0x14)
#define	PR_CONTENTS_SYNCHRONIZER		PROP_TAG( PT_OBJECT, pidStoreMin+0x15)
#define	PR_COLLECTOR					PROP_TAG( PT_OBJECT, pidStoreMin+0x16)

// Used with OpenProperty to get interface for folders, messages, attachmentson
#define	PR_FAST_TRANSFER				PROP_TAG( PT_OBJECT, pidStoreMin+0x17)

// This property is available on mailbox and public stores.  If it exists
// and its value is TRUE, the store is connected to the offline store provider.
#define PR_STORE_OFFLINE				PROP_TAG( PT_BOOLEAN, pidStoreMin+0x1A)

// In transit state for store object.  This state is
// set when mail is being moved and it pauses mail delivery
// to the mail box
#define	PR_IN_TRANSIT					PROP_TAG( PT_BOOLEAN, pidStoreMin)

// Writable only with Admin rights, available on public stores and folders
#define PR_REPLICATION_STYLE			PROP_TAG( PT_LONG, pidAdminMin)
#define PR_REPLICATION_SCHEDULE			PROP_TAG( PT_BINARY, pidAdminMin+0x01)
#define PR_REPLICATION_MESSAGE_PRIORITY PROP_TAG( PT_LONG, pidAdminMin+0x02)

// Writable only with Admin rights, available on public stores
#define PR_OVERALL_MSG_AGE_LIMIT		PROP_TAG( PT_LONG, pidAdminMin+0x03 )
#define PR_REPLICATION_ALWAYS_INTERVAL	PROP_TAG( PT_LONG, pidAdminMin+0x04 )
#define PR_REPLICATION_MSG_SIZE			PROP_TAG( PT_LONG, pidAdminMin+0x05 )

// default replication style=always interval (minutes)
#define STYLE_ALWAYS_INTERVAL_DEFAULT	(ULONG) 15

// default replication message size limit (KB)
#define REPLICATION_MESSAGE_SIZE_LIMIT_DEFAULT	(ULONG) 100

// Values for PR_REPLICATION_STYLE
#define STYLE_NEVER				(ULONG) 0	// never replicate
#define STYLE_NORMAL			(ULONG) 1	// use 84 byte schedule TIB
#define STYLE_ALWAYS			(ULONG) 2	// replicate at fastest rate
#define STYLE_DEFAULT			(ULONG) -1	// default value

/*------------------------------------------------------------------------
 *
 *	INCREMENTAL CHANGE SYNCHRONIZATION
 *	folder and message properties
 *
 *-----------------------------------------------------------------------*/

#define PR_SOURCE_KEY					PROP_TAG( PT_BINARY, pidExchangeNonXmitReservedMin+0x0)
#define PR_PARENT_SOURCE_KEY			PROP_TAG( PT_BINARY, pidExchangeNonXmitReservedMin+0x1)
#define PR_CHANGE_KEY					PROP_TAG( PT_BINARY, pidExchangeNonXmitReservedMin+0x2)
#define PR_PREDECESSOR_CHANGE_LIST		PROP_TAG( PT_BINARY, pidExchangeNonXmitReservedMin+0x3)

/*------------------------------------------------------------------------
 *
 *	FOLDER object properties
 *
 *-----------------------------------------------------------------------*/

// Read only, available on all folders
#define	PR_FOLDER_CHILD_COUNT			PROP_TAG( PT_LONG, pidFolderMin)
#define	PR_RIGHTS						PROP_TAG( PT_LONG, pidFolderMin+0x01)
#define	PR_ACL_TABLE					PROP_TAG( PT_OBJECT, pidExchangeXmitReservedMin)
#define	PR_RULES_TABLE					PROP_TAG( PT_OBJECT, pidExchangeXmitReservedMin+0x1)
#define	PR_HAS_RULES				PROP_TAG( PT_BOOLEAN, pidFolderMin+0x02)

//Read only, available only for public folders
#define	PR_ADDRESS_BOOK_ENTRYID		PROP_TAG( PT_BINARY, pidFolderMin+0x03)

//Writable, available on folders in all stores
#define	PR_ACL_DATA					PROP_TAG( PT_BINARY, pidExchangeXmitReservedMin)
#define	PR_RULES_DATA				PROP_TAG( PT_BINARY, pidExchangeXmitReservedMin+0x1)
#define	PR_FOLDER_DESIGN_FLAGS		PROP_TAG( PT_LONG, pidExchangeXmitReservedMin+0x2)
#define	PR_DESIGN_IN_PROGRESS		PROP_TAG( PT_BOOLEAN, pidExchangeXmitReservedMin+0x4)
#define	PR_SECURE_ORIGINATION		PROP_TAG( PT_BOOLEAN, pidExchangeXmitReservedMin+0x5)

//Writable, available only for public folders
#define	PR_PUBLISH_IN_ADDRESS_BOOK	PROP_TAG( PT_BOOLEAN, pidExchangeXmitReservedMin+0x6)
#define	PR_RESOLVE_METHOD			PROP_TAG( PT_LONG,  pidExchangeXmitReservedMin+0x7)
#define	PR_ADDRESS_BOOK_DISPLAY_NAME	PROP_TAG( PT_TSTRING, pidExchangeXmitReservedMin+0x8)

//Writable, used to indicate locale id for eforms registry subfolders
#define	PR_EFORMS_LOCALE_ID			PROP_TAG( PT_LONG, pidExchangeXmitReservedMin+0x9)

// Writable only with Admin rights, available only for public folders
#define PR_REPLICA_LIST				PROP_TAG( PT_BINARY, pidAdminMin+0x8)
#define PR_OVERALL_AGE_LIMIT		PROP_TAG( PT_LONG, pidAdminMin+0x9)

//PR_RESOLVE_METHOD values
#define	RESOLVE_METHOD_DEFAULT			((LONG)0)	// default handling attach conflicts
#define	RESOLVE_METHOD_LAST_WRITER_WINS	((LONG)1)	// the last writer will win conflict
#define	RESOLVE_METHOD_NO_CONFLICT_NOTIFICATION ((LONG)2) // no conflict notif

//Read only, available only for public folder favorites
#define PR_PUBLIC_FOLDER_ENTRYID	PROP_TAG( PT_BINARY, pidFolderMin+0x04)

/*------------------------------------------------------------------------
 *
 *	MESSAGE object properties
 *
 *-----------------------------------------------------------------------*/

// Read only, automatically set on all messages in all stores
#define	PR_HAS_NAMED_PROPERTIES			PROP_TAG(PT_BOOLEAN, pidMessageReadOnlyMin+0x0A)

// Read only but outside the provider specific range for replication thru GDK-GWs
#define	PR_CREATOR_NAME					PROP_TAG(PT_TSTRING, pidExchangeXmitReservedMin+0x18)
#define	PR_CREATOR_ENTRYID				PROP_TAG(PT_BINARY, pidExchangeXmitReservedMin+0x19)
#define	PR_LAST_MODIFIER_NAME			PROP_TAG(PT_TSTRING, pidExchangeXmitReservedMin+0x1A)
#define	PR_LAST_MODIFIER_ENTRYID		PROP_TAG(PT_BINARY, pidExchangeXmitReservedMin+0x1B)

// Read only, appears on messages which have DAM's pointing to them
#define PR_HAS_DAMS						PROP_TAG( PT_BOOLEAN, pidExchangeXmitReservedMin+0xA)
#define PR_RULE_TRIGGER_HISTORY			PROP_TAG( PT_BINARY, pidExchangeXmitReservedMin+0x12)
#define	PR_MOVE_TO_STORE_ENTRYID		PROP_TAG( PT_BINARY, pidExchangeXmitReservedMin+0x13)
#define	PR_MOVE_TO_FOLDER_ENTRYID		PROP_TAG( PT_BINARY, pidExchangeXmitReservedMin+0x14)

// Read only, available only on messages in the public store
#define	PR_REPLICA_SERVER				PROP_TAG(PT_TSTRING, pidMessageReadOnlyMin+0x4)

// Writeable, used for recording send option dialog settings
#define	PR_DEFERRED_SEND_NUMBER			PROP_TAG( PT_LONG, pidExchangeXmitReservedMin+0xB)
#define	PR_DEFERRED_SEND_UNITS			PROP_TAG( PT_LONG, pidExchangeXmitReservedMin+0xC)
#define	PR_EXPIRY_NUMBER				PROP_TAG( PT_LONG, pidExchangeXmitReservedMin+0xD)
#define	PR_EXPIRY_UNITS					PROP_TAG( PT_LONG, pidExchangeXmitReservedMin+0xE)

// Writeable, deferred send time
#define PR_DEFERRED_SEND_TIME			PROP_TAG( PT_SYSTIME, pidExchangeXmitReservedMin+0xF)

//Writeable, intended for both folders and messages in gateway mailbox
#define	PR_GW_ADMIN_OPERATIONS			PROP_TAG( PT_LONG, pidMessageWriteableMin)

//Writeable, used for DMS messages
#define PR_P1_CONTENT					PROP_TAG( PT_BINARY, 0x1100)
#define PR_P1_CONTENT_TYPE				PROP_TAG( PT_BINARY, 0x1101)

// Properties on deferred action messages
#define	PR_CLIENT_ACTIONS		  		PROP_TAG(PT_BINARY, pidMessageReadOnlyMin+0x5)
#define	PR_DAM_ORIGINAL_ENTRYID			PROP_TAG(PT_BINARY, pidMessageReadOnlyMin+0x6)
#define PR_DAM_BACK_PATCHED				PROP_TAG( PT_BOOLEAN, pidMessageReadOnlyMin+0x7)

// Properties on deferred action error messages
#define	PR_RULE_ERROR					PROP_TAG(PT_LONG, pidMessageReadOnlyMin+0x8)
#define	PR_RULE_ACTION_TYPE				PROP_TAG(PT_LONG, pidMessageReadOnlyMin+0x9)
#define	PR_RULE_ACTION_NUMBER			PROP_TAG(PT_LONG, pidMessageReadOnlyMin+0x10)
#define PR_RULE_FOLDER_ENTRYID			PROP_TAG(PT_BINARY, pidMessageReadOnlyMin+0x11)

// Property on conflict notification indicating entryid of conflicting object
#define	PR_CONFLICT_ENTRYID				PROP_TAG(PT_BINARY, pidExchangeXmitReservedMin+0x10)

// Property on messages to indicate the language client used to create this message
#define	PR_MESSAGE_LOCALE_ID			PROP_TAG(PT_LONG, pidExchangeXmitReservedMin+0x11)

// Properties on Quota warning messages to indicate Storage quota and Excess used
#define	PR_STORAGE_QUOTA_LIMIT			PROP_TAG(PT_LONG, pidExchangeXmitReservedMin+0x15)
#define	PR_EXCESS_STORAGE_USED			PROP_TAG(PT_LONG, pidExchangeXmitReservedMin+0x16)
#define PR_SVR_GENERATING_QUOTA_MSG		PROP_TAG(PT_TSTRING, pidExchangeXmitReservedMin+0x17)

// Property affixed by delegation rule and deleted on forwards
#define PR_DELEGATED_BY_RULE			PROP_TAG( PT_BOOLEAN, pidExchangeXmitReservedMin+0x3)

// Message status bit used to indicate message is in conflict
#define	MSGSTATUS_IN_CONFLICT			((ULONG) 0x800)

/*------------------------------------------------------------------------
 *
 *	ATTACHMENT object properties
 *
 *-----------------------------------------------------------------------*/

// Appears on attachments to a message marked to be in conflict.  Identifies
// those attachments which are conflicting versions of the top level message
#define	PR_IN_CONFLICT					PROP_TAG(PT_BOOLEAN, pidAttachReadOnlyMin)


/*------------------------------------------------------------------------
 *
 *	TABLE object properties
 *
 *	Id Range: 0x662F-0x662F
 *
 *-----------------------------------------------------------------------*/

//This property can be used in a contents table to get PR_ENTRYID returned
//as a long term entryid instead of a short term entryid.
#define	PR_LONGTERM_ENTRYID_FROM_TABLE	PROP_TAG(PT_BINARY, pidSpecialMin)


/*------------------------------------------------------------------------
 *
 *	Gateway "MTE" ENVELOPE properties
 *
 *	Id Range:  0x66E0-0x66FF
 *
 *-----------------------------------------------------------------------*/

#define PR_ORIGINATOR_NAME				PROP_TAG( PT_TSTRING, pidMessageWriteableMin+0x3)
#define PR_ORIGINATOR_ADDR				PROP_TAG( PT_TSTRING, pidMessageWriteableMin+0x4)
#define PR_ORIGINATOR_ADDRTYPE			PROP_TAG( PT_TSTRING, pidMessageWriteableMin+0x5)
#define PR_ORIGINATOR_ENTRYID			PROP_TAG( PT_BINARY, pidMessageWriteableMin+0x6)
#define PR_ARRIVAL_TIME					PROP_TAG( PT_SYSTIME, pidMessageWriteableMin+0x7)
#define PR_TRACE_INFO					PROP_TAG( PT_BINARY, pidMessageWriteableMin+0x8)
#define PR_INTERNAL_TRACE_INFO 			PROP_TAG( PT_BINARY, pidMessageWriteableMin+0x12)
#define PR_SUBJECT_TRACE_INFO			PROP_TAG( PT_BINARY, pidMessageWriteableMin+0x9)
#define PR_RECIPIENT_NUMBER				PROP_TAG( PT_LONG, pidMessageWriteableMin+0xA)
#define PR_MTS_SUBJECT_ID				PROP_TAG(PT_BINARY, pidMessageWriteableMin+0xB)
#define PR_REPORT_DESTINATION_NAME		PROP_TAG(PT_TSTRING, pidMessageWriteableMin+0xC)
#define PR_REPORT_DESTINATION_ENTRYID	PROP_TAG(PT_BINARY, pidMessageWriteableMin+0xD)
#define PR_CONTENT_SEARCH_KEY			PROP_TAG(PT_BINARY, pidMessageWriteableMin+0xE)
#define PR_FOREIGN_ID					PROP_TAG(PT_BINARY, pidMessageWriteableMin+0xF)
#define PR_FOREIGN_REPORT_ID			PROP_TAG(PT_BINARY, pidMessageWriteableMin+0x10)
#define PR_FOREIGN_SUBJECT_ID			PROP_TAG(PT_BINARY, pidMessageWriteableMin+0x11)
#define PR_MTS_ID						PR_MESSAGE_SUBMISSION_ID
#define PR_MTS_REPORT_ID				PR_MESSAGE_SUBMISSION_ID


/*------------------------------------------------------------------------
 *
 *	Trace properties format
 *		PR_TRACE_INFO
 *		PR_INTERNAL_TRACE_INFO
 *
 *-----------------------------------------------------------------------*/

#define MAX_ADMD_NAME_SIZ       17
#define MAX_PRMD_NAME_SIZ       17
#define MAX_COUNTRY_NAME_SIZ    4
#define MAX_MTA_NAME_SIZ		33

#define	ADMN_PAD				3
#define	PRMD_PAD				3
#define	COUNTRY_PAD				0
#define	MTA_PAD					3

typedef struct {
    LONG     lAction;                // The routing action the tracing site
                                     // took.
    FILETIME ftArrivalTime;          // The time at which the communique
                                     // entered the tracing site.
    FILETIME ftDeferredTime;         // The time are which the tracing site
                                     // released the message.
    char     rgchADMDName[MAX_ADMD_NAME_SIZ+ADMN_PAD];           	// ADMD
    char     rgchCountryName[MAX_COUNTRY_NAME_SIZ+COUNTRY_PAD]; 	// Country
    char     rgchPRMDId[MAX_PRMD_NAME_SIZ+PRMD_PAD];              	// PRMD
    char     rgchAttADMDName[MAX_ADMD_NAME_SIZ+ADMN_PAD];       	// Attempted ADMD
    char     rgchAttCountryName[MAX_COUNTRY_NAME_SIZ+COUNTRY_PAD];  // Attempted Country
    char     rgchAttPRMDId[MAX_PRMD_NAME_SIZ+PRMD_PAD];				// Attempted PRMD
}   TRACEENTRY, FAR * LPTRACEENTRY;

typedef struct {
    ULONG       cEntries;               // Number of trace entries
    TRACEENTRY  rgtraceentry[MAPI_DIM]; // array of trace entries
} TRACEINFO, FAR * LPTRACEINFO;

typedef struct
{
	LONG		lAction;				// The routing action the tracing domain took.
	FILETIME	ftArrivalTime;			// The time at which the communique entered the tracing domain.
	FILETIME	ftDeferredTime;			// The time are which the tracing domain released the message.

    char        rgchADMDName[MAX_ADMD_NAME_SIZ+ADMN_PAD];				// ADMD
    char        rgchCountryName[MAX_COUNTRY_NAME_SIZ+COUNTRY_PAD]; 		// Country
    char        rgchPRMDId[MAX_PRMD_NAME_SIZ+PRMD_PAD];             	// PRMD
    char        rgchAttADMDName[MAX_ADMD_NAME_SIZ+ADMN_PAD];       		// Attempted ADMD
    char        rgchAttCountryName[MAX_COUNTRY_NAME_SIZ+COUNTRY_PAD];	// Attempted Country
    char        rgchAttPRMDId[MAX_PRMD_NAME_SIZ+PRMD_PAD];		        // Attempted PRMD
    char        rgchMTAName[MAX_MTA_NAME_SIZ+MTA_PAD]; 		            // MTA Name
    char        rgchAttMTAName[MAX_MTA_NAME_SIZ+MTA_PAD];		        // Attempted MTA Name
}INTTRACEENTRY, *PINTTRACEENTRY;

typedef	struct
{
	ULONG  			cEntries;					// Number of trace entries
	INTTRACEENTRY	rgIntTraceEntry[MAPI_DIM];	// array of internal trace entries
}INTTRACEINFO, *PINTTRACEINFO;


/*------------------------------------------------------------------------
 *
 *	"IExchangeModifyTable" Interface Declaration
 *
 *	Used for get/set rules and access control on folders.
 *
 *-----------------------------------------------------------------------*/


/* ulRowFlags */
#define ROWLIST_REPLACE		((ULONG)1)

#define ROW_ADD				((ULONG)1)
#define ROW_MODIFY			((ULONG)2)
#define ROW_REMOVE			((ULONG)4)
#define ROW_EMPTY			(ROW_ADD|ROW_REMOVE)

typedef struct _ROWENTRY
{
	ULONG			ulRowFlags;
	ULONG			cValues;
	LPSPropValue	rgPropVals;
} ROWENTRY, FAR * LPROWENTRY;

typedef struct _ROWLIST
{
	ULONG			cEntries;
	ROWENTRY		aEntries[MAPI_DIM];
} ROWLIST, FAR * LPROWLIST;

#define EXCHANGE_IEXCHANGEMODIFYTABLE_METHODS(IPURE)					\
	MAPIMETHOD(GetLastError)											\
		(THIS_	HRESULT						hResult,					\
				ULONG						ulFlags,					\
				LPMAPIERROR FAR *			lppMAPIError) IPURE;		\
	MAPIMETHOD(GetTable)												\
		(THIS_	ULONG						ulFlags,					\
				LPMAPITABLE FAR *			lppTable) IPURE;			\
	MAPIMETHOD(ModifyTable)												\
		(THIS_	ULONG						ulFlags,					\
				LPROWLIST					lpMods) IPURE;

#undef		 INTERFACE
#define		 INTERFACE  IExchangeModifyTable
DECLARE_MAPI_INTERFACE_(IExchangeModifyTable, IUnknown)
{
	MAPI_IUNKNOWN_METHODS(PURE)
	EXCHANGE_IEXCHANGEMODIFYTABLE_METHODS(PURE)
};
#undef	IMPL
#define IMPL

DECLARE_MAPI_INTERFACE_PTR(IExchangeModifyTable,	LPEXCHANGEMODIFYTABLE);

/* Access Control Specifics */

//Properties
#define	PR_MEMBER_ID					PROP_TAG( PT_I8, pidSpecialMin+0x01)
#define	PR_MEMBER_NAME					PROP_TAG( PT_TSTRING, pidSpecialMin+0x02)
#define	PR_MEMBER_ENTRYID				PR_ENTRYID
#define	PR_MEMBER_RIGHTS				PROP_TAG( PT_LONG, pidSpecialMin+0x03)

//Security bits
typedef DWORD RIGHTS;
#define frightsReadAny			0x0000001L
#define	frightsCreate			0x0000002L
#define	frightsEditOwned		0x0000008L
#define	frightsDeleteOwned		0x0000010L
#define	frightsEditAny			0x0000020L
#define	frightsDeleteAny		0x0000040L
#define	frightsCreateSubfolder	0x0000080L
#define	frightsOwner			0x0000100L
#define	frightsContact			0x0000200L	// NOTE: not part of rightsAll
#define	rightsNone				0x00000000
#define	rightsReadOnly			frightsReadAny
#define	rightsReadWrite			(frightsReadAny|frightsEditAny)
#define	rightsAll				0x00001FBL

/* Rules specifics */

//Property types
#define	PT_SRESTRICTION				((ULONG) 0x00FD)
#define	PT_ACTIONS					((ULONG) 0x00FE)

//Properties in rule table
#define	PR_RULE_ID						PROP_TAG( PT_I8, pidSpecialMin+0x04)
#define	PR_RULE_IDS						PROP_TAG( PT_BINARY, pidSpecialMin+0x05)
#define	PR_RULE_SEQUENCE				PROP_TAG( PT_LONG, pidSpecialMin+0x06)
#define	PR_RULE_STATE					PROP_TAG( PT_LONG, pidSpecialMin+0x07)
#define	PR_RULE_USER_FLAGS				PROP_TAG( PT_LONG, pidSpecialMin+0x08)
#define	PR_RULE_CONDITION				PROP_TAG( PT_SRESTRICTION, pidSpecialMin+0x09)
#define	PR_RULE_ACTIONS					PROP_TAG( PT_ACTIONS, pidSpecialMin+0x10)
#define	PR_RULE_PROVIDER				PROP_TAG( PT_STRING8, pidSpecialMin+0x11)
#define	PR_RULE_NAME					PROP_TAG( PT_TSTRING, pidSpecialMin+0x12)
#define	PR_RULE_LEVEL					PROP_TAG( PT_LONG, pidSpecialMin+0x13)
#define	PR_RULE_PROVIDER_DATA			PROP_TAG( PT_BINARY, pidSpecialMin+0x14)

//PR_STATE property values
#define ST_DISABLED			0x0000
#define ST_ENABLED			0x0001
#define ST_ERROR			0x0002
#define ST_ONLY_WHEN_OOF	0x0004
#define ST_KEEP_OOF_HIST	0x0008
#define ST_EXIT_LEVEL		0x0010

#define ST_CLEAR_OOF_HIST	0x80000000

//Empty restriction
#define NULL_RESTRICTION	0xff

// special RELOP for Member of DL
#define RELOP_MEMBER_OF_DL	100

//Action types
typedef enum
{
	OP_MOVE = 1,
	OP_COPY,
	OP_REPLY,
	OP_OOF_REPLY,
	OP_DEFER_ACTION,
	OP_BOUNCE,
	OP_FORWARD,
	OP_DELEGATE,
	OP_TAG,
	OP_DELETE,
	OP_MARK_AS_READ
} ACTTYPE;

// action flavors

// for OP_REPLY
#define	DO_NOT_SEND_TO_ORIGINATOR		1

//scBounceCode values
#define	BOUNCE_MESSAGE_SIZE_TOO_LARGE	(SCODE) MAPI_DIAG_LENGTH_CONSTRAINT_VIOLATD
#define BOUNCE_FORMS_MISMATCH			(SCODE) MAPI_DIAG_RENDITION_UNSUPPORTED
#define BOUNCE_ACCESS_DENIED			(SCODE) MAPI_DIAG_MAIL_REFUSED

//Message class prefix for Reply and OOF Reply templates
#define szReplyTemplateMsgClassPrefix	"IPM.Note.Rules.ReplyTemplate."
#define szOofTemplateMsgClassPrefix		"IPM.Note.Rules.OofTemplate."

//Action structure
typedef struct _action
{
	ACTTYPE		acttype;

	// to indicate which flavour of the action.
	ULONG		ulActionFlavor;

	// Action restriction
	// currently unsed and must be set to NULL
	LPSRestriction	lpRes;

	// currently unused, must be set to 0.
	LPSPropTagArray	lpPropTagArray;

	// User defined flags
	ULONG		ulFlags;

	// padding to align the union on 8 byte boundary
	ULONG		dwAlignPad;

	union
	{
		// used for OP_MOVE and OP_COPY actions
		struct
		{
			ULONG		cbStoreEntryId;
			LPENTRYID	lpStoreEntryId;
			ULONG		cbFldEntryId;
			LPENTRYID	lpFldEntryId;
		} actMoveCopy;

		// used for OP_REPLY and OP_OOF_REPLY actions
		struct
		{
			ULONG		cbEntryId;
			LPENTRYID	lpEntryId;
			GUID		guidReplyTemplate;
		} actReply;

		// used for OP_DEFER_ACTION action
		struct
		{
			ULONG		cbData;
			BYTE		*pbData;
		} actDeferAction;

		// Error code to set for OP_BOUNCE action
		SCODE			scBounceCode;

		// list of address for OP_FORWARD and OP_DELEGATE action
		LPADRLIST		lpadrlist;

		// prop value for OP_TAG action
		SPropValue		propTag;
	};
} ACTION, FAR * LPACTION;

// Rules version
#define EDK_RULES_VERSION		1

//Array of actions
typedef struct _actions
{
	ULONG		ulVersion;		// use the #define above
	UINT		cActions;
	LPACTION	lpAction;
} ACTIONS;

// message class definitions for Deferred Action and Deffered Error messages
#define szDamMsgClass		"IPC.Microsoft Exchange 4.0.Deferred Action"
#define szDemMsgClass		"IPC.Microsoft Exchange 4.0.Deferred Error"

/*
 *	Rule error codes
 *	Values for PR_RULE_ERROR
 */
#define	RULE_ERR_UNKNOWN		1			//general catchall error
#define	RULE_ERR_LOAD			2			//unable to load folder rules
#define	RULE_ERR_DELIVERY		3			//unable to deliver message temporarily
#define	RULE_ERR_PARSING		4			//error while parsing
#define	RULE_ERR_CREATE_DAE		5			//error creating DAE message
#define	RULE_ERR_NO_FOLDER		6			//folder to move/copy doesn't exist
#define	RULE_ERR_NO_RIGHTS		7			//no rights to move/copy into folder
#define	RULE_ERR_CREATE_DAM		8			//error creating DAM
#define RULE_ERR_NO_SENDAS		9			//can not send as another user
#define RULE_ERR_NO_TEMPLATE	10			//reply template is missing
#define RULE_ERR_EXECUTION		11			//error in rule execution
#define RULE_ERR_QUOTA_EXCEEDED	12

#define RULE_ERR_FIRST		RULE_ERR_UNKNOWN
#define RULE_ERR_LAST		RULE_ERR_QUOTA_EXCEEDED

/*------------------------------------------------------------------------
 *
 *	"IExchangeRuleAction" Interface Declaration
 *
 *	Used for get actions from a Deferred Action Message.
 *
 *-----------------------------------------------------------------------*/

#define EXCHANGE_IEXCHANGERULEACTION_METHODS(IPURE)						\
	MAPIMETHOD(ActionCount)												\
		(THIS_	ULONG FAR *					lpcActions) IPURE;			\
	MAPIMETHOD(GetAction)												\
		(THIS_	ULONG						ulActionNumber,				\
				LARGE_INTEGER	*			lpruleid,					\
				LPACTION FAR *				lppAction) IPURE;

#undef		 INTERFACE
#define		 INTERFACE  IExchangeRuleAction
DECLARE_MAPI_INTERFACE_(IExchangeRuleAction, IUnknown)
{
	MAPI_IUNKNOWN_METHODS(PURE)
	EXCHANGE_IEXCHANGERULEACTION_METHODS(PURE)
};
#undef	IMPL
#define IMPL

DECLARE_MAPI_INTERFACE_PTR(IExchangeRuleAction,	LPEXCHANGERULEACTION);

/*------------------------------------------------------------------------
 *
 *	"IExchangeManageStore" Interface Declaration
 *
 *	Used for store management functions.
 *
 *-----------------------------------------------------------------------*/

#define EXCHANGE_IEXCHANGEMANAGESTORE_METHODS(IPURE)					\
	MAPIMETHOD(CreateStoreEntryID)										\
		(THIS_	LPSTR						lpszMsgStoreDN,				\
				LPSTR						lpszMailboxDN,				\
				ULONG						ulFlags,					\
				ULONG FAR *					lpcbEntryID,				\
				LPENTRYID FAR *				lppEntryID) IPURE;			\
	MAPIMETHOD(EntryIDFromSourceKey)									\
		(THIS_	ULONG						cFolderKeySize,				\
				BYTE FAR *					lpFolderSourceKey,			\
				ULONG						cMessageKeySize,			\
				BYTE FAR *					lpMessageSourceKey,			\
				ULONG FAR *					lpcbEntryID,				\
				LPENTRYID FAR *				lppEntryID) IPURE;			\
	MAPIMETHOD(GetRights)												\
		(THIS_	ULONG						cbUserEntryID,				\
				LPENTRYID					lpUserEntryID,				\
				ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID,					\
				ULONG FAR *					lpulRights) IPURE;			\
	MAPIMETHOD(GetMailboxTable)											\
		(THIS_	LPSTR						lpszServerName,				\
				LPMAPITABLE FAR *			lppTable,					\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(GetPublicFolderTable)									\
		(THIS_	LPSTR						lpszServerName,				\
				LPMAPITABLE FAR *			lppTable,					\
				ULONG						ulFlags) IPURE;

#undef		 INTERFACE
#define		 INTERFACE  IExchangeManageStore
DECLARE_MAPI_INTERFACE_(IExchangeManageStore, IUnknown)
{
	MAPI_IUNKNOWN_METHODS(PURE)
	EXCHANGE_IEXCHANGEMANAGESTORE_METHODS(PURE)
};
#undef	IMPL
#define IMPL

DECLARE_MAPI_INTERFACE_PTR(IExchangeManageStore, LPEXCHANGEMANAGESTORE);


// Properties for GetMailboxTable
#define PR_NT_USER_NAME                         PROP_TAG( PT_TSTRING, pidAdminMin+0x10)
#define PR_LOCALE_ID                            PROP_TAG( PT_LONG, pidAdminMin+0x11 )
#define PR_LAST_LOGON_TIME                      PROP_TAG( PT_SYSTIME, pidAdminMin+0x12 )
#define PR_LAST_LOGOFF_TIME                     PROP_TAG( PT_SYSTIME, pidAdminMin+0x13 )
#define PR_STORAGE_LIMIT_INFORMATION			PROP_TAG( PT_LONG, pidAdminMin+0x14 )

// Properties for GetPublicFolderTable
#define PR_FOLDER_FLAGS                         PROP_TAG( PT_LONG, pidAdminMin+0x18 )
#define	PR_LAST_ACCESS_TIME						PROP_TAG( PT_SYSTIME, pidAdminMin+0x19 )
#define PR_RESTRICTION_COUNT                    PROP_TAG( PT_LONG, pidAdminMin+0x1A )
#define PR_CATEG_COUNT                          PROP_TAG( PT_LONG, pidAdminMin+0x1B )
#define PR_CACHED_COLUMN_COUNT                  PROP_TAG( PT_LONG, pidAdminMin+0x1C )
#define PR_NORMAL_MSG_W_ATTACH_COUNT    		PROP_TAG( PT_LONG, pidAdminMin+0x1D )
#define PR_ASSOC_MSG_W_ATTACH_COUNT             PROP_TAG( PT_LONG, pidAdminMin+0x1E )
#define PR_RECIPIENT_ON_NORMAL_MSG_COUNT        PROP_TAG( PT_LONG, pidAdminMin+0x1F )
#define PR_RECIPIENT_ON_ASSOC_MSG_COUNT 		PROP_TAG( PT_LONG, pidAdminMin+0x20 )
#define PR_ATTACH_ON_NORMAL_MSG_COUNT   		PROP_TAG( PT_LONG, pidAdminMin+0x21 )
#define PR_ATTACH_ON_ASSOC_MSG_COUNT    		PROP_TAG( PT_LONG, pidAdminMin+0x22 )
#define PR_NORMAL_MESSAGE_SIZE                  PROP_TAG( PT_LONG, pidAdminMin+0x23 )
#define PR_NORMAL_MESSAGE_SIZE_EXTENDED         PROP_TAG( PT_I8, pidAdminMin+0x23 )
#define PR_ASSOC_MESSAGE_SIZE                   PROP_TAG( PT_LONG, pidAdminMin+0x24 )
#define PR_ASSOC_MESSAGE_SIZE_EXTENDED          PROP_TAG( PT_I8, pidAdminMin+0x24 )
#define PR_FOLDER_PATHNAME                      PROP_TAG(PT_TSTRING, pidAdminMin+0x25 )
#define PR_OWNER_COUNT							PROP_TAG( PT_LONG, pidAdminMin+0x26 )
#define PR_CONTACT_COUNT						PROP_TAG( PT_LONG, pidAdminMin+0x27 )

// PT_I8 version of PR_MESSAGE_SIZE defined in mapitags.h
#define	PR_MESSAGE_SIZE_EXTENDED			PROP_TAG(PT_I8, PROP_ID(PR_MESSAGE_SIZE))

/* Bits in PR_FOLDER_FLAGS */
#define MDB_FOLDER_IPM                  0x1
#define MDB_FOLDER_SEARCH               0x2
#define MDB_FOLDER_NORMAL               0x4
#define MDB_FOLDER_RULES                0x8

/* Bits used in ulFlags in GetPublicFolderTable() */
#define MDB_NON_IPM                     0x10
#define MDB_IPM                         0x20

/* Bits in PR_STORAGE_LIMIT_INFORMATION */
#define MDB_LIMIT_BELOW					0x1
#define MDB_LIMIT_ISSUE_WARNING			0x2
#define MDB_LIMIT_PROHIBIT_SEND			0x4
#define MDB_LIMIT_NO_CHECK				0x8


/*------------------------------------------------------------------------
 *
 *	"IExchangeFastTransfer" Interface Declaration
 *
 *	Used for fast transfer interface used to
 *	implement CopyTo, CopyProps, CopyFolder, and
 *	CopyMessages.
 *
 *-----------------------------------------------------------------------*/

// Transfer flags
// Use MAPI_MOVE for move option

// Transfer methods
#define	TRANSFER_COPYTO			1
#define	TRANSFER_COPYPROPS		2
#define	TRANSFER_COPYMESSAGES	3
#define	TRANSFER_COPYFOLDER		4


#define EXCHANGE_IEXCHANGEFASTTRANSFER_METHODS(IPURE)			\
	MAPIMETHOD(Config)											\
		(THIS_	ULONG				ulFlags,					\
				ULONG				ulTransferMethod) IPURE;	\
	MAPIMETHOD(TransferBuffer)									\
		(THIS_	ULONG				cb,							\
				LPBYTE				lpb,						\
				ULONG				*lpcbProcessed) IPURE;		\
	STDMETHOD_(BOOL, IsInterfaceOk)								\
		(THIS_	ULONG				ulTransferMethod,			\
				REFIID				refiid,						\
				LPSPropTagArray		lpptagList,					\
				ULONG				ulFlags) IPURE;

#undef		 INTERFACE
#define		 INTERFACE  IExchangeFastTransfer
DECLARE_MAPI_INTERFACE_(IExchangeFastTransfer, IUnknown)
{
	MAPI_IUNKNOWN_METHODS(PURE)
	EXCHANGE_IEXCHANGEFASTTRANSFER_METHODS(PURE)
};
#undef	IMPL
#define IMPL

DECLARE_MAPI_INTERFACE_PTR(IExchangeFastTransfer, LPEXCHANGEFASTTRANSFER);



/*------------------------------------------------------------------------
 *
 *	"IExchangeExportChanges" Interface Declaration
 *
 *	Used for Incremental Synchronization
 *
 *-----------------------------------------------------------------------*/

#define EXCHANGE_IEXCHANGEEXPORTCHANGES_METHODS(IPURE)		\
	MAPIMETHOD(GetLastError)								\
		(THIS_	HRESULT				hResult,				\
		 	    ULONG				ulFlags,				\
		 	    LPMAPIERROR FAR *	lppMAPIError) IPURE;	\
	MAPIMETHOD(Config)										\
		(THIS_	LPSTREAM			lpStream,				\
				ULONG				ulFlags,				\
				LPUNKNOWN			lpUnk,					\
		 		LPSRestriction		lpRestriction,			\
		 	    LPSPropTagArray		lpIncludeProps,			\
		 	    LPSPropTagArray		lpExcludeProps,			\
		 		ULONG				ulBufferSize) IPURE;	\
	MAPIMETHOD(Synchronize)									\
		(THIS_	ULONG FAR *			lpulSteps,				\
				ULONG FAR *			lpulProgress) IPURE;	\
	MAPIMETHOD(UpdateState)									\
		(THIS_	LPSTREAM			lpStream) IPURE;

#undef		 INTERFACE
#define		 INTERFACE  IExchangeExportChanges
DECLARE_MAPI_INTERFACE_(IExchangeExportChanges, IUnknown)
{
	MAPI_IUNKNOWN_METHODS(PURE)
	EXCHANGE_IEXCHANGEEXPORTCHANGES_METHODS(PURE)
};
#undef	IMPL
#define IMPL

DECLARE_MAPI_INTERFACE_PTR(IExchangeExportChanges, LPEXCHANGEEXPORTCHANGES);


typedef struct _ReadState
{
	ULONG		cbSourceKey;
	BYTE	*	pbSourceKey;
	ULONG		ulFlags;
} READSTATE, *LPREADSTATE;

/*------------------------------------------------------------------------
 *
 *	"IExchangeImportContentsChanges" Interface Declaration
 *
 *	Used for Incremental Synchronization of folder contents (i.e. messages)
 *
 *-----------------------------------------------------------------------*/


#define EXCHANGE_IEXCHANGEIMPORTCONTENTSCHANGES_METHODS(IPURE)		\
	MAPIMETHOD(GetLastError)										\
		(THIS_	HRESULT				hResult,						\
		 	    ULONG				ulFlags,						\
		 	    LPMAPIERROR FAR *	lppMAPIError) IPURE;			\
	MAPIMETHOD(Config)												\
		(THIS_	LPSTREAM				lpStream,					\
		 		ULONG					ulFlags) IPURE;				\
	MAPIMETHOD(UpdateState)											\
		(THIS_	LPSTREAM				lpStream) IPURE;			\
	MAPIMETHOD(ImportMessageChange)									\
		(THIS_	ULONG					cpvalChanges,				\
				LPSPropValue			ppvalChanges,				\
				ULONG					ulFlags,					\
				LPMESSAGE				*lppmessage) IPURE;			\
	MAPIMETHOD(ImportMessageDeletion)								\
		(THIS_	ULONG					ulFlags,					\
		 		LPENTRYLIST				lpSrcEntryList) IPURE;		\
	MAPIMETHOD(ImportPerUserReadStateChange)						\
		(THIS_	ULONG					cElements,					\
		 		LPREADSTATE			 	lpReadState) IPURE;			\
	MAPIMETHOD(ImportMessageMove)									\
		(THIS_	ULONG					cbSourceKeySrcFolder,		\
		 		BYTE FAR *				pbSourceKeySrcFolder,		\
		 		ULONG					cbSourceKeySrcMessage,		\
		 		BYTE FAR *				pbSourceKeySrcMessage,		\
		 		ULONG					cbPCLMessage,				\
		 		BYTE FAR *				pbPCLMessage,				\
		 		ULONG					cbSourceKeyDestMessage,		\
		 		BYTE FAR *				pbSourceKeyDestMessage,		\
		 		ULONG					cbChangeNumDestMessage,		\
		 		BYTE FAR *				pbChangeNumDestMessage) IPURE;


#undef		 INTERFACE
#define		 INTERFACE  IExchangeImportContentsChanges
DECLARE_MAPI_INTERFACE_(IExchangeImportContentsChanges, IUnknown)
{
	MAPI_IUNKNOWN_METHODS(PURE)
	EXCHANGE_IEXCHANGEIMPORTCONTENTSCHANGES_METHODS(PURE)
};
#undef	IMPL
#define IMPL

DECLARE_MAPI_INTERFACE_PTR(IExchangeImportContentsChanges,
						   LPEXCHANGEIMPORTCONTENTSCHANGES);

/*------------------------------------------------------------------------
 *
 *	"IExchangeImportHierarchyChanges" Interface Declaration
 *
 *	Used for Incremental Synchronization of folder hierarchy
 *
 *-----------------------------------------------------------------------*/

#define EXCHANGE_IEXCHANGEIMPORTHIERARCHYCHANGES_METHODS(IPURE)		\
	MAPIMETHOD(GetLastError)										\
		(THIS_	HRESULT				hResult,						\
				ULONG 				ulFlags,						\
				LPMAPIERROR FAR *	lppMAPIError) IPURE;			\
	MAPIMETHOD(Config)												\
		(THIS_	LPSTREAM				lpStream,					\
		 		ULONG					ulFlags) IPURE;				\
	MAPIMETHOD(UpdateState)											\
		(THIS_	LPSTREAM				lpStream) IPURE;			\
	MAPIMETHOD(ImportFolderChange)									\
		(THIS_	ULONG						cpvalChanges,			\
				LPSPropValue				ppvalChanges) IPURE;	\
	MAPIMETHOD(ImportFolderDeletion)								\
		(THIS_	ULONG						ulFlags,				\
		 		LPENTRYLIST					lpSrcEntryList) IPURE;

#undef		 INTERFACE
#define		 INTERFACE  IExchangeImportHierarchyChanges
DECLARE_MAPI_INTERFACE_(IExchangeImportHierarchyChanges, IUnknown)
{
	MAPI_IUNKNOWN_METHODS(PURE)
	EXCHANGE_IEXCHANGEIMPORTHIERARCHYCHANGES_METHODS(PURE)
};
#undef	IMPL
#define IMPL

DECLARE_MAPI_INTERFACE_PTR(IExchangeImportHierarchyChanges,
						   LPEXCHANGEIMPORTHIERARCHYCHANGES);

/*------------------------------------------------------------------------
 *
 *	Errors returned by Exchange Incremental Change Synchronization Interface
 *
 *-----------------------------------------------------------------------*/

#define MAKE_SYNC_E(err)	(MAKE_SCODE(SEVERITY_ERROR, FACILITY_ITF, err))
#define MAKE_SYNC_W(warn)	(MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, warn))

#define SYNC_E_UNKNOWN_FLAGS			MAPI_E_UNKNOWN_FLAGS
#define SYNC_E_INVALID_PARAMETER		E_INVALIDARG
#define SYNC_E_ERROR					E_FAIL
#define SYNC_E_OBJECT_DELETED			MAKE_SYNC_E(0x800)
#define SYNC_E_IGNORE					MAKE_SYNC_E(0x801)
#define SYNC_E_CONFLICT					MAKE_SYNC_E(0x802)
#define SYNC_E_NO_PARENT				MAKE_SYNC_E(0x803)
#define SYNC_E_INCEST					MAKE_SYNC_E(0x804)
#define SYNC_E_UNSYNCHRONIZED			MAKE_SYNC_E(0x805)

#define SYNC_W_PROGRESS					MAKE_SYNC_W(0x820)
#define SYNC_W_CLIENT_CHANGE_NEWER		MAKE_SYNC_W(0x821)

/*------------------------------------------------------------------------
 *
 *	Flags used by Exchange Incremental Change Synchronization Interface
 *
 *-----------------------------------------------------------------------*/

#define	SYNC_UNICODE				0x01
#define SYNC_NO_DELETIONS			0x02
#define SYNC_NO_SOFT_DELETIONS		0x04
#define	SYNC_READ_STATE				0x08
#define SYNC_ASSOCIATED				0x10
#define SYNC_NORMAL					0x20
#define	SYNC_NO_CONFLICTS			0x40
#define SYNC_ONLY_SPECIFIED_PROPS	0x80
#define SYNC_NO_FOREIGN_KEYS		0x100
#define SYNC_LIMITED_IMESSAGE		0x200


/*------------------------------------------------------------------------
 *
 *	Flags used by ImportMessageDeletion and ImportFolderDeletion methods
 *
 *-----------------------------------------------------------------------*/

#define SYNC_SOFT_DELETE			0x01
#define SYNC_EXPIRY					0x02

/*------------------------------------------------------------------------
 *
 *	Flags used by ImportPerUserReadStateChange method
 *
 *-----------------------------------------------------------------------*/

#define SYNC_READ					0x01

/*------------------------------------------------------------------------
 *
 *	"IExchangeFavorites" Interface Declaration
 *
 *	Used for adding or removing favorite folders from the public store.
 *	This interface is obtained by calling QueryInterface on the folder
 *	whose EntryID is specified by PR_IPM_FAVORITES_ENTRYID on the public
 *	store.
 *
 *-----------------------------------------------------------------------*/

#define EXCHANGE_IEXCHANGEFAVORITES_METHODS(IPURE)						\
	MAPIMETHOD(GetLastError)											\
		(THIS_	HRESULT						hResult,					\
				ULONG						ulFlags,					\
				LPMAPIERROR FAR *			lppMAPIError) IPURE;		\
	MAPIMETHOD(AddFavorites)											\
		(THIS_	LPENTRYLIST					lpEntryList) IPURE;			\
	MAPIMETHOD(DelFavorites)											\
		(THIS_	LPENTRYLIST					lpEntryList) IPURE;			\

#undef		 INTERFACE
#define		 INTERFACE  IExchangeFavorites
DECLARE_MAPI_INTERFACE_(IExchangeFavorites, IUnknown)
{
	MAPI_IUNKNOWN_METHODS(PURE)
	EXCHANGE_IEXCHANGEFAVORITES_METHODS(PURE)
};

DECLARE_MAPI_INTERFACE_PTR(IExchangeFavorites,	LPEXCHANGEFAVORITES);


/*------------------------------------------------------------------------
 *
 *	Properties used by the Offline Folders API
 *
 *-----------------------------------------------------------------------*/
											  
#define PR_OFFLINE_FLAGS				PROP_TAG( PT_LONG, pidFolderMin + 0x5)
#define PR_SYNCHRONIZE_FLAGS			PROP_TAG( PT_LONG, pidExchangeNonXmitReservedMin + 0x4)
							

/*------------------------------------------------------------------------
 *
 *	Flags used by the Offline Folders API
 *
 *-----------------------------------------------------------------------*/

#define OF_AVAILABLE_OFFLINE					((ULONG) 0x00000001)
#define OF_FORCE								((ULONG) 0x80000000)

#define SF_DISABLE_STARTUP_SYNC					((ULONG) 0x00000001)


#endif	//EDKMDB_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\effect.h ===
#ifndef __EFFECT_H__
#define __EFFECT_H__

// Forward declares...
struct IDirectDrawSurface;

//{1F9DDD20-4146-11d0-BDC2-00A0C908DB96}
DEFINE_GUID(CATID_BitmapEffect, 
0x1f9ddd20, 0x4146, 0x11d0, 0xbd, 0xc2, 0x0, 0xa0, 0xc9, 0x8, 0xdb, 0x96);

#define CATSZ_BitmapEffectDescription __T("Bitmap Effect")

// {ACEA25C0-415B-11d0-BDC2-00A0C908DB96}
DEFINE_GUID(IID_IBitmapEffect, 
0xacea25c0, 0x415b, 0x11d0, 0xbd, 0xc2, 0x0, 0xa0, 0xc9, 0x8, 0xdb, 0x96);

#define BITMAP_EFFECT_INPLACE                           0x00000001
#define BITMAP_EFFECT_REALTIME                          0x00000002
#define BITMAP_EFFECT_DIRECTDRAW                        0x00000004
#define BITMAP_EFFECT_SUPPORTS_INVALIDATE       0x00000008

DECLARE_INTERFACE_(IBitmapEffect, IUnknown)
{
        STDMETHOD(SetSite)(LPUNKNOWN pUnk) PURE;
        STDMETHOD(GetMiscStatusBits)(DWORD* pdwFlags) PURE;
    STDMETHOD(GetSupportedFormatsCount)(unsigned *pcFormats) PURE;
    STDMETHOD(GetSupportedFormats)(unsigned cFormats, DWORD *pdwColorDepths)  PURE;
    STDMETHOD(Begin)(DWORD dwColorDepth, SIZE* psizeEffect) PURE;
    STDMETHOD(End)(void) PURE;
        STDMETHOD(DoEffect)(IDirectDrawSurface* pbsIn, IDirectDrawSurface* pbsOut, RECT *prcFull, RECT* prcInvalid) PURE;
};

#endif //__EFFECT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\edkmsg.h ===
// --edkmsg.mc-----------------------------------------------------------------
//
//  This file contains the messages common to the entire EDK.
//
// Copyright 1986 - 1998 Microsoft Corporation.  All Rights Reserved.
// ----------------------------------------------------------------------------
//
//
// Message Naming Convention
// -------------------------
//
// Each message has a symbolic name that becomes a #define'ed constant for 
// use in a .C file.  A message's symbolic name should follow this naming 
// convention:
// 
// <COMPONENT>_<MESSAGE_DESCRIPTION>
//
// If a message is used by more than one library and/or application, then 
// <COMPONENT> should be "EDKEVENT".
//
// The <MESSAGE_DESCRIPTION> portion of the name describes what the message 
// is about.  For example, a message called EDKEVENT_INVALID_HEX_DIGIT could 
// indicate that an illegal hexidecimal digit was found.
//
// Only the first message in this file should have a Message ID number--
// the message compiler will then assign consecutive numbers to the rest.
//
//
// Generic Information message allowing user to fill in text or error code.
//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//


//
// Define the severity codes
//


//
// MessageId: EDKEVENT_INFORMATION
//
// MessageText:
//
//  %1
//
#define EDKEVENT_INFORMATION             ((DWORD)0x60000000L)

// Generic Warning message allowing user to fill in text or error code.
//
// MessageId: EDKEVENT_WARNING
//
// MessageText:
//
//  %1
//
#define EDKEVENT_WARNING                 ((DWORD)0xA0000001L)

// Generic Error message allowing user to fill in text or error code.
//
// MessageId: EDKEVENT_ERROR
//
// MessageText:
//
//  %1
//
#define EDKEVENT_ERROR                   ((DWORD)0xE0000002L)

//
// MessageId: WINWRAP_SERVICE_STARTING
//
// MessageText:
//
//  Service starting.
//
#define WINWRAP_SERVICE_STARTING         ((DWORD)0x60000003L)

//
// MessageId: WINWRAP_SERVICE_STARTED
//
// MessageText:
//
//  Service started.
//
#define WINWRAP_SERVICE_STARTED          ((DWORD)0x60000004L)

//
// MessageId: WINWRAP_SERVICE_STOPPING
//
// MessageText:
//
//  Service stopping.
//
#define WINWRAP_SERVICE_STOPPING         ((DWORD)0x60000005L)

//
// MessageId: WINWRAP_SERVICE_STOPPED
//
// MessageText:
//
//  Service stopped.
//
#define WINWRAP_SERVICE_STOPPED          ((DWORD)0x60000006L)

//
// MessageId: EDKEVENT_CANNOT_INIT_MAPI
//
// MessageText:
//
//  Unable to initialize MAPI.
//
#define EDKEVENT_CANNOT_INIT_MAPI        ((DWORD)0xE0000007L)

//
// MessageId: MESGXLAT_CNV_CONVERT_FAIL
//
// MessageText:
//
//  %1 conversion DLL convert function failed:  point = %2, class = %3, error code = %4.
//
#define MESGXLAT_CNV_CONVERT_FAIL        ((DWORD)0xE0000008L)

//
// MessageId: MESGXLAT_CNV_NO_CANDIDATE
//
// MessageText:
//
//  No conversion DLL candidate found for point = %1 and class = %2.
//
#define MESGXLAT_CNV_NO_CANDIDATE        ((DWORD)0xE0000009L)

//
// MessageId: MESGXLAT_CNV_NO_ACCEPT
//
// MessageText:
//
//  Candidate conversion DLL %1 rejected conversion for point = %2, class = %3.  Error code = %4.
//
#define MESGXLAT_CNV_NO_ACCEPT           ((DWORD)0xE000000AL)

//
// MessageId: MESGXLAT_CNV_QUERY_FAIL
//
// MessageText:
//
//  Conversion DLL %1 query function failed:  point = %2, class = %3.  Error code = %4.
//
#define MESGXLAT_CNV_QUERY_FAIL          ((DWORD)0xE000000BL)

//
// MessageId: MESGXLAT_CNV_BAD_SYNTAX
//
// MessageText:
//
//  Invalid registry key values for MAPI Conversion DLL %1:  entry point = %2 class = %3, options = %4, point = %5.
//
#define MESGXLAT_CNV_BAD_SYNTAX          ((DWORD)0xE000000CL)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\epgdspid.h ===
// epgdspid.h

#ifndef __EPGDSPID_H__
#define __EPGDSPID_H__

#ifdef __MKTYPLIB__

	// Use with SetActiveView
	typedef enum epgview
	{
		EPG_GRID_VIEW		= 0,
		EPG_CATEGORY_VIEW	= 1,
		EPG_DSS_VIEW		= 2,
		EPG_MAX_VIEW		= 3
	} EPGVIEW;

typedef enum 
{
		TVX_CONTROL_GENERIC = 0,
		TVX_CONTROL_EPG	= 1,
		TVX_CONTROL_FSVIDEO = 2,
		// number of controls as enumed above
		TVX_CONTROL_NUM_OF_TYPES=3
}TVX_CONTROL_TYPES;


#endif

// Dispatch IDs

// IEPGComponent

#define dispidSetItem					1001
#define dispidClear						1002

// IEPG

#define dispidSetActiveView				2001
#define dispidGetActiveView				2002
#define dispidJumpTo					2003
#define dispidTakeFocus					2004

// ITVControlPrivate

#define dispidResume					3001
#define dispidSuspend					3002
#define dispidIdentify					3003
#define dispidAccelCommand				3004

#endif // __EPGDSPID_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\epgdisp.h ===
/* This header file machine-generated by mktyplib.exe */
/* Interface to type library: EPGDisp */

#ifndef _EPGDisp_H_
#define _EPGDisp_H_

DEFINE_GUID(LIBID_EPGDisp,0xA74E7EF1L,0xC3D2,0x11CF,0x85,0x78,0x00,0x80,0x5F,0xE4,0x80,0x9B);
#ifndef BEGIN_INTERFACE
#define BEGIN_INTERFACE
#endif

typedef enum epgview {
    EPG_GRID_VIEW = 0,
    EPG_CATEGORY_VIEW = 1,
    EPG_DSS_VIEW = 2,
    EPG_MAX_VIEW = 3
} EPGVIEW;

typedef enum {
    TVX_CONTROL_GENERIC = 0,
    TVX_CONTROL_EPG = 1,
    TVX_CONTROL_FSVIDEO = 2,
    TVX_CONTROL_NUM_OF_TYPES = 3
} TVX_CONTROL_TYPES;

DEFINE_GUID(IID_ITVControlPrivate,0x621CA624L,0xF887,0x11D0,0x8B,0x90,0x00,0xC0,0x4F,0xBB,0xDE,0x88);

/* Definition of interface: ITVControlPrivate */
#undef INTERFACE
#define INTERFACE ITVControlPrivate

DECLARE_INTERFACE_(ITVControlPrivate, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* ITVControlPrivate methods */
    STDMETHOD(Resume)(THIS) PURE;
    STDMETHOD(Suspend)(THIS) PURE;
    STDMETHOD(Identify)(THIS_ TVX_CONTROL_TYPES FAR* id) PURE;
    STDMETHOD(AccelCommand)(THIS_ int id) PURE;
};

DEFINE_GUID(IID_IEPG,0x3F8A2EA4L,0xC171,0x11CF,0x86,0x8C,0x00,0x80,0x5F,0x2C,0x11,0xCE);

/* Definition of interface: IEPG */
#undef INTERFACE
#define INTERFACE IEPG

DECLARE_INTERFACE_(IEPG, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IEPG methods */
    STDMETHOD(SetActiveView)(THIS_ int iView, IUnknown * punk) PURE;
    STDMETHOD(GetActiveView)(THIS_ int FAR* piView) PURE;
    STDMETHOD(JumpTo)(THIS_ DATE dt) PURE;
    STDMETHOD(TakeFocus)(THIS) PURE;
};

DEFINE_GUID(DIID__DEPG,0xA74E7EF2L,0xC3D2,0x11CF,0x85,0x78,0x00,0x80,0x5F,0xE4,0x80,0x9B);

/* Definition of dispatch interface: _DEPG */
#undef INTERFACE
#define INTERFACE _DEPG

DECLARE_INTERFACE_(_DEPG, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* _DEPG properties:
    BSTR TabFontName;
    long TabFontSize;
    VARIANT_BOOL TabFontBold;
    VARIANT_BOOL TabFontItalic;
    VARIANT_BOOL TabFontUnderline;
    VARIANT_BOOL TabFontStrikethrough;
    OLE_COLOR TabFontColor;
    BSTR ButtonFontName;
    long ButtonFontSize;
    VARIANT_BOOL ButtonFontBold;
    VARIANT_BOOL ButtonFontItalic;
    VARIANT_BOOL ButtonFontUnderline;
    VARIANT_BOOL ButtonFontStrikethrough;
    OLE_COLOR ButtonFontColor;
    */

    /* _DEPG methods:
    void AboutBox(void);
    */
};

DEFINE_GUID(DIID__DEPGEvents,0xA74E7EF3L,0xC3D2,0x11CF,0x85,0x78,0x00,0x80,0x5F,0xE4,0x80,0x9B);

/* Definition of dispatch interface: _DEPGEvents */
#undef INTERFACE
#define INTERFACE _DEPGEvents

DECLARE_INTERFACE_(_DEPGEvents, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif
};

DEFINE_GUID(CLSID_EPG,0xA74E7EF4L,0xC3D2,0x11CF,0x85,0x78,0x00,0x80,0x5F,0xE4,0x80,0x9B);

#ifdef __cplusplus
class EPG;
#endif

DEFINE_GUID(IID_IEPGComponent,0x3F8A2EA5L,0xC171,0x11CF,0x86,0x8C,0x00,0x80,0x5F,0x2C,0x11,0xCE);

/* Definition of interface: IEPGComponent */
#undef INTERFACE
#define INTERFACE IEPGComponent

DECLARE_INTERFACE_(IEPGComponent, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IEPGComponent methods */
    STDMETHOD(SetItem)(THIS_ IUnknown * pItem) PURE;
    STDMETHOD(Clear)(THIS) PURE;
};

DEFINE_GUID(DIID__DPSP,0xA74E7EF6L,0xC3D2,0x11CF,0x85,0x78,0x00,0x80,0x5F,0xE4,0x80,0x9B);

/* Definition of dispatch interface: _DPSP */
#undef INTERFACE
#define INTERFACE _DPSP

DECLARE_INTERFACE_(_DPSP, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* _DPSP properties:
    BSTR ProgramFontName;
    long ProgramFontSize;
    VARIANT_BOOL ProgramFontBold;
    VARIANT_BOOL ProgramFontItalic;
    VARIANT_BOOL ProgramFontUnderline;
    VARIANT_BOOL ProgramFontStrikethrough;
    OLE_COLOR ProgramFontColor;
    BSTR TitleFontName;
    long TitleFontSize;
    VARIANT_BOOL TitleFontBold;
    VARIANT_BOOL TitleFontItalic;
    VARIANT_BOOL TitleFontUnderline;
    VARIANT_BOOL TitleFontStrikethrough;
    OLE_COLOR TitleFontColor;
    */

    /* _DPSP methods:
    void AboutBox(void);
    */
};

DEFINE_GUID(DIID__DPSPEvents,0xA74E7EF7L,0xC3D2,0x11CF,0x85,0x78,0x00,0x80,0x5F,0xE4,0x80,0x9B);

/* Definition of dispatch interface: _DPSPEvents */
#undef INTERFACE
#define INTERFACE _DPSPEvents

DECLARE_INTERFACE_(_DPSPEvents, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif
};

DEFINE_GUID(CLSID_PSP,0xA74E7EF8L,0xC3D2,0x11CF,0x85,0x78,0x00,0x80,0x5F,0xE4,0x80,0x9B);

#ifdef __cplusplus
class PSP;
#endif

DEFINE_GUID(DIID__DPOP,0xA74E7EFAL,0xC3D2,0x11CF,0x85,0x78,0x00,0x80,0x5F,0xE4,0x80,0x9B);

/* Definition of dispatch interface: _DPOP */
#undef INTERFACE
#define INTERFACE _DPOP

DECLARE_INTERFACE_(_DPOP, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* _DPOP properties:
    BSTR ButtonFontName;
    long ButtonFontSize;
    VARIANT_BOOL ButtonFontBold;
    VARIANT_BOOL ButtonFontItalic;
    VARIANT_BOOL ButtonFontUnderline;
    VARIANT_BOOL ButtonFontStrikethrough;
    OLE_COLOR ButtonFontColor;
    OLE_COLOR ButtonBackColor;
    OLE_COLOR ButtonFocusColor;
    OLE_COLOR ButtonDisabledColor;
    VARIANT_BOOL VerticalLayout;
    long ButtonHeight;
    long ButtonWidth;
    */

    /* _DPOP methods:
    void AboutBox(void);
    */
};

DEFINE_GUID(DIID__DPOPEvents,0xA74E7EFBL,0xC3D2,0x11CF,0x85,0x78,0x00,0x80,0x5F,0xE4,0x80,0x9B);

/* Definition of dispatch interface: _DPOPEvents */
#undef INTERFACE
#define INTERFACE _DPOPEvents

DECLARE_INTERFACE_(_DPOPEvents, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif
};

DEFINE_GUID(CLSID_POP,0xA74E7EFCL,0xC3D2,0x11CF,0x85,0x78,0x00,0x80,0x5F,0xE4,0x80,0x9B);

#ifdef __cplusplus
class POP;
#endif

DEFINE_GUID(DIID__DBan,0xA74E7F0EL,0xC3D2,0x11CF,0x85,0x78,0x00,0x80,0x5F,0xE4,0x80,0x9B);

/* Definition of dispatch interface: _DBan */
#undef INTERFACE
#define INTERFACE _DBan

DECLARE_INTERFACE_(_DBan, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* _DBan properties:
    BSTR HourFontName;
    long HourFontSize;
    VARIANT_BOOL HourFontBold;
    VARIANT_BOOL HourFontItalic;
    VARIANT_BOOL HourFontUnderline;
    VARIANT_BOOL HourFontStrikethrough;
    OLE_COLOR HourFontColor;
    BSTR MinuteFontName;
    long MinuteFontSize;
    VARIANT_BOOL MinuteFontBold;
    VARIANT_BOOL MinuteFontItalic;
    VARIANT_BOOL MinuteFontUnderline;
    VARIANT_BOOL MinuteFontStrikethrough;
    OLE_COLOR MinuteFontColor;
    BSTR AMPMFontName;
    long AMPMFontSize;
    VARIANT_BOOL AMPMFontBold;
    VARIANT_BOOL AMPMFontItalic;
    VARIANT_BOOL AMPMFontUnderline;
    VARIANT_BOOL AMPMFontStrikethrough;
    OLE_COLOR AMPMFontColor;
    VARIANT_BOOL LeftClock;
    OLE_COLOR BackgroundColor;
    */

    /* _DBan methods:
    void AboutBox(void);
    */
};

DEFINE_GUID(DIID__DBanEvents,0xA74E7F10L,0xC3D2,0x11CF,0x85,0x78,0x00,0x80,0x5F,0xE4,0x80,0x9B);

/* Definition of dispatch interface: _DBanEvents */
#undef INTERFACE
#define INTERFACE _DBanEvents

DECLARE_INTERFACE_(_DBanEvents, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif
};

DEFINE_GUID(CLSID_Ban,0xA74E7F11L,0xC3D2,0x11CF,0x85,0x78,0x00,0x80,0x5F,0xE4,0x80,0x9B);

#ifdef __cplusplus
class Ban;
#endif

DEFINE_GUID(DIID__DMsepg4,0xA74E7EFEL,0xC3D2,0x11CF,0x85,0x78,0x00,0x80,0x5F,0xE4,0x80,0x9B);

/* Definition of dispatch interface: _DMsepg4 */
#undef INTERFACE
#define INTERFACE _DMsepg4

DECLARE_INTERFACE_(_DMsepg4, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* _DMsepg4 methods:
    VARIANT_BOOL GetCC(void);
    void AboutBox(void);
    */
};

DEFINE_GUID(DIID__DMsepg4Events,0xA74E7EFFL,0xC3D2,0x11CF,0x85,0x78,0x00,0x80,0x5F,0xE4,0x80,0x9B);

/* Definition of dispatch interface: _DMsepg4Events */
#undef INTERFACE
#define INTERFACE _DMsepg4Events

DECLARE_INTERFACE_(_DMsepg4Events, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif
};

DEFINE_GUID(CLSID_Msepg4,0xA74E7F00L,0xC3D2,0x11CF,0x85,0x78,0x00,0x80,0x5F,0xE4,0x80,0x9B);

#ifdef __cplusplus
class Msepg4;
#endif

DEFINE_GUID(DIID__DPreview,0xA74E7F02L,0xC3D2,0x11CF,0x85,0x78,0x00,0x80,0x5F,0xE4,0x80,0x9B);

/* Definition of dispatch interface: _DPreview */
#undef INTERFACE
#define INTERFACE _DPreview

DECLARE_INTERFACE_(_DPreview, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* _DPreview methods:
    void AboutBox(void);
    */
};

DEFINE_GUID(DIID__DPreviewEvents,0xA74E7F03L,0xC3D2,0x11CF,0x85,0x78,0x00,0x80,0x5F,0xE4,0x80,0x9B);

/* Definition of dispatch interface: _DPreviewEvents */
#undef INTERFACE
#define INTERFACE _DPreviewEvents

DECLARE_INTERFACE_(_DPreviewEvents, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif
};

DEFINE_GUID(CLSID_Preview,0xA74E7F04L,0xC3D2,0x11CF,0x85,0x78,0x00,0x80,0x5F,0xE4,0x80,0x9B);

#ifdef __cplusplus
class Preview;
#endif

DEFINE_GUID(DIID__DTUNE_TVX_CONTROL,0xA74E7F06L,0xC3D2,0x11CF,0x85,0x78,0x00,0x80,0x5F,0xE4,0x80,0x9B);

/* Definition of dispatch interface: _DTUNE_TVX_CONTROL */
#undef INTERFACE
#define INTERFACE _DTUNE_TVX_CONTROL

DECLARE_INTERFACE_(_DTUNE_TVX_CONTROL, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* _DTUNE_TVX_CONTROL properties:
    BSTR BackgroundImage;
    */

    /* _DTUNE_TVX_CONTROL methods:
    void AboutBox(void);
    */
};

DEFINE_GUID(DIID__DTUNE_TVX_CONTROLEvents,0xA74E7F07L,0xC3D2,0x11CF,0x85,0x78,0x00,0x80,0x5F,0xE4,0x80,0x9B);

/* Definition of dispatch interface: _DTUNE_TVX_CONTROLEvents */
#undef INTERFACE
#define INTERFACE _DTUNE_TVX_CONTROLEvents

DECLARE_INTERFACE_(_DTUNE_TVX_CONTROLEvents, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif
};

DEFINE_GUID(CLSID_TUNE_TVX_CONTROL,0xA74E7F08L,0xC3D2,0x11CF,0x85,0x78,0x00,0x80,0x5F,0xE4,0x80,0x9B);

#ifdef __cplusplus
class TUNE_TVX_CONTROL;
#endif

DEFINE_GUID(DIID__DADV_CONTROL,0xA74E7F0AL,0xC3D2,0x11CF,0x85,0x78,0x00,0x80,0x5F,0xE4,0x80,0x9B);

/* Definition of dispatch interface: _DADV_CONTROL */
#undef INTERFACE
#define INTERFACE _DADV_CONTROL

DECLARE_INTERFACE_(_DADV_CONTROL, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* _DADV_CONTROL properties:
    BSTR BackgroundImage;
    */

    /* _DADV_CONTROL methods:
    void AboutBox(void);
    */
};

DEFINE_GUID(DIID__DADV_CONTROLEvents,0xA74E7F0BL,0xC3D2,0x11CF,0x85,0x78,0x00,0x80,0x5F,0xE4,0x80,0x9B);

/* Definition of dispatch interface: _DADV_CONTROLEvents */
#undef INTERFACE
#define INTERFACE _DADV_CONTROLEvents

DECLARE_INTERFACE_(_DADV_CONTROLEvents, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif
};

DEFINE_GUID(CLSID_ADV_CONTROL,0xA74E7F0CL,0xC3D2,0x11CF,0x85,0x78,0x00,0x80,0x5F,0xE4,0x80,0x9B);

#ifdef __cplusplus
class ADV_CONTROL;
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\episodet.h ===
/***********************************************************************
**      E P I S O D E T. H                                              *
**                                                                     *
************************************************************************
** Copyright (C) 1996 by Microsoft Corporation                         *
**                 All Rights Reserved                                 *
************************************************************************/
/*
        EPISODET.H

        EpisodeT record object class definitions for Microsoft Guide

	This code controls the Episode table.  The code in Episode.cpp
	controls the SQ_EPG query.

*/


#ifndef __EPISODET_H__
#define __EPISODET_H__


/*

EpisodeT objects are constructed from database records of the EpisodeT table.

The CEpisodeTRecordset class is used to select and create CEpisodeT objects
from the EpisodeT table via functions in the CDatabaseRecordset parent class.

*/


#include "dbsets.h"


class COMMMSTVEXPORT CEpisodeTRecordset : public CDatabaseRecordset
{
// This class provides EpisodeT recordset manipulation via parent functions
protected:

virtual CString GetTableName( VOID);

virtual BOOL    SetRecordsetObject( VOID* cRecordsetObject);

public:
virtual VOID*   GetRecordsetObject( VOID);
virtual BOOLEAN Seek(LPCTSTR lpszComparison, CObject &coo);
virtual BOOLEAN Seek(LPCTSTR lpszComparison, LONG lEpisodeID);
};


class COMMMSTVEXPORT CEpisodeT : public CObject
{

    friend class CEpisodeTRecordset; // generates the CEpisodeT record object

private:

	LONG			m_lEpisodeID;
	CString			m_cszTitle;
	CString			m_cszDescription;
	LONG			m_lEnhMapID;
	LONG			m_lDisplayMask;
	LONG			m_lThemeID;
	LONG			m_lRatingID;
	LONG			m_lAbbreviation;
	COleDateTime	m_codtLastUpdate;

public:

	CEpisodeT(LONG lEpisodeID = AFX_RFX_LONG_PSEUDO_NULL,
				CString cszTitle = "",
				CString cszDescription = "",
				LONG lEnhMapID = 0,
				LONG lDisplayMask = 0,
				LONG lThemeID = 0,
				LONG lRatingID = 0,
				LONG lAbbreviation = 0,
				COleDateTime codtLastUpdate = (DATE) 0) :
			m_lEpisodeID(lEpisodeID),
			m_cszTitle(cszTitle),
			m_cszDescription(cszDescription),
			m_lEnhMapID(lEnhMapID),
			m_lDisplayMask(lDisplayMask),
			m_lThemeID(lThemeID),
			m_lRatingID(lRatingID),
			m_lAbbreviation(lAbbreviation),
			m_codtLastUpdate(codtLastUpdate) { }
	~CEpisodeT(VOID) { }
	
    VOID    SetTitle( LPCTSTR cszTitle) { m_cszTitle = cszTitle; }
    VOID    SetDescription( LPCTSTR cszDescription) { m_cszDescription = cszDescription; }
    VOID	SetEnhMapID( LONG lEnhMapID) { m_lEnhMapID = lEnhMapID; }
	VOID	SetDisplayMask( LONG lDisplayMask) { m_lDisplayMask = lDisplayMask; }
	VOID	SetThemeID( LONG lThemeID) { m_lThemeID = lThemeID; }
	VOID	SetRatingID( LONG lRatingID) { m_lRatingID = lRatingID; }
	VOID	SetAbbreviation( LONG lAbbreviation) { m_lAbbreviation = lAbbreviation; }
	VOID	SetLastUpdate( COleDateTime codtLastUpdate) { m_codtLastUpdate = codtLastUpdate; }


	LONG			EpisodeID() { return m_lEpisodeID; }
	CString			Title() { return m_cszTitle; }
	CString			Description() { return m_cszDescription; }
    LONG			EnhMapID() { return m_lEnhMapID; }
	LONG			DisplayMask() { return m_lDisplayMask; }
	LONG			ThemeID() { return m_lThemeID; }
	LONG			RatingID() { return m_lRatingID; }
	LONG			Abbreviation() { return m_lAbbreviation; }
	COleDateTime	LastUpdate() { return m_codtLastUpdate; }
};

// Table: EpisodeT

#define  TBL_EpisodeT  _T("Episode")

//      Field:                          Name                            Type    Size

#define FLD_EpisodeT_EpisodeID            _T("E Episode ID")              // Auto-Count
#define FLD_EpisodeT_Title                _T("E Title")                   // Text    255
#define FLD_EpisodeT_Description          _T("E Description")             // Text    255
#define FLD_EpisodeT_EnhMapID			  _T("E Enhancement Mapping ID")
#define FLD_EpisodeT_DisplayMask          _T("E Display Mask")            // Long      4
#define FLD_EpisodeT_ThemeID			  _T("E Theme ID")				  // Long	   4
#define FLD_EpisodeT_RatingID             _T("E Rating ID")               // Long      4
#define FLD_EpisodeT_Abbreviation         _T("E Abbreviation")            // Long      4
#define FLD_EpisodeT_LastUpdate			  _T("E Last Update")             // Date      4


#endif // __EPISODET_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\emsabtag.h ===
/*
** --emsabtag.h---------------------------------------------------------------
**
**  Property tag definitions for standard properties of Exchange Address
**  Book objects.
**
**  Note: These proptags are only valid when talking directly to the
**  Exchange Server Address Book. They are specifically NOT valid when
**  trying to read properties from an object copied into another address
**  book provider (the Personal Address Book, for example).
**
**  Copyright (c) Microsoft Corp. 1986-1996. All rights reserved.
** ---------------------------------------------------------------------------
*/

#ifndef _EMSABTAG_H
#define _EMSABTAG_H

/*
* Flags for ulInterfaceOptions on OpenProperty
*/
#define AB_SHOW_PHANTOMS                      2
#define AB_SHOW_OTHERS                        4

/*
* Flags for ulFlag on ResolveNames
*/
#define EMS_AB_ADDRESS_LOOKUP                 0x01

/*
* Constructed, but externally visible.
*/
#define PR_EMS_AB_SERVER                     PROP_TAG( PT_TSTRING, 0xFFFE)
#define PR_EMS_AB_SERVER_A                   PROP_TAG( PT_STRING8, 0xFFFE)
#define PR_EMS_AB_SERVER_W                   PROP_TAG( PT_UNICODE, 0xFFFE)
#define PR_EMS_AB_CONTAINERID                PROP_TAG( PT_LONG,    0xFFFD)
#define PR_EMS_AB_DOS_ENTRYID                PR_EMS_AB_CONTAINERID
#define PR_EMS_AB_PARENT_ENTRYID             PROP_TAG( PT_BINARY,  0xFFFC)
#define PR_EMS_AB_IS_MASTER                  PROP_TAG(PT_BOOLEAN,  0xFFFB)
#define PR_EMS_AB_OBJECT_OID                 PROP_TAG(PT_BINARY,   0xFFFA)
#define PR_EMS_AB_HIERARCHY_PATH             PROP_TAG(PT_TSTRING,  0xFFF9)
#define PR_EMS_AB_HIERARCHY_PATH_A           PROP_TAG(PT_STRING8,  0xFFF9)
#define PR_EMS_AB_HIERARCHY_PATH_W           PROP_TAG(PT_UNICODE,  0xFFF9)
#define PR_EMS_AB_CHILD_RDNS                  PROP_TAG(PT_MV_STRING8,   0xFFF8)

#define MIN_EMS_AB_CONSTRUCTED_PROP_ID        0xFFF8

#define PR_EMS_AB_OTHER_RECIPS                PROP_TAG(PT_OBJECT,       0xF000)

/*
 * Prop tags defined in the schema.
 */
#define PR_EMS_AB_DISPLAY_NAME_PRINTABLE      PROP_TAG(PT_TSTRING,      0x39FF)
#define PR_EMS_AB_DISPLAY_NAME_PRINTABLE_A    PROP_TAG(PT_STRING8,      0x39FF)
#define PR_EMS_AB_DISPLAY_NAME_PRINTABLE_W    PROP_TAG(PT_UNICODE,      0x39FF)

#define PR_EMS_AB_ACCESS_CATEGORY            PROP_TAG( PT_LONG,          0x8044)
#define PR_EMS_AB_ACTIVATION_SCHEDULE        PROP_TAG( PT_BINARY,        0x8045)
#define PR_EMS_AB_ACTIVATION_STYLE           PROP_TAG( PT_LONG,          0x8046)
#define PR_EMS_AB_ADDRESS_ENTRY_DISPLAY_TABLE PROP_TAG( PT_BINARY,        0x8017)
#define PR_EMS_AB_ADDRESS_ENTRY_DISPLAY_TABLE_MSDOS PROP_TAG( PT_BINARY,        0x8047)
#define PR_EMS_AB_ADDRESS_SYNTAX             PROP_TAG( PT_BINARY,        0x8018)
#define PR_EMS_AB_ADDRESS_TYPE               PROP_TAG( PT_TSTRING,       0x8048)
#define PR_EMS_AB_ADDRESS_TYPE_A             PROP_TAG( PT_STRING8,       0x8048)
#define PR_EMS_AB_ADDRESS_TYPE_W             PROP_TAG( PT_UNICODE,       0x8048)
#define PR_EMS_AB_ADMD                       PROP_TAG( PT_TSTRING,       0x8049)
#define PR_EMS_AB_ADMD_A                     PROP_TAG( PT_STRING8,       0x8049)
#define PR_EMS_AB_ADMD_W                     PROP_TAG( PT_UNICODE,       0x8049)
#define PR_EMS_AB_ADMIN_DESCRIPTION          PROP_TAG( PT_TSTRING,       0x804A)
#define PR_EMS_AB_ADMIN_DESCRIPTION_A        PROP_TAG( PT_STRING8,       0x804A)
#define PR_EMS_AB_ADMIN_DESCRIPTION_W        PROP_TAG( PT_UNICODE,       0x804A)
#define PR_EMS_AB_ADMIN_DISPLAY_NAME         PROP_TAG( PT_TSTRING,       0x804B)
#define PR_EMS_AB_ADMIN_DISPLAY_NAME_A       PROP_TAG( PT_STRING8,       0x804B)
#define PR_EMS_AB_ADMIN_DISPLAY_NAME_W       PROP_TAG( PT_UNICODE,       0x804B)
#define PR_EMS_AB_ADMIN_EXTENSION_DLL        PROP_TAG( PT_TSTRING,       0x804C)
#define PR_EMS_AB_ADMIN_EXTENSION_DLL_A      PROP_TAG( PT_STRING8,       0x804C)
#define PR_EMS_AB_ADMIN_EXTENSION_DLL_W      PROP_TAG( PT_UNICODE,       0x804C)
#define PR_EMS_AB_ALIASED_OBJECT_NAME        PROP_TAG( PT_TSTRING,       0x804D)
#define PR_EMS_AB_ALIASED_OBJECT_NAME_A      PROP_TAG( PT_STRING8,       0x804D)
#define PR_EMS_AB_ALIASED_OBJECT_NAME_W      PROP_TAG( PT_UNICODE,       0x804D)
#define PR_EMS_AB_ALIASED_OBJECT_NAME_O      PROP_TAG( PT_OBJECT,        0x804D)
#define PR_EMS_AB_ALIASED_OBJECT_NAME_T      PROP_TAG( PT_TSTRING,       0x804D)
#define PR_EMS_AB_ALT_RECIPIENT              PROP_TAG( PT_TSTRING,       0x804E)
#define PR_EMS_AB_ALT_RECIPIENT_A            PROP_TAG( PT_STRING8,       0x804E)
#define PR_EMS_AB_ALT_RECIPIENT_W            PROP_TAG( PT_UNICODE,       0x804E)
#define PR_EMS_AB_ALT_RECIPIENT_O            PROP_TAG( PT_OBJECT,        0x804E)
#define PR_EMS_AB_ALT_RECIPIENT_T            PROP_TAG( PT_TSTRING,       0x804E)
#define PR_EMS_AB_ALT_RECIPIENT_BL           PROP_TAG( PT_MV_TSTRING,    0x804F)
#define PR_EMS_AB_ALT_RECIPIENT_BL_A         PROP_TAG( PT_MV_STRING8,    0x804F)
#define PR_EMS_AB_ALT_RECIPIENT_BL_W         PROP_TAG( PT_MV_UNICODE,    0x804F)
#define PR_EMS_AB_ALT_RECIPIENT_BL_O         PROP_TAG( PT_OBJECT,        0x804F)
#define PR_EMS_AB_ALT_RECIPIENT_BL_T         PROP_TAG( PT_MV_TSTRING,    0x804F)
#define PR_EMS_AB_ANCESTOR_ID                PROP_TAG( PT_BINARY,        0x8050)
#define PR_EMS_AB_ASSOC_NT_ACCOUNT           PROP_TAG( PT_BINARY,        0x8027)
#define PR_EMS_AB_ASSOC_REMOTE_DXA           PROP_TAG( PT_MV_TSTRING,    0x8051)
#define PR_EMS_AB_ASSOC_REMOTE_DXA_A         PROP_TAG( PT_MV_STRING8,    0x8051)
#define PR_EMS_AB_ASSOC_REMOTE_DXA_W         PROP_TAG( PT_MV_UNICODE,    0x8051)
#define PR_EMS_AB_ASSOC_REMOTE_DXA_O         PROP_TAG( PT_OBJECT,        0x8051)
#define PR_EMS_AB_ASSOC_REMOTE_DXA_T         PROP_TAG( PT_MV_TSTRING,    0x8051)
#define PR_EMS_AB_ASSOCIATION_LIFETIME       PROP_TAG( PT_LONG,          0x8052)
#define PR_EMS_AB_AUTH_ORIG_BL               PROP_TAG( PT_MV_TSTRING,    0x8053)
#define PR_EMS_AB_AUTH_ORIG_BL_A             PROP_TAG( PT_MV_STRING8,    0x8053)
#define PR_EMS_AB_AUTH_ORIG_BL_W             PROP_TAG( PT_MV_UNICODE,    0x8053)
#define PR_EMS_AB_AUTH_ORIG_BL_O             PROP_TAG( PT_OBJECT,        0x8053)
#define PR_EMS_AB_AUTH_ORIG_BL_T             PROP_TAG( PT_MV_TSTRING,    0x8053)
#define PR_EMS_AB_AUTHORITY_REVOCATION_LIST  PROP_TAG( PT_MV_BINARY,     0x8026)
#define PR_EMS_AB_AUTHORIZED_DOMAIN          PROP_TAG( PT_TSTRING,       0x8054)
#define PR_EMS_AB_AUTHORIZED_DOMAIN_A        PROP_TAG( PT_STRING8,       0x8054)
#define PR_EMS_AB_AUTHORIZED_DOMAIN_W        PROP_TAG( PT_UNICODE,       0x8054)
#define PR_EMS_AB_AUTHORIZED_PASSWORD        PROP_TAG( PT_BINARY,        0x8055)
#define PR_EMS_AB_AUTHORIZED_USER            PROP_TAG( PT_TSTRING,       0x8056)
#define PR_EMS_AB_AUTHORIZED_USER_A          PROP_TAG( PT_STRING8,       0x8056)
#define PR_EMS_AB_AUTHORIZED_USER_W          PROP_TAG( PT_UNICODE,       0x8056)
#define PR_EMS_AB_AUTOREPLY                  PROP_TAG( PT_BOOLEAN,       0x800B)
#define PR_EMS_AB_AUTOREPLY_MESSAGE          PROP_TAG( PT_TSTRING,       0x800A)
#define PR_EMS_AB_AUTOREPLY_MESSAGE_A        PROP_TAG( PT_STRING8,       0x800A)
#define PR_EMS_AB_AUTOREPLY_MESSAGE_W        PROP_TAG( PT_UNICODE,       0x800A)
#define PR_EMS_AB_AUTOREPLY_SUBJECT          PROP_TAG( PT_TSTRING,       0x803E)
#define PR_EMS_AB_AUTOREPLY_SUBJECT_A        PROP_TAG( PT_STRING8,       0x803E)
#define PR_EMS_AB_AUTOREPLY_SUBJECT_W        PROP_TAG( PT_UNICODE,       0x803E)
#define PR_EMS_AB_BRIDGEHEAD_SERVERS         PROP_TAG( PT_MV_TSTRING,    0x8174)
#define PR_EMS_AB_BRIDGEHEAD_SERVERS_A       PROP_TAG( PT_MV_STRING8,    0x8174)
#define PR_EMS_AB_BRIDGEHEAD_SERVERS_W       PROP_TAG( PT_MV_UNICODE,    0x8174)
#define PR_EMS_AB_BRIDGEHEAD_SERVERS_O       PROP_TAG( PT_OBJECT,        0x8174)
#define PR_EMS_AB_BRIDGEHEAD_SERVERS_T       PROP_TAG( PT_MV_TSTRING,    0x8174)
#define PR_EMS_AB_BUSINESS_CATEGORY          PROP_TAG( PT_MV_TSTRING,    0x8057)
#define PR_EMS_AB_BUSINESS_CATEGORY_A        PROP_TAG( PT_MV_STRING8,    0x8057)
#define PR_EMS_AB_BUSINESS_CATEGORY_W        PROP_TAG( PT_MV_UNICODE,    0x8057)
#define PR_EMS_AB_BUSINESS_ROLES             PROP_TAG( PT_BINARY,        0x8023)
#define PR_EMS_AB_CA_CERTIFICATE             PROP_TAG( PT_MV_BINARY,     0x8003)
#define PR_EMS_AB_CAN_CREATE_PF              PROP_TAG( PT_MV_TSTRING,    0x8058)
#define PR_EMS_AB_CAN_CREATE_PF_A            PROP_TAG( PT_MV_STRING8,    0x8058)
#define PR_EMS_AB_CAN_CREATE_PF_W            PROP_TAG( PT_MV_UNICODE,    0x8058)
#define PR_EMS_AB_CAN_CREATE_PF_O            PROP_TAG( PT_OBJECT,        0x8058)
#define PR_EMS_AB_CAN_CREATE_PF_T            PROP_TAG( PT_MV_TSTRING,    0x8058)
#define PR_EMS_AB_CAN_CREATE_PF_BL           PROP_TAG( PT_MV_TSTRING,    0x8059)
#define PR_EMS_AB_CAN_CREATE_PF_BL_A         PROP_TAG( PT_MV_STRING8,    0x8059)
#define PR_EMS_AB_CAN_CREATE_PF_BL_W         PROP_TAG( PT_MV_UNICODE,    0x8059)
#define PR_EMS_AB_CAN_CREATE_PF_BL_O         PROP_TAG( PT_OBJECT,        0x8059)
#define PR_EMS_AB_CAN_CREATE_PF_BL_T         PROP_TAG( PT_MV_TSTRING,    0x8059)
#define PR_EMS_AB_CAN_CREATE_PF_DL           PROP_TAG( PT_MV_TSTRING,    0x805A)
#define PR_EMS_AB_CAN_CREATE_PF_DL_A         PROP_TAG( PT_MV_STRING8,    0x805A)
#define PR_EMS_AB_CAN_CREATE_PF_DL_W         PROP_TAG( PT_MV_UNICODE,    0x805A)
#define PR_EMS_AB_CAN_CREATE_PF_DL_O         PROP_TAG( PT_OBJECT,        0x805A)
#define PR_EMS_AB_CAN_CREATE_PF_DL_T         PROP_TAG( PT_MV_TSTRING,    0x805A)
#define PR_EMS_AB_CAN_CREATE_PF_DL_BL        PROP_TAG( PT_MV_TSTRING,    0x805B)
#define PR_EMS_AB_CAN_CREATE_PF_DL_BL_A      PROP_TAG( PT_MV_STRING8,    0x805B)
#define PR_EMS_AB_CAN_CREATE_PF_DL_BL_W      PROP_TAG( PT_MV_UNICODE,    0x805B)
#define PR_EMS_AB_CAN_CREATE_PF_DL_BL_O      PROP_TAG( PT_OBJECT,        0x805B)
#define PR_EMS_AB_CAN_CREATE_PF_DL_BL_T      PROP_TAG( PT_MV_TSTRING,    0x805B)
#define PR_EMS_AB_CAN_NOT_CREATE_PF          PROP_TAG( PT_MV_TSTRING,    0x805C)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_A        PROP_TAG( PT_MV_STRING8,    0x805C)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_W        PROP_TAG( PT_MV_UNICODE,    0x805C)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_O        PROP_TAG( PT_OBJECT,        0x805C)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_T        PROP_TAG( PT_MV_TSTRING,    0x805C)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_BL       PROP_TAG( PT_MV_TSTRING,    0x805D)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_BL_A     PROP_TAG( PT_MV_STRING8,    0x805D)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_BL_W     PROP_TAG( PT_MV_UNICODE,    0x805D)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_BL_O     PROP_TAG( PT_OBJECT,        0x805D)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_BL_T     PROP_TAG( PT_MV_TSTRING,    0x805D)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_DL       PROP_TAG( PT_MV_TSTRING,    0x805E)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_DL_A     PROP_TAG( PT_MV_STRING8,    0x805E)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_DL_W     PROP_TAG( PT_MV_UNICODE,    0x805E)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_DL_O     PROP_TAG( PT_OBJECT,        0x805E)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_DL_T     PROP_TAG( PT_MV_TSTRING,    0x805E)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_DL_BL    PROP_TAG( PT_MV_TSTRING,    0x805F)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_DL_BL_A  PROP_TAG( PT_MV_STRING8,    0x805F)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_DL_BL_W  PROP_TAG( PT_MV_UNICODE,    0x805F)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_DL_BL_O  PROP_TAG( PT_OBJECT,        0x805F)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_DL_BL_T  PROP_TAG( PT_MV_TSTRING,    0x805F)
#define PR_EMS_AB_CAN_PRESERVE_DNS           PROP_TAG( PT_BOOLEAN,       0x8060)
#define PR_EMS_AB_CERTIFICATE_REVOCATION_LIST PROP_TAG( PT_BINARY,        0x8016)
#define PR_EMS_AB_CLOCK_ALERT_OFFSET         PROP_TAG( PT_LONG,          0x8061)
#define PR_EMS_AB_CLOCK_ALERT_REPAIR         PROP_TAG( PT_BOOLEAN,       0x8062)
#define PR_EMS_AB_CLOCK_WARNING_OFFSET       PROP_TAG( PT_LONG,          0x8063)
#define PR_EMS_AB_CLOCK_WARNING_REPAIR       PROP_TAG( PT_BOOLEAN,       0x8064)
#define PR_EMS_AB_COMPUTER_NAME              PROP_TAG( PT_TSTRING,       0x8065)
#define PR_EMS_AB_COMPUTER_NAME_A            PROP_TAG( PT_STRING8,       0x8065)
#define PR_EMS_AB_COMPUTER_NAME_W            PROP_TAG( PT_UNICODE,       0x8065)
#define PR_EMS_AB_CONNECTED_DOMAINS          PROP_TAG( PT_MV_TSTRING,    0x8066)
#define PR_EMS_AB_CONNECTED_DOMAINS_A        PROP_TAG( PT_MV_STRING8,    0x8066)
#define PR_EMS_AB_CONNECTED_DOMAINS_W        PROP_TAG( PT_MV_UNICODE,    0x8066)
#define PR_EMS_AB_CONTAINER_INFO             PROP_TAG( PT_LONG,          0x8067)
#define PR_EMS_AB_COST                       PROP_TAG( PT_LONG,          0x8068)
#define PR_EMS_AB_COUNTRY_NAME               PROP_TAG( PT_TSTRING,       0x8069)
#define PR_EMS_AB_COUNTRY_NAME_A             PROP_TAG( PT_STRING8,       0x8069)
#define PR_EMS_AB_COUNTRY_NAME_W             PROP_TAG( PT_UNICODE,       0x8069)
#define PR_EMS_AB_CROSS_CERTIFICATE_PAIR     PROP_TAG( PT_MV_BINARY,     0x8025)
#define PR_EMS_AB_DELIV_CONT_LENGTH          PROP_TAG( PT_LONG,          0x806A)
#define PR_EMS_AB_DELIV_EITS                 PROP_TAG( PT_MV_BINARY,     0x806B)
#define PR_EMS_AB_DELIV_EXT_CONT_TYPES       PROP_TAG( PT_MV_BINARY,     0x806C)
#define PR_EMS_AB_DELIVER_AND_REDIRECT       PROP_TAG( PT_BOOLEAN,       0x806D)
#define PR_EMS_AB_DELIVERY_MECHANISM         PROP_TAG( PT_LONG,          0x806E)
#define PR_EMS_AB_DESCRIPTION                PROP_TAG( PT_MV_TSTRING,    0x806F)
#define PR_EMS_AB_DESCRIPTION_A              PROP_TAG( PT_MV_STRING8,    0x806F)
#define PR_EMS_AB_DESCRIPTION_W              PROP_TAG( PT_MV_UNICODE,    0x806F)
#define PR_EMS_AB_DESTINATION_INDICATOR      PROP_TAG( PT_MV_TSTRING,    0x8070)
#define PR_EMS_AB_DESTINATION_INDICATOR_A    PROP_TAG( PT_MV_STRING8,    0x8070)
#define PR_EMS_AB_DESTINATION_INDICATOR_W    PROP_TAG( PT_MV_UNICODE,    0x8070)
#define PR_EMS_AB_DIAGNOSTIC_REG_KEY         PROP_TAG( PT_TSTRING,       0x8071)
#define PR_EMS_AB_DIAGNOSTIC_REG_KEY_A       PROP_TAG( PT_STRING8,       0x8071)
#define PR_EMS_AB_DIAGNOSTIC_REG_KEY_W       PROP_TAG( PT_UNICODE,       0x8071)
#define PR_EMS_AB_DISPLAY_NAME_OVERRIDE      PROP_TAG( PT_BOOLEAN,       0x8001)
#define PR_EMS_AB_DL_MEM_REJECT_PERMS_BL     PROP_TAG( PT_MV_TSTRING,    0x8072)
#define PR_EMS_AB_DL_MEM_REJECT_PERMS_BL_A   PROP_TAG( PT_MV_STRING8,    0x8072)
#define PR_EMS_AB_DL_MEM_REJECT_PERMS_BL_W   PROP_TAG( PT_MV_UNICODE,    0x8072)
#define PR_EMS_AB_DL_MEM_REJECT_PERMS_BL_O   PROP_TAG( PT_OBJECT,        0x8072)
#define PR_EMS_AB_DL_MEM_REJECT_PERMS_BL_T   PROP_TAG( PT_MV_TSTRING,    0x8072)
#define PR_EMS_AB_DL_MEM_SUBMIT_PERMS_BL     PROP_TAG( PT_MV_TSTRING,    0x8073)
#define PR_EMS_AB_DL_MEM_SUBMIT_PERMS_BL_A   PROP_TAG( PT_MV_STRING8,    0x8073)
#define PR_EMS_AB_DL_MEM_SUBMIT_PERMS_BL_W   PROP_TAG( PT_MV_UNICODE,    0x8073)
#define PR_EMS_AB_DL_MEM_SUBMIT_PERMS_BL_O   PROP_TAG( PT_OBJECT,        0x8073)
#define PR_EMS_AB_DL_MEM_SUBMIT_PERMS_BL_T   PROP_TAG( PT_MV_TSTRING,    0x8073)
#define PR_EMS_AB_DL_MEMBER_RULE             PROP_TAG( PT_MV_BINARY,     0x8074)
#define PR_EMS_AB_DOMAIN_DEF_ALT_RECIP       PROP_TAG( PT_TSTRING,       0x8075)
#define PR_EMS_AB_DOMAIN_DEF_ALT_RECIP_A     PROP_TAG( PT_STRING8,       0x8075)
#define PR_EMS_AB_DOMAIN_DEF_ALT_RECIP_W     PROP_TAG( PT_UNICODE,       0x8075)
#define PR_EMS_AB_DOMAIN_DEF_ALT_RECIP_O     PROP_TAG( PT_OBJECT,        0x8075)
#define PR_EMS_AB_DOMAIN_DEF_ALT_RECIP_T     PROP_TAG( PT_TSTRING,       0x8075)
#define PR_EMS_AB_DOMAIN_NAME                PROP_TAG( PT_TSTRING,       0x8076)
#define PR_EMS_AB_DOMAIN_NAME_A              PROP_TAG( PT_STRING8,       0x8076)
#define PR_EMS_AB_DOMAIN_NAME_W              PROP_TAG( PT_UNICODE,       0x8076)
#define PR_EMS_AB_DSA_SIGNATURE              PROP_TAG( PT_BINARY,        0x8077)
#define PR_EMS_AB_DXA_ADMIN_COPY             PROP_TAG( PT_BOOLEAN,       0x8078)
#define PR_EMS_AB_DXA_ADMIN_FORWARD          PROP_TAG( PT_BOOLEAN,       0x8079)
#define PR_EMS_AB_DXA_ADMIN_UPDATE           PROP_TAG( PT_LONG,          0x807A)
#define PR_EMS_AB_DXA_APPEND_REQCN           PROP_TAG( PT_BOOLEAN,       0x807B)
#define PR_EMS_AB_DXA_CONF_CONTAINER_LIST    PROP_TAG( PT_MV_TSTRING,    0x807C)
#define PR_EMS_AB_DXA_CONF_CONTAINER_LIST_A  PROP_TAG( PT_MV_STRING8,    0x807C)
#define PR_EMS_AB_DXA_CONF_CONTAINER_LIST_W  PROP_TAG( PT_MV_UNICODE,    0x807C)
#define PR_EMS_AB_DXA_CONF_CONTAINER_LIST_O  PROP_TAG( PT_OBJECT,        0x807C)
#define PR_EMS_AB_DXA_CONF_CONTAINER_LIST_T  PROP_TAG( PT_MV_TSTRING,    0x807C)
#define PR_EMS_AB_DXA_CONF_REQ_TIME          PROP_TAG( PT_SYSTIME,       0x807D)
#define PR_EMS_AB_DXA_CONF_SEQ               PROP_TAG( PT_TSTRING,       0x807E)
#define PR_EMS_AB_DXA_CONF_SEQ_A             PROP_TAG( PT_STRING8,       0x807E)
#define PR_EMS_AB_DXA_CONF_SEQ_W             PROP_TAG( PT_UNICODE,       0x807E)
#define PR_EMS_AB_DXA_CONF_SEQ_USN           PROP_TAG( PT_LONG,          0x807F)
#define PR_EMS_AB_DXA_EXCHANGE_OPTIONS       PROP_TAG( PT_LONG,          0x8080)
#define PR_EMS_AB_DXA_EXPORT_NOW             PROP_TAG( PT_BOOLEAN,       0x8081)
#define PR_EMS_AB_DXA_FLAGS                  PROP_TAG( PT_LONG,          0x8082)
#define PR_EMS_AB_DXA_IMP_SEQ                PROP_TAG( PT_TSTRING,       0x8083)
#define PR_EMS_AB_DXA_IMP_SEQ_A              PROP_TAG( PT_STRING8,       0x8083)
#define PR_EMS_AB_DXA_IMP_SEQ_W              PROP_TAG( PT_UNICODE,       0x8083)
#define PR_EMS_AB_DXA_IMP_SEQ_TIME           PROP_TAG( PT_SYSTIME,       0x8084)
#define PR_EMS_AB_DXA_IMP_SEQ_USN            PROP_TAG( PT_LONG,          0x8085)
#define PR_EMS_AB_DXA_IMPORT_NOW             PROP_TAG( PT_BOOLEAN,       0x8086)
#define PR_EMS_AB_DXA_IN_TEMPLATE_MAP        PROP_TAG( PT_MV_TSTRING,    0x8087)
#define PR_EMS_AB_DXA_IN_TEMPLATE_MAP_A      PROP_TAG( PT_MV_STRING8,    0x8087)
#define PR_EMS_AB_DXA_IN_TEMPLATE_MAP_W      PROP_TAG( PT_MV_UNICODE,    0x8087)
#define PR_EMS_AB_DXA_LOCAL_ADMIN            PROP_TAG( PT_TSTRING,       0x8088)
#define PR_EMS_AB_DXA_LOCAL_ADMIN_A          PROP_TAG( PT_STRING8,       0x8088)
#define PR_EMS_AB_DXA_LOCAL_ADMIN_W          PROP_TAG( PT_UNICODE,       0x8088)
#define PR_EMS_AB_DXA_LOCAL_ADMIN_O          PROP_TAG( PT_OBJECT,        0x8088)
#define PR_EMS_AB_DXA_LOCAL_ADMIN_T          PROP_TAG( PT_TSTRING,       0x8088)
#define PR_EMS_AB_DXA_LOGGING_LEVEL          PROP_TAG( PT_LONG,          0x8089)
#define PR_EMS_AB_DXA_NATIVE_ADDRESS_TYPE    PROP_TAG( PT_TSTRING,       0x808A)
#define PR_EMS_AB_DXA_NATIVE_ADDRESS_TYPE_A  PROP_TAG( PT_STRING8,       0x808A)
#define PR_EMS_AB_DXA_NATIVE_ADDRESS_TYPE_W  PROP_TAG( PT_UNICODE,       0x808A)
#define PR_EMS_AB_DXA_OUT_TEMPLATE_MAP       PROP_TAG( PT_MV_TSTRING,    0x808B)
#define PR_EMS_AB_DXA_OUT_TEMPLATE_MAP_A     PROP_TAG( PT_MV_STRING8,    0x808B)
#define PR_EMS_AB_DXA_OUT_TEMPLATE_MAP_W     PROP_TAG( PT_MV_UNICODE,    0x808B)
#define PR_EMS_AB_DXA_PASSWORD               PROP_TAG( PT_TSTRING,       0x808C)
#define PR_EMS_AB_DXA_PASSWORD_A             PROP_TAG( PT_STRING8,       0x808C)
#define PR_EMS_AB_DXA_PASSWORD_W             PROP_TAG( PT_UNICODE,       0x808C)
#define PR_EMS_AB_DXA_PREV_EXCHANGE_OPTIONS  PROP_TAG( PT_LONG,          0x808D)
#define PR_EMS_AB_DXA_PREV_EXPORT_NATIVE_ONLY PROP_TAG( PT_BOOLEAN,       0x808E)
#define PR_EMS_AB_DXA_PREV_IN_EXCHANGE_SENSITIVITY PROP_TAG( PT_LONG,          0x808F)
#define PR_EMS_AB_DXA_PREV_REMOTE_ENTRIES    PROP_TAG( PT_TSTRING,       0x8090)
#define PR_EMS_AB_DXA_PREV_REMOTE_ENTRIES_A  PROP_TAG( PT_STRING8,       0x8090)
#define PR_EMS_AB_DXA_PREV_REMOTE_ENTRIES_W  PROP_TAG( PT_UNICODE,       0x8090)
#define PR_EMS_AB_DXA_PREV_REMOTE_ENTRIES_O  PROP_TAG( PT_OBJECT,        0x8090)
#define PR_EMS_AB_DXA_PREV_REMOTE_ENTRIES_T  PROP_TAG( PT_TSTRING,       0x8090)
#define PR_EMS_AB_DXA_PREV_REPLICATION_SENSITIVITY PROP_TAG( PT_LONG,          0x8091)
#define PR_EMS_AB_DXA_PREV_TEMPLATE_OPTIONS  PROP_TAG( PT_LONG,          0x8092)
#define PR_EMS_AB_DXA_PREV_TYPES             PROP_TAG( PT_LONG,          0x8093)
#define PR_EMS_AB_DXA_RECIPIENT_CP           PROP_TAG( PT_TSTRING,       0x8094)
#define PR_EMS_AB_DXA_RECIPIENT_CP_A         PROP_TAG( PT_STRING8,       0x8094)
#define PR_EMS_AB_DXA_RECIPIENT_CP_W         PROP_TAG( PT_UNICODE,       0x8094)
#define PR_EMS_AB_DXA_REMOTE_CLIENT          PROP_TAG( PT_TSTRING,       0x8095)
#define PR_EMS_AB_DXA_REMOTE_CLIENT_A        PROP_TAG( PT_STRING8,       0x8095)
#define PR_EMS_AB_DXA_REMOTE_CLIENT_W        PROP_TAG( PT_UNICODE,       0x8095)
#define PR_EMS_AB_DXA_REMOTE_CLIENT_O        PROP_TAG( PT_OBJECT,        0x8095)
#define PR_EMS_AB_DXA_REMOTE_CLIENT_T        PROP_TAG( PT_TSTRING,       0x8095)
#define PR_EMS_AB_DXA_REQ_SEQ                PROP_TAG( PT_TSTRING,       0x8096)
#define PR_EMS_AB_DXA_REQ_SEQ_A              PROP_TAG( PT_STRING8,       0x8096)
#define PR_EMS_AB_DXA_REQ_SEQ_W              PROP_TAG( PT_UNICODE,       0x8096)
#define PR_EMS_AB_DXA_REQ_SEQ_TIME           PROP_TAG( PT_SYSTIME,       0x8097)
#define PR_EMS_AB_DXA_REQ_SEQ_USN            PROP_TAG( PT_LONG,          0x8098)
#define PR_EMS_AB_DXA_REQNAME                PROP_TAG( PT_TSTRING,       0x8099)
#define PR_EMS_AB_DXA_REQNAME_A              PROP_TAG( PT_STRING8,       0x8099)
#define PR_EMS_AB_DXA_REQNAME_W              PROP_TAG( PT_UNICODE,       0x8099)
#define PR_EMS_AB_DXA_SVR_SEQ                PROP_TAG( PT_TSTRING,       0x809A)
#define PR_EMS_AB_DXA_SVR_SEQ_A              PROP_TAG( PT_STRING8,       0x809A)
#define PR_EMS_AB_DXA_SVR_SEQ_W              PROP_TAG( PT_UNICODE,       0x809A)
#define PR_EMS_AB_DXA_SVR_SEQ_TIME           PROP_TAG( PT_SYSTIME,       0x809B)
#define PR_EMS_AB_DXA_SVR_SEQ_USN            PROP_TAG( PT_LONG,          0x809C)
#define PR_EMS_AB_DXA_TASK                   PROP_TAG( PT_LONG,          0x809D)
#define PR_EMS_AB_DXA_TEMPLATE_OPTIONS       PROP_TAG( PT_LONG,          0x809E)
#define PR_EMS_AB_DXA_TEMPLATE_TIMESTAMP     PROP_TAG( PT_SYSTIME,       0x809F)
#define PR_EMS_AB_DXA_TYPES                  PROP_TAG( PT_LONG,          0x80A0)
#define PR_EMS_AB_DXA_UNCONF_CONTAINER_LIST  PROP_TAG( PT_MV_TSTRING,    0x80A1)
#define PR_EMS_AB_DXA_UNCONF_CONTAINER_LIST_A PROP_TAG( PT_MV_STRING8,    0x80A1)
#define PR_EMS_AB_DXA_UNCONF_CONTAINER_LIST_W PROP_TAG( PT_MV_UNICODE,    0x80A1)
#define PR_EMS_AB_DXA_UNCONF_CONTAINER_LIST_O PROP_TAG( PT_OBJECT,        0x80A1)
#define PR_EMS_AB_DXA_UNCONF_CONTAINER_LIST_T PROP_TAG( PT_MV_TSTRING,    0x80A1)
#define PR_EMS_AB_ENABLED_PROTOCOLS          PROP_TAG( PT_LONG,          0x817F)
#define PR_EMS_AB_ENCAPSULATION_METHOD       PROP_TAG( PT_LONG,          0x80A2)
#define PR_EMS_AB_ENCRYPT                    PROP_TAG( PT_BOOLEAN,       0x80A3)
#define PR_EMS_AB_ENCRYPT_ALG_LIST_NA        PROP_TAG( PT_MV_TSTRING,    0x8040)
#define PR_EMS_AB_ENCRYPT_ALG_LIST_NA_A      PROP_TAG( PT_MV_STRING8,    0x8040)
#define PR_EMS_AB_ENCRYPT_ALG_LIST_NA_W      PROP_TAG( PT_MV_UNICODE,    0x8040)
#define PR_EMS_AB_ENCRYPT_ALG_LIST_OTHER     PROP_TAG( PT_MV_TSTRING,    0x8041)
#define PR_EMS_AB_ENCRYPT_ALG_LIST_OTHER_A   PROP_TAG( PT_MV_STRING8,    0x8041)
#define PR_EMS_AB_ENCRYPT_ALG_LIST_OTHER_W   PROP_TAG( PT_MV_UNICODE,    0x8041)
#define PR_EMS_AB_ENCRYPT_ALG_SELECTED_NA    PROP_TAG( PT_TSTRING,       0x8043)
#define PR_EMS_AB_ENCRYPT_ALG_SELECTED_NA_A  PROP_TAG( PT_STRING8,       0x8043)
#define PR_EMS_AB_ENCRYPT_ALG_SELECTED_NA_W  PROP_TAG( PT_UNICODE,       0x8043)
#define PR_EMS_AB_ENCRYPT_ALG_SELECTED_OTHER PROP_TAG( PT_TSTRING,       0x803D)
#define PR_EMS_AB_ENCRYPT_ALG_SELECTED_OTHER_A PROP_TAG( PT_STRING8,       0x803D)
#define PR_EMS_AB_ENCRYPT_ALG_SELECTED_OTHER_W PROP_TAG( PT_UNICODE,       0x803D)
#define PR_EMS_AB_EXPAND_DLS_LOCALLY         PROP_TAG( PT_BOOLEAN,       0x80A4)
#define PR_EMS_AB_EXPIRATION_TIME            PROP_TAG( PT_SYSTIME,       0x8028)
#define PR_EMS_AB_EXPORT_CONTAINERS          PROP_TAG( PT_MV_TSTRING,    0x80A5)
#define PR_EMS_AB_EXPORT_CONTAINERS_A        PROP_TAG( PT_MV_STRING8,    0x80A5)
#define PR_EMS_AB_EXPORT_CONTAINERS_W        PROP_TAG( PT_MV_UNICODE,    0x80A5)
#define PR_EMS_AB_EXPORT_CONTAINERS_O        PROP_TAG( PT_OBJECT,        0x80A5)
#define PR_EMS_AB_EXPORT_CONTAINERS_T        PROP_TAG( PT_MV_TSTRING,    0x80A5)
#define PR_EMS_AB_EXPORT_CUSTOM_RECIPIENTS   PROP_TAG( PT_BOOLEAN,       0x80A6)
#define PR_EMS_AB_EXTENDED_CHARS_ALLOWED     PROP_TAG( PT_BOOLEAN,       0x80A7)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_1      PROP_TAG( PT_TSTRING,       0x802D)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_1_A    PROP_TAG( PT_STRING8,       0x802D)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_1_W    PROP_TAG( PT_UNICODE,       0x802D)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_10     PROP_TAG( PT_TSTRING,       0x8036)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_10_A   PROP_TAG( PT_STRING8,       0x8036)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_10_W   PROP_TAG( PT_UNICODE,       0x8036)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_2      PROP_TAG( PT_TSTRING,       0x802E)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_2_A    PROP_TAG( PT_STRING8,       0x802E)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_2_W    PROP_TAG( PT_UNICODE,       0x802E)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_3      PROP_TAG( PT_TSTRING,       0x802F)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_3_A    PROP_TAG( PT_STRING8,       0x802F)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_3_W    PROP_TAG( PT_UNICODE,       0x802F)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_4      PROP_TAG( PT_TSTRING,       0x8030)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_4_A    PROP_TAG( PT_STRING8,       0x8030)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_4_W    PROP_TAG( PT_UNICODE,       0x8030)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_5      PROP_TAG( PT_TSTRING,       0x8031)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_5_A    PROP_TAG( PT_STRING8,       0x8031)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_5_W    PROP_TAG( PT_UNICODE,       0x8031)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_6      PROP_TAG( PT_TSTRING,       0x8032)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_6_A    PROP_TAG( PT_STRING8,       0x8032)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_6_W    PROP_TAG( PT_UNICODE,       0x8032)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_7      PROP_TAG( PT_TSTRING,       0x8033)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_7_A    PROP_TAG( PT_STRING8,       0x8033)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_7_W    PROP_TAG( PT_UNICODE,       0x8033)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_8      PROP_TAG( PT_TSTRING,       0x8034)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_8_A    PROP_TAG( PT_STRING8,       0x8034)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_8_W    PROP_TAG( PT_UNICODE,       0x8034)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_9      PROP_TAG( PT_TSTRING,       0x8035)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_9_A    PROP_TAG( PT_STRING8,       0x8035)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_9_W    PROP_TAG( PT_UNICODE,       0x8035)
#define PR_EMS_AB_EXTENSION_DATA             PROP_TAG( PT_MV_BINARY,     0x80A8)
#define PR_EMS_AB_EXTENSION_NAME             PROP_TAG( PT_MV_TSTRING,    0x80A9)
#define PR_EMS_AB_EXTENSION_NAME_A           PROP_TAG( PT_MV_STRING8,    0x80A9)
#define PR_EMS_AB_EXTENSION_NAME_W           PROP_TAG( PT_MV_UNICODE,    0x80A9)
#define PR_EMS_AB_EXTENSION_NAME_INHERITED   PROP_TAG( PT_MV_TSTRING,    0x80AA)
#define PR_EMS_AB_EXTENSION_NAME_INHERITED_A PROP_TAG( PT_MV_STRING8,    0x80AA)
#define PR_EMS_AB_EXTENSION_NAME_INHERITED_W PROP_TAG( PT_MV_UNICODE,    0x80AA)
#define PR_EMS_AB_FACSIMILE_TELEPHONE_NUMBER PROP_TAG( PT_MV_BINARY,     0x80AB)
#define PR_EMS_AB_FILE_VERSION               PROP_TAG( PT_BINARY,        0x80AC)
#define PR_EMS_AB_FILTER_LOCAL_ADDRESSES     PROP_TAG( PT_BOOLEAN,       0x80AD)
#define PR_EMS_AB_FOLDER_PATHNAME            PROP_TAG( PT_TSTRING,       0x8004)
#define PR_EMS_AB_FOLDER_PATHNAME_A          PROP_TAG( PT_STRING8,       0x8004)
#define PR_EMS_AB_FOLDER_PATHNAME_W          PROP_TAG( PT_UNICODE,       0x8004)
#define PR_EMS_AB_FOLDERS_CONTAINER          PROP_TAG( PT_TSTRING,       0x80AE)
#define PR_EMS_AB_FOLDERS_CONTAINER_A        PROP_TAG( PT_STRING8,       0x80AE)
#define PR_EMS_AB_FOLDERS_CONTAINER_W        PROP_TAG( PT_UNICODE,       0x80AE)
#define PR_EMS_AB_FOLDERS_CONTAINER_O        PROP_TAG( PT_OBJECT,        0x80AE)
#define PR_EMS_AB_FOLDERS_CONTAINER_T        PROP_TAG( PT_TSTRING,       0x80AE)
#define PR_EMS_AB_GARBAGE_COLL_PERIOD        PROP_TAG( PT_LONG,          0x80AF)
#define PR_EMS_AB_GATEWAY_LOCAL_CRED         PROP_TAG( PT_TSTRING,       0x80B0)
#define PR_EMS_AB_GATEWAY_LOCAL_CRED_A       PROP_TAG( PT_STRING8,       0x80B0)
#define PR_EMS_AB_GATEWAY_LOCAL_CRED_W       PROP_TAG( PT_UNICODE,       0x80B0)
#define PR_EMS_AB_GATEWAY_LOCAL_DESIG        PROP_TAG( PT_TSTRING,       0x80B1)
#define PR_EMS_AB_GATEWAY_LOCAL_DESIG_A      PROP_TAG( PT_STRING8,       0x80B1)
#define PR_EMS_AB_GATEWAY_LOCAL_DESIG_W      PROP_TAG( PT_UNICODE,       0x80B1)
#define PR_EMS_AB_GATEWAY_PROXY              PROP_TAG( PT_MV_TSTRING,    0x80B2)
#define PR_EMS_AB_GATEWAY_PROXY_A            PROP_TAG( PT_MV_STRING8,    0x80B2)
#define PR_EMS_AB_GATEWAY_PROXY_W            PROP_TAG( PT_MV_UNICODE,    0x80B2)
#define PR_EMS_AB_GATEWAY_ROUTING_TREE       PROP_TAG( PT_BINARY,        0x80B3)
#define PR_EMS_AB_GWART_LAST_MODIFIED        PROP_TAG( PT_SYSTIME,       0x80B4)
#define PR_EMS_AB_HAS_FULL_REPLICA_NCS       PROP_TAG( PT_MV_TSTRING,    0x80B5)
#define PR_EMS_AB_HAS_FULL_REPLICA_NCS_A     PROP_TAG( PT_MV_STRING8,    0x80B5)
#define PR_EMS_AB_HAS_FULL_REPLICA_NCS_W     PROP_TAG( PT_MV_UNICODE,    0x80B5)
#define PR_EMS_AB_HAS_FULL_REPLICA_NCS_O     PROP_TAG( PT_OBJECT,        0x80B5)
#define PR_EMS_AB_HAS_FULL_REPLICA_NCS_T     PROP_TAG( PT_MV_TSTRING,    0x80B5)
#define PR_EMS_AB_HAS_MASTER_NCS             PROP_TAG( PT_MV_TSTRING,    0x80B6)
#define PR_EMS_AB_HAS_MASTER_NCS_A           PROP_TAG( PT_MV_STRING8,    0x80B6)
#define PR_EMS_AB_HAS_MASTER_NCS_W           PROP_TAG( PT_MV_UNICODE,    0x80B6)
#define PR_EMS_AB_HAS_MASTER_NCS_O           PROP_TAG( PT_OBJECT,        0x80B6)
#define PR_EMS_AB_HAS_MASTER_NCS_T           PROP_TAG( PT_MV_TSTRING,    0x80B6)
#define PR_EMS_AB_HELP_DATA16                PROP_TAG( PT_BINARY,        0x803A)
#define PR_EMS_AB_HELP_DATA32                PROP_TAG( PT_BINARY,        0x8010)
#define PR_EMS_AB_HELP_FILE_NAME             PROP_TAG( PT_TSTRING,       0x803B)
#define PR_EMS_AB_HELP_FILE_NAME_A           PROP_TAG( PT_STRING8,       0x803B)
#define PR_EMS_AB_HELP_FILE_NAME_W           PROP_TAG( PT_UNICODE,       0x803B)
#define PR_EMS_AB_HEURISTICS                 PROP_TAG( PT_LONG,          0x80B7)
#define PR_EMS_AB_HIDE_DL_MEMBERSHIP         PROP_TAG( PT_BOOLEAN,       0x80B8)
#define PR_EMS_AB_HIDE_FROM_ADDRESS_BOOK     PROP_TAG( PT_BOOLEAN,       0x80B9)
#define PR_EMS_AB_HOME_MDB                   PROP_TAG( PT_TSTRING,       0x8006)
#define PR_EMS_AB_HOME_MDB_A                 PROP_TAG( PT_STRING8,       0x8006)
#define PR_EMS_AB_HOME_MDB_W                 PROP_TAG( PT_UNICODE,       0x8006)
#define PR_EMS_AB_HOME_MDB_O                 PROP_TAG( PT_OBJECT,        0x8006)
#define PR_EMS_AB_HOME_MDB_T                 PROP_TAG( PT_TSTRING,       0x8006)
#define PR_EMS_AB_HOME_MDB_BL                PROP_TAG( PT_MV_TSTRING,    0x8014)
#define PR_EMS_AB_HOME_MDB_BL_A              PROP_TAG( PT_MV_STRING8,    0x8014)
#define PR_EMS_AB_HOME_MDB_BL_W              PROP_TAG( PT_MV_UNICODE,    0x8014)
#define PR_EMS_AB_HOME_MDB_BL_O              PROP_TAG( PT_OBJECT,        0x8014)
#define PR_EMS_AB_HOME_MDB_BL_T              PROP_TAG( PT_MV_TSTRING,    0x8014)
#define PR_EMS_AB_HOME_MTA                   PROP_TAG( PT_TSTRING,       0x8007)
#define PR_EMS_AB_HOME_MTA_A                 PROP_TAG( PT_STRING8,       0x8007)
#define PR_EMS_AB_HOME_MTA_W                 PROP_TAG( PT_UNICODE,       0x8007)
#define PR_EMS_AB_HOME_MTA_O                 PROP_TAG( PT_OBJECT,        0x8007)
#define PR_EMS_AB_HOME_MTA_T                 PROP_TAG( PT_TSTRING,       0x8007)
#define PR_EMS_AB_HOME_PUBLIC_SERVER         PROP_TAG( PT_TSTRING,       0x803F)
#define PR_EMS_AB_HOME_PUBLIC_SERVER_A       PROP_TAG( PT_STRING8,       0x803F)
#define PR_EMS_AB_HOME_PUBLIC_SERVER_W       PROP_TAG( PT_UNICODE,       0x803F)
#define PR_EMS_AB_HOME_PUBLIC_SERVER_O       PROP_TAG( PT_OBJECT,        0x803F)
#define PR_EMS_AB_HOME_PUBLIC_SERVER_T       PROP_TAG( PT_TSTRING,       0x803F)
#define PR_EMS_AB_IMPORT_CONTAINER           PROP_TAG( PT_TSTRING,       0x80BA)
#define PR_EMS_AB_IMPORT_CONTAINER_A         PROP_TAG( PT_STRING8,       0x80BA)
#define PR_EMS_AB_IMPORT_CONTAINER_W         PROP_TAG( PT_UNICODE,       0x80BA)
#define PR_EMS_AB_IMPORT_CONTAINER_O         PROP_TAG( PT_OBJECT,        0x80BA)
#define PR_EMS_AB_IMPORT_CONTAINER_T         PROP_TAG( PT_TSTRING,       0x80BA)
#define PR_EMS_AB_IMPORT_SENSITIVITY         PROP_TAG( PT_LONG,          0x80BB)
#define PR_EMS_AB_IMPORTED_FROM              PROP_TAG( PT_TSTRING,       0x8042)
#define PR_EMS_AB_IMPORTED_FROM_A            PROP_TAG( PT_STRING8,       0x8042)
#define PR_EMS_AB_IMPORTED_FROM_W            PROP_TAG( PT_UNICODE,       0x8042)
#define PR_EMS_AB_INBOUND_SITES              PROP_TAG( PT_MV_TSTRING,    0x80BC)
#define PR_EMS_AB_INBOUND_SITES_A            PROP_TAG( PT_MV_STRING8,    0x80BC)
#define PR_EMS_AB_INBOUND_SITES_W            PROP_TAG( PT_MV_UNICODE,    0x80BC)
#define PR_EMS_AB_INBOUND_SITES_O            PROP_TAG( PT_OBJECT,        0x80BC)
#define PR_EMS_AB_INBOUND_SITES_T            PROP_TAG( PT_MV_TSTRING,    0x80BC)
#define PR_EMS_AB_INSTANCE_TYPE              PROP_TAG( PT_LONG,          0x80BD)
#define PR_EMS_AB_INTERNATIONAL_ISDN_NUMBER  PROP_TAG( PT_MV_TSTRING,    0x80BE)
#define PR_EMS_AB_INTERNATIONAL_ISDN_NUMBER_A PROP_TAG( PT_MV_STRING8,    0x80BE)
#define PR_EMS_AB_INTERNATIONAL_ISDN_NUMBER_W PROP_TAG( PT_MV_UNICODE,    0x80BE)
#define PR_EMS_AB_INVOCATION_ID              PROP_TAG( PT_BINARY,        0x80BF)
#define PR_EMS_AB_IS_DELETED                 PROP_TAG( PT_BOOLEAN,       0x80C0)
#define PR_EMS_AB_IS_MEMBER_OF_DL            PROP_TAG( PT_OBJECT,	 0x8008)
#define PR_EMS_AB_IS_MEMBER_OF_DL_A          PROP_TAG( PT_MV_STRING8,    0x8008)
#define PR_EMS_AB_IS_MEMBER_OF_DL_W          PROP_TAG( PT_MV_UNICODE,    0x8008)
#define PR_EMS_AB_IS_MEMBER_OF_DL_O          PROP_TAG( PT_OBJECT,        0x8008)
#define PR_EMS_AB_IS_MEMBER_OF_DL_T          PROP_TAG( PT_MV_TSTRING,    0x8008)
#define PR_EMS_AB_IS_SINGLE_VALUED           PROP_TAG( PT_BOOLEAN,       0x80C1)
#define PR_EMS_AB_KCC_STATUS                 PROP_TAG( PT_MV_BINARY,     0x80C2)
#define PR_EMS_AB_KM_SERVER                  PROP_TAG( PT_TSTRING,       0x800D)
#define PR_EMS_AB_KM_SERVER_A                PROP_TAG( PT_STRING8,       0x800D)
#define PR_EMS_AB_KM_SERVER_W                PROP_TAG( PT_UNICODE,       0x800D)
#define PR_EMS_AB_KM_SERVER_O                PROP_TAG( PT_OBJECT,        0x800D)
#define PR_EMS_AB_KM_SERVER_T                PROP_TAG( PT_TSTRING,       0x800D)
#define PR_EMS_AB_KNOWLEDGE_INFORMATION      PROP_TAG( PT_MV_TSTRING,    0x80C3)
#define PR_EMS_AB_KNOWLEDGE_INFORMATION_A    PROP_TAG( PT_MV_STRING8,    0x80C3)
#define PR_EMS_AB_KNOWLEDGE_INFORMATION_W    PROP_TAG( PT_MV_UNICODE,    0x80C3)
#define PR_EMS_AB_LANGUAGE                   PROP_TAG( PT_LONG,          0x8178)
#define PR_EMS_AB_LDAP_DISPLAY_NAME          PROP_TAG( PT_MV_TSTRING,    0x8171)
#define PR_EMS_AB_LDAP_DISPLAY_NAME_A        PROP_TAG( PT_MV_STRING8,    0x8171)
#define PR_EMS_AB_LDAP_DISPLAY_NAME_W        PROP_TAG( PT_MV_UNICODE,    0x8171)
#define PR_EMS_AB_LINE_WRAP                  PROP_TAG( PT_LONG,          0x80C4)
#define PR_EMS_AB_LINK_ID                    PROP_TAG( PT_LONG,          0x80C5)
#define PR_EMS_AB_LOCAL_BRIDGE_HEAD          PROP_TAG( PT_TSTRING,       0x80C6)
#define PR_EMS_AB_LOCAL_BRIDGE_HEAD_A        PROP_TAG( PT_STRING8,       0x80C6)
#define PR_EMS_AB_LOCAL_BRIDGE_HEAD_W        PROP_TAG( PT_UNICODE,       0x80C6)
#define PR_EMS_AB_LOCAL_BRIDGE_HEAD_ADDRESS  PROP_TAG( PT_TSTRING,       0x80C7)
#define PR_EMS_AB_LOCAL_BRIDGE_HEAD_ADDRESS_A PROP_TAG( PT_STRING8,       0x80C7)
#define PR_EMS_AB_LOCAL_BRIDGE_HEAD_ADDRESS_W PROP_TAG( PT_UNICODE,       0x80C7)
#define PR_EMS_AB_LOCAL_INITIAL_TURN         PROP_TAG( PT_BOOLEAN,       0x80C8)
#define PR_EMS_AB_LOCAL_SCOPE                PROP_TAG( PT_MV_TSTRING,    0x80C9)
#define PR_EMS_AB_LOCAL_SCOPE_A              PROP_TAG( PT_MV_STRING8,    0x80C9)
#define PR_EMS_AB_LOCAL_SCOPE_W              PROP_TAG( PT_MV_UNICODE,    0x80C9)
#define PR_EMS_AB_LOCAL_SCOPE_O              PROP_TAG( PT_OBJECT,        0x80C9)
#define PR_EMS_AB_LOCAL_SCOPE_T              PROP_TAG( PT_MV_TSTRING,    0x80C9)
#define PR_EMS_AB_LOG_FILENAME               PROP_TAG( PT_TSTRING,       0x80CA)
#define PR_EMS_AB_LOG_FILENAME_A             PROP_TAG( PT_STRING8,       0x80CA)
#define PR_EMS_AB_LOG_FILENAME_W             PROP_TAG( PT_UNICODE,       0x80CA)
#define PR_EMS_AB_LOG_ROLLOVER_INTERVAL      PROP_TAG( PT_LONG,          0x80CB)
#define PR_EMS_AB_MAINTAIN_AUTOREPLY_HISTORY PROP_TAG( PT_BOOLEAN,       0x80CC)
#define PR_EMS_AB_MANAGER                    PROP_TAG( PT_OBJECT,        0x8005)
#define PR_EMS_AB_MANAGER_A                  PROP_TAG( PT_STRING8,       0x8005)
#define PR_EMS_AB_MANAGER_W                  PROP_TAG( PT_UNICODE,       0x8005)
#define PR_EMS_AB_MANAGER_O                  PROP_TAG( PT_OBJECT,        0x8005)
#define PR_EMS_AB_MANAGER_T                  PROP_TAG( PT_TSTRING,       0x8005)
#define PR_EMS_AB_MAPI_DISPLAY_TYPE          PROP_TAG( PT_LONG,          0x80CD)
#define PR_EMS_AB_MAPI_ID                    PROP_TAG( PT_LONG,          0x80CE)
#define PR_EMS_AB_MAXIMUM_OBJECT_ID          PROP_TAG( PT_BINARY,        0x8169)
#define PR_EMS_AB_MDB_BACKOFF_INTERVAL       PROP_TAG( PT_LONG,          0x80CF)
#define PR_EMS_AB_MDB_MSG_TIME_OUT_PERIOD    PROP_TAG( PT_LONG,          0x80D0)
#define PR_EMS_AB_MDB_OVER_QUOTA_LIMIT       PROP_TAG( PT_LONG,          0x80D1)
#define PR_EMS_AB_MDB_STORAGE_QUOTA          PROP_TAG( PT_LONG,          0x80D2)
#define PR_EMS_AB_MDB_UNREAD_LIMIT           PROP_TAG( PT_LONG,          0x80D3)
#define PR_EMS_AB_MDB_USE_DEFAULTS           PROP_TAG( PT_BOOLEAN,       0x80D4)
#define PR_EMS_AB_MEMBER                     PROP_TAG( PT_OBJECT,        0x8009)
#define PR_EMS_AB_MEMBER_A                   PROP_TAG( PT_MV_STRING8,    0x8009)
#define PR_EMS_AB_MEMBER_W                   PROP_TAG( PT_MV_UNICODE,    0x8009)
#define PR_EMS_AB_MEMBER_O                   PROP_TAG( PT_OBJECT,        0x8009)
#define PR_EMS_AB_MEMBER_T                   PROP_TAG( PT_MV_TSTRING,    0x8009)
#define PR_EMS_AB_MESSAGE_TRACKING_ENABLED   PROP_TAG( PT_BOOLEAN,       0x80D5)
#define PR_EMS_AB_MONITOR_CLOCK              PROP_TAG( PT_BOOLEAN,       0x80D6)
#define PR_EMS_AB_MONITOR_SERVERS            PROP_TAG( PT_BOOLEAN,       0x80D7)
#define PR_EMS_AB_MONITOR_SERVICES           PROP_TAG( PT_BOOLEAN,       0x80D8)
#define PR_EMS_AB_MONITORED_CONFIGURATIONS   PROP_TAG( PT_MV_TSTRING,    0x80D9)
#define PR_EMS_AB_MONITORED_CONFIGURATIONS_A PROP_TAG( PT_MV_STRING8,    0x80D9)
#define PR_EMS_AB_MONITORED_CONFIGURATIONS_W PROP_TAG( PT_MV_UNICODE,    0x80D9)
#define PR_EMS_AB_MONITORED_CONFIGURATIONS_O PROP_TAG( PT_OBJECT,        0x80D9)
#define PR_EMS_AB_MONITORED_CONFIGURATIONS_T PROP_TAG( PT_MV_TSTRING,    0x80D9)
#define PR_EMS_AB_MONITORED_SERVERS          PROP_TAG( PT_MV_TSTRING,    0x80DA)
#define PR_EMS_AB_MONITORED_SERVERS_A        PROP_TAG( PT_MV_STRING8,    0x80DA)
#define PR_EMS_AB_MONITORED_SERVERS_W        PROP_TAG( PT_MV_UNICODE,    0x80DA)
#define PR_EMS_AB_MONITORED_SERVERS_O        PROP_TAG( PT_OBJECT,        0x80DA)
#define PR_EMS_AB_MONITORED_SERVERS_T        PROP_TAG( PT_MV_TSTRING,    0x80DA)
#define PR_EMS_AB_MONITORED_SERVICES         PROP_TAG( PT_MV_TSTRING,    0x80DB)
#define PR_EMS_AB_MONITORED_SERVICES_A       PROP_TAG( PT_MV_STRING8,    0x80DB)
#define PR_EMS_AB_MONITORED_SERVICES_W       PROP_TAG( PT_MV_UNICODE,    0x80DB)
#define PR_EMS_AB_MONITORING_ALERT_DELAY     PROP_TAG( PT_LONG,          0x80DC)
#define PR_EMS_AB_MONITORING_ALERT_UNITS     PROP_TAG( PT_LONG,          0x80DD)
#define PR_EMS_AB_MONITORING_AVAILABILITY_STYLE PROP_TAG( PT_LONG,          0x80DE)
#define PR_EMS_AB_MONITORING_AVAILABILITY_WINDOW PROP_TAG( PT_BINARY,        0x80DF)
#define PR_EMS_AB_MONITORING_CACHED_VIA_MAIL PROP_TAG( PT_MV_TSTRING,    0x80E0)
#define PR_EMS_AB_MONITORING_CACHED_VIA_MAIL_A PROP_TAG( PT_MV_STRING8,    0x80E0)
#define PR_EMS_AB_MONITORING_CACHED_VIA_MAIL_W PROP_TAG( PT_MV_UNICODE,    0x80E0)
#define PR_EMS_AB_MONITORING_CACHED_VIA_MAIL_O PROP_TAG( PT_OBJECT,        0x80E0)
#define PR_EMS_AB_MONITORING_CACHED_VIA_MAIL_T PROP_TAG( PT_MV_TSTRING,    0x80E0)
#define PR_EMS_AB_MONITORING_CACHED_VIA_RPC  PROP_TAG( PT_MV_TSTRING,    0x80E1)
#define PR_EMS_AB_MONITORING_CACHED_VIA_RPC_A PROP_TAG( PT_MV_STRING8,    0x80E1)
#define PR_EMS_AB_MONITORING_CACHED_VIA_RPC_W PROP_TAG( PT_MV_UNICODE,    0x80E1)
#define PR_EMS_AB_MONITORING_CACHED_VIA_RPC_O PROP_TAG( PT_OBJECT,        0x80E1)
#define PR_EMS_AB_MONITORING_CACHED_VIA_RPC_T PROP_TAG( PT_MV_TSTRING,    0x80E1)
#define PR_EMS_AB_MONITORING_ESCALATION_PROCEDURE PROP_TAG( PT_MV_BINARY,     0x80E2)
#define PR_EMS_AB_MONITORING_HOTSITE_POLL_INTERVAL PROP_TAG( PT_LONG,          0x80E3)
#define PR_EMS_AB_MONITORING_HOTSITE_POLL_UNITS PROP_TAG( PT_LONG,          0x80E4)
#define PR_EMS_AB_MONITORING_MAIL_UPDATE_INTERVAL PROP_TAG( PT_LONG,          0x80E5)
#define PR_EMS_AB_MONITORING_MAIL_UPDATE_UNITS PROP_TAG( PT_LONG,          0x80E6)
#define PR_EMS_AB_MONITORING_NORMAL_POLL_INTERVAL PROP_TAG( PT_LONG,          0x80E7)
#define PR_EMS_AB_MONITORING_NORMAL_POLL_UNITS PROP_TAG( PT_LONG,          0x80E8)
#define PR_EMS_AB_MONITORING_RECIPIENTS      PROP_TAG( PT_MV_TSTRING,    0x80E9)
#define PR_EMS_AB_MONITORING_RECIPIENTS_A    PROP_TAG( PT_MV_STRING8,    0x80E9)
#define PR_EMS_AB_MONITORING_RECIPIENTS_W    PROP_TAG( PT_MV_UNICODE,    0x80E9)
#define PR_EMS_AB_MONITORING_RECIPIENTS_O    PROP_TAG( PT_OBJECT,        0x80E9)
#define PR_EMS_AB_MONITORING_RECIPIENTS_T    PROP_TAG( PT_MV_TSTRING,    0x80E9)
#define PR_EMS_AB_MONITORING_RECIPIENTS_NDR  PROP_TAG( PT_MV_TSTRING,    0x80EA)
#define PR_EMS_AB_MONITORING_RECIPIENTS_NDR_A PROP_TAG( PT_MV_STRING8,    0x80EA)
#define PR_EMS_AB_MONITORING_RECIPIENTS_NDR_W PROP_TAG( PT_MV_UNICODE,    0x80EA)
#define PR_EMS_AB_MONITORING_RECIPIENTS_NDR_O PROP_TAG( PT_OBJECT,        0x80EA)
#define PR_EMS_AB_MONITORING_RECIPIENTS_NDR_T PROP_TAG( PT_MV_TSTRING,    0x80EA)
#define PR_EMS_AB_MONITORING_RPC_UPDATE_INTERVAL PROP_TAG( PT_LONG,          0x80EB)
#define PR_EMS_AB_MONITORING_RPC_UPDATE_UNITS PROP_TAG( PT_LONG,          0x80EC)
#define PR_EMS_AB_MONITORING_WARNING_DELAY   PROP_TAG( PT_LONG,          0x80ED)
#define PR_EMS_AB_MONITORING_WARNING_UNITS   PROP_TAG( PT_LONG,          0x80EE)
#define PR_EMS_AB_MTA_LOCAL_CRED             PROP_TAG( PT_TSTRING,       0x80EF)
#define PR_EMS_AB_MTA_LOCAL_CRED_A           PROP_TAG( PT_STRING8,       0x80EF)
#define PR_EMS_AB_MTA_LOCAL_CRED_W           PROP_TAG( PT_UNICODE,       0x80EF)
#define PR_EMS_AB_MTA_LOCAL_DESIG            PROP_TAG( PT_TSTRING,       0x80F0)
#define PR_EMS_AB_MTA_LOCAL_DESIG_A          PROP_TAG( PT_STRING8,       0x80F0)
#define PR_EMS_AB_MTA_LOCAL_DESIG_W          PROP_TAG( PT_UNICODE,       0x80F0)
#define PR_EMS_AB_N_ADDRESS                  PROP_TAG( PT_BINARY,        0x80F1)
#define PR_EMS_AB_N_ADDRESS_TYPE             PROP_TAG( PT_LONG,          0x80F2)
#define PR_EMS_AB_NETWORK_ADDRESS            PROP_TAG( PT_MV_TSTRING,    0x8170)
#define PR_EMS_AB_NETWORK_ADDRESS_A          PROP_TAG( PT_MV_STRING8,    0x8170)
#define PR_EMS_AB_NETWORK_ADDRESS_W          PROP_TAG( PT_MV_UNICODE,    0x8170)
#define PR_EMS_AB_NNTP_CHARACTER_SET         PROP_TAG( PT_TSTRING,       0x817D)
#define PR_EMS_AB_NNTP_CHARACTER_SET_A       PROP_TAG( PT_STRING8,       0x817D)
#define PR_EMS_AB_NNTP_CHARACTER_SET_W       PROP_TAG( PT_UNICODE,       0x817D)
#define PR_EMS_AB_NNTP_CONTENT_FORMAT        PROP_TAG( PT_TSTRING,       0x8176)
#define PR_EMS_AB_NNTP_CONTENT_FORMAT_A      PROP_TAG( PT_STRING8,       0x8176)
#define PR_EMS_AB_NNTP_CONTENT_FORMAT_W      PROP_TAG( PT_UNICODE,       0x8176)
#define PR_EMS_AB_NT_MACHINE_NAME            PROP_TAG( PT_TSTRING,       0x80F3)
#define PR_EMS_AB_NT_MACHINE_NAME_A          PROP_TAG( PT_STRING8,       0x80F3)
#define PR_EMS_AB_NT_MACHINE_NAME_W          PROP_TAG( PT_UNICODE,       0x80F3)
#define PR_EMS_AB_NT_SECURITY_DESCRIPTOR     PROP_TAG( PT_BINARY,        0x8013)
#define PR_EMS_AB_NUM_OF_OPEN_RETRIES        PROP_TAG( PT_LONG,          0x80F4)
#define PR_EMS_AB_NUM_OF_TRANSFER_RETRIES    PROP_TAG( PT_LONG,          0x80F5)
#define PR_EMS_AB_OBJ_DIST_NAME              PROP_TAG( PT_TSTRING,       0x803C)
#define PR_EMS_AB_OBJ_DIST_NAME_A            PROP_TAG( PT_STRING8,       0x803C)
#define PR_EMS_AB_OBJ_DIST_NAME_W            PROP_TAG( PT_UNICODE,       0x803C)
#define PR_EMS_AB_OBJ_DIST_NAME_O            PROP_TAG( PT_OBJECT,        0x803C)
#define PR_EMS_AB_OBJ_DIST_NAME_T            PROP_TAG( PT_TSTRING,       0x803C)
#define PR_EMS_AB_OBJECT_CLASS_CATEGORY      PROP_TAG( PT_LONG,          0x80F6)
#define PR_EMS_AB_OBJECT_VERSION             PROP_TAG( PT_LONG,          0x80F7)
#define PR_EMS_AB_OFF_LINE_AB_CONTAINERS     PROP_TAG( PT_MV_TSTRING,    0x80F8)
#define PR_EMS_AB_OFF_LINE_AB_CONTAINERS_A   PROP_TAG( PT_MV_STRING8,    0x80F8)
#define PR_EMS_AB_OFF_LINE_AB_CONTAINERS_W   PROP_TAG( PT_MV_UNICODE,    0x80F8)
#define PR_EMS_AB_OFF_LINE_AB_CONTAINERS_O   PROP_TAG( PT_OBJECT,        0x80F8)
#define PR_EMS_AB_OFF_LINE_AB_CONTAINERS_T   PROP_TAG( PT_MV_TSTRING,    0x80F8)
#define PR_EMS_AB_OFF_LINE_AB_SCHEDULE       PROP_TAG( PT_BINARY,        0x80F9)
#define PR_EMS_AB_OFF_LINE_AB_SERVER         PROP_TAG( PT_TSTRING,       0x80FA)
#define PR_EMS_AB_OFF_LINE_AB_SERVER_A       PROP_TAG( PT_STRING8,       0x80FA)
#define PR_EMS_AB_OFF_LINE_AB_SERVER_W       PROP_TAG( PT_UNICODE,       0x80FA)
#define PR_EMS_AB_OFF_LINE_AB_SERVER_O       PROP_TAG( PT_OBJECT,        0x80FA)
#define PR_EMS_AB_OFF_LINE_AB_SERVER_T       PROP_TAG( PT_TSTRING,       0x80FA)
#define PR_EMS_AB_OFF_LINE_AB_STYLE          PROP_TAG( PT_LONG,          0x80FB)
#define PR_EMS_AB_OID_TYPE                   PROP_TAG( PT_LONG,          0x80FC)
#define PR_EMS_AB_OM_OBJECT_CLASS            PROP_TAG( PT_BINARY,        0x80FD)
#define PR_EMS_AB_OM_SYNTAX                  PROP_TAG( PT_LONG,          0x80FE)
#define PR_EMS_AB_OOF_REPLY_TO_ORIGINATOR    PROP_TAG( PT_BOOLEAN,       0x80FF)
#define PR_EMS_AB_OPEN_RETRY_INTERVAL        PROP_TAG( PT_LONG,          0x8100)
#define PR_EMS_AB_ORGANIZATION_NAME          PROP_TAG( PT_MV_TSTRING,    0x8101)
#define PR_EMS_AB_ORGANIZATION_NAME_A        PROP_TAG( PT_MV_STRING8,    0x8101)
#define PR_EMS_AB_ORGANIZATION_NAME_W        PROP_TAG( PT_MV_UNICODE,    0x8101)
#define PR_EMS_AB_ORGANIZATIONAL_UNIT_NAME   PROP_TAG( PT_MV_TSTRING,    0x8102)
#define PR_EMS_AB_ORGANIZATIONAL_UNIT_NAME_A PROP_TAG( PT_MV_STRING8,    0x8102)
#define PR_EMS_AB_ORGANIZATIONAL_UNIT_NAME_W PROP_TAG( PT_MV_UNICODE,    0x8102)
#define PR_EMS_AB_ORIGINAL_DISPLAY_TABLE     PROP_TAG( PT_BINARY,        0x8103)
#define PR_EMS_AB_ORIGINAL_DISPLAY_TABLE_MSDOS PROP_TAG( PT_BINARY,        0x8104)
#define PR_EMS_AB_OUTBOUND_SITES             PROP_TAG( PT_MV_TSTRING,    0x8105)
#define PR_EMS_AB_OUTBOUND_SITES_A           PROP_TAG( PT_MV_STRING8,    0x8105)
#define PR_EMS_AB_OUTBOUND_SITES_W           PROP_TAG( PT_MV_UNICODE,    0x8105)
#define PR_EMS_AB_OUTBOUND_SITES_O           PROP_TAG( PT_OBJECT,        0x8105)
#define PR_EMS_AB_OUTBOUND_SITES_T           PROP_TAG( PT_MV_TSTRING,    0x8105)
#define PR_EMS_AB_OWNER                      PROP_TAG( PT_TSTRING,       0x800C)
#define PR_EMS_AB_OWNER_A                    PROP_TAG( PT_STRING8,       0x800C)
#define PR_EMS_AB_OWNER_W                    PROP_TAG( PT_UNICODE,       0x800C)
#define PR_EMS_AB_OWNER_O                    PROP_TAG( PT_OBJECT,        0x800C)
#define PR_EMS_AB_OWNER_T                    PROP_TAG( PT_TSTRING,       0x800C)
#define PR_EMS_AB_OWNER_BL                   PROP_TAG( PT_TSTRING,       0x8024)
#define PR_EMS_AB_OWNER_BL_A                 PROP_TAG( PT_STRING8,       0x8024)
#define PR_EMS_AB_OWNER_BL_W                 PROP_TAG( PT_UNICODE,       0x8024)
#define PR_EMS_AB_OWNER_BL_O                 PROP_TAG( PT_OBJECT,        0x8024)
#define PR_EMS_AB_OWNER_BL_T                 PROP_TAG( PT_TSTRING,       0x8024)
#define PR_EMS_AB_P_SELECTOR                 PROP_TAG( PT_BINARY,        0x8106)
#define PR_EMS_AB_P_SELECTOR_INBOUND         PROP_TAG( PT_BINARY,        0x8107)
#define PR_EMS_AB_PER_MSG_DIALOG_DISPLAY_TABLE PROP_TAG( PT_BINARY,        0x8108)
#define PR_EMS_AB_PER_RECIP_DIALOG_DISPLAY_TABLE PROP_TAG( PT_BINARY,        0x8109)
#define PR_EMS_AB_PERIOD_REP_SYNC_TIMES      PROP_TAG( PT_BINARY,        0x810A)
#define PR_EMS_AB_PERIOD_REPL_STAGGER        PROP_TAG( PT_LONG,          0x810B)
#define PR_EMS_AB_PF_CONTACTS                PROP_TAG( PT_MV_TSTRING,    0x8038)
#define PR_EMS_AB_PF_CONTACTS_A              PROP_TAG( PT_MV_STRING8,    0x8038)
#define PR_EMS_AB_PF_CONTACTS_W              PROP_TAG( PT_MV_UNICODE,    0x8038)
#define PR_EMS_AB_PF_CONTACTS_O              PROP_TAG( PT_OBJECT,        0x8038)
#define PR_EMS_AB_PF_CONTACTS_T              PROP_TAG( PT_MV_TSTRING,    0x8038)
#define PR_EMS_AB_POP_CHARACTER_SET          PROP_TAG( PT_TSTRING,       0x8179)
#define PR_EMS_AB_POP_CHARACTER_SET_A        PROP_TAG( PT_STRING8,       0x8179)
#define PR_EMS_AB_POP_CHARACTER_SET_W        PROP_TAG( PT_UNICODE,       0x8179)
#define PR_EMS_AB_POP_CONTENT_FORMAT         PROP_TAG( PT_TSTRING,       0x8177)
#define PR_EMS_AB_POP_CONTENT_FORMAT_A       PROP_TAG( PT_STRING8,       0x8177)
#define PR_EMS_AB_POP_CONTENT_FORMAT_W       PROP_TAG( PT_UNICODE,       0x8177)
#define PR_EMS_AB_POSTAL_ADDRESS             PROP_TAG( PT_MV_BINARY,     0x810C)
#define PR_EMS_AB_PREFERRED_DELIVERY_METHOD  PROP_TAG( PT_MV_LONG,       0x810D)
#define PR_EMS_AB_PRMD                       PROP_TAG( PT_TSTRING,       0x810E)
#define PR_EMS_AB_PRMD_A                     PROP_TAG( PT_STRING8,       0x810E)
#define PR_EMS_AB_PRMD_W                     PROP_TAG( PT_UNICODE,       0x810E)
#define PR_EMS_AB_PROXY_ADDRESSES            PROP_TAG( PT_MV_TSTRING,    0x800F)
#define PR_EMS_AB_PROXY_ADDRESSES_A          PROP_TAG( PT_MV_STRING8,    0x800F)
#define PR_EMS_AB_PROXY_ADDRESSES_W          PROP_TAG( PT_MV_UNICODE,    0x800F)
#define PR_EMS_AB_PROXY_GENERATOR_DLL        PROP_TAG( PT_TSTRING,       0x810F)
#define PR_EMS_AB_PROXY_GENERATOR_DLL_A      PROP_TAG( PT_STRING8,       0x810F)
#define PR_EMS_AB_PROXY_GENERATOR_DLL_W      PROP_TAG( PT_UNICODE,       0x810F)
#define PR_EMS_AB_PUBLIC_DELEGATES           PROP_TAG( PT_OBJECT,        0x8015)
#define PR_EMS_AB_PUBLIC_DELEGATES_A         PROP_TAG( PT_MV_STRING8,    0x8015)
#define PR_EMS_AB_PUBLIC_DELEGATES_W         PROP_TAG( PT_MV_UNICODE,    0x8015)
#define PR_EMS_AB_PUBLIC_DELEGATES_O         PROP_TAG( PT_OBJECT,        0x8015)
#define PR_EMS_AB_PUBLIC_DELEGATES_T         PROP_TAG( PT_MV_TSTRING,    0x8015)
#define PR_EMS_AB_PUBLIC_DELEGATES_BL        PROP_TAG( PT_MV_TSTRING,    0x8110)
#define PR_EMS_AB_PUBLIC_DELEGATES_BL_A      PROP_TAG( PT_MV_STRING8,    0x8110)
#define PR_EMS_AB_PUBLIC_DELEGATES_BL_W      PROP_TAG( PT_MV_UNICODE,    0x8110)
#define PR_EMS_AB_PUBLIC_DELEGATES_BL_O      PROP_TAG( PT_OBJECT,        0x8110)
#define PR_EMS_AB_PUBLIC_DELEGATES_BL_T      PROP_TAG( PT_MV_TSTRING,    0x8110)
#define PR_EMS_AB_QUOTA_NOTIFICATION_SCHEDULE PROP_TAG( PT_BINARY,        0x8111)
#define PR_EMS_AB_QUOTA_NOTIFICATION_STYLE   PROP_TAG( PT_LONG,          0x8112)
#define PR_EMS_AB_RANGE_LOWER                PROP_TAG( PT_LONG,          0x8113)
#define PR_EMS_AB_RANGE_UPPER                PROP_TAG( PT_LONG,          0x8114)
#define PR_EMS_AB_RAS_CALLBACK_NUMBER        PROP_TAG( PT_TSTRING,       0x8115)
#define PR_EMS_AB_RAS_CALLBACK_NUMBER_A      PROP_TAG( PT_STRING8,       0x8115)
#define PR_EMS_AB_RAS_CALLBACK_NUMBER_W      PROP_TAG( PT_UNICODE,       0x8115)
#define PR_EMS_AB_RAS_PHONE_NUMBER           PROP_TAG( PT_TSTRING,       0x8116)
#define PR_EMS_AB_RAS_PHONE_NUMBER_A         PROP_TAG( PT_STRING8,       0x8116)
#define PR_EMS_AB_RAS_PHONE_NUMBER_W         PROP_TAG( PT_UNICODE,       0x8116)
#define PR_EMS_AB_RAS_PHONEBOOK_ENTRY_NAME   PROP_TAG( PT_TSTRING,       0x8117)
#define PR_EMS_AB_RAS_PHONEBOOK_ENTRY_NAME_A PROP_TAG( PT_STRING8,       0x8117)
#define PR_EMS_AB_RAS_PHONEBOOK_ENTRY_NAME_W PROP_TAG( PT_UNICODE,       0x8117)
#define PR_EMS_AB_RAS_REMOTE_SRVR_NAME       PROP_TAG( PT_TSTRING,       0x8118)
#define PR_EMS_AB_RAS_REMOTE_SRVR_NAME_A     PROP_TAG( PT_STRING8,       0x8118)
#define PR_EMS_AB_RAS_REMOTE_SRVR_NAME_W     PROP_TAG( PT_UNICODE,       0x8118)
#define PR_EMS_AB_REGISTERED_ADDRESS         PROP_TAG( PT_MV_BINARY,     0x8119)
#define PR_EMS_AB_REMOTE_BRIDGE_HEAD         PROP_TAG( PT_TSTRING,       0x811A)
#define PR_EMS_AB_REMOTE_BRIDGE_HEAD_A       PROP_TAG( PT_STRING8,       0x811A)
#define PR_EMS_AB_REMOTE_BRIDGE_HEAD_W       PROP_TAG( PT_UNICODE,       0x811A)
#define PR_EMS_AB_REMOTE_BRIDGE_HEAD_ADDRESS PROP_TAG( PT_TSTRING,       0x811B)
#define PR_EMS_AB_REMOTE_BRIDGE_HEAD_ADDRESS_A PROP_TAG( PT_STRING8,       0x811B)
#define PR_EMS_AB_REMOTE_BRIDGE_HEAD_ADDRESS_W PROP_TAG( PT_UNICODE,       0x811B)
#define PR_EMS_AB_REMOTE_OUT_BH_SERVER       PROP_TAG( PT_TSTRING,       0x811C)
#define PR_EMS_AB_REMOTE_OUT_BH_SERVER_A     PROP_TAG( PT_STRING8,       0x811C)
#define PR_EMS_AB_REMOTE_OUT_BH_SERVER_W     PROP_TAG( PT_UNICODE,       0x811C)
#define PR_EMS_AB_REMOTE_OUT_BH_SERVER_O     PROP_TAG( PT_OBJECT,        0x811C)
#define PR_EMS_AB_REMOTE_OUT_BH_SERVER_T     PROP_TAG( PT_TSTRING,       0x811C)
#define PR_EMS_AB_REMOTE_SITE                PROP_TAG( PT_TSTRING,       0x811D)
#define PR_EMS_AB_REMOTE_SITE_A              PROP_TAG( PT_STRING8,       0x811D)
#define PR_EMS_AB_REMOTE_SITE_W              PROP_TAG( PT_UNICODE,       0x811D)
#define PR_EMS_AB_REMOTE_SITE_O              PROP_TAG( PT_OBJECT,        0x811D)
#define PR_EMS_AB_REMOTE_SITE_T              PROP_TAG( PT_TSTRING,       0x811D)
#define PR_EMS_AB_REPLICATION_MAIL_MSG_SIZE  PROP_TAG( PT_LONG,          0x8168)
#define PR_EMS_AB_REPLICATION_SENSITIVITY    PROP_TAG( PT_LONG,          0x811E)
#define PR_EMS_AB_REPLICATION_STAGGER        PROP_TAG( PT_LONG,          0x811F)
#define PR_EMS_AB_REPORT_TO_ORIGINATOR       PROP_TAG( PT_BOOLEAN,       0x8120)
#define PR_EMS_AB_REPORT_TO_OWNER            PROP_TAG( PT_BOOLEAN,       0x8121)
#define PR_EMS_AB_REPORTS                    PROP_TAG( PT_OBJECT,        0x800E)
#define PR_EMS_AB_REPORTS_A                  PROP_TAG( PT_MV_STRING8,    0x800E)
#define PR_EMS_AB_REPORTS_W                  PROP_TAG( PT_MV_UNICODE,    0x800E)
#define PR_EMS_AB_REPORTS_O                  PROP_TAG( PT_OBJECT,        0x800E)
#define PR_EMS_AB_REPORTS_T                  PROP_TAG( PT_MV_TSTRING,    0x800E)
#define PR_EMS_AB_REQ_SEQ                    PROP_TAG( PT_LONG,          0x8122)
#define PR_EMS_AB_RESPONSIBLE_LOCAL_DXA      PROP_TAG( PT_TSTRING,       0x8123)
#define PR_EMS_AB_RESPONSIBLE_LOCAL_DXA_A    PROP_TAG( PT_STRING8,       0x8123)
#define PR_EMS_AB_RESPONSIBLE_LOCAL_DXA_W    PROP_TAG( PT_UNICODE,       0x8123)
#define PR_EMS_AB_RESPONSIBLE_LOCAL_DXA_O    PROP_TAG( PT_OBJECT,        0x8123)
#define PR_EMS_AB_RESPONSIBLE_LOCAL_DXA_T    PROP_TAG( PT_TSTRING,       0x8123)
#define PR_EMS_AB_RID_SERVER                 PROP_TAG( PT_TSTRING,       0x8124)
#define PR_EMS_AB_RID_SERVER_A               PROP_TAG( PT_STRING8,       0x8124)
#define PR_EMS_AB_RID_SERVER_W               PROP_TAG( PT_UNICODE,       0x8124)
#define PR_EMS_AB_RID_SERVER_O               PROP_TAG( PT_OBJECT,        0x8124)
#define PR_EMS_AB_RID_SERVER_T               PROP_TAG( PT_TSTRING,       0x8124)
#define PR_EMS_AB_ROLE_OCCUPANT              PROP_TAG( PT_MV_TSTRING,    0x8125)
#define PR_EMS_AB_ROLE_OCCUPANT_A            PROP_TAG( PT_MV_STRING8,    0x8125)
#define PR_EMS_AB_ROLE_OCCUPANT_W            PROP_TAG( PT_MV_UNICODE,    0x8125)
#define PR_EMS_AB_ROLE_OCCUPANT_O            PROP_TAG( PT_OBJECT,        0x8125)
#define PR_EMS_AB_ROLE_OCCUPANT_T            PROP_TAG( PT_MV_TSTRING,    0x8125)
#define PR_EMS_AB_ROUTING_LIST               PROP_TAG( PT_MV_TSTRING,    0x8126)
#define PR_EMS_AB_ROUTING_LIST_A             PROP_TAG( PT_MV_STRING8,    0x8126)
#define PR_EMS_AB_ROUTING_LIST_W             PROP_TAG( PT_MV_UNICODE,    0x8126)
#define PR_EMS_AB_RTS_CHECKPOINT_SIZE        PROP_TAG( PT_LONG,          0x8127)
#define PR_EMS_AB_RTS_RECOVERY_TIMEOUT       PROP_TAG( PT_LONG,          0x8128)
#define PR_EMS_AB_RTS_WINDOW_SIZE            PROP_TAG( PT_LONG,          0x8129)
#define PR_EMS_AB_RUNS_ON                    PROP_TAG( PT_MV_TSTRING,    0x812A)
#define PR_EMS_AB_RUNS_ON_A                  PROP_TAG( PT_MV_STRING8,    0x812A)
#define PR_EMS_AB_RUNS_ON_W                  PROP_TAG( PT_MV_UNICODE,    0x812A)
#define PR_EMS_AB_RUNS_ON_O                  PROP_TAG( PT_OBJECT,        0x812A)
#define PR_EMS_AB_RUNS_ON_T                  PROP_TAG( PT_MV_TSTRING,    0x812A)
#define PR_EMS_AB_S_SELECTOR                 PROP_TAG( PT_BINARY,        0x812B)
#define PR_EMS_AB_S_SELECTOR_INBOUND         PROP_TAG( PT_BINARY,        0x812C)
#define PR_EMS_AB_SCHEMA_FLAGS               PROP_TAG( PT_LONG,          0x8173)
#define PR_EMS_AB_SCHEMA_VERSION             PROP_TAG( PT_MV_LONG,       0x817C)
#define PR_EMS_AB_SEARCH_FLAGS               PROP_TAG( PT_LONG,          0x812D)
#define PR_EMS_AB_SEARCH_GUIDE               PROP_TAG( PT_MV_BINARY,     0x812E)
#define PR_EMS_AB_SECURITY_PROTOCOL          PROP_TAG( PT_MV_BINARY,     0x8037)
#define PR_EMS_AB_SEE_ALSO                   PROP_TAG( PT_MV_TSTRING,    0x812F)
#define PR_EMS_AB_SEE_ALSO_A                 PROP_TAG( PT_MV_STRING8,    0x812F)
#define PR_EMS_AB_SEE_ALSO_W                 PROP_TAG( PT_MV_UNICODE,    0x812F)
#define PR_EMS_AB_SEE_ALSO_O                 PROP_TAG( PT_OBJECT,        0x812F)
#define PR_EMS_AB_SEE_ALSO_T                 PROP_TAG( PT_MV_TSTRING,    0x812F)
#define PR_EMS_AB_SERIAL_NUMBER              PROP_TAG( PT_MV_TSTRING,    0x8130)
#define PR_EMS_AB_SERIAL_NUMBER_A            PROP_TAG( PT_MV_STRING8,    0x8130)
#define PR_EMS_AB_SERIAL_NUMBER_W            PROP_TAG( PT_MV_UNICODE,    0x8130)
#define PR_EMS_AB_SERVICE_ACTION_FIRST       PROP_TAG( PT_LONG,          0x8131)
#define PR_EMS_AB_SERVICE_ACTION_OTHER       PROP_TAG( PT_LONG,          0x8132)
#define PR_EMS_AB_SERVICE_ACTION_SECOND      PROP_TAG( PT_LONG,          0x8133)
#define PR_EMS_AB_SERVICE_RESTART_DELAY      PROP_TAG( PT_LONG,          0x8134)
#define PR_EMS_AB_SERVICE_RESTART_MESSAGE    PROP_TAG( PT_TSTRING,       0x8135)
#define PR_EMS_AB_SERVICE_RESTART_MESSAGE_A  PROP_TAG( PT_STRING8,       0x8135)
#define PR_EMS_AB_SERVICE_RESTART_MESSAGE_W  PROP_TAG( PT_UNICODE,       0x8135)
#define PR_EMS_AB_SESSION_DISCONNECT_TIMER   PROP_TAG( PT_LONG,          0x8136)
#define PR_EMS_AB_SITE_AFFINITY              PROP_TAG( PT_MV_TSTRING,    0x8137)
#define PR_EMS_AB_SITE_AFFINITY_A            PROP_TAG( PT_MV_STRING8,    0x8137)
#define PR_EMS_AB_SITE_AFFINITY_W            PROP_TAG( PT_MV_UNICODE,    0x8137)
#define PR_EMS_AB_SITE_FOLDER_GUID           PROP_TAG( PT_BINARY,        0x8166)
#define PR_EMS_AB_SITE_FOLDER_SERVER         PROP_TAG( PT_TSTRING,       0x8167)
#define PR_EMS_AB_SITE_FOLDER_SERVER_A       PROP_TAG( PT_STRING8,       0x8167)
#define PR_EMS_AB_SITE_FOLDER_SERVER_W       PROP_TAG( PT_UNICODE,       0x8167)
#define PR_EMS_AB_SITE_FOLDER_SERVER_O       PROP_TAG( PT_OBJECT,        0x8167)
#define PR_EMS_AB_SITE_FOLDER_SERVER_T       PROP_TAG( PT_TSTRING,       0x8167)
#define PR_EMS_AB_SITE_PROXY_SPACE           PROP_TAG( PT_MV_TSTRING,    0x8138)
#define PR_EMS_AB_SITE_PROXY_SPACE_A         PROP_TAG( PT_MV_STRING8,    0x8138)
#define PR_EMS_AB_SITE_PROXY_SPACE_W         PROP_TAG( PT_MV_UNICODE,    0x8138)
#define PR_EMS_AB_SPACE_LAST_COMPUTED        PROP_TAG( PT_SYSTIME,       0x8139)
#define PR_EMS_AB_STREET_ADDRESS             PROP_TAG( PT_TSTRING,       0x813A)
#define PR_EMS_AB_STREET_ADDRESS_A           PROP_TAG( PT_STRING8,       0x813A)
#define PR_EMS_AB_STREET_ADDRESS_W           PROP_TAG( PT_UNICODE,       0x813A)
#define PR_EMS_AB_SUB_REFS                   PROP_TAG( PT_MV_TSTRING,    0x813B)
#define PR_EMS_AB_SUB_REFS_A                 PROP_TAG( PT_MV_STRING8,    0x813B)
#define PR_EMS_AB_SUB_REFS_W                 PROP_TAG( PT_MV_UNICODE,    0x813B)
#define PR_EMS_AB_SUB_REFS_O                 PROP_TAG( PT_OBJECT,        0x813B)
#define PR_EMS_AB_SUB_REFS_T                 PROP_TAG( PT_MV_TSTRING,    0x813B)
#define PR_EMS_AB_SUB_SITE                   PROP_TAG( PT_TSTRING,       0x817B)
#define PR_EMS_AB_SUB_SITE_A                 PROP_TAG( PT_STRING8,       0x817B)
#define PR_EMS_AB_SUB_SITE_W                 PROP_TAG( PT_UNICODE,       0x817B)
#define PR_EMS_AB_SUBMISSION_CONT_LENGTH     PROP_TAG( PT_LONG,          0x813C)
#define PR_EMS_AB_SUPPORTED_APPLICATION_CONTEXT PROP_TAG( PT_MV_BINARY,     0x813D)
#define PR_EMS_AB_SUPPORTING_STACK           PROP_TAG( PT_MV_TSTRING,    0x813E)
#define PR_EMS_AB_SUPPORTING_STACK_A         PROP_TAG( PT_MV_STRING8,    0x813E)
#define PR_EMS_AB_SUPPORTING_STACK_W         PROP_TAG( PT_MV_UNICODE,    0x813E)
#define PR_EMS_AB_SUPPORTING_STACK_O         PROP_TAG( PT_OBJECT,        0x813E)
#define PR_EMS_AB_SUPPORTING_STACK_T         PROP_TAG( PT_MV_TSTRING,    0x813E)
#define PR_EMS_AB_SUPPORTING_STACK_BL        PROP_TAG( PT_MV_TSTRING,    0x813F)
#define PR_EMS_AB_SUPPORTING_STACK_BL_A      PROP_TAG( PT_MV_STRING8,    0x813F)
#define PR_EMS_AB_SUPPORTING_STACK_BL_W      PROP_TAG( PT_MV_UNICODE,    0x813F)
#define PR_EMS_AB_SUPPORTING_STACK_BL_O      PROP_TAG( PT_OBJECT,        0x813F)
#define PR_EMS_AB_SUPPORTING_STACK_BL_T      PROP_TAG( PT_MV_TSTRING,    0x813F)
#define PR_EMS_AB_T_SELECTOR                 PROP_TAG( PT_BINARY,        0x8140)
#define PR_EMS_AB_T_SELECTOR_INBOUND         PROP_TAG( PT_BINARY,        0x8141)
#define PR_EMS_AB_TARGET_ADDRESS             PROP_TAG( PT_TSTRING,       0x8011)
#define PR_EMS_AB_TARGET_ADDRESS_A           PROP_TAG( PT_STRING8,       0x8011)
#define PR_EMS_AB_TARGET_ADDRESS_W           PROP_TAG( PT_UNICODE,       0x8011)
#define PR_EMS_AB_TARGET_MTAS                PROP_TAG( PT_MV_TSTRING,    0x8142)
#define PR_EMS_AB_TARGET_MTAS_A              PROP_TAG( PT_MV_STRING8,    0x8142)
#define PR_EMS_AB_TARGET_MTAS_W              PROP_TAG( PT_MV_UNICODE,    0x8142)
#define PR_EMS_AB_TELEPHONE_NUMBER           PROP_TAG( PT_MV_TSTRING,    0x8012)
#define PR_EMS_AB_TELEPHONE_NUMBER_A         PROP_TAG( PT_MV_STRING8,    0x8012)
#define PR_EMS_AB_TELEPHONE_NUMBER_W         PROP_TAG( PT_MV_UNICODE,    0x8012)
#define PR_EMS_AB_TELETEX_TERMINAL_IDENTIFIER PROP_TAG( PT_MV_BINARY,     0x8143)
#define PR_EMS_AB_TEMP_ASSOC_THRESHOLD       PROP_TAG( PT_LONG,          0x8144)
#define PR_EMS_AB_TOMBSTONE_LIFETIME         PROP_TAG( PT_LONG,          0x8145)
#define PR_EMS_AB_TRACKING_LOG_PATH_NAME     PROP_TAG( PT_TSTRING,       0x8146)
#define PR_EMS_AB_TRACKING_LOG_PATH_NAME_A   PROP_TAG( PT_STRING8,       0x8146)
#define PR_EMS_AB_TRACKING_LOG_PATH_NAME_W   PROP_TAG( PT_UNICODE,       0x8146)
#define PR_EMS_AB_TRANS_RETRY_MINS           PROP_TAG( PT_LONG,          0x8147)
#define PR_EMS_AB_TRANS_TIMEOUT_MINS         PROP_TAG( PT_LONG,          0x8148)
#define PR_EMS_AB_TRANSFER_RETRY_INTERVAL    PROP_TAG( PT_LONG,          0x8149)
#define PR_EMS_AB_TRANSFER_TIMEOUT_NON_URGENT PROP_TAG( PT_LONG,          0x814A)
#define PR_EMS_AB_TRANSFER_TIMEOUT_NORMAL    PROP_TAG( PT_LONG,          0x814B)
#define PR_EMS_AB_TRANSFER_TIMEOUT_URGENT    PROP_TAG( PT_LONG,          0x814C)
#define PR_EMS_AB_TRANSLATION_TABLE_USED     PROP_TAG( PT_LONG,          0x814D)
#define PR_EMS_AB_TRANSPORT_EXPEDITED_DATA   PROP_TAG( PT_BOOLEAN,       0x814E)
#define PR_EMS_AB_TRUST_LEVEL                PROP_TAG( PT_LONG,          0x814F)
#define PR_EMS_AB_TURN_REQUEST_THRESHOLD     PROP_TAG( PT_LONG,          0x8150)
#define PR_EMS_AB_TWO_WAY_ALTERNATE_FACILITY PROP_TAG( PT_BOOLEAN,       0x8151)
#define PR_EMS_AB_UNAUTH_ORIG_BL             PROP_TAG( PT_MV_TSTRING,    0x8152)
#define PR_EMS_AB_UNAUTH_ORIG_BL_A           PROP_TAG( PT_MV_STRING8,    0x8152)
#define PR_EMS_AB_UNAUTH_ORIG_BL_W           PROP_TAG( PT_MV_UNICODE,    0x8152)
#define PR_EMS_AB_UNAUTH_ORIG_BL_O           PROP_TAG( PT_OBJECT,        0x8152)
#define PR_EMS_AB_UNAUTH_ORIG_BL_T           PROP_TAG( PT_MV_TSTRING,    0x8152)
#define PR_EMS_AB_USE_SERVER_VALUES          PROP_TAG( PT_BOOLEAN,       0x817E)
#define PR_EMS_AB_USER_PASSWORD              PROP_TAG( PT_MV_BINARY,     0x8153)
#define PR_EMS_AB_USN_CHANGED                PROP_TAG( PT_LONG,          0x8029)
#define PR_EMS_AB_USN_CREATED                PROP_TAG( PT_LONG,          0x8154)
#define PR_EMS_AB_USN_DSA_LAST_OBJ_REMOVED   PROP_TAG( PT_LONG,          0x8155)
#define PR_EMS_AB_USN_INTERSITE              PROP_TAG( PT_LONG,          0x817A)
#define PR_EMS_AB_USN_LAST_OBJ_REM           PROP_TAG( PT_LONG,          0x8156)
#define PR_EMS_AB_USN_SOURCE                 PROP_TAG( PT_LONG,          0x8157)
#define PR_EMS_AB_WWW_HOME_PAGE              PROP_TAG( PT_TSTRING,       0x8175)
#define PR_EMS_AB_WWW_HOME_PAGE_A            PROP_TAG( PT_STRING8,       0x8175)
#define PR_EMS_AB_WWW_HOME_PAGE_W            PROP_TAG( PT_UNICODE,       0x8175)
#define PR_EMS_AB_X121_ADDRESS               PROP_TAG( PT_MV_TSTRING,    0x8158)
#define PR_EMS_AB_X121_ADDRESS_A             PROP_TAG( PT_MV_STRING8,    0x8158)
#define PR_EMS_AB_X121_ADDRESS_W             PROP_TAG( PT_MV_UNICODE,    0x8158)
#define PR_EMS_AB_X25_CALL_USER_DATA_INCOMING PROP_TAG( PT_BINARY,        0x8159)
#define PR_EMS_AB_X25_CALL_USER_DATA_OUTGOING PROP_TAG( PT_BINARY,        0x815A)
#define PR_EMS_AB_X25_FACILITIES_DATA_INCOMING PROP_TAG( PT_BINARY,        0x815B)
#define PR_EMS_AB_X25_FACILITIES_DATA_OUTGOING PROP_TAG( PT_BINARY,        0x815C)
#define PR_EMS_AB_X25_LEASED_LINE_PORT       PROP_TAG( PT_BINARY,        0x815D)
#define PR_EMS_AB_X25_LEASED_OR_SWITCHED     PROP_TAG( PT_BOOLEAN,       0x815E)
#define PR_EMS_AB_X25_REMOTE_MTA_PHONE       PROP_TAG( PT_TSTRING,       0x815F)
#define PR_EMS_AB_X25_REMOTE_MTA_PHONE_A     PROP_TAG( PT_STRING8,       0x815F)
#define PR_EMS_AB_X25_REMOTE_MTA_PHONE_W     PROP_TAG( PT_UNICODE,       0x815F)
#define PR_EMS_AB_X400_ATTACHMENT_TYPE       PROP_TAG( PT_BINARY,        0x8160)
#define PR_EMS_AB_X400_SELECTOR_SYNTAX       PROP_TAG( PT_LONG,          0x8161)
#define PR_EMS_AB_X500_ACCESS_CONTROL_LIST   PROP_TAG( PT_BINARY,        0x8162)
#define PR_EMS_AB_XMIT_TIMEOUT_NON_URGENT    PROP_TAG( PT_LONG,          0x8163)
#define PR_EMS_AB_XMIT_TIMEOUT_NORMAL        PROP_TAG( PT_LONG,          0x8164)
#define PR_EMS_AB_XMIT_TIMEOUT_URGENT        PROP_TAG( PT_LONG,          0x8165)

#endif /* _EMSABTAG_H */

=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\emmintrin.h ===
/**
*** INTEL CONFIDENTIAL
***
*** Copyright (C) 1985-1999 Intel Corporation.  All rights reserved.
***
*** The information and source code contained herein is the exclusive
*** property of Intel Corporation and may not be disclosed, examined
*** or reproduced in whole or in part without explicit written authorization
*** from the company.
***
*** static char sccs_id[] = "@(#)emmintrin.h    1.6 04/14/99 11:10:32";
**/

/*
 * emmintrin.h
 *
 * Principal header file for Willamette New Instruction intrinsics
 *
 * The intrinsics package can be used in 2 ways, based whether or not
 * _EMM_FUNCTIONALITY is defined; if it is, the C implementation
 * will be used (the "functional intrinsics").
 */

#ifndef _INCLUDED_EMM
#define _INCLUDED_EMM

/*
 * the __m128 & __m64 types are required for the intrinsics
 */
#include <xmmintrin.h>

#ifdef __ICL
#ifdef _EMM_FUNCTIONALITY
#include "emm_func.h"
#else
typedef long long __m128d;
typedef long long __m128i;
#endif
#elif _MSC_VER >= 1300
typedef union __declspec(intrin_type) __declspec(align(16)) __m128i {
    __int8              m128i_i8[16];
    __int16             m128i_i16[8];
    __int32             m128i_i32[4];    
    __int64             m128i_i64[2];
    unsigned __int8     m128i_u8[16];
    unsigned __int16    m128i_u16[8];
    unsigned __int32    m128i_u32[4];
    unsigned __int64    m128i_u64[2];
} __m128i;

typedef struct __declspec(intrin_type) __declspec(align(16)) __m128d {
    double              m128d_f64[2];
} __m128d;
#endif

/*
 * Macro function for shuffle
 */
#define _MM_SHUFFLE2(x,y) (((x)<<1) | (y))

/*****************************************************/
/*     INTRINSICS FUNCTION PROTOTYPES START HERE     */
/*****************************************************/

#if defined __cplusplus
extern "C" { /* Begin "C" */
  /* Intrinsics use C name-mangling. */
#endif /* __cplusplus */

/*
 * DP, arithmetic
 */

extern __m128d _mm_add_sd(__m128d a, __m128d b);
extern __m128d _mm_add_pd(__m128d a, __m128d b);
extern __m128d _mm_sub_sd(__m128d a, __m128d b);
extern __m128d _mm_sub_pd(__m128d a, __m128d b);
extern __m128d _mm_mul_sd(__m128d a, __m128d b);
extern __m128d _mm_mul_pd(__m128d a, __m128d b);
extern __m128d _mm_sqrt_sd(__m128d a, __m128d b);
extern __m128d _mm_sqrt_pd(__m128d a);
extern __m128d _mm_div_sd(__m128d a, __m128d b);
extern __m128d _mm_div_pd(__m128d a, __m128d b);
extern __m128d _mm_min_sd(__m128d a, __m128d b);
extern __m128d _mm_min_pd(__m128d a, __m128d b);
extern __m128d _mm_max_sd(__m128d a, __m128d b);
extern __m128d _mm_max_pd(__m128d a, __m128d b);

/*
 * DP, logicals
 */

extern __m128d _mm_and_pd(__m128d a, __m128d b);
extern __m128d _mm_andnot_pd(__m128d a, __m128d b);
extern __m128d _mm_or_pd(__m128d a, __m128d b);
extern __m128d _mm_xor_pd(__m128d a, __m128d b);

/*
 * DP, comparisons
 */

extern __m128d _mm_cmpeq_sd(__m128d a, __m128d b);
extern __m128d _mm_cmpeq_pd(__m128d a, __m128d b);
extern __m128d _mm_cmplt_sd(__m128d a, __m128d b);
extern __m128d _mm_cmplt_pd(__m128d a, __m128d b);
extern __m128d _mm_cmple_sd(__m128d a, __m128d b);
extern __m128d _mm_cmple_pd(__m128d a, __m128d b);
extern __m128d _mm_cmpgt_sd(__m128d a, __m128d b);
extern __m128d _mm_cmpgt_pd(__m128d a, __m128d b);
extern __m128d _mm_cmpge_sd(__m128d a, __m128d b);
extern __m128d _mm_cmpge_pd(__m128d a, __m128d b);
extern __m128d _mm_cmpneq_sd(__m128d a, __m128d b);
extern __m128d _mm_cmpneq_pd(__m128d a, __m128d b);
extern __m128d _mm_cmpnlt_sd(__m128d a, __m128d b);
extern __m128d _mm_cmpnlt_pd(__m128d a, __m128d b);
extern __m128d _mm_cmpnle_sd(__m128d a, __m128d b);
extern __m128d _mm_cmpnle_pd(__m128d a, __m128d b);
extern __m128d _mm_cmpngt_sd(__m128d a, __m128d b);
extern __m128d _mm_cmpngt_pd(__m128d a, __m128d b);
extern __m128d _mm_cmpnge_sd(__m128d a, __m128d b);
extern __m128d _mm_cmpnge_pd(__m128d a, __m128d b);
extern __m128d _mm_cmpord_pd(__m128d a, __m128d b);
extern __m128d _mm_cmpord_sd(__m128d a, __m128d b);
extern __m128d _mm_cmpunord_pd(__m128d a, __m128d b);
extern __m128d _mm_cmpunord_sd(__m128d a, __m128d b);
extern int _mm_comieq_sd(__m128d a, __m128d b);
extern int _mm_comilt_sd(__m128d a, __m128d b);
extern int _mm_comile_sd(__m128d a, __m128d b);
extern int _mm_comigt_sd(__m128d a, __m128d b);
extern int _mm_comige_sd(__m128d a, __m128d b);
extern int _mm_comineq_sd(__m128d a, __m128d b);
extern int _mm_ucomieq_sd(__m128d a, __m128d b);
extern int _mm_ucomilt_sd(__m128d a, __m128d b);
extern int _mm_ucomile_sd(__m128d a, __m128d b);
extern int _mm_ucomigt_sd(__m128d a, __m128d b);
extern int _mm_ucomige_sd(__m128d a, __m128d b);
extern int _mm_ucomineq_sd(__m128d a, __m128d b);

/*
 * DP, converts
 */

extern __m128d _mm_cvtepi32_pd(__m128i a);
extern __m128i _mm_cvtpd_epi32(__m128d a);
extern __m128i _mm_cvttpd_epi32(__m128d a);
extern __m128 _mm_cvtepi32_ps(__m128i a);
extern __m128i _mm_cvtps_epi32(__m128 a);
extern __m128i _mm_cvttps_epi32(__m128 a);
extern __m128 _mm_cvtpd_ps(__m128d a);
extern __m128d _mm_cvtps_pd(__m128 a);
extern __m128 _mm_cvtsd_ss(__m128 a, __m128d b);
extern __m128d _mm_cvtss_sd(__m128d a, __m128 b);

extern int _mm_cvtsd_si32(__m128d a);
extern int _mm_cvttsd_si32(__m128d a);
extern __m128d _mm_cvtsi32_sd(__m128d a, int b);

extern __m64 _mm_cvtpd_pi32(__m128d a);
extern __m64 _mm_cvttpd_pi32(__m128d a);
extern __m128d _mm_cvtpi32_pd(__m64 a);

/*
 * DP, misc
 */

extern __m128d _mm_unpackhi_pd(__m128d a, __m128d b);
extern __m128d _mm_unpacklo_pd(__m128d a, __m128d b);
extern int _mm_movemask_pd(__m128d a);
extern __m128d _mm_shuffle_pd(__m128d a, __m128d b, int i);

/*
 * DP, loads
 */

extern __m128d _mm_load_pd(double const*dp);
extern __m128d _mm_load1_pd(double const*dp);
extern __m128d _mm_loadr_pd(double const*dp);
extern __m128d _mm_loadu_pd(double const*dp);
extern __m128d _mm_load_sd(double const*dp);
extern __m128d _mm_loadh_pd(__m128d a, double const*dp);
extern __m128d _mm_loadl_pd(__m128d a, double const*dp);

/*
 * DP, sets
 */

extern __m128d _mm_set_sd(double w);
extern __m128d _mm_set1_pd(double a);
extern __m128d _mm_set_pd(double z, double y);
extern __m128d _mm_setr_pd(double y, double z);
extern __m128d _mm_setzero_pd(void);
extern __m128d _mm_move_sd(__m128d a, __m128d b);;

/* 
 * DP, stores
 */

extern void _mm_store_sd(double *dp, __m128d a);
extern void _mm_store1_pd(double *dp, __m128d a);
extern void _mm_store_pd(double *dp, __m128d a);
extern void _mm_storeu_pd(double *dp, __m128d a);
extern void _mm_storer_pd(double *dp, __m128d a);
extern void _mm_storeh_pd(double *dp, __m128d a);
extern void _mm_storel_pd(double *dp, __m128d a);

/*
 * Integer, arithmetic
 */

extern __m128i _mm_add_epi8(__m128i a, __m128i b);
extern __m128i _mm_add_epi16(__m128i a, __m128i b);
extern __m128i _mm_add_epi32(__m128i a, __m128i b);
extern __m64 _mm_add_si64(__m64 a, __m64 b);
extern __m128i _mm_add_epi64(__m128i a, __m128i b);
extern __m128i _mm_adds_epi8(__m128i a, __m128i b);
extern __m128i _mm_adds_epi16(__m128i a, __m128i b);
extern __m128i _mm_adds_epu8(__m128i a, __m128i b);
extern __m128i _mm_adds_epu16(__m128i a, __m128i b);
extern __m128i _mm_avg_epu8(__m128i a, __m128i b);
extern __m128i _mm_avg_epu16(__m128i a, __m128i b);
extern __m128i _mm_madd_epi16(__m128i a, __m128i b);
extern __m128i _mm_max_epi16(__m128i a, __m128i b);
extern __m128i _mm_max_epu8(__m128i a, __m128i b);
extern __m128i _mm_min_epi16(__m128i a, __m128i b);
extern __m128i _mm_min_epu8(__m128i a, __m128i b);
extern __m128i _mm_mulhi_epi16(__m128i a, __m128i b);
extern __m128i _mm_mulhi_epu16(__m128i a, __m128i b);
extern __m128i _mm_mullo_epi16(__m128i a, __m128i b);
extern __m64 _mm_mul_su32(__m64 a, __m64 b);
extern __m128i _mm_mul_epu32(__m128i a, __m128i b);
extern __m128i _mm_sad_epu8(__m128i a, __m128i b);
extern __m128i _mm_sub_epi8(__m128i a, __m128i b);
extern __m128i _mm_sub_epi16(__m128i a, __m128i b);
extern __m128i _mm_sub_epi32(__m128i a, __m128i b);
extern __m64 _mm_sub_si64(__m64 a, __m64 b);
extern __m128i _mm_sub_epi64(__m128i a, __m128i b);
extern __m128i _mm_subs_epi8(__m128i a, __m128i b);
extern __m128i _mm_subs_epi16(__m128i a, __m128i b);
extern __m128i _mm_subs_epu8(__m128i a, __m128i b);
extern __m128i _mm_subs_epu16(__m128i a, __m128i b);

/*
 * Integer, logicals
 */

extern __m128i _mm_and_si128(__m128i a, __m128i b);
extern __m128i _mm_andnot_si128(__m128i a, __m128i b);
extern __m128i _mm_or_si128(__m128i a, __m128i b);
extern __m128i _mm_xor_si128(__m128i a, __m128i b);

/*
 * Integer, shifts
 */

extern __m128i _mm_slli_si128(__m128i a, int imm);
extern __m128i _mm_slli_epi16(__m128i a, int count);
extern __m128i _mm_sll_epi16(__m128i a, __m128i count);
extern __m128i _mm_slli_epi32(__m128i a, int count);
extern __m128i _mm_sll_epi32(__m128i a, __m128i count);
extern __m128i _mm_slli_epi64(__m128i a, int count);
extern __m128i _mm_sll_epi64(__m128i a, __m128i count);
extern __m128i _mm_srai_epi16(__m128i a, int count);
extern __m128i _mm_sra_epi16(__m128i a, __m128i count);
extern __m128i _mm_srai_epi32(__m128i a, int count);
extern __m128i _mm_sra_epi32(__m128i a, __m128i count);
extern __m128i _mm_srli_si128(__m128i a, int imm);
extern __m128i _mm_srli_epi16(__m128i a, int count);
extern __m128i _mm_srl_epi16(__m128i a, __m128i count);
extern __m128i _mm_srli_epi32(__m128i a, int count);
extern __m128i _mm_srl_epi32(__m128i a, __m128i count);
extern __m128i _mm_srli_epi64(__m128i a, int count);
extern __m128i _mm_srl_epi64(__m128i a, __m128i count);

/*
 * Integer, comparisons
 */

extern __m128i _mm_cmpeq_epi8(__m128i a, __m128i b);
extern __m128i _mm_cmpeq_epi16(__m128i a, __m128i b);
extern __m128i _mm_cmpeq_epi32(__m128i a, __m128i b);
extern __m128i _mm_cmpgt_epi8(__m128i a, __m128i b);
extern __m128i _mm_cmpgt_epi16(__m128i a, __m128i b);
extern __m128i _mm_cmpgt_epi32(__m128i a, __m128i b);
extern __m128i _mm_cmplt_epi8(__m128i a, __m128i b);
extern __m128i _mm_cmplt_epi16(__m128i a, __m128i b);
extern __m128i _mm_cmplt_epi32(__m128i a, __m128i b);

/*
 * Integer, converts
 */

extern __m128i _mm_cvtsi32_si128(int a);
extern int _mm_cvtsi128_si32(__m128i a);

/*
 * Integer, misc
 */

extern __m128i _mm_packs_epi16(__m128i a, __m128i b);
extern __m128i _mm_packs_epi32(__m128i a, __m128i b);
extern __m128i _mm_packus_epi16(__m128i a, __m128i b);
extern int _mm_extract_epi16(__m128i a, int imm);
extern __m128i _mm_insert_epi16(__m128i a, int b, int imm);
extern int _mm_movemask_epi8(__m128i a);
extern __m128i _mm_shuffle_epi32(__m128i a, int imm);
extern __m128i _mm_shufflehi_epi16(__m128i a, int imm);
extern __m128i _mm_shufflelo_epi16(__m128i a, int imm);
extern __m128i _mm_unpackhi_epi8(__m128i a, __m128i b);
extern __m128i _mm_unpackhi_epi16(__m128i a, __m128i b);
extern __m128i _mm_unpackhi_epi32(__m128i a, __m128i b);
extern __m128i _mm_unpackhi_epi64(__m128i a, __m128i b);
extern __m128i _mm_unpacklo_epi8(__m128i a, __m128i b);
extern __m128i _mm_unpacklo_epi16(__m128i a, __m128i b);
extern __m128i _mm_unpacklo_epi32(__m128i a, __m128i b);
extern __m128i _mm_unpacklo_epi64(__m128i a, __m128i b);

/*
 * Integer, loads
 */

extern __m128i _mm_load_si128(__m128i const*p);
extern __m128i _mm_loadu_si128(__m128i const*p);
extern __m128i _mm_loadl_epi64(__m128i const*p);

/*
 * Integer, sets
 */

extern __m128i _mm_set_epi64(__m64 q1, __m64 q0);
extern __m128i _mm_set_epi32(int i3, int i2, int i1, int i0);
extern __m128i _mm_set_epi16(short w7, short w6, short w5, short w4,
                             short w3, short w2, short w1, short w0);
extern __m128i _mm_set_epi8(char b15, char b14, char b13, char b12, 
                            char b11, char b10, char b9, char b8, 
                            char b7, char b6, char b5, char b4, 
                            char b3, char b2, char b1, char b0);
extern __m128i _mm_set1_epi64(__m64 q);
extern __m128i _mm_set1_epi32(int i);
extern __m128i _mm_set1_epi16(short w);
extern __m128i _mm_set1_epi8(char b);
extern __m128i _mm_setl_epi64(__m128i q);
extern __m128i _mm_setr_epi64(__m64 q0, __m64 q1);
extern __m128i _mm_setr_epi32(int i0, int i1, int i2, int i3);
extern __m128i _mm_setr_epi16(short w0, short w1, short w2, short w3, 
                              short w4, short w5, short w6, short w7);
extern __m128i _mm_setr_epi8(char b15, char b14, char b13, char b12, 
                             char b11, char b10, char b9, char b8, 
                             char b7, char b6, char b5, char b4, 
                             char b3, char b2, char b1, char b0);
extern __m128i _mm_setzero_si128();

/*
 * Integer, stores
 */

extern void _mm_store_si128(__m128i *p, __m128i b);
extern void _mm_storeu_si128(__m128i *p, __m128i b);
extern void _mm_storel_epi64(__m128i *p, __m128i q);
extern void _mm_maskmoveu_si128(__m128i d, __m128i n, char *p);

/*
 * Integer, moves
 */

extern __m128i _mm_move_epi64(__m128i q);
extern __m128i _mm_movpi64_epi64(__m64 q);
extern __m64 _mm_movepi64_pi64(__m128i q);

/*
 * Cacheability support
 */

extern void _mm_stream_pd(double *dp, __m128d a);;
extern void _mm_stream_si128(__m128i *p, __m128i a);
extern void _mm_clflush(void const*p);
extern void _mm_lfence(void);
extern void _mm_mfence(void);
extern void _mm_stream_si32(int *p, int i);
extern void _mm_pause(void);

#if defined __cplusplus
}; /* End "C" */
#endif /* __cplusplus */

#endif /* _INCLUDED_EMM */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\epgldrx.h ===
// tssldrx.h : external interface definition for
// epg loader .dlls main entry point
//
// Copyright(c) 1996 Microsoft Corp.

#ifndef _EPGLDRX_H_
#define _EPGLDRX_H_

extern "C"
{

// this list defines the exit codes used by the standard loader stub and
// the sample loader.
// any codes <= EXIT_LDR_DEF_SUCCESS or >= EXIT_LDR_DEF_ERROR
// will be passed straight through in order to implement extensible loader
// defined errors.  it is up to an individual loader to add the appropriate
// section to sage registry entries for these additional codes.
// each loader should check to make sure that extended error codes are not
// colliding with codes already present.
enum ExitCodeList
{
 	// common loader codes
	EXIT_OK = 0,             // success
	EXIT_FIRST_CODE = EXIT_OK,
	EXIT_INCOMPLETE = 1,     // success, but not all guide info added
 	EXIT_LAST_LOADER_SUCCESS = 1,
	EXIT_ABORT = 2,
	// 3 is the value returned by VC's ASSERT mechanism
	EXIT_FAIL = 4,           // unknown failure
 	
	// loadstub codes
    EXIT_MISSINGDLL = 5,
    EXIT_DB = 6,				// can't open database
    EXIT_USAGE = 7,				// missing command line argument
    EXIT_BUSY = 0xF9,			// magic sage retry code

	// more common loader codes
	EXIT_COMPACT = 300,
	EXIT_REPAIR = 301,
	EXIT_FAIL_CEXCEPTION = 302,
	EXIT_FAIL_DBEXCEPTION = 303,
	EXIT_FAIL_GETTIMEZONE = 304,
	EXIT_FAIL_GETTUNINGSPACE = 305,
	EXIT_FAIL_BADTUNINGSPACE = 306,
	EXIT_FAIL_BADSTARTTIME = 307,
	EXIT_FAIL_BADENDTIME = 308,
	EXIT_FAIL_GETLOADERREADFILE = 309,
	EXIT_FAIL_LOADERREADFILE = 310,

	// StarSight specific
	EXIT_FAIL_GETREGIONID = 400,
    EXIT_FIRST_LOADER_DEF = EXIT_FAIL_GETREGIONID,

	// DTV specific
	EXIT_FAIL_NULLPGDR = 500,
	EXIT_FAIL_NULLPGM = 501,
	EXIT_FAIL_PGMHEADER = 502,
	EXIT_FAIL_PGMSIZE = 503,
	EXIT_FAIL_PIVHEADER = 504,
	EXIT_FAIL_PIVSPGNUM = 505,
	EXIT_FAIL_VIEWLISTSPRINTF = 506,
	EXIT_FAIL_VIEWLISTMASK = 507,
	EXIT_FAIL_NULLAPGD = 508,
	EXIT_FAIL_APGDSYNC = 509,
	EXIT_FAIL_APGDHEADER = 510,
	EXIT_FAIL_APGDCHECKSUM = 511,
	EXIT_FAIL_SPIGTV = 512,
	EXIT_FAIL_SPILTV = 513,
	EXIT_FAIL_SPIGTV_CD = 514,
	EXIT_FAIL_SPILTV_CD = 515,
	EXIT_FAIL_SPIGTV_SD = 516,
	EXIT_FAIL_SPILTV_SD = 517,
	EXIT_FAIL_SPIGTV_DAVIS = 518,
	EXIT_FAIL_SPIGTV_R9_DAVIS = 519,
	EXIT_FAIL_SPIGTV_R9 = 520,
	EXIT_FAIL_SPILTV_R9 = 521,
	EXIT_FAIL_SPILTV_DAVIS = 522,
	EXIT_FAIL_SPIGA = 523,
	EXIT_FAIL_SPICD = 524,
	EXIT_FAIL_SPISD = 525,
	EXIT_FAIL_SPIHSD = 526,
	EXIT_FAIL_EXPLICITSCID = 527,
	EXIT_FAIL_SPI = 528,
	EXIT_FAIL_EXPLICITHEAP = 529,
	EXIT_FAIL_SCIDSIZE = 530,
	EXIT_FAIL_DIPXSPONDER = 531,
	EXIT_FAIL_DIPFLAG = 532,
	EXIT_FAIL_LABELEN = 533,
	EXIT_FAIL_NOLABEL = 534,
	EXIT_FAIL_PIPXSPONDER = 535,
	EXIT_FAIL_CSSMNULL = 536,
	EXIT_FAIL_CSSMSYNC = 537,
	EXIT_FAIL_CSSMHEADER = 538,
	EXIT_FAIL_CSSMCHECKSUM = 539,
	EXIT_FAIL_SEGMENTNUM = 540,
	EXIT_FAIL_CIREC = 541,
	EXIT_FAIL_DIPPROCESSBUFFER = 542,
	EXIT_FAIL_DSSDATE = 543,
	EXIT_FAIL_APPLIEDTIME = 544,
	EXIT_FAIL_NULLSEGM = 545,
	EXIT_FAIL_SEGMSYNC = 546,
	EXIT_FAIL_SEGMHEADER = 547,
	EXIT_FAIL_SEGMCHECKSUM = 548,
	EXIT_FAIL_SEGMSEGMENTS = 549,
	EXIT_FAIL_SEGMPACKETSIZE = 550,
	EXIT_FAIL_STARTDAY = 551,
	EXIT_FAIL_STARTINFO = 552,
	EXIT_FAIL_STARTTIME = 553,
	EXIT_FAIL_RATING = 554,
	EXIT_FAIL_PI2CHAN = 555,
	EXIT_FAIL_CHAN2PIP = 556,
	EXIT_FAIL_CHAN2DIP = 557,
	EXIT_FAIL_CHAN2NUM = 558,
	EXIT_FAIL_PIAHEADER = 559,
	EXIT_FAIL_STARTSLOT = 560,
	EXIT_FAIL_ENDTIME = 561,
	EXIT_FAIL_NULLPISM = 562,
	EXIT_FAIL_PISMSYNC = 563,
	EXIT_FAIL_PISMHEADER = 564,
	EXIT_FAIL_PISMCHECKSUM = 565,
	EXIT_FAIL_LISTGUIDESLOTS = 566,
	EXIT_FAIL_ES = 567,
	EXIT_FAIL_ARRIVALTIME = 568,
	EXIT_FAIL_MPGPROCESSBUFFER = 569,
	EXIT_FAIL_SPGPROCESSBUFFER = 570,
	EXIT_FAIL_PIPFLAG = 571,
	EXIT_FAIL_CHAN2PIPMSGNUM = 572,
	EXIT_FAIL_PARSE = 573,
	EXIT_FAIL_LOADERREADNET = 574,
	EXIT_FAIL_DBE_INIT = 575,
	EXIT_FAIL_DBE_IMPORT_BLOB = 576,
	EXIT_FAIL_DBE_EXPORT_BLOB = 577,
	EXIT_FAIL_AUTHORIZE = 578,
	EXIT_LAST_CODE = EXIT_FAIL_AUTHORIZE
};

#ifdef _DBDAO_H_
typedef BOOL (*PFNFORCEQUIT)(VOID);
ExitCodeList APIENTRY EPG_DBLoad(int &argc, _TCHAR **argv, CdbDBEngine &db, PFNFORCEQUIT pfnForceQuit);
typedef ExitCodeList (APIENTRY *PFNDBLOAD)(int &argc, _TCHAR **argv, CdbDBEngine &db, PFNFORCEQUIT pfnForceQuit);
#endif
};

// the tuning space value must be the 0th parameter
// of all of the delete queries
const int giTuningSpacePos = 0;

// wparam for broadcast event messages
enum EpgldrEventList
{
    EPGLDR_STARTING = 1,
    EPGLDR_ACTIVE_COMMIT_STARTING = 2,
    EPGLDR_ACTIVE_COMMIT_ENDING = 3,
    EPGLDR_PASSIVE_COMMIT_STARTING = 4,
    EPGLDR_PASSIVE_COMMIT_ENDING = 5,
    EPGLDR_ENDING = 6,
    EPGLDR_EXCLUSIVE_STARTING = 7,
    EPGLDR_EXCLUSIVE_ENDING = 8,
    EPGLDR_ACTIVE_COMMIT_EPIENHANCE_STARTING = 9,
    EPGLDR_ACTIVE_COMMIT_EPIENHANCE_ENDING = 10
};

#define SZLOADERSTUBGUID _T("{27DB71E0-776C-11cf-B8E8-0020AFDFD047}")
#define GUIDLOADERSTUB ({ 0x27db71e0, 0x776c, 0x11cf, { 0xb8, 0xe8, 0x0, 0x20, 0xaf, 0xdf, 0xd0, 0x47 } })

#define SZDTVLOADGUID _T("{7B501360-8D71-11cf-A88F-444553540000}")
#define GUIDDTVLOAD ({ 0x7b501360, 0x8d71, 0x11cf, { 0xa8, 0x8f, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0 } })

#define SZSSLOADGUID _T("{C94D1940-9F69-11d0-BDB8-0000F8027346}")
#define GUIDSSLOAD ({ 0xc94d1940, 0x9f69, 0x11d0, { 0xbd, 0xb8, 0x0, 0x0, 0xf8, 0x2, 0x73, 0x46 } })

#define SZCDFLOADGUID _T("{45CD64E2-D2D5-11d0-AB57-00AA00C23166}")
#define GUIDCDFLOAD ({ 0x45CD64E2, 0xD2D5, 0x11d0, { 0xAB, 0x57, 0x0, 0xAA, 0x0, 0xC2, 0x31, 0x66 } })

#define SZDOWNLOADGUID _T("{62765981-333D-11d1-883A-3C8B00C10000}")
#define GUIDDOWNLOAD ({ 0x62765981, 0x333d, 0x11d1, { 0x88, 0x3a, 0x3c, 0x8b, 0x0, 0xc1, 0x0, 0x0 } })

#define SSSCAN		_T("{C94D1940-9F69-11d0-BDB8-0000F8027346}-Scan")
#define SSSCANEND	_T("{C94D1940-9F69-11d0-BDB8-0000F8027346}-ScanEnded")
#define SSHEAR		_T("{C94D1940-9F69-11d0-BDB8-0000F8027346}-Listen")
#define SSHEAREND	_T("{C94D1940-9F69-11d0-BDB8-0000F8027346}-ListenEnded")


enum SSExitCodeList
{
	SUCCESS,
	INCOMPLETE_SCAN,
	NO_CHANNELS_FOUND,
	NO_VBI_DATA_FOUND,
	NO_SS_DATA_FOUND,
	NO_GOOD_SS_DATA_FOUND,
	NO_REGION_FOUND,
	INCOMPLETE_DATA
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\edktrack.h ===
// --edktrack.h-----------------------------------------------------------------
//
//  Header file for module containing gateway tracking functions and structures.
// 
// Copyright 1986 - 1998 Microsoft Corporation.  All Rights Reserved.
// -----------------------------------------------------------------------------

#ifndef _EDKTRACK_H
#define _EDKTRACK_H

#include "rpcpub.h"

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

//$--HrTrackInitLog-------------------------------------------------------------
//  This function initializes the gateway event tracking module.
// -----------------------------------------------------------------------------
HRESULT HrTrackInitLog(
	IN LPSTR lpszComputer,          // name of the remote computer
    OUT PVOID *ppvSession);         // pointer to gateway tracking session

//$--HrTrackWriteLog@-------------------------------------------------------
//  This function logs a gateway tracking event.
// ----------------------------------------------------------------------------
HRESULT HrTrackWriteLogW(
    IN PVOID           pvSession,       // gateway tracking session
    IN UINT            nEventType,      // gateway tracking event type
    IN SYSTEMTIME      stEvent,         // time event took place
    IN LPCWSTR         lpszGatewayName, // gateway name
    IN LPCWSTR         lpszPartner,     // pointer to entity name string
    IN LPCWSTR         lpszMTSID,       // pointer to MTS-ID string
    IN LPCWSTR         lpszSubjectMTSID,// pointer to subject MTS-ID string
    IN LPCWSTR         lpszRemoteID,    // pointer to foreign ID string
    IN LPCWSTR         lpszOriginator,  // pointer to originator string
    IN INT             nPriority,       // message priority
    IN INT             nLength,         // message length
    IN INT             nSeconds,        // seconds to process this message
    IN INT             nCost,           // cost of processing this message
    IN INT             cRecipients,     // count of recipients
    IN LPCWSTR        *lppszRecipients);// pointer to recipient pointers

HRESULT HrTrackWriteLogA(
    IN PVOID           pvSession,       // gateway tracking session
    IN UINT            nEventType,      // gateway tracking event type
    IN SYSTEMTIME      stEvent,         // time event took place
    IN LPCSTR          lpszGatewayName, // gateway name
    IN LPCSTR          lpszPartner,     // pointer to entity name string
    IN LPCSTR          lpszMTSID,       // pointer to MTS-ID string
    IN LPCSTR          lpszSubjectMTSID,// pointer to subject MTS-ID string
    IN LPCSTR          lpszRemoteID,    // pointer to foreign ID string
    IN LPCSTR          lpszOriginator,  // pointer to originator string
    IN INT             nPriority,       // message priority
    IN INT             nLength,         // message length
    IN INT             nSeconds,        // seconds to process this message
    IN INT             nCost,           // cost of processing this message
    IN INT             cRecipients,     // count of recipients
    IN LPCSTR         *lppszRecipients);// pointer to recipient pointers

#ifdef UNICODE
#define HrTrackWriteLog  HrTrackWriteLogW
#else
#define HrTrackWriteLog  HrTrackWriteLogA
#endif

//$--HrTrackUninitLog----------------------------------------------------------
//  This function uninitializes the gateway event tracking module.
// ----------------------------------------------------------------------------
HRESULT HrTrackUninitLog(
    IN OUT PVOID *ppvSession);          // pointer to gateway tracking session

#ifdef __cplusplus
}
#endif  // __cplusplus

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\emptyvc.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0279 */
/* at Fri Sep 24 19:24:05 1999
 */
/* Compiler settings for emptyvc.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __emptyvc_h__
#define __emptyvc_h__

/* Forward Declarations */ 

#ifndef __IEmptyVolumeCacheCallBack_FWD_DEFINED__
#define __IEmptyVolumeCacheCallBack_FWD_DEFINED__
typedef interface IEmptyVolumeCacheCallBack IEmptyVolumeCacheCallBack;
#endif 	/* __IEmptyVolumeCacheCallBack_FWD_DEFINED__ */


#ifndef __IEmptyVolumeCache_FWD_DEFINED__
#define __IEmptyVolumeCache_FWD_DEFINED__
typedef interface IEmptyVolumeCache IEmptyVolumeCache;
#endif 	/* __IEmptyVolumeCache_FWD_DEFINED__ */


#ifndef __IEmptyVolumeCache2_FWD_DEFINED__
#define __IEmptyVolumeCache2_FWD_DEFINED__
typedef interface IEmptyVolumeCache2 IEmptyVolumeCache2;
#endif 	/* __IEmptyVolumeCache2_FWD_DEFINED__ */


/* header files for imported files */
#include "objidl.h"
#include "oleidl.h"
#include "oaidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_emptyvc_0000 */
/* [local] */ 

//=--------------------------------------------------------------------------=
// emptyvc.h
//=--------------------------------------------------------------------------=
// (C) Copyright 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=

#pragma comment(lib,"uuid.lib")

//---------------------------------------------------------------------------=
// Empty Volume Cache Interfaces.



// IEmptyVolumeCache Flags
#define EVCF_HASSETTINGS             0x0001
#define EVCF_ENABLEBYDEFAULT         0x0002
#define EVCF_REMOVEFROMLIST          0x0004
#define EVCF_ENABLEBYDEFAULT_AUTO    0x0008
#define EVCF_DONTSHOWIFZERO          0x0010
#define EVCF_SETTINGSMODE            0x0020
#define EVCF_OUTOFDISKSPACE          0x0040

// IEmptyVolumeCacheCallBack Flags
#define EVCCBF_LASTNOTIFICATION  0x0001

////////////////////////////////////////////////////////////////////////////
//  Interface Definitions
#ifndef _LPEMPTYVOLUMECACHECALLBACK_DEFINED
#define _LPEMPTYVOLUMECACHECALLBACK_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_emptyvc_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_emptyvc_0000_v0_0_s_ifspec;

#ifndef __IEmptyVolumeCacheCallBack_INTERFACE_DEFINED__
#define __IEmptyVolumeCacheCallBack_INTERFACE_DEFINED__

/* interface IEmptyVolumeCacheCallBack */
/* [unique][uuid][object] */ 

typedef /* [unique] */ IEmptyVolumeCacheCallBack __RPC_FAR *LPEMPTYVOLUMECACHECALLBACK;


EXTERN_C const IID IID_IEmptyVolumeCacheCallBack;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6E793361-73C6-11D0-8469-00AA00442901")
    IEmptyVolumeCacheCallBack : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ScanProgress( 
            /* [in] */ DWORDLONG dwlSpaceUsed,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pcwszStatus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PurgeProgress( 
            /* [in] */ DWORDLONG dwlSpaceFreed,
            /* [in] */ DWORDLONG dwlSpaceToFree,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pcwszStatus) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEmptyVolumeCacheCallBackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEmptyVolumeCacheCallBack __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEmptyVolumeCacheCallBack __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEmptyVolumeCacheCallBack __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ScanProgress )( 
            IEmptyVolumeCacheCallBack __RPC_FAR * This,
            /* [in] */ DWORDLONG dwlSpaceUsed,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pcwszStatus);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PurgeProgress )( 
            IEmptyVolumeCacheCallBack __RPC_FAR * This,
            /* [in] */ DWORDLONG dwlSpaceFreed,
            /* [in] */ DWORDLONG dwlSpaceToFree,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pcwszStatus);
        
        END_INTERFACE
    } IEmptyVolumeCacheCallBackVtbl;

    interface IEmptyVolumeCacheCallBack
    {
        CONST_VTBL struct IEmptyVolumeCacheCallBackVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEmptyVolumeCacheCallBack_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEmptyVolumeCacheCallBack_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEmptyVolumeCacheCallBack_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEmptyVolumeCacheCallBack_ScanProgress(This,dwlSpaceUsed,dwFlags,pcwszStatus)	\
    (This)->lpVtbl -> ScanProgress(This,dwlSpaceUsed,dwFlags,pcwszStatus)

#define IEmptyVolumeCacheCallBack_PurgeProgress(This,dwlSpaceFreed,dwlSpaceToFree,dwFlags,pcwszStatus)	\
    (This)->lpVtbl -> PurgeProgress(This,dwlSpaceFreed,dwlSpaceToFree,dwFlags,pcwszStatus)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEmptyVolumeCacheCallBack_ScanProgress_Proxy( 
    IEmptyVolumeCacheCallBack __RPC_FAR * This,
    /* [in] */ DWORDLONG dwlSpaceUsed,
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPCWSTR pcwszStatus);


void __RPC_STUB IEmptyVolumeCacheCallBack_ScanProgress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEmptyVolumeCacheCallBack_PurgeProgress_Proxy( 
    IEmptyVolumeCacheCallBack __RPC_FAR * This,
    /* [in] */ DWORDLONG dwlSpaceFreed,
    /* [in] */ DWORDLONG dwlSpaceToFree,
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPCWSTR pcwszStatus);


void __RPC_STUB IEmptyVolumeCacheCallBack_PurgeProgress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEmptyVolumeCacheCallBack_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_emptyvc_0131 */
/* [local] */ 

#endif
#ifndef _LPEMPTYVOLUMECACHE_DEFINED
#define _LPEMPTYVOLUMECACHE_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_emptyvc_0131_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_emptyvc_0131_v0_0_s_ifspec;

#ifndef __IEmptyVolumeCache_INTERFACE_DEFINED__
#define __IEmptyVolumeCache_INTERFACE_DEFINED__

/* interface IEmptyVolumeCache */
/* [unique][uuid][object] */ 

typedef /* [unique] */ IEmptyVolumeCache __RPC_FAR *LPEMPTYVOLUMECACHE;


EXTERN_C const IID IID_IEmptyVolumeCache;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8FCE5227-04DA-11d1-A004-00805F8ABE06")
    IEmptyVolumeCache : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ HKEY hkRegKey,
            /* [in] */ LPCWSTR pcwszVolume,
            /* [out] */ LPWSTR __RPC_FAR *ppwszDisplayName,
            /* [out] */ LPWSTR __RPC_FAR *ppwszDescription,
            /* [out] */ DWORD __RPC_FAR *pdwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSpaceUsed( 
            /* [out] */ DWORDLONG __RPC_FAR *pdwlSpaceUsed,
            /* [in] */ IEmptyVolumeCacheCallBack __RPC_FAR *picb) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Purge( 
            /* [in] */ DWORDLONG dwlSpaceToFree,
            /* [in] */ IEmptyVolumeCacheCallBack __RPC_FAR *picb) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ShowProperties( 
            /* [in] */ HWND hwnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Deactivate( 
            /* [out] */ DWORD __RPC_FAR *pdwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEmptyVolumeCacheVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEmptyVolumeCache __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEmptyVolumeCache __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEmptyVolumeCache __RPC_FAR * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Initialize )( 
            IEmptyVolumeCache __RPC_FAR * This,
            /* [in] */ HKEY hkRegKey,
            /* [in] */ LPCWSTR pcwszVolume,
            /* [out] */ LPWSTR __RPC_FAR *ppwszDisplayName,
            /* [out] */ LPWSTR __RPC_FAR *ppwszDescription,
            /* [out] */ DWORD __RPC_FAR *pdwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSpaceUsed )( 
            IEmptyVolumeCache __RPC_FAR * This,
            /* [out] */ DWORDLONG __RPC_FAR *pdwlSpaceUsed,
            /* [in] */ IEmptyVolumeCacheCallBack __RPC_FAR *picb);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Purge )( 
            IEmptyVolumeCache __RPC_FAR * This,
            /* [in] */ DWORDLONG dwlSpaceToFree,
            /* [in] */ IEmptyVolumeCacheCallBack __RPC_FAR *picb);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ShowProperties )( 
            IEmptyVolumeCache __RPC_FAR * This,
            /* [in] */ HWND hwnd);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Deactivate )( 
            IEmptyVolumeCache __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwFlags);
        
        END_INTERFACE
    } IEmptyVolumeCacheVtbl;

    interface IEmptyVolumeCache
    {
        CONST_VTBL struct IEmptyVolumeCacheVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEmptyVolumeCache_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEmptyVolumeCache_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEmptyVolumeCache_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEmptyVolumeCache_Initialize(This,hkRegKey,pcwszVolume,ppwszDisplayName,ppwszDescription,pdwFlags)	\
    (This)->lpVtbl -> Initialize(This,hkRegKey,pcwszVolume,ppwszDisplayName,ppwszDescription,pdwFlags)

#define IEmptyVolumeCache_GetSpaceUsed(This,pdwlSpaceUsed,picb)	\
    (This)->lpVtbl -> GetSpaceUsed(This,pdwlSpaceUsed,picb)

#define IEmptyVolumeCache_Purge(This,dwlSpaceToFree,picb)	\
    (This)->lpVtbl -> Purge(This,dwlSpaceToFree,picb)

#define IEmptyVolumeCache_ShowProperties(This,hwnd)	\
    (This)->lpVtbl -> ShowProperties(This,hwnd)

#define IEmptyVolumeCache_Deactivate(This,pdwFlags)	\
    (This)->lpVtbl -> Deactivate(This,pdwFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [local] */ HRESULT STDMETHODCALLTYPE IEmptyVolumeCache_Initialize_Proxy( 
    IEmptyVolumeCache __RPC_FAR * This,
    /* [in] */ HKEY hkRegKey,
    /* [in] */ LPCWSTR pcwszVolume,
    /* [out] */ LPWSTR __RPC_FAR *ppwszDisplayName,
    /* [out] */ LPWSTR __RPC_FAR *ppwszDescription,
    /* [out] */ DWORD __RPC_FAR *pdwFlags);


void __RPC_STUB IEmptyVolumeCache_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEmptyVolumeCache_GetSpaceUsed_Proxy( 
    IEmptyVolumeCache __RPC_FAR * This,
    /* [out] */ DWORDLONG __RPC_FAR *pdwlSpaceUsed,
    /* [in] */ IEmptyVolumeCacheCallBack __RPC_FAR *picb);


void __RPC_STUB IEmptyVolumeCache_GetSpaceUsed_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEmptyVolumeCache_Purge_Proxy( 
    IEmptyVolumeCache __RPC_FAR * This,
    /* [in] */ DWORDLONG dwlSpaceToFree,
    /* [in] */ IEmptyVolumeCacheCallBack __RPC_FAR *picb);


void __RPC_STUB IEmptyVolumeCache_Purge_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEmptyVolumeCache_ShowProperties_Proxy( 
    IEmptyVolumeCache __RPC_FAR * This,
    /* [in] */ HWND hwnd);


void __RPC_STUB IEmptyVolumeCache_ShowProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEmptyVolumeCache_Deactivate_Proxy( 
    IEmptyVolumeCache __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwFlags);


void __RPC_STUB IEmptyVolumeCache_Deactivate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEmptyVolumeCache_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_emptyvc_0132 */
/* [local] */ 

#endif
#ifndef _LPEMPTYVOLUMECACHE2_DEFINED
#define _LPEMPTYVOLUMECACHE2_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_emptyvc_0132_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_emptyvc_0132_v0_0_s_ifspec;

#ifndef __IEmptyVolumeCache2_INTERFACE_DEFINED__
#define __IEmptyVolumeCache2_INTERFACE_DEFINED__

/* interface IEmptyVolumeCache2 */
/* [unique][uuid][object] */ 

typedef /* [unique] */ IEmptyVolumeCache2 __RPC_FAR *LPEMPTYVOLUMECACHE2;


EXTERN_C const IID IID_IEmptyVolumeCache2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("02b7e3ba-4db3-11d2-b2d9-00c04f8eec8c")
    IEmptyVolumeCache2 : public IEmptyVolumeCache
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE InitializeEx( 
            /* [in] */ HKEY hkRegKey,
            /* [in] */ LPCWSTR pcwszVolume,
            /* [in] */ LPCWSTR pcwszKeyName,
            /* [out] */ LPWSTR __RPC_FAR *ppwszDisplayName,
            /* [out] */ LPWSTR __RPC_FAR *ppwszDescription,
            /* [out] */ LPWSTR __RPC_FAR *ppwszBtnText,
            /* [out] */ DWORD __RPC_FAR *pdwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEmptyVolumeCache2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEmptyVolumeCache2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEmptyVolumeCache2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEmptyVolumeCache2 __RPC_FAR * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Initialize )( 
            IEmptyVolumeCache2 __RPC_FAR * This,
            /* [in] */ HKEY hkRegKey,
            /* [in] */ LPCWSTR pcwszVolume,
            /* [out] */ LPWSTR __RPC_FAR *ppwszDisplayName,
            /* [out] */ LPWSTR __RPC_FAR *ppwszDescription,
            /* [out] */ DWORD __RPC_FAR *pdwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSpaceUsed )( 
            IEmptyVolumeCache2 __RPC_FAR * This,
            /* [out] */ DWORDLONG __RPC_FAR *pdwlSpaceUsed,
            /* [in] */ IEmptyVolumeCacheCallBack __RPC_FAR *picb);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Purge )( 
            IEmptyVolumeCache2 __RPC_FAR * This,
            /* [in] */ DWORDLONG dwlSpaceToFree,
            /* [in] */ IEmptyVolumeCacheCallBack __RPC_FAR *picb);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ShowProperties )( 
            IEmptyVolumeCache2 __RPC_FAR * This,
            /* [in] */ HWND hwnd);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Deactivate )( 
            IEmptyVolumeCache2 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwFlags);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InitializeEx )( 
            IEmptyVolumeCache2 __RPC_FAR * This,
            /* [in] */ HKEY hkRegKey,
            /* [in] */ LPCWSTR pcwszVolume,
            /* [in] */ LPCWSTR pcwszKeyName,
            /* [out] */ LPWSTR __RPC_FAR *ppwszDisplayName,
            /* [out] */ LPWSTR __RPC_FAR *ppwszDescription,
            /* [out] */ LPWSTR __RPC_FAR *ppwszBtnText,
            /* [out] */ DWORD __RPC_FAR *pdwFlags);
        
        END_INTERFACE
    } IEmptyVolumeCache2Vtbl;

    interface IEmptyVolumeCache2
    {
        CONST_VTBL struct IEmptyVolumeCache2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEmptyVolumeCache2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEmptyVolumeCache2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEmptyVolumeCache2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEmptyVolumeCache2_Initialize(This,hkRegKey,pcwszVolume,ppwszDisplayName,ppwszDescription,pdwFlags)	\
    (This)->lpVtbl -> Initialize(This,hkRegKey,pcwszVolume,ppwszDisplayName,ppwszDescription,pdwFlags)

#define IEmptyVolumeCache2_GetSpaceUsed(This,pdwlSpaceUsed,picb)	\
    (This)->lpVtbl -> GetSpaceUsed(This,pdwlSpaceUsed,picb)

#define IEmptyVolumeCache2_Purge(This,dwlSpaceToFree,picb)	\
    (This)->lpVtbl -> Purge(This,dwlSpaceToFree,picb)

#define IEmptyVolumeCache2_ShowProperties(This,hwnd)	\
    (This)->lpVtbl -> ShowProperties(This,hwnd)

#define IEmptyVolumeCache2_Deactivate(This,pdwFlags)	\
    (This)->lpVtbl -> Deactivate(This,pdwFlags)


#define IEmptyVolumeCache2_InitializeEx(This,hkRegKey,pcwszVolume,pcwszKeyName,ppwszDisplayName,ppwszDescription,ppwszBtnText,pdwFlags)	\
    (This)->lpVtbl -> InitializeEx(This,hkRegKey,pcwszVolume,pcwszKeyName,ppwszDisplayName,ppwszDescription,ppwszBtnText,pdwFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [local] */ HRESULT STDMETHODCALLTYPE IEmptyVolumeCache2_InitializeEx_Proxy( 
    IEmptyVolumeCache2 __RPC_FAR * This,
    /* [in] */ HKEY hkRegKey,
    /* [in] */ LPCWSTR pcwszVolume,
    /* [in] */ LPCWSTR pcwszKeyName,
    /* [out] */ LPWSTR __RPC_FAR *ppwszDisplayName,
    /* [out] */ LPWSTR __RPC_FAR *ppwszDescription,
    /* [out] */ LPWSTR __RPC_FAR *ppwszBtnText,
    /* [out] */ DWORD __RPC_FAR *pdwFlags);


void __RPC_STUB IEmptyVolumeCache2_InitializeEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEmptyVolumeCache2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_emptyvc_0133 */
/* [local] */ 

#endif


extern RPC_IF_HANDLE __MIDL_itf_emptyvc_0133_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_emptyvc_0133_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  HWND_UserSize(     unsigned long __RPC_FAR *, unsigned long            , HWND __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  HWND_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, HWND __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  HWND_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, HWND __RPC_FAR * ); 
void                      __RPC_USER  HWND_UserFree(     unsigned long __RPC_FAR *, HWND __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\errno.h ===
/***
*errno.h - system wide error numbers (set by system calls)
*
*       Copyright (c) 1985-1997, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines the system-wide error numbers (set by
*       system calls).  Conforms to the XENIX standard.  Extended
*       for compatibility with Uniforum standard.
*       [System V]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_ERRNO
#define _INC_ERRNO

#if     !defined(_WIN32) && !defined(_MAC)
#error ERROR: Only Mac or Win32 targets supported!
#endif


#ifdef  __cplusplus
extern "C" {
#endif



/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

/* Define _CRTAPI1 (for compatibility with the NT SDK) */

#ifndef _CRTAPI1
#if	_MSC_VER >= 800 && _M_IX86 >= 300
#define _CRTAPI1 __cdecl
#else
#define _CRTAPI1
#endif
#endif


/* declare reference to errno */

#if     (defined(_MT) || defined(_DLL)) && !defined(_MAC)
_CRTIMP extern int * __cdecl _errno(void);
#define errno   (*_errno())
#else   /* ndef _MT && ndef _DLL */
_CRTIMP extern int errno;
#endif  /* _MT || _DLL */

/* Error Codes */

#define EPERM           1
#define ENOENT          2
#define ESRCH           3
#define EINTR           4
#define EIO             5
#define ENXIO           6
#define E2BIG           7
#define ENOEXEC         8
#define EBADF           9
#define ECHILD          10
#define EAGAIN          11
#define ENOMEM          12
#define EACCES          13
#define EFAULT          14
#define EBUSY           16
#define EEXIST          17
#define EXDEV           18
#define ENODEV          19
#define ENOTDIR         20
#define EISDIR          21
#define EINVAL          22
#define ENFILE          23
#define EMFILE          24
#define ENOTTY          25
#define EFBIG           27
#define ENOSPC          28
#define ESPIPE          29
#define EROFS           30
#define EMLINK          31
#define EPIPE           32
#define EDOM            33
#define ERANGE          34
#define EDEADLK         36
#define ENAMETOOLONG    38
#define ENOLCK          39
#define ENOSYS          40
#define ENOTEMPTY       41
#define EILSEQ          42

/*
 * Support EDEADLOCK for compatibiity with older MS-C versions.
 */
#define EDEADLOCK       EDEADLK

#ifdef  __cplusplus
}
#endif

#endif  /* _INC_ERRNO */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\EsConf_I.c ===
/* this file contains the actual definitions of */
/* the IIDs and CLSIDs */

/* link this file in with the server and any clients */


/* File created by MIDL compiler version 3.01.75 */
/* at Fri Mar 27 05:37:32 1998
 */
/* Compiler settings for J:\events\src\esconf\esconf.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

const IID IID_IEvents = {0x2F42C690,0xC6A4,0x11D0,{0x93,0xE9,0x00,0xAA,0x00,0x64,0xD4,0x70}};


const IID IID_IHosts = {0x2F42C69A,0xC6A4,0x11D0,{0x93,0xE9,0x00,0xAA,0x00,0x64,0xD4,0x70}};


const IID IID_IHost = {0x4AA3F8E1,0xC6AF,0x11D0,{0x93,0xE9,0x00,0xAA,0x00,0x64,0xD4,0x70}};


const IID IID_IHandlers = {0x2F42C69D,0xC6A4,0x11D0,{0x93,0xE9,0x00,0xAA,0x00,0x64,0xD4,0x70}};


const IID IID_IHandler = {0x4AA3F8E4,0xC6AF,0x11D0,{0x93,0xE9,0x00,0xAA,0x00,0x64,0xD4,0x70}};


const IID IID_IBoundFolders = {0xB0C0F075,0xDEA0,0x11d0,{0x84,0xB0,0x00,0xC0,0x4F,0xC2,0xF8,0xDA}};


const IID IID_IBoundFolder = {0xB0C0F074,0xDEA0,0x11d0,{0x84,0xB0,0x00,0xC0,0x4F,0xC2,0xF8,0xDA}};


const IID IID_IEventBindings = {0x2F42C694,0xC6A4,0x11D0,{0x93,0xE9,0x00,0xAA,0x00,0x64,0xD4,0x70}};


const IID IID_IEventBinding = {0x2F42C697,0xC6A4,0x11D0,{0x93,0xE9,0x00,0xAA,0x00,0x64,0xD4,0x70}};


const IID IID_ISchedule = {0x2F42C699,0xC6A4,0x11D0,{0x93,0xE9,0x00,0xAA,0x00,0x64,0xD4,0x70}};


const IID LIBID_ESCONFIGLib = {0x2F42C683,0xC6A4,0x11D0,{0x93,0xE9,0x00,0xAA,0x00,0x64,0xD4,0x70}};


const CLSID CLSID_Events = {0x2F42C693,0xC6A4,0x11D0,{0x93,0xE9,0x00,0xAA,0x00,0x64,0xD4,0x70}};


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\errcppd.h ===
// ErrCppD.h--------------------------------------------------------------------
// This defines an array of mapi error codes.
// Include this file only once in your code for the entire project.
//
// Copyright 1986 - 1998 Microsoft Corporation.  All Rights Reserved.
// -----------------------------------------------------------------------------

#ifndef _ERRCPPD_H_
#define _ERRCPPD_H_

// -----------------------------------------------------------------------------

static IDList MAPIErrors[] = 
{
    (ULONG) SUCCESS_SUCCESS,    "SUCCESS_SUCCESS",
    (ULONG) MAPI_E_CALL_FAILED, "MAPI_E_CALL_FAILED",
    (ULONG) MAPI_E_NOT_ENOUGH_MEMORY,   "MAPI_E_NOT_ENOUGH_MEMORY",
    (ULONG) MAPI_E_INVALID_PARAMETER,   "MAPI_E_INVALID_PARAMETER",
    (ULONG) MAPI_E_INTERFACE_NOT_SUPPORTED, "MAPI_E_INTERFACE_NOT_SUPPORTED",
    (ULONG) MAPI_E_NO_ACCESS,   "MAPI_E_NO_ACCESS",
    (ULONG) MAPI_E_NO_SUPPORT,  "MAPI_E_NO_SUPPORT",
    (ULONG) MAPI_E_BAD_CHARWIDTH,   "MAPI_E_BAD_CHARWIDTH",
    (ULONG) MAPI_E_STRING_TOO_LONG, "MAPI_E_STRING_TOO_LONG",
    (ULONG) MAPI_E_UNKNOWN_FLAGS,   "MAPI_E_UNKNOWN_FLAGS",
    (ULONG) MAPI_E_INVALID_ENTRYID, "MAPI_E_INVALID_ENTRYID",
    (ULONG) MAPI_E_INVALID_OBJECT,  "MAPI_E_INVALID_OBJECT",
    (ULONG) MAPI_E_OBJECT_CHANGED,  "MAPI_E_OBJECT_CHANGED",
    (ULONG) MAPI_E_OBJECT_DELETED,  "MAPI_E_OBJECT_DELETED",
    (ULONG) MAPI_E_BUSY,    "MAPI_E_BUSY",
    (ULONG) MAPI_E_NOT_ENOUGH_DISK, "MAPI_E_NOT_ENOUGH_DISK",
    (ULONG) MAPI_E_NOT_ENOUGH_RESOURCES,    "MAPI_E_NOT_ENOUGH_RESOURCES",
    (ULONG) MAPI_E_NOT_FOUND,   "MAPI_E_NOT_FOUND",
    (ULONG) MAPI_E_VERSION, "MAPI_E_VERSION",
    (ULONG) MAPI_E_LOGON_FAILED,    "MAPI_E_LOGON_FAILED",
    (ULONG) MAPI_E_SESSION_LIMIT,   "MAPI_E_SESSION_LIMIT",
    (ULONG) MAPI_E_USER_CANCEL, "MAPI_E_USER_CANCEL",
    (ULONG) MAPI_E_UNABLE_TO_ABORT, "MAPI_E_UNABLE_TO_ABORT",
    (ULONG) MAPI_E_NETWORK_ERROR,   "MAPI_E_NETWORK_ERROR",
    (ULONG) MAPI_E_DISK_ERROR,  "MAPI_E_DISK_ERROR",
    (ULONG) MAPI_E_TOO_COMPLEX, "MAPI_E_TOO_COMPLEX",
    (ULONG) MAPI_E_BAD_COLUMN,  "MAPI_E_BAD_COLUMN",
    (ULONG) MAPI_E_EXTENDED_ERROR,  "MAPI_E_EXTENDED_ERROR",
    (ULONG) MAPI_E_COMPUTED,    "MAPI_E_COMPUTED",
    (ULONG) MAPI_E_END_OF_SESSION,  "MAPI_E_END_OF_SESSION",
    (ULONG) MAPI_E_UNKNOWN_ENTRYID, "MAPI_E_UNKNOWN_ENTRYID",
    (ULONG) MAPI_E_MISSING_REQUIRED_COLUMN, "MAPI_E_MISSING_REQUIRED_COLUMN",
    (ULONG) MAPI_W_NO_SERVICE,  "MAPI_W_NO_SERVICE",
    (ULONG) MAPI_E_BAD_VALUE,   "MAPI_E_BAD_VALUE",
    (ULONG) MAPI_E_INVALID_TYPE,    "MAPI_E_INVALID_TYPE",
    (ULONG) MAPI_E_TYPE_NO_SUPPORT, "MAPI_E_TYPE_NO_SUPPORT",
    (ULONG) MAPI_E_UNEXPECTED_TYPE, "MAPI_E_UNEXPECTED_TYPE",
    (ULONG) MAPI_E_TOO_BIG, "MAPI_E_TOO_BIG",
    (ULONG) MAPI_W_ERRORS_RETURNED, "MAPI_W_ERRORS_RETURNED",
    (ULONG) MAPI_E_UNABLE_TO_COMPLETE,  "MAPI_E_UNABLE_TO_COMPLETE",
    (ULONG) MAPI_E_TABLE_EMPTY, "MAPI_E_TABLE_EMPTY",
    (ULONG) MAPI_E_TABLE_TOO_BIG,   "MAPI_E_TABLE_TOO_BIG",
    (ULONG) MAPI_E_INVALID_BOOKMARK,    "MAPI_E_INVALID_BOOKMARK",
    (ULONG) MAPI_W_POSITION_CHANGED,    "MAPI_W_POSITION_CHANGED",
    (ULONG) MAPI_W_APPROX_COUNT,    "MAPI_W_APPROX_COUNT",
    (ULONG) MAPI_E_WAIT,    "MAPI_E_WAIT",
    (ULONG) MAPI_E_CANCEL,  "MAPI_E_CANCEL",
    (ULONG) MAPI_E_NOT_ME,  "MAPI_E_NOT_ME",
    (ULONG) MAPI_W_CANCEL_MESSAGE,  "MAPI_W_CANCEL_MESSAGE",
    (ULONG) MAPI_E_CORRUPT_STORE,   "MAPI_E_CORRUPT_STORE",
    (ULONG) MAPI_E_NOT_IN_QUEUE,    "MAPI_E_NOT_IN_QUEUE",
    (ULONG) MAPI_E_NO_SUPPRESS, "MAPI_E_NO_SUPPRESS",
    (ULONG) MAPI_E_COLLISION,   "MAPI_E_COLLISION",
    (ULONG) MAPI_E_NOT_INITIALIZED, "MAPI_E_NOT_INITIALIZED",
    (ULONG) MAPI_E_NON_STANDARD,    "MAPI_E_NON_STANDARD",
    (ULONG) MAPI_E_NO_RECIPIENTS,   "MAPI_E_NO_RECIPIENTS",
    (ULONG) MAPI_E_SUBMITTED,   "MAPI_E_SUBMITTED",
    (ULONG) MAPI_E_HAS_FOLDERS, "MAPI_E_HAS_FOLDERS",
    (ULONG) MAPI_E_HAS_MESSAGES,    "MAPI_E_HAS_MESSAGES",
    (ULONG) MAPI_E_FOLDER_CYCLE,    "MAPI_E_FOLDER_CYCLE",
    (ULONG) MAPI_W_PARTIAL_COMPLETION,  "MAPI_W_PARTIAL_COMPLETION",
    (ULONG) MAPI_E_AMBIGUOUS_RECIP, "MAPI_E_AMBIGUOUS_RECIP",
    (ULONG) E_NOTIMPL,      "E_NOTIMPL",
    (ULONG) E_UNEXPECTED,   "E_UNEXPECTED",
    (ULONG) E_OUTOFMEMORY,  "E_OUTOFMEMORY",
    (ULONG) E_INVALIDARG,   "E_INVALIDARG",
    (ULONG) E_NOINTERFACE,  "E_NOINTERFACE",
    (ULONG) E_POINTER,      "E_POINTER",
    (ULONG) E_HANDLE,       "E_HANDLE",
    (ULONG) E_ABORT,        "E_ABORT",
    (ULONG) E_FAIL,         "E_FAIL",
    (ULONG) E_ACCESSDENIED, "E_ACCESSDENIED",
};

// -----------------------------------------------------------------------------

#endif  //_ERRCPPD_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\epprop.h ===
/***********************************************************************
**      E P P R O P . H                                                *
**                                                                     *
************************************************************************
** Copyright (C) 1996 by Microsoft Corporation                         *
**                 All Rights Reserved                                 *
************************************************************************/
/*

        EPPROP.H

        EpisodeProperty record object class definitions for Microsoft Guide



*/



#ifndef _EPPROP_H_
#define _EPPROP_H_


#include "dbsets.h"


/*

EpisodeProperty objects are constructed from database records of the EpisodeProperty table.

The CEpisodePropertyRecordset class is used to select and create CEpisodeProperty objects
from the EpisodeProperty table via functions in the CDatabaseRecordset parent class.

*/



class  COMMMSTVEXPORT CEpisodePropertyRecordset : public CDatabaseRecordset
{

// This class provides EpisodeProperty recordset manipulation via parent functions

virtual CString GetTableName( VOID);

virtual BOOL    SetRecordsetObject( VOID* cRecordsetObject);

public:
virtual VOID*   GetRecordsetObject( VOID);
virtual BOOLEAN Seek(LPCTSTR lpszComparison, CObject &coo);
};




class COMMMSTVEXPORT CEpisodeProperty : public CObject
{

    friend class CEpisodePropertyRecordset; // generates the CEpisodeProperty record object


public:

	CEpisodeProperty(LONG m_lEpisodeID = 0,
						LONG lBroadcastPropertyID = 0) :
					    m_lEpisodeID(m_lEpisodeID),
					    m_lBroadcastPropertyID(lBroadcastPropertyID) { }

	~CEpisodeProperty(VOID) { }

    VOID    SetEpisodeID( LONG lEpisodeID) { m_lEpisodeID = lEpisodeID; }
    VOID    SetBroadcastPropertyID( LONG lBroadcastPropertyID) { m_lBroadcastPropertyID = lBroadcastPropertyID; }

    LONG            EpisodeID() { return m_lEpisodeID; }
    LONG            BroadcastPropertyID() { return m_lBroadcastPropertyID; }


private:

    LONG            m_lEpisodeID;
    LONG            m_lBroadcastPropertyID;


};

// Table: EpisodeProperty

#define  TBL_EpisodeProperty  _T("[Episode Property]")

//      Field:                                      Name                          Type    Size

#define FLD_EpisodeProperty_EpisodeID           _T("EP Episode ID")            // Long      4
#define FLD_EpisodeProperty_BroadcastPropertyID _T("EP Broadcast Property ID") // Long      4


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\errcpp.h ===
// ErrCpp.h---------------------------------------------------------------------
// Defines a helper class for mapi errors.
//
// Copyright 1986 - 1998 Microsoft Corporation.  All Rights Reserved.
// -----------------------------------------------------------------------------

#ifndef _ERRCPP_H_
#define _ERRCPP_H_

#include "EdkUtCpp.H"

// -----------------------------------------------------------------------------
// This class is intended as a replacement for the HRESULT type defined by MAPI.
// It has two advantages over MAPI's version.
//   1) You can report the error code as a readable string using the Msg() 
//      member function.
//   2) When in debug mode you can view this object and see the return code
//      as a readable string by viewing the contents of the m_sMsg member object.
//
// You can use this exactly like you use HRESULT.  In other words you can assign
// an HRESULT return value directly to it.  You can test it using FAILED.  You
// can assign it back to a type HRESULT or return it from a function whose return
// type is HRESULT.  You can even assign it to a const char* or pass it to a 
// function that takes a const char* and you will get the readable string version
// of the HRESULT.
// -----------------------------------------------------------------------------

class CHRESULT
{
public:
    // CONSTRUCTOR: defaults to NOERROR or uses the value you pass in.
    CHRESULT( HRESULT hr = NOERROR)
    {
        m_hr = hr;
        #if DEBUG
            m_sMsg = m_idlMAPIErr.Find( m_hr);
        #endif
    }
    
    // Returns TRUE if the HRESULT failed.
    BOOL bFailed() {return( FAILED( m_hr));}

    // Returns the defined constant for the error as a string constant. Usage example:
    //   CHRESULT hr = MAPI_E_NOT_FOUND;
    //   char chBuf[500];
    //   sprintf( chBuf, "Error: %s occurred", hr.Msg());
    const LPSTR Msg()
    {
        #if DEBUG
            return( m_sMsg.GetBuffer(0));
        #else
            return( m_idlMAPIErr.Find( m_hr));
        #endif
    }
    
    // Returns the defined constant for the error as a string. Usage example:
    //   CHRESULT hr = MAPI_E_NOT_FOUND;
    //   const char* pErrMsg = hr;    // returns "MAPI_E_NOT_FOUND".
    operator LPSTR()                {return( Msg());}                   

    // Returns the HRESULT. Usage example:
    //   CHRESULT hr = MAPI_E_NOT_FOUND;
    //   HRESULT mapiHR = hr;
    operator HRESULT()              {return( m_hr);}                    

    // Assigns an HRESULT to CHRESULT. Usage example:
    //   CHRESULT hr;       // Defaults to SUCCESS_SUCCESS
    //   hr = imapiProp->GetProps( ...
    const CHRESULT& operator=( HRESULT hr)
    {
        m_hr = hr;
        #if DEBUG
            m_sMsg = m_idlMAPIErr.Find( m_hr);
        #endif
        return( *this);
    }

protected:
    static CIDList  m_idlMAPIErr;   // Static ID list of MAPI Errors.
    HRESULT         m_hr;           // Contains the actual HRESULT.
    
    #if DEBUG
    CString         m_sMsg;         // In the dubugger look at this to see the 
    #endif                          // current HRESULT as a readable string.
};

// -----------------------------------------------------------------------------
#ifdef _GLOBAL_OBJECTS_
#pragma message("Declaration of global objects for: " __FILE__)

#include "ErrCppD.h"
CIDList CHRESULT::m_idlMAPIErr( MAPIErrors, ARRAY_CNT( MAPIErrors));

#endif //_GLOBAL_OBJECTS_
// -----------------------------------------------------------------------------

#endif // _ERRCPP_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\EsConf.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.01.75 */
/* at Fri Mar 27 05:37:32 1998
 */
/* Compiler settings for J:\events\src\esconf\esconf.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __esconf_h__
#define __esconf_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IEvents_FWD_DEFINED__
#define __IEvents_FWD_DEFINED__
typedef interface IEvents IEvents;
#endif 	/* __IEvents_FWD_DEFINED__ */


#ifndef __IHosts_FWD_DEFINED__
#define __IHosts_FWD_DEFINED__
typedef interface IHosts IHosts;
#endif 	/* __IHosts_FWD_DEFINED__ */


#ifndef __IHost_FWD_DEFINED__
#define __IHost_FWD_DEFINED__
typedef interface IHost IHost;
#endif 	/* __IHost_FWD_DEFINED__ */


#ifndef __IHandlers_FWD_DEFINED__
#define __IHandlers_FWD_DEFINED__
typedef interface IHandlers IHandlers;
#endif 	/* __IHandlers_FWD_DEFINED__ */


#ifndef __IHandler_FWD_DEFINED__
#define __IHandler_FWD_DEFINED__
typedef interface IHandler IHandler;
#endif 	/* __IHandler_FWD_DEFINED__ */


#ifndef __IBoundFolders_FWD_DEFINED__
#define __IBoundFolders_FWD_DEFINED__
typedef interface IBoundFolders IBoundFolders;
#endif 	/* __IBoundFolders_FWD_DEFINED__ */


#ifndef __IBoundFolder_FWD_DEFINED__
#define __IBoundFolder_FWD_DEFINED__
typedef interface IBoundFolder IBoundFolder;
#endif 	/* __IBoundFolder_FWD_DEFINED__ */


#ifndef __IEventBindings_FWD_DEFINED__
#define __IEventBindings_FWD_DEFINED__
typedef interface IEventBindings IEventBindings;
#endif 	/* __IEventBindings_FWD_DEFINED__ */


#ifndef __IEventBinding_FWD_DEFINED__
#define __IEventBinding_FWD_DEFINED__
typedef interface IEventBinding IEventBinding;
#endif 	/* __IEventBinding_FWD_DEFINED__ */


#ifndef __ISchedule_FWD_DEFINED__
#define __ISchedule_FWD_DEFINED__
typedef interface ISchedule ISchedule;
#endif 	/* __ISchedule_FWD_DEFINED__ */


#ifndef __IHosts_FWD_DEFINED__
#define __IHosts_FWD_DEFINED__
typedef interface IHosts IHosts;
#endif 	/* __IHosts_FWD_DEFINED__ */


#ifndef __IHost_FWD_DEFINED__
#define __IHost_FWD_DEFINED__
typedef interface IHost IHost;
#endif 	/* __IHost_FWD_DEFINED__ */


#ifndef __IHandlers_FWD_DEFINED__
#define __IHandlers_FWD_DEFINED__
typedef interface IHandlers IHandlers;
#endif 	/* __IHandlers_FWD_DEFINED__ */


#ifndef __IHandler_FWD_DEFINED__
#define __IHandler_FWD_DEFINED__
typedef interface IHandler IHandler;
#endif 	/* __IHandler_FWD_DEFINED__ */


#ifndef __IBoundFolders_FWD_DEFINED__
#define __IBoundFolders_FWD_DEFINED__
typedef interface IBoundFolders IBoundFolders;
#endif 	/* __IBoundFolders_FWD_DEFINED__ */


#ifndef __IBoundFolder_FWD_DEFINED__
#define __IBoundFolder_FWD_DEFINED__
typedef interface IBoundFolder IBoundFolder;
#endif 	/* __IBoundFolder_FWD_DEFINED__ */


#ifndef __IEventBindings_FWD_DEFINED__
#define __IEventBindings_FWD_DEFINED__
typedef interface IEventBindings IEventBindings;
#endif 	/* __IEventBindings_FWD_DEFINED__ */


#ifndef __IEventBinding_FWD_DEFINED__
#define __IEventBinding_FWD_DEFINED__
typedef interface IEventBinding IEventBinding;
#endif 	/* __IEventBinding_FWD_DEFINED__ */


#ifndef __ISchedule_FWD_DEFINED__
#define __ISchedule_FWD_DEFINED__
typedef interface ISchedule ISchedule;
#endif 	/* __ISchedule_FWD_DEFINED__ */


#ifndef __Events_FWD_DEFINED__
#define __Events_FWD_DEFINED__

#ifdef __cplusplus
typedef class Events Events;
#else
typedef struct Events Events;
#endif /* __cplusplus */

#endif 	/* __Events_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __IEvents_INTERFACE_DEFINED__
#define __IEvents_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEvents
 * at Fri Mar 27 05:37:32 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][dual][oleautomation][helpstring][uuid][object] */ 



EXTERN_C const IID IID_IEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("2F42C690-C6A4-11D0-93E9-00AA0064D470")
    IEvents : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Session( 
            /* [retval][out] */ LPUNKNOWN __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Session( 
            /* [in] */ VARIANT newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Hosts( 
            /* [retval][out] */ VARIANT __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Options( 
            /* [retval][out] */ ULONG __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Options( 
            /* [in] */ ULONG newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_BoundFolder( 
            /* [in] */ VARIANT varFolder,
            /* [in] */ BOOL fCreate,
            /* [retval][out] */ VARIANT __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PublicMDB( 
            /* [retval][out] */ LPUNKNOWN __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_EventBinding( 
            /* [in] */ BSTR strID,
            /* [retval][out] */ VARIANT __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE MoveBoundFolder( 
            /* [in] */ BSTR bstrHostName,
            /* [in] */ VARIANT varBoundFolder) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEvents __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEvents __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IEvents __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IEvents __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IEvents __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Session )( 
            IEvents __RPC_FAR * This,
            /* [retval][out] */ LPUNKNOWN __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Session )( 
            IEvents __RPC_FAR * This,
            /* [in] */ VARIANT newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Hosts )( 
            IEvents __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Options )( 
            IEvents __RPC_FAR * This,
            /* [retval][out] */ ULONG __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Options )( 
            IEvents __RPC_FAR * This,
            /* [in] */ ULONG newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_BoundFolder )( 
            IEvents __RPC_FAR * This,
            /* [in] */ VARIANT varFolder,
            /* [in] */ BOOL fCreate,
            /* [retval][out] */ VARIANT __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_PublicMDB )( 
            IEvents __RPC_FAR * This,
            /* [retval][out] */ LPUNKNOWN __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_EventBinding )( 
            IEvents __RPC_FAR * This,
            /* [in] */ BSTR strID,
            /* [retval][out] */ VARIANT __RPC_FAR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveBoundFolder )( 
            IEvents __RPC_FAR * This,
            /* [in] */ BSTR bstrHostName,
            /* [in] */ VARIANT varBoundFolder);
        
        END_INTERFACE
    } IEventsVtbl;

    interface IEvents
    {
        CONST_VTBL struct IEventsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEvents_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEvents_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEvents_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEvents_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IEvents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IEvents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IEvents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IEvents_get_Session(This,pVal)	\
    (This)->lpVtbl -> get_Session(This,pVal)

#define IEvents_put_Session(This,newVal)	\
    (This)->lpVtbl -> put_Session(This,newVal)

#define IEvents_get_Hosts(This,pVal)	\
    (This)->lpVtbl -> get_Hosts(This,pVal)

#define IEvents_get_Options(This,pVal)	\
    (This)->lpVtbl -> get_Options(This,pVal)

#define IEvents_put_Options(This,newVal)	\
    (This)->lpVtbl -> put_Options(This,newVal)

#define IEvents_get_BoundFolder(This,varFolder,fCreate,pVal)	\
    (This)->lpVtbl -> get_BoundFolder(This,varFolder,fCreate,pVal)

#define IEvents_get_PublicMDB(This,pVal)	\
    (This)->lpVtbl -> get_PublicMDB(This,pVal)

#define IEvents_get_EventBinding(This,strID,pVal)	\
    (This)->lpVtbl -> get_EventBinding(This,strID,pVal)

#define IEvents_MoveBoundFolder(This,bstrHostName,varBoundFolder)	\
    (This)->lpVtbl -> MoveBoundFolder(This,bstrHostName,varBoundFolder)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IEvents_get_Session_Proxy( 
    IEvents __RPC_FAR * This,
    /* [retval][out] */ LPUNKNOWN __RPC_FAR *pVal);


void __RPC_STUB IEvents_get_Session_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IEvents_put_Session_Proxy( 
    IEvents __RPC_FAR * This,
    /* [in] */ VARIANT newVal);


void __RPC_STUB IEvents_put_Session_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IEvents_get_Hosts_Proxy( 
    IEvents __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pVal);


void __RPC_STUB IEvents_get_Hosts_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IEvents_get_Options_Proxy( 
    IEvents __RPC_FAR * This,
    /* [retval][out] */ ULONG __RPC_FAR *pVal);


void __RPC_STUB IEvents_get_Options_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IEvents_put_Options_Proxy( 
    IEvents __RPC_FAR * This,
    /* [in] */ ULONG newVal);


void __RPC_STUB IEvents_put_Options_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IEvents_get_BoundFolder_Proxy( 
    IEvents __RPC_FAR * This,
    /* [in] */ VARIANT varFolder,
    /* [in] */ BOOL fCreate,
    /* [retval][out] */ VARIANT __RPC_FAR *pVal);


void __RPC_STUB IEvents_get_BoundFolder_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IEvents_get_PublicMDB_Proxy( 
    IEvents __RPC_FAR * This,
    /* [retval][out] */ LPUNKNOWN __RPC_FAR *pVal);


void __RPC_STUB IEvents_get_PublicMDB_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IEvents_get_EventBinding_Proxy( 
    IEvents __RPC_FAR * This,
    /* [in] */ BSTR strID,
    /* [retval][out] */ VARIANT __RPC_FAR *pVal);


void __RPC_STUB IEvents_get_EventBinding_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IEvents_MoveBoundFolder_Proxy( 
    IEvents __RPC_FAR * This,
    /* [in] */ BSTR bstrHostName,
    /* [in] */ VARIANT varBoundFolder);


void __RPC_STUB IEvents_MoveBoundFolder_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEvents_INTERFACE_DEFINED__ */


#ifndef __IHosts_INTERFACE_DEFINED__
#define __IHosts_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IHosts
 * at Fri Mar 27 05:37:32 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][dual][oleautomation][helpstring][uuid][object] */ 



EXTERN_C const IID IID_IHosts;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("2F42C69A-C6A4-11D0-93E9-00AA0064D470")
    IHosts : public IDispatch
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ VARIANT varIndex,
            /* [retval][out] */ VARIANT __RPC_FAR *retval) = 0;
        
        virtual /* [restricted][propget][id] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *retval) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHostsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IHosts __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IHosts __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IHosts __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IHosts __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IHosts __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IHosts __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IHosts __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            IHosts __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Item )( 
            IHosts __RPC_FAR * This,
            /* [in] */ VARIANT varIndex,
            /* [retval][out] */ VARIANT __RPC_FAR *retval);
        
        /* [restricted][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__NewEnum )( 
            IHosts __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *retval);
        
        END_INTERFACE
    } IHostsVtbl;

    interface IHosts
    {
        CONST_VTBL struct IHostsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHosts_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHosts_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHosts_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHosts_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IHosts_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IHosts_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IHosts_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IHosts_get_Count(This,pVal)	\
    (This)->lpVtbl -> get_Count(This,pVal)

#define IHosts_get_Item(This,varIndex,retval)	\
    (This)->lpVtbl -> get_Item(This,varIndex,retval)

#define IHosts_get__NewEnum(This,retval)	\
    (This)->lpVtbl -> get__NewEnum(This,retval)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget][id] */ HRESULT STDMETHODCALLTYPE IHosts_get_Count_Proxy( 
    IHosts __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IHosts_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE IHosts_get_Item_Proxy( 
    IHosts __RPC_FAR * This,
    /* [in] */ VARIANT varIndex,
    /* [retval][out] */ VARIANT __RPC_FAR *retval);


void __RPC_STUB IHosts_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][propget][id] */ HRESULT STDMETHODCALLTYPE IHosts_get__NewEnum_Proxy( 
    IHosts __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *retval);


void __RPC_STUB IHosts_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHosts_INTERFACE_DEFINED__ */


#ifndef __IHost_INTERFACE_DEFINED__
#define __IHost_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IHost
 * at Fri Mar 27 05:37:32 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][dual][oleautomation][helpstring][uuid][object] */ 



EXTERN_C const IID IID_IHost;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("4AA3F8E1-C6AF-11D0-93E9-00AA0064D470")
    IHost : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Handlers( 
            /* [retval][out] */ VARIANT __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_BoundFolders( 
            /* [retval][out] */ VARIANT __RPC_FAR *pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHostVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IHost __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IHost __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IHost __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IHost __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IHost __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IHost __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IHost __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )( 
            IHost __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Handlers )( 
            IHost __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_BoundFolders )( 
            IHost __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pVal);
        
        END_INTERFACE
    } IHostVtbl;

    interface IHost
    {
        CONST_VTBL struct IHostVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHost_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHost_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHost_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHost_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IHost_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IHost_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IHost_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IHost_get_Name(This,pVal)	\
    (This)->lpVtbl -> get_Name(This,pVal)

#define IHost_get_Handlers(This,pVal)	\
    (This)->lpVtbl -> get_Handlers(This,pVal)

#define IHost_get_BoundFolders(This,pVal)	\
    (This)->lpVtbl -> get_BoundFolders(This,pVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IHost_get_Name_Proxy( 
    IHost __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IHost_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IHost_get_Handlers_Proxy( 
    IHost __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pVal);


void __RPC_STUB IHost_get_Handlers_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IHost_get_BoundFolders_Proxy( 
    IHost __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pVal);


void __RPC_STUB IHost_get_BoundFolders_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHost_INTERFACE_DEFINED__ */


#ifndef __IHandlers_INTERFACE_DEFINED__
#define __IHandlers_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IHandlers
 * at Fri Mar 27 05:37:32 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][dual][oleautomation][helpstring][uuid][object] */ 



EXTERN_C const IID IID_IHandlers;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("2F42C69D-C6A4-11D0-93E9-00AA0064D470")
    IHandlers : public IDispatch
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ VARIANT varIndex,
            /* [retval][out] */ VARIANT __RPC_FAR *retval) = 0;
        
        virtual /* [restricted][propget][id] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *retval) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Add( 
            /* [in] */ BSTR Name,
            /* [in] */ BSTR bstrCLSID,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarNew) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Delete( 
            /* [in] */ BSTR bstrCLSID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHandlersVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IHandlers __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IHandlers __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IHandlers __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IHandlers __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IHandlers __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IHandlers __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IHandlers __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            IHandlers __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Item )( 
            IHandlers __RPC_FAR * This,
            /* [in] */ VARIANT varIndex,
            /* [retval][out] */ VARIANT __RPC_FAR *retval);
        
        /* [restricted][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__NewEnum )( 
            IHandlers __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Add )( 
            IHandlers __RPC_FAR * This,
            /* [in] */ BSTR Name,
            /* [in] */ BSTR bstrCLSID,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarNew);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Delete )( 
            IHandlers __RPC_FAR * This,
            /* [in] */ BSTR bstrCLSID);
        
        END_INTERFACE
    } IHandlersVtbl;

    interface IHandlers
    {
        CONST_VTBL struct IHandlersVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHandlers_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHandlers_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHandlers_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHandlers_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IHandlers_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IHandlers_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IHandlers_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IHandlers_get_Count(This,pVal)	\
    (This)->lpVtbl -> get_Count(This,pVal)

#define IHandlers_get_Item(This,varIndex,retval)	\
    (This)->lpVtbl -> get_Item(This,varIndex,retval)

#define IHandlers_get__NewEnum(This,retval)	\
    (This)->lpVtbl -> get__NewEnum(This,retval)

#define IHandlers_Add(This,Name,bstrCLSID,pvarNew)	\
    (This)->lpVtbl -> Add(This,Name,bstrCLSID,pvarNew)

#define IHandlers_Delete(This,bstrCLSID)	\
    (This)->lpVtbl -> Delete(This,bstrCLSID)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget][id] */ HRESULT STDMETHODCALLTYPE IHandlers_get_Count_Proxy( 
    IHandlers __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IHandlers_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE IHandlers_get_Item_Proxy( 
    IHandlers __RPC_FAR * This,
    /* [in] */ VARIANT varIndex,
    /* [retval][out] */ VARIANT __RPC_FAR *retval);


void __RPC_STUB IHandlers_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][propget][id] */ HRESULT STDMETHODCALLTYPE IHandlers_get__NewEnum_Proxy( 
    IHandlers __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *retval);


void __RPC_STUB IHandlers_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IHandlers_Add_Proxy( 
    IHandlers __RPC_FAR * This,
    /* [in] */ BSTR Name,
    /* [in] */ BSTR bstrCLSID,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarNew);


void __RPC_STUB IHandlers_Add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IHandlers_Delete_Proxy( 
    IHandlers __RPC_FAR * This,
    /* [in] */ BSTR bstrCLSID);


void __RPC_STUB IHandlers_Delete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHandlers_INTERFACE_DEFINED__ */


#ifndef __IHandler_INTERFACE_DEFINED__
#define __IHandler_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IHandler
 * at Fri Mar 27 05:37:32 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][dual][oleautomation][helpstring][uuid][object] */ 



EXTERN_C const IID IID_IHandler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("4AA3F8E4-C6AF-11D0-93E9-00AA0064D470")
    IHandler : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ClassID( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHandlerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IHandler __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IHandler __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IHandler __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IHandler __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IHandler __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IHandler __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IHandler __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )( 
            IHandler __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ClassID )( 
            IHandler __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        END_INTERFACE
    } IHandlerVtbl;

    interface IHandler
    {
        CONST_VTBL struct IHandlerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHandler_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHandler_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHandler_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHandler_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IHandler_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IHandler_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IHandler_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IHandler_get_Name(This,pVal)	\
    (This)->lpVtbl -> get_Name(This,pVal)

#define IHandler_get_ClassID(This,pVal)	\
    (This)->lpVtbl -> get_ClassID(This,pVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IHandler_get_Name_Proxy( 
    IHandler __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IHandler_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IHandler_get_ClassID_Proxy( 
    IHandler __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IHandler_get_ClassID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHandler_INTERFACE_DEFINED__ */


#ifndef __IBoundFolders_INTERFACE_DEFINED__
#define __IBoundFolders_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IBoundFolders
 * at Fri Mar 27 05:37:32 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][dual][oleautomation][helpstring][uuid][object] */ 



EXTERN_C const IID IID_IBoundFolders;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("B0C0F075-DEA0-11d0-84B0-00C04FC2F8DA")
    IBoundFolders : public IDispatch
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ VARIANT varIndex,
            /* [retval][out] */ VARIANT __RPC_FAR *retval) = 0;
        
        virtual /* [restricted][propget][id] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *retval) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBoundFoldersVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IBoundFolders __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IBoundFolders __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IBoundFolders __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IBoundFolders __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IBoundFolders __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IBoundFolders __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IBoundFolders __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            IBoundFolders __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Item )( 
            IBoundFolders __RPC_FAR * This,
            /* [in] */ VARIANT varIndex,
            /* [retval][out] */ VARIANT __RPC_FAR *retval);
        
        /* [restricted][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__NewEnum )( 
            IBoundFolders __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *retval);
        
        END_INTERFACE
    } IBoundFoldersVtbl;

    interface IBoundFolders
    {
        CONST_VTBL struct IBoundFoldersVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBoundFolders_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IBoundFolders_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IBoundFolders_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IBoundFolders_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IBoundFolders_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IBoundFolders_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IBoundFolders_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IBoundFolders_get_Count(This,pVal)	\
    (This)->lpVtbl -> get_Count(This,pVal)

#define IBoundFolders_get_Item(This,varIndex,retval)	\
    (This)->lpVtbl -> get_Item(This,varIndex,retval)

#define IBoundFolders_get__NewEnum(This,retval)	\
    (This)->lpVtbl -> get__NewEnum(This,retval)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget][id] */ HRESULT STDMETHODCALLTYPE IBoundFolders_get_Count_Proxy( 
    IBoundFolders __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IBoundFolders_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE IBoundFolders_get_Item_Proxy( 
    IBoundFolders __RPC_FAR * This,
    /* [in] */ VARIANT varIndex,
    /* [retval][out] */ VARIANT __RPC_FAR *retval);


void __RPC_STUB IBoundFolders_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][propget][id] */ HRESULT STDMETHODCALLTYPE IBoundFolders_get__NewEnum_Proxy( 
    IBoundFolders __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *retval);


void __RPC_STUB IBoundFolders_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IBoundFolders_INTERFACE_DEFINED__ */


#ifndef __IBoundFolder_INTERFACE_DEFINED__
#define __IBoundFolder_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IBoundFolder
 * at Fri Mar 27 05:37:32 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][dual][oleautomation][helpstring][uuid][object] */ 



EXTERN_C const IID IID_IBoundFolder;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("B0C0F074-DEA0-11d0-84B0-00C04FC2F8DA")
    IBoundFolder : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_HostName( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_EntryID( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MDBEntryID( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Bindings( 
            /* [retval][out] */ VARIANT __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_EventMask( 
            /* [retval][out] */ ULONG __RPC_FAR *pl) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Access( 
            /* [retval][out] */ ULONG __RPC_FAR *pl) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ScheduleCount( 
            /* [retval][out] */ ULONG __RPC_FAR *pl) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SaveChanges( void) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_EntryID2( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBoundFolderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IBoundFolder __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IBoundFolder __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IBoundFolder __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IBoundFolder __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IBoundFolder __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IBoundFolder __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IBoundFolder __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_HostName )( 
            IBoundFolder __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_EntryID )( 
            IBoundFolder __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_MDBEntryID )( 
            IBoundFolder __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Bindings )( 
            IBoundFolder __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_EventMask )( 
            IBoundFolder __RPC_FAR * This,
            /* [retval][out] */ ULONG __RPC_FAR *pl);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Access )( 
            IBoundFolder __RPC_FAR * This,
            /* [retval][out] */ ULONG __RPC_FAR *pl);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ScheduleCount )( 
            IBoundFolder __RPC_FAR * This,
            /* [retval][out] */ ULONG __RPC_FAR *pl);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SaveChanges )( 
            IBoundFolder __RPC_FAR * This);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_EntryID2 )( 
            IBoundFolder __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        END_INTERFACE
    } IBoundFolderVtbl;

    interface IBoundFolder
    {
        CONST_VTBL struct IBoundFolderVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBoundFolder_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IBoundFolder_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IBoundFolder_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IBoundFolder_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IBoundFolder_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IBoundFolder_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IBoundFolder_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IBoundFolder_get_HostName(This,pVal)	\
    (This)->lpVtbl -> get_HostName(This,pVal)

#define IBoundFolder_get_EntryID(This,pVal)	\
    (This)->lpVtbl -> get_EntryID(This,pVal)

#define IBoundFolder_get_MDBEntryID(This,pVal)	\
    (This)->lpVtbl -> get_MDBEntryID(This,pVal)

#define IBoundFolder_get_Bindings(This,pVal)	\
    (This)->lpVtbl -> get_Bindings(This,pVal)

#define IBoundFolder_get_EventMask(This,pl)	\
    (This)->lpVtbl -> get_EventMask(This,pl)

#define IBoundFolder_get_Access(This,pl)	\
    (This)->lpVtbl -> get_Access(This,pl)

#define IBoundFolder_get_ScheduleCount(This,pl)	\
    (This)->lpVtbl -> get_ScheduleCount(This,pl)

#define IBoundFolder_SaveChanges(This)	\
    (This)->lpVtbl -> SaveChanges(This)

#define IBoundFolder_get_EntryID2(This,pVal)	\
    (This)->lpVtbl -> get_EntryID2(This,pVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IBoundFolder_get_HostName_Proxy( 
    IBoundFolder __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IBoundFolder_get_HostName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IBoundFolder_get_EntryID_Proxy( 
    IBoundFolder __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IBoundFolder_get_EntryID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IBoundFolder_get_MDBEntryID_Proxy( 
    IBoundFolder __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IBoundFolder_get_MDBEntryID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IBoundFolder_get_Bindings_Proxy( 
    IBoundFolder __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pVal);


void __RPC_STUB IBoundFolder_get_Bindings_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IBoundFolder_get_EventMask_Proxy( 
    IBoundFolder __RPC_FAR * This,
    /* [retval][out] */ ULONG __RPC_FAR *pl);


void __RPC_STUB IBoundFolder_get_EventMask_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IBoundFolder_get_Access_Proxy( 
    IBoundFolder __RPC_FAR * This,
    /* [retval][out] */ ULONG __RPC_FAR *pl);


void __RPC_STUB IBoundFolder_get_Access_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IBoundFolder_get_ScheduleCount_Proxy( 
    IBoundFolder __RPC_FAR * This,
    /* [retval][out] */ ULONG __RPC_FAR *pl);


void __RPC_STUB IBoundFolder_get_ScheduleCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IBoundFolder_SaveChanges_Proxy( 
    IBoundFolder __RPC_FAR * This);


void __RPC_STUB IBoundFolder_SaveChanges_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IBoundFolder_get_EntryID2_Proxy( 
    IBoundFolder __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IBoundFolder_get_EntryID2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IBoundFolder_INTERFACE_DEFINED__ */


#ifndef __IEventBindings_INTERFACE_DEFINED__
#define __IEventBindings_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEventBindings
 * at Fri Mar 27 05:37:32 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][dual][oleautomation][helpstring][uuid][object] */ 



EXTERN_C const IID IID_IEventBindings;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("2F42C694-C6A4-11D0-93E9-00AA0064D470")
    IEventBindings : public IDispatch
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ VARIANT varIndex,
            /* [retval][out] */ VARIANT __RPC_FAR *retval) = 0;
        
        virtual /* [restricted][propget][id] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *retval) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Add( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvarNewBinding) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Delete( 
            /* [in] */ VARIANT varItem) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Clone( 
            /* [in] */ VARIANT varItem,
            /* [retval][out] */ VARIANT __RPC_FAR *varNewCopy) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEventBindingsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEventBindings __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEventBindings __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEventBindings __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IEventBindings __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IEventBindings __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IEventBindings __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IEventBindings __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            IEventBindings __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Item )( 
            IEventBindings __RPC_FAR * This,
            /* [in] */ VARIANT varIndex,
            /* [retval][out] */ VARIANT __RPC_FAR *retval);
        
        /* [restricted][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__NewEnum )( 
            IEventBindings __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Add )( 
            IEventBindings __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarNewBinding);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Delete )( 
            IEventBindings __RPC_FAR * This,
            /* [in] */ VARIANT varItem);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEventBindings __RPC_FAR * This,
            /* [in] */ VARIANT varItem,
            /* [retval][out] */ VARIANT __RPC_FAR *varNewCopy);
        
        END_INTERFACE
    } IEventBindingsVtbl;

    interface IEventBindings
    {
        CONST_VTBL struct IEventBindingsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEventBindings_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEventBindings_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEventBindings_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEventBindings_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IEventBindings_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IEventBindings_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IEventBindings_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IEventBindings_get_Count(This,pVal)	\
    (This)->lpVtbl -> get_Count(This,pVal)

#define IEventBindings_get_Item(This,varIndex,retval)	\
    (This)->lpVtbl -> get_Item(This,varIndex,retval)

#define IEventBindings_get__NewEnum(This,retval)	\
    (This)->lpVtbl -> get__NewEnum(This,retval)

#define IEventBindings_Add(This,pvarNewBinding)	\
    (This)->lpVtbl -> Add(This,pvarNewBinding)

#define IEventBindings_Delete(This,varItem)	\
    (This)->lpVtbl -> Delete(This,varItem)

#define IEventBindings_Clone(This,varItem,varNewCopy)	\
    (This)->lpVtbl -> Clone(This,varItem,varNewCopy)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget][id] */ HRESULT STDMETHODCALLTYPE IEventBindings_get_Count_Proxy( 
    IEventBindings __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IEventBindings_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE IEventBindings_get_Item_Proxy( 
    IEventBindings __RPC_FAR * This,
    /* [in] */ VARIANT varIndex,
    /* [retval][out] */ VARIANT __RPC_FAR *retval);


void __RPC_STUB IEventBindings_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][propget][id] */ HRESULT STDMETHODCALLTYPE IEventBindings_get__NewEnum_Proxy( 
    IEventBindings __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *retval);


void __RPC_STUB IEventBindings_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IEventBindings_Add_Proxy( 
    IEventBindings __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarNewBinding);


void __RPC_STUB IEventBindings_Add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IEventBindings_Delete_Proxy( 
    IEventBindings __RPC_FAR * This,
    /* [in] */ VARIANT varItem);


void __RPC_STUB IEventBindings_Delete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IEventBindings_Clone_Proxy( 
    IEventBindings __RPC_FAR * This,
    /* [in] */ VARIANT varItem,
    /* [retval][out] */ VARIANT __RPC_FAR *varNewCopy);


void __RPC_STUB IEventBindings_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEventBindings_INTERFACE_DEFINED__ */


#ifndef __IEventBinding_INTERFACE_DEFINED__
#define __IEventBinding_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEventBinding
 * at Fri Mar 27 05:37:32 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][dual][oleautomation][helpstring][uuid][object] */ 



EXTERN_C const IID IID_IEventBinding;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("2F42C697-C6A4-11D0-93E9-00AA0064D470")
    IEventBinding : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_HandlerClassID( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_HandlerClassID( 
            /* [in] */ BSTR bstrVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Handler( 
            /* [in] */ VARIANT newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Name( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Priority( 
            /* [retval][out] */ ULONG __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Priority( 
            /* [in] */ ULONG newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Active( 
            /* [retval][out] */ BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Active( 
            /* [in] */ BOOL newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CustomProperty( 
            /* [in] */ VARIANT varPropId,
            /* [retval][out] */ VARIANT __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_CustomProperty( 
            /* [in] */ VARIANT varPropId,
            /* [in] */ VARIANT newVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SaveChanges( void) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_EventMask( 
            /* [retval][out] */ ULONG __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_EventMask( 
            /* [in] */ ULONG newVal) = 0;
        
        virtual /* [helpstring][restricted][hidden][id][propget] */ HRESULT STDMETHODCALLTYPE get_MAPIOBJECT( 
            /* [retval][out] */ VARIANT __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Schedule( 
            /* [retval][out] */ VARIANT __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_EntryID( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CreationTime( 
            /* [retval][out] */ VARIANT __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Access( 
            /* [retval][out] */ ULONG __RPC_FAR *plAccess) = 0;
        
        virtual /* [helpstring][restricted][hidden][id][propget] */ HRESULT STDMETHODCALLTYPE get_MAPIOBJECT2( 
            /* [retval][out] */ VARIANT __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SaveCustomChanges( 
            /* [in] */ VARIANT varMAPIOBJECT) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_EntryID2( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_EntryID3( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][restricted][hidden][id][propget] */ HRESULT STDMETHODCALLTYPE get_MAPIOBJECT3( 
            /* [retval][out] */ VARIANT __RPC_FAR *pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEventBindingVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEventBinding __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEventBinding __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEventBinding __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IEventBinding __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IEventBinding __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IEventBinding __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IEventBinding __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_HandlerClassID )( 
            IEventBinding __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_HandlerClassID )( 
            IEventBinding __RPC_FAR * This,
            /* [in] */ BSTR bstrVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Handler )( 
            IEventBinding __RPC_FAR * This,
            /* [in] */ VARIANT newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )( 
            IEventBinding __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Name )( 
            IEventBinding __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Priority )( 
            IEventBinding __RPC_FAR * This,
            /* [retval][out] */ ULONG __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Priority )( 
            IEventBinding __RPC_FAR * This,
            /* [in] */ ULONG newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Active )( 
            IEventBinding __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Active )( 
            IEventBinding __RPC_FAR * This,
            /* [in] */ BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CustomProperty )( 
            IEventBinding __RPC_FAR * This,
            /* [in] */ VARIANT varPropId,
            /* [retval][out] */ VARIANT __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_CustomProperty )( 
            IEventBinding __RPC_FAR * This,
            /* [in] */ VARIANT varPropId,
            /* [in] */ VARIANT newVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SaveChanges )( 
            IEventBinding __RPC_FAR * This);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_EventMask )( 
            IEventBinding __RPC_FAR * This,
            /* [retval][out] */ ULONG __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_EventMask )( 
            IEventBinding __RPC_FAR * This,
            /* [in] */ ULONG newVal);
        
        /* [helpstring][restricted][hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_MAPIOBJECT )( 
            IEventBinding __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Schedule )( 
            IEventBinding __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_EntryID )( 
            IEventBinding __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CreationTime )( 
            IEventBinding __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Access )( 
            IEventBinding __RPC_FAR * This,
            /* [retval][out] */ ULONG __RPC_FAR *plAccess);
        
        /* [helpstring][restricted][hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_MAPIOBJECT2 )( 
            IEventBinding __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SaveCustomChanges )( 
            IEventBinding __RPC_FAR * This,
            /* [in] */ VARIANT varMAPIOBJECT);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_EntryID2 )( 
            IEventBinding __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_EntryID3 )( 
            IEventBinding __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][restricted][hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_MAPIOBJECT3 )( 
            IEventBinding __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pVal);
        
        END_INTERFACE
    } IEventBindingVtbl;

    interface IEventBinding
    {
        CONST_VTBL struct IEventBindingVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEventBinding_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEventBinding_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEventBinding_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEventBinding_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IEventBinding_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IEventBinding_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IEventBinding_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IEventBinding_get_HandlerClassID(This,pbstrVal)	\
    (This)->lpVtbl -> get_HandlerClassID(This,pbstrVal)

#define IEventBinding_put_HandlerClassID(This,bstrVal)	\
    (This)->lpVtbl -> put_HandlerClassID(This,bstrVal)

#define IEventBinding_put_Handler(This,newVal)	\
    (This)->lpVtbl -> put_Handler(This,newVal)

#define IEventBinding_get_Name(This,pVal)	\
    (This)->lpVtbl -> get_Name(This,pVal)

#define IEventBinding_put_Name(This,newVal)	\
    (This)->lpVtbl -> put_Name(This,newVal)

#define IEventBinding_get_Priority(This,pVal)	\
    (This)->lpVtbl -> get_Priority(This,pVal)

#define IEventBinding_put_Priority(This,newVal)	\
    (This)->lpVtbl -> put_Priority(This,newVal)

#define IEventBinding_get_Active(This,pVal)	\
    (This)->lpVtbl -> get_Active(This,pVal)

#define IEventBinding_put_Active(This,newVal)	\
    (This)->lpVtbl -> put_Active(This,newVal)

#define IEventBinding_get_CustomProperty(This,varPropId,pVal)	\
    (This)->lpVtbl -> get_CustomProperty(This,varPropId,pVal)

#define IEventBinding_put_CustomProperty(This,varPropId,newVal)	\
    (This)->lpVtbl -> put_CustomProperty(This,varPropId,newVal)

#define IEventBinding_SaveChanges(This)	\
    (This)->lpVtbl -> SaveChanges(This)

#define IEventBinding_get_EventMask(This,pVal)	\
    (This)->lpVtbl -> get_EventMask(This,pVal)

#define IEventBinding_put_EventMask(This,newVal)	\
    (This)->lpVtbl -> put_EventMask(This,newVal)

#define IEventBinding_get_MAPIOBJECT(This,pVal)	\
    (This)->lpVtbl -> get_MAPIOBJECT(This,pVal)

#define IEventBinding_get_Schedule(This,pVal)	\
    (This)->lpVtbl -> get_Schedule(This,pVal)

#define IEventBinding_get_EntryID(This,pVal)	\
    (This)->lpVtbl -> get_EntryID(This,pVal)

#define IEventBinding_get_CreationTime(This,pVal)	\
    (This)->lpVtbl -> get_CreationTime(This,pVal)

#define IEventBinding_get_Access(This,plAccess)	\
    (This)->lpVtbl -> get_Access(This,plAccess)

#define IEventBinding_get_MAPIOBJECT2(This,pVal)	\
    (This)->lpVtbl -> get_MAPIOBJECT2(This,pVal)

#define IEventBinding_SaveCustomChanges(This,varMAPIOBJECT)	\
    (This)->lpVtbl -> SaveCustomChanges(This,varMAPIOBJECT)

#define IEventBinding_get_EntryID2(This,pVal)	\
    (This)->lpVtbl -> get_EntryID2(This,pVal)

#define IEventBinding_get_EntryID3(This,pVal)	\
    (This)->lpVtbl -> get_EntryID3(This,pVal)

#define IEventBinding_get_MAPIOBJECT3(This,pVal)	\
    (This)->lpVtbl -> get_MAPIOBJECT3(This,pVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IEventBinding_get_HandlerClassID_Proxy( 
    IEventBinding __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrVal);


void __RPC_STUB IEventBinding_get_HandlerClassID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IEventBinding_put_HandlerClassID_Proxy( 
    IEventBinding __RPC_FAR * This,
    /* [in] */ BSTR bstrVal);


void __RPC_STUB IEventBinding_put_HandlerClassID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IEventBinding_put_Handler_Proxy( 
    IEventBinding __RPC_FAR * This,
    /* [in] */ VARIANT newVal);


void __RPC_STUB IEventBinding_put_Handler_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IEventBinding_get_Name_Proxy( 
    IEventBinding __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IEventBinding_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IEventBinding_put_Name_Proxy( 
    IEventBinding __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IEventBinding_put_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IEventBinding_get_Priority_Proxy( 
    IEventBinding __RPC_FAR * This,
    /* [retval][out] */ ULONG __RPC_FAR *pVal);


void __RPC_STUB IEventBinding_get_Priority_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IEventBinding_put_Priority_Proxy( 
    IEventBinding __RPC_FAR * This,
    /* [in] */ ULONG newVal);


void __RPC_STUB IEventBinding_put_Priority_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IEventBinding_get_Active_Proxy( 
    IEventBinding __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pVal);


void __RPC_STUB IEventBinding_get_Active_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IEventBinding_put_Active_Proxy( 
    IEventBinding __RPC_FAR * This,
    /* [in] */ BOOL newVal);


void __RPC_STUB IEventBinding_put_Active_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IEventBinding_get_CustomProperty_Proxy( 
    IEventBinding __RPC_FAR * This,
    /* [in] */ VARIANT varPropId,
    /* [retval][out] */ VARIANT __RPC_FAR *pVal);


void __RPC_STUB IEventBinding_get_CustomProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IEventBinding_put_CustomProperty_Proxy( 
    IEventBinding __RPC_FAR * This,
    /* [in] */ VARIANT varPropId,
    /* [in] */ VARIANT newVal);


void __RPC_STUB IEventBinding_put_CustomProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IEventBinding_SaveChanges_Proxy( 
    IEventBinding __RPC_FAR * This);


void __RPC_STUB IEventBinding_SaveChanges_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IEventBinding_get_EventMask_Proxy( 
    IEventBinding __RPC_FAR * This,
    /* [retval][out] */ ULONG __RPC_FAR *pVal);


void __RPC_STUB IEventBinding_get_EventMask_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IEventBinding_put_EventMask_Proxy( 
    IEventBinding __RPC_FAR * This,
    /* [in] */ ULONG newVal);


void __RPC_STUB IEventBinding_put_EventMask_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][restricted][hidden][id][propget] */ HRESULT STDMETHODCALLTYPE IEventBinding_get_MAPIOBJECT_Proxy( 
    IEventBinding __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pVal);


void __RPC_STUB IEventBinding_get_MAPIOBJECT_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IEventBinding_get_Schedule_Proxy( 
    IEventBinding __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pVal);


void __RPC_STUB IEventBinding_get_Schedule_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IEventBinding_get_EntryID_Proxy( 
    IEventBinding __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IEventBinding_get_EntryID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IEventBinding_get_CreationTime_Proxy( 
    IEventBinding __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pVal);


void __RPC_STUB IEventBinding_get_CreationTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IEventBinding_get_Access_Proxy( 
    IEventBinding __RPC_FAR * This,
    /* [retval][out] */ ULONG __RPC_FAR *plAccess);


void __RPC_STUB IEventBinding_get_Access_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][restricted][hidden][id][propget] */ HRESULT STDMETHODCALLTYPE IEventBinding_get_MAPIOBJECT2_Proxy( 
    IEventBinding __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pVal);


void __RPC_STUB IEventBinding_get_MAPIOBJECT2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IEventBinding_SaveCustomChanges_Proxy( 
    IEventBinding __RPC_FAR * This,
    /* [in] */ VARIANT varMAPIOBJECT);


void __RPC_STUB IEventBinding_SaveCustomChanges_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IEventBinding_get_EntryID2_Proxy( 
    IEventBinding __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IEventBinding_get_EntryID2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IEventBinding_get_EntryID3_Proxy( 
    IEventBinding __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IEventBinding_get_EntryID3_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][restricted][hidden][id][propget] */ HRESULT STDMETHODCALLTYPE IEventBinding_get_MAPIOBJECT3_Proxy( 
    IEventBinding __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pVal);


void __RPC_STUB IEventBinding_get_MAPIOBJECT3_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEventBinding_INTERFACE_DEFINED__ */


#ifndef __ISchedule_INTERFACE_DEFINED__
#define __ISchedule_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ISchedule
 * at Fri Mar 27 05:37:32 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][dual][oleautomation][helpstring][uuid][object] */ 



EXTERN_C const IID IID_ISchedule;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("2F42C699-C6A4-11D0-93E9-00AA0064D470")
    ISchedule : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Interval( 
            /* [retval][out] */ ULONG __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Interval( 
            /* [in] */ ULONG newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Days( 
            /* [retval][out] */ ULONG __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Days( 
            /* [in] */ ULONG newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_At( 
            /* [retval][out] */ DATE __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_At( 
            /* [in] */ DATE newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_StartTime( 
            /* [retval][out] */ DATE __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_StartTime( 
            /* [in] */ DATE newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_EndTime( 
            /* [retval][out] */ DATE __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_EndTime( 
            /* [in] */ DATE newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Type( 
            /* [retval][out] */ ULONG __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Type( 
            /* [in] */ ULONG newVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Clear( void) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Bitmap( 
            /* [retval][out] */ VARIANT __RPC_FAR *pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IScheduleVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISchedule __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISchedule __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISchedule __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ISchedule __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ISchedule __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ISchedule __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ISchedule __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Interval )( 
            ISchedule __RPC_FAR * This,
            /* [retval][out] */ ULONG __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Interval )( 
            ISchedule __RPC_FAR * This,
            /* [in] */ ULONG newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Days )( 
            ISchedule __RPC_FAR * This,
            /* [retval][out] */ ULONG __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Days )( 
            ISchedule __RPC_FAR * This,
            /* [in] */ ULONG newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_At )( 
            ISchedule __RPC_FAR * This,
            /* [retval][out] */ DATE __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_At )( 
            ISchedule __RPC_FAR * This,
            /* [in] */ DATE newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StartTime )( 
            ISchedule __RPC_FAR * This,
            /* [retval][out] */ DATE __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_StartTime )( 
            ISchedule __RPC_FAR * This,
            /* [in] */ DATE newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_EndTime )( 
            ISchedule __RPC_FAR * This,
            /* [retval][out] */ DATE __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_EndTime )( 
            ISchedule __RPC_FAR * This,
            /* [in] */ DATE newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Type )( 
            ISchedule __RPC_FAR * This,
            /* [retval][out] */ ULONG __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Type )( 
            ISchedule __RPC_FAR * This,
            /* [in] */ ULONG newVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clear )( 
            ISchedule __RPC_FAR * This);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Bitmap )( 
            ISchedule __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pVal);
        
        END_INTERFACE
    } IScheduleVtbl;

    interface ISchedule
    {
        CONST_VTBL struct IScheduleVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISchedule_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISchedule_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISchedule_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISchedule_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ISchedule_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ISchedule_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ISchedule_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ISchedule_get_Interval(This,pVal)	\
    (This)->lpVtbl -> get_Interval(This,pVal)

#define ISchedule_put_Interval(This,newVal)	\
    (This)->lpVtbl -> put_Interval(This,newVal)

#define ISchedule_get_Days(This,pVal)	\
    (This)->lpVtbl -> get_Days(This,pVal)

#define ISchedule_put_Days(This,newVal)	\
    (This)->lpVtbl -> put_Days(This,newVal)

#define ISchedule_get_At(This,pVal)	\
    (This)->lpVtbl -> get_At(This,pVal)

#define ISchedule_put_At(This,newVal)	\
    (This)->lpVtbl -> put_At(This,newVal)

#define ISchedule_get_StartTime(This,pVal)	\
    (This)->lpVtbl -> get_StartTime(This,pVal)

#define ISchedule_put_StartTime(This,newVal)	\
    (This)->lpVtbl -> put_StartTime(This,newVal)

#define ISchedule_get_EndTime(This,pVal)	\
    (This)->lpVtbl -> get_EndTime(This,pVal)

#define ISchedule_put_EndTime(This,newVal)	\
    (This)->lpVtbl -> put_EndTime(This,newVal)

#define ISchedule_get_Type(This,pVal)	\
    (This)->lpVtbl -> get_Type(This,pVal)

#define ISchedule_put_Type(This,newVal)	\
    (This)->lpVtbl -> put_Type(This,newVal)

#define ISchedule_Clear(This)	\
    (This)->lpVtbl -> Clear(This)

#define ISchedule_get_Bitmap(This,pVal)	\
    (This)->lpVtbl -> get_Bitmap(This,pVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ISchedule_get_Interval_Proxy( 
    ISchedule __RPC_FAR * This,
    /* [retval][out] */ ULONG __RPC_FAR *pVal);


void __RPC_STUB ISchedule_get_Interval_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE ISchedule_put_Interval_Proxy( 
    ISchedule __RPC_FAR * This,
    /* [in] */ ULONG newVal);


void __RPC_STUB ISchedule_put_Interval_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ISchedule_get_Days_Proxy( 
    ISchedule __RPC_FAR * This,
    /* [retval][out] */ ULONG __RPC_FAR *pVal);


void __RPC_STUB ISchedule_get_Days_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE ISchedule_put_Days_Proxy( 
    ISchedule __RPC_FAR * This,
    /* [in] */ ULONG newVal);


void __RPC_STUB ISchedule_put_Days_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ISchedule_get_At_Proxy( 
    ISchedule __RPC_FAR * This,
    /* [retval][out] */ DATE __RPC_FAR *pVal);


void __RPC_STUB ISchedule_get_At_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE ISchedule_put_At_Proxy( 
    ISchedule __RPC_FAR * This,
    /* [in] */ DATE newVal);


void __RPC_STUB ISchedule_put_At_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ISchedule_get_StartTime_Proxy( 
    ISchedule __RPC_FAR * This,
    /* [retval][out] */ DATE __RPC_FAR *pVal);


void __RPC_STUB ISchedule_get_StartTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE ISchedule_put_StartTime_Proxy( 
    ISchedule __RPC_FAR * This,
    /* [in] */ DATE newVal);


void __RPC_STUB ISchedule_put_StartTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ISchedule_get_EndTime_Proxy( 
    ISchedule __RPC_FAR * This,
    /* [retval][out] */ DATE __RPC_FAR *pVal);


void __RPC_STUB ISchedule_get_EndTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE ISchedule_put_EndTime_Proxy( 
    ISchedule __RPC_FAR * This,
    /* [in] */ DATE newVal);


void __RPC_STUB ISchedule_put_EndTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ISchedule_get_Type_Proxy( 
    ISchedule __RPC_FAR * This,
    /* [retval][out] */ ULONG __RPC_FAR *pVal);


void __RPC_STUB ISchedule_get_Type_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE ISchedule_put_Type_Proxy( 
    ISchedule __RPC_FAR * This,
    /* [in] */ ULONG newVal);


void __RPC_STUB ISchedule_put_Type_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISchedule_Clear_Proxy( 
    ISchedule __RPC_FAR * This);


void __RPC_STUB ISchedule_Clear_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ISchedule_get_Bitmap_Proxy( 
    ISchedule __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pVal);


void __RPC_STUB ISchedule_get_Bitmap_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISchedule_INTERFACE_DEFINED__ */



#ifndef __ESCONFIGLib_LIBRARY_DEFINED__
#define __ESCONFIGLib_LIBRARY_DEFINED__

/****************************************
 * Generated header for library: ESCONFIGLib
 * at Fri Mar 27 05:37:32 1998
 * using MIDL 3.01.75
 ****************************************/
/* [helpstring][version][uuid] */ 


typedef 
enum _EventMask
    {	ESEM_None	= 0,
	ESEM_ScheduledEvents	= 0x1,
	ESEM_NewItemEvents	= 0x2,
	ESEM_ChangedItemEvents	= 0x4,
	ESEM_DeletedItemEvents	= 0x8,
	ESEM_AllEvents	= 0xffff
    }	_EventMask;

typedef 
enum _ScheduleResolution
    {	ES_Resolution_Unknown	= 0,
	ES_Resolution_15Min	= ES_Resolution_Unknown + 1,
	ES_Resolution_1Hour	= ES_Resolution_15Min + 1
    }	_ScheduleResolution;

typedef 
enum _ScheduleDays
    {	ES_DOW_None	= 0,
	ES_DOW_Monday	= 0x1,
	ES_DOW_Tuesday	= 0x2,
	ES_DOW_Wednesday	= 0x4,
	ES_DOW_Thursday	= 0x8,
	ES_DOW_Friday	= 0x10,
	ES_DOW_Saturday	= 0x20,
	ES_DOW_Sunday	= 0x40,
	ES_DOW_Daily	= 0x7f
    }	_ScheduleDays;

typedef 
enum _ScheduleType
    {	ES_ScheduleTypeUnknown	= 0,
	ES_ScheduleTypeHourly	= ES_ScheduleTypeUnknown + 1,
	ES_ScheduleTypeDaily	= ES_ScheduleTypeHourly + 1,
	ES_ScheduleTypeWeekly	= ES_ScheduleTypeDaily + 1
    }	_ScheduleType;











EXTERN_C const IID LIBID_ESCONFIGLib;

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_Events;

class DECLSPEC_UUID("2F42C693-C6A4-11D0-93E9-00AA0064D470")
Events;
#endif
#endif /* __ESCONFIGLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long __RPC_FAR *, unsigned long            , VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long __RPC_FAR *, VARIANT __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\evntrace.h ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    EvnTrace.h

Abstract:

    Public headers for event tracing control applications,
    consumers and providers

Author:

    15-Sep-1997 JeePang

Revision History:

--*/

#ifndef _EVNTRACE_
#define _EVNTRACE_

#if defined(_WINNT_) || defined(WINNT)
#ifndef WMIAPI
#ifndef MIDL_PASS
#ifdef _WMI_SOURCE_
#define WMIAPI __stdcall
#else
#define WMIAPI DECLSPEC_IMPORT __stdcall
#endif // _WMI_SOURCE
#endif // MIDL_PASS

#endif // WMIAPI

#include <guiddef.h>

//
// EventTraceGuid is used to identify a event tracing session
//
DEFINE_GUID ( /* 68fdd900-4a3e-11d1-84f4-0000f80464e3 */
    EventTraceGuid,
    0x68fdd900,
    0x4a3e,
    0x11d1,
    0x84, 0xf4, 0x00, 0x00, 0xf8, 0x04, 0x64, 0xe3
  );

//
// SystemTraceControlGuid. Used to specify event tracing for kernel
//
DEFINE_GUID ( /* 9e814aad-3204-11d2-9a82-006008a86939 */
    SystemTraceControlGuid,
    0x9e814aad,
    0x3204,
    0x11d2,
    0x9a, 0x82, 0x00, 0x60, 0x08, 0xa8, 0x69, 0x39
  );


#define MAX_MOF_FIELDS                      16  // Limit of USE_MOF_PTR fields
typedef ULONG64 TRACEHANDLE, *PTRACEHANDLE;

typedef struct _TRACE_ENABLE_CONTEXT {
    USHORT  LoggerId;           // Actual Id of the logger
    UCHAR   Level;              // Enable level passed by control caller
    UCHAR   InternalFlag;       // Reserved
    ULONG   EnableFlags;        // Enable flags passed by control caller
} TRACE_ENABLE_CONTEXT, *PTRACE_ENABLE_CONTEXT;

//
// predefined generic event types (0x00 to 0x09 reserved).
//

#define EVENT_TRACE_TYPE_INFO               0x00  // Info or point event
#define EVENT_TRACE_TYPE_START              0x01  // Start event
#define EVENT_TRACE_TYPE_END                0x02  // End event
#define EVENT_TRACE_TYPE_DC_START           0x03  // Collection start marker
#define EVENT_TRACE_TYPE_DC_END             0x04  // Collection end marker
#define EVENT_TRACE_TYPE_EXTENSION          0x05  // Extension/continuation
#define EVENT_TRACE_TYPE_REPLY              0x06  // Reply event
#define EVENT_TRACE_TYPE_DEQUEUE            0x07  // De-queue event
#define EVENT_TRACE_TYPE_CHECKPOINT         0x08  // Generic checkpoint event
#define EVENT_TRACE_TYPE_RESERVED9          0x09

//
// Event types for Process & Threads
//

#define EVENT_TRACE_TYPE_LOAD                  0x0A      // Load image

//
// Event types for IO subsystem
//

#define EVENT_TRACE_TYPE_IO_READ               0x0A
#define EVENT_TRACE_TYPE_IO_WRITE              0x0B

//
// Event types for Memory subsystem
//

#define EVENT_TRACE_TYPE_MM_TF                 0x0A      // Transition fault
#define EVENT_TRACE_TYPE_MM_DZF                0x0B      // Demand Zero fault
#define EVENT_TRACE_TYPE_MM_COW                0x0C      // Copy on Write
#define EVENT_TRACE_TYPE_MM_GPF                0x0D      // Guard Page fault
#define EVENT_TRACE_TYPE_MM_HPF                0x0E      // Hard page fault

//
// Event types for Network subsystem, all protocols
//

#define EVENT_TRACE_TYPE_SEND                  0x0A     // Send
#define EVENT_TRACE_TYPE_RECEIVE               0x0B     // Receive
#define EVENT_TRACE_TYPE_CONNECT               0x0C     // Connect
#define EVENT_TRACE_TYPE_DISCONNECT            0x0D     // Disconnect

//
// Event Types for the Header (to handle internal event headers)
//

#define EVENT_TRACE_TYPE_GUIDMAP                0x0A
#define EVENT_TRACE_TYPE_CONFIG                 0x0B
#define EVENT_TRACE_TYPE_SIDINFO                0x0C
#define EVENT_TRACE_TYPE_SECURITY               0x0D

//
// Event types for Registry subsystem
//

#define EVENT_TRACE_TYPE_REGCREATE              0x0A     // NtCreateKey
#define EVENT_TRACE_TYPE_REGOPEN                0x0B     // NtOpenKey
#define EVENT_TRACE_TYPE_REGDELETE              0x0C     // NtDeleteKey
#define EVENT_TRACE_TYPE_REGQUERY               0x0D     // NtQueryKey
#define EVENT_TRACE_TYPE_REGSETVALUE            0x0E     // NtSetValueKey
#define EVENT_TRACE_TYPE_REGDELETEVALUE         0x0F     // NtDeleteValueKey
#define EVENT_TRACE_TYPE_REGQUERYVALUE          0x10     // NtQueryValueKey
#define EVENT_TRACE_TYPE_REGENUMERATEKEY        0x11     // NtEnumerateKey
#define EVENT_TRACE_TYPE_REGENUMERATEVALUEKEY   0x12     // NtEnumerateValueKey
#define EVENT_TRACE_TYPE_REGQUERYMULTIPLEVALUE  0x13     // NtQueryMultipleValueKey
#define EVENT_TRACE_TYPE_REGSETINFORMATION      0x14     // NtSetInformationKey
#define EVENT_TRACE_TYPE_REGFLUSH               0x15     // NtFlushKey

//
// Enable flags for SystemControlGuid only
//
#define EVENT_TRACE_FLAG_PROCESS            0x00000001  // process start & end
#define EVENT_TRACE_FLAG_THREAD             0x00000002  // thread start & end
#define EVENT_TRACE_FLAG_IMAGE_LOAD         0x00000004  // image load

#define EVENT_TRACE_FLAG_DISK_IO            0x00000100  // physical disk IO
#define EVENT_TRACE_FLAG_DISK_FILE_IO       0x00000200  // requires disk IO

#define EVENT_TRACE_FLAG_MEMORY_PAGE_FAULTS 0x00001000  // all page faults
#define EVENT_TRACE_FLAG_MEMORY_HARD_FAULTS 0x00002000  // hard faults only

#define EVENT_TRACE_FLAG_NETWORK_TCPIP      0x00010000  // tcpip send & receive

#define EVENT_TRACE_FLAG_REGISTRY           0x00020000  // registry calls

//
// Pre-defined Enable flags for everybody else
//
#define EVENT_TRACE_FLAG_EXTENSION          0x80000000  // indicates more flags
#define EVENT_TRACE_FLAG_FORWARD_WMI        0x40000000  // Can forward to WMI
#define EVENT_TRACE_FLAG_ENABLE_RESERVE     0x20000000  // Reserved

//
// Logfile flags
//

#define EVENT_TRACE_FILE_MODE_NONE          0x0000  // logfile is off
#define EVENT_TRACE_FILE_MODE_SEQUENTIAL    0x0001  // log sequentially
#define EVENT_TRACE_FILE_MODE_CIRCULAR      0x0002  // log in circular manner

#define EVENT_TRACE_REAL_TIME_MODE          0x0100  // real time mode on
#define EVENT_TRACE_DELAY_OPEN_FILE_MODE    0x0200  // delay opening file
#define EVENT_TRACE_BUFFERING_MODE          0x0400  // buffering mode only
#define EVENT_TRACE_PRIVATE_LOGGER_MODE     0x0800  // Process Private Logger
#define EVENT_TRACE_ADD_HEADER_MODE         0x1000  // Add a logfile header

//
// internal control codes used.
//
#define EVENT_TRACE_CONTROL_QUERY           0
#define EVENT_TRACE_CONTROL_STOP            1
#define EVENT_TRACE_CONTROL_UPDATE          2

//
// Trace header for all (except kernel) events. This is used to overlay
// to bottom part of WNODE_HEADER to conserve space.
//

typedef struct _EVENT_TRACE_HEADER {    // overlays WNODE_HEADER
    USHORT          Size;                   // Size of entire record
    UCHAR           HeaderType;             // Header type - internal use only
    UCHAR           MarkerFlags;            // Marker - internal use only
    union {
        ULONG       Version;
        struct {
            UCHAR   Type;                   // event type
            UCHAR   Level;                  // trace instrumentation level
            USHORT  Version;                // version of trace record
        } Class;
    };
    ULONGLONG       ThreadId;               // thread Id responsible
    LARGE_INTEGER   TimeStamp;              // time when event happens
    union {
        GUID        Guid;                   // Guid that identifies event
        ULONGLONG   GuidPtr;                // use with WNODE_FLAG_USE_GUID_PTR
    };
    union {
        struct {
            ULONG   ClientContext;          // Reserved
            ULONG   Flags;                  // Flags for header
        };
        struct {
            ULONG   KernelTime;             // Kernel Mode CPU ticks
            ULONG   UserTime;               // User mode CPU ticks
        };
        ULONG64     ProcessorTime;          // Processor Clock
    };
} EVENT_TRACE_HEADER, *PEVENT_TRACE_HEADER;

//
// This header is used to trace and track transaction co-relations
//
typedef struct _EVENT_INSTANCE_HEADER {
    USHORT          Size;
    UCHAR           HeaderType;
    UCHAR           MarkerFlags;
    union {
        ULONG       Version;
        struct {
            UCHAR   Type;
            UCHAR   Level;
            USHORT  Version;
        } Class;
    };
    ULONGLONG       ThreadId;
    LARGE_INTEGER   TimeStamp;
    ULONGLONG       RegHandle;
    ULONG           InstanceId;
    ULONG           ParentInstanceId;
    union {
        struct {
            ULONG   ClientContext;          // Reserved
            ULONG   Flags;                  // Flags for header
        };
        struct {
            ULONG   KernelTime;             // Kernel Mode CPU ticks
            ULONG   UserTime;               // User mode CPU ticks
        };
        ULONG64     ProcessorTime;          // Processor Clock
    };
    ULONGLONG       ParentRegHandle;
} EVENT_INSTANCE_HEADER, *PEVENT_INSTANCE_HEADER;

//
// Following are structures and macros for use with USE_MOF_PTR
//

#define DEFINE_TRACE_MOF_FIELD(MOF, ptr, length, type) \
    (MOF)->DataPtr  = (ULONG64) ptr; \
    (MOF)->Length   = (ULONG) length; \
    (MOF)->DataType = (ULONG) type;

typedef struct _MOF_FIELD {
    ULONG64     DataPtr;    // Pointer to the field. Up to 64-bits only
    ULONG       Length;     // Length of the MOF field
    ULONG       DataType;   // Type of data
} MOF_FIELD, *PMOF_FIELD;


#if !defined(_NTDDK_) || defined(_WMIKM_)
//
// This is the header for every logfile. The memory for LoggerName
// and LogFileName must be contiguous adjacent to this structure
// Allows both user-mode and kernel-mode to understand the header
//
typedef struct _TRACE_LOGFILE_HEADER {
    ULONG           BufferSize;         // Logger buffer size in Kbytes
    union {
        ULONG       Version;            // Logger version
        struct {
            UCHAR   MajorVersion;
            UCHAR   MinorVersion;
            UCHAR   SubVersion;
            UCHAR   SubMinorVersion;
        } VersionDetail;
    };
    ULONG           ProviderVersion;    // defaults to NT version
    ULONG           NumberOfProcessors; // Number of Processors
    LARGE_INTEGER   EndTime;            // Time when logger stops
    ULONG           TimerResolution;    // assumes timer is constant!!!
    ULONG           MaximumFileSize;    // Maximum in Mbytes
    ULONG           LogFileMode;        // specify logfile mode
    ULONG           BuffersWritten;     // used to file start of Circular File
    union {
        GUID LogInstanceGuid;           // For RealTime Buffer Delivery
        struct {
            ULONG   StartBuffers;       // Count of buffers written at start.
            ULONG   PointerSize;        // Size of pointer type in bits
            ULONG   EventsLost;         // Events losts during log session
            ULONG   Reserved32;         // Reserved 32bits
        };
    };
#if defined(_WMIKM_)
    PWCHAR          LoggerName;
    PWCHAR          LogFileName;
    RTL_TIME_ZONE_INFORMATION TimeZone;
#else
    LPWSTR          LoggerName;
    LPWSTR          LogFileName;
    TIME_ZONE_INFORMATION TimeZone;
#endif
    LARGE_INTEGER   BootTime;
    LARGE_INTEGER   PerfFreq;           // Reserved
    LARGE_INTEGER   StartTime;          // Reserved
    ULONG           ReservedFlags;      // Reserved
    ULONG           BuffersLost;
} TRACE_LOGFILE_HEADER, *PTRACE_LOGFILE_HEADER;

#endif // !_NTDDK_ || _WMIKM_


//
// Instance Information to track parent child relationship of Instances.
//
typedef struct EVENT_INSTANCE_INFO {
    HANDLE      RegHandle;
    ULONG       InstanceId;
} EVENT_INSTANCE_INFO, *PEVENT_INSTANCE_INFO;

#if !defined(_WMIKM_) && !defined(_NTDDK_)
//
// Structures that have UNICODE and ANSI versions are defined here
//

//
// Logger configuration and running statistics. This structure is used
// by user-mode callers, such as PDH library
//

typedef struct _EVENT_TRACE_PROPERTIES {
    WNODE_HEADER Wnode;
//
// data provided by caller
    ULONG BufferSize;                   // buffer size for logging (kbytes)
    ULONG MinimumBuffers;               // minimum to preallocate
    ULONG MaximumBuffers;               // maximum buffers allowed
    ULONG MaximumFileSize;              // maximum logfile size (in MBytes)
    ULONG LogFileMode;                  // sequential, circular
    ULONG FlushTimer;                   // buffer flush timer, in seconds
    ULONG EnableFlags;                  // trace enable flags
    LONG  AgeLimit;                     // age decay time, in minutes

// data returned to caller
    ULONG NumberOfBuffers;              // no of buffers in use
    ULONG FreeBuffers;                  // no of buffers free
    ULONG EventsLost;                   // event records lost
    ULONG BuffersWritten;               // no of buffers written to file
    ULONG LogBuffersLost;               // no of logfile write failures
    ULONG RealTimeBuffersLost;          // no of rt delivery failures
    HANDLE LoggerThreadId;              // thread id of Logger
    ULONG LogFileNameOffset;            // Offset to LogFileName
    ULONG LoggerNameOffset;             // Offset to LoggerName
} EVENT_TRACE_PROPERTIES, *PEVENT_TRACE_PROPERTIES;

// NOTE:
// If AgeLimit is 0, default is used
// If AgeLimit is < 0, buffer aging is turned off

//
// Data Provider structures
//
// Used by RegisterTraceGuids()

typedef struct  _TRACE_GUID_REGISTRATION {
    LPCGUID Guid;           // Guid of data block being registered or updated.
    HANDLE RegHandle;      // Guid Registration Handle is returned.
} TRACE_GUID_REGISTRATION, *PTRACE_GUID_REGISTRATION;

//
// Data consumer structures
//

// An EVENT_TRACE consists of a fixed header (EVENT_TRACE_HEADER) and
// optionally a variable portion pointed to by MofData. The datablock
// layout of the variable portion is unknown to the Logger and must
// be obtained from WBEM CIMOM database.
//
typedef struct _EVENT_TRACE {
    EVENT_TRACE_HEADER      Header;             // Event trace header
    ULONG                   InstanceId;         // Instance Id of this event
    ULONG                   ParentInstanceId;   // Parent Instance Id.
    GUID                    ParentGuid;         // Parent Guid;
    PVOID                   MofData;            // Pointer to Variable Data
    ULONG                   MofLength;          // Variable Datablock Length
    ULONG                   ClientContext;      // Reserved
} EVENT_TRACE, *PEVENT_TRACE;


typedef struct _EVENT_TRACE_LOGFILEW
                EVENT_TRACE_LOGFILEW, *PEVENT_TRACE_LOGFILEW;

typedef struct _EVENT_TRACE_LOGFILEA
                EVENT_TRACE_LOGFILEA, *PEVENT_TRACE_LOGFILEA;

typedef ULONG (WINAPI * PEVENT_TRACE_BUFFER_CALLBACKW)
                (PEVENT_TRACE_LOGFILEW Logfile);

typedef ULONG (WINAPI * PEVENT_TRACE_BUFFER_CALLBACKA)
                (PEVENT_TRACE_LOGFILEA Logfile);

typedef VOID (WINAPI *PEVENT_CALLBACK)( PEVENT_TRACE pEvent );

//
// Prototype for service request callback. Data providers register with WMI
// by passing a service request callback function that is called for all
// wmi requests.

typedef ULONG (
#ifndef MIDL_PASS
WINAPI
#endif
*WMIDPREQUEST)(
    IN WMIDPREQUESTCODE RequestCode,
    IN PVOID RequestContext,
    IN OUT ULONG *BufferSize,
    IN OUT PVOID Buffer
    );


struct _EVENT_TRACE_LOGFILEW {
    LPWSTR                  LogFileName;    // Logfile Name
    LPWSTR                  LoggerName;     // LoggerName
    LONGLONG                CurrentTime;    // timestamp of last event
    ULONG                   BuffersRead;    // buffers read to date
    ULONG                   LogFileMode;    // Mode of the logfile

    EVENT_TRACE             CurrentEvent;   // Current Event from this stream.
    TRACE_LOGFILE_HEADER    LogfileHeader;  // logfile header structure
    PEVENT_TRACE_BUFFER_CALLBACKW           // callback before each buffer
                            BufferCallback; // is read
    //
    // following variables are filled for BufferCallback.
    //
    ULONG                   BufferSize;
    ULONG                   Filled;
    ULONG                   EventsLost;
    //
    // following needs to be propaged to each buffer
    //

    PEVENT_CALLBACK         EventCallback;  // callback for every event
    ULONG                   IsKernelTrace;  // TRUE for kernel logfile

    PVOID                   Context;        // reserved for internal use
};

struct _EVENT_TRACE_LOGFILEA {
    LPSTR                   LogFileName;    // Logfile Name
    LPSTR                   LoggerName;     // LoggerName
    LONGLONG                CurrentTime;    // timestamp of last event
    ULONG                   BuffersRead;    // buffers read to date
    ULONG                   LogFileMode;    // LogFile Mode.

    EVENT_TRACE             CurrentEvent;   // Current Event from this stream
    TRACE_LOGFILE_HEADER    LogfileHeader;  // logfile header structure
    PEVENT_TRACE_BUFFER_CALLBACKA           // callback before each buffer
                            BufferCallback; // is read

    //
    // following variables are filled for BufferCallback.
    //
    ULONG                   BufferSize;
    ULONG                   Filled;
    ULONG                   EventsLost;
    //
    // following needs to be propaged to each buffer
    //

    PEVENT_CALLBACK         EventCallback;  // callback for every event
    ULONG                   IsKernelTrace;  // TRUE for kernel logfile

    PVOID                   Context;        // reserved for internal use
};

//
// Define generic structures
//

#if defined(_UNICODE) || defined(UNICODE)
#define PEVENT_TRACE_BUFFER_CALLBACK    PEVENT_TRACE_BUFFER_CALLBACKW
#define EVENT_TRACE_LOGFILE             EVENT_TRACE_LOGFILEW
#define PEVENT_TRACE_LOGFILE            PEVENT_TRACE_LOGFILEW

#else

#define PEVENT_TRACE_BUFFER_CALLBACK    PEVENT_TRACE_BUFFER_CALLBACKA
#define EVENT_TRACE_LOGFILE             EVENT_TRACE_LOGFILEA
#define PEVENT_TRACE_LOGFILE            PEVENT_TRACE_LOGFILEA

#endif

#ifdef __cplusplus
extern "C" {
#endif


//
// Logger control APIs
//

//
// Use the routine below to start an event trace session
//

// ULONG
// StartTrace(
//      OUT PTRACEHANDLE TraceHandle,
//      IN LPTSTR InstanceName,
//      IN OUT PEVENT_TRACE_PROPERTIES Properties
//      );


EXTERN_C
ULONG
WMIAPI
StartTraceW(
    OUT PTRACEHANDLE TraceHandle,
    IN LPCWSTR InstanceName,
    IN OUT PEVENT_TRACE_PROPERTIES Properties
    );

EXTERN_C
ULONG
WMIAPI
StartTraceA(
    OUT PTRACEHANDLE TraceHandle,
    IN LPCSTR InstanceName,
    IN OUT PEVENT_TRACE_PROPERTIES Properties
    );

//
// Use the routine below to stop an event trace session
//

//
// ULONG
// StopTrace(
//      IN PTRACEHANDLE TraceHandle,
//      IN LPTSTR InstanceName,
//      IN OUT PEVENT_TRACE_PROPERTIES Properties
//      );

//
// Use the routine below to query the properties of an event trace session
//

// ULONG
// QueryTrace(
//      IN PTRACEHANDLE TraceHandle,
//      IN LPTSTR InstanceName,
//      IN OUT PEVENT_TRACE_PROPERTIES Properties
//      );

//
// Use the routine below to update certain properties of an event trace session
//

// ULONG
// UpdateTrace(
//      IN (PTRACEHANDLE TraceHandle,
//      IN LPTSTR InstanceName,
//      IN OUT PEVENT_TRACE_PROPERTIES Properties
//      );

EXTERN_C
ULONG
WMIAPI
ControlTraceW(
    IN TRACEHANDLE TraceHandle,
    IN LPCWSTR InstanceName,
    IN OUT PEVENT_TRACE_PROPERTIES Properties,
    IN ULONG ControlCode
    );

EXTERN_C
ULONG
WMIAPI
ControlTraceA(
    IN TRACEHANDLE TraceHandle,
    IN LPCSTR InstanceName,
    IN OUT PEVENT_TRACE_PROPERTIES Properties,
    IN ULONG ControlCode
    );

//
// ULONG
// QueryAllTraces(
//  OUT PEVENT_TRACE_PROPERTIES *PropertyArray,
//  IN ULONG PropertyArrayCount,
//  OUT PULONG LoggerCount
//  );
//

EXTERN_C
ULONG
WMIAPI
QueryAllTracesW(
    OUT PEVENT_TRACE_PROPERTIES *PropertyArray,
    IN ULONG PropertyArrayCount,
    OUT PULONG LoggerCount
    );

EXTERN_C
ULONG
WMIAPI
QueryAllTracesA(
    OUT PEVENT_TRACE_PROPERTIES *PropertyArray,
    IN ULONG PropertyArrayCount,
    OUT PULONG LoggerCount
    );


//
// Data Provider APIs
//

EXTERN_C
ULONG
WMIAPI
CreateTraceInstanceId(
    IN HANDLE RegHandle,
    IN OUT PEVENT_INSTANCE_INFO pInstInfo
    );

EXTERN_C
ULONG
WMIAPI
EnableTrace(
    IN ULONG Enable,
    IN ULONG EnableFlag,
    IN ULONG EnableLevel,
    IN LPCGUID ControlGuid,
    IN TRACEHANDLE TraceHandle
    );

//
// Use the routine below to generate and record an event trace
//


EXTERN_C
ULONG
WMIAPI
TraceEvent(
    IN TRACEHANDLE  TraceHandle,
    IN PEVENT_TRACE_HEADER EventTrace
    );

EXTERN_C
ULONG
WMIAPI
TraceEventInstance(
    IN TRACEHANDLE TraceHandle,
    IN PEVENT_INSTANCE_HEADER EventTrace,
    IN PEVENT_INSTANCE_INFO pInstInfo,
    IN PEVENT_INSTANCE_INFO pParentInstInfo
    );

//
// Use the routine below to register a guid for tracing
//

//
// ULONG
// RegisterTraceGuids(
//  IN WMIDPREQUEST  RequestAddress,
//  IN PVOID         RequestContext,
//  IN LPCGUID       ControlGuid,
//  IN ULONG         GuidCount,
//  IN PTRACE_GUID_REGISTRATION TraceGuidReg,
//  IN LPCTSTR       MofImagePath,
//  IN LPCTSTR       MofResourceName,
//  OUT PTRACEHANDLE RegistrationHandle
//  );
//

EXTERN_C
ULONG
WMIAPI
RegisterTraceGuidsW(
    IN WMIDPREQUEST  RequestAddress,
    IN PVOID         RequestContext,
    IN LPCGUID       ControlGuid,
    IN ULONG         GuidCount,
    IN PTRACE_GUID_REGISTRATION TraceGuidReg,
    IN LPCWSTR       MofImagePath,
    IN LPCWSTR       MofResourceName,
    OUT PTRACEHANDLE RegistrationHandle
    );

EXTERN_C
ULONG
WMIAPI
RegisterTraceGuidsA(
    IN WMIDPREQUEST  RequestAddress,
    IN PVOID         RequestContext,
    IN LPCGUID       ControlGuid,
    IN ULONG         GuidCount,
    IN PTRACE_GUID_REGISTRATION TraceGuidReg,
    IN LPCSTR        MofImagePath,
    IN LPCSTR        MofResourceName,
    OUT PTRACEHANDLE RegistrationHandle
    );

EXTERN_C
ULONG
WMIAPI
UnregisterTraceGuids(
    IN TRACEHANDLE RegistrationHandle
    );

EXTERN_C
TRACEHANDLE
WMIAPI
GetTraceLoggerHandle(
    IN PVOID Buffer
    );

EXTERN_C
UCHAR
WMIAPI
GetTraceEnableLevel(
    IN TRACEHANDLE TraceHandle
    );

EXTERN_C
ULONG
WMIAPI
GetTraceEnableFlags(
    IN TRACEHANDLE TraceHandle
    );

//
// Data Consumer APIs and structures start here
//

//
// TRACEHANDLE
// OpenTrace(
//  IN OUT PEVENT_TRACE_LOGFILE Logfile
//  );
//

EXTERN_C
TRACEHANDLE
WMIAPI
OpenTraceA(
    IN OUT PEVENT_TRACE_LOGFILEA Logfile
    );

EXTERN_C
TRACEHANDLE
WMIAPI
OpenTraceW(
    IN OUT PEVENT_TRACE_LOGFILEW Logfile
    );

EXTERN_C
ULONG
WMIAPI
ProcessTrace(
    IN PTRACEHANDLE HandleArray,
    IN ULONG HandleCount,
    IN LPFILETIME StartTime,
    IN LPFILETIME EndTime
    );

EXTERN_C
ULONG
WMIAPI
CloseTrace(
    IN TRACEHANDLE TraceHandle
    );

EXTERN_C
ULONG
WMIAPI
SetTraceCallback(
    IN LPCGUID pGuid,
    IN PEVENT_CALLBACK EventCallback
    );

EXTERN_C
ULONG
WMIAPI
RemoveTraceCallback (
    IN LPCGUID pGuid
    );

#ifdef __cplusplus
}       // extern "C"
#endif

//
//
// Define the encoding independent routines
//

#if defined(UNICODE) || defined(_UNICODE)
#define RegisterTraceGuids      RegisterTraceGuidsW
#define StartTrace              StartTraceW
#define ControlTrace            ControlTraceW
#define StopTrace(a,b,c)        ControlTraceW((a),(b),(c), \
                                        EVENT_TRACE_CONTROL_STOP)
#define QueryTrace(a,b,c)       ControlTraceW((a),(b),(c), \
                                        EVENT_TRACE_CONTROL_QUERY)
#define UpdateTrace(a,b,c)      ControlTraceW((a),(b),(c), \
                                        EVENT_TRACE_CONTROL_UPDATE)
#define QueryAllTraces          QueryAllTracesW
#define OpenTrace               OpenTraceW
#else
#define RegisterTraceGuids      RegisterTraceGuidsA
#define StartTrace              StartTraceA
#define ControlTrace            ControlTraceA
#define StopTrace(a,b,c)        ControlTraceA((a),(b),(c), \
                                        EVENT_TRACE_CONTROL_STOP)
#define QueryTrace(a,b,c)       ControlTraceA((a),(b),(c), \
                                        EVENT_TRACE_CONTROL_QUERY)
#define UpdateTrace(a,b,c)      ControlTraceA((a),(b),(c), \
                                        EVENT_TRACE_CONTROL_UPDATE)
#define QueryAllTraces          QueryAllTracesA
#define OpenTrace               OpenTraceA
#endif  // UNICODE

#endif /* _WMIKM_  && _NTDDK_ */

#endif // WINNT
#endif /* _EVNTRACE_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\errors.h ===
//------------------------------------------------------------------------------
// File: Errors.h
//
// Desc:  ActiveMovie error defines.
//
// Copyright (c) 1992 - 2000, Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------------------------


#ifndef __ERRORS__
#define __ERRORS__

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

#ifndef _AMOVIE_
#define AMOVIEAPI   DECLSPEC_IMPORT
#else
#define AMOVIEAPI
#endif

// codes 0-01ff are reserved for OLE
#define VFW_FIRST_CODE   0x200
#define MAX_ERROR_TEXT_LEN 160

#include <VFWMSGS.H>                    // includes all message definitions

typedef BOOL (WINAPI* AMGETERRORTEXTPROCA)(HRESULT, char *, DWORD);
typedef BOOL (WINAPI* AMGETERRORTEXTPROCW)(HRESULT, WCHAR *, DWORD);

AMOVIEAPI DWORD WINAPI AMGetErrorTextA( HRESULT hr , char *pbuffer , DWORD MaxLen);
AMOVIEAPI DWORD WINAPI AMGetErrorTextW( HRESULT hr , WCHAR *pbuffer , DWORD MaxLen);


#ifdef UNICODE
#define AMGetErrorText  AMGetErrorTextW
typedef AMGETERRORTEXTPROCW AMGETERRORTEXTPROC;
#else
#define AMGetErrorText  AMGetErrorTextA
typedef AMGETERRORTEXTPROCA AMGETERRORTEXTPROC;
#endif

#ifdef __cplusplus
}
#endif // __cplusplus
#endif // __ERRORS__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\error.h ===
/***
*error.h - DOS error codes
*
*   Copyright (c) 1987-1999, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   DOS calls all return error codes through AX.  If an error occurred then
*   the carry bit will be set and the error code is in AX.  If no error occurred
*   then the carry bit is reset and AX contains returned info.
*
*   Since the set of error codes is being extended as we extend the operating
*   system, we have provided a means for applications to ask the system for a
*   recommended course of action when they receive an error.
*
*   The GetExtendedError system call returns a universal error, an error
*   location and a recommended course of action. The universal error code is
*   a symptom of the error REGARDLESS of the context in which GetExtendedError
*   is issued.
*
****/

/*static char *SCCSID = "@(#)error.h  7.25 87/07/23";*/
/* XENIX calls all return error codes through AX.  If an error occurred then */
/* the carry bit will be set and the error code is in AX.  If no error occurred */
/* then the carry bit is reset and AX contains returned info. */
/* */
/* Since the set of error codes is being extended as we extend the operating */
/* system, we have provided a means for applications to ask the system for a */
/* recommended course of action when they receive an error. */
/* */
/* The GetExtendedError system call returns a universal error, an error */
/* location and a recommended course of action. The universal error code is */
/* a symptom of the error REGARDLESS of the context in which GetExtendedError */
/* is issued. */
/* */
/* */
/* These are the 2.0 error codes */
/* */
#define NO_ERROR            0
#define ERROR_INVALID_FUNCTION      1
#define ERROR_FILE_NOT_FOUND        2
#define ERROR_PATH_NOT_FOUND        3
#define ERROR_TOO_MANY_OPEN_FILES   4
#define ERROR_ACCESS_DENIED     5
#define ERROR_INVALID_HANDLE        6
#define ERROR_ARENA_TRASHED     7
#define ERROR_NOT_ENOUGH_MEMORY     8
#define ERROR_INVALID_BLOCK     9
#define ERROR_BAD_ENVIRONMENT       10
#define ERROR_BAD_FORMAT        11
#define ERROR_INVALID_ACCESS        12
#define ERROR_INVALID_DATA      13
/* **** reserved            14  ; ***** */
#define ERROR_INVALID_DRIVE     15
#define ERROR_CURRENT_DIRECTORY     16
#define ERROR_NOT_SAME_DEVICE       17
#define ERROR_NO_MORE_FILES     18
/* */
/* These are the universal int 24 mappings for the old INT 24 set of errors */
/* */
#define ERROR_WRITE_PROTECT     19
#define ERROR_BAD_UNIT          20
#define ERROR_NOT_READY         21
#define ERROR_BAD_COMMAND       22
#define ERROR_CRC           23
#define ERROR_BAD_LENGTH        24
#define ERROR_SEEK          25
#define ERROR_NOT_DOS_DISK      26
#define ERROR_SECTOR_NOT_FOUND      27
#define ERROR_OUT_OF_PAPER      28
#define ERROR_WRITE_FAULT       29
#define ERROR_READ_FAULT        30
#define ERROR_GEN_FAILURE       31
/* */
/* These are the new 3.0 error codes reported through INT 24 */
/* */
#define ERROR_SHARING_VIOLATION     32
#define ERROR_LOCK_VIOLATION        33
#define ERROR_WRONG_DISK        34
#define ERROR_FCB_UNAVAILABLE       35
#define ERROR_SHARING_BUFFER_EXCEEDED   36
/* */
/* New OEM network-related errors are 50-79 */
/* */
#define ERROR_NOT_SUPPORTED     50
/* */
/* End of INT 24 reportable errors */
/* */
#define ERROR_FILE_EXISTS       80
#define ERROR_DUP_FCB           81 /* ***** */
#define ERROR_CANNOT_MAKE       82
#define ERROR_FAIL_I24          83
/* */
/* New 3.0 network related error codes */
/* */
#define ERROR_OUT_OF_STRUCTURES     84
#define ERROR_ALREADY_ASSIGNED      85
#define ERROR_INVALID_PASSWORD      86
#define ERROR_INVALID_PARAMETER     87
#define ERROR_NET_WRITE_FAULT       88
/* */
/* New error codes for 4.0 */
/* */
#define ERROR_NO_PROC_SLOTS     89  /* no process slots available */
#define ERROR_NOT_FROZEN        90
#define ERR_TSTOVFL         91  /* timer service table overflow */
#define ERR_TSTDUP          92  /* timer service table duplicate */
#define ERROR_NO_ITEMS          93  /* There were no items to operate upon */
#define ERROR_INTERRUPT         95  /* interrupted system call */

#define ERROR_TOO_MANY_SEMAPHORES   100
#define ERROR_EXCL_SEM_ALREADY_OWNED    101
#define ERROR_SEM_IS_SET        102
#define ERROR_TOO_MANY_SEM_REQUESTS 103
#define ERROR_INVALID_AT_INTERRUPT_TIME 104

#define ERROR_SEM_OWNER_DIED        105 /* waitsem found owner died */
#define ERROR_SEM_USER_LIMIT        106 /* too many procs have this sem */
#define ERROR_DISK_CHANGE       107 /* insert disk b into drive a */
#define ERROR_DRIVE_LOCKED      108 /* drive locked by another process */
#define ERROR_BROKEN_PIPE       109 /* write on pipe with no reader */
/* */
/* New error codes for OS/2 */
/* */
#define ERROR_OPEN_FAILED       110 /* open/created failed due to */
                        /* explicit fail command */
#define ERROR_BUFFER_OVERFLOW       111 /* buffer passed to system call */
                        /* is too small to hold return */
                        /* data. */
#define ERROR_DISK_FULL         112 /* not enough space on the disk */
                        /* (DOSNEWSIZE/w_NewSize) */
#define ERROR_NO_MORE_SEARCH_HANDLES    113 /* can't allocate another search */
                        /* structure and handle. */
                        /* (DOSFINDFIRST/w_FindFirst) */
#define ERROR_INVALID_TARGET_HANDLE 114 /* Target handle in DOSDUPHANDLE */
                        /* is invalid */
#define ERROR_PROTECTION_VIOLATION  115 /* Bad user virtual address */
#define ERROR_VIOKBD_REQUEST        116
#define ERROR_INVALID_CATEGORY      117 /* Category for DEVIOCTL in not */
                        /* defined */
#define ERROR_INVALID_VERIFY_SWITCH 118 /* invalid value passed for */
                        /* verify flag */
#define ERROR_BAD_DRIVER_LEVEL      119 /* DosDevIOCTL looks for a level */
                        /* four driver.   If the driver */
                        /* is not level four we return */
                        /* this code */
#define ERROR_CALL_NOT_IMPLEMENTED  120 /* returned from stub api calls. */
                        /* This call will disappear when */
                        /* all the api's are implemented. */
#define ERROR_SEM_TIMEOUT       121 /* Time out happened from the */
                        /* semaphore api functions. */
#define ERROR_INSUFFICIENT_BUFFER   122 /* Some call require the  */
                        /* application to pass in a buffer */
                        /* filled with data.  This error is */
                        /* returned if the data buffer is too */
                        /* small.  For example: DosSetFileInfo */
                        /* requires 4 bytes of data.  If a */
                        /* two byte buffer is passed in then */
                        /* this error is returned.   */
                        /* error_buffer_overflow is used when */
                        /* the output buffer in not big enough. */
#define ERROR_INVALID_NAME      123 /* illegal character or malformed */
                        /* file system name */
#define ERROR_INVALID_LEVEL     124 /* unimplemented level for info */
                        /* retrieval or setting */
#define ERROR_NO_VOLUME_LABEL       125 /* no volume label found with */
                        /* DosQFSInfo command */
#define ERROR_MOD_NOT_FOUND     126 /* w_getprocaddr,w_getmodhandle */
#define ERROR_PROC_NOT_FOUND        127 /* w_getprocaddr */

#define ERROR_WAIT_NO_CHILDREN      128 /* CWait finds to children */

#define ERROR_CHILD_NOT_COMPLETE    129 /* CWait children not dead yet */

/*This is a temporary fix for the 4-19-86 build this should be changed when */
/* we get the file from MS */
#define ERROR_DIRECT_ACCESS_HANDLE  130 /* handle operation is invalid */
                        /* for direct disk access */
                        /* handles */
#define ERROR_NEGATIVE_SEEK     131 /* application tried to seek  */
                        /* with negative offset */
#define ERROR_SEEK_ON_DEVICE        132 /* application tried to seek */
                        /* on device or pipe */
/* */
/* The following are errors generated by the join and subst workers */
/* */
#define ERROR_IS_JOIN_TARGET        133
#define ERROR_IS_JOINED         134
#define ERROR_IS_SUBSTED        135
#define ERROR_NOT_JOINED        136
#define ERROR_NOT_SUBSTED       137
#define ERROR_JOIN_TO_JOIN      138
#define ERROR_SUBST_TO_SUBST        139
#define ERROR_JOIN_TO_SUBST     140
#define ERROR_SUBST_TO_JOIN     141
#define ERROR_BUSY_DRIVE        142
#define ERROR_SAME_DRIVE        143
#define ERROR_DIR_NOT_ROOT      144
#define ERROR_DIR_NOT_EMPTY     145
#define ERROR_IS_SUBST_PATH     146
#define ERROR_IS_JOIN_PATH      147
#define ERROR_PATH_BUSY         148
#define ERROR_IS_SUBST_TARGET       149
#define ERROR_SYSTEM_TRACE      150 /* system trace error */
#define ERROR_INVALID_EVENT_COUNT   151 /* DosMuxSemWait errors */
#define ERROR_TOO_MANY_MUXWAITERS   152
#define ERROR_INVALID_LIST_FORMAT   153
#define ERROR_LABEL_TOO_LONG        154
#define ERROR_TOO_MANY_TCBS     155
#define ERROR_SIGNAL_REFUSED        156
#define ERROR_DISCARDED         157
#define ERROR_NOT_LOCKED        158
#define ERROR_BAD_THREADID_ADDR     159
#define ERROR_BAD_ARGUMENTS     160
#define ERROR_BAD_PATHNAME      161
#define ERROR_SIGNAL_PENDING        162
#define ERROR_UNCERTAIN_MEDIA       163
#define ERROR_MAX_THRDS_REACHED     164
#define ERROR_MONITORS_NOT_SUPPORTED    165

#define ERROR_INVALID_SEGMENT_NUMBER    180
#define ERROR_INVALID_CALLGATE      181
#define ERROR_INVALID_ORDINAL       182
#define ERROR_ALREADY_EXISTS        183
#define ERROR_NO_CHILD_PROCESS      184
#define ERROR_CHILD_ALIVE_NOWAIT    185
#define ERROR_INVALID_FLAG_NUMBER   186
#define ERROR_SEM_NOT_FOUND     187

/*  following error codes have added to make the loader error
    messages distinct
*/

#define ERROR_INVALID_STARTING_CODESEG  188
#define ERROR_INVALID_STACKSEG      189
#define ERROR_INVALID_MODULETYPE    190
#define ERROR_INVALID_EXE_SIGNATURE 191
#define ERROR_EXE_MARKED_INVALID    192
#define ERROR_BAD_EXE_FORMAT        193
#define ERROR_ITERATED_DATA_EXCEEDS_64k 194
#define ERROR_INVALID_MINALLOCSIZE  195
#define ERROR_DYNLINK_FROM_INVALID_RING 196
#define ERROR_IOPL_NOT_ENABLED      197
#define ERROR_INVALID_SEGDPL        198
#define ERROR_AUTODATASEG_EXCEEDS_64k   199
#define ERROR_RING2SEG_MUST_BE_MOVABLE  200
#define ERROR_RELOC_CHAIN_XEEDS_SEGLIM  201
#define ERROR_INFLOOP_IN_RELOC_CHAIN    202

#define ERROR_ENVVAR_NOT_FOUND      203
#define ERROR_NOT_CURRENT_CTRY      204
#define ERROR_NO_SIGNAL_SENT        205
#define ERROR_FILENAME_EXCED_RANGE  206 /* if filename > 8.3 */
#define ERROR_RING2_STACK_IN_USE    207 /* for FAPI */
#define ERROR_META_EXPANSION_TOO_LONG   208 /* if "*a" > 8.3 */

#define ERROR_INVALID_SIGNAL_NUMBER 209
#define ERROR_THREAD_1_INACTIVE     210
#define ERROR_INFO_NOT_AVAIL        211 /*@@ PTM 5550 */
#define ERROR_LOCKED            212
#define ERROR_BAD_DYNALINK      213 /*@@ PTM 5760 */
#define ERROR_TOO_MANY_MODULES      214
#define ERROR_NESTING_NOT_ALLOWED   215

/*
 * Error codes 230 - 249 are reserved for MS Networks
 */

#define ERROR_USER_DEFINED_BASE     0xF000

#define ERROR_I24_WRITE_PROTECT     0
#define ERROR_I24_BAD_UNIT      1
#define ERROR_I24_NOT_READY     2
#define ERROR_I24_BAD_COMMAND       3
#define ERROR_I24_CRC           4
#define ERROR_I24_BAD_LENGTH        5
#define ERROR_I24_SEEK          6
#define ERROR_I24_NOT_DOS_DISK      7
#define ERROR_I24_SECTOR_NOT_FOUND  8
#define ERROR_I24_OUT_OF_PAPER      9
#define ERROR_I24_WRITE_FAULT       0x0A
#define ERROR_I24_READ_FAULT        0x0B
#define ERROR_I24_GEN_FAILURE       0x0C
#define ERROR_I24_DISK_CHANGE       0x0D
#define ERROR_I24_WRONG_DISK        0x0F
#define ERROR_I24_UNCERTAIN_MEDIA   0x10
#define ERROR_I24_CHAR_CALL_INTERRUPTED 0x11
#define ERROR_I24_NO_MONITOR_SUPPORT    0x12
#define ERROR_I24_INVALID_PARAMETER 0x13

#define ALLOWED_FAIL        0x0001
#define ALLOWED_ABORT       0x0002
#define ALLOWED_RETRY       0x0004
#define ALLOWED_IGNORE      0x0008

#define I24_OPERATION       0x1
#define I24_AREA        0x6
                    /* 01 if FAT */
                    /* 10 if root DIR */
                    /* 11 if DATA */
#define I24_CLASS       0x80


/* Values for error CLASS */

#define ERRCLASS_OUTRES     1   /* Out of Resource */
#define ERRCLASS_TEMPSIT    2   /* Temporary Situation */
#define ERRCLASS_AUTH       3   /* Permission problem */
#define ERRCLASS_INTRN      4   /* Internal System Error */
#define ERRCLASS_HRDFAIL    5   /* Hardware Failure */
#define ERRCLASS_SYSFAIL    6   /* System Failure */
#define ERRCLASS_APPERR     7   /* Application Error */
#define ERRCLASS_NOTFND     8   /* Not Found */
#define ERRCLASS_BADFMT     9   /* Bad Format */
#define ERRCLASS_LOCKED     10  /* Locked */
#define ERRCLASS_MEDIA      11  /* Media Failure */
#define ERRCLASS_ALREADY    12  /* Collision with Existing Item */
#define ERRCLASS_UNK        13  /* Unknown/other */
#define ERRCLASS_CANT       14
#define ERRCLASS_TIME       15

/* Values for error ACTION */

#define ERRACT_RETRY        1   /* Retry */
#define ERRACT_DLYRET       2   /* Delay Retry, retry after pause */
#define ERRACT_USER     3   /* Ask user to regive info */
#define ERRACT_ABORT        4   /* abort with clean up */
#define ERRACT_PANIC        5   /* abort immediately */
#define ERRACT_IGNORE       6   /* ignore */
#define ERRACT_INTRET       7   /* Retry after User Intervention */

/* Values for error LOCUS */

#define ERRLOC_UNK      1   /* No appropriate value */
#define ERRLOC_DISK     2   /* Random Access Mass Storage */
#define ERRLOC_NET      3   /* Network */
#define ERRLOC_SERDEV       4   /* Serial Device */
#define ERRLOC_MEM      5   /* Memory */

/* Abnormal termination codes */

#define TC_NORMAL   0
#define TC_HARDERR  1
#define TC_GP_TRAP  2
#define TC_SIGNAL   3
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\eventsys.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0279 */
/* at Wed Sep 15 03:28:31 1999
 */
/* Compiler settings for eventsys.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __eventsys_h__
#define __eventsys_h__

/* Forward Declarations */ 

#ifndef __IEventSystem_FWD_DEFINED__
#define __IEventSystem_FWD_DEFINED__
typedef interface IEventSystem IEventSystem;
#endif 	/* __IEventSystem_FWD_DEFINED__ */


#ifndef __IEventPublisher_FWD_DEFINED__
#define __IEventPublisher_FWD_DEFINED__
typedef interface IEventPublisher IEventPublisher;
#endif 	/* __IEventPublisher_FWD_DEFINED__ */


#ifndef __IEventClass_FWD_DEFINED__
#define __IEventClass_FWD_DEFINED__
typedef interface IEventClass IEventClass;
#endif 	/* __IEventClass_FWD_DEFINED__ */


#ifndef __IEventSubscription_FWD_DEFINED__
#define __IEventSubscription_FWD_DEFINED__
typedef interface IEventSubscription IEventSubscription;
#endif 	/* __IEventSubscription_FWD_DEFINED__ */


#ifndef __IFiringControl_FWD_DEFINED__
#define __IFiringControl_FWD_DEFINED__
typedef interface IFiringControl IFiringControl;
#endif 	/* __IFiringControl_FWD_DEFINED__ */


#ifndef __IPublisherFilter_FWD_DEFINED__
#define __IPublisherFilter_FWD_DEFINED__
typedef interface IPublisherFilter IPublisherFilter;
#endif 	/* __IPublisherFilter_FWD_DEFINED__ */


#ifndef __IMultiInterfacePublisherFilter_FWD_DEFINED__
#define __IMultiInterfacePublisherFilter_FWD_DEFINED__
typedef interface IMultiInterfacePublisherFilter IMultiInterfacePublisherFilter;
#endif 	/* __IMultiInterfacePublisherFilter_FWD_DEFINED__ */


#ifndef __IEventObjectChange_FWD_DEFINED__
#define __IEventObjectChange_FWD_DEFINED__
typedef interface IEventObjectChange IEventObjectChange;
#endif 	/* __IEventObjectChange_FWD_DEFINED__ */


#ifndef __IEnumEventObject_FWD_DEFINED__
#define __IEnumEventObject_FWD_DEFINED__
typedef interface IEnumEventObject IEnumEventObject;
#endif 	/* __IEnumEventObject_FWD_DEFINED__ */


#ifndef __IEventObjectCollection_FWD_DEFINED__
#define __IEventObjectCollection_FWD_DEFINED__
typedef interface IEventObjectCollection IEventObjectCollection;
#endif 	/* __IEventObjectCollection_FWD_DEFINED__ */


#ifndef __IEventProperty_FWD_DEFINED__
#define __IEventProperty_FWD_DEFINED__
typedef interface IEventProperty IEventProperty;
#endif 	/* __IEventProperty_FWD_DEFINED__ */


#ifndef __IEventControl_FWD_DEFINED__
#define __IEventControl_FWD_DEFINED__
typedef interface IEventControl IEventControl;
#endif 	/* __IEventControl_FWD_DEFINED__ */


#ifndef __IMultiInterfaceEventControl_FWD_DEFINED__
#define __IMultiInterfaceEventControl_FWD_DEFINED__
typedef interface IMultiInterfaceEventControl IMultiInterfaceEventControl;
#endif 	/* __IMultiInterfaceEventControl_FWD_DEFINED__ */


#ifndef __CEventSystem_FWD_DEFINED__
#define __CEventSystem_FWD_DEFINED__

#ifdef __cplusplus
typedef class CEventSystem CEventSystem;
#else
typedef struct CEventSystem CEventSystem;
#endif /* __cplusplus */

#endif 	/* __CEventSystem_FWD_DEFINED__ */


#ifndef __CEventPublisher_FWD_DEFINED__
#define __CEventPublisher_FWD_DEFINED__

#ifdef __cplusplus
typedef class CEventPublisher CEventPublisher;
#else
typedef struct CEventPublisher CEventPublisher;
#endif /* __cplusplus */

#endif 	/* __CEventPublisher_FWD_DEFINED__ */


#ifndef __CEventClass_FWD_DEFINED__
#define __CEventClass_FWD_DEFINED__

#ifdef __cplusplus
typedef class CEventClass CEventClass;
#else
typedef struct CEventClass CEventClass;
#endif /* __cplusplus */

#endif 	/* __CEventClass_FWD_DEFINED__ */


#ifndef __CEventSubscription_FWD_DEFINED__
#define __CEventSubscription_FWD_DEFINED__

#ifdef __cplusplus
typedef class CEventSubscription CEventSubscription;
#else
typedef struct CEventSubscription CEventSubscription;
#endif /* __cplusplus */

#endif 	/* __CEventSubscription_FWD_DEFINED__ */


#ifndef __EventObjectChange_FWD_DEFINED__
#define __EventObjectChange_FWD_DEFINED__

#ifdef __cplusplus
typedef class EventObjectChange EventObjectChange;
#else
typedef struct EventObjectChange EventObjectChange;
#endif /* __cplusplus */

#endif 	/* __EventObjectChange_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_eventsys_0000 */
/* [local] */ 

#define PROGID_EventSystem OLESTR("EventSystem.EventSystem")
#define PROGID_EventPublisher OLESTR("EventSystem.EventPublisher")
#define PROGID_EventClass OLESTR("EventSystem.EventClass")
#define PROGID_EventSubscription OLESTR("EventSystem.EventSubscription")
#define PROGID_EventPublisherCollection OLESTR("EventSystem.EventPublisherCollection")
#define PROGID_EventClassCollection OLESTR("EventSystem.EventClassCollection")
#define PROGID_EventSubscriptionCollection OLESTR("EventSystem.EventSubscriptionCollection")
#define PROGID_EventSubsystem OLESTR("EventSystem.EventSubsystem")
#define EVENTSYSTEM_PUBLISHER_ID OLESTR("{d0564c30-9df4-11d1-a281-00c04fca0aa7}")
#define EVENTSYSTEM_SUBSYSTEM_CLSID OLESTR("{503c1fd8-b605-11d2-a92d-006008c60e24}")






extern RPC_IF_HANDLE __MIDL_itf_eventsys_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_eventsys_0000_v0_0_s_ifspec;

#ifndef __IEventSystem_INTERFACE_DEFINED__
#define __IEventSystem_INTERFACE_DEFINED__

/* interface IEventSystem */
/* [unique][helpstring][dual][uuid][object] */ 

// *****************************************************************
// This is a Deprecated interface - Use COMAdmin interfaces instead.
// *****************************************************************

EXTERN_C const IID IID_IEventSystem;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4E14FB9F-2E22-11D1-9964-00C04FBBB345")
    IEventSystem : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Query( 
            /* [in] */ BSTR progID,
            /* [in] */ BSTR queryCriteria,
            /* [out] */ int __RPC_FAR *errorIndex,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppInterface) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Store( 
            /* [in] */ BSTR ProgID,
            /* [in] */ IUnknown __RPC_FAR *pInterface) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Remove( 
            /* [in] */ BSTR progID,
            /* [in] */ BSTR queryCriteria,
            /* [out] */ int __RPC_FAR *errorIndex) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_EventObjectChangeEventClassID( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrEventClassID) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE QueryS( 
            /* [in] */ BSTR progID,
            /* [in] */ BSTR queryCriteria,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppInterface) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE RemoveS( 
            /* [in] */ BSTR progID,
            /* [in] */ BSTR queryCriteria) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEventSystemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEventSystem __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEventSystem __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEventSystem __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IEventSystem __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IEventSystem __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IEventSystem __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IEventSystem __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Query )( 
            IEventSystem __RPC_FAR * This,
            /* [in] */ BSTR progID,
            /* [in] */ BSTR queryCriteria,
            /* [out] */ int __RPC_FAR *errorIndex,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppInterface);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Store )( 
            IEventSystem __RPC_FAR * This,
            /* [in] */ BSTR ProgID,
            /* [in] */ IUnknown __RPC_FAR *pInterface);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Remove )( 
            IEventSystem __RPC_FAR * This,
            /* [in] */ BSTR progID,
            /* [in] */ BSTR queryCriteria,
            /* [out] */ int __RPC_FAR *errorIndex);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_EventObjectChangeEventClassID )( 
            IEventSystem __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrEventClassID);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryS )( 
            IEventSystem __RPC_FAR * This,
            /* [in] */ BSTR progID,
            /* [in] */ BSTR queryCriteria,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppInterface);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveS )( 
            IEventSystem __RPC_FAR * This,
            /* [in] */ BSTR progID,
            /* [in] */ BSTR queryCriteria);
        
        END_INTERFACE
    } IEventSystemVtbl;

    interface IEventSystem
    {
        CONST_VTBL struct IEventSystemVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEventSystem_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEventSystem_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEventSystem_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEventSystem_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IEventSystem_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IEventSystem_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IEventSystem_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IEventSystem_Query(This,progID,queryCriteria,errorIndex,ppInterface)	\
    (This)->lpVtbl -> Query(This,progID,queryCriteria,errorIndex,ppInterface)

#define IEventSystem_Store(This,ProgID,pInterface)	\
    (This)->lpVtbl -> Store(This,ProgID,pInterface)

#define IEventSystem_Remove(This,progID,queryCriteria,errorIndex)	\
    (This)->lpVtbl -> Remove(This,progID,queryCriteria,errorIndex)

#define IEventSystem_get_EventObjectChangeEventClassID(This,pbstrEventClassID)	\
    (This)->lpVtbl -> get_EventObjectChangeEventClassID(This,pbstrEventClassID)

#define IEventSystem_QueryS(This,progID,queryCriteria,ppInterface)	\
    (This)->lpVtbl -> QueryS(This,progID,queryCriteria,ppInterface)

#define IEventSystem_RemoveS(This,progID,queryCriteria)	\
    (This)->lpVtbl -> RemoveS(This,progID,queryCriteria)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IEventSystem_Query_Proxy( 
    IEventSystem __RPC_FAR * This,
    /* [in] */ BSTR progID,
    /* [in] */ BSTR queryCriteria,
    /* [out] */ int __RPC_FAR *errorIndex,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppInterface);


void __RPC_STUB IEventSystem_Query_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IEventSystem_Store_Proxy( 
    IEventSystem __RPC_FAR * This,
    /* [in] */ BSTR ProgID,
    /* [in] */ IUnknown __RPC_FAR *pInterface);


void __RPC_STUB IEventSystem_Store_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IEventSystem_Remove_Proxy( 
    IEventSystem __RPC_FAR * This,
    /* [in] */ BSTR progID,
    /* [in] */ BSTR queryCriteria,
    /* [out] */ int __RPC_FAR *errorIndex);


void __RPC_STUB IEventSystem_Remove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IEventSystem_get_EventObjectChangeEventClassID_Proxy( 
    IEventSystem __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrEventClassID);


void __RPC_STUB IEventSystem_get_EventObjectChangeEventClassID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IEventSystem_QueryS_Proxy( 
    IEventSystem __RPC_FAR * This,
    /* [in] */ BSTR progID,
    /* [in] */ BSTR queryCriteria,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppInterface);


void __RPC_STUB IEventSystem_QueryS_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IEventSystem_RemoveS_Proxy( 
    IEventSystem __RPC_FAR * This,
    /* [in] */ BSTR progID,
    /* [in] */ BSTR queryCriteria);


void __RPC_STUB IEventSystem_RemoveS_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEventSystem_INTERFACE_DEFINED__ */


#ifndef __IEventPublisher_INTERFACE_DEFINED__
#define __IEventPublisher_INTERFACE_DEFINED__

/* interface IEventPublisher */
/* [unique][helpstring][dual][uuid][object] */ 

// ********************************************
// This is a Deprecated interface - Do Not Use.
// ********************************************

EXTERN_C const IID IID_IEventPublisher;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E341516B-2E32-11D1-9964-00C04FBBB345")
    IEventPublisher : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PublisherID( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrPublisherID) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_PublisherID( 
            /* [in] */ BSTR bstrPublisherID) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PublisherName( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrPublisherName) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_PublisherName( 
            /* [in] */ BSTR bstrPublisherName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PublisherType( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrPublisherType) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_PublisherType( 
            /* [in] */ BSTR bstrPublisherType) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_OwnerSID( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrOwnerSID) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_OwnerSID( 
            /* [in] */ BSTR bstrOwnerSID) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Description( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrDescription) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Description( 
            /* [in] */ BSTR bstrDescription) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetDefaultProperty( 
            /* [in] */ BSTR bstrPropertyName,
            /* [retval][out] */ VARIANT __RPC_FAR *propertyValue) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE PutDefaultProperty( 
            /* [in] */ BSTR bstrPropertyName,
            /* [in] */ VARIANT __RPC_FAR *propertyValue) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE RemoveDefaultProperty( 
            /* [in] */ BSTR bstrPropertyName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetDefaultPropertyCollection( 
            /* [retval][out] */ IEventObjectCollection __RPC_FAR *__RPC_FAR *collection) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEventPublisherVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEventPublisher __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEventPublisher __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEventPublisher __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IEventPublisher __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IEventPublisher __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IEventPublisher __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IEventPublisher __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_PublisherID )( 
            IEventPublisher __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrPublisherID);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_PublisherID )( 
            IEventPublisher __RPC_FAR * This,
            /* [in] */ BSTR bstrPublisherID);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_PublisherName )( 
            IEventPublisher __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrPublisherName);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_PublisherName )( 
            IEventPublisher __RPC_FAR * This,
            /* [in] */ BSTR bstrPublisherName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_PublisherType )( 
            IEventPublisher __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrPublisherType);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_PublisherType )( 
            IEventPublisher __RPC_FAR * This,
            /* [in] */ BSTR bstrPublisherType);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_OwnerSID )( 
            IEventPublisher __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrOwnerSID);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_OwnerSID )( 
            IEventPublisher __RPC_FAR * This,
            /* [in] */ BSTR bstrOwnerSID);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Description )( 
            IEventPublisher __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrDescription);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Description )( 
            IEventPublisher __RPC_FAR * This,
            /* [in] */ BSTR bstrDescription);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDefaultProperty )( 
            IEventPublisher __RPC_FAR * This,
            /* [in] */ BSTR bstrPropertyName,
            /* [retval][out] */ VARIANT __RPC_FAR *propertyValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PutDefaultProperty )( 
            IEventPublisher __RPC_FAR * This,
            /* [in] */ BSTR bstrPropertyName,
            /* [in] */ VARIANT __RPC_FAR *propertyValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveDefaultProperty )( 
            IEventPublisher __RPC_FAR * This,
            /* [in] */ BSTR bstrPropertyName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDefaultPropertyCollection )( 
            IEventPublisher __RPC_FAR * This,
            /* [retval][out] */ IEventObjectCollection __RPC_FAR *__RPC_FAR *collection);
        
        END_INTERFACE
    } IEventPublisherVtbl;

    interface IEventPublisher
    {
        CONST_VTBL struct IEventPublisherVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEventPublisher_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEventPublisher_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEventPublisher_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEventPublisher_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IEventPublisher_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IEventPublisher_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IEventPublisher_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IEventPublisher_get_PublisherID(This,pbstrPublisherID)	\
    (This)->lpVtbl -> get_PublisherID(This,pbstrPublisherID)

#define IEventPublisher_put_PublisherID(This,bstrPublisherID)	\
    (This)->lpVtbl -> put_PublisherID(This,bstrPublisherID)

#define IEventPublisher_get_PublisherName(This,pbstrPublisherName)	\
    (This)->lpVtbl -> get_PublisherName(This,pbstrPublisherName)

#define IEventPublisher_put_PublisherName(This,bstrPublisherName)	\
    (This)->lpVtbl -> put_PublisherName(This,bstrPublisherName)

#define IEventPublisher_get_PublisherType(This,pbstrPublisherType)	\
    (This)->lpVtbl -> get_PublisherType(This,pbstrPublisherType)

#define IEventPublisher_put_PublisherType(This,bstrPublisherType)	\
    (This)->lpVtbl -> put_PublisherType(This,bstrPublisherType)

#define IEventPublisher_get_OwnerSID(This,pbstrOwnerSID)	\
    (This)->lpVtbl -> get_OwnerSID(This,pbstrOwnerSID)

#define IEventPublisher_put_OwnerSID(This,bstrOwnerSID)	\
    (This)->lpVtbl -> put_OwnerSID(This,bstrOwnerSID)

#define IEventPublisher_get_Description(This,pbstrDescription)	\
    (This)->lpVtbl -> get_Description(This,pbstrDescription)

#define IEventPublisher_put_Description(This,bstrDescription)	\
    (This)->lpVtbl -> put_Description(This,bstrDescription)

#define IEventPublisher_GetDefaultProperty(This,bstrPropertyName,propertyValue)	\
    (This)->lpVtbl -> GetDefaultProperty(This,bstrPropertyName,propertyValue)

#define IEventPublisher_PutDefaultProperty(This,bstrPropertyName,propertyValue)	\
    (This)->lpVtbl -> PutDefaultProperty(This,bstrPropertyName,propertyValue)

#define IEventPublisher_RemoveDefaultProperty(This,bstrPropertyName)	\
    (This)->lpVtbl -> RemoveDefaultProperty(This,bstrPropertyName)

#define IEventPublisher_GetDefaultPropertyCollection(This,collection)	\
    (This)->lpVtbl -> GetDefaultPropertyCollection(This,collection)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IEventPublisher_get_PublisherID_Proxy( 
    IEventPublisher __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrPublisherID);


void __RPC_STUB IEventPublisher_get_PublisherID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IEventPublisher_put_PublisherID_Proxy( 
    IEventPublisher __RPC_FAR * This,
    /* [in] */ BSTR bstrPublisherID);


void __RPC_STUB IEventPublisher_put_PublisherID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IEventPublisher_get_PublisherName_Proxy( 
    IEventPublisher __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrPublisherName);


void __RPC_STUB IEventPublisher_get_PublisherName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IEventPublisher_put_PublisherName_Proxy( 
    IEventPublisher __RPC_FAR * This,
    /* [in] */ BSTR bstrPublisherName);


void __RPC_STUB IEventPublisher_put_PublisherName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IEventPublisher_get_PublisherType_Proxy( 
    IEventPublisher __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrPublisherType);


void __RPC_STUB IEventPublisher_get_PublisherType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IEventPublisher_put_PublisherType_Proxy( 
    IEventPublisher __RPC_FAR * This,
    /* [in] */ BSTR bstrPublisherType);


void __RPC_STUB IEventPublisher_put_PublisherType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IEventPublisher_get_OwnerSID_Proxy( 
    IEventPublisher __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrOwnerSID);


void __RPC_STUB IEventPublisher_get_OwnerSID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IEventPublisher_put_OwnerSID_Proxy( 
    IEventPublisher __RPC_FAR * This,
    /* [in] */ BSTR bstrOwnerSID);


void __RPC_STUB IEventPublisher_put_OwnerSID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IEventPublisher_get_Description_Proxy( 
    IEventPublisher __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrDescription);


void __RPC_STUB IEventPublisher_get_Description_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IEventPublisher_put_Description_Proxy( 
    IEventPublisher __RPC_FAR * This,
    /* [in] */ BSTR bstrDescription);


void __RPC_STUB IEventPublisher_put_Description_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IEventPublisher_GetDefaultProperty_Proxy( 
    IEventPublisher __RPC_FAR * This,
    /* [in] */ BSTR bstrPropertyName,
    /* [retval][out] */ VARIANT __RPC_FAR *propertyValue);


void __RPC_STUB IEventPublisher_GetDefaultProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IEventPublisher_PutDefaultProperty_Proxy( 
    IEventPublisher __RPC_FAR * This,
    /* [in] */ BSTR bstrPropertyName,
    /* [in] */ VARIANT __RPC_FAR *propertyValue);


void __RPC_STUB IEventPublisher_PutDefaultProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IEventPublisher_RemoveDefaultProperty_Proxy( 
    IEventPublisher __RPC_FAR * This,
    /* [in] */ BSTR bstrPropertyName);


void __RPC_STUB IEventPublisher_RemoveDefaultProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IEventPublisher_GetDefaultPropertyCollection_Proxy( 
    IEventPublisher __RPC_FAR * This,
    /* [retval][out] */ IEventObjectCollection __RPC_FAR *__RPC_FAR *collection);


void __RPC_STUB IEventPublisher_GetDefaultPropertyCollection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEventPublisher_INTERFACE_DEFINED__ */


#ifndef __IEventClass_INTERFACE_DEFINED__
#define __IEventClass_INTERFACE_DEFINED__

/* interface IEventClass */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IEventClass;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("fb2b72a0-7a68-11d1-88f9-0080c7d771bf")
    IEventClass : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_EventClassID( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrEventClassID) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_EventClassID( 
            /* [in] */ BSTR bstrEventClassID) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_EventClassName( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrEventClassName) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_EventClassName( 
            /* [in] */ BSTR bstrEventClassName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_OwnerSID( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrOwnerSID) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_OwnerSID( 
            /* [in] */ BSTR bstrOwnerSID) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_FiringInterfaceID( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrFiringInterfaceID) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_FiringInterfaceID( 
            /* [in] */ BSTR bstrFiringInterfaceID) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Description( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrDescription) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Description( 
            /* [in] */ BSTR bstrDescription) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CustomConfigCLSID( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrCustomConfigCLSID) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_CustomConfigCLSID( 
            /* [in] */ BSTR bstrCustomConfigCLSID) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TypeLib( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrTypeLib) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_TypeLib( 
            /* [in] */ BSTR bstrTypeLib) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEventClassVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEventClass __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEventClass __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEventClass __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IEventClass __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IEventClass __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IEventClass __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IEventClass __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_EventClassID )( 
            IEventClass __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrEventClassID);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_EventClassID )( 
            IEventClass __RPC_FAR * This,
            /* [in] */ BSTR bstrEventClassID);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_EventClassName )( 
            IEventClass __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrEventClassName);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_EventClassName )( 
            IEventClass __RPC_FAR * This,
            /* [in] */ BSTR bstrEventClassName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_OwnerSID )( 
            IEventClass __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrOwnerSID);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_OwnerSID )( 
            IEventClass __RPC_FAR * This,
            /* [in] */ BSTR bstrOwnerSID);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_FiringInterfaceID )( 
            IEventClass __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrFiringInterfaceID);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_FiringInterfaceID )( 
            IEventClass __RPC_FAR * This,
            /* [in] */ BSTR bstrFiringInterfaceID);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Description )( 
            IEventClass __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrDescription);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Description )( 
            IEventClass __RPC_FAR * This,
            /* [in] */ BSTR bstrDescription);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CustomConfigCLSID )( 
            IEventClass __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrCustomConfigCLSID);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_CustomConfigCLSID )( 
            IEventClass __RPC_FAR * This,
            /* [in] */ BSTR bstrCustomConfigCLSID);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_TypeLib )( 
            IEventClass __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrTypeLib);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_TypeLib )( 
            IEventClass __RPC_FAR * This,
            /* [in] */ BSTR bstrTypeLib);
        
        END_INTERFACE
    } IEventClassVtbl;

    interface IEventClass
    {
        CONST_VTBL struct IEventClassVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEventClass_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEventClass_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEventClass_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEventClass_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IEventClass_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IEventClass_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IEventClass_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IEventClass_get_EventClassID(This,pbstrEventClassID)	\
    (This)->lpVtbl -> get_EventClassID(This,pbstrEventClassID)

#define IEventClass_put_EventClassID(This,bstrEventClassID)	\
    (This)->lpVtbl -> put_EventClassID(This,bstrEventClassID)

#define IEventClass_get_EventClassName(This,pbstrEventClassName)	\
    (This)->lpVtbl -> get_EventClassName(This,pbstrEventClassName)

#define IEventClass_put_EventClassName(This,bstrEventClassName)	\
    (This)->lpVtbl -> put_EventClassName(This,bstrEventClassName)

#define IEventClass_get_OwnerSID(This,pbstrOwnerSID)	\
    (This)->lpVtbl -> get_OwnerSID(This,pbstrOwnerSID)

#define IEventClass_put_OwnerSID(This,bstrOwnerSID)	\
    (This)->lpVtbl -> put_OwnerSID(This,bstrOwnerSID)

#define IEventClass_get_FiringInterfaceID(This,pbstrFiringInterfaceID)	\
    (This)->lpVtbl -> get_FiringInterfaceID(This,pbstrFiringInterfaceID)

#define IEventClass_put_FiringInterfaceID(This,bstrFiringInterfaceID)	\
    (This)->lpVtbl -> put_FiringInterfaceID(This,bstrFiringInterfaceID)

#define IEventClass_get_Description(This,pbstrDescription)	\
    (This)->lpVtbl -> get_Description(This,pbstrDescription)

#define IEventClass_put_Description(This,bstrDescription)	\
    (This)->lpVtbl -> put_Description(This,bstrDescription)

#define IEventClass_get_CustomConfigCLSID(This,pbstrCustomConfigCLSID)	\
    (This)->lpVtbl -> get_CustomConfigCLSID(This,pbstrCustomConfigCLSID)

#define IEventClass_put_CustomConfigCLSID(This,bstrCustomConfigCLSID)	\
    (This)->lpVtbl -> put_CustomConfigCLSID(This,bstrCustomConfigCLSID)

#define IEventClass_get_TypeLib(This,pbstrTypeLib)	\
    (This)->lpVtbl -> get_TypeLib(This,pbstrTypeLib)

#define IEventClass_put_TypeLib(This,bstrTypeLib)	\
    (This)->lpVtbl -> put_TypeLib(This,bstrTypeLib)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IEventClass_get_EventClassID_Proxy( 
    IEventClass __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrEventClassID);


void __RPC_STUB IEventClass_get_EventClassID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IEventClass_put_EventClassID_Proxy( 
    IEventClass __RPC_FAR * This,
    /* [in] */ BSTR bstrEventClassID);


void __RPC_STUB IEventClass_put_EventClassID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IEventClass_get_EventClassName_Proxy( 
    IEventClass __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrEventClassName);


void __RPC_STUB IEventClass_get_EventClassName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IEventClass_put_EventClassName_Proxy( 
    IEventClass __RPC_FAR * This,
    /* [in] */ BSTR bstrEventClassName);


void __RPC_STUB IEventClass_put_EventClassName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IEventClass_get_OwnerSID_Proxy( 
    IEventClass __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrOwnerSID);


void __RPC_STUB IEventClass_get_OwnerSID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IEventClass_put_OwnerSID_Proxy( 
    IEventClass __RPC_FAR * This,
    /* [in] */ BSTR bstrOwnerSID);


void __RPC_STUB IEventClass_put_OwnerSID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IEventClass_get_FiringInterfaceID_Proxy( 
    IEventClass __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrFiringInterfaceID);


void __RPC_STUB IEventClass_get_FiringInterfaceID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IEventClass_put_FiringInterfaceID_Proxy( 
    IEventClass __RPC_FAR * This,
    /* [in] */ BSTR bstrFiringInterfaceID);


void __RPC_STUB IEventClass_put_FiringInterfaceID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IEventClass_get_Description_Proxy( 
    IEventClass __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrDescription);


void __RPC_STUB IEventClass_get_Description_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IEventClass_put_Description_Proxy( 
    IEventClass __RPC_FAR * This,
    /* [in] */ BSTR bstrDescription);


void __RPC_STUB IEventClass_put_Description_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IEventClass_get_CustomConfigCLSID_Proxy( 
    IEventClass __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrCustomConfigCLSID);


void __RPC_STUB IEventClass_get_CustomConfigCLSID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IEventClass_put_CustomConfigCLSID_Proxy( 
    IEventClass __RPC_FAR * This,
    /* [in] */ BSTR bstrCustomConfigCLSID);


void __RPC_STUB IEventClass_put_CustomConfigCLSID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IEventClass_get_TypeLib_Proxy( 
    IEventClass __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrTypeLib);


void __RPC_STUB IEventClass_get_TypeLib_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IEventClass_put_TypeLib_Proxy( 
    IEventClass __RPC_FAR * This,
    /* [in] */ BSTR bstrTypeLib);


void __RPC_STUB IEventClass_put_TypeLib_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEventClass_INTERFACE_DEFINED__ */


#ifndef __IEventSubscription_INTERFACE_DEFINED__
#define __IEventSubscription_INTERFACE_DEFINED__

/* interface IEventSubscription */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IEventSubscription;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4A6B0E15-2E38-11D1-9965-00C04FBBB345")
    IEventSubscription : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SubscriptionID( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrSubscriptionID) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_SubscriptionID( 
            /* [in] */ BSTR bstrSubscriptionID) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SubscriptionName( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrSubscriptionName) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_SubscriptionName( 
            /* [in] */ BSTR bstrSubscriptionName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PublisherID( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrPublisherID) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_PublisherID( 
            /* [in] */ BSTR bstrPublisherID) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_EventClassID( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrEventClassID) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_EventClassID( 
            /* [in] */ BSTR bstrEventClassID) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MethodName( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrMethodName) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_MethodName( 
            /* [in] */ BSTR bstrMethodName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SubscriberCLSID( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrSubscriberCLSID) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_SubscriberCLSID( 
            /* [in] */ BSTR bstrSubscriberCLSID) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SubscriberInterface( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppSubscriberInterface) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_SubscriberInterface( 
            /* [in] */ IUnknown __RPC_FAR *pSubscriberInterface) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PerUser( 
            /* [retval][out] */ BOOL __RPC_FAR *pfPerUser) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_PerUser( 
            /* [in] */ BOOL fPerUser) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_OwnerSID( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrOwnerSID) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_OwnerSID( 
            /* [in] */ BSTR bstrOwnerSID) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Enabled( 
            /* [retval][out] */ BOOL __RPC_FAR *pfEnabled) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Enabled( 
            /* [in] */ BOOL fEnabled) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Description( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrDescription) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Description( 
            /* [in] */ BSTR bstrDescription) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MachineName( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrMachineName) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_MachineName( 
            /* [in] */ BSTR bstrMachineName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetPublisherProperty( 
            /* [in] */ BSTR bstrPropertyName,
            /* [retval][out] */ VARIANT __RPC_FAR *propertyValue) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE PutPublisherProperty( 
            /* [in] */ BSTR bstrPropertyName,
            /* [in] */ VARIANT __RPC_FAR *propertyValue) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE RemovePublisherProperty( 
            /* [in] */ BSTR bstrPropertyName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetPublisherPropertyCollection( 
            /* [retval][out] */ IEventObjectCollection __RPC_FAR *__RPC_FAR *collection) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetSubscriberProperty( 
            /* [in] */ BSTR bstrPropertyName,
            /* [retval][out] */ VARIANT __RPC_FAR *propertyValue) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE PutSubscriberProperty( 
            /* [in] */ BSTR bstrPropertyName,
            /* [in] */ VARIANT __RPC_FAR *propertyValue) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE RemoveSubscriberProperty( 
            /* [in] */ BSTR bstrPropertyName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetSubscriberPropertyCollection( 
            /* [retval][out] */ IEventObjectCollection __RPC_FAR *__RPC_FAR *collection) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_InterfaceID( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrInterfaceID) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_InterfaceID( 
            /* [in] */ BSTR bstrInterfaceID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEventSubscriptionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEventSubscription __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEventSubscription __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEventSubscription __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IEventSubscription __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IEventSubscription __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IEventSubscription __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IEventSubscription __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SubscriptionID )( 
            IEventSubscription __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrSubscriptionID);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_SubscriptionID )( 
            IEventSubscription __RPC_FAR * This,
            /* [in] */ BSTR bstrSubscriptionID);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SubscriptionName )( 
            IEventSubscription __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrSubscriptionName);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_SubscriptionName )( 
            IEventSubscription __RPC_FAR * This,
            /* [in] */ BSTR bstrSubscriptionName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_PublisherID )( 
            IEventSubscription __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrPublisherID);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_PublisherID )( 
            IEventSubscription __RPC_FAR * This,
            /* [in] */ BSTR bstrPublisherID);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_EventClassID )( 
            IEventSubscription __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrEventClassID);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_EventClassID )( 
            IEventSubscription __RPC_FAR * This,
            /* [in] */ BSTR bstrEventClassID);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_MethodName )( 
            IEventSubscription __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrMethodName);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_MethodName )( 
            IEventSubscription __RPC_FAR * This,
            /* [in] */ BSTR bstrMethodName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SubscriberCLSID )( 
            IEventSubscription __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrSubscriberCLSID);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_SubscriberCLSID )( 
            IEventSubscription __RPC_FAR * This,
            /* [in] */ BSTR bstrSubscriberCLSID);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SubscriberInterface )( 
            IEventSubscription __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppSubscriberInterface);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_SubscriberInterface )( 
            IEventSubscription __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *pSubscriberInterface);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_PerUser )( 
            IEventSubscription __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pfPerUser);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_PerUser )( 
            IEventSubscription __RPC_FAR * This,
            /* [in] */ BOOL fPerUser);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_OwnerSID )( 
            IEventSubscription __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrOwnerSID);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_OwnerSID )( 
            IEventSubscription __RPC_FAR * This,
            /* [in] */ BSTR bstrOwnerSID);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Enabled )( 
            IEventSubscription __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pfEnabled);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Enabled )( 
            IEventSubscription __RPC_FAR * This,
            /* [in] */ BOOL fEnabled);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Description )( 
            IEventSubscription __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrDescription);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Description )( 
            IEventSubscription __RPC_FAR * This,
            /* [in] */ BSTR bstrDescription);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_MachineName )( 
            IEventSubscription __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrMachineName);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_MachineName )( 
            IEventSubscription __RPC_FAR * This,
            /* [in] */ BSTR bstrMachineName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPublisherProperty )( 
            IEventSubscription __RPC_FAR * This,
            /* [in] */ BSTR bstrPropertyName,
            /* [retval][out] */ VARIANT __RPC_FAR *propertyValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PutPublisherProperty )( 
            IEventSubscription __RPC_FAR * This,
            /* [in] */ BSTR bstrPropertyName,
            /* [in] */ VARIANT __RPC_FAR *propertyValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemovePublisherProperty )( 
            IEventSubscription __RPC_FAR * This,
            /* [in] */ BSTR bstrPropertyName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPublisherPropertyCollection )( 
            IEventSubscription __RPC_FAR * This,
            /* [retval][out] */ IEventObjectCollection __RPC_FAR *__RPC_FAR *collection);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSubscriberProperty )( 
            IEventSubscription __RPC_FAR * This,
            /* [in] */ BSTR bstrPropertyName,
            /* [retval][out] */ VARIANT __RPC_FAR *propertyValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PutSubscriberProperty )( 
            IEventSubscription __RPC_FAR * This,
            /* [in] */ BSTR bstrPropertyName,
            /* [in] */ VARIANT __RPC_FAR *propertyValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveSubscriberProperty )( 
            IEventSubscription __RPC_FAR * This,
            /* [in] */ BSTR bstrPropertyName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSubscriberPropertyCollection )( 
            IEventSubscription __RPC_FAR * This,
            /* [retval][out] */ IEventObjectCollection __RPC_FAR *__RPC_FAR *collection);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_InterfaceID )( 
            IEventSubscription __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrInterfaceID);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_InterfaceID )( 
            IEventSubscription __RPC_FAR * This,
            /* [in] */ BSTR bstrInterfaceID);
        
        END_INTERFACE
    } IEventSubscriptionVtbl;

    interface IEventSubscription
    {
        CONST_VTBL struct IEventSubscriptionVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEventSubscription_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEventSubscription_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEventSubscription_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEventSubscription_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IEventSubscription_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IEventSubscription_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IEventSubscription_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IEventSubscription_get_SubscriptionID(This,pbstrSubscriptionID)	\
    (This)->lpVtbl -> get_SubscriptionID(This,pbstrSubscriptionID)

#define IEventSubscription_put_SubscriptionID(This,bstrSubscriptionID)	\
    (This)->lpVtbl -> put_SubscriptionID(This,bstrSubscriptionID)

#define IEventSubscription_get_SubscriptionName(This,pbstrSubscriptionName)	\
    (This)->lpVtbl -> get_SubscriptionName(This,pbstrSubscriptionName)

#define IEventSubscription_put_SubscriptionName(This,bstrSubscriptionName)	\
    (This)->lpVtbl -> put_SubscriptionName(This,bstrSubscriptionName)

#define IEventSubscription_get_PublisherID(This,pbstrPublisherID)	\
    (This)->lpVtbl -> get_PublisherID(This,pbstrPublisherID)

#define IEventSubscription_put_PublisherID(This,bstrPublisherID)	\
    (This)->lpVtbl -> put_PublisherID(This,bstrPublisherID)

#define IEventSubscription_get_EventClassID(This,pbstrEventClassID)	\
    (This)->lpVtbl -> get_EventClassID(This,pbstrEventClassID)

#define IEventSubscription_put_EventClassID(This,bstrEventClassID)	\
    (This)->lpVtbl -> put_EventClassID(This,bstrEventClassID)

#define IEventSubscription_get_MethodName(This,pbstrMethodName)	\
    (This)->lpVtbl -> get_MethodName(This,pbstrMethodName)

#define IEventSubscription_put_MethodName(This,bstrMethodName)	\
    (This)->lpVtbl -> put_MethodName(This,bstrMethodName)

#define IEventSubscription_get_SubscriberCLSID(This,pbstrSubscriberCLSID)	\
    (This)->lpVtbl -> get_SubscriberCLSID(This,pbstrSubscriberCLSID)

#define IEventSubscription_put_SubscriberCLSID(This,bstrSubscriberCLSID)	\
    (This)->lpVtbl -> put_SubscriberCLSID(This,bstrSubscriberCLSID)

#define IEventSubscription_get_SubscriberInterface(This,ppSubscriberInterface)	\
    (This)->lpVtbl -> get_SubscriberInterface(This,ppSubscriberInterface)

#define IEventSubscription_put_SubscriberInterface(This,pSubscriberInterface)	\
    (This)->lpVtbl -> put_SubscriberInterface(This,pSubscriberInterface)

#define IEventSubscription_get_PerUser(This,pfPerUser)	\
    (This)->lpVtbl -> get_PerUser(This,pfPerUser)

#define IEventSubscription_put_PerUser(This,fPerUser)	\
    (This)->lpVtbl -> put_PerUser(This,fPerUser)

#define IEventSubscription_get_OwnerSID(This,pbstrOwnerSID)	\
    (This)->lpVtbl -> get_OwnerSID(This,pbstrOwnerSID)

#define IEventSubscription_put_OwnerSID(This,bstrOwnerSID)	\
    (This)->lpVtbl -> put_OwnerSID(This,bstrOwnerSID)

#define IEventSubscription_get_Enabled(This,pfEnabled)	\
    (This)->lpVtbl -> get_Enabled(This,pfEnabled)

#define IEventSubscription_put_Enabled(This,fEnabled)	\
    (This)->lpVtbl -> put_Enabled(This,fEnabled)

#define IEventSubscription_get_Description(This,pbstrDescription)	\
    (This)->lpVtbl -> get_Description(This,pbstrDescription)

#define IEventSubscription_put_Description(This,bstrDescription)	\
    (This)->lpVtbl -> put_Description(This,bstrDescription)

#define IEventSubscription_get_MachineName(This,pbstrMachineName)	\
    (This)->lpVtbl -> get_MachineName(This,pbstrMachineName)

#define IEventSubscription_put_MachineName(This,bstrMachineName)	\
    (This)->lpVtbl -> put_MachineName(This,bstrMachineName)

#define IEventSubscription_GetPublisherProperty(This,bstrPropertyName,propertyValue)	\
    (This)->lpVtbl -> GetPublisherProperty(This,bstrPropertyName,propertyValue)

#define IEventSubscription_PutPublisherProperty(This,bstrPropertyName,propertyValue)	\
    (This)->lpVtbl -> PutPublisherProperty(This,bstrPropertyName,propertyValue)

#define IEventSubscription_RemovePublisherProperty(This,bstrPropertyName)	\
    (This)->lpVtbl -> RemovePublisherProperty(This,bstrPropertyName)

#define IEventSubscription_GetPublisherPropertyCollection(This,collection)	\
    (This)->lpVtbl -> GetPublisherPropertyCollection(This,collection)

#define IEventSubscription_GetSubscriberProperty(This,bstrPropertyName,propertyValue)	\
    (This)->lpVtbl -> GetSubscriberProperty(This,bstrPropertyName,propertyValue)

#define IEventSubscription_PutSubscriberProperty(This,bstrPropertyName,propertyValue)	\
    (This)->lpVtbl -> PutSubscriberProperty(This,bstrPropertyName,propertyValue)

#define IEventSubscription_RemoveSubscriberProperty(This,bstrPropertyName)	\
    (This)->lpVtbl -> RemoveSubscriberProperty(This,bstrPropertyName)

#define IEventSubscription_GetSubscriberPropertyCollection(This,collection)	\
    (This)->lpVtbl -> GetSubscriberPropertyCollection(This,collection)

#define IEventSubscription_get_InterfaceID(This,pbstrInterfaceID)	\
    (This)->lpVtbl -> get_InterfaceID(This,pbstrInterfaceID)

#define IEventSubscription_put_InterfaceID(This,bstrInterfaceID)	\
    (This)->lpVtbl -> put_InterfaceID(This,bstrInterfaceID)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IEventSubscription_get_SubscriptionID_Proxy( 
    IEventSubscription __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrSubscriptionID);


void __RPC_STUB IEventSubscription_get_SubscriptionID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IEventSubscription_put_SubscriptionID_Proxy( 
    IEventSubscription __RPC_FAR * This,
    /* [in] */ BSTR bstrSubscriptionID);


void __RPC_STUB IEventSubscription_put_SubscriptionID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IEventSubscription_get_SubscriptionName_Proxy( 
    IEventSubscription __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrSubscriptionName);


void __RPC_STUB IEventSubscription_get_SubscriptionName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IEventSubscription_put_SubscriptionName_Proxy( 
    IEventSubscription __RPC_FAR * This,
    /* [in] */ BSTR bstrSubscriptionName);


void __RPC_STUB IEventSubscription_put_SubscriptionName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IEventSubscription_get_PublisherID_Proxy( 
    IEventSubscription __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrPublisherID);


void __RPC_STUB IEventSubscription_get_PublisherID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IEventSubscription_put_PublisherID_Proxy( 
    IEventSubscription __RPC_FAR * This,
    /* [in] */ BSTR bstrPublisherID);


void __RPC_STUB IEventSubscription_put_PublisherID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IEventSubscription_get_EventClassID_Proxy( 
    IEventSubscription __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrEventClassID);


void __RPC_STUB IEventSubscription_get_EventClassID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IEventSubscription_put_EventClassID_Proxy( 
    IEventSubscription __RPC_FAR * This,
    /* [in] */ BSTR bstrEventClassID);


void __RPC_STUB IEventSubscription_put_EventClassID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IEventSubscription_get_MethodName_Proxy( 
    IEventSubscription __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrMethodName);


void __RPC_STUB IEventSubscription_get_MethodName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IEventSubscription_put_MethodName_Proxy( 
    IEventSubscription __RPC_FAR * This,
    /* [in] */ BSTR bstrMethodName);


void __RPC_STUB IEventSubscription_put_MethodName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IEventSubscription_get_SubscriberCLSID_Proxy( 
    IEventSubscription __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrSubscriberCLSID);


void __RPC_STUB IEventSubscription_get_SubscriberCLSID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IEventSubscription_put_SubscriberCLSID_Proxy( 
    IEventSubscription __RPC_FAR * This,
    /* [in] */ BSTR bstrSubscriberCLSID);


void __RPC_STUB IEventSubscription_put_SubscriberCLSID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IEventSubscription_get_SubscriberInterface_Proxy( 
    IEventSubscription __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppSubscriberInterface);


void __RPC_STUB IEventSubscription_get_SubscriberInterface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IEventSubscription_put_SubscriberInterface_Proxy( 
    IEventSubscription __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *pSubscriberInterface);


void __RPC_STUB IEventSubscription_put_SubscriberInterface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IEventSubscription_get_PerUser_Proxy( 
    IEventSubscription __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pfPerUser);


void __RPC_STUB IEventSubscription_get_PerUser_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IEventSubscription_put_PerUser_Proxy( 
    IEventSubscription __RPC_FAR * This,
    /* [in] */ BOOL fPerUser);


void __RPC_STUB IEventSubscription_put_PerUser_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IEventSubscription_get_OwnerSID_Proxy( 
    IEventSubscription __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrOwnerSID);


void __RPC_STUB IEventSubscription_get_OwnerSID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IEventSubscription_put_OwnerSID_Proxy( 
    IEventSubscription __RPC_FAR * This,
    /* [in] */ BSTR bstrOwnerSID);


void __RPC_STUB IEventSubscription_put_OwnerSID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IEventSubscription_get_Enabled_Proxy( 
    IEventSubscription __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pfEnabled);


void __RPC_STUB IEventSubscription_get_Enabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IEventSubscription_put_Enabled_Proxy( 
    IEventSubscription __RPC_FAR * This,
    /* [in] */ BOOL fEnabled);


void __RPC_STUB IEventSubscription_put_Enabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IEventSubscription_get_Description_Proxy( 
    IEventSubscription __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrDescription);


void __RPC_STUB IEventSubscription_get_Description_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IEventSubscription_put_Description_Proxy( 
    IEventSubscription __RPC_FAR * This,
    /* [in] */ BSTR bstrDescription);


void __RPC_STUB IEventSubscription_put_Description_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IEventSubscription_get_MachineName_Proxy( 
    IEventSubscription __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrMachineName);


void __RPC_STUB IEventSubscription_get_MachineName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IEventSubscription_put_MachineName_Proxy( 
    IEventSubscription __RPC_FAR * This,
    /* [in] */ BSTR bstrMachineName);


void __RPC_STUB IEventSubscription_put_MachineName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IEventSubscription_GetPublisherProperty_Proxy( 
    IEventSubscription __RPC_FAR * This,
    /* [in] */ BSTR bstrPropertyName,
    /* [retval][out] */ VARIANT __RPC_FAR *propertyValue);


void __RPC_STUB IEventSubscription_GetPublisherProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IEventSubscription_PutPublisherProperty_Proxy( 
    IEventSubscription __RPC_FAR * This,
    /* [in] */ BSTR bstrPropertyName,
    /* [in] */ VARIANT __RPC_FAR *propertyValue);


void __RPC_STUB IEventSubscription_PutPublisherProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IEventSubscription_RemovePublisherProperty_Proxy( 
    IEventSubscription __RPC_FAR * This,
    /* [in] */ BSTR bstrPropertyName);


void __RPC_STUB IEventSubscription_RemovePublisherProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IEventSubscription_GetPublisherPropertyCollection_Proxy( 
    IEventSubscription __RPC_FAR * This,
    /* [retval][out] */ IEventObjectCollection __RPC_FAR *__RPC_FAR *collection);


void __RPC_STUB IEventSubscription_GetPublisherPropertyCollection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IEventSubscription_GetSubscriberProperty_Proxy( 
    IEventSubscription __RPC_FAR * This,
    /* [in] */ BSTR bstrPropertyName,
    /* [retval][out] */ VARIANT __RPC_FAR *propertyValue);


void __RPC_STUB IEventSubscription_GetSubscriberProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IEventSubscription_PutSubscriberProperty_Proxy( 
    IEventSubscription __RPC_FAR * This,
    /* [in] */ BSTR bstrPropertyName,
    /* [in] */ VARIANT __RPC_FAR *propertyValue);


void __RPC_STUB IEventSubscription_PutSubscriberProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IEventSubscription_RemoveSubscriberProperty_Proxy( 
    IEventSubscription __RPC_FAR * This,
    /* [in] */ BSTR bstrPropertyName);


void __RPC_STUB IEventSubscription_RemoveSubscriberProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IEventSubscription_GetSubscriberPropertyCollection_Proxy( 
    IEventSubscription __RPC_FAR * This,
    /* [retval][out] */ IEventObjectCollection __RPC_FAR *__RPC_FAR *collection);


void __RPC_STUB IEventSubscription_GetSubscriberPropertyCollection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IEventSubscription_get_InterfaceID_Proxy( 
    IEventSubscription __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrInterfaceID);


void __RPC_STUB IEventSubscription_get_InterfaceID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IEventSubscription_put_InterfaceID_Proxy( 
    IEventSubscription __RPC_FAR * This,
    /* [in] */ BSTR bstrInterfaceID);


void __RPC_STUB IEventSubscription_put_InterfaceID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEventSubscription_INTERFACE_DEFINED__ */


#ifndef __IFiringControl_INTERFACE_DEFINED__
#define __IFiringControl_INTERFACE_DEFINED__

/* interface IFiringControl */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IFiringControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("e0498c93-4efe-11d1-9971-00c04fbbb345")
    IFiringControl : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE FireSubscription( 
            /* [in] */ IEventSubscription __RPC_FAR *subscription) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFiringControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IFiringControl __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IFiringControl __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IFiringControl __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IFiringControl __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IFiringControl __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IFiringControl __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IFiringControl __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FireSubscription )( 
            IFiringControl __RPC_FAR * This,
            /* [in] */ IEventSubscription __RPC_FAR *subscription);
        
        END_INTERFACE
    } IFiringControlVtbl;

    interface IFiringControl
    {
        CONST_VTBL struct IFiringControlVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFiringControl_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFiringControl_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFiringControl_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFiringControl_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFiringControl_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFiringControl_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFiringControl_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFiringControl_FireSubscription(This,subscription)	\
    (This)->lpVtbl -> FireSubscription(This,subscription)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFiringControl_FireSubscription_Proxy( 
    IFiringControl __RPC_FAR * This,
    /* [in] */ IEventSubscription __RPC_FAR *subscription);


void __RPC_STUB IFiringControl_FireSubscription_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFiringControl_INTERFACE_DEFINED__ */


#ifndef __IPublisherFilter_INTERFACE_DEFINED__
#define __IPublisherFilter_INTERFACE_DEFINED__

/* interface IPublisherFilter */
/* [unique][helpstring][uuid][object] */ 

// ****************************************************************************
// This is a Deprecated interface - Use IMultiInterfacePublisherFilter instead.
// ****************************************************************************

EXTERN_C const IID IID_IPublisherFilter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("465e5cc0-7b26-11d1-88fb-0080c7d771bf")
    IPublisherFilter : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ BSTR methodName,
            /* [unique][in] */ IDispatch __RPC_FAR *dispUserDefined) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE PrepareToFire( 
            /* [in] */ BSTR methodName,
            /* [in] */ IFiringControl __RPC_FAR *firingControl) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPublisherFilterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IPublisherFilter __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IPublisherFilter __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IPublisherFilter __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Initialize )( 
            IPublisherFilter __RPC_FAR * This,
            /* [in] */ BSTR methodName,
            /* [unique][in] */ IDispatch __RPC_FAR *dispUserDefined);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PrepareToFire )( 
            IPublisherFilter __RPC_FAR * This,
            /* [in] */ BSTR methodName,
            /* [in] */ IFiringControl __RPC_FAR *firingControl);
        
        END_INTERFACE
    } IPublisherFilterVtbl;

    interface IPublisherFilter
    {
        CONST_VTBL struct IPublisherFilterVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPublisherFilter_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPublisherFilter_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPublisherFilter_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPublisherFilter_Initialize(This,methodName,dispUserDefined)	\
    (This)->lpVtbl -> Initialize(This,methodName,dispUserDefined)

#define IPublisherFilter_PrepareToFire(This,methodName,firingControl)	\
    (This)->lpVtbl -> PrepareToFire(This,methodName,firingControl)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IPublisherFilter_Initialize_Proxy( 
    IPublisherFilter __RPC_FAR * This,
    /* [in] */ BSTR methodName,
    /* [unique][in] */ IDispatch __RPC_FAR *dispUserDefined);


void __RPC_STUB IPublisherFilter_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IPublisherFilter_PrepareToFire_Proxy( 
    IPublisherFilter __RPC_FAR * This,
    /* [in] */ BSTR methodName,
    /* [in] */ IFiringControl __RPC_FAR *firingControl);


void __RPC_STUB IPublisherFilter_PrepareToFire_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPublisherFilter_INTERFACE_DEFINED__ */


#ifndef __IMultiInterfacePublisherFilter_INTERFACE_DEFINED__
#define __IMultiInterfacePublisherFilter_INTERFACE_DEFINED__

/* interface IMultiInterfacePublisherFilter */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IMultiInterfacePublisherFilter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("465e5cc1-7b26-11d1-88fb-0080c7d771bf")
    IMultiInterfacePublisherFilter : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ IMultiInterfaceEventControl __RPC_FAR *pEIC) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE PrepareToFire( 
            /* [in] */ REFIID iid,
            /* [in] */ BSTR methodName,
            /* [in] */ IFiringControl __RPC_FAR *firingControl) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMultiInterfacePublisherFilterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMultiInterfacePublisherFilter __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMultiInterfacePublisherFilter __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMultiInterfacePublisherFilter __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Initialize )( 
            IMultiInterfacePublisherFilter __RPC_FAR * This,
            /* [in] */ IMultiInterfaceEventControl __RPC_FAR *pEIC);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PrepareToFire )( 
            IMultiInterfacePublisherFilter __RPC_FAR * This,
            /* [in] */ REFIID iid,
            /* [in] */ BSTR methodName,
            /* [in] */ IFiringControl __RPC_FAR *firingControl);
        
        END_INTERFACE
    } IMultiInterfacePublisherFilterVtbl;

    interface IMultiInterfacePublisherFilter
    {
        CONST_VTBL struct IMultiInterfacePublisherFilterVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMultiInterfacePublisherFilter_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMultiInterfacePublisherFilter_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMultiInterfacePublisherFilter_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMultiInterfacePublisherFilter_Initialize(This,pEIC)	\
    (This)->lpVtbl -> Initialize(This,pEIC)

#define IMultiInterfacePublisherFilter_PrepareToFire(This,iid,methodName,firingControl)	\
    (This)->lpVtbl -> PrepareToFire(This,iid,methodName,firingControl)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IMultiInterfacePublisherFilter_Initialize_Proxy( 
    IMultiInterfacePublisherFilter __RPC_FAR * This,
    /* [in] */ IMultiInterfaceEventControl __RPC_FAR *pEIC);


void __RPC_STUB IMultiInterfacePublisherFilter_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IMultiInterfacePublisherFilter_PrepareToFire_Proxy( 
    IMultiInterfacePublisherFilter __RPC_FAR * This,
    /* [in] */ REFIID iid,
    /* [in] */ BSTR methodName,
    /* [in] */ IFiringControl __RPC_FAR *firingControl);


void __RPC_STUB IMultiInterfacePublisherFilter_PrepareToFire_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMultiInterfacePublisherFilter_INTERFACE_DEFINED__ */


#ifndef __IEventObjectChange_INTERFACE_DEFINED__
#define __IEventObjectChange_INTERFACE_DEFINED__

/* interface IEventObjectChange */
/* [unique][helpstring][uuid][object] */ 

typedef /* [public][public][public][public] */ 
enum __MIDL_IEventObjectChange_0001
    {	EOC_NewObject	= 0,
	EOC_ModifiedObject	= EOC_NewObject + 1,
	EOC_DeletedObject	= EOC_ModifiedObject + 1
    }	EOC_ChangeType;


EXTERN_C const IID IID_IEventObjectChange;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F4A07D70-2E25-11D1-9964-00C04FBBB345")
    IEventObjectChange : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ChangedSubscription( 
            /* [in] */ EOC_ChangeType changeType,
            /* [in] */ BSTR bstrSubscriptionID) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ChangedEventClass( 
            /* [in] */ EOC_ChangeType changeType,
            /* [in] */ BSTR bstrEventClassID) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ChangedPublisher( 
            /* [in] */ EOC_ChangeType changeType,
            /* [in] */ BSTR bstrPublisherID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEventObjectChangeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEventObjectChange __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEventObjectChange __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEventObjectChange __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ChangedSubscription )( 
            IEventObjectChange __RPC_FAR * This,
            /* [in] */ EOC_ChangeType changeType,
            /* [in] */ BSTR bstrSubscriptionID);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ChangedEventClass )( 
            IEventObjectChange __RPC_FAR * This,
            /* [in] */ EOC_ChangeType changeType,
            /* [in] */ BSTR bstrEventClassID);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ChangedPublisher )( 
            IEventObjectChange __RPC_FAR * This,
            /* [in] */ EOC_ChangeType changeType,
            /* [in] */ BSTR bstrPublisherID);
        
        END_INTERFACE
    } IEventObjectChangeVtbl;

    interface IEventObjectChange
    {
        CONST_VTBL struct IEventObjectChangeVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEventObjectChange_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEventObjectChange_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEventObjectChange_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEventObjectChange_ChangedSubscription(This,changeType,bstrSubscriptionID)	\
    (This)->lpVtbl -> ChangedSubscription(This,changeType,bstrSubscriptionID)

#define IEventObjectChange_ChangedEventClass(This,changeType,bstrEventClassID)	\
    (This)->lpVtbl -> ChangedEventClass(This,changeType,bstrEventClassID)

#define IEventObjectChange_ChangedPublisher(This,changeType,bstrPublisherID)	\
    (This)->lpVtbl -> ChangedPublisher(This,changeType,bstrPublisherID)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IEventObjectChange_ChangedSubscription_Proxy( 
    IEventObjectChange __RPC_FAR * This,
    /* [in] */ EOC_ChangeType changeType,
    /* [in] */ BSTR bstrSubscriptionID);


void __RPC_STUB IEventObjectChange_ChangedSubscription_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IEventObjectChange_ChangedEventClass_Proxy( 
    IEventObjectChange __RPC_FAR * This,
    /* [in] */ EOC_ChangeType changeType,
    /* [in] */ BSTR bstrEventClassID);


void __RPC_STUB IEventObjectChange_ChangedEventClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IEventObjectChange_ChangedPublisher_Proxy( 
    IEventObjectChange __RPC_FAR * This,
    /* [in] */ EOC_ChangeType changeType,
    /* [in] */ BSTR bstrPublisherID);


void __RPC_STUB IEventObjectChange_ChangedPublisher_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEventObjectChange_INTERFACE_DEFINED__ */


#ifndef __IEnumEventObject_INTERFACE_DEFINED__
#define __IEnumEventObject_INTERFACE_DEFINED__

/* interface IEnumEventObject */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IEnumEventObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F4A07D63-2E25-11D1-9964-00C04FBBB345")
    IEnumEventObject : public IUnknown
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumEventObject __RPC_FAR *__RPC_FAR *ppInterface) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG cReqElem,
            /* [length_is][size_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppInterface,
            /* [out] */ ULONG __RPC_FAR *cRetElem) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG cSkipElem) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumEventObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumEventObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumEventObject __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumEventObject __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumEventObject __RPC_FAR * This,
            /* [out] */ IEnumEventObject __RPC_FAR *__RPC_FAR *ppInterface);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumEventObject __RPC_FAR * This,
            /* [in] */ ULONG cReqElem,
            /* [length_is][size_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppInterface,
            /* [out] */ ULONG __RPC_FAR *cRetElem);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumEventObject __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumEventObject __RPC_FAR * This,
            /* [in] */ ULONG cSkipElem);
        
        END_INTERFACE
    } IEnumEventObjectVtbl;

    interface IEnumEventObject
    {
        CONST_VTBL struct IEnumEventObjectVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumEventObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumEventObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumEventObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumEventObject_Clone(This,ppInterface)	\
    (This)->lpVtbl -> Clone(This,ppInterface)

#define IEnumEventObject_Next(This,cReqElem,ppInterface,cRetElem)	\
    (This)->lpVtbl -> Next(This,cReqElem,ppInterface,cRetElem)

#define IEnumEventObject_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumEventObject_Skip(This,cSkipElem)	\
    (This)->lpVtbl -> Skip(This,cSkipElem)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IEnumEventObject_Clone_Proxy( 
    IEnumEventObject __RPC_FAR * This,
    /* [out] */ IEnumEventObject __RPC_FAR *__RPC_FAR *ppInterface);


void __RPC_STUB IEnumEventObject_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IEnumEventObject_Next_Proxy( 
    IEnumEventObject __RPC_FAR * This,
    /* [in] */ ULONG cReqElem,
    /* [length_is][size_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppInterface,
    /* [out] */ ULONG __RPC_FAR *cRetElem);


void __RPC_STUB IEnumEventObject_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IEnumEventObject_Reset_Proxy( 
    IEnumEventObject __RPC_FAR * This);


void __RPC_STUB IEnumEventObject_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IEnumEventObject_Skip_Proxy( 
    IEnumEventObject __RPC_FAR * This,
    /* [in] */ ULONG cSkipElem);


void __RPC_STUB IEnumEventObject_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumEventObject_INTERFACE_DEFINED__ */


#ifndef __IEventObjectCollection_INTERFACE_DEFINED__
#define __IEventObjectCollection_INTERFACE_DEFINED__

/* interface IEventObjectCollection */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IEventObjectCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("f89ac270-d4eb-11d1-b682-00805fc79216")
    IEventObjectCollection : public IDispatch
    {
    public:
        virtual /* [helpstring][restricted][propget][id] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppUnkEnum) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ BSTR objectID,
            /* [retval][out] */ VARIANT __RPC_FAR *pItem) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_NewEnum( 
            /* [retval][out] */ IEnumEventObject __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long __RPC_FAR *pCount) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Add( 
            /* [in] */ VARIANT __RPC_FAR *item,
            /* [in] */ BSTR objectID) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Remove( 
            /* [in] */ BSTR objectID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEventObjectCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEventObjectCollection __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEventObjectCollection __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEventObjectCollection __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IEventObjectCollection __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IEventObjectCollection __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IEventObjectCollection __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IEventObjectCollection __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][restricted][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__NewEnum )( 
            IEventObjectCollection __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppUnkEnum);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Item )( 
            IEventObjectCollection __RPC_FAR * This,
            /* [in] */ BSTR objectID,
            /* [retval][out] */ VARIANT __RPC_FAR *pItem);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_NewEnum )( 
            IEventObjectCollection __RPC_FAR * This,
            /* [retval][out] */ IEnumEventObject __RPC_FAR *__RPC_FAR *ppEnum);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            IEventObjectCollection __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pCount);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Add )( 
            IEventObjectCollection __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *item,
            /* [in] */ BSTR objectID);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Remove )( 
            IEventObjectCollection __RPC_FAR * This,
            /* [in] */ BSTR objectID);
        
        END_INTERFACE
    } IEventObjectCollectionVtbl;

    interface IEventObjectCollection
    {
        CONST_VTBL struct IEventObjectCollectionVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEventObjectCollection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEventObjectCollection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEventObjectCollection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEventObjectCollection_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IEventObjectCollection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IEventObjectCollection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IEventObjectCollection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IEventObjectCollection_get__NewEnum(This,ppUnkEnum)	\
    (This)->lpVtbl -> get__NewEnum(This,ppUnkEnum)

#define IEventObjectCollection_get_Item(This,objectID,pItem)	\
    (This)->lpVtbl -> get_Item(This,objectID,pItem)

#define IEventObjectCollection_get_NewEnum(This,ppEnum)	\
    (This)->lpVtbl -> get_NewEnum(This,ppEnum)

#define IEventObjectCollection_get_Count(This,pCount)	\
    (This)->lpVtbl -> get_Count(This,pCount)

#define IEventObjectCollection_Add(This,item,objectID)	\
    (This)->lpVtbl -> Add(This,item,objectID)

#define IEventObjectCollection_Remove(This,objectID)	\
    (This)->lpVtbl -> Remove(This,objectID)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][restricted][propget][id] */ HRESULT STDMETHODCALLTYPE IEventObjectCollection_get__NewEnum_Proxy( 
    IEventObjectCollection __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppUnkEnum);


void __RPC_STUB IEventObjectCollection_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE IEventObjectCollection_get_Item_Proxy( 
    IEventObjectCollection __RPC_FAR * This,
    /* [in] */ BSTR objectID,
    /* [retval][out] */ VARIANT __RPC_FAR *pItem);


void __RPC_STUB IEventObjectCollection_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IEventObjectCollection_get_NewEnum_Proxy( 
    IEventObjectCollection __RPC_FAR * This,
    /* [retval][out] */ IEnumEventObject __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IEventObjectCollection_get_NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IEventObjectCollection_get_Count_Proxy( 
    IEventObjectCollection __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pCount);


void __RPC_STUB IEventObjectCollection_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IEventObjectCollection_Add_Proxy( 
    IEventObjectCollection __RPC_FAR * This,
    /* [in] */ VARIANT __RPC_FAR *item,
    /* [in] */ BSTR objectID);


void __RPC_STUB IEventObjectCollection_Add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IEventObjectCollection_Remove_Proxy( 
    IEventObjectCollection __RPC_FAR * This,
    /* [in] */ BSTR objectID);


void __RPC_STUB IEventObjectCollection_Remove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEventObjectCollection_INTERFACE_DEFINED__ */


#ifndef __IEventProperty_INTERFACE_DEFINED__
#define __IEventProperty_INTERFACE_DEFINED__

/* interface IEventProperty */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IEventProperty;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("da538ee2-f4de-11d1-b6bb-00805fc79216")
    IEventProperty : public IDispatch
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR __RPC_FAR *propertyName) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Name( 
            /* [in] */ BSTR propertyName) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Value( 
            /* [retval][out] */ VARIANT __RPC_FAR *propertyValue) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Value( 
            /* [in] */ VARIANT __RPC_FAR *propertyValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEventPropertyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEventProperty __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEventProperty __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEventProperty __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IEventProperty __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IEventProperty __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IEventProperty __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IEventProperty __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )( 
            IEventProperty __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *propertyName);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Name )( 
            IEventProperty __RPC_FAR * This,
            /* [in] */ BSTR propertyName);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Value )( 
            IEventProperty __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *propertyValue);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Value )( 
            IEventProperty __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *propertyValue);
        
        END_INTERFACE
    } IEventPropertyVtbl;

    interface IEventProperty
    {
        CONST_VTBL struct IEventPropertyVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEventProperty_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEventProperty_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEventProperty_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEventProperty_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IEventProperty_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IEventProperty_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IEventProperty_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IEventProperty_get_Name(This,propertyName)	\
    (This)->lpVtbl -> get_Name(This,propertyName)

#define IEventProperty_put_Name(This,propertyName)	\
    (This)->lpVtbl -> put_Name(This,propertyName)

#define IEventProperty_get_Value(This,propertyValue)	\
    (This)->lpVtbl -> get_Value(This,propertyValue)

#define IEventProperty_put_Value(This,propertyValue)	\
    (This)->lpVtbl -> put_Value(This,propertyValue)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IEventProperty_get_Name_Proxy( 
    IEventProperty __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *propertyName);


void __RPC_STUB IEventProperty_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IEventProperty_put_Name_Proxy( 
    IEventProperty __RPC_FAR * This,
    /* [in] */ BSTR propertyName);


void __RPC_STUB IEventProperty_put_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IEventProperty_get_Value_Proxy( 
    IEventProperty __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *propertyValue);


void __RPC_STUB IEventProperty_get_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IEventProperty_put_Value_Proxy( 
    IEventProperty __RPC_FAR * This,
    /* [in] */ VARIANT __RPC_FAR *propertyValue);


void __RPC_STUB IEventProperty_put_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEventProperty_INTERFACE_DEFINED__ */


#ifndef __IEventControl_INTERFACE_DEFINED__
#define __IEventControl_INTERFACE_DEFINED__

/* interface IEventControl */
/* [unique][helpstring][dual][uuid][object] */ 

// *************************************************************************
// This is a Deprecated interface - Use IMultiInterfaceEventControl instead.
// *************************************************************************

EXTERN_C const IID IID_IEventControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0343e2f4-86f6-11d1-b760-00c04fb926af")
    IEventControl : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetPublisherFilter( 
            /* [in] */ BSTR methodName,
            /* [unique][in] */ IPublisherFilter __RPC_FAR *pPublisherFilter) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AllowInprocActivation( 
            /* [retval][out] */ BOOL __RPC_FAR *pfAllowInprocActivation) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_AllowInprocActivation( 
            /* [in] */ BOOL fAllowInprocActivation) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetSubscriptions( 
            /* [in] */ BSTR methodName,
            /* [unique][in] */ BSTR optionalCriteria,
            /* [unique][in] */ int __RPC_FAR *optionalErrorIndex,
            /* [retval][out] */ IEventObjectCollection __RPC_FAR *__RPC_FAR *ppCollection) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetDefaultQuery( 
            /* [in] */ BSTR methodName,
            /* [in] */ BSTR criteria,
            /* [retval][out] */ int __RPC_FAR *errorIndex) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEventControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEventControl __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEventControl __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEventControl __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IEventControl __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IEventControl __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IEventControl __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IEventControl __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPublisherFilter )( 
            IEventControl __RPC_FAR * This,
            /* [in] */ BSTR methodName,
            /* [unique][in] */ IPublisherFilter __RPC_FAR *pPublisherFilter);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_AllowInprocActivation )( 
            IEventControl __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pfAllowInprocActivation);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_AllowInprocActivation )( 
            IEventControl __RPC_FAR * This,
            /* [in] */ BOOL fAllowInprocActivation);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSubscriptions )( 
            IEventControl __RPC_FAR * This,
            /* [in] */ BSTR methodName,
            /* [unique][in] */ BSTR optionalCriteria,
            /* [unique][in] */ int __RPC_FAR *optionalErrorIndex,
            /* [retval][out] */ IEventObjectCollection __RPC_FAR *__RPC_FAR *ppCollection);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDefaultQuery )( 
            IEventControl __RPC_FAR * This,
            /* [in] */ BSTR methodName,
            /* [in] */ BSTR criteria,
            /* [retval][out] */ int __RPC_FAR *errorIndex);
        
        END_INTERFACE
    } IEventControlVtbl;

    interface IEventControl
    {
        CONST_VTBL struct IEventControlVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEventControl_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEventControl_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEventControl_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEventControl_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IEventControl_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IEventControl_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IEventControl_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IEventControl_SetPublisherFilter(This,methodName,pPublisherFilter)	\
    (This)->lpVtbl -> SetPublisherFilter(This,methodName,pPublisherFilter)

#define IEventControl_get_AllowInprocActivation(This,pfAllowInprocActivation)	\
    (This)->lpVtbl -> get_AllowInprocActivation(This,pfAllowInprocActivation)

#define IEventControl_put_AllowInprocActivation(This,fAllowInprocActivation)	\
    (This)->lpVtbl -> put_AllowInprocActivation(This,fAllowInprocActivation)

#define IEventControl_GetSubscriptions(This,methodName,optionalCriteria,optionalErrorIndex,ppCollection)	\
    (This)->lpVtbl -> GetSubscriptions(This,methodName,optionalCriteria,optionalErrorIndex,ppCollection)

#define IEventControl_SetDefaultQuery(This,methodName,criteria,errorIndex)	\
    (This)->lpVtbl -> SetDefaultQuery(This,methodName,criteria,errorIndex)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IEventControl_SetPublisherFilter_Proxy( 
    IEventControl __RPC_FAR * This,
    /* [in] */ BSTR methodName,
    /* [unique][in] */ IPublisherFilter __RPC_FAR *pPublisherFilter);


void __RPC_STUB IEventControl_SetPublisherFilter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IEventControl_get_AllowInprocActivation_Proxy( 
    IEventControl __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pfAllowInprocActivation);


void __RPC_STUB IEventControl_get_AllowInprocActivation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IEventControl_put_AllowInprocActivation_Proxy( 
    IEventControl __RPC_FAR * This,
    /* [in] */ BOOL fAllowInprocActivation);


void __RPC_STUB IEventControl_put_AllowInprocActivation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IEventControl_GetSubscriptions_Proxy( 
    IEventControl __RPC_FAR * This,
    /* [in] */ BSTR methodName,
    /* [unique][in] */ BSTR optionalCriteria,
    /* [unique][in] */ int __RPC_FAR *optionalErrorIndex,
    /* [retval][out] */ IEventObjectCollection __RPC_FAR *__RPC_FAR *ppCollection);


void __RPC_STUB IEventControl_GetSubscriptions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IEventControl_SetDefaultQuery_Proxy( 
    IEventControl __RPC_FAR * This,
    /* [in] */ BSTR methodName,
    /* [in] */ BSTR criteria,
    /* [retval][out] */ int __RPC_FAR *errorIndex);


void __RPC_STUB IEventControl_SetDefaultQuery_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEventControl_INTERFACE_DEFINED__ */


#ifndef __IMultiInterfaceEventControl_INTERFACE_DEFINED__
#define __IMultiInterfaceEventControl_INTERFACE_DEFINED__

/* interface IMultiInterfaceEventControl */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IMultiInterfaceEventControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0343e2f5-86f6-11d1-b760-00c04fb926af")
    IMultiInterfaceEventControl : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetMultiInterfacePublisherFilter( 
            /* [unique][in] */ IMultiInterfacePublisherFilter __RPC_FAR *classFilter) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetSubscriptions( 
            /* [in] */ REFIID eventIID,
            /* [in] */ BSTR bstrMethodName,
            /* [unique][in] */ BSTR optionalCriteria,
            /* [unique][in] */ int __RPC_FAR *optionalErrorIndex,
            /* [retval][out] */ IEventObjectCollection __RPC_FAR *__RPC_FAR *ppCollection) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetDefaultQuery( 
            /* [in] */ REFIID eventIID,
            /* [in] */ BSTR bstrMethodName,
            /* [in] */ BSTR bstrCriteria,
            /* [retval][out] */ int __RPC_FAR *errorIndex) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_AllowInprocActivation( 
            /* [retval][out] */ BOOL __RPC_FAR *pfAllowInprocActivation) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_AllowInprocActivation( 
            /* [in] */ BOOL fAllowInprocActivation) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_FireInParallel( 
            /* [retval][out] */ BOOL __RPC_FAR *pfFireInParallel) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_FireInParallel( 
            /* [in] */ BOOL fFireInParallel) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMultiInterfaceEventControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMultiInterfaceEventControl __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMultiInterfaceEventControl __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMultiInterfaceEventControl __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetMultiInterfacePublisherFilter )( 
            IMultiInterfaceEventControl __RPC_FAR * This,
            /* [unique][in] */ IMultiInterfacePublisherFilter __RPC_FAR *classFilter);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSubscriptions )( 
            IMultiInterfaceEventControl __RPC_FAR * This,
            /* [in] */ REFIID eventIID,
            /* [in] */ BSTR bstrMethodName,
            /* [unique][in] */ BSTR optionalCriteria,
            /* [unique][in] */ int __RPC_FAR *optionalErrorIndex,
            /* [retval][out] */ IEventObjectCollection __RPC_FAR *__RPC_FAR *ppCollection);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDefaultQuery )( 
            IMultiInterfaceEventControl __RPC_FAR * This,
            /* [in] */ REFIID eventIID,
            /* [in] */ BSTR bstrMethodName,
            /* [in] */ BSTR bstrCriteria,
            /* [retval][out] */ int __RPC_FAR *errorIndex);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_AllowInprocActivation )( 
            IMultiInterfaceEventControl __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pfAllowInprocActivation);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_AllowInprocActivation )( 
            IMultiInterfaceEventControl __RPC_FAR * This,
            /* [in] */ BOOL fAllowInprocActivation);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_FireInParallel )( 
            IMultiInterfaceEventControl __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pfFireInParallel);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_FireInParallel )( 
            IMultiInterfaceEventControl __RPC_FAR * This,
            /* [in] */ BOOL fFireInParallel);
        
        END_INTERFACE
    } IMultiInterfaceEventControlVtbl;

    interface IMultiInterfaceEventControl
    {
        CONST_VTBL struct IMultiInterfaceEventControlVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMultiInterfaceEventControl_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMultiInterfaceEventControl_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMultiInterfaceEventControl_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMultiInterfaceEventControl_SetMultiInterfacePublisherFilter(This,classFilter)	\
    (This)->lpVtbl -> SetMultiInterfacePublisherFilter(This,classFilter)

#define IMultiInterfaceEventControl_GetSubscriptions(This,eventIID,bstrMethodName,optionalCriteria,optionalErrorIndex,ppCollection)	\
    (This)->lpVtbl -> GetSubscriptions(This,eventIID,bstrMethodName,optionalCriteria,optionalErrorIndex,ppCollection)

#define IMultiInterfaceEventControl_SetDefaultQuery(This,eventIID,bstrMethodName,bstrCriteria,errorIndex)	\
    (This)->lpVtbl -> SetDefaultQuery(This,eventIID,bstrMethodName,bstrCriteria,errorIndex)

#define IMultiInterfaceEventControl_get_AllowInprocActivation(This,pfAllowInprocActivation)	\
    (This)->lpVtbl -> get_AllowInprocActivation(This,pfAllowInprocActivation)

#define IMultiInterfaceEventControl_put_AllowInprocActivation(This,fAllowInprocActivation)	\
    (This)->lpVtbl -> put_AllowInprocActivation(This,fAllowInprocActivation)

#define IMultiInterfaceEventControl_get_FireInParallel(This,pfFireInParallel)	\
    (This)->lpVtbl -> get_FireInParallel(This,pfFireInParallel)

#define IMultiInterfaceEventControl_put_FireInParallel(This,fFireInParallel)	\
    (This)->lpVtbl -> put_FireInParallel(This,fFireInParallel)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IMultiInterfaceEventControl_SetMultiInterfacePublisherFilter_Proxy( 
    IMultiInterfaceEventControl __RPC_FAR * This,
    /* [unique][in] */ IMultiInterfacePublisherFilter __RPC_FAR *classFilter);


void __RPC_STUB IMultiInterfaceEventControl_SetMultiInterfacePublisherFilter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IMultiInterfaceEventControl_GetSubscriptions_Proxy( 
    IMultiInterfaceEventControl __RPC_FAR * This,
    /* [in] */ REFIID eventIID,
    /* [in] */ BSTR bstrMethodName,
    /* [unique][in] */ BSTR optionalCriteria,
    /* [unique][in] */ int __RPC_FAR *optionalErrorIndex,
    /* [retval][out] */ IEventObjectCollection __RPC_FAR *__RPC_FAR *ppCollection);


void __RPC_STUB IMultiInterfaceEventControl_GetSubscriptions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IMultiInterfaceEventControl_SetDefaultQuery_Proxy( 
    IMultiInterfaceEventControl __RPC_FAR * This,
    /* [in] */ REFIID eventIID,
    /* [in] */ BSTR bstrMethodName,
    /* [in] */ BSTR bstrCriteria,
    /* [retval][out] */ int __RPC_FAR *errorIndex);


void __RPC_STUB IMultiInterfaceEventControl_SetDefaultQuery_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IMultiInterfaceEventControl_get_AllowInprocActivation_Proxy( 
    IMultiInterfaceEventControl __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pfAllowInprocActivation);


void __RPC_STUB IMultiInterfaceEventControl_get_AllowInprocActivation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IMultiInterfaceEventControl_put_AllowInprocActivation_Proxy( 
    IMultiInterfaceEventControl __RPC_FAR * This,
    /* [in] */ BOOL fAllowInprocActivation);


void __RPC_STUB IMultiInterfaceEventControl_put_AllowInprocActivation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IMultiInterfaceEventControl_get_FireInParallel_Proxy( 
    IMultiInterfaceEventControl __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pfFireInParallel);


void __RPC_STUB IMultiInterfaceEventControl_get_FireInParallel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IMultiInterfaceEventControl_put_FireInParallel_Proxy( 
    IMultiInterfaceEventControl __RPC_FAR * This,
    /* [in] */ BOOL fFireInParallel);


void __RPC_STUB IMultiInterfaceEventControl_put_FireInParallel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMultiInterfaceEventControl_INTERFACE_DEFINED__ */



#ifndef __DummyEventSystemLib_LIBRARY_DEFINED__
#define __DummyEventSystemLib_LIBRARY_DEFINED__

/* library DummyEventSystemLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_DummyEventSystemLib;

EXTERN_C const CLSID CLSID_CEventSystem;

#ifdef __cplusplus

class DECLSPEC_UUID("4E14FBA2-2E22-11D1-9964-00C04FBBB345")
CEventSystem;
#endif

EXTERN_C const CLSID CLSID_CEventPublisher;

#ifdef __cplusplus

class DECLSPEC_UUID("ab944620-79c6-11d1-88f9-0080c7d771bf")
CEventPublisher;
#endif

EXTERN_C const CLSID CLSID_CEventClass;

#ifdef __cplusplus

class DECLSPEC_UUID("cdbec9c0-7a68-11d1-88f9-0080c7d771bf")
CEventClass;
#endif

EXTERN_C const CLSID CLSID_CEventSubscription;

#ifdef __cplusplus

class DECLSPEC_UUID("7542e960-79c7-11d1-88f9-0080c7d771bf")
CEventSubscription;
#endif

EXTERN_C const CLSID CLSID_EventObjectChange;

#ifdef __cplusplus

class DECLSPEC_UUID("d0565000-9df4-11d1-a281-00c04fca0aa7")
EventObjectChange;
#endif
#endif /* __DummyEventSystemLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long __RPC_FAR *, unsigned long            , VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long __RPC_FAR *, VARIANT __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\eventcpts_i.c ===
/* this file contains the actual definitions of */
/* the IIDs and CLSIDs */

/* link this file in with the server and any clients */


/* File created by MIDL compiler version 3.01.75 */
/* at Thu Sep 11 16:03:12 1997
 */
/* Compiler settings for eventcpts.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

const IID IID_IMtsUserEvent = {0xD56C3DC0,0x8482,0x11d0,{0xB1,0x70,0x00,0xAA,0x00,0xBA,0x32,0x58}};


const IID IID_IMtsThreadEvents = {0xBACEDF4F,0x74AB,0x11D0,{0xB1,0x62,0x00,0xAA,0x00,0xBA,0x32,0x58}};


const IID IID_IMtsPackageEvents = {0xBACEDF50,0x74AB,0x11D0,{0xB1,0x62,0x00,0xAA,0x00,0xBA,0x32,0x58}};


const IID IID_IMtsInstanceEvents = {0xBACEDF51,0x74AB,0x11D0,{0xB1,0x62,0x00,0xAA,0x00,0xBA,0x32,0x58}};


const IID IID_IMtsTransactionEvents = {0xBACEDF52,0x74AB,0x11D0,{0xB1,0x62,0x00,0xAA,0x00,0xBA,0x32,0x58}};


const IID IID_IMtsMethodEvents = {0xBACEDF53,0x74AB,0x11D0,{0xB1,0x62,0x00,0xAA,0x00,0xBA,0x32,0x58}};


const IID IID_IMtsObjectEvents = {0xBACEDF54,0x74AB,0x11D0,{0xB1,0x62,0x00,0xAA,0x00,0xBA,0x32,0x58}};


const IID IID_IMtsResourceEvents = {0xBACEDF55,0x74AB,0x11D0,{0xB1,0x62,0x00,0xAA,0x00,0xBA,0x32,0x58}};


const IID IID_IMtsSecurityEvents = {0x55EB3AFB,0x0A11,0x11d1,{0xB1,0xB4,0x00,0xAA,0x00,0xBA,0x32,0x58}};


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\evcode.h ===
//------------------------------------------------------------------------------
// File: EvCode.h
//
// Desc: List of standard Quartz event codes and the expected params.
//
// Copyright (c) 1992 - 2000, Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------------------------


// Event codes are broken into two groups
//   -- system event codes
//   -- extension event codes
// All system event codes are below EC_USER

#define EC_SYSTEMBASE                       0x00
#define EC_USER                             0x8000

// System-defined event codes
// ==========================
//
// There are three types of system-defined event codes:
//
// 1.  Those which are always passed through to the application
//     (To be collected by calls to GetEvent or within WaitForCompletion.)
//     (e.g. EC_ERRORABORT, EC_USERABORT.)
//
// 2.  Those which are pure internal and will never be passed to
//     the application.  (e.g. EC_SHUTDOWN)
//
// 3.  Those which have default handling.  Default handing implies that
//     the event is not passed to the application.  However, default
//     handling may be canceled by calling
//     IMediaEvent::CancelDefaultHandling.  If the default handling is
//     cancelled in this way, then the message will be delivered to the
//     application and the application must action it appropriately.
//     Default handling can be restored by calling RestoreDefaultHandling.
//
// We will refer to these events as application, internal and defaulted
// events respectively.
//
// System-defined events may have interface pointers, BSTR's, etc passed
// as parameters.  It is therefore essential that, for any message
// retrieved using GetEvent, a matching call to FreeEventParams is made
// to ensure that relevant interfaces are released and storage freed.
// Failure to call FreeEventParams will result in memory leaks, if not
// worse.
//
// Filters sending these messages to the filter graph should not AddRef()
// any interfaces that they may pass as parameters.  The filter graph
// manager will AddRef them if required.  E.g. if the event is to be queued
// for the application or queued to a worker thread.

// Each event listed below is immediately followed by a parameter list
// detailing the types of the parameters associated with the message,
// and an indication of whether the message is an application, internal
// or defaulted message.  This is then followed by a short description.
// The use of "void" in the parameter list implies that the parameter is not
// used.  Such parameters should be zero.

// Other defined EC_ regions:
// DVD event codes           0x0100 - 0x0150 (dvdevcod.h)
// audio device event codes  0x0200 - 0x0250 (audevcod.h)
// WindowsMedia SDK-originated events 0x0251 - 0x0300 (see below)

#define EC_COMPLETE                         0x01
// ( HRESULT, void ) : defaulted (special)
// Signals the completed playback of a stream within the graph.  This message
// is sent by renderers when they receive end-of-stream.  The default handling
// of this message results in a _SINGLE_ EC_COMPLETE being sent to the
// application when ALL of the individual renderers have signaled EC_COMPLETE
// to the filter graph.  If the default handing is canceled, the application
// will see all of the individual EC_COMPLETEs.


#define EC_USERABORT                        0x02
// ( void, void ) : application
// In some sense, the user has requested that playback be terminated.
// This message is typically sent by renderers that render into a
// window if the user closes the window into which it was rendering.
// It is up to the application to decide if playback should actually
// be stopped.


#define EC_ERRORABORT                       0x03
// ( HRESULT, void ) : application
// Operation aborted because of error


#define EC_TIME                             0x04
// ( DWORD, DWORD ) : application
// The requested reference time occurred.  (This event is currently not used).
// lParam1 is low dword of ref time, lParam2 is high dword of reftime.


#define EC_REPAINT                          0x05
// ( IPin * (could be NULL), void ) : defaulted
// A repaint is required - lParam1 contains the (IPin *) that needs the data
// to be sent again. Default handling is: if the output pin which the IPin is
// attached  to supports the IMediaEventSink interface then it will be called
// with the EC_REPAINT first.  If that fails then normal repaint processing is
// done by the filter graph.


// Stream error notifications
#define EC_STREAM_ERROR_STOPPED             0x06
#define EC_STREAM_ERROR_STILLPLAYING        0x07
// ( HRESULT, DWORD ) : application
// lParam 1 is major code, lParam2 is minor code, either may be zero.


#define EC_ERROR_STILLPLAYING               0x08
// ( HRESULT, void ) : application
// The filter graph manager may issue Run's to the graph asynchronously.
// If such a Run fails, EC_ERROR_STILLPLAYING is issued to notify the
// application of the failure.  The state of the underlying filters
// at such a time will be indeterminate - they will all have been asked
// to run, but some are almost certainly not.


#define EC_PALETTE_CHANGED                  0x09
// ( void, void ) : application
// notify application that the video palette has changed


#define EC_VIDEO_SIZE_CHANGED               0x0A
// ( DWORD, void ) : application
// Sent by video renderers.
// Notifies the application that the native video size has changed.
// LOWORD of the DWORD is the new width, HIWORD is the new height.


#define EC_QUALITY_CHANGE                   0x0B
// ( void, void ) : application
// Notify application that playback degradation has occurred


#define EC_SHUTTING_DOWN                    0x0C
// ( void, void ) : internal
// This message is sent by the filter graph manager to any plug-in
// distributors which support IMediaEventSink to notify them that
// the filter graph is starting to shutdown.


#define EC_CLOCK_CHANGED                    0x0D
// ( void, void ) : application
// Notify application that the clock has changed.
// (i.e. SetSyncSource has been called on the filter graph and has been
// distributed successfully to the filters in the graph.)


#define EC_PAUSED                           0x0E
// ( HRESULT, void ) : application
// Notify application the previous pause request has completed


#define EC_OPENING_FILE	                    0x10
#define EC_BUFFERING_DATA                   0x11
// ( BOOL, void ) : application
// lParam1 == 1   --> starting to open file or buffer data
// lParam1 == 0   --> not opening or buffering any more
// (This event does not appear to be used by ActiveMovie.)


#define EC_FULLSCREEN_LOST                  0x12
// ( void, IBaseFilter * ) : application
// Sent by full screen renderers when switched away from full screen.
// IBaseFilter may be NULL.


#define EC_ACTIVATE                         0x13
// ( BOOL, IBaseFilter * ) : internal
// Sent by video renderers when they lose or gain activation.
// lParam1 is set to 1 if gained or 0 if lost
// lParam2 is the IBaseFilter* for the filter that is sending the message
// Used for sound follows focus and full-screen switching


#define EC_NEED_RESTART                     0x14
// ( void, void ) : defaulted
// Sent by renderers when they regain a resource (e.g. audio renderer).
// Causes a restart by Pause/put_Current/Run (if running).


#define EC_WINDOW_DESTROYED                 0x15
// ( IBaseFilter *, void ) : internal
// Sent by video renderers when the window has been destroyed. Handled
// by the filter graph / distributor telling the resource manager.
// lParam1 is the IBaseFilter* of the filter whose window is being destroyed


#define EC_DISPLAY_CHANGED                  0x16
// ( IPin *, void ) : internal
// Sent by renderers when they detect a display change. the filter graph
// will arrange for the graph to be stopped and the pin send in lParam1
// to be reconnected. by being reconnected it allows a renderer to reset
// and connect with a more appropriate format for the new display mode
// lParam1 contains an (IPin *) that should be reconnected by the graph


#define EC_STARVATION                       0x17
// ( void, void ) : defaulted
// Sent by a filter when it detects starvation. Default handling (only when
// running) is for the graph to be paused until all filters enter the
// paused state and then run. Normally this would be sent by a parser or source
// filter when too little data is arriving.


#define EC_OLE_EVENT			    0x18
// ( BSTR, BSTR ) : application
// Sent by a filter to pass a text string to the application.
// Conventionally, the first string is a type, and the second a parameter.


#define EC_NOTIFY_WINDOW                    0x19
// ( HWND, void ) : internal
// Pass the window handle around during pin connection.

#define EC_STREAM_CONTROL_STOPPED	    0x1A
// ( IPin * pSender, DWORD dwCookie )
// Notification that an earlier call to IAMStreamControl::StopAt
// has now take effect.  Calls to the method can be marked
// with a cookie which is passed back in the second parameter,
// allowing applications to easily tie together request
// and completion notifications.
//
// NB: IPin will point to the pin that actioned the Stop.  This
// may not be the pin that the StopAt was sent to.

#define EC_STREAM_CONTROL_STARTED	    0x1B
// ( IPin * pSender, DWORD dwCookie )
// Notification that an earlier call to IAMStreamControl::StartAt
// has now take effect.  Calls to the method can be marked
// with a cookie which is passed back in the second parameter,
// allowing applications to easily tie together request
// and completion notifications.
//
// NB: IPin will point to the pin that actioned the Start.  This
// may not be the pin that the StartAt was sent to.

#define EC_END_OF_SEGMENT                   0x1C
//
// ( const REFERENCE_TIME *pStreamTimeAtEndOfSegment, DWORD dwSegmentNumber )
//
// pStreamTimeAtEndOfSegment
//     pointer to the accumulated stream clock
//     time since the start of the segment - this is directly computable
//     as the sum of the previous and current segment durations (Stop - Start)
//     and the rate applied to each segment
//     The source add this time to the time within each segment to get
//     a total elapsed time
//
// dwSegmentNumber
//     Segment number - starts at 0
//
// Notifies that a segment end has been reached when the
// AM_SEEKING_Segment flags was set for IMediaSeeking::SetPositions
// Passes in an IMediaSeeking interface to allow the next segment
// to be defined by the application

#define EC_SEGMENT_STARTED                  0x1D
//
// ( const REFERENCE_TIME *pStreamTimeAtStartOfSegment, DWORD dwSegmentNumber)
//
// pStreamTimeAtStartOfSegment
//     pointer to the accumulated stream clock
//     time since the start of the segment - this is directly computable
//     as the sum of the previous segment durations (Stop - Start)
//     and the rate applied to each segment
//
// dwSegmentNumber
//     Segment number - starts at 0
//
// Notifies that a new segment has been started.
// This is sent synchronously by any entity that will issue
// EC_END_OF_SEGMENT when a new segment is started
// (See IMediaSeeking::SetPositions - AM_SEEKING_Segment flag)
// It is used to compute how many EC_END_OF_SEGMENT notifications
// to expect at the end of a segment and as a consitency check

#define EC_LENGTH_CHANGED                  0x1E
// (void, void)
// sent to indicate that the length of the "file" has changed

#define EC_DEVICE_LOST                     0x1f
// (IUnknown, 0)
//
// request window notification when the device is available again
// (through WM_DEVICECHANGED messages registered with
// RegisterDeviceNotification; see IAMDeviceRemoval interface)

#define EC_STEP_COMPLETE                      0x24
// (BOOL bCacelled, void)
// Step request complete
// if bCancelled is TRUE the step was cancelled.  This can happen
// if the application issued some control request or because there
// was a mode change etc etc


#define EC_SKIP_FRAMES                      0x25
// ( nFramesToSkip, void ) : internal
// Get the filter graph to seek accuratley.

#define EC_TIMECODE_AVAILABLE			0x30
// Sent by filter supporting timecode
// Param1 has a pointer to the sending object
// Param2 has the device ID of the sending object

#define EC_EXTDEVICE_MODE_CHANGE		0x31
// Sent by filter supporting IAMExtDevice
// Param1 has the new mode
// Param2 has the device ID of the sending object

#define EC_GRAPH_CHANGED                        0x50
// Sent by filter to notify interesting graph changes

#define EC_CLOCK_UNSET                      0x51
// ( void, void ) : application
// Used to notify the filter graph to unset the current graph clock.
// Has the affect of forcing the filter graph to reestablish the graph clock
// on the next Pause/Run (note that this is only used by ksproxy, when the pin 
// of a clock providing filter is disconnected)


//------------------------------------------
//
// WindowsMedia SDK filter-specific events:
// 
#define EC_WMT_EVENT_BASE                   0x0251
//
#define EC_WMT_INDEX_EVENT                  EC_WMT_EVENT_BASE
// WindowsMedia SDK-originated file indexing status, sent by WMSDK-based filters
//
// lParam1 is one of the enum WMT_STATUS messages listed below, sent by the WindowsMedia SDK 
// lParam2 is specific to the lParam event 
//
//     the following WMT_STATUS messages are sent for this event:
//         WMT_STARTED        - lParam2 is 0
//         WMT_CLOSED         - lParam2 is 0
//         WMT_INDEX_PROGRESS - lParam2 is a DWORD containing the progress percent complete
//
// end WMSDK-originated events
//-----------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\exchext.h ===
#ifndef EXCHEXT_H
#define EXCHEXT_H


/*
 *	E X C H E X T . H
 *
 *	Declarations of interfaces for providers of Microsoft Exchange
 *	client extensions. 
 *
 *  Copyright 1986-1996 Microsoft Corporation. All Rights Reserved.
 */


#ifndef BEGIN_INTERFACE
#define BEGIN_INTERFACE
#endif


/*
 *	C o n s t a n t s
 */


// SCODEs
#define EXCHEXT_S_NOCRITERIA	MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 1)
#define EXCHEXT_S_NOCHANGE		MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 2)

// Flag for Unicode strings
#define EXCHEXT_UNICODE					(0x80000000)

// Flag values for IExchExtCallback::GetVersion
#define EECBGV_GETBUILDVERSION			(0x00000001)
#define EECBGV_GETACTUALVERSION			(0x00000002)
#define EECBGV_GETVIRTUALVERSION		(0x00000004)

// Build version value for IExchExtCallback::GetVersion
#define EECBGV_BUILDVERSION_MAJOR		(0x000d0000)
#define EECBGV_BUILDVERSION_MAJOR_MASK	(0xFFFF0000)
#define EECBGV_BUILDVERSION_MINOR_MASK	(0x0000FFFF)

// Actual/Virtual version values for IExchExtCallback::GetVersion
#define EECBGV_MSEXCHANGE_WIN31			(0x01010000)
#define EECBGV_MSEXCHANGE_WIN95			(0x01020000)
#define EECBGV_MSEXCHANGE_WINNT			(0x01030000)
#define EECBGV_MSEXCHANGE_MAC			(0x01040000)
#define EECBGV_VERSION_PRODUCT_MASK		(0xFF000000)
#define EECBGV_VERSION_PLATFORM_MASK	(0x00FF0000)
#define EECBGV_VERSION_MAJOR_MASK		(0x0000FF00)
#define EECBGV_VERSION_MINOR_MASK		(0x000000FF)

// Flag values for IExchExtCallback::GetMenuPos
#define EECBGMP_RANGE					(0x00000001)

// Flag values for IExchExtCallback::GetNewMessageSite
#define EECBGNMS_MODAL					(0x00000001)

// Flag values for IExchExtCallback::ChooseFolder
#define EECBCF_GETNAME					(0x00000001)
#define EECBCF_HIDENEW					(0x00000002)
#define EECBCF_PREVENTROOT				(0x00000004)

// Extensibility contexts used with IExchExt::Install
#define EECONTEXT_SESSION				(0x00000001)
#define EECONTEXT_VIEWER				(0x00000002)
#define EECONTEXT_REMOTEVIEWER			(0x00000003)
#define EECONTEXT_SEARCHVIEWER			(0x00000004)
#define EECONTEXT_ADDRBOOK				(0x00000005)
#define EECONTEXT_SENDNOTEMESSAGE		(0x00000006)
#define EECONTEXT_READNOTEMESSAGE		(0x00000007)
#define EECONTEXT_SENDPOSTMESSAGE		(0x00000008)
#define EECONTEXT_READPOSTMESSAGE		(0x00000009)
#define EECONTEXT_READREPORTMESSAGE		(0x0000000A)
#define EECONTEXT_SENDRESENDMESSAGE		(0x0000000B)
#define EECONTEXT_PROPERTYSHEETS		(0x0000000C)
#define EECONTEXT_ADVANCEDCRITERIA		(0x0000000D)
#define EECONTEXT_TASK					(0x0000000E)

// Flag values for IExchExt::Install
#define EE_MODAL						(0x00000001)

// Toolbar ids used with IExchExtCommands::InstallCommands
#define EETBID_STANDARD					(0x00000001)

// Flag values for IExchExtCommands::QueryHelpText
#define EECQHT_STATUS					(0x00000001)
#define EECQHT_TOOLTIP					(0x00000002)

// Flag values for IExchExtMessageEvents::OnXComplete
#define EEME_FAILED						(0x00000001)
#define EEME_COMPLETE_FAILED			(0x00000002)

// Flag values for IExchExtAttachedFileEvents::OpenSzFile
#define EEAFE_OPEN						(0x00000001)
#define EEAFE_PRINT						(0x00000002)
#define EEAFE_QUICKVIEW					(0x00000003)

// Flag values for IExchExtPropertySheets methods
#define EEPS_MESSAGE					(0x00000001)
#define EEPS_FOLDER						(0x00000002)
#define EEPS_STORE						(0x00000003)
#define EEPS_TOOLSOPTIONS				(0x00000004)

// Flag values for IExchExtAdvancedCriteria::Install and ::SetFolder
#define EEAC_INCLUDESUBFOLDERS			(0x00000001)


/*
 *	S t r u c t u r e s
 */


// Hook procedure for IExchExtCallback::ChooseFolder
typedef UINT (STDAPICALLTYPE FAR * LPEECFHOOKPROC)(HWND, UINT, WPARAM, LPARAM);

// Dialog information for IExchExtCallback::ChooseFolder
typedef struct
{
	UINT cbLength;
	HWND hwnd;
	LPTSTR szCaption;
	LPTSTR szLabel;
	LPTSTR szHelpFile;
	ULONG ulHelpID;
	HINSTANCE hinst;
	UINT uiDlgID;
	LPEECFHOOKPROC lpeecfhp;
	DWORD dwHookData;
	ULONG ulFlags;
	LPMDB pmdb;
	LPMAPIFOLDER pfld;
	LPTSTR szName;
	DWORD dwReserved1;
	DWORD dwReserved2;
	DWORD dwReserved3;
}
EXCHEXTCHOOSEFOLDER, FAR * LPEXCHEXTCHOOSEFOLDER;

// Toolbar list entries for IExchExtCommands::InstallCommands
typedef struct
{
	HWND hwnd;
	ULONG tbid;
	ULONG ulFlags;
	UINT itbbBase;
}
TBENTRY, FAR * LPTBENTRY;


/*
 *	E x t e r n a l   T y p e s
 */


// Property sheet pages from Windows 95 prsht.h
#ifndef _PRSHT_H_
typedef struct _PROPSHEETPAGE;
typedef struct _PROPSHEETPAGE FAR * LPPROPSHEETPAGE;
#endif

// Toolbar adjust info from Windows 95 commctrl.h
#ifndef _INC_COMMCTRL
typedef struct _TBBUTTON;
typedef struct _TBBUTTON FAR * LPTBBUTTON;
#endif


/*
 *	S u p p o r t   I n t e r f a c e s
 */


// Forward reference
#ifdef __cplusplus
interface IExchExtModeless;
#else
typedef interface IExchExtModeless IExchExtModeless;
#endif 
typedef IExchExtModeless FAR* LPEXCHEXTMODELESS;


/*
 *  IExchExtModelessCallback
 *
 *  Purpose:
 *      Interface which may be used by Exchange client
 *      extensions that create modeless UI.
 */
#undef INTERFACE
#define INTERFACE   IExchExtModelessCallback
DECLARE_INTERFACE_(IExchExtModelessCallback, IUnknown)
{
	BEGIN_INTERFACE

	// *** IUnknown methods ***
	STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * lppvObj) PURE;
	STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
	STDMETHOD_(ULONG,Release) (THIS) PURE;
  
	// *** IExchExtModelessCallback methods ***
	STDMETHOD(EnableModeless) (THIS_ HWND hwnd, BOOL fEnable) PURE;
	STDMETHOD(AddWindow) (THIS) PURE;
	STDMETHOD(ReleaseWindow) (THIS) PURE;
};
typedef IExchExtModelessCallback FAR * LPEXCHEXTMODELESSCALLBACK;


/*
 *	IExchExtCallback
 *
 *	Purpose:
 *		Resource interface that may be used by Exchange client extensions.
 */
#undef INTERFACE
#define INTERFACE   IExchExtCallback

DECLARE_INTERFACE_(IExchExtCallback, IUnknown)
{
	BEGIN_INTERFACE

    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * lppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IExchExtCallback methods ***
	STDMETHOD(GetVersion) (THIS_ ULONG FAR * lpulVersion, ULONG ulFlags) PURE;
    STDMETHOD(GetWindow) (THIS_ HWND FAR * lphwnd) PURE;
    STDMETHOD(GetMenu) (THIS_ HMENU FAR * lphmenu) PURE;
    STDMETHOD(GetToolbar) (THIS_ ULONG tbid, HWND FAR * lphwndTb) PURE;
    STDMETHOD(GetSession) (THIS_ LPMAPISESSION FAR * lppses, 
    					   LPADRBOOK FAR * lppab) PURE;
    STDMETHOD(GetObject) (THIS_ LPMDB FAR * lppmdb, 
    					  LPMAPIPROP FAR * lppmp) PURE;
    STDMETHOD(GetSelectionCount) (THIS_ ULONG FAR * lpceid) PURE;
    STDMETHOD(GetSelectionItem) (THIS_ ULONG ieid, ULONG FAR * lpcbEid,
	    						 LPENTRYID FAR * lppeid, ULONG FAR * lpulType,
	    						 LPTSTR lpszMsgClass, ULONG cbMsgClass,
	    						 ULONG FAR * lpulMsgFlags, ULONG ulFlags) PURE;
	STDMETHOD(GetMenuPos) (THIS_ ULONG cmdid, HMENU FAR * lphmenu,
						   ULONG FAR * lpmposMin, ULONG FAR * lpmposMax,
						   ULONG ulFlags) PURE;
	STDMETHOD(GetSharedExtsDir) (THIS_ LPTSTR lpszDir, ULONG cchDir, 
								 ULONG ulFlags) PURE;
	STDMETHOD(GetRecipients) (THIS_ LPADRLIST FAR * lppal) PURE;
	STDMETHOD(SetRecipients) (THIS_ LPADRLIST lpal) PURE;
	STDMETHOD(GetNewMessageSite) (THIS_ ULONG fComposeInFolder,
								  LPMAPIFOLDER pfldFocus,
								  LPPERSISTMESSAGE ppermsg,
								  LPMESSAGE FAR * ppmsg,
								  LPMAPIMESSAGESITE FAR * ppmms,
								  LPMAPIVIEWCONTEXT FAR * ppmvc,
								  ULONG ulFlags) PURE;
	STDMETHOD(RegisterModeless) (THIS_ LPEXCHEXTMODELESS peem,
								 LPEXCHEXTMODELESSCALLBACK FAR * ppeemcb) PURE;
	STDMETHOD(ChooseFolder) (THIS_ LPEXCHEXTCHOOSEFOLDER peecf) PURE;
};
typedef IExchExtCallback FAR * LPEXCHEXTCALLBACK;


/*
 *	E x t e n s i o n   I n t e r f a c e s
 */


/*
 *	IExchExt
 *
 *	Purpose:
 *		Central interface implemented by Exchange client extensions.
 */
#undef INTERFACE
#define INTERFACE   IExchExt

DECLARE_INTERFACE_(IExchExt, IUnknown)
{
	BEGIN_INTERFACE

    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * lppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS) PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IExchExt methods ***
    STDMETHOD(Install) (THIS_ LPEXCHEXTCALLBACK lpeecb, 
    					ULONG mecontext, ULONG ulFlags) PURE;
};
typedef IExchExt FAR * LPEXCHEXT;

// Type of function called by the client to load an extension
typedef LPEXCHEXT (CALLBACK * LPFNEXCHEXTENTRY)(VOID);


/*
 *	IExchExtCommands
 *
 *	Purpose:
 *		Interface implemented by Exchange client extensions that wish to
 *		add additional commands to the client's menus.
 */
#undef INTERFACE
#define INTERFACE   IExchExtCommands

DECLARE_INTERFACE_(IExchExtCommands, IUnknown)
{
	BEGIN_INTERFACE

    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * lppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS) PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IExchExtCommands methods ***
	STDMETHOD(InstallCommands) (THIS_ LPEXCHEXTCALLBACK lpeecb, HWND hwnd, 
								HMENU hmenu, UINT FAR * lpcmdidBase, 
								LPTBENTRY lptbeArray, UINT ctbe, 
								ULONG ulFlags) PURE;
	STDMETHOD_(VOID,InitMenu) (THIS_ LPEXCHEXTCALLBACK lpeecb) PURE;
	STDMETHOD(DoCommand) (THIS_ LPEXCHEXTCALLBACK lpeecb, UINT cmdid) PURE;
	STDMETHOD(Help) (THIS_ LPEXCHEXTCALLBACK lpeecb, UINT cmdid) PURE;
	STDMETHOD(QueryHelpText) (THIS_ UINT cmdid, ULONG ulFlags,
							  LPTSTR lpsz, UINT cch) PURE;
	STDMETHOD(QueryButtonInfo) (THIS_ ULONG tbid, UINT itbb, LPTBBUTTON ptbb,
								LPTSTR lpsz, UINT cch, ULONG ulFlags) PURE;
	STDMETHOD(ResetToolbar) (THIS_ ULONG tbid, ULONG ulFlags) PURE;
};
typedef IExchExtCommands FAR * LPEXCHEXTCOMMANDS;


/*
 *	IExchExtUserEvents
 *
 *	Purpose:
 *		Interface implemented by Exchange client extensions that wish to
 *		take special action when the user does certain actions.
 */
#undef INTERFACE
#define INTERFACE   IExchExtUserEvents

DECLARE_INTERFACE_(IExchExtUserEvents, IUnknown)
{
	BEGIN_INTERFACE

    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * lppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IExchExtUserEvents methods ***
	STDMETHOD_(VOID,OnSelectionChange) (THIS_ LPEXCHEXTCALLBACK lpeecb) PURE;
	STDMETHOD_(VOID,OnObjectChange) (THIS_ LPEXCHEXTCALLBACK lpeecb) PURE;
};
typedef IExchExtUserEvents FAR * LPEXCHEXTUSEREVENTS;


/*
 *	IExchExtSessionEvents
 *
 *	Purpose:
 *		Interface implemented by Exchange client extensions that wish to
 *		take special action when certain events happen in the session.
 */
#undef INTERFACE
#define INTERFACE   IExchExtSessionEvents

DECLARE_INTERFACE_(IExchExtSessionEvents, IUnknown)
{
	BEGIN_INTERFACE

    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * lppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IExchExtEvents methods ***
	STDMETHOD(OnDelivery)(THIS_ LPEXCHEXTCALLBACK lpeecb) PURE;
};
typedef IExchExtSessionEvents FAR * LPEXCHEXTSESSIONEVENTS;


/*
 *	IExchExtMessageEvents
 *
 *	Purpose:
 *		Interface implemented by Exchange client extensions that wish to
 *		take special action when certain events happen to messages.
 */
#undef INTERFACE
#define INTERFACE   IExchExtMessageEvents

DECLARE_INTERFACE_(IExchExtMessageEvents, IUnknown)
{
	BEGIN_INTERFACE

    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * lppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IExchExtMessageEvents methods ***
	STDMETHOD(OnRead)(THIS_ LPEXCHEXTCALLBACK lpeecb) PURE;
	STDMETHOD(OnReadComplete)(THIS_ LPEXCHEXTCALLBACK lpeecb, 
							  ULONG ulFlags) PURE;
	STDMETHOD(OnWrite)(THIS_ LPEXCHEXTCALLBACK lpeecb) PURE;
	STDMETHOD(OnWriteComplete)(THIS_ LPEXCHEXTCALLBACK lpeecb, 
							   ULONG ulFlags) PURE;
	STDMETHOD(OnCheckNames)(THIS_ LPEXCHEXTCALLBACK lpeecb) PURE;
	STDMETHOD(OnCheckNamesComplete)(THIS_ LPEXCHEXTCALLBACK lpeecb, 
									ULONG ulFlags) PURE;
	STDMETHOD(OnSubmit)(THIS_ LPEXCHEXTCALLBACK lpeecb) PURE;
	STDMETHOD_(VOID, OnSubmitComplete)(THIS_ LPEXCHEXTCALLBACK lpeecb, 
									   ULONG ulFlags) PURE;
};
typedef IExchExtMessageEvents FAR * LPEXCHEXTMESSAGEEVENTS;


/*
 *	IExchExtAttachedFileEvents
 *
 *	Purpose:
 *		Interface implemented by Exchange client extensions that wish to
 *		take special action when certain events happen to attached files.
 */
#undef INTERFACE
#define INTERFACE   IExchExtAttachedFileEvents

DECLARE_INTERFACE_(IExchExtAttachedFileEvents, IUnknown)
{
	BEGIN_INTERFACE

    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * lppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IExchExtAttachedFileEvents methods ***
	STDMETHOD(OnReadPattFromSzFile)(THIS_ LPATTACH lpatt, LPTSTR lpszFile,
									ULONG ulFlags) PURE;
	STDMETHOD(OnWritePattToSzFile)(THIS_ LPATTACH lpatt, LPTSTR lpszFile,
								   ULONG ulFlags) PURE;
	STDMETHOD(QueryDisallowOpenPatt)(THIS_ LPATTACH lpatt) PURE;
	STDMETHOD(OnOpenPatt)(THIS_ LPATTACH lpatt) PURE;
	STDMETHOD(OnOpenSzFile)(THIS_ LPTSTR lpszFile, ULONG ulFlags) PURE;
};
typedef IExchExtAttachedFileEvents FAR * LPEXCHEXTATTACHEDFILEEVENTS;


/*
 *	IExchExtPropertySheets
 *
 *	Purpose:
 *		Interface implemented by Exchange client extensions that wish
 *		to add additional pages to the client's object property sheets.
 */
#undef INTERFACE
#define INTERFACE   IExchExtPropertySheets

DECLARE_INTERFACE_(IExchExtPropertySheets, IUnknown)
{
	BEGIN_INTERFACE

    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * lppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IExchExtPropertySheet methods ***
	STDMETHOD_(ULONG,GetMaxPageCount) (THIS_ ULONG ulFlags) PURE;
	STDMETHOD(GetPages) (THIS_ LPEXCHEXTCALLBACK lpeecb, ULONG ulFlags,
						 LPPROPSHEETPAGE lppsp, ULONG FAR * lpcpsp) PURE;
	STDMETHOD_(VOID,FreePages) (THIS_ LPPROPSHEETPAGE lppsp, 
								ULONG ulFlags, ULONG cpsp) PURE;
};
typedef IExchExtPropertySheets FAR * LPEXCHEXTPROPERTYSHEETS;


/*
 *	IExchExtAdvancedCriteria
 *
 *	Purpose:
 *		Interface implemented by Exchange client extensions that wish to
 *		implement an advanced criteria dialog.
 */
#undef INTERFACE
#define INTERFACE   IExchExtAdvancedCriteria

DECLARE_INTERFACE_(IExchExtAdvancedCriteria, IUnknown)
{
	BEGIN_INTERFACE

    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * lppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IExchExtAdvancedCriteria methods ***
	STDMETHOD(InstallAdvancedCriteria) (THIS_ HWND hwnd, LPSRestriction lpres, 
										BOOL fNot, LPENTRYLIST lpeidl, 
										ULONG ulFlags) PURE;
	STDMETHOD(DoDialog) (THIS) PURE;
	STDMETHOD_(VOID,Clear) (THIS) PURE;
	STDMETHOD_(VOID,SetFolders) (THIS_ LPENTRYLIST lpeidl, ULONG ulFlags) PURE;
	STDMETHOD(QueryRestriction) (THIS_ LPVOID lpvAllocBase, 
								 LPSRestriction FAR * lppres,
								 LPSPropTagArray FAR * lppPropTags,
								 LPMAPINAMEID FAR * FAR * lpppPropNames,
								 BOOL * lpfNot, LPTSTR lpszDesc, ULONG cchDesc, 
								 ULONG ulFlags) PURE;
	STDMETHOD_(VOID,UninstallAdvancedCriteria) (THIS) PURE;
};
typedef IExchExtAdvancedCriteria FAR * LPEXCHEXTADVANCEDCRITERIA;


/*
 *  IExchExtModeless
 *
 *	Purpose:
 *		Interface implemented by Exchange client extensions that wish
 *		to create modeless UI.
 */
#undef INTERFACE
#define INTERFACE   IExchExtModeless

DECLARE_INTERFACE_(IExchExtModeless, IUnknown)
{
	BEGIN_INTERFACE

	// *** IUnknown methods ***
	STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * lppvObj) PURE;
	STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
	STDMETHOD_(ULONG,Release) (THIS) PURE;

	// *** IExchExtModeless methods ***
	STDMETHOD(TranslateAccelerator) (THIS_ LPMSG pmsg) PURE;
	STDMETHOD(EnableModeless) (THIS_ BOOL fEnable) PURE;
};


/*
 *	G U I D s
 */


#define DEFINE_EXCHEXTGUID(name, b) \
    DEFINE_GUID(name, 0x00020D00 | (b), 0, 0, 0xC0,0,0,0,0,0,0,0x46)

#ifndef NOEXCHEXTGUIDS
DEFINE_EXCHEXTGUID(IID_IExchExtCallback,			0x10);
DEFINE_EXCHEXTGUID(IID_IExchExt,					0x11);
DEFINE_EXCHEXTGUID(IID_IExchExtCommands,			0x12);
DEFINE_EXCHEXTGUID(IID_IExchExtUserEvents,			0x13);
DEFINE_EXCHEXTGUID(IID_IExchExtSessionEvents,		0x14);
DEFINE_EXCHEXTGUID(IID_IExchExtMessageEvents,		0x15);
DEFINE_EXCHEXTGUID(IID_IExchExtAttachedFileEvents,	0x16);
DEFINE_EXCHEXTGUID(IID_IExchExtPropertySheets,		0x17);
DEFINE_EXCHEXTGUID(IID_IExchExtAdvancedCriteria,	0x18);
DEFINE_EXCHEXTGUID(IID_IExchExtModeless,			0x19);
DEFINE_EXCHEXTGUID(IID_IExchExtModelessCallback,	0x1a);
#endif // NOEXCHEXTGUIDS


/*
 *	C M D I D s
 */


// File
#define EECMDID_File								10
#define EECMDID_FileOpen							11
#define EECMDID_FileSend							12
#define EECMDID_FileSave             				13
#define EECMDID_FileSaveAs							14
#define EECMDID_FileMove      						16
#define EECMDID_FileCopy	      					17
#define EECMDID_FilePrint							25
#define EECMDID_FileNewEntry						18
#define EECMDID_FileNewMessage						19
#define EECMDID_FileNewFolder						20
#define EECMDID_FileAddToPAB						29
#define EECMDID_FileDelete							21
#define EECMDID_FileRename							22
#define EECMDID_FileProperties						23
#define EECMDID_FilePropertiesRecipients			24
#define EECMDID_FileClose            				30
#define EECMDID_FileExit							32
#define EECMDID_FileExitAndLogOff					33

// Edit
#define EECMDID_Edit                    			40
#define EECMDID_EditUndo                			41
#define EECMDID_EditCut                 			42
#define EECMDID_EditCopy                			43
#define EECMDID_EditPaste       					44
#define EECMDID_EditPasteSpecial   					45
#define EECMDID_EditSelectAll           			46
#define	EECMDID_EditMarkAsRead						49
#define EECMDID_EditMarkAsUnread					50
#define EECMDID_EditMarkToRetrieve					52
#define EECMDID_EditMarkToRetrieveACopy				53
#define EECMDID_EditMarkToDelete					54
#define EECMDID_EditUnmarkAll						55
#define EECMDID_EditFind                			56
#define EECMDID_EditReplace             			57
#define EECMDID_EditLinks               			59
#define EECMDID_EditObject              			60
#define EECMDID_EditObjectConvert					61
#ifdef DBCS
#define	EECMDID_EditFullShape						62
#define	EECMDID_EditHiraKataAlpha					63
#define	EECMDID_EditHangAlpha						64
#define	EECMDID_EditHanja							65
#define	EECMDID_EditRoman							66
#define	EECMDID_EditCode							67	
#endif

// View
#define EECMDID_View                    			70
#define EECMDID_ViewFolders             			71
#define EECMDID_ViewToolbar             			72
#define EECMDID_ViewFormattingToolbar   			73
#define EECMDID_ViewStatusBar           			74
#define EECMDID_ViewNewWindow						75
#define EECMDID_ViewColumns							79
#define EECMDID_ViewSort							78
#define EECMDID_ViewFilter							80
#define EECMDID_ViewBccBox              			91
#define EECMDID_ViewPrevious           				87
#define EECMDID_ViewNext           					88
#ifdef DBCS											
#define EECMDID_ViewWritingMode						89
#define EECMDID_ViewImeStatus						94
#endif
													
// Insert											
#define EECMDID_Insert                  			100
#define EECMDID_InsertFile							101
#define EECMDID_InsertMessage						102
#define EECMDID_InsertObject            			103
#define EECMDID_InsertInkObject						104
													
// Format											
#define EECMDID_Format                  			110
#define EECMDID_FormatFont              			111
#define EECMDID_FormatParagraph         			112
													
// Tools											
#define EECMDID_Tools								120
#define EECMDID_ToolsDeliverNowUsing				121
#define EECMDID_ToolsDeliverNow						122
#define EECMDID_ToolsSpelling	        			131
#define EECMDID_ToolsAddressBook					123
#define EECMDID_ToolsCheckNames         			133
#define EECMDID_ToolsFind							124
#define EECMDID_ToolsConnect						126
#define EECMDID_ToolsUpdateHeaders					127
#define EECMDID_ToolsTransferMail					128
#define EECMDID_ToolsDisconnect						129
#define EECMDID_ToolsRemoteMail						130
#define EECMDID_ToolsCustomizeToolbar				134
#define EECMDID_ToolsServices						135
#define EECMDID_ToolsOptions						136
#ifdef DBCS											
#define	EECMDID_ToolsWordRegistration				137
#endif												
													
// Compose											
#define EECMDID_Compose								150
#define EECMDID_ComposeNewMessage					151
#define EECMDID_ComposeReplyToSender				154
#define EECMDID_ComposeReplyToAll					155
#define EECMDID_ComposeForward						156
													
// Help
#define EECMDID_Help								160
#define EECMDID_HelpMicrosoftExchangeHelpTopics		161
#define EECMDID_HelpAboutMicrosoftExchange			162

// Header											
#define EECMDID_CtxHeader							203
#define EECMDID_CtxHeaderSortAscending				204
#define EECMDID_CtxHeaderSortDescending				205
													
// In Folder										
#define EECMDID_CtxInFolder							206
#define EECMDID_CtxInFolderChoose					207
													
// Container										
#define EECMDID_CtxContainer						208
#define EECMDID_CtxContainerProperties				209

// Standard Toolbar
#define EECMDID_Toolbar								220
#define EECMDID_ToolbarPrint            			221
#define EECMDID_ToolbarReadReceipt					222
#define EECMDID_ToolbarImportanceHigh				223
#define EECMDID_ToolbarImportanceLow				224
#define EECMDID_ToolbarFolderList					225
#define EECMDID_ToolbarOpenParent					226
#define EECMDID_ToolbarInbox						76
#define EECMDID_ToolbarOutbox						77

// Formatting Toolbar
#define EECMDID_Formatting							230
#define EECMDID_FormattingFont						231
#define EECMDID_FormattingSize						232
#define EECMDID_FormattingColor						233
#define EECMDID_FormattingColorAuto					234
#define EECMDID_FormattingColor1					235
#define EECMDID_FormattingColor2					236
#define EECMDID_FormattingColor3					237
#define EECMDID_FormattingColor4					238
#define EECMDID_FormattingColor5					239
#define EECMDID_FormattingColor6					240
#define EECMDID_FormattingColor7					241
#define EECMDID_FormattingColor8					242
#define EECMDID_FormattingColor9					243
#define EECMDID_FormattingColor10					244
#define EECMDID_FormattingColor11					245
#define EECMDID_FormattingColor12					246
#define EECMDID_FormattingColor13					247
#define EECMDID_FormattingColor14					248
#define EECMDID_FormattingColor15					249
#define EECMDID_FormattingColor16					250
#define EECMDID_FormattingBold						251
#define EECMDID_FormattingItalic					252
#define EECMDID_FormattingUnderline					253
#define EECMDID_FormattingBullets					254
#define EECMDID_FormattingDecreaseIndent			255
#define EECMDID_FormattingIncreaseIndent			256
#define EECMDID_FormattingLeft						257
#define EECMDID_FormattingCenter					258
#define EECMDID_FormattingRight						259

// Note accelerators
#define EECMDID_Accel								270
#define EECMDID_AccelFont							271
#define EECMDID_AccelSize							272
#define EECMDID_AccelSizePlus1						273
#define EECMDID_AccelSizeMinus1						274
#define EECMDID_AccelBold							275
#define EECMDID_AccelItalic							276
#define EECMDID_AccelUnderline						277
#define EECMDID_AccelLeft							278
#define EECMDID_AccelCenter							279
#define EECMDID_AccelRight							280
#define EECMDID_AccelBullets						281
#define EECMDID_AccelNoFormatting					282
#define EECMDID_AccelRepeatFind						283
#define EECMDID_AccelContextHelp					284
#define EECMDID_AccelNextWindow						285
#define EECMDID_AccelPrevWindow						286
#define EECMDID_AccelCtrlTab						287
#define EECMDID_AccelUndo							288
#define EECMDID_AccelCut							289
#define EECMDID_AccelCopy							290
#define EECMDID_AccelPaste							291
#define EECMDID_AccelSubject						292
#define EECMDID_AccelContextHelpOff					293
#define EECMDID_AccelDecreaseIndent					294
#define EECMDID_AccelIncreaseIndent					295
#define EECMDID_AccelColor							296

// Edit.Object
#define EECMDID_ObjectMin							300
#define EECMDID_ObjectMax							399

// Tools.Remote Mail
#define EECMDID_RemoteMailMin						600
#define EECMDID_RemoteMailMax						699

// Tools.Deliver Now Using
#define EECMDID_DeliverNowUsingMin					700
#define EECMDID_DeliverNowUsingMax					799

// Form verbs
#define EECMDID_FormVerbMin							800
#define EECMDID_FormVerbMax							899

// For backward compatibility with earlier header versions
#define EECMDID_ViewInbox				EECMDID_ToolbarInbox
#define EECMDID_ViewOutbox				EECMDID_ToolbarOutbox
#define EECMDID_ViewItemAbove			EECMDID_ViewPrevious
#define EECMDID_ViewItemBelow           EECMDID_ViewNext
#define EECMDID_ToolsFindItem			EECMDID_ToolsFind
#define EECMDID_HelpUsersGuideContents	EECMDID_HelpMicrosoftExchangeHelpTopics
#define EECMDID_HelpAbout				EECMDID_HelpAboutMicrosoftExchange

#endif // EXCHEXT_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\eventcpts.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.01.75 */
/* at Thu Sep 11 16:03:12 1997
 */
/* Compiler settings for eventcpts.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __eventcpts_h__
#define __eventcpts_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IMtsUserEvent_FWD_DEFINED__
#define __IMtsUserEvent_FWD_DEFINED__
typedef interface IMtsUserEvent IMtsUserEvent;
#endif 	/* __IMtsUserEvent_FWD_DEFINED__ */


#ifndef __IMtsThreadEvents_FWD_DEFINED__
#define __IMtsThreadEvents_FWD_DEFINED__
typedef interface IMtsThreadEvents IMtsThreadEvents;
#endif 	/* __IMtsThreadEvents_FWD_DEFINED__ */


#ifndef __IMtsPackageEvents_FWD_DEFINED__
#define __IMtsPackageEvents_FWD_DEFINED__
typedef interface IMtsPackageEvents IMtsPackageEvents;
#endif 	/* __IMtsPackageEvents_FWD_DEFINED__ */


#ifndef __IMtsInstanceEvents_FWD_DEFINED__
#define __IMtsInstanceEvents_FWD_DEFINED__
typedef interface IMtsInstanceEvents IMtsInstanceEvents;
#endif 	/* __IMtsInstanceEvents_FWD_DEFINED__ */


#ifndef __IMtsTransactionEvents_FWD_DEFINED__
#define __IMtsTransactionEvents_FWD_DEFINED__
typedef interface IMtsTransactionEvents IMtsTransactionEvents;
#endif 	/* __IMtsTransactionEvents_FWD_DEFINED__ */


#ifndef __IMtsMethodEvents_FWD_DEFINED__
#define __IMtsMethodEvents_FWD_DEFINED__
typedef interface IMtsMethodEvents IMtsMethodEvents;
#endif 	/* __IMtsMethodEvents_FWD_DEFINED__ */


#ifndef __IMtsObjectEvents_FWD_DEFINED__
#define __IMtsObjectEvents_FWD_DEFINED__
typedef interface IMtsObjectEvents IMtsObjectEvents;
#endif 	/* __IMtsObjectEvents_FWD_DEFINED__ */


#ifndef __IMtsResourceEvents_FWD_DEFINED__
#define __IMtsResourceEvents_FWD_DEFINED__
typedef interface IMtsResourceEvents IMtsResourceEvents;
#endif 	/* __IMtsResourceEvents_FWD_DEFINED__ */


#ifndef __IMtsSecurityEvents_FWD_DEFINED__
#define __IMtsSecurityEvents_FWD_DEFINED__
typedef interface IMtsSecurityEvents IMtsSecurityEvents;
#endif 	/* __IMtsSecurityEvents_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/****************************************
 * Generated header for interface: __MIDL_itf_eventcpts_0000
 * at Thu Sep 11 16:03:12 1997
 * using MIDL 3.01.75
 ****************************************/
/* [local] */ 


typedef ULONG MTS_OBJID;

typedef ULONG MTS_RESID;



extern RPC_IF_HANDLE __MIDL_itf_eventcpts_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_eventcpts_0000_v0_0_s_ifspec;

#ifndef __IMtsUserEvent_INTERFACE_DEFINED__
#define __IMtsUserEvent_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IMtsUserEvent
 * at Thu Sep 11 16:03:12 1997
 * using MIDL 3.01.75
 ****************************************/
/* [uuid][object] */ 



EXTERN_C const IID IID_IMtsUserEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("D56C3DC0-8482-11d0-B170-00AA00BA3258")
    IMtsUserEvent : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnUserEvent( 
            /* [in] */ LONGLONG perfCount,
            /* [in] */ VARIANT __RPC_FAR *pvarEvent) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMtsUserEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMtsUserEvent __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMtsUserEvent __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMtsUserEvent __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnUserEvent )( 
            IMtsUserEvent __RPC_FAR * This,
            /* [in] */ LONGLONG perfCount,
            /* [in] */ VARIANT __RPC_FAR *pvarEvent);
        
        END_INTERFACE
    } IMtsUserEventVtbl;

    interface IMtsUserEvent
    {
        CONST_VTBL struct IMtsUserEventVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMtsUserEvent_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMtsUserEvent_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMtsUserEvent_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMtsUserEvent_OnUserEvent(This,perfCount,pvarEvent)	\
    (This)->lpVtbl -> OnUserEvent(This,perfCount,pvarEvent)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMtsUserEvent_OnUserEvent_Proxy( 
    IMtsUserEvent __RPC_FAR * This,
    /* [in] */ LONGLONG perfCount,
    /* [in] */ VARIANT __RPC_FAR *pvarEvent);


void __RPC_STUB IMtsUserEvent_OnUserEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMtsUserEvent_INTERFACE_DEFINED__ */


#ifndef __IMtsThreadEvents_INTERFACE_DEFINED__
#define __IMtsThreadEvents_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IMtsThreadEvents
 * at Thu Sep 11 16:03:12 1997
 * using MIDL 3.01.75
 ****************************************/
/* [uuid][object] */ 



EXTERN_C const IID IID_IMtsThreadEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("BACEDF4F-74AB-11D0-B162-00AA00BA3258")
    IMtsThreadEvents : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnThreadStart( 
            /* [in] */ LONGLONG perfCount,
            /* [in] */ ULONG ThreadID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnThreadTerminate( 
            /* [in] */ LONGLONG perfCount,
            /* [in] */ ULONG ThreadID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnThreadAssignToActivity( 
            /* [in] */ LONGLONG perfCount,
            /* [in] */ REFGUID guidActivity,
            /* [in] */ ULONG ThreadID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnThreadUnassignFromActivity( 
            /* [in] */ LONGLONG perfCount,
            /* [in] */ REFGUID guidActivity,
            /* [in] */ ULONG ThreadID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMtsThreadEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMtsThreadEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMtsThreadEvents __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMtsThreadEvents __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnThreadStart )( 
            IMtsThreadEvents __RPC_FAR * This,
            /* [in] */ LONGLONG perfCount,
            /* [in] */ ULONG ThreadID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnThreadTerminate )( 
            IMtsThreadEvents __RPC_FAR * This,
            /* [in] */ LONGLONG perfCount,
            /* [in] */ ULONG ThreadID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnThreadAssignToActivity )( 
            IMtsThreadEvents __RPC_FAR * This,
            /* [in] */ LONGLONG perfCount,
            /* [in] */ REFGUID guidActivity,
            /* [in] */ ULONG ThreadID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnThreadUnassignFromActivity )( 
            IMtsThreadEvents __RPC_FAR * This,
            /* [in] */ LONGLONG perfCount,
            /* [in] */ REFGUID guidActivity,
            /* [in] */ ULONG ThreadID);
        
        END_INTERFACE
    } IMtsThreadEventsVtbl;

    interface IMtsThreadEvents
    {
        CONST_VTBL struct IMtsThreadEventsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMtsThreadEvents_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMtsThreadEvents_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMtsThreadEvents_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMtsThreadEvents_OnThreadStart(This,perfCount,ThreadID)	\
    (This)->lpVtbl -> OnThreadStart(This,perfCount,ThreadID)

#define IMtsThreadEvents_OnThreadTerminate(This,perfCount,ThreadID)	\
    (This)->lpVtbl -> OnThreadTerminate(This,perfCount,ThreadID)

#define IMtsThreadEvents_OnThreadAssignToActivity(This,perfCount,guidActivity,ThreadID)	\
    (This)->lpVtbl -> OnThreadAssignToActivity(This,perfCount,guidActivity,ThreadID)

#define IMtsThreadEvents_OnThreadUnassignFromActivity(This,perfCount,guidActivity,ThreadID)	\
    (This)->lpVtbl -> OnThreadUnassignFromActivity(This,perfCount,guidActivity,ThreadID)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMtsThreadEvents_OnThreadStart_Proxy( 
    IMtsThreadEvents __RPC_FAR * This,
    /* [in] */ LONGLONG perfCount,
    /* [in] */ ULONG ThreadID);


void __RPC_STUB IMtsThreadEvents_OnThreadStart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMtsThreadEvents_OnThreadTerminate_Proxy( 
    IMtsThreadEvents __RPC_FAR * This,
    /* [in] */ LONGLONG perfCount,
    /* [in] */ ULONG ThreadID);


void __RPC_STUB IMtsThreadEvents_OnThreadTerminate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMtsThreadEvents_OnThreadAssignToActivity_Proxy( 
    IMtsThreadEvents __RPC_FAR * This,
    /* [in] */ LONGLONG perfCount,
    /* [in] */ REFGUID guidActivity,
    /* [in] */ ULONG ThreadID);


void __RPC_STUB IMtsThreadEvents_OnThreadAssignToActivity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMtsThreadEvents_OnThreadUnassignFromActivity_Proxy( 
    IMtsThreadEvents __RPC_FAR * This,
    /* [in] */ LONGLONG perfCount,
    /* [in] */ REFGUID guidActivity,
    /* [in] */ ULONG ThreadID);


void __RPC_STUB IMtsThreadEvents_OnThreadUnassignFromActivity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMtsThreadEvents_INTERFACE_DEFINED__ */


#ifndef __IMtsPackageEvents_INTERFACE_DEFINED__
#define __IMtsPackageEvents_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IMtsPackageEvents
 * at Thu Sep 11 16:03:12 1997
 * using MIDL 3.01.75
 ****************************************/
/* [uuid][object] */ 



EXTERN_C const IID IID_IMtsPackageEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("BACEDF50-74AB-11D0-B162-00AA00BA3258")
    IMtsPackageEvents : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnPackageActivation( 
            /* [in] */ LONGLONG perfCount,
            /* [in] */ REFGUID guidPackage,
            /* [in] */ LPCOLESTR sPackageName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnPackageShutdown( 
            /* [in] */ LONGLONG perfCount,
            /* [in] */ REFGUID guidPackage,
            /* [in] */ LPCOLESTR sPackageName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMtsPackageEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMtsPackageEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMtsPackageEvents __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMtsPackageEvents __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnPackageActivation )( 
            IMtsPackageEvents __RPC_FAR * This,
            /* [in] */ LONGLONG perfCount,
            /* [in] */ REFGUID guidPackage,
            /* [in] */ LPCOLESTR sPackageName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnPackageShutdown )( 
            IMtsPackageEvents __RPC_FAR * This,
            /* [in] */ LONGLONG perfCount,
            /* [in] */ REFGUID guidPackage,
            /* [in] */ LPCOLESTR sPackageName);
        
        END_INTERFACE
    } IMtsPackageEventsVtbl;

    interface IMtsPackageEvents
    {
        CONST_VTBL struct IMtsPackageEventsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMtsPackageEvents_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMtsPackageEvents_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMtsPackageEvents_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMtsPackageEvents_OnPackageActivation(This,perfCount,guidPackage,sPackageName)	\
    (This)->lpVtbl -> OnPackageActivation(This,perfCount,guidPackage,sPackageName)

#define IMtsPackageEvents_OnPackageShutdown(This,perfCount,guidPackage,sPackageName)	\
    (This)->lpVtbl -> OnPackageShutdown(This,perfCount,guidPackage,sPackageName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMtsPackageEvents_OnPackageActivation_Proxy( 
    IMtsPackageEvents __RPC_FAR * This,
    /* [in] */ LONGLONG perfCount,
    /* [in] */ REFGUID guidPackage,
    /* [in] */ LPCOLESTR sPackageName);


void __RPC_STUB IMtsPackageEvents_OnPackageActivation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMtsPackageEvents_OnPackageShutdown_Proxy( 
    IMtsPackageEvents __RPC_FAR * This,
    /* [in] */ LONGLONG perfCount,
    /* [in] */ REFGUID guidPackage,
    /* [in] */ LPCOLESTR sPackageName);


void __RPC_STUB IMtsPackageEvents_OnPackageShutdown_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMtsPackageEvents_INTERFACE_DEFINED__ */


#ifndef __IMtsInstanceEvents_INTERFACE_DEFINED__
#define __IMtsInstanceEvents_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IMtsInstanceEvents
 * at Thu Sep 11 16:03:12 1997
 * using MIDL 3.01.75
 ****************************************/
/* [uuid][object] */ 



EXTERN_C const IID IID_IMtsInstanceEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("BACEDF51-74AB-11D0-B162-00AA00BA3258")
    IMtsInstanceEvents : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnObjectCreate( 
            /* [in] */ LONGLONG perfCount,
            /* [in] */ REFGUID guidActivity,
            /* [in] */ REFCLSID clsid,
            /* [in] */ REFGUID tsid,
            /* [in] */ MTS_OBJID ObjectID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnObjectRelease( 
            /* [in] */ LONGLONG perfCount,
            /* [in] */ MTS_OBJID ObjectID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMtsInstanceEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMtsInstanceEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMtsInstanceEvents __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMtsInstanceEvents __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnObjectCreate )( 
            IMtsInstanceEvents __RPC_FAR * This,
            /* [in] */ LONGLONG perfCount,
            /* [in] */ REFGUID guidActivity,
            /* [in] */ REFCLSID clsid,
            /* [in] */ REFGUID tsid,
            /* [in] */ MTS_OBJID ObjectID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnObjectRelease )( 
            IMtsInstanceEvents __RPC_FAR * This,
            /* [in] */ LONGLONG perfCount,
            /* [in] */ MTS_OBJID ObjectID);
        
        END_INTERFACE
    } IMtsInstanceEventsVtbl;

    interface IMtsInstanceEvents
    {
        CONST_VTBL struct IMtsInstanceEventsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMtsInstanceEvents_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMtsInstanceEvents_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMtsInstanceEvents_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMtsInstanceEvents_OnObjectCreate(This,perfCount,guidActivity,clsid,tsid,ObjectID)	\
    (This)->lpVtbl -> OnObjectCreate(This,perfCount,guidActivity,clsid,tsid,ObjectID)

#define IMtsInstanceEvents_OnObjectRelease(This,perfCount,ObjectID)	\
    (This)->lpVtbl -> OnObjectRelease(This,perfCount,ObjectID)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMtsInstanceEvents_OnObjectCreate_Proxy( 
    IMtsInstanceEvents __RPC_FAR * This,
    /* [in] */ LONGLONG perfCount,
    /* [in] */ REFGUID guidActivity,
    /* [in] */ REFCLSID clsid,
    /* [in] */ REFGUID tsid,
    /* [in] */ MTS_OBJID ObjectID);


void __RPC_STUB IMtsInstanceEvents_OnObjectCreate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMtsInstanceEvents_OnObjectRelease_Proxy( 
    IMtsInstanceEvents __RPC_FAR * This,
    /* [in] */ LONGLONG perfCount,
    /* [in] */ MTS_OBJID ObjectID);


void __RPC_STUB IMtsInstanceEvents_OnObjectRelease_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMtsInstanceEvents_INTERFACE_DEFINED__ */


#ifndef __IMtsTransactionEvents_INTERFACE_DEFINED__
#define __IMtsTransactionEvents_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IMtsTransactionEvents
 * at Thu Sep 11 16:03:12 1997
 * using MIDL 3.01.75
 ****************************************/
/* [uuid][object] */ 



EXTERN_C const IID IID_IMtsTransactionEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("BACEDF52-74AB-11D0-B162-00AA00BA3258")
    IMtsTransactionEvents : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnTransactionStart( 
            /* [in] */ LONGLONG perfCount,
            /* [in] */ REFGUID guidTx,
            /* [in] */ REFGUID tsid,
            /* [in] */ BOOL fRoot) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnTransactionPrepared( 
            /* [in] */ LONGLONG perfCount,
            /* [in] */ REFGUID guidTx,
            /* [in] */ BOOL fVoteYes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnTransactionAborted( 
            /* [in] */ LONGLONG perfCount,
            /* [in] */ REFGUID guidTx) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMtsTransactionEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMtsTransactionEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMtsTransactionEvents __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMtsTransactionEvents __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnTransactionStart )( 
            IMtsTransactionEvents __RPC_FAR * This,
            /* [in] */ LONGLONG perfCount,
            /* [in] */ REFGUID guidTx,
            /* [in] */ REFGUID tsid,
            /* [in] */ BOOL fRoot);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnTransactionPrepared )( 
            IMtsTransactionEvents __RPC_FAR * This,
            /* [in] */ LONGLONG perfCount,
            /* [in] */ REFGUID guidTx,
            /* [in] */ BOOL fVoteYes);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnTransactionAborted )( 
            IMtsTransactionEvents __RPC_FAR * This,
            /* [in] */ LONGLONG perfCount,
            /* [in] */ REFGUID guidTx);
        
        END_INTERFACE
    } IMtsTransactionEventsVtbl;

    interface IMtsTransactionEvents
    {
        CONST_VTBL struct IMtsTransactionEventsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMtsTransactionEvents_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMtsTransactionEvents_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMtsTransactionEvents_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMtsTransactionEvents_OnTransactionStart(This,perfCount,guidTx,tsid,fRoot)	\
    (This)->lpVtbl -> OnTransactionStart(This,perfCount,guidTx,tsid,fRoot)

#define IMtsTransactionEvents_OnTransactionPrepared(This,perfCount,guidTx,fVoteYes)	\
    (This)->lpVtbl -> OnTransactionPrepared(This,perfCount,guidTx,fVoteYes)

#define IMtsTransactionEvents_OnTransactionAborted(This,perfCount,guidTx)	\
    (This)->lpVtbl -> OnTransactionAborted(This,perfCount,guidTx)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMtsTransactionEvents_OnTransactionStart_Proxy( 
    IMtsTransactionEvents __RPC_FAR * This,
    /* [in] */ LONGLONG perfCount,
    /* [in] */ REFGUID guidTx,
    /* [in] */ REFGUID tsid,
    /* [in] */ BOOL fRoot);


void __RPC_STUB IMtsTransactionEvents_OnTransactionStart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMtsTransactionEvents_OnTransactionPrepared_Proxy( 
    IMtsTransactionEvents __RPC_FAR * This,
    /* [in] */ LONGLONG perfCount,
    /* [in] */ REFGUID guidTx,
    /* [in] */ BOOL fVoteYes);


void __RPC_STUB IMtsTransactionEvents_OnTransactionPrepared_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMtsTransactionEvents_OnTransactionAborted_Proxy( 
    IMtsTransactionEvents __RPC_FAR * This,
    /* [in] */ LONGLONG perfCount,
    /* [in] */ REFGUID guidTx);


void __RPC_STUB IMtsTransactionEvents_OnTransactionAborted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMtsTransactionEvents_INTERFACE_DEFINED__ */


#ifndef __IMtsMethodEvents_INTERFACE_DEFINED__
#define __IMtsMethodEvents_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IMtsMethodEvents
 * at Thu Sep 11 16:03:12 1997
 * using MIDL 3.01.75
 ****************************************/
/* [uuid][object] */ 



EXTERN_C const IID IID_IMtsMethodEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("BACEDF53-74AB-11D0-B162-00AA00BA3258")
    IMtsMethodEvents : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnMethodCall( 
            /* [in] */ LONGLONG perfCount,
            /* [in] */ MTS_OBJID oid,
            /* [in] */ REFCLSID guidCid,
            /* [in] */ REFIID guidRid,
            /* [in] */ ULONG iMeth) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnMethodReturn( 
            /* [in] */ LONGLONG perfCount,
            /* [in] */ MTS_OBJID oid,
            /* [in] */ REFCLSID guidCid,
            /* [in] */ REFIID guidRid,
            /* [in] */ ULONG iMeth,
            /* [in] */ HRESULT hresult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnMethodException( 
            /* [in] */ LONGLONG perfCount,
            /* [in] */ MTS_OBJID oid,
            /* [in] */ REFCLSID guidCid,
            /* [in] */ REFIID guidRid,
            /* [in] */ ULONG iMeth) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMtsMethodEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMtsMethodEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMtsMethodEvents __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMtsMethodEvents __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnMethodCall )( 
            IMtsMethodEvents __RPC_FAR * This,
            /* [in] */ LONGLONG perfCount,
            /* [in] */ MTS_OBJID oid,
            /* [in] */ REFCLSID guidCid,
            /* [in] */ REFIID guidRid,
            /* [in] */ ULONG iMeth);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnMethodReturn )( 
            IMtsMethodEvents __RPC_FAR * This,
            /* [in] */ LONGLONG perfCount,
            /* [in] */ MTS_OBJID oid,
            /* [in] */ REFCLSID guidCid,
            /* [in] */ REFIID guidRid,
            /* [in] */ ULONG iMeth,
            /* [in] */ HRESULT hresult);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnMethodException )( 
            IMtsMethodEvents __RPC_FAR * This,
            /* [in] */ LONGLONG perfCount,
            /* [in] */ MTS_OBJID oid,
            /* [in] */ REFCLSID guidCid,
            /* [in] */ REFIID guidRid,
            /* [in] */ ULONG iMeth);
        
        END_INTERFACE
    } IMtsMethodEventsVtbl;

    interface IMtsMethodEvents
    {
        CONST_VTBL struct IMtsMethodEventsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMtsMethodEvents_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMtsMethodEvents_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMtsMethodEvents_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMtsMethodEvents_OnMethodCall(This,perfCount,oid,guidCid,guidRid,iMeth)	\
    (This)->lpVtbl -> OnMethodCall(This,perfCount,oid,guidCid,guidRid,iMeth)

#define IMtsMethodEvents_OnMethodReturn(This,perfCount,oid,guidCid,guidRid,iMeth,hresult)	\
    (This)->lpVtbl -> OnMethodReturn(This,perfCount,oid,guidCid,guidRid,iMeth,hresult)

#define IMtsMethodEvents_OnMethodException(This,perfCount,oid,guidCid,guidRid,iMeth)	\
    (This)->lpVtbl -> OnMethodException(This,perfCount,oid,guidCid,guidRid,iMeth)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMtsMethodEvents_OnMethodCall_Proxy( 
    IMtsMethodEvents __RPC_FAR * This,
    /* [in] */ LONGLONG perfCount,
    /* [in] */ MTS_OBJID oid,
    /* [in] */ REFCLSID guidCid,
    /* [in] */ REFIID guidRid,
    /* [in] */ ULONG iMeth);


void __RPC_STUB IMtsMethodEvents_OnMethodCall_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMtsMethodEvents_OnMethodReturn_Proxy( 
    IMtsMethodEvents __RPC_FAR * This,
    /* [in] */ LONGLONG perfCount,
    /* [in] */ MTS_OBJID oid,
    /* [in] */ REFCLSID guidCid,
    /* [in] */ REFIID guidRid,
    /* [in] */ ULONG iMeth,
    /* [in] */ HRESULT hresult);


void __RPC_STUB IMtsMethodEvents_OnMethodReturn_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMtsMethodEvents_OnMethodException_Proxy( 
    IMtsMethodEvents __RPC_FAR * This,
    /* [in] */ LONGLONG perfCount,
    /* [in] */ MTS_OBJID oid,
    /* [in] */ REFCLSID guidCid,
    /* [in] */ REFIID guidRid,
    /* [in] */ ULONG iMeth);


void __RPC_STUB IMtsMethodEvents_OnMethodException_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMtsMethodEvents_INTERFACE_DEFINED__ */


#ifndef __IMtsObjectEvents_INTERFACE_DEFINED__
#define __IMtsObjectEvents_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IMtsObjectEvents
 * at Thu Sep 11 16:03:12 1997
 * using MIDL 3.01.75
 ****************************************/
/* [uuid][object] */ 



EXTERN_C const IID IID_IMtsObjectEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("BACEDF54-74AB-11D0-B162-00AA00BA3258")
    IMtsObjectEvents : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnObjectActivate( 
            /* [in] */ LONGLONG perfCount,
            /* [in] */ MTS_OBJID ObjectID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnObjectDeactivate( 
            /* [in] */ LONGLONG perfCount,
            /* [in] */ MTS_OBJID ObjectID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnDisableCommit( 
            /* [in] */ LONGLONG perfCount,
            /* [in] */ MTS_OBJID ObjectID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnEnableCommit( 
            /* [in] */ LONGLONG perfCount,
            /* [in] */ MTS_OBJID ObjectID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnSetComplete( 
            /* [in] */ LONGLONG perfCount,
            /* [in] */ MTS_OBJID ObjectID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMtsObjectEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMtsObjectEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMtsObjectEvents __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMtsObjectEvents __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnObjectActivate )( 
            IMtsObjectEvents __RPC_FAR * This,
            /* [in] */ LONGLONG perfCount,
            /* [in] */ MTS_OBJID ObjectID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnObjectDeactivate )( 
            IMtsObjectEvents __RPC_FAR * This,
            /* [in] */ LONGLONG perfCount,
            /* [in] */ MTS_OBJID ObjectID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnDisableCommit )( 
            IMtsObjectEvents __RPC_FAR * This,
            /* [in] */ LONGLONG perfCount,
            /* [in] */ MTS_OBJID ObjectID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnEnableCommit )( 
            IMtsObjectEvents __RPC_FAR * This,
            /* [in] */ LONGLONG perfCount,
            /* [in] */ MTS_OBJID ObjectID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnSetComplete )( 
            IMtsObjectEvents __RPC_FAR * This,
            /* [in] */ LONGLONG perfCount,
            /* [in] */ MTS_OBJID ObjectID);
        
        END_INTERFACE
    } IMtsObjectEventsVtbl;

    interface IMtsObjectEvents
    {
        CONST_VTBL struct IMtsObjectEventsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMtsObjectEvents_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMtsObjectEvents_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMtsObjectEvents_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMtsObjectEvents_OnObjectActivate(This,perfCount,ObjectID)	\
    (This)->lpVtbl -> OnObjectActivate(This,perfCount,ObjectID)

#define IMtsObjectEvents_OnObjectDeactivate(This,perfCount,ObjectID)	\
    (This)->lpVtbl -> OnObjectDeactivate(This,perfCount,ObjectID)

#define IMtsObjectEvents_OnDisableCommit(This,perfCount,ObjectID)	\
    (This)->lpVtbl -> OnDisableCommit(This,perfCount,ObjectID)

#define IMtsObjectEvents_OnEnableCommit(This,perfCount,ObjectID)	\
    (This)->lpVtbl -> OnEnableCommit(This,perfCount,ObjectID)

#define IMtsObjectEvents_OnSetComplete(This,perfCount,ObjectID)	\
    (This)->lpVtbl -> OnSetComplete(This,perfCount,ObjectID)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMtsObjectEvents_OnObjectActivate_Proxy( 
    IMtsObjectEvents __RPC_FAR * This,
    /* [in] */ LONGLONG perfCount,
    /* [in] */ MTS_OBJID ObjectID);


void __RPC_STUB IMtsObjectEvents_OnObjectActivate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMtsObjectEvents_OnObjectDeactivate_Proxy( 
    IMtsObjectEvents __RPC_FAR * This,
    /* [in] */ LONGLONG perfCount,
    /* [in] */ MTS_OBJID ObjectID);


void __RPC_STUB IMtsObjectEvents_OnObjectDeactivate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMtsObjectEvents_OnDisableCommit_Proxy( 
    IMtsObjectEvents __RPC_FAR * This,
    /* [in] */ LONGLONG perfCount,
    /* [in] */ MTS_OBJID ObjectID);


void __RPC_STUB IMtsObjectEvents_OnDisableCommit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMtsObjectEvents_OnEnableCommit_Proxy( 
    IMtsObjectEvents __RPC_FAR * This,
    /* [in] */ LONGLONG perfCount,
    /* [in] */ MTS_OBJID ObjectID);


void __RPC_STUB IMtsObjectEvents_OnEnableCommit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMtsObjectEvents_OnSetComplete_Proxy( 
    IMtsObjectEvents __RPC_FAR * This,
    /* [in] */ LONGLONG perfCount,
    /* [in] */ MTS_OBJID ObjectID);


void __RPC_STUB IMtsObjectEvents_OnSetComplete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMtsObjectEvents_INTERFACE_DEFINED__ */


#ifndef __IMtsResourceEvents_INTERFACE_DEFINED__
#define __IMtsResourceEvents_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IMtsResourceEvents
 * at Thu Sep 11 16:03:12 1997
 * using MIDL 3.01.75
 ****************************************/
/* [uuid][object] */ 



EXTERN_C const IID IID_IMtsResourceEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("BACEDF55-74AB-11D0-B162-00AA00BA3258")
    IMtsResourceEvents : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnResourceCreate( 
            /* [in] */ LONGLONG perfCount,
            /* [in] */ REFGUID guidActivity,
            /* [in] */ MTS_OBJID ObjectID,
            /* [in] */ LPCOLESTR pszType,
            /* [in] */ MTS_RESID resId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnResourceAllocate( 
            /* [in] */ LONGLONG perfCount,
            /* [in] */ REFGUID guidActivity,
            /* [in] */ MTS_OBJID ObjectID,
            /* [in] */ LPCOLESTR pszType,
            /* [in] */ MTS_RESID resId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnResourceRecycle( 
            /* [in] */ LONGLONG perfCount,
            /* [in] */ MTS_OBJID ObjectID,
            /* [in] */ LPCOLESTR pszType,
            /* [in] */ MTS_RESID resId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnResourceDestroy( 
            /* [in] */ LONGLONG perfCount,
            /* [in] */ MTS_OBJID ObjectID,
            /* [in] */ LPCOLESTR pszType,
            /* [in] */ MTS_RESID resId) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMtsResourceEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMtsResourceEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMtsResourceEvents __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMtsResourceEvents __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnResourceCreate )( 
            IMtsResourceEvents __RPC_FAR * This,
            /* [in] */ LONGLONG perfCount,
            /* [in] */ REFGUID guidActivity,
            /* [in] */ MTS_OBJID ObjectID,
            /* [in] */ LPCOLESTR pszType,
            /* [in] */ MTS_RESID resId);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnResourceAllocate )( 
            IMtsResourceEvents __RPC_FAR * This,
            /* [in] */ LONGLONG perfCount,
            /* [in] */ REFGUID guidActivity,
            /* [in] */ MTS_OBJID ObjectID,
            /* [in] */ LPCOLESTR pszType,
            /* [in] */ MTS_RESID resId);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnResourceRecycle )( 
            IMtsResourceEvents __RPC_FAR * This,
            /* [in] */ LONGLONG perfCount,
            /* [in] */ MTS_OBJID ObjectID,
            /* [in] */ LPCOLESTR pszType,
            /* [in] */ MTS_RESID resId);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnResourceDestroy )( 
            IMtsResourceEvents __RPC_FAR * This,
            /* [in] */ LONGLONG perfCount,
            /* [in] */ MTS_OBJID ObjectID,
            /* [in] */ LPCOLESTR pszType,
            /* [in] */ MTS_RESID resId);
        
        END_INTERFACE
    } IMtsResourceEventsVtbl;

    interface IMtsResourceEvents
    {
        CONST_VTBL struct IMtsResourceEventsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMtsResourceEvents_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMtsResourceEvents_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMtsResourceEvents_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMtsResourceEvents_OnResourceCreate(This,perfCount,guidActivity,ObjectID,pszType,resId)	\
    (This)->lpVtbl -> OnResourceCreate(This,perfCount,guidActivity,ObjectID,pszType,resId)

#define IMtsResourceEvents_OnResourceAllocate(This,perfCount,guidActivity,ObjectID,pszType,resId)	\
    (This)->lpVtbl -> OnResourceAllocate(This,perfCount,guidActivity,ObjectID,pszType,resId)

#define IMtsResourceEvents_OnResourceRecycle(This,perfCount,ObjectID,pszType,resId)	\
    (This)->lpVtbl -> OnResourceRecycle(This,perfCount,ObjectID,pszType,resId)

#define IMtsResourceEvents_OnResourceDestroy(This,perfCount,ObjectID,pszType,resId)	\
    (This)->lpVtbl -> OnResourceDestroy(This,perfCount,ObjectID,pszType,resId)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMtsResourceEvents_OnResourceCreate_Proxy( 
    IMtsResourceEvents __RPC_FAR * This,
    /* [in] */ LONGLONG perfCount,
    /* [in] */ REFGUID guidActivity,
    /* [in] */ MTS_OBJID ObjectID,
    /* [in] */ LPCOLESTR pszType,
    /* [in] */ MTS_RESID resId);


void __RPC_STUB IMtsResourceEvents_OnResourceCreate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMtsResourceEvents_OnResourceAllocate_Proxy( 
    IMtsResourceEvents __RPC_FAR * This,
    /* [in] */ LONGLONG perfCount,
    /* [in] */ REFGUID guidActivity,
    /* [in] */ MTS_OBJID ObjectID,
    /* [in] */ LPCOLESTR pszType,
    /* [in] */ MTS_RESID resId);


void __RPC_STUB IMtsResourceEvents_OnResourceAllocate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMtsResourceEvents_OnResourceRecycle_Proxy( 
    IMtsResourceEvents __RPC_FAR * This,
    /* [in] */ LONGLONG perfCount,
    /* [in] */ MTS_OBJID ObjectID,
    /* [in] */ LPCOLESTR pszType,
    /* [in] */ MTS_RESID resId);


void __RPC_STUB IMtsResourceEvents_OnResourceRecycle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMtsResourceEvents_OnResourceDestroy_Proxy( 
    IMtsResourceEvents __RPC_FAR * This,
    /* [in] */ LONGLONG perfCount,
    /* [in] */ MTS_OBJID ObjectID,
    /* [in] */ LPCOLESTR pszType,
    /* [in] */ MTS_RESID resId);


void __RPC_STUB IMtsResourceEvents_OnResourceDestroy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMtsResourceEvents_INTERFACE_DEFINED__ */


#ifndef __IMtsSecurityEvents_INTERFACE_DEFINED__
#define __IMtsSecurityEvents_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IMtsSecurityEvents
 * at Thu Sep 11 16:03:12 1997
 * using MIDL 3.01.75
 ****************************************/
/* [uuid][object] */ 



EXTERN_C const IID IID_IMtsSecurityEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("55EB3AFB-0A11-11d1-B1B4-00AA00BA3258")
    IMtsSecurityEvents : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnAuthenticate( 
            LONGLONG perfCount,
            REFGUID guidActivity,
            ULONG cbByteOrig,
            /* [size_is][in] */ BYTE __RPC_FAR *pSidOriginalUser,
            ULONG cbByteCur,
            /* [size_is][in] */ BYTE __RPC_FAR *pSidCurrentUser,
            BOOL bCurrentUserInpersonatingInProc) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMtsSecurityEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMtsSecurityEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMtsSecurityEvents __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMtsSecurityEvents __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnAuthenticate )( 
            IMtsSecurityEvents __RPC_FAR * This,
            LONGLONG perfCount,
            REFGUID guidActivity,
            ULONG cbByteOrig,
            /* [size_is][in] */ BYTE __RPC_FAR *pSidOriginalUser,
            ULONG cbByteCur,
            /* [size_is][in] */ BYTE __RPC_FAR *pSidCurrentUser,
            BOOL bCurrentUserInpersonatingInProc);
        
        END_INTERFACE
    } IMtsSecurityEventsVtbl;

    interface IMtsSecurityEvents
    {
        CONST_VTBL struct IMtsSecurityEventsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMtsSecurityEvents_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMtsSecurityEvents_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMtsSecurityEvents_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMtsSecurityEvents_OnAuthenticate(This,perfCount,guidActivity,cbByteOrig,pSidOriginalUser,cbByteCur,pSidCurrentUser,bCurrentUserInpersonatingInProc)	\
    (This)->lpVtbl -> OnAuthenticate(This,perfCount,guidActivity,cbByteOrig,pSidOriginalUser,cbByteCur,pSidCurrentUser,bCurrentUserInpersonatingInProc)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMtsSecurityEvents_OnAuthenticate_Proxy( 
    IMtsSecurityEvents __RPC_FAR * This,
    LONGLONG perfCount,
    REFGUID guidActivity,
    ULONG cbByteOrig,
    /* [size_is][in] */ BYTE __RPC_FAR *pSidOriginalUser,
    ULONG cbByteCur,
    /* [size_is][in] */ BYTE __RPC_FAR *pSidCurrentUser,
    BOOL bCurrentUserInpersonatingInProc);


void __RPC_STUB IMtsSecurityEvents_OnAuthenticate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMtsSecurityEvents_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long __RPC_FAR *, unsigned long            , VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long __RPC_FAR *, VARIANT __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\exchcli.h ===
/* Microsoft Exchange. Copyright 1986 - 1998, Microsoft Corporation -
   All Rights Reserved */

/*
 * E X C H C L I . H
 * Client-side Exchange programmability interfaces
 *
 * This file contains interfaces to the following Exchange features:
 *	Enterprise-wide forms registry
 *	Conflict resolution interfaces for forms
 *	Custom actions on inbox management rules
 *
 * Information in this document is subject to change without notice and does
 * not represent a commitment on the part of Microsoft Corporation.
 */

#ifndef _EXCHCLI_H_
#define _EXCHCLI_H_


/* Parameter to IMAPIFormMgr::OpenFormContainer
   denoting the Exchange Enterprise Forms Registry */

#if defined(HFRMREG_DEFAULT)
#define HFRMREG_ENTERPRISE 4
#endif


/* The GUID for Exchange's form extension properties. */

#if !defined(INITGUID) || defined(USES_GUID_ExchangeFormExts)
DEFINE_GUID (
	GUID_ExchangeFormExts,
	0x77f69534, 0x6b7d, 0x101b, 0x9f, 0x0d, 0x00, 0xaa, 0x00, 0x3b, 0xa9, 0x05);
#endif
#define IDFEXT_ExchangeResolvesConflict 0


/*
	Interfaces for "custom actions," the client rule extensions.

	Exchange rules are evaluated against each message on the server,
	where matches result in the server executing one or more actions
	against the message.  For purposes of performance and robustness
	the server offers a fixed set of actions.
	However, some actions must necessarily execute on a client machine.
	To allow this, the server encodes the desired action in a message
	(known as a DAM, or Deferred Action Message), then waits for a client
	to open the mailbox and process these client-side action requests.
	Client side actions include popup alerts, cross-store moves and copies,
	and CUSTOM ACTIONS.

	Custom actions are the sole rule extensibility mechanism available
	to clients.  A user installs a DLL containing a custom action on
	his workstation, then writes a rule naming this DLL as its action.
	When the server finds a match for the rule, it generates a DAM
	specifying the action named.  Subsequently the client reads the DAM
	and executes the action by invoking the proper DLL.

	A custom action DLL very much resembles a Capone super-extension in
    its gross structure.  One installs it on 16 bit platforms by creating
    a section [Custom Actions] in exchng.ini, there adding a key
    "tag=4.0;DLL;ordinal" just as for a superextension.  On 32 bit platforms
    the custom action is specified in the Registry as a name/value pair
    under the registry key:

    \\HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Exchange\Client\Custom Actions

    The name/value pair is identical to that used on the 16 bit platform,
    where the 'name' is the 'tag' mentioned above, and the value is the
    DLL entry point information in the form: "4.0;DLL;ordinal".

    The tag should be suitable for display, as the Inbox Assistant will
    use it to represent the custom action for selection in its UI.  DLL
    should contain a fully qualified path to the DLL.  Ordinal is an
    integer denoting the ordinal of the extension entry point; it defaults
    to 1.

	That entry point is of type LPFNEXCHANGERULEEXTENTRY: it must allocate
	and return an instance of an IUnknown, off of which the Exchange
	client will QueryInterface the IExchangeRulesExt interface.  All
	subsequent calls will take place through this returned interface.
	Hence a custom action may easily reside in the same DLL as a super
	extension.

	Some methods of IExchangeRuleExt are passed an instance of the
	interface IExchangeRuleExtCallback.  This will return the extension
	information about the running Exchange client, including its MAPI
	session (off of which the extension may make calls) and a window
	handle (off of which to parent UI of its own).

	After the initial sequence of IUnknown methods, Exchange will
	invoke IExchangeRuleExt::Install.  This informs the extension into which
	context it is being invoked: either ERCONTEXT_INFO, that of the
	Inbox Assistant dialog, in which case it will be called upon to
	get new commands and translate existing commands; or else ERCONTEXT_EXEC,
	that of the client rule execution engine, in which case it will be
	called upon to execute the actual extension commands on a message.
	Return S_FALSE to abort installation or further processing.

		HRESULT IExchangeRuleExt::Install(
			LPEXCHANGERULEEXTCALLBACK percb,
				- an instance of IExchangeRuleExtCallback
			ULONG ulContext
				- one of ERCONTEXT_INFO or ERCONTEXT_EXEC
			)

    The QueryRelease() method is reserved for future use.  For now all rule
    extensions should return S_OK in response to a call on this method.

		HRESULT IExchangeRuleExt::QueryRelease()

	When a user selects the extension's tag from the Inbox Assistant,
	that extension is queried via IExchangeRuleExt::GetCommand for the
	command encoding it wishes to use.  This is an opportunity for it
	to present further UI refining the user's selection or specifying
	options if necessary.  The extension should return both an
	encoding of the command and a display string suitably representing
	the command to the user.  Return S_OK or S_FALSE as per the user's
	Ok or Cancel to any secondary UI.

		HRESULT IExchangeRuleExt::GetCommand(
			LPEXCHANGERULEEXTCALLBACK percb,
				- an instance of IExchangeRuleExtCallback
			TCHAR FAR* pszCommand, ULONG cchCommand,
                - an IN/OUT buffer in which to return the encoded command,
                  the buffer may be pre-initialized with a previously
                  existing command for this provider.
				  together with the length of the buffer given
			TCHAR FAR* pszDisplayName, ULONG cchDisplayName
                - IN/OUT, as the previous buffer, but for the display string
			)

	When the Inbox Assistant is invoked to edit an existing rule which
	specifies a custom action, it queries the appropriate extension
	via IExchangeRuleExt::QueryCommandDisplayName for the display string
	corresponding to the encoded command.  This should match the
	display string originally returned from GetCommand.  (Note that
	Exchange does not save the display string when saving the rule.)

		HRESULT IExchangeRuleExt::QueryCommandDisplayName(
			LPEXCHANGERULEEXTCALLBACK percb,
				- an instance of IExchangeRuleExtCallback
			LPCTSTR pszCommand,
				- the encoded command for which we want the display string
			TCHAR FAR* pszDisplayName, ULONG cchDisplayName
				- a buffer in which to return the display string,
				  together with the length of the buffer given
			)

	At the time that Exchange processes client-side rule actions, any
	custom actions invoked will result in their extensions receiving
	IExchangeRuleExt::Command calls.

		HRESULT IExchangeRuleExt::Command(
			LPEXCHANGERULEEXTCALLBACK percb,
				- an instance of IExchangeRuleExtCallback
			LPCTSTR pszCommand,
				- the encoded command to execute
			ULONG cb, LPENTRYID peid
				- the entryid of the message on which to execute
			)

*/

/* Extensibility contexts used with IExchangeRuleExt::Install */

#define ERCONTEXT_INFO (0x00000001)
#define ERCONTEXT_EXEC (0x00000002)


#undef INTERFACE
#define INTERFACE   IExchangeRuleExtCallback

DECLARE_INTERFACE_(IExchangeRuleExtCallback, IUnknown)
{
	BEGIN_INTERFACE
    /* IUnknown methods */
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* lppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

	/* IExchangeRuleExtCallback methods */
	STDMETHOD(GetVersion) (THIS_ ULONG FAR* pulVersion, ULONG ulFlags) PURE;
    STDMETHOD(GetWindow) (THIS_ HWND FAR* phwnd) PURE;
    STDMETHOD(GetSession) (THIS_ LPMAPISESSION FAR* ppses) PURE;
};
typedef IExchangeRuleExtCallback FAR * LPEXCHANGERULEEXTCALLBACK;

#undef INTERFACE
#define INTERFACE   IExchangeRuleExt

DECLARE_INTERFACE_(IExchangeRuleExt, IUnknown)
{
    /* IUnknown methods */
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * lppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS) PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    /* IExchangeRuleExt methods */
    STDMETHOD(Install) (THIS_
    	LPEXCHANGERULEEXTCALLBACK percb, ULONG ulContext) PURE;
    STDMETHOD(QueryRelease) (THIS) PURE;

	STDMETHOD(GetCommand)(THIS_
		LPEXCHANGERULEEXTCALLBACK percb,
		TCHAR FAR* pszCommand, ULONG cchCommand,
		TCHAR FAR* pszDisplayName, ULONG cchDisplayName) PURE;
	STDMETHOD(QueryCommandDisplayName) (THIS_
		LPEXCHANGERULEEXTCALLBACK percb,
		LPCTSTR pszCommand,
		TCHAR FAR* pszDisplayName, ULONG cchDisplayName) PURE;

	STDMETHOD(Command) (THIS_
		LPEXCHANGERULEEXTCALLBACK percb,
		LPCTSTR pszCommand,
		ULONG cb, LPENTRYID peid ) PURE;
};
typedef IExchangeRuleExt FAR* LPEXCHANGERULEEXT;


/* Type of function called by rules to load a provider */
typedef LPUNKNOWN (CALLBACK * LPFNEXCHANGERULEEXTENTRY)(VOID);

#define DEFINE_RULEEXTGUID(name, b) \
    DEFINE_GUID(name, 0x00020E00 | (b), 0, 0, 0xC0,0,0,0,0,0,0,0x46)

DEFINE_RULEEXTGUID(IID_IExchangeRuleExtCallback,			0x10);
DEFINE_RULEEXTGUID(IID_IExchangeRuleExt,					0x11);

#endif /* end of file exchcli.h */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\ExchHndl_i.c ===
/* this file contains the actual definitions of */
/* the IIDs and CLSIDs */

/* link this file in with the server and any clients */


/* File created by MIDL compiler version 3.01.75 */
/* at Fri Mar 27 08:32:24 1998
 */
/* Compiler settings for J:\events\src\SS\exchhndl.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

const IID IID_IExchangeEventHandler = {0x69E54156,0xB371,0x11D0,{0xBC,0xD9,0x00,0xAA,0x00,0xC1,0xAB,0x1C}};


const IID IID_IEventSource = {0x69E54152,0xB371,0x11D0,{0xBC,0xD9,0x00,0xAA,0x00,0xC1,0xAB,0x1C}};


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\exadmin.h ===
// -----------------------------------------------------------------------------
// ExAdmin.H: Declaration of the classes necessary to create an Exchange 
//            Administration Extension DLL.
//              
// NOTE:      When we refer to "admin" we mean the Exchange Administration program.
//
// Copyright 1986 - 1998 Microsoft Corporation.  All Rights Reserved.
// -----------------------------------------------------------------------------

#ifndef _EXADMIN_H_
#define _EXADMIN_H_

// -----------------------------------------------------------------------------

#include <mapix.h>
#include "retcode.h"
#include "adminext.h"

// -----------------------------------------------------------------------------
// NOTE: Your resource file MUST define these two control ids with these exact 
//       numbers.  If you don't you will get a compile time error telling you 
//       that you are redefining a macro.  Just go into your resource.h file and
//       change those definitions to these values.
// -----------------------------------------------------------------------------

#define IDC_ADMINICON                   1000
#define IDC_TITLE                       1001

// -----------------------------------------------------------------------------
// The following macros and the SInitPropValue structure give the user the 
// ability to easily create a property value array.  This is intended to make
// it easier to use the CAdminDialog::HrSetExtProps() function.
//
// See usage example that follows.
// -----------------------------------------------------------------------------

#define MAKE_PROP_VALUE( cnt, ptr) ((LONGLONG) ((((LONGLONG) ((ULONG) (ptr))) << 32) + ((LONGLONG) ((ULONG) (cnt)))))
#define BINARY_PROP_VALUE( bin)  MAKE_PROP_VALUE( sizeof( bin), &bin)
#define MULTI_VALUE_PROP( array) MAKE_PROP_VALUE( ARRAY_CNT( array), array)

typedef struct
{
    ULONG    ulPropTag;
    ULONG    dwAlignPad;
    LONGLONG ll;    
} SInitPropValue, *LPSInitPropValue;

//::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
// Usage example:
//::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#ifdef  _USAGE_EXAMPLE_
#ifndef _USAGE_EXAMPLE_
    // Example of a binary structure that could be used by the property value array.
    typedef struct
    {
        CHAR    ch[20];
        LPSTR   lpsz;
        ULONG   ul;
        BOOL    flag;
    } ExampleStruct;

    // Example data that could go in the property value array.
    ExampleStruct BinData     = { "Binary Data", "A STRING", 3752789, TRUE};
    LONG          LongArray[] = { 92314535, 2231223, 111, 424242312};

    // The example property value array.
    static SInitPropValue ExtensionProps[] =
    {
        { PT_STRING8, 0, (ULONG)"Topic Folder"}, 
        { PT_LONG,    0, 0},      
        { PT_BOOLEAN, 0, FALSE},  
        { PT_BINARY,  0, BINARY_PROP_VALUE( BinData)},
        { PT_MV_LONG, 0, MULTI_VALUE_PROP( LongArray)},
    };
    
    // Somewhere in your OnInitDialog() function make the following call.
    hr = HrSetExtProps( ARRAY_CNT( ExtensionProps), ExtensionProps);
#endif
#endif

// -----------------------------------------------------------------------------
// This is called once per standard property sheet.  Not at all for our property
// sheets.  If you want to disable some or all of the standard property sheets 
// Then define this function in your code.  Your function will need to return 
// FALSE to disable a default property sheet.
// -----------------------------------------------------------------------------

BOOL PASCAL bShowPage( UINT iddAdminPage);

// -----------------------------------------------------------------------------
// This function is called once durring initialization.  Return -1 to cause the 
// first standard property sheet to be displayed.  Or return the index of one of 
// our property sheets to have it come up first.  The user can override this 
// function by simply defining their own function in their code.
// -----------------------------------------------------------------------------

INT PASCAL iStartPage( void);

// -----------------------------------------------------------------------------
// Class to initialize the DLL for both Windows and MFC.
// -----------------------------------------------------------------------------

class CInitDLL : public CWinApp
{
public:
    ~CInitDLL();
	virtual BOOL InitInstance(); // Initialization
	virtual int ExitInstance();  // Termination (WEP-like code)

	// Nothing special for the constructor.
	CInitDLL(LPCSTR pszAppName) : CWinApp(pszAppName) {}
};

// -----------------------------------------------------------------------------
// This dialog class allows easy subclassing of controls.
// -----------------------------------------------------------------------------

class CADialog : public CDialog
{
protected:    
    CADialog() : CDialog() {}   // Constructor.
    CADialog( LPCSTR lpszTemplateName, CWnd* pParentWnd = NULL) : CDialog( lpszTemplateName, pParentWnd) {}
    CADialog( UINT nIDTemplate, CWnd* pParentWnd = NULL) : CDialog( nIDTemplate, pParentWnd) {}

    // To make subclassing controls to CWnd derived objects easier.
    HRESULT HrSubclassWindow( 
        int   nID,  // Id of a control in this dialog.
        CWnd& Wnd); // Reference to MFC CWnd object to connect to Windows control.
};

// -----------------------------------------------------------------------------
// Derive your dialog class from this class to have it become an automatic
// property sheet of the Exchange Administration application.
//
// NOTE: In your derived dialog you MUST NOT release a MAPI interface in the 
//       destructor, this will cause a deadlock hang.  Use the OnDestroy() method
//       of the dialog to ULRELEASE() any MAPI Interface objects.
//
//       The problem is that the destructor does not get called until the DLL is
//       unloading.  This is a single threaded opperation in NT.  The ULRELEASE
//       process needs to run multi-threaded and waits INFINITELY for threads to
//       terminate.  The threads can't terminate until the DLL exits, and the DLL
//       can't exit until the threads terminate resulting in a deadlock.
// -----------------------------------------------------------------------------

class CAdminDialog : public CADialog
{
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// You may find the following information useful for creating your dialog.
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
protected:
    // Protected constructor insures that you must derive a class from CAdminDialog
    // in order to use it.  You may NOT instantiate directly from this class.
    //
    // To override the show page function you must pass in the pfnShowPage parameter.
    // Your function will be called once for each default property sheet and will 
    // receive an id of the sheet.  Your function must return TRUE if you want it 
    // to show.
    CAdminDialog( 
        UINT iddDialog,     // The resource ID of your dialog.
        UINT idsName,       // The resource ID of the string containing the name
                            // used by admin for the tab of your property sheet.
        LPSTR lpszBlobName = NULL);// Name of extension data blob.

    ~CAdminDialog();

    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    // Functions to make displaying of message boxes easier. 
    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    // If the caller does not pass in the lpszCaption then use the title of the 
    // parent window for the default title of our message box.
    int MessageBox( LPCSTR lpszText, LPCSTR lpszCaption = NULL, UINT nType = MB_OK);
    int MessageBox2( int IDText, int IDCaption = NULL, UINT nType = MB_OK);
    CString m_sMsgBoxCaption;   // This will contain the title of the parent window.

    // Displays a message box with a resource string for invalid entries.  After
    // the user presses OK the appropriate control gets focus.
    void InvalidEntry( int nResourceStrID, CWnd& wndCtrl);

    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    // Use this function to create child dialog box templates.  It will ensure that 
    // the correct language and fonts are used.  Then use the CDialog::InitModalIndirect()
    // function to create the dialog
    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

public:
    const HGLOBAL LoadDialogTemplate( UINT iddDialog);

    static int LoadStringA(UINT wID, LPSTR szBuf,  int cchBuf);
	static int LoadStringW(UINT wID, LPWSTR wzBuf, int cchBuf);

    // Free the template loaded with the above function.
    void FreeDialogTemplate( HGLOBAL* lphDlgTemplate)  { m_pAdminFunctions->pfnFreeDialogResource( (LPBYTE*) lphDlgTemplate);}

    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    // Override these virtual functions in your derived class if you want them to do
    // something.
    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
protected:    
    // Called when a different property sheet has been selected or when either the
    // OK or APPLY NOW button is pressed.  This saves the data to a memory buffer 
    // inside of admin.  Even if the user just switches to a different property sheet
    // this needs to be done so that other property sheets can read any changes that 
    // may have been made to the data.
    // Return TRUE if data has been validated and saved.  Default return is TRUE.
    virtual BOOL bSaveData();
    
    // Called when either the OK or APPLY NOW button is pressed and after bSaveData().
    // Return TRUE if data has been committed.  This saves the extension data and returns
    // TRUE if it was successful.
    virtual BOOL bCommitData();
    
    // Called so that your property sheet can refresh with data that may have been changed
    // by another property sheet.  You say you don't have more than one property sheet that
    // modifies the same data fields.  Ahh, but the Exchange SDK provides a sample that 
    // lets an Administrator view and modify any Exchange SDK packed extension data array.
    virtual void Refresh();

    // Called to determine if you supply help.  Return TRUE if you do, defaults to FALSE.
    virtual BOOL bHasHelp();
    
    // Called to start help.  Default does nothing.
    virtual VOID DoHelp();

    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    
    // Call this to inform admin that the data has changed.
    void DataHasChanged() { m_pAdminFunctions->pfnInfoHasChanged( GetSafeHwnd());}

    // Get the count of extension data properties.
    ULONG GetExtCount() { return( m_cExtProps);}

    // Set the extension data properties to an existing property value array.  This
    // can be used to create a blob for the first time.  To do this initialized the
    // lpExtProps array with just property types and no real data.  Then use the 
    // CAdminDialog::HrMod...() functions to set the values.
    HRESULT HrSetExtProps(
        ULONG        cExtProps,     // Count of extension data properties.
        LPSPropValue lpExtProps);   // Array of properties to set extension data to.
    
    // Overloaded function to convert our property initialization structure to
    // the real MAPI property structure.  (This is temporary until MAPI changes
    // their _UPV union definition.)
    HRESULT HrSetExtProps(
        ULONG        cExtProps,     // Count of extension data properties.
        LPSInitPropValue lpExtProps)// Array of properties to set extension data to.
    {
        return( HrSetExtProps( cExtProps, (LPSPropValue) lpExtProps));
    }

    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    // Functions to get extension data.
    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    // Use this to get a binary extension data property.
    LPSBinary GetExtBinary(
        ULONG iProp);       // Index of property.

    // Use this to get a string extension data property.
    LPSTR GetExtString(
        ULONG iProp);       // Index of property.

    // Use this to get a long extension data property.
    LONG GetExtLong(
        ULONG iProp);       // Index of property.

    // Use this to get a double word extension data property.
    DWORD GetExtDWord(
        ULONG iProp)        // Index of property.
    {
        return( (DWORD) GetExtLong( iProp));
    }

    // Use this to get a boolean extension data property.
    BOOL GetExtBool(
        ULONG iProp);       // Index of property.

    // Use this to get a system time extension data property.
    FILETIME GetExtSysTime(
        ULONG iProp);       // Index of property.

    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    // Functions to modify extension data.
    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    // Use this to modify a binary extension data property.
    HRESULT HrModExtBinary(
        IN ULONG  iProp,    // Index of property
        IN ULONG  cb,       // Count of new data bytes.
        IN const LPBYTE lpNew);   // New data bytes.

    // Use this to modify a string extension data property.
    HRESULT HrModExtString(
        IN ULONG   iProp,     // Index of property
        IN LPCSTR lpszNew);   // New data bytes.

    // Use this to modify a long extension data property.
    HRESULT HrModExtLong(
        IN ULONG  iProp,    // Index of property
        IN LONG   lNew);    // New long data value.
    
    // Use this to modify a double word extension data property.
    HRESULT HrModExtDWord(
        IN ULONG  iProp,    // Index of property
        IN DWORD  dwNew)     // New long data value.
    {
        return( HrModExtLong( iProp, (LONG) dwNew));
    }
    
    // Use this to modify a boolean extension data property.
    HRESULT HrModExtBool(
        IN ULONG  iProp,    // Index of property
        IN BOOL   bNew);    // New boolean data value.

    // Use this to modify a SysTime extension data property.
    HRESULT HrModExtSysTime(
        IN ULONG    iProp,    // Index of property
        IN FILETIME ftNew);   // New boolean data value.

    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    // Other miscellaneous functions that wrap administration functions.
    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    // Add service to be tracked by Server Monitor.
    HRESULT HrAddService(
        IN LPSTR lpszServiceName);   // SHORT name of the service.

    // Remove service to be tracked by Server Monitor.
    HRESULT HrRemoveService( 
        IN LPSTR lpszServiceName);   // SHORT name of the service.

    // You MUST release the array with FreeNameList.
    BOOL GetNameList( 
        OUT int*     lpcNameList,     // Ptr to number of WIDE strings in the array.
        OUT LPWSTR** lppwszNameList); // Ptr to a ptr of WIDE string array.  

    BOOL SetNameList(
        IN int      cNameList,        // Number of WIDE strings in the array.
        IN LPWSTR*  lpwszNameList);   // Ptr to a WIDE string array.  

    // Free the name list that was received in a call to GetNameList.
    void CAdminDialog::FreeNameList(
        IN int      cNameList,        // Number of WIDE strings in the array.
        IN LPWSTR*  lpwszNameList)    // Ptr to a WIDE string array.  
    {
        m_pAdminFunctions->pfnFreeNameList( cNameList, lpwszNameList);
    }    

    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    // Functions to get other miscellaneous data that admin gave us.
    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

	// Return the MAPI session interface pointer.
	IMAPISession* GetMAPISession() { return( m_pMAPISession);}

	// Return the MAPI address book interface pointer.
	IAddrBook* GetAddrBook() { return( m_pAddrBook);}

	// Return the MAPI address book container interface pointer.
	IABContainer* GetABContainer() { return( m_pABContainer);}

	// Return the name of computer on which the gateway runs, when applicable.
	LPWSTR GetComputerName() { return( m_pAdminObjectInfo->szComputerName);}
	
	// Return the distinguished name of the object administered.
	LPWSTR GetDN()           { return( m_pAdminObjectInfo->szDistinguishedName);}	
	
	// Return the distinguished name of the server running the home message database.
	LPWSTR GetDNHomeMDB()    { return( m_pAdminObjectInfo->szDNHomeMDB);}

	// Return the distinguished name of the server running the home message transport agent.
	LPWSTR GetDNHomeMTA()    { return( m_pAdminObjectInfo->szDNHomeMTA);}
	
	// Return the language id.
	static LANGID GetLanguageId()   { return( LANGIDFROMLCID(m_lcid));}
	static void   SetLcid(LCID lcid);

	// Return font in use by Admin.
	HFONT GetAdminFont()     { return( m_pAdminObjectInfo->hfontDialog);}

    // Return the object id.  Compare this against one or more of the #defined 
    // constants that can be found in "adminext.h"
    UINT GetObjectId()       { return( m_pAdminObjectInfo->uObjectID);}

    // Return a const ptr to the extension data properties.
    const LPSPropValue GetExtProps() { return( m_lpExtProps);}

    // Are we in read only mode?
    static BOOL bIsReadOnly(){ return( m_bReadOnly);}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// Your dialog need not be concerned with these members.
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
protected:
    // Load extension data into buffer contained in this object.  This is called
    // by the OnInitDialog() and OnChildActivate() functions of this class so 
    // you will probably not want to call this in your code.
    HRESULT HrLoadExtData();
    
    // Save extension data buffer that is contained in this object.  This is called
    // by the bCommitData function of this class so you will probably not want
    // to call this in your code.
    HRESULT HrSaveExtData();

public:
    static VOID ADMIN_Initialize( ADMIN_AdministratorConnections*, ADMIN_AdministratorFunction*);

private:
    UINT    m_iddDialog;    // The resource ID of your dialog.
    UINT    m_idsName;      // The resource ID of the string containing the name
                            // used by admin for the tab of your property sheet. 
    LPWSTR  m_lpwszBlobName;// Name of extension data blob (if there is one).
    
    ULONG        m_cExtData;   // Count of extension data blob.
    LPBYTE       m_lpbExtData; // Extension data blob.
    ULONG        m_cExtProps;  // Count of extension data properties. 
    LPSPropValue m_lpExtProps; // Ptr to extension data properties.
    
    static CPtrList          m_DlgList;      // List of dialog instances derived from this class.
    static IMAPISession*     m_pMAPISession; // The MAPI session handle opened by admin.
    static IAddrBook*        m_pAddrBook;    // The MAPI Address book opened by admin.
	static IABContainer*     m_pABContainer; // The MAPI Address Book Container opened by admin.
    static ADMIN_SheetInfo*  m_pSheetInfo;   // Dynamic information used by admin.
    static ADMIN_ObjectInfo* m_pAdminObjectInfo; // Admin server name and other useful DNs.
    static ADMIN_AdministratorFunction* m_pAdminFunctions;  // Admin functions available to you.
    static BOOL              m_bReadOnly;     // Open property sheets in read only mode.
	static LCID				 m_lcid;          // LCID to be used

    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    // Finds the CAdminDialog derived object using a handle to the dialog's window.
    static CAdminDialog* FindDlg( HWND hDlg);
    
    // Helper functions to access protected and private data.
    static BOOL bInitSheet( ADMIN_ObjectInfo* poi, ULONG fFlags, ADMIN_SheetInfo** ppsi, UINT* pcsi, VOID** ppNotUsed);
    static void DeinitSheet( IN VOID* pNotUsed);
    
    // Called directly by the Exchange Administrator program.
    friend BOOL PASCAL bInstallExtension(ADMIN_ObjectInfo* poi);
    friend BOOL PASCAL bDeinstallExtension(ADMIN_ObjectInfo* poi);
    friend BOOL PASCAL bInitSheet( ADMIN_ObjectInfo* poi, ULONG fFlags, ADMIN_SheetInfo** ppsi, UINT* pcsi, VOID** ppNotUsed);
    friend BOOL PASCAL bShowPage( UINT iddAdminPage);
    friend INT  PASCAL iStartPage( void);
    friend BOOL PASCAL bSaveData(VOID*, HWND);
    friend BOOL PASCAL bCommitData(VOID*, HWND);
    friend VOID PASCAL DeinitSheet(VOID*);
    friend BOOL PASCAL bHasHelp(VOID*, HWND);
    friend VOID PASCAL DoHelp(VOID*, HWND);

// -----------------------------------------------------------------------------
// Check function stuff
// -----------------------------------------------------------------------------

__inline HRESULT CHK_HrExtData(
    ULONG iProp,            // Index of property.
    ULONG ulPropType)       // Property type expected.
{
    if( iProp >= m_cExtProps)
        RETURN( E_INVALIDARG);
    
    // Sanity check that should never fail.
    if( !TEST_READ_PTR( m_lpExtProps, sizeof( SPropValue) * m_cExtProps))
        RETURN( E_FAIL);

    // Make sure we have the property type we are expecting.
    if( PROP_TYPE( m_lpExtProps[ iProp].ulPropTag) != ulPropType)
        RETURN( E_FAIL);

    return( NOERROR);
}

// -----------------------------------------------------------------------------

__inline HRESULT CHK_HrModExtBin( 
    IN ULONG  iProp,    // Index of property
    IN ULONG  cb,       // Count of new data bytes.
    IN LPBYTE lpNew)    // New data bytes.
{
    HRESULT hr = CHK_HrExtData( iProp, PT_BINARY);
    if( FAILED( hr))
        return( hr);

    if( cb == 0)
        RETURN( E_INVALIDARG);

    if( !TEST_READ_PTR( lpNew, cb))
        RETURN( E_INVALIDARG);

    return( NOERROR);
}

// -----------------------------------------------------------------------------

__inline HRESULT CHK_HrModExtString(
    IN ULONG   iProp,   // Index of property
    IN LPCSTR lpszNew) // New data string.
{
    HRESULT hr = CHK_HrExtData( iProp, PT_STRING8);
    if( FAILED( hr))
        return( hr);

    if( !TEST_STRING_PTR( lpszNew))
        RETURN( E_INVALIDARG);

    return( NOERROR);
}

// -----------------------------------------------------------------------------

__inline HRESULT CHK_HrSetExtProps(
    ULONG        cExtProps,     // Count of extension data properties.
    LPSPropValue lpExtProps)    // Array of properties to set extension data to.
{
    if( cExtProps == 0)
        RETURN( E_INVALIDARG);

    if( !TEST_READ_PTR( lpExtProps, sizeof( SPropValue) * cExtProps))
        RETURN( E_INVALIDARG);

    if( m_lpwszBlobName == NULL)
        RETURN( E_FAIL);    // There must be a blob name to use this function.

    return( NOERROR);
}
 

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// Class wizard stuff.
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
public:
	//{{AFX_DATA(CAdminDialog)
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA


protected:
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAdminDialog)
	//}}AFX_VIRTUAL

	// Generated message map functions
	//{{AFX_MSG(CAdminDialog)
	virtual BOOL OnInitDialog();
    afx_msg LONG OnChildActivate( UINT, LONG);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};

// -----------------------------------------------------------------------------
// Our dialog proc calls the MFC one.
// -----------------------------------------------------------------------------

LRESULT CALLBACK AdminDlgProc(HWND, UINT, WPARAM, LPARAM lParam);   // Ours
BOOL CALLBACK AfxDlgProc(HWND, UINT, WPARAM, LPARAM lParam);     // MFC

// -----------------------------------------------------------------------------
#ifdef _GLOBAL_OBJECTS_
#pragma message("Declaration of global objects for: " __FILE__)

// Instance of application initialization object.
CInitDLL InitDLL(_T("InitDLL.dll"));    

// Intialize static member data.
CPtrList                        CAdminDialog::m_DlgList(2);
ADMIN_SheetInfo*                CAdminDialog::m_pSheetInfo = NULL;
ADMIN_AdministratorFunction*    CAdminDialog::m_pAdminFunctions = NULL;  
ADMIN_ObjectInfo*               CAdminDialog::m_pAdminObjectInfo = NULL;
IMAPISession*                   CAdminDialog::m_pMAPISession = NULL;
IAddrBook*                      CAdminDialog::m_pAddrBook = NULL;
IABContainer*                   CAdminDialog::m_pABContainer = NULL;
BOOL                            CAdminDialog::m_bReadOnly = FALSE;
LCID                            CAdminDialog::m_lcid = MAKELCID( MAKELANGID( LANG_ENGLISH, SUBLANG_NEUTRAL),  SORT_DEFAULT);

#else  // ! _GLOBAL_OBJECTS_

extern CInitDLL InitDLL;

#endif //_GLOBAL_OBJECTS_
// -----------------------------------------------------------------------------

#endif  //_EXADMIN_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\exchform.h ===
#ifndef EXCHFORM_H
#define EXCHFORM_H


/*
 *  E X C H F O R M . H
 *
 *  Declarations of interfaces and constants for forms that work with
 *  the Microsoft Exchange client.
 *
 *  Copyright 1986-1999 Microsoft Corporation. All Rights Reserved.
 */


/*
 *  V e r b s
 */


// Interpersonal messaging verbs
#define EXCHIVERB_OPEN              0
#define EXCHIVERB_RESERVED_COMPOSE  100
#define EXCHIVERB_RESERVED_OPEN     101
#define EXCHIVERB_REPLYTOSENDER     102
#define EXCHIVERB_REPLYTOALL        103
#define EXCHIVERB_FORWARD           104
#define EXCHIVERB_PRINT             105
#define EXCHIVERB_SAVEAS            106
#define EXCHIVERB_RESERVED_DELIVERY 107
#define EXCHIVERB_REPLYTOFOLDER     108


/*
 *  G U I D s
 */


#define DEFINE_EXCHFORMGUID(name, b) \
    DEFINE_GUID(name, 0x00020D00 | (b), 0, 0, 0xC0,0,0,0,0,0,0,0x46)

#ifndef NOEXCHFORMGUIDS
DEFINE_EXCHFORMGUID(PS_EXCHFORM, 0x0C);
#endif // NOEXCHFORMGUIDS


/*
 *  E x t e n d e d   P r o p e r t i e s
 */


// Operation map property
#define psOpMap                     PS_EXCHFORM
#define ulKindOpMap                 MNID_ID
#define lidOpMap                    1
#define ptOpMap                     PT_STRING8

// Operation map indices
#define ichOpMapReservedCompose     0
#define ichOpMapOpen                1
#define ichOpMapReplyToSender       2
#define ichOpMapReplyToAll          3
#define ichOpMapForward             4
#define ichOpMapPrint               5
#define ichOpMapSaveAs              6
#define ichOpMapReservedDelivery    7
#define ichOpMapReplyToFolder       8

// Operation map values
#define chOpMapByClient             '0'
#define chOpMapByForm               '1'
#define chOpMapDisable              '2'


#endif // EXCHFORM_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\exchinst.h ===
// --exchinst.h-----------------------------------------------------------------
//
// Functions for installing Exchange objects.
//
// Copyright 1986 - 1998 Microsoft Corporation.  All Rights Reserved.
// -----------------------------------------------------------------------------

#ifndef _EXCHINST_H
#define _EXCHINST_H

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

#define OBJECT_GUID_MAIL_GATEWAY   "61DF5950-E40A-11ce-A2C9-00AA0040E865"
#define OBJECT_GUID_MAILBOX_AGENT  "75BB4220-E40A-11ce-A2C9-00AA0040E865"

//$--HrEnumOrganizations--------------------------------------------------------
//  Enumerates the organization name(s).
// -----------------------------------------------------------------------------
HRESULT HrEnumOrganizations(          // RETURNS: return code
    IN  LPSTR lpszRootDN,                // distinguished name of DIT root
    IN  LPSTR lpszServer,                // server name
    OUT LPSTR *lppszOrganizations);      // organizations

//$--HrEnumSites----------------------------------------------------------------
//  Enumerates the site name(s).
// -----------------------------------------------------------------------------
HRESULT HrEnumSites(                  // RETURNS: return code
    IN  LPSTR lpszServer,                // server name
    IN  LPSTR lpszOrganizationDN,        // distinguished name of organization
    OUT LPSTR *lppszSites);              // sites

//$--HrEnumContainers-----------------------------------------------------------
//  Enumerates the container name(s).
// -----------------------------------------------------------------------------
HRESULT HrEnumContainers(             // RETURNS: return code
    IN  LPSTR lpszServer,                // server name
    IN  LPSTR lpszSiteDN,                // distinguished name of site
    IN  BOOL  fSubtree,                  // sub-tree?
    OUT LPSTR *lppszContainers);         // containers
 
//$--HrEnumSiteAdmins-----------------------------------------------------------
//  Enumerates the administrators for a given site.
// -----------------------------------------------------------------------------
HRESULT HrEnumSiteAdmins(             // RETURNS: return code
    IN  LPSTR lpszServer,                // server name
    IN  LPSTR lpszSiteDN,                // distinguished name of site
    OUT LPSTR *lppszAdmins);             // administrator accounts

//$--HrEnumProductServices------------------------------------------------------
//  Enumerates the services for a product.
// -----------------------------------------------------------------------------
HRESULT HrEnumProductServices(        // RETURNS: return code
    IN  LPSTR lpszProductGuid,           // product GUID
    OUT LPSTR *lppszServices,            // service names
    OUT LPSTR *lppszDisplayNames);       // service display names

//$--HrInstallService-----------------------------------------------------------
//  Installs a service associated with an Exchange object.
// -----------------------------------------------------------------------------
HRESULT HrInstallService(            // RETURNS: return code
    IN LPSTR  lpszServer,               // server name
    IN LPSTR  lpszSiteDN,               // distinguished name of site
    IN LPSTR  lpszServiceDisplayName,   // service display name
    IN LPSTR  lpszServiceName,          // service name
    IN LPSTR  lpszCommonName,           // object relative distinguished name
    IN LPSTR  lpszObjectGuid,           // object GUID
    IN LPSTR  lpszProductGuid,          // product GUID
    IN LPSTR  lpszExeName,              // executable name
    IN LPCSTR lpszDependencies,         // dependencies
    IN LPSTR  lpszAccount,              // account
    IN LPSTR  lpszPassword);            // password

//$--HrGetServiceServerName-----------------------------------------------------
//  Get the Exchange server name associated with the service.
// -----------------------------------------------------------------------------
HRESULT HrGetServiceServerName(      // RETURNS: return code
    IN  LPSTR  lpszServiceName,         // service name
    OUT LPSTR  *lppszServerName);       // server name

//$--HrGetServiceSiteDN---------------------------------------------------------
//  Get the site DN of the Exchange object associated with the service.
// -----------------------------------------------------------------------------
HRESULT HrGetServiceSiteDN(          // RETURNS: return code
    IN  LPSTR  lpszServiceName,         // service name
    OUT LPSTR  *lppszSiteDN);           // site distinguished name

//$--HrGetServiceCommonName-----------------------------------------------------
//  Get the common name of the Exchange object associated with the service.
// -----------------------------------------------------------------------------
HRESULT HrGetServiceCommonName(      // RETURNS: return code
    IN  LPSTR  lpszServiceName,         // service name
    OUT LPSTR  *lppszCommonName);       // object relative distinguished name
 
//$--HrGetServiceObjectGUID-----------------------------------------------------
//  Get the object GUID associated with the service.
// -----------------------------------------------------------------------------
HRESULT HrGetServiceObjectGUID(      // RETURNS: return code
    IN  LPSTR  lpszServiceName,         // service name
    OUT LPSTR  *lppszObjectGUID);      // object GUID

//$--HrGetServiceProductGUID----------------------------------------------------
//  Get the product GUID associated with the service.
// -----------------------------------------------------------------------------
HRESULT HrGetServiceProductGUID(     // RETURNS: return code
    IN  LPSTR  lpszServiceName,        // service name
    OUT LPSTR  *lppszProductGUID);     // product GUID

//$--HrGetServiceDisplayName----------------------------------------------------
//  Get the display name associated with the service.
// -----------------------------------------------------------------------------
HRESULT HrGetServiceDisplayName(     // RETURNS: return code
    IN  LPSTR  lpszServiceName,        // service name
    OUT LPSTR  *lppszDisplayName);     // display name

//$--HrGetServiceExecutableName-------------------------------------------------
//  Get the executable name associated with the service.
// -----------------------------------------------------------------------------
HRESULT HrGetServiceExecutableName(  // RETURNS: return code
    IN  LPSTR  lpszServiceName,        // service name
    OUT LPSTR  *lppszExecutableName);  // executable name

//$--HrGetServiceAccountName----------------------------------------------------
//  Get the account name associated with the service.
// -----------------------------------------------------------------------------
HRESULT HrGetServiceAccountName(     // RETURNS: return code
    IN  LPSTR  lpszServiceName,        // service name
    OUT LPSTR  *lppszAccountName);     // account name

//$--HrRemoveRegistry-----------------------------------------------------------
//  Remove the registry for the service.
// -----------------------------------------------------------------------------
HRESULT HrRemoveRegistry(              // RETURNS: nothing
    IN LPCSTR lpszServiceName);        // service name

//$--HrRemoveService------------------------------------------------------------
//  Removes a service.
// -----------------------------------------------------------------------------
HRESULT HrRemoveService(             // RETURNS: return code
    IN LPCSTR lpszServiceName);        // service name

//$--HrInstallServicePerfMon----------------------------------------------------
//  Installs service performance monitoring.
// -----------------------------------------------------------------------------
HRESULT HrInstallServicePerfMon(         // RETURNS: return code
    IN LPSTR lpszServiceName,              // service name
    IN LPSTR lpszClassName,                // class name
    IN LPSTR lpszLibraryName,              // library name
    IN LPSTR lpszLibraryOpenFunction,      // open function
    IN LPSTR lpszLibraryCollectFunction,   // collect function
    IN LPSTR lpszLibraryCloseFunction) ;   // close function

//$--HrRemoveServicePerfMon-----------------------------------------------------
//  Removes service performance monitoring.
// -----------------------------------------------------------------------------
HRESULT HrRemoveServicePerfMon(          // RETURNS: return code
    IN  LPSTR lpszServiceName,             // service name
    IN  LPSTR lpszClassName,               // class name
    OUT BOOL   *lpfUnloadCounters);         // unload counters?

//$--HrCreateGatewayProfile-----------------------------------------------------
//  Creates a gateway profile.
// -----------------------------------------------------------------------------
HRESULT HrCreateGatewayProfile(          // RETURNS: return code
    IN LPSTR lpszServiceName,              // service name
    IN LPSTR lpszProfileName);             // profile name

//$--HrCreateMailboxAgentProfile------------------------------------------------
//  Creates a mailbox agent profile.
// -----------------------------------------------------------------------------
HRESULT HrCreateMailboxAgentProfile(     // RETURNS: return code
    IN LPSTR lpszServiceName,              // service name
    IN LPSTR lpszProfileName);             // profile name

//$--HrRemoveProfile------------------------------------------------------------
//  Removes a profile.
//------------------------------------------------------------------------------
HRESULT HrRemoveProfile(                 // RETURNS: return code
    IN LPSTR lpszProfileName);                // profile name

//$--HrMAPIProfileExists--------------------------------------------------------
//  Checks for an existing profile.
// -----------------------------------------------------------------------------
HRESULT HrMAPIProfileExists(            // RETURNS: return code
    IN LPPROFADMIN lpProfAdmin,         // profile admin object
    IN LPSTR       lpszProfileName);    // profile name

//$--HrInstallGateway-----------------------------------------------------------
// Installs a gateway into a given site.
// -----------------------------------------------------------------------------
HRESULT HrInstallGateway(           // RETURNS: return code
    IN LPSTR lpszServer,            // server name
    IN LPSTR lpszSiteDN,            // distinguished name of site
    IN LPSTR lpszDisplayName,       // display name
    IN LPSTR lpszCommonName,        // common name
    IN LPSTR lpszExtensionName,     // admin extension name
    IN LPSTR lpszExtensionData,     // extension data file
    IN LPSTR lpszAddressType,       // address type handled by this gateway
    IN LPSTR lpszAccountName,       // account name
    IN BOOL  fCanPreserveDNs);      // can this gateway preserve DNs?

//$--HrRemoveGateway------------------------------------------------------------
//  Removes a gateway from a given site.
// -----------------------------------------------------------------------------
HRESULT HrRemoveGateway(            // RETURNS: return code
    IN LPSTR lpszServer,            // server name
    IN LPSTR lpszSiteDN,            // distinguished name of site
    IN LPSTR lpszCommonName);       // common name

//$--HrGatewayExists------------------------------------------------------------
//  Checks if a gateway exists on a given site.
// -----------------------------------------------------------------------------
HRESULT HrGatewayExists(            // RETURNS: return code
    IN LPSTR lpszServer,            // server name
    IN LPSTR lpszSiteDN,            // distinguished name of site
    IN LPSTR lpszCommonName);       // common name

//$--HrInstallMailboxAgent------------------------------------------------------
//  Installs a mailbox agent into a given site.
// -----------------------------------------------------------------------------
HRESULT HrInstallMailboxAgent(      // RETURNS: return code
    IN LPSTR lpszServer,            // server name
    IN LPSTR lpszSiteDN,            // distinguished name of site
    IN LPSTR lpszDisplayName,       // display name
    IN LPSTR lpszRDN,               // relative distinguished name
    IN LPSTR lpszExtensionName,     // admin extension name
    IN LPSTR lpszExtensionData,     // extension data file
    IN LPSTR lpszAccountName);      // account name

//$--HrRemoveMailboxAgent-------------------------------------------------------
// Removes a mailbox agent from a given site.
// -----------------------------------------------------------------------------
HRESULT HrRemoveMailboxAgent(       // RETURNS: return code
    IN LPSTR lpszServer,            // server name
    IN LPSTR lpszSiteDN,            // distinguished name of site
    IN LPSTR lpszRDN);              // relative distinguished name

//$--HrMailboxAgentExists-------------------------------------------------------
// Checks if a mailbox agent exists on a given site.
// -----------------------------------------------------------------------------
HRESULT HrMailboxAgentExists(       // RETURNS: return code
    IN LPSTR lpszServer,            // server name
    IN LPSTR lpszSiteDN,            // distinguished name of site
    IN LPSTR lpszRDN);              // relative distinguished name

//$--HrInstallAddressType-------------------------------------------------------
//  Installs an address type object into a given site.
// -----------------------------------------------------------------------------
HRESULT HrInstallAddressType(       // RETURNS: return code
    IN LPSTR lpszServer,            // server name
    IN LPSTR lpszSiteDN,            // distinguished name of site
    IN LPSTR lpszDisplayName,       // display name
    IN LPSTR lpszCommonName,        // common name
    IN DWORD  dwFileVersionMS,      // high-order 32 bits of file version number
    IN DWORD  dwFileVersionLS,      // low-order 32 bits of file version number
    IN LPSTR lpszProxyGenDLL,       // proxy generator DLL file name
    IN LPSTR lpszMachineType);      // machine type (e.g. "i386")

//$--HrRemoveAddressType--------------------------------------------------------
//  Removes an address type from a given site.
// -----------------------------------------------------------------------------
HRESULT HrRemoveAddressType(        // RETURNS: return code
    IN LPSTR lpszServer,            // server name
    IN LPSTR lpszSiteDN,            // distinguished name of site
    IN LPSTR lpszCommonName,        // common name
    IN LPSTR lpszMachineType);      // machine type (e.g. "i386")

//$--HrAddressTypeExists--------------------------------------------------------
//  Checks if an address type exists on a given site.
// -----------------------------------------------------------------------------
HRESULT HrAddressTypeExists(        // RETURNS: return code
    IN LPSTR lpszServer,            // server name
    IN LPSTR lpszSiteDN,            // distinguished name of site
    IN LPSTR lpszCommonName,        // common name
    IN LPSTR lpszMachineType);      // machine type (e.g. "i386")

//$--HrGetAddressTypeVersion----------------------------------------------------
//  Get the version of an address type object in a given site.
// -----------------------------------------------------------------------------
HRESULT HrGetAddressTypeVersion(    // RETURNS: return code
    IN LPSTR lpszServer,            // server name
    IN LPSTR lpszSiteDN,            // distinguished name of site
    IN LPSTR lpszCommonName,        // common name
    IN LPSTR lpszMachineType,       // machine type (e.g. "i386")
    OUT DWORD *lpdwFileVersionMS,   // high-order 32 bits of file version
    OUT DWORD *lpdwFileVersionLS);  // low-order 32 bits of file version

//$--HrInstallAddressTemplate---------------------------------------------------
//  Installs an address template into a given site.
// -----------------------------------------------------------------------------
HRESULT HrInstallAddressTemplate(   // RETURNS: return code
    IN LPSTR lpszServer,            // server name
    IN LPSTR lpszSiteDN,            // distinguished name of site
    IN LPSTR lpszDisplayName,       // display name
    IN LPSTR lpszCommonName,        // common name
    IN LPSTR lpszAddressSyntax,     // address syntax generator file
    IN LPSTR lpszAddressType,       // address type supported by this template
    IN LPSTR lpszPerMessageDDT,     // per-message dialog file
    IN LPSTR lpszPerRecipientDDT,   // per-recipient dialog file
    IN LPSTR lpszAddressEntryDDT,   // address entry dialog file
    IN LPSTR lpszLanguage,          // language supported by this template
    IN LPSTR lpszHelpData16,        // help data for 16-bit clients
    IN LPSTR lpszHelpData32,        // help data for 32-bit clients
    IN LPSTR lpszHelpFile);         // client help file name

//$--HrRemoveAddressTemplate----------------------------------------------------
//  Removes an address template from a given site.
// -----------------------------------------------------------------------------
HRESULT HrRemoveAddressTemplate(    // RETURNS: return code
    IN LPSTR lpszServer,            // server name
    IN LPSTR lpszSiteDN,            // distinguished name of site
    IN LPSTR lpszCommonName,        // common name
    IN LPSTR lpszAddressType,       // address type supported by this template
    IN LPSTR lpszLanguage);         // language supported by this template

//$--HrAddressTemplateExists----------------------------------------------------
//  Checks if an address template exists on a given site.
// -----------------------------------------------------------------------------
HRESULT HrAddressTemplateExists(    // RETURNS: return code
    IN LPSTR lpszServer,            // server name
    IN LPSTR lpszSiteDN,            // distinguished name of site
    IN LPSTR lpszCommonName,        // common name
    IN LPSTR lpszAddressType,       // address type supported by this template
    IN LPSTR lpszLanguage);         // language supported by this template

//$--HrInstallAdminExtension----------------------------------------------------
//  Installs an admin extension object into a given site.
// -----------------------------------------------------------------------------
HRESULT HrInstallAdminExtension(    // RETURNS: return code
    IN LPSTR lpszServer,            // server name
    IN LPSTR lpszSiteDN,            // distinguished name of site
    IN LPSTR lpszDisplayName,       // display name
    IN LPSTR lpszCommonName,        // common name
    IN DWORD dwFileVersionMS,       // high-order 32 bits of file version number
    IN DWORD dwFileVersionLS,       // low-order 32 bits of file version number
    IN LPSTR lpszExtensionDLL,      // admin extension DLL file name
    IN LPSTR lpszMachineType);      // machine type (e.g. "i386")


//$--HrRemoveAdminExtension-----------------------------------------------------
//  Removes an admin extension from a given site.
// -----------------------------------------------------------------------------
HRESULT HrRemoveAdminExtension(     // RETURNS: return code
    IN LPSTR lpszServer,            // server name
    IN LPSTR lpszSiteDN,            // distinguished name of site
    IN LPSTR lpszCommonName,        // common name
    IN LPSTR lpszMachineType);      // machine type (e.g. "i386")

//$--HrAdminExtensionExists-----------------------------------------------------
//  Checks if an admin extension exists on a given site.
// -----------------------------------------------------------------------------
HRESULT HrAdminExtensionExists(     // RETURNS: return code
    IN LPSTR lpszServer,            // server name
    IN LPSTR lpszSiteDN,            // distinguished name of site
    IN LPSTR lpszCommonName,        // common name
    IN LPSTR lpszMachineType);      // machine type (e.g. "i386")

//$--HrGetAdminExtensionVersion-------------------------------------------------
//  Get the version of an admin extension object in a given site.
// -----------------------------------------------------------------------------
HRESULT HrGetAdminExtensionVersion(     // RETURNS: return code
    IN LPSTR lpszServer,                // server name
    IN LPSTR lpszSiteDN,                // distinguished name of site
    IN LPSTR lpszCommonName,            // common name
    IN LPSTR lpszMachineType,           // machine type (e.g. "i386")
    OUT DWORD *lpdwFileVersionMS,       // high-order 32 bits of file version
    OUT DWORD *lpdwFileVersionLS);      // low-order 32 bits of file version

//$--HrInstallContainer---------------------------------------------------------
//  Installs a container in the directory.
// -----------------------------------------------------------------------------
HRESULT HrInstallContainer(         // RETURNS: return code
    IN LPSTR lpszServer,            // server name
    IN LPSTR lpszBasePoint,         // base point
    IN LPSTR lpszCommonName,        // common name
    IN LPSTR lpszDisplayName,       // display name
    IN LPSTR lpszContainerInfo);    // container information

//$--HrRemoveContainer----------------------------------------------------------
//  Removes a container from the directory.
// -----------------------------------------------------------------------------
HRESULT HrRemoveContainer(          // RETURNS: return code
    IN LPSTR lpszServer,            // server name
    IN LPSTR lpszBasePoint,         // base point
    IN LPSTR lpszCommonName);       // common name

//$--HrContainerExists----------------------------------------------------------
//  Checks if a container exists in the directory.
// -----------------------------------------------------------------------------
HRESULT HrContainerExists(          // RETURNS: return code
    IN LPSTR lpszServer,            // server name
    IN LPSTR lpszBasePoint,         // base point
    IN LPSTR lpszCommonName);       // common name

//$--HrInstallAddressTemplateContainer------------------------------------------
//  Installs an address template container in the directory.
// -----------------------------------------------------------------------------
HRESULT HrInstallAddressTemplateContainer(  // RETURNS: return code
    IN LPSTR lpszServer,                    // server name
    IN LPSTR lpszSiteDN,                    // site distinguished name
    IN LPSTR lpszLanguage,                  // language supported by container
    IN LPSTR lpszDisplayName);              // display name

//$--HrRemoveAddressTemplateContainer-------------------------------------------
//  Removes an address template container from the directory.
// -----------------------------------------------------------------------------
HRESULT HrRemoveAddressTemplateContainer(   // RETURNS: return code
    IN LPSTR lpszServer,                    // server name
    IN LPSTR lpszSiteDN,                    // site distinguished name
    IN LPSTR lpszLanguage);                 // language supported by container

//$--HrAddressTemplateContainerExists-------------------------------------------
//  Checks if an address template container exists in the directory.
// -----------------------------------------------------------------------------
HRESULT HrAddressTemplateContainerExists(   // RETURNS: return code
    IN LPSTR lpszServer,                    // server name
    IN LPSTR lpszSiteDN,                    // site distinguished name
    IN LPSTR lpszLanguage);                 // language supported by container

//$--HrInstallGatewayProxy------------------------------------------------------
//  Installs a gateway proxy into a given site.
// -----------------------------------------------------------------------------
HRESULT HrInstallGatewayProxy(      // RETURNS: return code
    IN LPSTR lpszServer,            // server name
    IN LPSTR lpszSiteDN,            // distinguished name of site
    IN LPSTR lpszProxy);            // gateway proxy

//$--HrRemoveGatewayProxy-------------------------------------------------------
//  Removes a gateway proxy from a given site.
// -----------------------------------------------------------------------------
HRESULT HrRemoveGatewayProxy(       // RETURNS: return code
    IN LPSTR lpszServer,            // server name
    IN LPSTR lpszSiteDN,            // distinguished name of site
    IN LPSTR lpszProxy);            // gateway proxy

//$--FHasAdminPrivs-------------------------------------------------------------
//  Returns TRUE if the current user is an administrator.
// -----------------------------------------------------------------------------
BOOL FHasAdminPrivs(                // RETURNS: TRUE/FALSE
    void);                          // no arguments


//$--HrInstallMessageConverter--------------------------------------------------
// Installs a message conversion DLL.
// -----------------------------------------------------------------------------
HRESULT HrInstallMessageConverter(      // RETURNS: return code
    IN LPSTR lpszConverter,             // converter name
    IN LPSTR lpszDllName,               // name of conversion DLL
    IN LPSTR lpszMessageClasses,        // message classes
    IN LPSTR lpszOptions,               // options string
    IN LPSTR lpszPoint);                // conversion point

//$--HrRemoveMessageConverter--------------------------------------------------
//  Delete a message conversion DLL.
// ----------------------------------------------------------------------------
HRESULT HrRemoveMessageConverter(       // RETURNS: return code
    IN LPCSTR lpszConverter);           // converter name


//$--HrAdminProgramExists------------------------------------------------------
//  Check if the admin program has been installed on the local computer.
// ----------------------------------------------------------------------------
HRESULT HrAdminProgramExists(           // RETURNS: return code
    void);                              // nothing

//$--HrSetGatewayBit------------------------------------------------------------
//  This function will set the gateway bit on a given server.
// -----------------------------------------------------------------------------
HRESULT HrSetGatewayBit(                // RETURNS: return code
    IN  LPSTR lpszServer,               // server name
    IN  LPSTR lpszSiteDN,               // site distinguished name
    IN  LPSTR lpszServerName);          // server name

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\fastfile.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995-1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       fastfile.h
 *  Content:	Definitions for fastfile access.
 *
 * THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
 * EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
 * WARRANTIES OF MERCHANTBILITY AND/OR FITNESS FOR A PARTICULAR PURPOSE.
 *
 ***************************************************************************/

typedef LPVOID	HFASTFILE;

extern BOOL FastFileInit( LPSTR fname, int max_handles );
extern void FastFileFini( void );
extern HFASTFILE FastFileOpen( LPSTR name );
extern BOOL FastFileClose( HFASTFILE pfe );
extern BOOL FastFileRead( HFASTFILE pfh, LPVOID ptr, int size );
extern BOOL FastFileSeek( HFASTFILE pfe, int off, int how );
extern long FastFileTell( HFASTFILE pfe );
extern LPVOID FastFileLock( HFASTFILE pfe, int off, int len );
extern BOOL FastFileUnlock( HFASTFILE pfe, int off, int len );
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\exdispid.h ===
#ifndef EXDISPID_H_
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright 1995-1999 Microsoft Corporation. All Rights Reserved.
//
//  File: exdispid.h
//
//--------------------------------------------------------------------------


//
// Dispatch IDS for IExplorer Dispatch Events.
//
#define DISPID_BEFORENAVIGATE     100   // this is sent before navigation to give a chance to abort
#define DISPID_NAVIGATECOMPLETE   101   // in async, this is sent when we have enough to show
#define DISPID_STATUSTEXTCHANGE   102
#define DISPID_QUIT               103
#define DISPID_DOWNLOADCOMPLETE   104
#define DISPID_COMMANDSTATECHANGE 105
#define DISPID_DOWNLOADBEGIN      106
#define DISPID_NEWWINDOW          107   // sent when a new window should be created
#define DISPID_PROGRESSCHANGE     108   // sent when download progress is updated
#define DISPID_WINDOWMOVE         109   // sent when main window has been moved
#define DISPID_WINDOWRESIZE       110   // sent when main window has been sized
#define DISPID_WINDOWACTIVATE     111   // sent when main window has been activated
#define DISPID_PROPERTYCHANGE     112   // sent when the PutProperty method is called
#define DISPID_TITLECHANGE        113   // sent when the document title changes
#define DISPID_TITLEICONCHANGE    114   // sent when the top level window icon may have changed.

#define DISPID_FRAMEBEFORENAVIGATE    200
#define DISPID_FRAMENAVIGATECOMPLETE  201
#define DISPID_FRAMENEWWINDOW         204

#define DISPID_BEFORENAVIGATE2      250   // hyperlink clicked on
#define DISPID_NEWWINDOW2           251
#define DISPID_NAVIGATECOMPLETE2    252   // UIActivate new document
#define DISPID_ONQUIT               253
#define DISPID_ONVISIBLE            254   // sent when the window goes visible/hidden
#define DISPID_ONTOOLBAR            255   // sent when the toolbar should be shown/hidden
#define DISPID_ONMENUBAR            256   // sent when the menubar should be shown/hidden
#define DISPID_ONSTATUSBAR          257   // sent when the statusbar should be shown/hidden
#define DISPID_ONFULLSCREEN         258   // sent when kiosk mode should be on/off
#define DISPID_DOCUMENTCOMPLETE     259   // new document goes ReadyState_Complete
#define DISPID_ONTHEATERMODE        260   // sent when theater mode should be on/off
#define DISPID_ONADDRESSBAR         261   // sent when the address bar should be shown/hidden

// define the events for the shell wiwndow list
#define DISPID_WINDOWREGISTERED     200     // Window registered
#define DISPID_WINDOWREVOKED        201     // Window Revoked

#define DISPID_RESETFIRSTBOOTMODE       1
#define DISPID_RESETSAFEMODE            2
#define DISPID_REFRESHOFFLINEDESKTOP    3
#define DISPID_ADDFAVORITE              4
#define DISPID_ADDCHANNEL               5
#define DISPID_ADDDESKTOPCOMPONENT      6
#define DISPID_ISSUBSCRIBED             7
#define DISPID_NAVIGATEANDFIND          8
#define DISPID_IMPORTEXPORTFAVORITES    9
#define DISPID_AUTOCOMPLETESAVEFORM     10
#define DISPID_AUTOSCAN                 11
#define DISPID_AUTOCOMPLETEATTACH       12
#define DISPID_SHOWBROWSERUI            13
#define DISPID_SHELLUIHELPERLAST        13

#define DISPID_ADVANCEERROR             10
#define DISPID_RETREATERROR             11
#define DISPID_CANADVANCEERROR          12
#define DISPID_CANRETREATERROR          13
#define DISPID_GETERRORLINE             14
#define DISPID_GETERRORCHAR             15
#define DISPID_GETERRORCODE             16
#define DISPID_GETERRORMSG              17
#define DISPID_GETERRORURL              18
#define DISPID_GETDETAILSSTATE          19
#define DISPID_SETDETAILSSTATE          20
#define DISPID_GETPERERRSTATE           21
#define DISPID_SETPERERRSTATE           22
#define DISPID_GETALWAYSSHOWLOCKSTATE   23

// Dispatch IDS for ShellFavoritesNameSpace Dispatch Events.
//
#define DISPID_SELECTIONCHANGE     1000

#define EXDISPID_H_
#endif // EXDISPID_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\ExchHndl.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.01.75 */
/* at Fri Mar 27 08:32:24 1998
 */
/* Compiler settings for J:\events\src\SS\exchhndl.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __exchhndl_h__
#define __exchhndl_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IExchangeEventHandler_FWD_DEFINED__
#define __IExchangeEventHandler_FWD_DEFINED__
typedef interface IExchangeEventHandler IExchangeEventHandler;
#endif 	/* __IExchangeEventHandler_FWD_DEFINED__ */


#ifndef __IEventSource_FWD_DEFINED__
#define __IEventSource_FWD_DEFINED__
typedef interface IEventSource IEventSource;
#endif 	/* __IEventSource_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/****************************************
 * Generated header for interface: __MIDL_itf_exchhndl_0000
 * at Fri Mar 27 08:32:24 1998
 * using MIDL 3.01.75
 ****************************************/
/* [local] */ 


//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright 1997 - 1999 Microsoft Corporation.
//
//--------------------------------------------------------------------------


extern RPC_IF_HANDLE __MIDL_itf_exchhndl_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_exchhndl_0000_v0_0_s_ifspec;

#ifndef __IExchangeEventHandler_INTERFACE_DEFINED__
#define __IExchangeEventHandler_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IExchangeEventHandler
 * at Fri Mar 27 08:32:24 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][oleautomation][helpstring][uuid][object] */ 



EXTERN_C const IID IID_IExchangeEventHandler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("69E54156-B371-11D0-BCD9-00AA00C1AB1C")
    IExchangeEventHandler : public IUnknown
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ExecuteEvent( 
            /* [in] */ IDispatch __RPC_FAR *pEventSource) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IExchangeEventHandlerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IExchangeEventHandler __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IExchangeEventHandler __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IExchangeEventHandler __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ExecuteEvent )( 
            IExchangeEventHandler __RPC_FAR * This,
            /* [in] */ IDispatch __RPC_FAR *pEventSource);
        
        END_INTERFACE
    } IExchangeEventHandlerVtbl;

    interface IExchangeEventHandler
    {
        CONST_VTBL struct IExchangeEventHandlerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IExchangeEventHandler_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IExchangeEventHandler_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IExchangeEventHandler_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IExchangeEventHandler_ExecuteEvent(This,pEventSource)	\
    (This)->lpVtbl -> ExecuteEvent(This,pEventSource)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IExchangeEventHandler_ExecuteEvent_Proxy( 
    IExchangeEventHandler __RPC_FAR * This,
    /* [in] */ IDispatch __RPC_FAR *pEventSource);


void __RPC_STUB IExchangeEventHandler_ExecuteEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IExchangeEventHandler_INTERFACE_DEFINED__ */


#ifndef __IEventSource_INTERFACE_DEFINED__
#define __IEventSource_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEventSource
 * at Fri Mar 27 08:32:24 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][oleautomation][helpstring][uuid][object] */ 



EXTERN_C const IID IID_IEventSource;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("69E54152-B371-11D0-BCD9-00AA00C1AB1C")
    IEventSource : public IUnknown
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Source( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *pSource) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Source( 
            /* [in] */ IUnknown __RPC_FAR *varSource) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_SourceID( 
            /* [retval][out] */ BSTR __RPC_FAR *pSourceID) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_SourceID( 
            /* [in] */ BSTR varSourceID) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_MessageID( 
            /* [retval][out] */ BSTR __RPC_FAR *pMessageID) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_MessageID( 
            /* [in] */ BSTR varMessageID) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Session( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *pSession) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Session( 
            /* [in] */ IUnknown __RPC_FAR *varSession) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_EventType( 
            /* [retval][out] */ DWORD __RPC_FAR *pEventType) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_EventType( 
            /* [in] */ DWORD varEventType) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Response( 
            /* [retval][out] */ VARIANT __RPC_FAR *pResponse) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Response( 
            /* [in] */ VARIANT varResponse) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_MaxExecutionTime( 
            /* [retval][out] */ DWORD __RPC_FAR *pMaxExecutionTime) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_MaxExecutionTime( 
            /* [in] */ DWORD varMaxExecutionTime) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEventSourceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEventSource __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEventSource __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEventSource __RPC_FAR * This);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Source )( 
            IEventSource __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *pSource);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Source )( 
            IEventSource __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *varSource);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SourceID )( 
            IEventSource __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pSourceID);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_SourceID )( 
            IEventSource __RPC_FAR * This,
            /* [in] */ BSTR varSourceID);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_MessageID )( 
            IEventSource __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pMessageID);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_MessageID )( 
            IEventSource __RPC_FAR * This,
            /* [in] */ BSTR varMessageID);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Session )( 
            IEventSource __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *pSession);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Session )( 
            IEventSource __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *varSession);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_EventType )( 
            IEventSource __RPC_FAR * This,
            /* [retval][out] */ DWORD __RPC_FAR *pEventType);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_EventType )( 
            IEventSource __RPC_FAR * This,
            /* [in] */ DWORD varEventType);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Response )( 
            IEventSource __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pResponse);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Response )( 
            IEventSource __RPC_FAR * This,
            /* [in] */ VARIANT varResponse);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_MaxExecutionTime )( 
            IEventSource __RPC_FAR * This,
            /* [retval][out] */ DWORD __RPC_FAR *pMaxExecutionTime);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_MaxExecutionTime )( 
            IEventSource __RPC_FAR * This,
            /* [in] */ DWORD varMaxExecutionTime);
        
        END_INTERFACE
    } IEventSourceVtbl;

    interface IEventSource
    {
        CONST_VTBL struct IEventSourceVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEventSource_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEventSource_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEventSource_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEventSource_get_Source(This,pSource)	\
    (This)->lpVtbl -> get_Source(This,pSource)

#define IEventSource_put_Source(This,varSource)	\
    (This)->lpVtbl -> put_Source(This,varSource)

#define IEventSource_get_SourceID(This,pSourceID)	\
    (This)->lpVtbl -> get_SourceID(This,pSourceID)

#define IEventSource_put_SourceID(This,varSourceID)	\
    (This)->lpVtbl -> put_SourceID(This,varSourceID)

#define IEventSource_get_MessageID(This,pMessageID)	\
    (This)->lpVtbl -> get_MessageID(This,pMessageID)

#define IEventSource_put_MessageID(This,varMessageID)	\
    (This)->lpVtbl -> put_MessageID(This,varMessageID)

#define IEventSource_get_Session(This,pSession)	\
    (This)->lpVtbl -> get_Session(This,pSession)

#define IEventSource_put_Session(This,varSession)	\
    (This)->lpVtbl -> put_Session(This,varSession)

#define IEventSource_get_EventType(This,pEventType)	\
    (This)->lpVtbl -> get_EventType(This,pEventType)

#define IEventSource_put_EventType(This,varEventType)	\
    (This)->lpVtbl -> put_EventType(This,varEventType)

#define IEventSource_get_Response(This,pResponse)	\
    (This)->lpVtbl -> get_Response(This,pResponse)

#define IEventSource_put_Response(This,varResponse)	\
    (This)->lpVtbl -> put_Response(This,varResponse)

#define IEventSource_get_MaxExecutionTime(This,pMaxExecutionTime)	\
    (This)->lpVtbl -> get_MaxExecutionTime(This,pMaxExecutionTime)

#define IEventSource_put_MaxExecutionTime(This,varMaxExecutionTime)	\
    (This)->lpVtbl -> put_MaxExecutionTime(This,varMaxExecutionTime)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IEventSource_get_Source_Proxy( 
    IEventSource __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *pSource);


void __RPC_STUB IEventSource_get_Source_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IEventSource_put_Source_Proxy( 
    IEventSource __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *varSource);


void __RPC_STUB IEventSource_put_Source_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IEventSource_get_SourceID_Proxy( 
    IEventSource __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pSourceID);


void __RPC_STUB IEventSource_get_SourceID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IEventSource_put_SourceID_Proxy( 
    IEventSource __RPC_FAR * This,
    /* [in] */ BSTR varSourceID);


void __RPC_STUB IEventSource_put_SourceID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IEventSource_get_MessageID_Proxy( 
    IEventSource __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pMessageID);


void __RPC_STUB IEventSource_get_MessageID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IEventSource_put_MessageID_Proxy( 
    IEventSource __RPC_FAR * This,
    /* [in] */ BSTR varMessageID);


void __RPC_STUB IEventSource_put_MessageID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IEventSource_get_Session_Proxy( 
    IEventSource __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *pSession);


void __RPC_STUB IEventSource_get_Session_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IEventSource_put_Session_Proxy( 
    IEventSource __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *varSession);


void __RPC_STUB IEventSource_put_Session_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IEventSource_get_EventType_Proxy( 
    IEventSource __RPC_FAR * This,
    /* [retval][out] */ DWORD __RPC_FAR *pEventType);


void __RPC_STUB IEventSource_get_EventType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IEventSource_put_EventType_Proxy( 
    IEventSource __RPC_FAR * This,
    /* [in] */ DWORD varEventType);


void __RPC_STUB IEventSource_put_EventType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IEventSource_get_Response_Proxy( 
    IEventSource __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pResponse);


void __RPC_STUB IEventSource_get_Response_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IEventSource_put_Response_Proxy( 
    IEventSource __RPC_FAR * This,
    /* [in] */ VARIANT varResponse);


void __RPC_STUB IEventSource_put_Response_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IEventSource_get_MaxExecutionTime_Proxy( 
    IEventSource __RPC_FAR * This,
    /* [retval][out] */ DWORD __RPC_FAR *pMaxExecutionTime);


void __RPC_STUB IEventSource_get_MaxExecutionTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IEventSource_put_MaxExecutionTime_Proxy( 
    IEventSource __RPC_FAR * This,
    /* [in] */ DWORD varMaxExecutionTime);


void __RPC_STUB IEventSource_put_MaxExecutionTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEventSource_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long __RPC_FAR *, unsigned long            , VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long __RPC_FAR *, VARIANT __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\excpt.h ===
/***
*excpt.h - defines exception values, types and routines
*
*       Copyright (c) 1990-1997, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains the definitions and prototypes for the compiler-
*       dependent intrinsics, support functions and keywords which implement
*       the structured exception handling extensions.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_EXCPT
#define _INC_EXCPT

#if     !defined(_WIN32) && !defined(_MAC)
#error ERROR: Only Mac or Win32 targets supported!
#endif


#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif



/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

/* Define _CRTAPI1 (for compatibility with the NT SDK) */

#ifndef _CRTAPI1
#if	_MSC_VER >= 800 && _M_IX86 >= 300
#define _CRTAPI1 __cdecl
#else
#define _CRTAPI1
#endif
#endif


/*
 * Exception disposition return values.
 */
typedef enum _EXCEPTION_DISPOSITION {
    ExceptionContinueExecution,
    ExceptionContinueSearch,
    ExceptionNestedException,
    ExceptionCollidedUnwind
} EXCEPTION_DISPOSITION;


/*
 * Prototype for SEH support function.
 */

#ifdef  _M_IX86

/*
 * Declarations to keep MS C 8 (386/486) compiler happy
 */
struct _EXCEPTION_RECORD;
struct _CONTEXT;

EXCEPTION_DISPOSITION __cdecl _except_handler (
    struct _EXCEPTION_RECORD *ExceptionRecord,
    void * EstablisherFrame,
    struct _CONTEXT *ContextRecord,
    void * DispatcherContext
    );

#elif   defined(_M_MRX000) || defined(_M_ALPHA) || defined(_M_PPC)

/*
 * Declarations to keep MIPS, ALPHA, and PPC compiler happy
 */
typedef struct _EXCEPTION_POINTERS *Exception_info_ptr;
struct _EXCEPTION_RECORD;
struct _CONTEXT;
struct _DISPATCHER_CONTEXT;


_CRTIMP EXCEPTION_DISPOSITION __C_specific_handler (
    struct _EXCEPTION_RECORD *ExceptionRecord,
    void *EstablisherFrame,
    struct _CONTEXT *ContextRecord,
    struct _DISPATCHER_CONTEXT *DispatcherContext
    );

#endif


/*
 * Keywords and intrinsics for SEH
 */

#ifdef  _MSC_VER

#define GetExceptionCode            _exception_code
#define exception_code              _exception_code
#define GetExceptionInformation     (struct _EXCEPTION_POINTERS *)_exception_info
#define exception_info              (struct _EXCEPTION_POINTERS *)_exception_info
#define AbnormalTermination         _abnormal_termination
#define abnormal_termination        _abnormal_termination

unsigned long __cdecl _exception_code(void);
void *        __cdecl _exception_info(void);
int           __cdecl _abnormal_termination(void);

#endif


/*
 * Legal values for expression in except().
 */

#define EXCEPTION_EXECUTE_HANDLER       1
#define EXCEPTION_CONTINUE_SEARCH       0
#define EXCEPTION_CONTINUE_EXECUTION    -1



#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_EXCPT */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\exdisp.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0279 */
/* at Fri Sep 24 19:24:07 1999
 */
/* Compiler settings for exdisp.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __exdisp_h__
#define __exdisp_h__

/* Forward Declarations */ 

#ifndef __IWebBrowser_FWD_DEFINED__
#define __IWebBrowser_FWD_DEFINED__
typedef interface IWebBrowser IWebBrowser;
#endif 	/* __IWebBrowser_FWD_DEFINED__ */


#ifndef __DWebBrowserEvents_FWD_DEFINED__
#define __DWebBrowserEvents_FWD_DEFINED__
typedef interface DWebBrowserEvents DWebBrowserEvents;
#endif 	/* __DWebBrowserEvents_FWD_DEFINED__ */


#ifndef __IWebBrowserApp_FWD_DEFINED__
#define __IWebBrowserApp_FWD_DEFINED__
typedef interface IWebBrowserApp IWebBrowserApp;
#endif 	/* __IWebBrowserApp_FWD_DEFINED__ */


#ifndef __IWebBrowser2_FWD_DEFINED__
#define __IWebBrowser2_FWD_DEFINED__
typedef interface IWebBrowser2 IWebBrowser2;
#endif 	/* __IWebBrowser2_FWD_DEFINED__ */


#ifndef __DWebBrowserEvents2_FWD_DEFINED__
#define __DWebBrowserEvents2_FWD_DEFINED__
typedef interface DWebBrowserEvents2 DWebBrowserEvents2;
#endif 	/* __DWebBrowserEvents2_FWD_DEFINED__ */


#ifndef __WebBrowser_V1_FWD_DEFINED__
#define __WebBrowser_V1_FWD_DEFINED__

#ifdef __cplusplus
typedef class WebBrowser_V1 WebBrowser_V1;
#else
typedef struct WebBrowser_V1 WebBrowser_V1;
#endif /* __cplusplus */

#endif 	/* __WebBrowser_V1_FWD_DEFINED__ */


#ifndef __WebBrowser_FWD_DEFINED__
#define __WebBrowser_FWD_DEFINED__

#ifdef __cplusplus
typedef class WebBrowser WebBrowser;
#else
typedef struct WebBrowser WebBrowser;
#endif /* __cplusplus */

#endif 	/* __WebBrowser_FWD_DEFINED__ */


#ifndef __InternetExplorer_FWD_DEFINED__
#define __InternetExplorer_FWD_DEFINED__

#ifdef __cplusplus
typedef class InternetExplorer InternetExplorer;
#else
typedef struct InternetExplorer InternetExplorer;
#endif /* __cplusplus */

#endif 	/* __InternetExplorer_FWD_DEFINED__ */


#ifndef __ShellBrowserWindow_FWD_DEFINED__
#define __ShellBrowserWindow_FWD_DEFINED__

#ifdef __cplusplus
typedef class ShellBrowserWindow ShellBrowserWindow;
#else
typedef struct ShellBrowserWindow ShellBrowserWindow;
#endif /* __cplusplus */

#endif 	/* __ShellBrowserWindow_FWD_DEFINED__ */


#ifndef __DShellWindowsEvents_FWD_DEFINED__
#define __DShellWindowsEvents_FWD_DEFINED__
typedef interface DShellWindowsEvents DShellWindowsEvents;
#endif 	/* __DShellWindowsEvents_FWD_DEFINED__ */


#ifndef __IShellWindows_FWD_DEFINED__
#define __IShellWindows_FWD_DEFINED__
typedef interface IShellWindows IShellWindows;
#endif 	/* __IShellWindows_FWD_DEFINED__ */


#ifndef __ShellWindows_FWD_DEFINED__
#define __ShellWindows_FWD_DEFINED__

#ifdef __cplusplus
typedef class ShellWindows ShellWindows;
#else
typedef struct ShellWindows ShellWindows;
#endif /* __cplusplus */

#endif 	/* __ShellWindows_FWD_DEFINED__ */


#ifndef __IShellUIHelper_FWD_DEFINED__
#define __IShellUIHelper_FWD_DEFINED__
typedef interface IShellUIHelper IShellUIHelper;
#endif 	/* __IShellUIHelper_FWD_DEFINED__ */


#ifndef __ShellUIHelper_FWD_DEFINED__
#define __ShellUIHelper_FWD_DEFINED__

#ifdef __cplusplus
typedef class ShellUIHelper ShellUIHelper;
#else
typedef struct ShellUIHelper ShellUIHelper;
#endif /* __cplusplus */

#endif 	/* __ShellUIHelper_FWD_DEFINED__ */


#ifndef ___ShellFavoritesNameSpaceEvents_FWD_DEFINED__
#define ___ShellFavoritesNameSpaceEvents_FWD_DEFINED__
typedef interface _ShellFavoritesNameSpaceEvents _ShellFavoritesNameSpaceEvents;
#endif 	/* ___ShellFavoritesNameSpaceEvents_FWD_DEFINED__ */


#ifndef __IShellFavoritesNameSpace_FWD_DEFINED__
#define __IShellFavoritesNameSpace_FWD_DEFINED__
typedef interface IShellFavoritesNameSpace IShellFavoritesNameSpace;
#endif 	/* __IShellFavoritesNameSpace_FWD_DEFINED__ */


#ifndef __ShellFavoritesNameSpace_FWD_DEFINED__
#define __ShellFavoritesNameSpace_FWD_DEFINED__

#ifdef __cplusplus
typedef class ShellFavoritesNameSpace ShellFavoritesNameSpace;
#else
typedef struct ShellFavoritesNameSpace ShellFavoritesNameSpace;
#endif /* __cplusplus */

#endif 	/* __ShellFavoritesNameSpace_FWD_DEFINED__ */


#ifndef __IScriptErrorList_FWD_DEFINED__
#define __IScriptErrorList_FWD_DEFINED__
typedef interface IScriptErrorList IScriptErrorList;
#endif 	/* __IScriptErrorList_FWD_DEFINED__ */


#ifndef __CScriptErrorList_FWD_DEFINED__
#define __CScriptErrorList_FWD_DEFINED__

#ifdef __cplusplus
typedef class CScriptErrorList CScriptErrorList;
#else
typedef struct CScriptErrorList CScriptErrorList;
#endif /* __cplusplus */

#endif 	/* __CScriptErrorList_FWD_DEFINED__ */


#ifndef __ISearch_FWD_DEFINED__
#define __ISearch_FWD_DEFINED__
typedef interface ISearch ISearch;
#endif 	/* __ISearch_FWD_DEFINED__ */


#ifndef __ISearches_FWD_DEFINED__
#define __ISearches_FWD_DEFINED__
typedef interface ISearches ISearches;
#endif 	/* __ISearches_FWD_DEFINED__ */


#ifndef __ISearchAssistantOC_FWD_DEFINED__
#define __ISearchAssistantOC_FWD_DEFINED__
typedef interface ISearchAssistantOC ISearchAssistantOC;
#endif 	/* __ISearchAssistantOC_FWD_DEFINED__ */


#ifndef __ISearchAssistantOC2_FWD_DEFINED__
#define __ISearchAssistantOC2_FWD_DEFINED__
typedef interface ISearchAssistantOC2 ISearchAssistantOC2;
#endif 	/* __ISearchAssistantOC2_FWD_DEFINED__ */


#ifndef ___SearchAssistantEvents_FWD_DEFINED__
#define ___SearchAssistantEvents_FWD_DEFINED__
typedef interface _SearchAssistantEvents _SearchAssistantEvents;
#endif 	/* ___SearchAssistantEvents_FWD_DEFINED__ */


#ifndef __SearchAssistantOC_FWD_DEFINED__
#define __SearchAssistantOC_FWD_DEFINED__

#ifdef __cplusplus
typedef class SearchAssistantOC SearchAssistantOC;
#else
typedef struct SearchAssistantOC SearchAssistantOC;
#endif /* __cplusplus */

#endif 	/* __SearchAssistantOC_FWD_DEFINED__ */


/* header files for imported files */
#include "ocidl.h"
#include "docobj.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_exdisp_0000 */
/* [local] */ 

#pragma once


extern RPC_IF_HANDLE __MIDL_itf_exdisp_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_exdisp_0000_v0_0_s_ifspec;


#ifndef __SHDocVw_LIBRARY_DEFINED__
#define __SHDocVw_LIBRARY_DEFINED__

/* library SHDocVw */
/* [version][lcid][helpstring][uuid] */ 

typedef /* [helpstring][uuid] */  DECLSPEC_UUID("34A226E0-DF30-11CF-89A9-00A0C9054129") 
enum CommandStateChangeConstants
    {	CSC_UPDATECOMMANDS	= 0xffffffff,
	CSC_NAVIGATEFORWARD	= 0x1,
	CSC_NAVIGATEBACK	= 0x2
    }	CommandStateChangeConstants;

typedef /* [helpstring][uuid] */  DECLSPEC_UUID("F41E6981-28E5-11d0-82B4-00A0C90C29C5") 
enum ShellWindowTypeConstants
    {	SWC_EXPLORER	= 0,
	SWC_BROWSER	= 0x1,
	SWC_3RDPARTY	= 0x2,
	SWC_CALLBACK	= 0x4
    }	ShellWindowTypeConstants;

typedef /* [hidden][helpstring][uuid] */  DECLSPEC_UUID("7716a370-38ca-11d0-a48b-00a0c90a8f39") 
enum ShellWindowFindWindowOptions
    {	SWFO_NEEDDISPATCH	= 0x1,
	SWFO_INCLUDEPENDING	= 0x2,
	SWFO_COOKIEPASSED	= 0x4
    }	ShellWindowFindWindowOptions;


EXTERN_C const IID LIBID_SHDocVw;

#ifndef __IWebBrowser_INTERFACE_DEFINED__
#define __IWebBrowser_INTERFACE_DEFINED__

/* interface IWebBrowser */
/* [object][oleautomation][dual][hidden][helpcontext][helpstring][uuid] */ 

typedef /* [helpstring][uuid] */  DECLSPEC_UUID("14EE5380-A378-11cf-A731-00A0C9082637") 
enum BrowserNavConstants
    {	navOpenInNewWindow	= 0x1,
	navNoHistory	= 0x2,
	navNoReadFromCache	= 0x4,
	navNoWriteToCache	= 0x8,
	navAllowAutosearch	= 0x10,
	navBrowserBar	= 0x20
    }	BrowserNavConstants;

typedef /* [helpstring][uuid] */  DECLSPEC_UUID("C317C261-A991-11cf-A731-00A0C9082637") 
enum RefreshConstants
    {	REFRESH_NORMAL	= 0,
	REFRESH_IFEXPIRED	= 1,
	REFRESH_COMPLETELY	= 3
    }	RefreshConstants;


EXTERN_C const IID IID_IWebBrowser;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("EAB22AC1-30C1-11CF-A7EB-0000C05BAE0B")
    IWebBrowser : public IDispatch
    {
    public:
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE GoBack( void) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE GoForward( void) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE GoHome( void) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE GoSearch( void) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Navigate( 
            /* [in] */ BSTR URL,
            /* [optional][in] */ VARIANT __RPC_FAR *Flags,
            /* [optional][in] */ VARIANT __RPC_FAR *TargetFrameName,
            /* [optional][in] */ VARIANT __RPC_FAR *PostData,
            /* [optional][in] */ VARIANT __RPC_FAR *Headers) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Refresh( void) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Refresh2( 
            /* [optional][in] */ VARIANT __RPC_FAR *Level) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Stop( void) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Application( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDisp) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Parent( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDisp) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Container( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDisp) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Document( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDisp) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_TopLevelContainer( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pBool) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Type( 
            /* [retval][out] */ BSTR __RPC_FAR *Type) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Left( 
            /* [retval][out] */ long __RPC_FAR *pl) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Left( 
            /* [in] */ long Left) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Top( 
            /* [retval][out] */ long __RPC_FAR *pl) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Top( 
            /* [in] */ long Top) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Width( 
            /* [retval][out] */ long __RPC_FAR *pl) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Width( 
            /* [in] */ long Width) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Height( 
            /* [retval][out] */ long __RPC_FAR *pl) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Height( 
            /* [in] */ long Height) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_LocationName( 
            /* [retval][out] */ BSTR __RPC_FAR *LocationName) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_LocationURL( 
            /* [retval][out] */ BSTR __RPC_FAR *LocationURL) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Busy( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pBool) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWebBrowserVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWebBrowser __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWebBrowser __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWebBrowser __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IWebBrowser __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IWebBrowser __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IWebBrowser __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IWebBrowser __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GoBack )( 
            IWebBrowser __RPC_FAR * This);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GoForward )( 
            IWebBrowser __RPC_FAR * This);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GoHome )( 
            IWebBrowser __RPC_FAR * This);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GoSearch )( 
            IWebBrowser __RPC_FAR * This);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Navigate )( 
            IWebBrowser __RPC_FAR * This,
            /* [in] */ BSTR URL,
            /* [optional][in] */ VARIANT __RPC_FAR *Flags,
            /* [optional][in] */ VARIANT __RPC_FAR *TargetFrameName,
            /* [optional][in] */ VARIANT __RPC_FAR *PostData,
            /* [optional][in] */ VARIANT __RPC_FAR *Headers);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Refresh )( 
            IWebBrowser __RPC_FAR * This);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Refresh2 )( 
            IWebBrowser __RPC_FAR * This,
            /* [optional][in] */ VARIANT __RPC_FAR *Level);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Stop )( 
            IWebBrowser __RPC_FAR * This);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Application )( 
            IWebBrowser __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDisp);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Parent )( 
            IWebBrowser __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDisp);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Container )( 
            IWebBrowser __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDisp);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Document )( 
            IWebBrowser __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDisp);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_TopLevelContainer )( 
            IWebBrowser __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pBool);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Type )( 
            IWebBrowser __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *Type);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Left )( 
            IWebBrowser __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pl);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Left )( 
            IWebBrowser __RPC_FAR * This,
            /* [in] */ long Left);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Top )( 
            IWebBrowser __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pl);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Top )( 
            IWebBrowser __RPC_FAR * This,
            /* [in] */ long Top);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Width )( 
            IWebBrowser __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pl);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Width )( 
            IWebBrowser __RPC_FAR * This,
            /* [in] */ long Width);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Height )( 
            IWebBrowser __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pl);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Height )( 
            IWebBrowser __RPC_FAR * This,
            /* [in] */ long Height);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_LocationName )( 
            IWebBrowser __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *LocationName);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_LocationURL )( 
            IWebBrowser __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *LocationURL);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Busy )( 
            IWebBrowser __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pBool);
        
        END_INTERFACE
    } IWebBrowserVtbl;

    interface IWebBrowser
    {
        CONST_VTBL struct IWebBrowserVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWebBrowser_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWebBrowser_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWebBrowser_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWebBrowser_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWebBrowser_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWebBrowser_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWebBrowser_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWebBrowser_GoBack(This)	\
    (This)->lpVtbl -> GoBack(This)

#define IWebBrowser_GoForward(This)	\
    (This)->lpVtbl -> GoForward(This)

#define IWebBrowser_GoHome(This)	\
    (This)->lpVtbl -> GoHome(This)

#define IWebBrowser_GoSearch(This)	\
    (This)->lpVtbl -> GoSearch(This)

#define IWebBrowser_Navigate(This,URL,Flags,TargetFrameName,PostData,Headers)	\
    (This)->lpVtbl -> Navigate(This,URL,Flags,TargetFrameName,PostData,Headers)

#define IWebBrowser_Refresh(This)	\
    (This)->lpVtbl -> Refresh(This)

#define IWebBrowser_Refresh2(This,Level)	\
    (This)->lpVtbl -> Refresh2(This,Level)

#define IWebBrowser_Stop(This)	\
    (This)->lpVtbl -> Stop(This)

#define IWebBrowser_get_Application(This,ppDisp)	\
    (This)->lpVtbl -> get_Application(This,ppDisp)

#define IWebBrowser_get_Parent(This,ppDisp)	\
    (This)->lpVtbl -> get_Parent(This,ppDisp)

#define IWebBrowser_get_Container(This,ppDisp)	\
    (This)->lpVtbl -> get_Container(This,ppDisp)

#define IWebBrowser_get_Document(This,ppDisp)	\
    (This)->lpVtbl -> get_Document(This,ppDisp)

#define IWebBrowser_get_TopLevelContainer(This,pBool)	\
    (This)->lpVtbl -> get_TopLevelContainer(This,pBool)

#define IWebBrowser_get_Type(This,Type)	\
    (This)->lpVtbl -> get_Type(This,Type)

#define IWebBrowser_get_Left(This,pl)	\
    (This)->lpVtbl -> get_Left(This,pl)

#define IWebBrowser_put_Left(This,Left)	\
    (This)->lpVtbl -> put_Left(This,Left)

#define IWebBrowser_get_Top(This,pl)	\
    (This)->lpVtbl -> get_Top(This,pl)

#define IWebBrowser_put_Top(This,Top)	\
    (This)->lpVtbl -> put_Top(This,Top)

#define IWebBrowser_get_Width(This,pl)	\
    (This)->lpVtbl -> get_Width(This,pl)

#define IWebBrowser_put_Width(This,Width)	\
    (This)->lpVtbl -> put_Width(This,Width)

#define IWebBrowser_get_Height(This,pl)	\
    (This)->lpVtbl -> get_Height(This,pl)

#define IWebBrowser_put_Height(This,Height)	\
    (This)->lpVtbl -> put_Height(This,Height)

#define IWebBrowser_get_LocationName(This,LocationName)	\
    (This)->lpVtbl -> get_LocationName(This,LocationName)

#define IWebBrowser_get_LocationURL(This,LocationURL)	\
    (This)->lpVtbl -> get_LocationURL(This,LocationURL)

#define IWebBrowser_get_Busy(This,pBool)	\
    (This)->lpVtbl -> get_Busy(This,pBool)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IWebBrowser_GoBack_Proxy( 
    IWebBrowser __RPC_FAR * This);


void __RPC_STUB IWebBrowser_GoBack_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IWebBrowser_GoForward_Proxy( 
    IWebBrowser __RPC_FAR * This);


void __RPC_STUB IWebBrowser_GoForward_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IWebBrowser_GoHome_Proxy( 
    IWebBrowser __RPC_FAR * This);


void __RPC_STUB IWebBrowser_GoHome_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IWebBrowser_GoSearch_Proxy( 
    IWebBrowser __RPC_FAR * This);


void __RPC_STUB IWebBrowser_GoSearch_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IWebBrowser_Navigate_Proxy( 
    IWebBrowser __RPC_FAR * This,
    /* [in] */ BSTR URL,
    /* [optional][in] */ VARIANT __RPC_FAR *Flags,
    /* [optional][in] */ VARIANT __RPC_FAR *TargetFrameName,
    /* [optional][in] */ VARIANT __RPC_FAR *PostData,
    /* [optional][in] */ VARIANT __RPC_FAR *Headers);


void __RPC_STUB IWebBrowser_Navigate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IWebBrowser_Refresh_Proxy( 
    IWebBrowser __RPC_FAR * This);


void __RPC_STUB IWebBrowser_Refresh_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IWebBrowser_Refresh2_Proxy( 
    IWebBrowser __RPC_FAR * This,
    /* [optional][in] */ VARIANT __RPC_FAR *Level);


void __RPC_STUB IWebBrowser_Refresh2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IWebBrowser_Stop_Proxy( 
    IWebBrowser __RPC_FAR * This);


void __RPC_STUB IWebBrowser_Stop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWebBrowser_get_Application_Proxy( 
    IWebBrowser __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDisp);


void __RPC_STUB IWebBrowser_get_Application_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWebBrowser_get_Parent_Proxy( 
    IWebBrowser __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDisp);


void __RPC_STUB IWebBrowser_get_Parent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWebBrowser_get_Container_Proxy( 
    IWebBrowser __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDisp);


void __RPC_STUB IWebBrowser_get_Container_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWebBrowser_get_Document_Proxy( 
    IWebBrowser __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDisp);


void __RPC_STUB IWebBrowser_get_Document_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWebBrowser_get_TopLevelContainer_Proxy( 
    IWebBrowser __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pBool);


void __RPC_STUB IWebBrowser_get_TopLevelContainer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWebBrowser_get_Type_Proxy( 
    IWebBrowser __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *Type);


void __RPC_STUB IWebBrowser_get_Type_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWebBrowser_get_Left_Proxy( 
    IWebBrowser __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pl);


void __RPC_STUB IWebBrowser_get_Left_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IWebBrowser_put_Left_Proxy( 
    IWebBrowser __RPC_FAR * This,
    /* [in] */ long Left);


void __RPC_STUB IWebBrowser_put_Left_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWebBrowser_get_Top_Proxy( 
    IWebBrowser __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pl);


void __RPC_STUB IWebBrowser_get_Top_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IWebBrowser_put_Top_Proxy( 
    IWebBrowser __RPC_FAR * This,
    /* [in] */ long Top);


void __RPC_STUB IWebBrowser_put_Top_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWebBrowser_get_Width_Proxy( 
    IWebBrowser __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pl);


void __RPC_STUB IWebBrowser_get_Width_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IWebBrowser_put_Width_Proxy( 
    IWebBrowser __RPC_FAR * This,
    /* [in] */ long Width);


void __RPC_STUB IWebBrowser_put_Width_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWebBrowser_get_Height_Proxy( 
    IWebBrowser __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pl);


void __RPC_STUB IWebBrowser_get_Height_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IWebBrowser_put_Height_Proxy( 
    IWebBrowser __RPC_FAR * This,
    /* [in] */ long Height);


void __RPC_STUB IWebBrowser_put_Height_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWebBrowser_get_LocationName_Proxy( 
    IWebBrowser __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *LocationName);


void __RPC_STUB IWebBrowser_get_LocationName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWebBrowser_get_LocationURL_Proxy( 
    IWebBrowser __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *LocationURL);


void __RPC_STUB IWebBrowser_get_LocationURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWebBrowser_get_Busy_Proxy( 
    IWebBrowser __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pBool);


void __RPC_STUB IWebBrowser_get_Busy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWebBrowser_INTERFACE_DEFINED__ */


#ifndef __DWebBrowserEvents_DISPINTERFACE_DEFINED__
#define __DWebBrowserEvents_DISPINTERFACE_DEFINED__

/* dispinterface DWebBrowserEvents */
/* [hidden][helpstring][uuid] */ 


EXTERN_C const IID DIID_DWebBrowserEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("EAB22AC2-30C1-11CF-A7EB-0000C05BAE0B")
    DWebBrowserEvents : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct DWebBrowserEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            DWebBrowserEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            DWebBrowserEvents __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            DWebBrowserEvents __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            DWebBrowserEvents __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            DWebBrowserEvents __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            DWebBrowserEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            DWebBrowserEvents __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        END_INTERFACE
    } DWebBrowserEventsVtbl;

    interface DWebBrowserEvents
    {
        CONST_VTBL struct DWebBrowserEventsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define DWebBrowserEvents_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define DWebBrowserEvents_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define DWebBrowserEvents_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define DWebBrowserEvents_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define DWebBrowserEvents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define DWebBrowserEvents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define DWebBrowserEvents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* __DWebBrowserEvents_DISPINTERFACE_DEFINED__ */


#ifndef __IWebBrowserApp_INTERFACE_DEFINED__
#define __IWebBrowserApp_INTERFACE_DEFINED__

/* interface IWebBrowserApp */
/* [object][dual][oleautomation][hidden][helpcontext][helpstring][uuid] */ 


EXTERN_C const IID IID_IWebBrowserApp;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0002DF05-0000-0000-C000-000000000046")
    IWebBrowserApp : public IWebBrowser
    {
    public:
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Quit( void) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE ClientToWindow( 
            /* [out][in] */ int __RPC_FAR *pcx,
            /* [out][in] */ int __RPC_FAR *pcy) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE PutProperty( 
            /* [in] */ BSTR Property,
            /* [in] */ VARIANT vtValue) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE GetProperty( 
            /* [in] */ BSTR Property,
            /* [retval][out] */ VARIANT __RPC_FAR *pvtValue) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR __RPC_FAR *Name) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_HWND( 
            /* [retval][out] */ long __RPC_FAR *pHWND) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_FullName( 
            /* [retval][out] */ BSTR __RPC_FAR *FullName) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Path( 
            /* [retval][out] */ BSTR __RPC_FAR *Path) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Visible( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pBool) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Visible( 
            /* [in] */ VARIANT_BOOL Value) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_StatusBar( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pBool) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_StatusBar( 
            /* [in] */ VARIANT_BOOL Value) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_StatusText( 
            /* [retval][out] */ BSTR __RPC_FAR *StatusText) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_StatusText( 
            /* [in] */ BSTR StatusText) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ToolBar( 
            /* [retval][out] */ int __RPC_FAR *Value) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ToolBar( 
            /* [in] */ int Value) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_MenuBar( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *Value) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_MenuBar( 
            /* [in] */ VARIANT_BOOL Value) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_FullScreen( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbFullScreen) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_FullScreen( 
            /* [in] */ VARIANT_BOOL bFullScreen) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWebBrowserAppVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWebBrowserApp __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWebBrowserApp __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWebBrowserApp __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IWebBrowserApp __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IWebBrowserApp __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IWebBrowserApp __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IWebBrowserApp __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GoBack )( 
            IWebBrowserApp __RPC_FAR * This);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GoForward )( 
            IWebBrowserApp __RPC_FAR * This);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GoHome )( 
            IWebBrowserApp __RPC_FAR * This);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GoSearch )( 
            IWebBrowserApp __RPC_FAR * This);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Navigate )( 
            IWebBrowserApp __RPC_FAR * This,
            /* [in] */ BSTR URL,
            /* [optional][in] */ VARIANT __RPC_FAR *Flags,
            /* [optional][in] */ VARIANT __RPC_FAR *TargetFrameName,
            /* [optional][in] */ VARIANT __RPC_FAR *PostData,
            /* [optional][in] */ VARIANT __RPC_FAR *Headers);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Refresh )( 
            IWebBrowserApp __RPC_FAR * This);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Refresh2 )( 
            IWebBrowserApp __RPC_FAR * This,
            /* [optional][in] */ VARIANT __RPC_FAR *Level);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Stop )( 
            IWebBrowserApp __RPC_FAR * This);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Application )( 
            IWebBrowserApp __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDisp);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Parent )( 
            IWebBrowserApp __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDisp);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Container )( 
            IWebBrowserApp __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDisp);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Document )( 
            IWebBrowserApp __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDisp);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_TopLevelContainer )( 
            IWebBrowserApp __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pBool);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Type )( 
            IWebBrowserApp __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *Type);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Left )( 
            IWebBrowserApp __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pl);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Left )( 
            IWebBrowserApp __RPC_FAR * This,
            /* [in] */ long Left);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Top )( 
            IWebBrowserApp __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pl);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Top )( 
            IWebBrowserApp __RPC_FAR * This,
            /* [in] */ long Top);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Width )( 
            IWebBrowserApp __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pl);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Width )( 
            IWebBrowserApp __RPC_FAR * This,
            /* [in] */ long Width);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Height )( 
            IWebBrowserApp __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pl);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Height )( 
            IWebBrowserApp __RPC_FAR * This,
            /* [in] */ long Height);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_LocationName )( 
            IWebBrowserApp __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *LocationName);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_LocationURL )( 
            IWebBrowserApp __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *LocationURL);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Busy )( 
            IWebBrowserApp __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pBool);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Quit )( 
            IWebBrowserApp __RPC_FAR * This);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ClientToWindow )( 
            IWebBrowserApp __RPC_FAR * This,
            /* [out][in] */ int __RPC_FAR *pcx,
            /* [out][in] */ int __RPC_FAR *pcy);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PutProperty )( 
            IWebBrowserApp __RPC_FAR * This,
            /* [in] */ BSTR Property,
            /* [in] */ VARIANT vtValue);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProperty )( 
            IWebBrowserApp __RPC_FAR * This,
            /* [in] */ BSTR Property,
            /* [retval][out] */ VARIANT __RPC_FAR *pvtValue);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )( 
            IWebBrowserApp __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *Name);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_HWND )( 
            IWebBrowserApp __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pHWND);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_FullName )( 
            IWebBrowserApp __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *FullName);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Path )( 
            IWebBrowserApp __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *Path);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Visible )( 
            IWebBrowserApp __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pBool);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Visible )( 
            IWebBrowserApp __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL Value);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StatusBar )( 
            IWebBrowserApp __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pBool);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_StatusBar )( 
            IWebBrowserApp __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL Value);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StatusText )( 
            IWebBrowserApp __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *StatusText);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_StatusText )( 
            IWebBrowserApp __RPC_FAR * This,
            /* [in] */ BSTR StatusText);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ToolBar )( 
            IWebBrowserApp __RPC_FAR * This,
            /* [retval][out] */ int __RPC_FAR *Value);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ToolBar )( 
            IWebBrowserApp __RPC_FAR * This,
            /* [in] */ int Value);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_MenuBar )( 
            IWebBrowserApp __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *Value);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_MenuBar )( 
            IWebBrowserApp __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL Value);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_FullScreen )( 
            IWebBrowserApp __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbFullScreen);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_FullScreen )( 
            IWebBrowserApp __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL bFullScreen);
        
        END_INTERFACE
    } IWebBrowserAppVtbl;

    interface IWebBrowserApp
    {
        CONST_VTBL struct IWebBrowserAppVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWebBrowserApp_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWebBrowserApp_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWebBrowserApp_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWebBrowserApp_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWebBrowserApp_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWebBrowserApp_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWebBrowserApp_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWebBrowserApp_GoBack(This)	\
    (This)->lpVtbl -> GoBack(This)

#define IWebBrowserApp_GoForward(This)	\
    (This)->lpVtbl -> GoForward(This)

#define IWebBrowserApp_GoHome(This)	\
    (This)->lpVtbl -> GoHome(This)

#define IWebBrowserApp_GoSearch(This)	\
    (This)->lpVtbl -> GoSearch(This)

#define IWebBrowserApp_Navigate(This,URL,Flags,TargetFrameName,PostData,Headers)	\
    (This)->lpVtbl -> Navigate(This,URL,Flags,TargetFrameName,PostData,Headers)

#define IWebBrowserApp_Refresh(This)	\
    (This)->lpVtbl -> Refresh(This)

#define IWebBrowserApp_Refresh2(This,Level)	\
    (This)->lpVtbl -> Refresh2(This,Level)

#define IWebBrowserApp_Stop(This)	\
    (This)->lpVtbl -> Stop(This)

#define IWebBrowserApp_get_Application(This,ppDisp)	\
    (This)->lpVtbl -> get_Application(This,ppDisp)

#define IWebBrowserApp_get_Parent(This,ppDisp)	\
    (This)->lpVtbl -> get_Parent(This,ppDisp)

#define IWebBrowserApp_get_Container(This,ppDisp)	\
    (This)->lpVtbl -> get_Container(This,ppDisp)

#define IWebBrowserApp_get_Document(This,ppDisp)	\
    (This)->lpVtbl -> get_Document(This,ppDisp)

#define IWebBrowserApp_get_TopLevelContainer(This,pBool)	\
    (This)->lpVtbl -> get_TopLevelContainer(This,pBool)

#define IWebBrowserApp_get_Type(This,Type)	\
    (This)->lpVtbl -> get_Type(This,Type)

#define IWebBrowserApp_get_Left(This,pl)	\
    (This)->lpVtbl -> get_Left(This,pl)

#define IWebBrowserApp_put_Left(This,Left)	\
    (This)->lpVtbl -> put_Left(This,Left)

#define IWebBrowserApp_get_Top(This,pl)	\
    (This)->lpVtbl -> get_Top(This,pl)

#define IWebBrowserApp_put_Top(This,Top)	\
    (This)->lpVtbl -> put_Top(This,Top)

#define IWebBrowserApp_get_Width(This,pl)	\
    (This)->lpVtbl -> get_Width(This,pl)

#define IWebBrowserApp_put_Width(This,Width)	\
    (This)->lpVtbl -> put_Width(This,Width)

#define IWebBrowserApp_get_Height(This,pl)	\
    (This)->lpVtbl -> get_Height(This,pl)

#define IWebBrowserApp_put_Height(This,Height)	\
    (This)->lpVtbl -> put_Height(This,Height)

#define IWebBrowserApp_get_LocationName(This,LocationName)	\
    (This)->lpVtbl -> get_LocationName(This,LocationName)

#define IWebBrowserApp_get_LocationURL(This,LocationURL)	\
    (This)->lpVtbl -> get_LocationURL(This,LocationURL)

#define IWebBrowserApp_get_Busy(This,pBool)	\
    (This)->lpVtbl -> get_Busy(This,pBool)


#define IWebBrowserApp_Quit(This)	\
    (This)->lpVtbl -> Quit(This)

#define IWebBrowserApp_ClientToWindow(This,pcx,pcy)	\
    (This)->lpVtbl -> ClientToWindow(This,pcx,pcy)

#define IWebBrowserApp_PutProperty(This,Property,vtValue)	\
    (This)->lpVtbl -> PutProperty(This,Property,vtValue)

#define IWebBrowserApp_GetProperty(This,Property,pvtValue)	\
    (This)->lpVtbl -> GetProperty(This,Property,pvtValue)

#define IWebBrowserApp_get_Name(This,Name)	\
    (This)->lpVtbl -> get_Name(This,Name)

#define IWebBrowserApp_get_HWND(This,pHWND)	\
    (This)->lpVtbl -> get_HWND(This,pHWND)

#define IWebBrowserApp_get_FullName(This,FullName)	\
    (This)->lpVtbl -> get_FullName(This,FullName)

#define IWebBrowserApp_get_Path(This,Path)	\
    (This)->lpVtbl -> get_Path(This,Path)

#define IWebBrowserApp_get_Visible(This,pBool)	\
    (This)->lpVtbl -> get_Visible(This,pBool)

#define IWebBrowserApp_put_Visible(This,Value)	\
    (This)->lpVtbl -> put_Visible(This,Value)

#define IWebBrowserApp_get_StatusBar(This,pBool)	\
    (This)->lpVtbl -> get_StatusBar(This,pBool)

#define IWebBrowserApp_put_StatusBar(This,Value)	\
    (This)->lpVtbl -> put_StatusBar(This,Value)

#define IWebBrowserApp_get_StatusText(This,StatusText)	\
    (This)->lpVtbl -> get_StatusText(This,StatusText)

#define IWebBrowserApp_put_StatusText(This,StatusText)	\
    (This)->lpVtbl -> put_StatusText(This,StatusText)

#define IWebBrowserApp_get_ToolBar(This,Value)	\
    (This)->lpVtbl -> get_ToolBar(This,Value)

#define IWebBrowserApp_put_ToolBar(This,Value)	\
    (This)->lpVtbl -> put_ToolBar(This,Value)

#define IWebBrowserApp_get_MenuBar(This,Value)	\
    (This)->lpVtbl -> get_MenuBar(This,Value)

#define IWebBrowserApp_put_MenuBar(This,Value)	\
    (This)->lpVtbl -> put_MenuBar(This,Value)

#define IWebBrowserApp_get_FullScreen(This,pbFullScreen)	\
    (This)->lpVtbl -> get_FullScreen(This,pbFullScreen)

#define IWebBrowserApp_put_FullScreen(This,bFullScreen)	\
    (This)->lpVtbl -> put_FullScreen(This,bFullScreen)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IWebBrowserApp_Quit_Proxy( 
    IWebBrowserApp __RPC_FAR * This);


void __RPC_STUB IWebBrowserApp_Quit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IWebBrowserApp_ClientToWindow_Proxy( 
    IWebBrowserApp __RPC_FAR * This,
    /* [out][in] */ int __RPC_FAR *pcx,
    /* [out][in] */ int __RPC_FAR *pcy);


void __RPC_STUB IWebBrowserApp_ClientToWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IWebBrowserApp_PutProperty_Proxy( 
    IWebBrowserApp __RPC_FAR * This,
    /* [in] */ BSTR Property,
    /* [in] */ VARIANT vtValue);


void __RPC_STUB IWebBrowserApp_PutProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IWebBrowserApp_GetProperty_Proxy( 
    IWebBrowserApp __RPC_FAR * This,
    /* [in] */ BSTR Property,
    /* [retval][out] */ VARIANT __RPC_FAR *pvtValue);


void __RPC_STUB IWebBrowserApp_GetProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWebBrowserApp_get_Name_Proxy( 
    IWebBrowserApp __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *Name);


void __RPC_STUB IWebBrowserApp_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWebBrowserApp_get_HWND_Proxy( 
    IWebBrowserApp __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pHWND);


void __RPC_STUB IWebBrowserApp_get_HWND_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWebBrowserApp_get_FullName_Proxy( 
    IWebBrowserApp __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *FullName);


void __RPC_STUB IWebBrowserApp_get_FullName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWebBrowserApp_get_Path_Proxy( 
    IWebBrowserApp __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *Path);


void __RPC_STUB IWebBrowserApp_get_Path_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWebBrowserApp_get_Visible_Proxy( 
    IWebBrowserApp __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pBool);


void __RPC_STUB IWebBrowserApp_get_Visible_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IWebBrowserApp_put_Visible_Proxy( 
    IWebBrowserApp __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL Value);


void __RPC_STUB IWebBrowserApp_put_Visible_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWebBrowserApp_get_StatusBar_Proxy( 
    IWebBrowserApp __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pBool);


void __RPC_STUB IWebBrowserApp_get_StatusBar_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IWebBrowserApp_put_StatusBar_Proxy( 
    IWebBrowserApp __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL Value);


void __RPC_STUB IWebBrowserApp_put_StatusBar_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWebBrowserApp_get_StatusText_Proxy( 
    IWebBrowserApp __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *StatusText);


void __RPC_STUB IWebBrowserApp_get_StatusText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IWebBrowserApp_put_StatusText_Proxy( 
    IWebBrowserApp __RPC_FAR * This,
    /* [in] */ BSTR StatusText);


void __RPC_STUB IWebBrowserApp_put_StatusText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWebBrowserApp_get_ToolBar_Proxy( 
    IWebBrowserApp __RPC_FAR * This,
    /* [retval][out] */ int __RPC_FAR *Value);


void __RPC_STUB IWebBrowserApp_get_ToolBar_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IWebBrowserApp_put_ToolBar_Proxy( 
    IWebBrowserApp __RPC_FAR * This,
    /* [in] */ int Value);


void __RPC_STUB IWebBrowserApp_put_ToolBar_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWebBrowserApp_get_MenuBar_Proxy( 
    IWebBrowserApp __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *Value);


void __RPC_STUB IWebBrowserApp_get_MenuBar_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IWebBrowserApp_put_MenuBar_Proxy( 
    IWebBrowserApp __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL Value);


void __RPC_STUB IWebBrowserApp_put_MenuBar_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWebBrowserApp_get_FullScreen_Proxy( 
    IWebBrowserApp __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbFullScreen);


void __RPC_STUB IWebBrowserApp_get_FullScreen_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IWebBrowserApp_put_FullScreen_Proxy( 
    IWebBrowserApp __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL bFullScreen);


void __RPC_STUB IWebBrowserApp_put_FullScreen_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWebBrowserApp_INTERFACE_DEFINED__ */


#ifndef __IWebBrowser2_INTERFACE_DEFINED__
#define __IWebBrowser2_INTERFACE_DEFINED__

/* interface IWebBrowser2 */
/* [object][dual][oleautomation][hidden][helpcontext][helpstring][uuid] */ 


EXTERN_C const IID IID_IWebBrowser2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D30C1661-CDAF-11d0-8A3E-00C04FC9E26E")
    IWebBrowser2 : public IWebBrowserApp
    {
    public:
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Navigate2( 
            /* [in] */ VARIANT __RPC_FAR *URL,
            /* [optional][in] */ VARIANT __RPC_FAR *Flags,
            /* [optional][in] */ VARIANT __RPC_FAR *TargetFrameName,
            /* [optional][in] */ VARIANT __RPC_FAR *PostData,
            /* [optional][in] */ VARIANT __RPC_FAR *Headers) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE QueryStatusWB( 
            /* [in] */ OLECMDID cmdID,
            /* [retval][out] */ OLECMDF __RPC_FAR *pcmdf) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE ExecWB( 
            /* [in] */ OLECMDID cmdID,
            /* [in] */ OLECMDEXECOPT cmdexecopt,
            /* [optional][in] */ VARIANT __RPC_FAR *pvaIn,
            /* [optional][in][out] */ VARIANT __RPC_FAR *pvaOut) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE ShowBrowserBar( 
            /* [in] */ VARIANT __RPC_FAR *pvaClsid,
            /* [optional][in] */ VARIANT __RPC_FAR *pvarShow,
            /* [optional][in] */ VARIANT __RPC_FAR *pvarSize) = 0;
        
        virtual /* [bindable][propget][id] */ HRESULT STDMETHODCALLTYPE get_ReadyState( 
            /* [out][retval] */ READYSTATE __RPC_FAR *plReadyState) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Offline( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbOffline) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Offline( 
            /* [in] */ VARIANT_BOOL bOffline) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Silent( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbSilent) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Silent( 
            /* [in] */ VARIANT_BOOL bSilent) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_RegisterAsBrowser( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbRegister) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_RegisterAsBrowser( 
            /* [in] */ VARIANT_BOOL bRegister) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_RegisterAsDropTarget( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbRegister) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_RegisterAsDropTarget( 
            /* [in] */ VARIANT_BOOL bRegister) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_TheaterMode( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbRegister) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_TheaterMode( 
            /* [in] */ VARIANT_BOOL bRegister) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_AddressBar( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *Value) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_AddressBar( 
            /* [in] */ VARIANT_BOOL Value) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Resizable( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *Value) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Resizable( 
            /* [in] */ VARIANT_BOOL Value) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWebBrowser2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWebBrowser2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWebBrowser2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GoBack )( 
            IWebBrowser2 __RPC_FAR * This);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GoForward )( 
            IWebBrowser2 __RPC_FAR * This);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GoHome )( 
            IWebBrowser2 __RPC_FAR * This);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GoSearch )( 
            IWebBrowser2 __RPC_FAR * This);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Navigate )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [in] */ BSTR URL,
            /* [optional][in] */ VARIANT __RPC_FAR *Flags,
            /* [optional][in] */ VARIANT __RPC_FAR *TargetFrameName,
            /* [optional][in] */ VARIANT __RPC_FAR *PostData,
            /* [optional][in] */ VARIANT __RPC_FAR *Headers);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Refresh )( 
            IWebBrowser2 __RPC_FAR * This);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Refresh2 )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [optional][in] */ VARIANT __RPC_FAR *Level);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Stop )( 
            IWebBrowser2 __RPC_FAR * This);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Application )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDisp);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Parent )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDisp);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Container )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDisp);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Document )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDisp);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_TopLevelContainer )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pBool);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Type )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *Type);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Left )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pl);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Left )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [in] */ long Left);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Top )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pl);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Top )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [in] */ long Top);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Width )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pl);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Width )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [in] */ long Width);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Height )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pl);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Height )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [in] */ long Height);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_LocationName )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *LocationName);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_LocationURL )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *LocationURL);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Busy )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pBool);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Quit )( 
            IWebBrowser2 __RPC_FAR * This);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ClientToWindow )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [out][in] */ int __RPC_FAR *pcx,
            /* [out][in] */ int __RPC_FAR *pcy);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PutProperty )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [in] */ BSTR Property,
            /* [in] */ VARIANT vtValue);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProperty )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [in] */ BSTR Property,
            /* [retval][out] */ VARIANT __RPC_FAR *pvtValue);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *Name);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_HWND )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pHWND);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_FullName )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *FullName);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Path )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *Path);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Visible )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pBool);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Visible )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL Value);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StatusBar )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pBool);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_StatusBar )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL Value);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StatusText )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *StatusText);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_StatusText )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [in] */ BSTR StatusText);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ToolBar )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [retval][out] */ int __RPC_FAR *Value);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ToolBar )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [in] */ int Value);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_MenuBar )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *Value);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_MenuBar )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL Value);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_FullScreen )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbFullScreen);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_FullScreen )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL bFullScreen);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Navigate2 )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *URL,
            /* [optional][in] */ VARIANT __RPC_FAR *Flags,
            /* [optional][in] */ VARIANT __RPC_FAR *TargetFrameName,
            /* [optional][in] */ VARIANT __RPC_FAR *PostData,
            /* [optional][in] */ VARIANT __RPC_FAR *Headers);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryStatusWB )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [in] */ OLECMDID cmdID,
            /* [retval][out] */ OLECMDF __RPC_FAR *pcmdf);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ExecWB )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [in] */ OLECMDID cmdID,
            /* [in] */ OLECMDEXECOPT cmdexecopt,
            /* [optional][in] */ VARIANT __RPC_FAR *pvaIn,
            /* [optional][in][out] */ VARIANT __RPC_FAR *pvaOut);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ShowBrowserBar )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *pvaClsid,
            /* [optional][in] */ VARIANT __RPC_FAR *pvarShow,
            /* [optional][in] */ VARIANT __RPC_FAR *pvarSize);
        
        /* [bindable][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ReadyState )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [out][retval] */ READYSTATE __RPC_FAR *plReadyState);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Offline )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbOffline);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Offline )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL bOffline);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Silent )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbSilent);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Silent )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL bSilent);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_RegisterAsBrowser )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbRegister);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_RegisterAsBrowser )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL bRegister);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_RegisterAsDropTarget )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbRegister);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_RegisterAsDropTarget )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL bRegister);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_TheaterMode )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbRegister);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_TheaterMode )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL bRegister);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_AddressBar )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *Value);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_AddressBar )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL Value);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Resizable )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *Value);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Resizable )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL Value);
        
        END_INTERFACE
    } IWebBrowser2Vtbl;

    interface IWebBrowser2
    {
        CONST_VTBL struct IWebBrowser2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWebBrowser2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWebBrowser2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWebBrowser2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWebBrowser2_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWebBrowser2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWebBrowser2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWebBrowser2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWebBrowser2_GoBack(This)	\
    (This)->lpVtbl -> GoBack(This)

#define IWebBrowser2_GoForward(This)	\
    (This)->lpVtbl -> GoForward(This)

#define IWebBrowser2_GoHome(This)	\
    (This)->lpVtbl -> GoHome(This)

#define IWebBrowser2_GoSearch(This)	\
    (This)->lpVtbl -> GoSearch(This)

#define IWebBrowser2_Navigate(This,URL,Flags,TargetFrameName,PostData,Headers)	\
    (This)->lpVtbl -> Navigate(This,URL,Flags,TargetFrameName,PostData,Headers)

#define IWebBrowser2_Refresh(This)	\
    (This)->lpVtbl -> Refresh(This)

#define IWebBrowser2_Refresh2(This,Level)	\
    (This)->lpVtbl -> Refresh2(This,Level)

#define IWebBrowser2_Stop(This)	\
    (This)->lpVtbl -> Stop(This)

#define IWebBrowser2_get_Application(This,ppDisp)	\
    (This)->lpVtbl -> get_Application(This,ppDisp)

#define IWebBrowser2_get_Parent(This,ppDisp)	\
    (This)->lpVtbl -> get_Parent(This,ppDisp)

#define IWebBrowser2_get_Container(This,ppDisp)	\
    (This)->lpVtbl -> get_Container(This,ppDisp)

#define IWebBrowser2_get_Document(This,ppDisp)	\
    (This)->lpVtbl -> get_Document(This,ppDisp)

#define IWebBrowser2_get_TopLevelContainer(This,pBool)	\
    (This)->lpVtbl -> get_TopLevelContainer(This,pBool)

#define IWebBrowser2_get_Type(This,Type)	\
    (This)->lpVtbl -> get_Type(This,Type)

#define IWebBrowser2_get_Left(This,pl)	\
    (This)->lpVtbl -> get_Left(This,pl)

#define IWebBrowser2_put_Left(This,Left)	\
    (This)->lpVtbl -> put_Left(This,Left)

#define IWebBrowser2_get_Top(This,pl)	\
    (This)->lpVtbl -> get_Top(This,pl)

#define IWebBrowser2_put_Top(This,Top)	\
    (This)->lpVtbl -> put_Top(This,Top)

#define IWebBrowser2_get_Width(This,pl)	\
    (This)->lpVtbl -> get_Width(This,pl)

#define IWebBrowser2_put_Width(This,Width)	\
    (This)->lpVtbl -> put_Width(This,Width)

#define IWebBrowser2_get_Height(This,pl)	\
    (This)->lpVtbl -> get_Height(This,pl)

#define IWebBrowser2_put_Height(This,Height)	\
    (This)->lpVtbl -> put_Height(This,Height)

#define IWebBrowser2_get_LocationName(This,LocationName)	\
    (This)->lpVtbl -> get_LocationName(This,LocationName)

#define IWebBrowser2_get_LocationURL(This,LocationURL)	\
    (This)->lpVtbl -> get_LocationURL(This,LocationURL)

#define IWebBrowser2_get_Busy(This,pBool)	\
    (This)->lpVtbl -> get_Busy(This,pBool)


#define IWebBrowser2_Quit(This)	\
    (This)->lpVtbl -> Quit(This)

#define IWebBrowser2_ClientToWindow(This,pcx,pcy)	\
    (This)->lpVtbl -> ClientToWindow(This,pcx,pcy)

#define IWebBrowser2_PutProperty(This,Property,vtValue)	\
    (This)->lpVtbl -> PutProperty(This,Property,vtValue)

#define IWebBrowser2_GetProperty(This,Property,pvtValue)	\
    (This)->lpVtbl -> GetProperty(This,Property,pvtValue)

#define IWebBrowser2_get_Name(This,Name)	\
    (This)->lpVtbl -> get_Name(This,Name)

#define IWebBrowser2_get_HWND(This,pHWND)	\
    (This)->lpVtbl -> get_HWND(This,pHWND)

#define IWebBrowser2_get_FullName(This,FullName)	\
    (This)->lpVtbl -> get_FullName(This,FullName)

#define IWebBrowser2_get_Path(This,Path)	\
    (This)->lpVtbl -> get_Path(This,Path)

#define IWebBrowser2_get_Visible(This,pBool)	\
    (This)->lpVtbl -> get_Visible(This,pBool)

#define IWebBrowser2_put_Visible(This,Value)	\
    (This)->lpVtbl -> put_Visible(This,Value)

#define IWebBrowser2_get_StatusBar(This,pBool)	\
    (This)->lpVtbl -> get_StatusBar(This,pBool)

#define IWebBrowser2_put_StatusBar(This,Value)	\
    (This)->lpVtbl -> put_StatusBar(This,Value)

#define IWebBrowser2_get_StatusText(This,StatusText)	\
    (This)->lpVtbl -> get_StatusText(This,StatusText)

#define IWebBrowser2_put_StatusText(This,StatusText)	\
    (This)->lpVtbl -> put_StatusText(This,StatusText)

#define IWebBrowser2_get_ToolBar(This,Value)	\
    (This)->lpVtbl -> get_ToolBar(This,Value)

#define IWebBrowser2_put_ToolBar(This,Value)	\
    (This)->lpVtbl -> put_ToolBar(This,Value)

#define IWebBrowser2_get_MenuBar(This,Value)	\
    (This)->lpVtbl -> get_MenuBar(This,Value)

#define IWebBrowser2_put_MenuBar(This,Value)	\
    (This)->lpVtbl -> put_MenuBar(This,Value)

#define IWebBrowser2_get_FullScreen(This,pbFullScreen)	\
    (This)->lpVtbl -> get_FullScreen(This,pbFullScreen)

#define IWebBrowser2_put_FullScreen(This,bFullScreen)	\
    (This)->lpVtbl -> put_FullScreen(This,bFullScreen)


#define IWebBrowser2_Navigate2(This,URL,Flags,TargetFrameName,PostData,Headers)	\
    (This)->lpVtbl -> Navigate2(This,URL,Flags,TargetFrameName,PostData,Headers)

#define IWebBrowser2_QueryStatusWB(This,cmdID,pcmdf)	\
    (This)->lpVtbl -> QueryStatusWB(This,cmdID,pcmdf)

#define IWebBrowser2_ExecWB(This,cmdID,cmdexecopt,pvaIn,pvaOut)	\
    (This)->lpVtbl -> ExecWB(This,cmdID,cmdexecopt,pvaIn,pvaOut)

#define IWebBrowser2_ShowBrowserBar(This,pvaClsid,pvarShow,pvarSize)	\
    (This)->lpVtbl -> ShowBrowserBar(This,pvaClsid,pvarShow,pvarSize)

#define IWebBrowser2_get_ReadyState(This,plReadyState)	\
    (This)->lpVtbl -> get_ReadyState(This,plReadyState)

#define IWebBrowser2_get_Offline(This,pbOffline)	\
    (This)->lpVtbl -> get_Offline(This,pbOffline)

#define IWebBrowser2_put_Offline(This,bOffline)	\
    (This)->lpVtbl -> put_Offline(This,bOffline)

#define IWebBrowser2_get_Silent(This,pbSilent)	\
    (This)->lpVtbl -> get_Silent(This,pbSilent)

#define IWebBrowser2_put_Silent(This,bSilent)	\
    (This)->lpVtbl -> put_Silent(This,bSilent)

#define IWebBrowser2_get_RegisterAsBrowser(This,pbRegister)	\
    (This)->lpVtbl -> get_RegisterAsBrowser(This,pbRegister)

#define IWebBrowser2_put_RegisterAsBrowser(This,bRegister)	\
    (This)->lpVtbl -> put_RegisterAsBrowser(This,bRegister)

#define IWebBrowser2_get_RegisterAsDropTarget(This,pbRegister)	\
    (This)->lpVtbl -> get_RegisterAsDropTarget(This,pbRegister)

#define IWebBrowser2_put_RegisterAsDropTarget(This,bRegister)	\
    (This)->lpVtbl -> put_RegisterAsDropTarget(This,bRegister)

#define IWebBrowser2_get_TheaterMode(This,pbRegister)	\
    (This)->lpVtbl -> get_TheaterMode(This,pbRegister)

#define IWebBrowser2_put_TheaterMode(This,bRegister)	\
    (This)->lpVtbl -> put_TheaterMode(This,bRegister)

#define IWebBrowser2_get_AddressBar(This,Value)	\
    (This)->lpVtbl -> get_AddressBar(This,Value)

#define IWebBrowser2_put_AddressBar(This,Value)	\
    (This)->lpVtbl -> put_AddressBar(This,Value)

#define IWebBrowser2_get_Resizable(This,Value)	\
    (This)->lpVtbl -> get_Resizable(This,Value)

#define IWebBrowser2_put_Resizable(This,Value)	\
    (This)->lpVtbl -> put_Resizable(This,Value)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IWebBrowser2_Navigate2_Proxy( 
    IWebBrowser2 __RPC_FAR * This,
    /* [in] */ VARIANT __RPC_FAR *URL,
    /* [optional][in] */ VARIANT __RPC_FAR *Flags,
    /* [optional][in] */ VARIANT __RPC_FAR *TargetFrameName,
    /* [optional][in] */ VARIANT __RPC_FAR *PostData,
    /* [optional][in] */ VARIANT __RPC_FAR *Headers);


void __RPC_STUB IWebBrowser2_Navigate2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IWebBrowser2_QueryStatusWB_Proxy( 
    IWebBrowser2 __RPC_FAR * This,
    /* [in] */ OLECMDID cmdID,
    /* [retval][out] */ OLECMDF __RPC_FAR *pcmdf);


void __RPC_STUB IWebBrowser2_QueryStatusWB_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IWebBrowser2_ExecWB_Proxy( 
    IWebBrowser2 __RPC_FAR * This,
    /* [in] */ OLECMDID cmdID,
    /* [in] */ OLECMDEXECOPT cmdexecopt,
    /* [optional][in] */ VARIANT __RPC_FAR *pvaIn,
    /* [optional][in][out] */ VARIANT __RPC_FAR *pvaOut);


void __RPC_STUB IWebBrowser2_ExecWB_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IWebBrowser2_ShowBrowserBar_Proxy( 
    IWebBrowser2 __RPC_FAR * This,
    /* [in] */ VARIANT __RPC_FAR *pvaClsid,
    /* [optional][in] */ VARIANT __RPC_FAR *pvarShow,
    /* [optional][in] */ VARIANT __RPC_FAR *pvarSize);


void __RPC_STUB IWebBrowser2_ShowBrowserBar_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][propget][id] */ HRESULT STDMETHODCALLTYPE IWebBrowser2_get_ReadyState_Proxy( 
    IWebBrowser2 __RPC_FAR * This,
    /* [out][retval] */ READYSTATE __RPC_FAR *plReadyState);


void __RPC_STUB IWebBrowser2_get_ReadyState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWebBrowser2_get_Offline_Proxy( 
    IWebBrowser2 __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbOffline);


void __RPC_STUB IWebBrowser2_get_Offline_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IWebBrowser2_put_Offline_Proxy( 
    IWebBrowser2 __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL bOffline);


void __RPC_STUB IWebBrowser2_put_Offline_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWebBrowser2_get_Silent_Proxy( 
    IWebBrowser2 __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbSilent);


void __RPC_STUB IWebBrowser2_get_Silent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IWebBrowser2_put_Silent_Proxy( 
    IWebBrowser2 __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL bSilent);


void __RPC_STUB IWebBrowser2_put_Silent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWebBrowser2_get_RegisterAsBrowser_Proxy( 
    IWebBrowser2 __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbRegister);


void __RPC_STUB IWebBrowser2_get_RegisterAsBrowser_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IWebBrowser2_put_RegisterAsBrowser_Proxy( 
    IWebBrowser2 __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL bRegister);


void __RPC_STUB IWebBrowser2_put_RegisterAsBrowser_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWebBrowser2_get_RegisterAsDropTarget_Proxy( 
    IWebBrowser2 __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbRegister);


void __RPC_STUB IWebBrowser2_get_RegisterAsDropTarget_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IWebBrowser2_put_RegisterAsDropTarget_Proxy( 
    IWebBrowser2 __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL bRegister);


void __RPC_STUB IWebBrowser2_put_RegisterAsDropTarget_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWebBrowser2_get_TheaterMode_Proxy( 
    IWebBrowser2 __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbRegister);


void __RPC_STUB IWebBrowser2_get_TheaterMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IWebBrowser2_put_TheaterMode_Proxy( 
    IWebBrowser2 __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL bRegister);


void __RPC_STUB IWebBrowser2_put_TheaterMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWebBrowser2_get_AddressBar_Proxy( 
    IWebBrowser2 __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *Value);


void __RPC_STUB IWebBrowser2_get_AddressBar_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IWebBrowser2_put_AddressBar_Proxy( 
    IWebBrowser2 __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL Value);


void __RPC_STUB IWebBrowser2_put_AddressBar_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWebBrowser2_get_Resizable_Proxy( 
    IWebBrowser2 __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *Value);


void __RPC_STUB IWebBrowser2_get_Resizable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IWebBrowser2_put_Resizable_Proxy( 
    IWebBrowser2 __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL Value);


void __RPC_STUB IWebBrowser2_put_Resizable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWebBrowser2_INTERFACE_DEFINED__ */


#ifndef __DWebBrowserEvents2_DISPINTERFACE_DEFINED__
#define __DWebBrowserEvents2_DISPINTERFACE_DEFINED__

/* dispinterface DWebBrowserEvents2 */
/* [hidden][helpstring][uuid] */ 


EXTERN_C const IID DIID_DWebBrowserEvents2;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("34A715A0-6587-11D0-924A-0020AFC7AC4D")
    DWebBrowserEvents2 : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct DWebBrowserEvents2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            DWebBrowserEvents2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            DWebBrowserEvents2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            DWebBrowserEvents2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            DWebBrowserEvents2 __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            DWebBrowserEvents2 __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            DWebBrowserEvents2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            DWebBrowserEvents2 __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        END_INTERFACE
    } DWebBrowserEvents2Vtbl;

    interface DWebBrowserEvents2
    {
        CONST_VTBL struct DWebBrowserEvents2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define DWebBrowserEvents2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define DWebBrowserEvents2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define DWebBrowserEvents2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define DWebBrowserEvents2_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define DWebBrowserEvents2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define DWebBrowserEvents2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define DWebBrowserEvents2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* __DWebBrowserEvents2_DISPINTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_WebBrowser_V1;

#ifdef __cplusplus

class DECLSPEC_UUID("EAB22AC3-30C1-11CF-A7EB-0000C05BAE0B")
WebBrowser_V1;
#endif

EXTERN_C const CLSID CLSID_WebBrowser;

#ifdef __cplusplus

class DECLSPEC_UUID("8856F961-340A-11D0-A96B-00C04FD705A2")
WebBrowser;
#endif

EXTERN_C const CLSID CLSID_InternetExplorer;

#ifdef __cplusplus

class DECLSPEC_UUID("0002DF01-0000-0000-C000-000000000046")
InternetExplorer;
#endif

EXTERN_C const CLSID CLSID_ShellBrowserWindow;

#ifdef __cplusplus

class DECLSPEC_UUID("c08afd90-f2a1-11d1-8455-00a0c91f3880")
ShellBrowserWindow;
#endif

#ifndef __DShellWindowsEvents_DISPINTERFACE_DEFINED__
#define __DShellWindowsEvents_DISPINTERFACE_DEFINED__

/* dispinterface DShellWindowsEvents */
/* [helpstring][uuid] */ 


EXTERN_C const IID DIID_DShellWindowsEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("fe4106e0-399a-11d0-a48c-00a0c90a8f39")
    DShellWindowsEvents : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct DShellWindowsEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            DShellWindowsEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            DShellWindowsEvents __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            DShellWindowsEvents __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            DShellWindowsEvents __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            DShellWindowsEvents __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            DShellWindowsEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            DShellWindowsEvents __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        END_INTERFACE
    } DShellWindowsEventsVtbl;

    interface DShellWindowsEvents
    {
        CONST_VTBL struct DShellWindowsEventsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define DShellWindowsEvents_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define DShellWindowsEvents_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define DShellWindowsEvents_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define DShellWindowsEvents_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define DShellWindowsEvents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define DShellWindowsEvents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define DShellWindowsEvents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* __DShellWindowsEvents_DISPINTERFACE_DEFINED__ */


#ifndef __IShellWindows_INTERFACE_DEFINED__
#define __IShellWindows_INTERFACE_DEFINED__

/* interface IShellWindows */
/* [object][dual][oleautomation][helpstring][uuid] */ 


EXTERN_C const IID IID_IShellWindows;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("85CB6900-4D95-11CF-960C-0080C7F4EE85")
    IShellWindows : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long __RPC_FAR *Count) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Item( 
            /* [optional][in] */ VARIANT index,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *Folder) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE _NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunk) = 0;
        
        virtual /* [hidden][helpstring] */ HRESULT STDMETHODCALLTYPE Register( 
            /* [in] */ IDispatch __RPC_FAR *pid,
            /* [in] */ long hwnd,
            /* [in] */ int swClass,
            /* [out] */ long __RPC_FAR *plCookie) = 0;
        
        virtual /* [hidden][helpstring] */ HRESULT STDMETHODCALLTYPE RegisterPending( 
            /* [in] */ long lThreadId,
            /* [in] */ VARIANT __RPC_FAR *pvarloc,
            /* [in] */ VARIANT __RPC_FAR *pvarlocRoot,
            /* [in] */ int swClass,
            /* [out] */ long __RPC_FAR *plCookie) = 0;
        
        virtual /* [hidden][helpstring] */ HRESULT STDMETHODCALLTYPE Revoke( 
            /* [in] */ long lCookie) = 0;
        
        virtual /* [hidden][helpstring] */ HRESULT STDMETHODCALLTYPE OnNavigate( 
            /* [in] */ long lCookie,
            /* [in] */ VARIANT __RPC_FAR *pvarLoc) = 0;
        
        virtual /* [hidden][helpstring] */ HRESULT STDMETHODCALLTYPE OnActivated( 
            /* [in] */ long lCookie,
            /* [in] */ VARIANT_BOOL fActive) = 0;
        
        virtual /* [hidden][helpstring] */ HRESULT STDMETHODCALLTYPE FindWindow( 
            /* [in] */ VARIANT __RPC_FAR *pvarLoc,
            /* [in] */ VARIANT __RPC_FAR *pvarLocRoot,
            /* [in] */ int swClass,
            /* [out] */ long __RPC_FAR *phwnd,
            /* [in] */ int swfwOptions,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppdispOut) = 0;
        
        virtual /* [hidden][helpstring] */ HRESULT STDMETHODCALLTYPE OnCreated( 
            /* [in] */ long lCookie,
            /* [in] */ IUnknown __RPC_FAR *punk) = 0;
        
        virtual /* [hidden][helpstring] */ HRESULT STDMETHODCALLTYPE ProcessAttachDetach( 
            /* [in] */ VARIANT_BOOL fAttach) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IShellWindowsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IShellWindows __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IShellWindows __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IShellWindows __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IShellWindows __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IShellWindows __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IShellWindows __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IShellWindows __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            IShellWindows __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *Count);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Item )( 
            IShellWindows __RPC_FAR * This,
            /* [optional][in] */ VARIANT index,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *Folder);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *_NewEnum )( 
            IShellWindows __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunk);
        
        /* [hidden][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Register )( 
            IShellWindows __RPC_FAR * This,
            /* [in] */ IDispatch __RPC_FAR *pid,
            /* [in] */ long hwnd,
            /* [in] */ int swClass,
            /* [out] */ long __RPC_FAR *plCookie);
        
        /* [hidden][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RegisterPending )( 
            IShellWindows __RPC_FAR * This,
            /* [in] */ long lThreadId,
            /* [in] */ VARIANT __RPC_FAR *pvarloc,
            /* [in] */ VARIANT __RPC_FAR *pvarlocRoot,
            /* [in] */ int swClass,
            /* [out] */ long __RPC_FAR *plCookie);
        
        /* [hidden][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Revoke )( 
            IShellWindows __RPC_FAR * This,
            /* [in] */ long lCookie);
        
        /* [hidden][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnNavigate )( 
            IShellWindows __RPC_FAR * This,
            /* [in] */ long lCookie,
            /* [in] */ VARIANT __RPC_FAR *pvarLoc);
        
        /* [hidden][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnActivated )( 
            IShellWindows __RPC_FAR * This,
            /* [in] */ long lCookie,
            /* [in] */ VARIANT_BOOL fActive);
        
        /* [hidden][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindWindow )( 
            IShellWindows __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *pvarLoc,
            /* [in] */ VARIANT __RPC_FAR *pvarLocRoot,
            /* [in] */ int swClass,
            /* [out] */ long __RPC_FAR *phwnd,
            /* [in] */ int swfwOptions,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppdispOut);
        
        /* [hidden][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnCreated )( 
            IShellWindows __RPC_FAR * This,
            /* [in] */ long lCookie,
            /* [in] */ IUnknown __RPC_FAR *punk);
        
        /* [hidden][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ProcessAttachDetach )( 
            IShellWindows __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL fAttach);
        
        END_INTERFACE
    } IShellWindowsVtbl;

    interface IShellWindows
    {
        CONST_VTBL struct IShellWindowsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IShellWindows_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IShellWindows_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IShellWindows_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IShellWindows_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IShellWindows_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IShellWindows_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IShellWindows_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IShellWindows_get_Count(This,Count)	\
    (This)->lpVtbl -> get_Count(This,Count)

#define IShellWindows_Item(This,index,Folder)	\
    (This)->lpVtbl -> Item(This,index,Folder)

#define IShellWindows__NewEnum(This,ppunk)	\
    (This)->lpVtbl -> _NewEnum(This,ppunk)

#define IShellWindows_Register(This,pid,hwnd,swClass,plCookie)	\
    (This)->lpVtbl -> Register(This,pid,hwnd,swClass,plCookie)

#define IShellWindows_RegisterPending(This,lThreadId,pvarloc,pvarlocRoot,swClass,plCookie)	\
    (This)->lpVtbl -> RegisterPending(This,lThreadId,pvarloc,pvarlocRoot,swClass,plCookie)

#define IShellWindows_Revoke(This,lCookie)	\
    (This)->lpVtbl -> Revoke(This,lCookie)

#define IShellWindows_OnNavigate(This,lCookie,pvarLoc)	\
    (This)->lpVtbl -> OnNavigate(This,lCookie,pvarLoc)

#define IShellWindows_OnActivated(This,lCookie,fActive)	\
    (This)->lpVtbl -> OnActivated(This,lCookie,fActive)

#define IShellWindows_FindWindow(This,pvarLoc,pvarLocRoot,swClass,phwnd,swfwOptions,ppdispOut)	\
    (This)->lpVtbl -> FindWindow(This,pvarLoc,pvarLocRoot,swClass,phwnd,swfwOptions,ppdispOut)

#define IShellWindows_OnCreated(This,lCookie,punk)	\
    (This)->lpVtbl -> OnCreated(This,lCookie,punk)

#define IShellWindows_ProcessAttachDetach(This,fAttach)	\
    (This)->lpVtbl -> ProcessAttachDetach(This,fAttach)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IShellWindows_get_Count_Proxy( 
    IShellWindows __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *Count);


void __RPC_STUB IShellWindows_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IShellWindows_Item_Proxy( 
    IShellWindows __RPC_FAR * This,
    /* [optional][in] */ VARIANT index,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *Folder);


void __RPC_STUB IShellWindows_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IShellWindows__NewEnum_Proxy( 
    IShellWindows __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunk);


void __RPC_STUB IShellWindows__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][helpstring] */ HRESULT STDMETHODCALLTYPE IShellWindows_Register_Proxy( 
    IShellWindows __RPC_FAR * This,
    /* [in] */ IDispatch __RPC_FAR *pid,
    /* [in] */ long hwnd,
    /* [in] */ int swClass,
    /* [out] */ long __RPC_FAR *plCookie);


void __RPC_STUB IShellWindows_Register_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][helpstring] */ HRESULT STDMETHODCALLTYPE IShellWindows_RegisterPending_Proxy( 
    IShellWindows __RPC_FAR * This,
    /* [in] */ long lThreadId,
    /* [in] */ VARIANT __RPC_FAR *pvarloc,
    /* [in] */ VARIANT __RPC_FAR *pvarlocRoot,
    /* [in] */ int swClass,
    /* [out] */ long __RPC_FAR *plCookie);


void __RPC_STUB IShellWindows_RegisterPending_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][helpstring] */ HRESULT STDMETHODCALLTYPE IShellWindows_Revoke_Proxy( 
    IShellWindows __RPC_FAR * This,
    /* [in] */ long lCookie);


void __RPC_STUB IShellWindows_Revoke_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][helpstring] */ HRESULT STDMETHODCALLTYPE IShellWindows_OnNavigate_Proxy( 
    IShellWindows __RPC_FAR * This,
    /* [in] */ long lCookie,
    /* [in] */ VARIANT __RPC_FAR *pvarLoc);


void __RPC_STUB IShellWindows_OnNavigate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][helpstring] */ HRESULT STDMETHODCALLTYPE IShellWindows_OnActivated_Proxy( 
    IShellWindows __RPC_FAR * This,
    /* [in] */ long lCookie,
    /* [in] */ VARIANT_BOOL fActive);


void __RPC_STUB IShellWindows_OnActivated_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][helpstring] */ HRESULT STDMETHODCALLTYPE IShellWindows_FindWindow_Proxy( 
    IShellWindows __RPC_FAR * This,
    /* [in] */ VARIANT __RPC_FAR *pvarLoc,
    /* [in] */ VARIANT __RPC_FAR *pvarLocRoot,
    /* [in] */ int swClass,
    /* [out] */ long __RPC_FAR *phwnd,
    /* [in] */ int swfwOptions,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppdispOut);


void __RPC_STUB IShellWindows_FindWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][helpstring] */ HRESULT STDMETHODCALLTYPE IShellWindows_OnCreated_Proxy( 
    IShellWindows __RPC_FAR * This,
    /* [in] */ long lCookie,
    /* [in] */ IUnknown __RPC_FAR *punk);


void __RPC_STUB IShellWindows_OnCreated_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][helpstring] */ HRESULT STDMETHODCALLTYPE IShellWindows_ProcessAttachDetach_Proxy( 
    IShellWindows __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL fAttach);


void __RPC_STUB IShellWindows_ProcessAttachDetach_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IShellWindows_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_ShellWindows;

#ifdef __cplusplus

class DECLSPEC_UUID("9BA05972-F6A8-11CF-A442-00A0C90A8F39")
ShellWindows;
#endif

#ifndef __IShellUIHelper_INTERFACE_DEFINED__
#define __IShellUIHelper_INTERFACE_DEFINED__

/* interface IShellUIHelper */
/* [object][dual][oleautomation][helpstring][uuid] */ 


EXTERN_C const IID IID_IShellUIHelper;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("729FE2F8-1EA8-11d1-8F85-00C04FC2FBE1")
    IShellUIHelper : public IDispatch
    {
    public:
        virtual /* [id][hidden] */ HRESULT STDMETHODCALLTYPE ResetFirstBootMode( void) = 0;
        
        virtual /* [id][hidden] */ HRESULT STDMETHODCALLTYPE ResetSafeMode( void) = 0;
        
        virtual /* [id][hidden] */ HRESULT STDMETHODCALLTYPE RefreshOfflineDesktop( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE AddFavorite( 
            /* [in] */ BSTR URL,
            /* [in][optional] */ VARIANT __RPC_FAR *Title) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE AddChannel( 
            /* [in] */ BSTR URL) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE AddDesktopComponent( 
            /* [in] */ BSTR URL,
            /* [in] */ BSTR Type,
            /* [in][optional] */ VARIANT __RPC_FAR *Left,
            /* [in][optional] */ VARIANT __RPC_FAR *Top,
            /* [in][optional] */ VARIANT __RPC_FAR *Width,
            /* [in][optional] */ VARIANT __RPC_FAR *Height) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE IsSubscribed( 
            /* [in] */ BSTR URL,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pBool) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE NavigateAndFind( 
            /* [in] */ BSTR URL,
            /* [in] */ BSTR strQuery,
            /* [in] */ VARIANT __RPC_FAR *varTargetFrame) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE ImportExportFavorites( 
            /* [in] */ VARIANT_BOOL fImport,
            /* [in] */ BSTR strImpExpPath) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE AutoCompleteSaveForm( 
            /* [in][optional] */ VARIANT __RPC_FAR *Form) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE AutoScan( 
            /* [in] */ BSTR strSearch,
            /* [in] */ BSTR strFailureUrl,
            /* [in][optional] */ VARIANT __RPC_FAR *pvarTargetFrame) = 0;
        
        virtual /* [id][hidden] */ HRESULT STDMETHODCALLTYPE AutoCompleteAttach( 
            /* [in][optional] */ VARIANT __RPC_FAR *Reserved) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE ShowBrowserUI( 
            /* [in] */ BSTR bstrName,
            /* [in] */ VARIANT __RPC_FAR *pvarIn,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarOut) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IShellUIHelperVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IShellUIHelper __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IShellUIHelper __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IShellUIHelper __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IShellUIHelper __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IShellUIHelper __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IShellUIHelper __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IShellUIHelper __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][hidden] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ResetFirstBootMode )( 
            IShellUIHelper __RPC_FAR * This);
        
        /* [id][hidden] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ResetSafeMode )( 
            IShellUIHelper __RPC_FAR * This);
        
        /* [id][hidden] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RefreshOfflineDesktop )( 
            IShellUIHelper __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddFavorite )( 
            IShellUIHelper __RPC_FAR * This,
            /* [in] */ BSTR URL,
            /* [in][optional] */ VARIANT __RPC_FAR *Title);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddChannel )( 
            IShellUIHelper __RPC_FAR * This,
            /* [in] */ BSTR URL);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddDesktopComponent )( 
            IShellUIHelper __RPC_FAR * This,
            /* [in] */ BSTR URL,
            /* [in] */ BSTR Type,
            /* [in][optional] */ VARIANT __RPC_FAR *Left,
            /* [in][optional] */ VARIANT __RPC_FAR *Top,
            /* [in][optional] */ VARIANT __RPC_FAR *Width,
            /* [in][optional] */ VARIANT __RPC_FAR *Height);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsSubscribed )( 
            IShellUIHelper __RPC_FAR * This,
            /* [in] */ BSTR URL,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pBool);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NavigateAndFind )( 
            IShellUIHelper __RPC_FAR * This,
            /* [in] */ BSTR URL,
            /* [in] */ BSTR strQuery,
            /* [in] */ VARIANT __RPC_FAR *varTargetFrame);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ImportExportFavorites )( 
            IShellUIHelper __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL fImport,
            /* [in] */ BSTR strImpExpPath);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AutoCompleteSaveForm )( 
            IShellUIHelper __RPC_FAR * This,
            /* [in][optional] */ VARIANT __RPC_FAR *Form);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AutoScan )( 
            IShellUIHelper __RPC_FAR * This,
            /* [in] */ BSTR strSearch,
            /* [in] */ BSTR strFailureUrl,
            /* [in][optional] */ VARIANT __RPC_FAR *pvarTargetFrame);
        
        /* [id][hidden] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AutoCompleteAttach )( 
            IShellUIHelper __RPC_FAR * This,
            /* [in][optional] */ VARIANT __RPC_FAR *Reserved);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ShowBrowserUI )( 
            IShellUIHelper __RPC_FAR * This,
            /* [in] */ BSTR bstrName,
            /* [in] */ VARIANT __RPC_FAR *pvarIn,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarOut);
        
        END_INTERFACE
    } IShellUIHelperVtbl;

    interface IShellUIHelper
    {
        CONST_VTBL struct IShellUIHelperVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IShellUIHelper_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IShellUIHelper_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IShellUIHelper_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IShellUIHelper_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IShellUIHelper_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IShellUIHelper_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IShellUIHelper_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IShellUIHelper_ResetFirstBootMode(This)	\
    (This)->lpVtbl -> ResetFirstBootMode(This)

#define IShellUIHelper_ResetSafeMode(This)	\
    (This)->lpVtbl -> ResetSafeMode(This)

#define IShellUIHelper_RefreshOfflineDesktop(This)	\
    (This)->lpVtbl -> RefreshOfflineDesktop(This)

#define IShellUIHelper_AddFavorite(This,URL,Title)	\
    (This)->lpVtbl -> AddFavorite(This,URL,Title)

#define IShellUIHelper_AddChannel(This,URL)	\
    (This)->lpVtbl -> AddChannel(This,URL)

#define IShellUIHelper_AddDesktopComponent(This,URL,Type,Left,Top,Width,Height)	\
    (This)->lpVtbl -> AddDesktopComponent(This,URL,Type,Left,Top,Width,Height)

#define IShellUIHelper_IsSubscribed(This,URL,pBool)	\
    (This)->lpVtbl -> IsSubscribed(This,URL,pBool)

#define IShellUIHelper_NavigateAndFind(This,URL,strQuery,varTargetFrame)	\
    (This)->lpVtbl -> NavigateAndFind(This,URL,strQuery,varTargetFrame)

#define IShellUIHelper_ImportExportFavorites(This,fImport,strImpExpPath)	\
    (This)->lpVtbl -> ImportExportFavorites(This,fImport,strImpExpPath)

#define IShellUIHelper_AutoCompleteSaveForm(This,Form)	\
    (This)->lpVtbl -> AutoCompleteSaveForm(This,Form)

#define IShellUIHelper_AutoScan(This,strSearch,strFailureUrl,pvarTargetFrame)	\
    (This)->lpVtbl -> AutoScan(This,strSearch,strFailureUrl,pvarTargetFrame)

#define IShellUIHelper_AutoCompleteAttach(This,Reserved)	\
    (This)->lpVtbl -> AutoCompleteAttach(This,Reserved)

#define IShellUIHelper_ShowBrowserUI(This,bstrName,pvarIn,pvarOut)	\
    (This)->lpVtbl -> ShowBrowserUI(This,bstrName,pvarIn,pvarOut)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][hidden] */ HRESULT STDMETHODCALLTYPE IShellUIHelper_ResetFirstBootMode_Proxy( 
    IShellUIHelper __RPC_FAR * This);


void __RPC_STUB IShellUIHelper_ResetFirstBootMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][hidden] */ HRESULT STDMETHODCALLTYPE IShellUIHelper_ResetSafeMode_Proxy( 
    IShellUIHelper __RPC_FAR * This);


void __RPC_STUB IShellUIHelper_ResetSafeMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][hidden] */ HRESULT STDMETHODCALLTYPE IShellUIHelper_RefreshOfflineDesktop_Proxy( 
    IShellUIHelper __RPC_FAR * This);


void __RPC_STUB IShellUIHelper_RefreshOfflineDesktop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IShellUIHelper_AddFavorite_Proxy( 
    IShellUIHelper __RPC_FAR * This,
    /* [in] */ BSTR URL,
    /* [in][optional] */ VARIANT __RPC_FAR *Title);


void __RPC_STUB IShellUIHelper_AddFavorite_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IShellUIHelper_AddChannel_Proxy( 
    IShellUIHelper __RPC_FAR * This,
    /* [in] */ BSTR URL);


void __RPC_STUB IShellUIHelper_AddChannel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IShellUIHelper_AddDesktopComponent_Proxy( 
    IShellUIHelper __RPC_FAR * This,
    /* [in] */ BSTR URL,
    /* [in] */ BSTR Type,
    /* [in][optional] */ VARIANT __RPC_FAR *Left,
    /* [in][optional] */ VARIANT __RPC_FAR *Top,
    /* [in][optional] */ VARIANT __RPC_FAR *Width,
    /* [in][optional] */ VARIANT __RPC_FAR *Height);


void __RPC_STUB IShellUIHelper_AddDesktopComponent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IShellUIHelper_IsSubscribed_Proxy( 
    IShellUIHelper __RPC_FAR * This,
    /* [in] */ BSTR URL,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pBool);


void __RPC_STUB IShellUIHelper_IsSubscribed_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IShellUIHelper_NavigateAndFind_Proxy( 
    IShellUIHelper __RPC_FAR * This,
    /* [in] */ BSTR URL,
    /* [in] */ BSTR strQuery,
    /* [in] */ VARIANT __RPC_FAR *varTargetFrame);


void __RPC_STUB IShellUIHelper_NavigateAndFind_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IShellUIHelper_ImportExportFavorites_Proxy( 
    IShellUIHelper __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL fImport,
    /* [in] */ BSTR strImpExpPath);


void __RPC_STUB IShellUIHelper_ImportExportFavorites_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IShellUIHelper_AutoCompleteSaveForm_Proxy( 
    IShellUIHelper __RPC_FAR * This,
    /* [in][optional] */ VARIANT __RPC_FAR *Form);


void __RPC_STUB IShellUIHelper_AutoCompleteSaveForm_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IShellUIHelper_AutoScan_Proxy( 
    IShellUIHelper __RPC_FAR * This,
    /* [in] */ BSTR strSearch,
    /* [in] */ BSTR strFailureUrl,
    /* [in][optional] */ VARIANT __RPC_FAR *pvarTargetFrame);


void __RPC_STUB IShellUIHelper_AutoScan_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][hidden] */ HRESULT STDMETHODCALLTYPE IShellUIHelper_AutoCompleteAttach_Proxy( 
    IShellUIHelper __RPC_FAR * This,
    /* [in][optional] */ VARIANT __RPC_FAR *Reserved);


void __RPC_STUB IShellUIHelper_AutoCompleteAttach_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IShellUIHelper_ShowBrowserUI_Proxy( 
    IShellUIHelper __RPC_FAR * This,
    /* [in] */ BSTR bstrName,
    /* [in] */ VARIANT __RPC_FAR *pvarIn,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarOut);


void __RPC_STUB IShellUIHelper_ShowBrowserUI_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IShellUIHelper_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_ShellUIHelper;

#ifdef __cplusplus

class DECLSPEC_UUID("64AB4BB7-111E-11d1-8F79-00C04FC2FBE1")
ShellUIHelper;
#endif

#ifndef ___ShellFavoritesNameSpaceEvents_DISPINTERFACE_DEFINED__
#define ___ShellFavoritesNameSpaceEvents_DISPINTERFACE_DEFINED__

/* dispinterface _ShellFavoritesNameSpaceEvents */
/* [uuid] */ 


EXTERN_C const IID DIID__ShellFavoritesNameSpaceEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("55136806-B2DE-11D1-B9F2-00A0C98BC547")
    _ShellFavoritesNameSpaceEvents : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct _ShellFavoritesNameSpaceEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            _ShellFavoritesNameSpaceEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            _ShellFavoritesNameSpaceEvents __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            _ShellFavoritesNameSpaceEvents __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            _ShellFavoritesNameSpaceEvents __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            _ShellFavoritesNameSpaceEvents __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            _ShellFavoritesNameSpaceEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            _ShellFavoritesNameSpaceEvents __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        END_INTERFACE
    } _ShellFavoritesNameSpaceEventsVtbl;

    interface _ShellFavoritesNameSpaceEvents
    {
        CONST_VTBL struct _ShellFavoritesNameSpaceEventsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define _ShellFavoritesNameSpaceEvents_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define _ShellFavoritesNameSpaceEvents_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define _ShellFavoritesNameSpaceEvents_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define _ShellFavoritesNameSpaceEvents_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define _ShellFavoritesNameSpaceEvents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define _ShellFavoritesNameSpaceEvents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define _ShellFavoritesNameSpaceEvents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* ___ShellFavoritesNameSpaceEvents_DISPINTERFACE_DEFINED__ */


#ifndef __IShellFavoritesNameSpace_INTERFACE_DEFINED__
#define __IShellFavoritesNameSpace_INTERFACE_DEFINED__

/* interface IShellFavoritesNameSpace */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IShellFavoritesNameSpace;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("55136804-B2DE-11D1-B9F2-00A0C98BC547")
    IShellFavoritesNameSpace : public IDispatch
    {
    public:
        virtual /* [helpstring][id][hidden] */ HRESULT STDMETHODCALLTYPE MoveSelectionUp( void) = 0;
        
        virtual /* [helpstring][id][hidden] */ HRESULT STDMETHODCALLTYPE MoveSelectionDown( void) = 0;
        
        virtual /* [helpstring][id][hidden] */ HRESULT STDMETHODCALLTYPE ResetSort( void) = 0;
        
        virtual /* [helpstring][id][hidden] */ HRESULT STDMETHODCALLTYPE NewFolder( void) = 0;
        
        virtual /* [helpstring][id][hidden] */ HRESULT STDMETHODCALLTYPE Synchronize( void) = 0;
        
        virtual /* [helpstring][id][hidden] */ HRESULT STDMETHODCALLTYPE Import( void) = 0;
        
        virtual /* [helpstring][id][hidden] */ HRESULT STDMETHODCALLTYPE Export( void) = 0;
        
        virtual /* [helpstring][id][hidden] */ HRESULT STDMETHODCALLTYPE InvokeContextMenuCommand( 
            /* [in] */ BSTR strCommand) = 0;
        
        virtual /* [helpstring][id][hidden] */ HRESULT STDMETHODCALLTYPE MoveSelectionTo( void) = 0;
        
        virtual /* [helpstring][id][propget][hidden] */ HRESULT STDMETHODCALLTYPE get_FOfflinePackInstalled( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pBool) = 0;
        
        virtual /* [helpstring][id][hidden] */ HRESULT STDMETHODCALLTYPE CreateSubscriptionForSelection( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pBool) = 0;
        
        virtual /* [helpstring][id][hidden] */ HRESULT STDMETHODCALLTYPE DeleteSubscriptionForSelection( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pBool) = 0;
        
        virtual /* [helpstring][id][hidden] */ HRESULT STDMETHODCALLTYPE SetRoot( 
            /* [in] */ BSTR bstrFullPath) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IShellFavoritesNameSpaceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IShellFavoritesNameSpace __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IShellFavoritesNameSpace __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IShellFavoritesNameSpace __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IShellFavoritesNameSpace __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IShellFavoritesNameSpace __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IShellFavoritesNameSpace __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IShellFavoritesNameSpace __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][hidden] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveSelectionUp )( 
            IShellFavoritesNameSpace __RPC_FAR * This);
        
        /* [helpstring][id][hidden] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveSelectionDown )( 
            IShellFavoritesNameSpace __RPC_FAR * This);
        
        /* [helpstring][id][hidden] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ResetSort )( 
            IShellFavoritesNameSpace __RPC_FAR * This);
        
        /* [helpstring][id][hidden] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NewFolder )( 
            IShellFavoritesNameSpace __RPC_FAR * This);
        
        /* [helpstring][id][hidden] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Synchronize )( 
            IShellFavoritesNameSpace __RPC_FAR * This);
        
        /* [helpstring][id][hidden] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Import )( 
            IShellFavoritesNameSpace __RPC_FAR * This);
        
        /* [helpstring][id][hidden] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Export )( 
            IShellFavoritesNameSpace __RPC_FAR * This);
        
        /* [helpstring][id][hidden] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InvokeContextMenuCommand )( 
            IShellFavoritesNameSpace __RPC_FAR * This,
            /* [in] */ BSTR strCommand);
        
        /* [helpstring][id][hidden] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveSelectionTo )( 
            IShellFavoritesNameSpace __RPC_FAR * This);
        
        /* [helpstring][id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_FOfflinePackInstalled )( 
            IShellFavoritesNameSpace __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pBool);
        
        /* [helpstring][id][hidden] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateSubscriptionForSelection )( 
            IShellFavoritesNameSpace __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pBool);
        
        /* [helpstring][id][hidden] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteSubscriptionForSelection )( 
            IShellFavoritesNameSpace __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pBool);
        
        /* [helpstring][id][hidden] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetRoot )( 
            IShellFavoritesNameSpace __RPC_FAR * This,
            /* [in] */ BSTR bstrFullPath);
        
        END_INTERFACE
    } IShellFavoritesNameSpaceVtbl;

    interface IShellFavoritesNameSpace
    {
        CONST_VTBL struct IShellFavoritesNameSpaceVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IShellFavoritesNameSpace_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IShellFavoritesNameSpace_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IShellFavoritesNameSpace_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IShellFavoritesNameSpace_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IShellFavoritesNameSpace_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IShellFavoritesNameSpace_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IShellFavoritesNameSpace_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IShellFavoritesNameSpace_MoveSelectionUp(This)	\
    (This)->lpVtbl -> MoveSelectionUp(This)

#define IShellFavoritesNameSpace_MoveSelectionDown(This)	\
    (This)->lpVtbl -> MoveSelectionDown(This)

#define IShellFavoritesNameSpace_ResetSort(This)	\
    (This)->lpVtbl -> ResetSort(This)

#define IShellFavoritesNameSpace_NewFolder(This)	\
    (This)->lpVtbl -> NewFolder(This)

#define IShellFavoritesNameSpace_Synchronize(This)	\
    (This)->lpVtbl -> Synchronize(This)

#define IShellFavoritesNameSpace_Import(This)	\
    (This)->lpVtbl -> Import(This)

#define IShellFavoritesNameSpace_Export(This)	\
    (This)->lpVtbl -> Export(This)

#define IShellFavoritesNameSpace_InvokeContextMenuCommand(This,strCommand)	\
    (This)->lpVtbl -> InvokeContextMenuCommand(This,strCommand)

#define IShellFavoritesNameSpace_MoveSelectionTo(This)	\
    (This)->lpVtbl -> MoveSelectionTo(This)

#define IShellFavoritesNameSpace_get_FOfflinePackInstalled(This,pBool)	\
    (This)->lpVtbl -> get_FOfflinePackInstalled(This,pBool)

#define IShellFavoritesNameSpace_CreateSubscriptionForSelection(This,pBool)	\
    (This)->lpVtbl -> CreateSubscriptionForSelection(This,pBool)

#define IShellFavoritesNameSpace_DeleteSubscriptionForSelection(This,pBool)	\
    (This)->lpVtbl -> DeleteSubscriptionForSelection(This,pBool)

#define IShellFavoritesNameSpace_SetRoot(This,bstrFullPath)	\
    (This)->lpVtbl -> SetRoot(This,bstrFullPath)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][hidden] */ HRESULT STDMETHODCALLTYPE IShellFavoritesNameSpace_MoveSelectionUp_Proxy( 
    IShellFavoritesNameSpace __RPC_FAR * This);


void __RPC_STUB IShellFavoritesNameSpace_MoveSelectionUp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][hidden] */ HRESULT STDMETHODCALLTYPE IShellFavoritesNameSpace_MoveSelectionDown_Proxy( 
    IShellFavoritesNameSpace __RPC_FAR * This);


void __RPC_STUB IShellFavoritesNameSpace_MoveSelectionDown_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][hidden] */ HRESULT STDMETHODCALLTYPE IShellFavoritesNameSpace_ResetSort_Proxy( 
    IShellFavoritesNameSpace __RPC_FAR * This);


void __RPC_STUB IShellFavoritesNameSpace_ResetSort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][hidden] */ HRESULT STDMETHODCALLTYPE IShellFavoritesNameSpace_NewFolder_Proxy( 
    IShellFavoritesNameSpace __RPC_FAR * This);


void __RPC_STUB IShellFavoritesNameSpace_NewFolder_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][hidden] */ HRESULT STDMETHODCALLTYPE IShellFavoritesNameSpace_Synchronize_Proxy( 
    IShellFavoritesNameSpace __RPC_FAR * This);


void __RPC_STUB IShellFavoritesNameSpace_Synchronize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][hidden] */ HRESULT STDMETHODCALLTYPE IShellFavoritesNameSpace_Import_Proxy( 
    IShellFavoritesNameSpace __RPC_FAR * This);


void __RPC_STUB IShellFavoritesNameSpace_Import_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][hidden] */ HRESULT STDMETHODCALLTYPE IShellFavoritesNameSpace_Export_Proxy( 
    IShellFavoritesNameSpace __RPC_FAR * This);


void __RPC_STUB IShellFavoritesNameSpace_Export_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][hidden] */ HRESULT STDMETHODCALLTYPE IShellFavoritesNameSpace_InvokeContextMenuCommand_Proxy( 
    IShellFavoritesNameSpace __RPC_FAR * This,
    /* [in] */ BSTR strCommand);


void __RPC_STUB IShellFavoritesNameSpace_InvokeContextMenuCommand_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][hidden] */ HRESULT STDMETHODCALLTYPE IShellFavoritesNameSpace_MoveSelectionTo_Proxy( 
    IShellFavoritesNameSpace __RPC_FAR * This);


void __RPC_STUB IShellFavoritesNameSpace_MoveSelectionTo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget][hidden] */ HRESULT STDMETHODCALLTYPE IShellFavoritesNameSpace_get_FOfflinePackInstalled_Proxy( 
    IShellFavoritesNameSpace __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pBool);


void __RPC_STUB IShellFavoritesNameSpace_get_FOfflinePackInstalled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][hidden] */ HRESULT STDMETHODCALLTYPE IShellFavoritesNameSpace_CreateSubscriptionForSelection_Proxy( 
    IShellFavoritesNameSpace __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pBool);


void __RPC_STUB IShellFavoritesNameSpace_CreateSubscriptionForSelection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][hidden] */ HRESULT STDMETHODCALLTYPE IShellFavoritesNameSpace_DeleteSubscriptionForSelection_Proxy( 
    IShellFavoritesNameSpace __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pBool);


void __RPC_STUB IShellFavoritesNameSpace_DeleteSubscriptionForSelection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][hidden] */ HRESULT STDMETHODCALLTYPE IShellFavoritesNameSpace_SetRoot_Proxy( 
    IShellFavoritesNameSpace __RPC_FAR * This,
    /* [in] */ BSTR bstrFullPath);


void __RPC_STUB IShellFavoritesNameSpace_SetRoot_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IShellFavoritesNameSpace_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_ShellFavoritesNameSpace;

#ifdef __cplusplus

class DECLSPEC_UUID("55136805-B2DE-11D1-B9F2-00A0C98BC547")
ShellFavoritesNameSpace;
#endif

#ifndef __IScriptErrorList_INTERFACE_DEFINED__
#define __IScriptErrorList_INTERFACE_DEFINED__

/* interface IScriptErrorList */
/* [object][dual][hidden][oleautomation][helpstring][uuid] */ 


EXTERN_C const IID IID_IScriptErrorList;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F3470F24-15FD-11d2-BB2E-00805FF7EFCA")
    IScriptErrorList : public IDispatch
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE advanceError( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE retreatError( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE canAdvanceError( 
            /* [retval][out] */ BOOL __RPC_FAR *pfCanAdvance) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE canRetreatError( 
            /* [retval][out] */ BOOL __RPC_FAR *pfCanRetreat) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE getErrorLine( 
            /* [retval][out] */ LONG __RPC_FAR *plLine) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE getErrorChar( 
            /* [retval][out] */ LONG __RPC_FAR *plChar) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE getErrorCode( 
            /* [retval][out] */ LONG __RPC_FAR *plCode) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE getErrorMsg( 
            /* [retval][out] */ BSTR __RPC_FAR *pstr) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE getErrorUrl( 
            /* [retval][out] */ BSTR __RPC_FAR *pstr) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE getAlwaysShowLockState( 
            /* [retval][out] */ BOOL __RPC_FAR *pfAlwaysShowLocked) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE getDetailsPaneOpen( 
            /* [retval][out] */ BOOL __RPC_FAR *pfDetailsPaneOpen) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE setDetailsPaneOpen( 
            BOOL fDetailsPaneOpen) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE getPerErrorDisplay( 
            /* [retval][out] */ BOOL __RPC_FAR *pfPerErrorDisplay) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE setPerErrorDisplay( 
            BOOL fPerErrorDisplay) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IScriptErrorListVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IScriptErrorList __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IScriptErrorList __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IScriptErrorList __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IScriptErrorList __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IScriptErrorList __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IScriptErrorList __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IScriptErrorList __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *advanceError )( 
            IScriptErrorList __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *retreatError )( 
            IScriptErrorList __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *canAdvanceError )( 
            IScriptErrorList __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pfCanAdvance);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *canRetreatError )( 
            IScriptErrorList __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pfCanRetreat);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getErrorLine )( 
            IScriptErrorList __RPC_FAR * This,
            /* [retval][out] */ LONG __RPC_FAR *plLine);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getErrorChar )( 
            IScriptErrorList __RPC_FAR * This,
            /* [retval][out] */ LONG __RPC_FAR *plChar);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getErrorCode )( 
            IScriptErrorList __RPC_FAR * This,
            /* [retval][out] */ LONG __RPC_FAR *plCode);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getErrorMsg )( 
            IScriptErrorList __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pstr);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getErrorUrl )( 
            IScriptErrorList __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pstr);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getAlwaysShowLockState )( 
            IScriptErrorList __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pfAlwaysShowLocked);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getDetailsPaneOpen )( 
            IScriptErrorList __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pfDetailsPaneOpen);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *setDetailsPaneOpen )( 
            IScriptErrorList __RPC_FAR * This,
            BOOL fDetailsPaneOpen);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getPerErrorDisplay )( 
            IScriptErrorList __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pfPerErrorDisplay);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *setPerErrorDisplay )( 
            IScriptErrorList __RPC_FAR * This,
            BOOL fPerErrorDisplay);
        
        END_INTERFACE
    } IScriptErrorListVtbl;

    interface IScriptErrorList
    {
        CONST_VTBL struct IScriptErrorListVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IScriptErrorList_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IScriptErrorList_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IScriptErrorList_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IScriptErrorList_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IScriptErrorList_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IScriptErrorList_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IScriptErrorList_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IScriptErrorList_advanceError(This)	\
    (This)->lpVtbl -> advanceError(This)

#define IScriptErrorList_retreatError(This)	\
    (This)->lpVtbl -> retreatError(This)

#define IScriptErrorList_canAdvanceError(This,pfCanAdvance)	\
    (This)->lpVtbl -> canAdvanceError(This,pfCanAdvance)

#define IScriptErrorList_canRetreatError(This,pfCanRetreat)	\
    (This)->lpVtbl -> canRetreatError(This,pfCanRetreat)

#define IScriptErrorList_getErrorLine(This,plLine)	\
    (This)->lpVtbl -> getErrorLine(This,plLine)

#define IScriptErrorList_getErrorChar(This,plChar)	\
    (This)->lpVtbl -> getErrorChar(This,plChar)

#define IScriptErrorList_getErrorCode(This,plCode)	\
    (This)->lpVtbl -> getErrorCode(This,plCode)

#define IScriptErrorList_getErrorMsg(This,pstr)	\
    (This)->lpVtbl -> getErrorMsg(This,pstr)

#define IScriptErrorList_getErrorUrl(This,pstr)	\
    (This)->lpVtbl -> getErrorUrl(This,pstr)

#define IScriptErrorList_getAlwaysShowLockState(This,pfAlwaysShowLocked)	\
    (This)->lpVtbl -> getAlwaysShowLockState(This,pfAlwaysShowLocked)

#define IScriptErrorList_getDetailsPaneOpen(This,pfDetailsPaneOpen)	\
    (This)->lpVtbl -> getDetailsPaneOpen(This,pfDetailsPaneOpen)

#define IScriptErrorList_setDetailsPaneOpen(This,fDetailsPaneOpen)	\
    (This)->lpVtbl -> setDetailsPaneOpen(This,fDetailsPaneOpen)

#define IScriptErrorList_getPerErrorDisplay(This,pfPerErrorDisplay)	\
    (This)->lpVtbl -> getPerErrorDisplay(This,pfPerErrorDisplay)

#define IScriptErrorList_setPerErrorDisplay(This,fPerErrorDisplay)	\
    (This)->lpVtbl -> setPerErrorDisplay(This,fPerErrorDisplay)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id] */ HRESULT STDMETHODCALLTYPE IScriptErrorList_advanceError_Proxy( 
    IScriptErrorList __RPC_FAR * This);


void __RPC_STUB IScriptErrorList_advanceError_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IScriptErrorList_retreatError_Proxy( 
    IScriptErrorList __RPC_FAR * This);


void __RPC_STUB IScriptErrorList_retreatError_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IScriptErrorList_canAdvanceError_Proxy( 
    IScriptErrorList __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pfCanAdvance);


void __RPC_STUB IScriptErrorList_canAdvanceError_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IScriptErrorList_canRetreatError_Proxy( 
    IScriptErrorList __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pfCanRetreat);


void __RPC_STUB IScriptErrorList_canRetreatError_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IScriptErrorList_getErrorLine_Proxy( 
    IScriptErrorList __RPC_FAR * This,
    /* [retval][out] */ LONG __RPC_FAR *plLine);


void __RPC_STUB IScriptErrorList_getErrorLine_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IScriptErrorList_getErrorChar_Proxy( 
    IScriptErrorList __RPC_FAR * This,
    /* [retval][out] */ LONG __RPC_FAR *plChar);


void __RPC_STUB IScriptErrorList_getErrorChar_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IScriptErrorList_getErrorCode_Proxy( 
    IScriptErrorList __RPC_FAR * This,
    /* [retval][out] */ LONG __RPC_FAR *plCode);


void __RPC_STUB IScriptErrorList_getErrorCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IScriptErrorList_getErrorMsg_Proxy( 
    IScriptErrorList __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pstr);


void __RPC_STUB IScriptErrorList_getErrorMsg_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IScriptErrorList_getErrorUrl_Proxy( 
    IScriptErrorList __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pstr);


void __RPC_STUB IScriptErrorList_getErrorUrl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IScriptErrorList_getAlwaysShowLockState_Proxy( 
    IScriptErrorList __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pfAlwaysShowLocked);


void __RPC_STUB IScriptErrorList_getAlwaysShowLockState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IScriptErrorList_getDetailsPaneOpen_Proxy( 
    IScriptErrorList __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pfDetailsPaneOpen);


void __RPC_STUB IScriptErrorList_getDetailsPaneOpen_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IScriptErrorList_setDetailsPaneOpen_Proxy( 
    IScriptErrorList __RPC_FAR * This,
    BOOL fDetailsPaneOpen);


void __RPC_STUB IScriptErrorList_setDetailsPaneOpen_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IScriptErrorList_getPerErrorDisplay_Proxy( 
    IScriptErrorList __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pfPerErrorDisplay);


void __RPC_STUB IScriptErrorList_getPerErrorDisplay_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IScriptErrorList_setPerErrorDisplay_Proxy( 
    IScriptErrorList __RPC_FAR * This,
    BOOL fPerErrorDisplay);


void __RPC_STUB IScriptErrorList_setPerErrorDisplay_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IScriptErrorList_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_CScriptErrorList;

#ifdef __cplusplus

class DECLSPEC_UUID("EFD01300-160F-11d2-BB2E-00805FF7EFCA")
CScriptErrorList;
#endif

#ifndef __ISearch_INTERFACE_DEFINED__
#define __ISearch_INTERFACE_DEFINED__

/* interface ISearch */
/* [object][dual][oleautomation][hidden][helpstring][uuid] */ 


EXTERN_C const IID IID_ISearch;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ba9239a4-3dd5-11d2-bf8b-00c04fb93661")
    ISearch : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Title( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrTitle) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Id( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrId) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Url( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrUrl) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISearchVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISearch __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISearch __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISearch __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ISearch __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ISearch __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ISearch __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ISearch __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Title )( 
            ISearch __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrTitle);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Id )( 
            ISearch __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrId);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Url )( 
            ISearch __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrUrl);
        
        END_INTERFACE
    } ISearchVtbl;

    interface ISearch
    {
        CONST_VTBL struct ISearchVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISearch_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISearch_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISearch_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISearch_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ISearch_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ISearch_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ISearch_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ISearch_get_Title(This,pbstrTitle)	\
    (This)->lpVtbl -> get_Title(This,pbstrTitle)

#define ISearch_get_Id(This,pbstrId)	\
    (This)->lpVtbl -> get_Id(This,pbstrId)

#define ISearch_get_Url(This,pbstrUrl)	\
    (This)->lpVtbl -> get_Url(This,pbstrUrl)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE ISearch_get_Title_Proxy( 
    ISearch __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrTitle);


void __RPC_STUB ISearch_get_Title_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE ISearch_get_Id_Proxy( 
    ISearch __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrId);


void __RPC_STUB ISearch_get_Id_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE ISearch_get_Url_Proxy( 
    ISearch __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrUrl);


void __RPC_STUB ISearch_get_Url_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISearch_INTERFACE_DEFINED__ */


#ifndef __ISearches_INTERFACE_DEFINED__
#define __ISearches_INTERFACE_DEFINED__

/* interface ISearches */
/* [object][dual][oleautomation][hidden][helpstring][uuid] */ 


EXTERN_C const IID IID_ISearches;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("47c922a2-3dd5-11d2-bf8b-00c04fb93661")
    ISearches : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long __RPC_FAR *plCount) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Default( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrDefault) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Item( 
            /* [optional][in] */ VARIANT index,
            /* [retval][out] */ ISearch __RPC_FAR *__RPC_FAR *ppid) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE _NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunk) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISearchesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISearches __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISearches __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISearches __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ISearches __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ISearches __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ISearches __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ISearches __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            ISearches __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plCount);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Default )( 
            ISearches __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrDefault);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Item )( 
            ISearches __RPC_FAR * This,
            /* [optional][in] */ VARIANT index,
            /* [retval][out] */ ISearch __RPC_FAR *__RPC_FAR *ppid);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *_NewEnum )( 
            ISearches __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunk);
        
        END_INTERFACE
    } ISearchesVtbl;

    interface ISearches
    {
        CONST_VTBL struct ISearchesVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISearches_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISearches_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISearches_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISearches_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ISearches_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ISearches_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ISearches_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ISearches_get_Count(This,plCount)	\
    (This)->lpVtbl -> get_Count(This,plCount)

#define ISearches_get_Default(This,pbstrDefault)	\
    (This)->lpVtbl -> get_Default(This,pbstrDefault)

#define ISearches_Item(This,index,ppid)	\
    (This)->lpVtbl -> Item(This,index,ppid)

#define ISearches__NewEnum(This,ppunk)	\
    (This)->lpVtbl -> _NewEnum(This,ppunk)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE ISearches_get_Count_Proxy( 
    ISearches __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plCount);


void __RPC_STUB ISearches_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE ISearches_get_Default_Proxy( 
    ISearches __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrDefault);


void __RPC_STUB ISearches_get_Default_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISearches_Item_Proxy( 
    ISearches __RPC_FAR * This,
    /* [optional][in] */ VARIANT index,
    /* [retval][out] */ ISearch __RPC_FAR *__RPC_FAR *ppid);


void __RPC_STUB ISearches_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISearches__NewEnum_Proxy( 
    ISearches __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunk);


void __RPC_STUB ISearches__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISearches_INTERFACE_DEFINED__ */


#ifndef __ISearchAssistantOC_INTERFACE_DEFINED__
#define __ISearchAssistantOC_INTERFACE_DEFINED__

/* interface ISearchAssistantOC */
/* [unique][helpstring][dual][hidden][uuid][object] */ 


EXTERN_C const IID IID_ISearchAssistantOC;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("72423E8F-8011-11d2-BE79-00A0C9A83DA1")
    ISearchAssistantOC : public IDispatch
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE AddNextMenuItem( 
            /* [in] */ BSTR bstrText,
            /* [in] */ long idItem) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE SetDefaultSearchUrl( 
            /* [in] */ BSTR bstrUrl) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE NavigateToDefaultSearch( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE IsRestricted( 
            /* [in] */ BSTR bstrGuid,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ShellFeaturesEnabled( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SearchAssistantDefault( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Searches( 
            /* [retval][out] */ ISearches __RPC_FAR *__RPC_FAR *ppid) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_InWebFolder( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE PutProperty( 
            /* [in] */ VARIANT_BOOL bPerLocale,
            /* [in] */ BSTR bstrName,
            /* [in] */ BSTR bstrValue) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetProperty( 
            /* [in] */ VARIANT_BOOL bPerLocale,
            /* [in] */ BSTR bstrName,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrValue) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_EventHandled( 
            /* [in] */ VARIANT_BOOL bHandled) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE ResetNextMenu( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE FindOnWeb( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE FindFilesOrFolders( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE FindComputer( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE FindPrinter( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE FindPeople( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetSearchAssistantURL( 
            /* [in] */ VARIANT_BOOL bSubstitute,
            /* [in] */ VARIANT_BOOL bCustomize,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrValue) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE NotifySearchSettingsChanged( void) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_ASProvider( 
            /* [in] */ BSTR Provider) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_ASProvider( 
            /* [retval][out] */ BSTR __RPC_FAR *pProvider) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_ASSetting( 
            /* [in] */ int Setting) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_ASSetting( 
            /* [retval][out] */ int __RPC_FAR *pSetting) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE NETDetectNextNavigate( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE PutFindText( 
            /* [in] */ BSTR FindText) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Version( 
            /* [retval][out] */ int __RPC_FAR *pVersion) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE EncodeString( 
            /* [in] */ BSTR bstrValue,
            /* [in] */ BSTR bstrCharSet,
            /* [in] */ VARIANT_BOOL bUseUTF8,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrResult) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISearchAssistantOCVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISearchAssistantOC __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISearchAssistantOC __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISearchAssistantOC __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ISearchAssistantOC __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ISearchAssistantOC __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ISearchAssistantOC __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ISearchAssistantOC __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddNextMenuItem )( 
            ISearchAssistantOC __RPC_FAR * This,
            /* [in] */ BSTR bstrText,
            /* [in] */ long idItem);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDefaultSearchUrl )( 
            ISearchAssistantOC __RPC_FAR * This,
            /* [in] */ BSTR bstrUrl);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NavigateToDefaultSearch )( 
            ISearchAssistantOC __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsRestricted )( 
            ISearchAssistantOC __RPC_FAR * This,
            /* [in] */ BSTR bstrGuid,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ShellFeaturesEnabled )( 
            ISearchAssistantOC __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SearchAssistantDefault )( 
            ISearchAssistantOC __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Searches )( 
            ISearchAssistantOC __RPC_FAR * This,
            /* [retval][out] */ ISearches __RPC_FAR *__RPC_FAR *ppid);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_InWebFolder )( 
            ISearchAssistantOC __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PutProperty )( 
            ISearchAssistantOC __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL bPerLocale,
            /* [in] */ BSTR bstrName,
            /* [in] */ BSTR bstrValue);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProperty )( 
            ISearchAssistantOC __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL bPerLocale,
            /* [in] */ BSTR bstrName,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrValue);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_EventHandled )( 
            ISearchAssistantOC __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL bHandled);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ResetNextMenu )( 
            ISearchAssistantOC __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindOnWeb )( 
            ISearchAssistantOC __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindFilesOrFolders )( 
            ISearchAssistantOC __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindComputer )( 
            ISearchAssistantOC __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindPrinter )( 
            ISearchAssistantOC __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindPeople )( 
            ISearchAssistantOC __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSearchAssistantURL )( 
            ISearchAssistantOC __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL bSubstitute,
            /* [in] */ VARIANT_BOOL bCustomize,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrValue);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NotifySearchSettingsChanged )( 
            ISearchAssistantOC __RPC_FAR * This);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ASProvider )( 
            ISearchAssistantOC __RPC_FAR * This,
            /* [in] */ BSTR Provider);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ASProvider )( 
            ISearchAssistantOC __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pProvider);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ASSetting )( 
            ISearchAssistantOC __RPC_FAR * This,
            /* [in] */ int Setting);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ASSetting )( 
            ISearchAssistantOC __RPC_FAR * This,
            /* [retval][out] */ int __RPC_FAR *pSetting);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NETDetectNextNavigate )( 
            ISearchAssistantOC __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PutFindText )( 
            ISearchAssistantOC __RPC_FAR * This,
            /* [in] */ BSTR FindText);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Version )( 
            ISearchAssistantOC __RPC_FAR * This,
            /* [retval][out] */ int __RPC_FAR *pVersion);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EncodeString )( 
            ISearchAssistantOC __RPC_FAR * This,
            /* [in] */ BSTR bstrValue,
            /* [in] */ BSTR bstrCharSet,
            /* [in] */ VARIANT_BOOL bUseUTF8,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrResult);
        
        END_INTERFACE
    } ISearchAssistantOCVtbl;

    interface ISearchAssistantOC
    {
        CONST_VTBL struct ISearchAssistantOCVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISearchAssistantOC_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISearchAssistantOC_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISearchAssistantOC_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISearchAssistantOC_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ISearchAssistantOC_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ISearchAssistantOC_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ISearchAssistantOC_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ISearchAssistantOC_AddNextMenuItem(This,bstrText,idItem)	\
    (This)->lpVtbl -> AddNextMenuItem(This,bstrText,idItem)

#define ISearchAssistantOC_SetDefaultSearchUrl(This,bstrUrl)	\
    (This)->lpVtbl -> SetDefaultSearchUrl(This,bstrUrl)

#define ISearchAssistantOC_NavigateToDefaultSearch(This)	\
    (This)->lpVtbl -> NavigateToDefaultSearch(This)

#define ISearchAssistantOC_IsRestricted(This,bstrGuid,pVal)	\
    (This)->lpVtbl -> IsRestricted(This,bstrGuid,pVal)

#define ISearchAssistantOC_get_ShellFeaturesEnabled(This,pVal)	\
    (This)->lpVtbl -> get_ShellFeaturesEnabled(This,pVal)

#define ISearchAssistantOC_get_SearchAssistantDefault(This,pVal)	\
    (This)->lpVtbl -> get_SearchAssistantDefault(This,pVal)

#define ISearchAssistantOC_get_Searches(This,ppid)	\
    (This)->lpVtbl -> get_Searches(This,ppid)

#define ISearchAssistantOC_get_InWebFolder(This,pVal)	\
    (This)->lpVtbl -> get_InWebFolder(This,pVal)

#define ISearchAssistantOC_PutProperty(This,bPerLocale,bstrName,bstrValue)	\
    (This)->lpVtbl -> PutProperty(This,bPerLocale,bstrName,bstrValue)

#define ISearchAssistantOC_GetProperty(This,bPerLocale,bstrName,pbstrValue)	\
    (This)->lpVtbl -> GetProperty(This,bPerLocale,bstrName,pbstrValue)

#define ISearchAssistantOC_put_EventHandled(This,bHandled)	\
    (This)->lpVtbl -> put_EventHandled(This,bHandled)

#define ISearchAssistantOC_ResetNextMenu(This)	\
    (This)->lpVtbl -> ResetNextMenu(This)

#define ISearchAssistantOC_FindOnWeb(This)	\
    (This)->lpVtbl -> FindOnWeb(This)

#define ISearchAssistantOC_FindFilesOrFolders(This)	\
    (This)->lpVtbl -> FindFilesOrFolders(This)

#define ISearchAssistantOC_FindComputer(This)	\
    (This)->lpVtbl -> FindComputer(This)

#define ISearchAssistantOC_FindPrinter(This)	\
    (This)->lpVtbl -> FindPrinter(This)

#define ISearchAssistantOC_FindPeople(This)	\
    (This)->lpVtbl -> FindPeople(This)

#define ISearchAssistantOC_GetSearchAssistantURL(This,bSubstitute,bCustomize,pbstrValue)	\
    (This)->lpVtbl -> GetSearchAssistantURL(This,bSubstitute,bCustomize,pbstrValue)

#define ISearchAssistantOC_NotifySearchSettingsChanged(This)	\
    (This)->lpVtbl -> NotifySearchSettingsChanged(This)

#define ISearchAssistantOC_put_ASProvider(This,Provider)	\
    (This)->lpVtbl -> put_ASProvider(This,Provider)

#define ISearchAssistantOC_get_ASProvider(This,pProvider)	\
    (This)->lpVtbl -> get_ASProvider(This,pProvider)

#define ISearchAssistantOC_put_ASSetting(This,Setting)	\
    (This)->lpVtbl -> put_ASSetting(This,Setting)

#define ISearchAssistantOC_get_ASSetting(This,pSetting)	\
    (This)->lpVtbl -> get_ASSetting(This,pSetting)

#define ISearchAssistantOC_NETDetectNextNavigate(This)	\
    (This)->lpVtbl -> NETDetectNextNavigate(This)

#define ISearchAssistantOC_PutFindText(This,FindText)	\
    (This)->lpVtbl -> PutFindText(This,FindText)

#define ISearchAssistantOC_get_Version(This,pVersion)	\
    (This)->lpVtbl -> get_Version(This,pVersion)

#define ISearchAssistantOC_EncodeString(This,bstrValue,bstrCharSet,bUseUTF8,pbstrResult)	\
    (This)->lpVtbl -> EncodeString(This,bstrValue,bstrCharSet,bUseUTF8,pbstrResult)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id] */ HRESULT STDMETHODCALLTYPE ISearchAssistantOC_AddNextMenuItem_Proxy( 
    ISearchAssistantOC __RPC_FAR * This,
    /* [in] */ BSTR bstrText,
    /* [in] */ long idItem);


void __RPC_STUB ISearchAssistantOC_AddNextMenuItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ISearchAssistantOC_SetDefaultSearchUrl_Proxy( 
    ISearchAssistantOC __RPC_FAR * This,
    /* [in] */ BSTR bstrUrl);


void __RPC_STUB ISearchAssistantOC_SetDefaultSearchUrl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ISearchAssistantOC_NavigateToDefaultSearch_Proxy( 
    ISearchAssistantOC __RPC_FAR * This);


void __RPC_STUB ISearchAssistantOC_NavigateToDefaultSearch_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ISearchAssistantOC_IsRestricted_Proxy( 
    ISearchAssistantOC __RPC_FAR * This,
    /* [in] */ BSTR bstrGuid,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);


void __RPC_STUB ISearchAssistantOC_IsRestricted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ISearchAssistantOC_get_ShellFeaturesEnabled_Proxy( 
    ISearchAssistantOC __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);


void __RPC_STUB ISearchAssistantOC_get_ShellFeaturesEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ISearchAssistantOC_get_SearchAssistantDefault_Proxy( 
    ISearchAssistantOC __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);


void __RPC_STUB ISearchAssistantOC_get_SearchAssistantDefault_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ISearchAssistantOC_get_Searches_Proxy( 
    ISearchAssistantOC __RPC_FAR * This,
    /* [retval][out] */ ISearches __RPC_FAR *__RPC_FAR *ppid);


void __RPC_STUB ISearchAssistantOC_get_Searches_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ISearchAssistantOC_get_InWebFolder_Proxy( 
    ISearchAssistantOC __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);


void __RPC_STUB ISearchAssistantOC_get_InWebFolder_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ISearchAssistantOC_PutProperty_Proxy( 
    ISearchAssistantOC __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL bPerLocale,
    /* [in] */ BSTR bstrName,
    /* [in] */ BSTR bstrValue);


void __RPC_STUB ISearchAssistantOC_PutProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ISearchAssistantOC_GetProperty_Proxy( 
    ISearchAssistantOC __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL bPerLocale,
    /* [in] */ BSTR bstrName,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrValue);


void __RPC_STUB ISearchAssistantOC_GetProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ISearchAssistantOC_put_EventHandled_Proxy( 
    ISearchAssistantOC __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL bHandled);


void __RPC_STUB ISearchAssistantOC_put_EventHandled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ISearchAssistantOC_ResetNextMenu_Proxy( 
    ISearchAssistantOC __RPC_FAR * This);


void __RPC_STUB ISearchAssistantOC_ResetNextMenu_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ISearchAssistantOC_FindOnWeb_Proxy( 
    ISearchAssistantOC __RPC_FAR * This);


void __RPC_STUB ISearchAssistantOC_FindOnWeb_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ISearchAssistantOC_FindFilesOrFolders_Proxy( 
    ISearchAssistantOC __RPC_FAR * This);


void __RPC_STUB ISearchAssistantOC_FindFilesOrFolders_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ISearchAssistantOC_FindComputer_Proxy( 
    ISearchAssistantOC __RPC_FAR * This);


void __RPC_STUB ISearchAssistantOC_FindComputer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ISearchAssistantOC_FindPrinter_Proxy( 
    ISearchAssistantOC __RPC_FAR * This);


void __RPC_STUB ISearchAssistantOC_FindPrinter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ISearchAssistantOC_FindPeople_Proxy( 
    ISearchAssistantOC __RPC_FAR * This);


void __RPC_STUB ISearchAssistantOC_FindPeople_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ISearchAssistantOC_GetSearchAssistantURL_Proxy( 
    ISearchAssistantOC __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL bSubstitute,
    /* [in] */ VARIANT_BOOL bCustomize,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrValue);


void __RPC_STUB ISearchAssistantOC_GetSearchAssistantURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ISearchAssistantOC_NotifySearchSettingsChanged_Proxy( 
    ISearchAssistantOC __RPC_FAR * This);


void __RPC_STUB ISearchAssistantOC_NotifySearchSettingsChanged_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ISearchAssistantOC_put_ASProvider_Proxy( 
    ISearchAssistantOC __RPC_FAR * This,
    /* [in] */ BSTR Provider);


void __RPC_STUB ISearchAssistantOC_put_ASProvider_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ISearchAssistantOC_get_ASProvider_Proxy( 
    ISearchAssistantOC __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pProvider);


void __RPC_STUB ISearchAssistantOC_get_ASProvider_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ISearchAssistantOC_put_ASSetting_Proxy( 
    ISearchAssistantOC __RPC_FAR * This,
    /* [in] */ int Setting);


void __RPC_STUB ISearchAssistantOC_put_ASSetting_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ISearchAssistantOC_get_ASSetting_Proxy( 
    ISearchAssistantOC __RPC_FAR * This,
    /* [retval][out] */ int __RPC_FAR *pSetting);


void __RPC_STUB ISearchAssistantOC_get_ASSetting_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ISearchAssistantOC_NETDetectNextNavigate_Proxy( 
    ISearchAssistantOC __RPC_FAR * This);


void __RPC_STUB ISearchAssistantOC_NETDetectNextNavigate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ISearchAssistantOC_PutFindText_Proxy( 
    ISearchAssistantOC __RPC_FAR * This,
    /* [in] */ BSTR FindText);


void __RPC_STUB ISearchAssistantOC_PutFindText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ISearchAssistantOC_get_Version_Proxy( 
    ISearchAssistantOC __RPC_FAR * This,
    /* [retval][out] */ int __RPC_FAR *pVersion);


void __RPC_STUB ISearchAssistantOC_get_Version_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ISearchAssistantOC_EncodeString_Proxy( 
    ISearchAssistantOC __RPC_FAR * This,
    /* [in] */ BSTR bstrValue,
    /* [in] */ BSTR bstrCharSet,
    /* [in] */ VARIANT_BOOL bUseUTF8,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrResult);


void __RPC_STUB ISearchAssistantOC_EncodeString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISearchAssistantOC_INTERFACE_DEFINED__ */


#ifndef __ISearchAssistantOC2_INTERFACE_DEFINED__
#define __ISearchAssistantOC2_INTERFACE_DEFINED__

/* interface ISearchAssistantOC2 */
/* [unique][helpstring][dual][hidden][uuid][object] */ 


EXTERN_C const IID IID_ISearchAssistantOC2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("72423E8F-8011-11d2-BE79-00A0C9A83DA2")
    ISearchAssistantOC2 : public ISearchAssistantOC
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_ShowFindPrinter( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbShowFindPrinter) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISearchAssistantOC2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISearchAssistantOC2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISearchAssistantOC2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISearchAssistantOC2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ISearchAssistantOC2 __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ISearchAssistantOC2 __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ISearchAssistantOC2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ISearchAssistantOC2 __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddNextMenuItem )( 
            ISearchAssistantOC2 __RPC_FAR * This,
            /* [in] */ BSTR bstrText,
            /* [in] */ long idItem);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDefaultSearchUrl )( 
            ISearchAssistantOC2 __RPC_FAR * This,
            /* [in] */ BSTR bstrUrl);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NavigateToDefaultSearch )( 
            ISearchAssistantOC2 __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsRestricted )( 
            ISearchAssistantOC2 __RPC_FAR * This,
            /* [in] */ BSTR bstrGuid,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ShellFeaturesEnabled )( 
            ISearchAssistantOC2 __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SearchAssistantDefault )( 
            ISearchAssistantOC2 __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Searches )( 
            ISearchAssistantOC2 __RPC_FAR * This,
            /* [retval][out] */ ISearches __RPC_FAR *__RPC_FAR *ppid);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_InWebFolder )( 
            ISearchAssistantOC2 __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PutProperty )( 
            ISearchAssistantOC2 __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL bPerLocale,
            /* [in] */ BSTR bstrName,
            /* [in] */ BSTR bstrValue);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProperty )( 
            ISearchAssistantOC2 __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL bPerLocale,
            /* [in] */ BSTR bstrName,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrValue);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_EventHandled )( 
            ISearchAssistantOC2 __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL bHandled);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ResetNextMenu )( 
            ISearchAssistantOC2 __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindOnWeb )( 
            ISearchAssistantOC2 __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindFilesOrFolders )( 
            ISearchAssistantOC2 __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindComputer )( 
            ISearchAssistantOC2 __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindPrinter )( 
            ISearchAssistantOC2 __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindPeople )( 
            ISearchAssistantOC2 __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSearchAssistantURL )( 
            ISearchAssistantOC2 __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL bSubstitute,
            /* [in] */ VARIANT_BOOL bCustomize,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrValue);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NotifySearchSettingsChanged )( 
            ISearchAssistantOC2 __RPC_FAR * This);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ASProvider )( 
            ISearchAssistantOC2 __RPC_FAR * This,
            /* [in] */ BSTR Provider);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ASProvider )( 
            ISearchAssistantOC2 __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pProvider);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ASSetting )( 
            ISearchAssistantOC2 __RPC_FAR * This,
            /* [in] */ int Setting);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ASSetting )( 
            ISearchAssistantOC2 __RPC_FAR * This,
            /* [retval][out] */ int __RPC_FAR *pSetting);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NETDetectNextNavigate )( 
            ISearchAssistantOC2 __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PutFindText )( 
            ISearchAssistantOC2 __RPC_FAR * This,
            /* [in] */ BSTR FindText);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Version )( 
            ISearchAssistantOC2 __RPC_FAR * This,
            /* [retval][out] */ int __RPC_FAR *pVersion);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EncodeString )( 
            ISearchAssistantOC2 __RPC_FAR * This,
            /* [in] */ BSTR bstrValue,
            /* [in] */ BSTR bstrCharSet,
            /* [in] */ VARIANT_BOOL bUseUTF8,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrResult);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ShowFindPrinter )( 
            ISearchAssistantOC2 __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbShowFindPrinter);
        
        END_INTERFACE
    } ISearchAssistantOC2Vtbl;

    interface ISearchAssistantOC2
    {
        CONST_VTBL struct ISearchAssistantOC2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISearchAssistantOC2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISearchAssistantOC2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISearchAssistantOC2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISearchAssistantOC2_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ISearchAssistantOC2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ISearchAssistantOC2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ISearchAssistantOC2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ISearchAssistantOC2_AddNextMenuItem(This,bstrText,idItem)	\
    (This)->lpVtbl -> AddNextMenuItem(This,bstrText,idItem)

#define ISearchAssistantOC2_SetDefaultSearchUrl(This,bstrUrl)	\
    (This)->lpVtbl -> SetDefaultSearchUrl(This,bstrUrl)

#define ISearchAssistantOC2_NavigateToDefaultSearch(This)	\
    (This)->lpVtbl -> NavigateToDefaultSearch(This)

#define ISearchAssistantOC2_IsRestricted(This,bstrGuid,pVal)	\
    (This)->lpVtbl -> IsRestricted(This,bstrGuid,pVal)

#define ISearchAssistantOC2_get_ShellFeaturesEnabled(This,pVal)	\
    (This)->lpVtbl -> get_ShellFeaturesEnabled(This,pVal)

#define ISearchAssistantOC2_get_SearchAssistantDefault(This,pVal)	\
    (This)->lpVtbl -> get_SearchAssistantDefault(This,pVal)

#define ISearchAssistantOC2_get_Searches(This,ppid)	\
    (This)->lpVtbl -> get_Searches(This,ppid)

#define ISearchAssistantOC2_get_InWebFolder(This,pVal)	\
    (This)->lpVtbl -> get_InWebFolder(This,pVal)

#define ISearchAssistantOC2_PutProperty(This,bPerLocale,bstrName,bstrValue)	\
    (This)->lpVtbl -> PutProperty(This,bPerLocale,bstrName,bstrValue)

#define ISearchAssistantOC2_GetProperty(This,bPerLocale,bstrName,pbstrValue)	\
    (This)->lpVtbl -> GetProperty(This,bPerLocale,bstrName,pbstrValue)

#define ISearchAssistantOC2_put_EventHandled(This,bHandled)	\
    (This)->lpVtbl -> put_EventHandled(This,bHandled)

#define ISearchAssistantOC2_ResetNextMenu(This)	\
    (This)->lpVtbl -> ResetNextMenu(This)

#define ISearchAssistantOC2_FindOnWeb(This)	\
    (This)->lpVtbl -> FindOnWeb(This)

#define ISearchAssistantOC2_FindFilesOrFolders(This)	\
    (This)->lpVtbl -> FindFilesOrFolders(This)

#define ISearchAssistantOC2_FindComputer(This)	\
    (This)->lpVtbl -> FindComputer(This)

#define ISearchAssistantOC2_FindPrinter(This)	\
    (This)->lpVtbl -> FindPrinter(This)

#define ISearchAssistantOC2_FindPeople(This)	\
    (This)->lpVtbl -> FindPeople(This)

#define ISearchAssistantOC2_GetSearchAssistantURL(This,bSubstitute,bCustomize,pbstrValue)	\
    (This)->lpVtbl -> GetSearchAssistantURL(This,bSubstitute,bCustomize,pbstrValue)

#define ISearchAssistantOC2_NotifySearchSettingsChanged(This)	\
    (This)->lpVtbl -> NotifySearchSettingsChanged(This)

#define ISearchAssistantOC2_put_ASProvider(This,Provider)	\
    (This)->lpVtbl -> put_ASProvider(This,Provider)

#define ISearchAssistantOC2_get_ASProvider(This,pProvider)	\
    (This)->lpVtbl -> get_ASProvider(This,pProvider)

#define ISearchAssistantOC2_put_ASSetting(This,Setting)	\
    (This)->lpVtbl -> put_ASSetting(This,Setting)

#define ISearchAssistantOC2_get_ASSetting(This,pSetting)	\
    (This)->lpVtbl -> get_ASSetting(This,pSetting)

#define ISearchAssistantOC2_NETDetectNextNavigate(This)	\
    (This)->lpVtbl -> NETDetectNextNavigate(This)

#define ISearchAssistantOC2_PutFindText(This,FindText)	\
    (This)->lpVtbl -> PutFindText(This,FindText)

#define ISearchAssistantOC2_get_Version(This,pVersion)	\
    (This)->lpVtbl -> get_Version(This,pVersion)

#define ISearchAssistantOC2_EncodeString(This,bstrValue,bstrCharSet,bUseUTF8,pbstrResult)	\
    (This)->lpVtbl -> EncodeString(This,bstrValue,bstrCharSet,bUseUTF8,pbstrResult)


#define ISearchAssistantOC2_get_ShowFindPrinter(This,pbShowFindPrinter)	\
    (This)->lpVtbl -> get_ShowFindPrinter(This,pbShowFindPrinter)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE ISearchAssistantOC2_get_ShowFindPrinter_Proxy( 
    ISearchAssistantOC2 __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbShowFindPrinter);


void __RPC_STUB ISearchAssistantOC2_get_ShowFindPrinter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISearchAssistantOC2_INTERFACE_DEFINED__ */


#ifndef ___SearchAssistantEvents_DISPINTERFACE_DEFINED__
#define ___SearchAssistantEvents_DISPINTERFACE_DEFINED__

/* dispinterface _SearchAssistantEvents */
/* [hidden][uuid] */ 


EXTERN_C const IID DIID__SearchAssistantEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("1611FDDA-445B-11d2-85DE-00C04FA35C89")
    _SearchAssistantEvents : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct _SearchAssistantEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            _SearchAssistantEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            _SearchAssistantEvents __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            _SearchAssistantEvents __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            _SearchAssistantEvents __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            _SearchAssistantEvents __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            _SearchAssistantEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            _SearchAssistantEvents __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        END_INTERFACE
    } _SearchAssistantEventsVtbl;

    interface _SearchAssistantEvents
    {
        CONST_VTBL struct _SearchAssistantEventsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define _SearchAssistantEvents_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define _SearchAssistantEvents_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define _SearchAssistantEvents_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define _SearchAssistantEvents_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define _SearchAssistantEvents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define _SearchAssistantEvents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define _SearchAssistantEvents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* ___SearchAssistantEvents_DISPINTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_SearchAssistantOC;

#ifdef __cplusplus

class DECLSPEC_UUID("B45FF030-4447-11D2-85DE-00C04FA35C89")
SearchAssistantOC;
#endif
#endif /* __SHDocVw_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\fci.h ===
/*
 *  FCI.H -- File Compression Interface
 *
 *  Copyright (C) Microsoft Corporation 1993-1999
 *  All Rights Reserved.
 */

#ifndef INCLUDED_TYPES_FCI_FDI
#define INCLUDED_TYPES_FCI_FDI 1

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

#ifndef HUGE
#define HUGE
#endif

#ifndef FAR
#define FAR
#endif

#ifndef DIAMONDAPI
#define DIAMONDAPI __cdecl
#endif


//** Specify structure packing explicitly for clients of FCI

#ifndef _WIN64
#include <pshpack4.h>
#endif


//** Don't redefine types defined in Win16 WINDOWS.H (_INC_WINDOWS)
//   or Win32 WINDOWS.H (_WINDOWS_)
//
#if !defined(_INC_WINDOWS) && !defined(_WINDOWS_)
typedef int            BOOL;     /* f */
typedef unsigned char  BYTE;     /* b */
typedef unsigned int   UINT;     /* ui */
typedef unsigned short USHORT;   /* us */
typedef unsigned long  ULONG;    /* ul */
#endif   // _INC_WINDOWS

typedef unsigned long  CHECKSUM; /* csum */

typedef unsigned long  UOFF;     /* uoff - uncompressed offset */
typedef unsigned long  COFF;     /* coff - cabinet file offset */


#ifndef TRUE
#define TRUE    1
#endif

#ifndef FALSE
#define FALSE   0
#endif

#ifndef NULL
#define NULL    0
#endif


/***    ERF - Error structure
 *
 *  This structure returns error information from FCI/FDI.  The caller should
 *  not modify this structure.
 */
typedef struct {
    int     erfOper;            // FCI/FDI error code -- see FDIERROR_XXX
                                //  and FCIERR_XXX equates for details.

    int     erfType;            // Optional error value filled in by FCI/FDI.
                                // For FCI, this is usually the C run-time
                                // *errno* value.

    BOOL    fError;             // TRUE => error present
} ERF;      /* erf */
typedef ERF FAR *PERF;  /* perf */

#ifdef _DEBUG
// don't hide statics from map during debugging
#define STATIC      
#else // !DEBUG
#define STATIC static
#endif // !DEBUG

#define CB_MAX_CHUNK            32768U
#define CB_MAX_DISK        0x7fffffffL
#define CB_MAX_FILENAME            256
#define CB_MAX_CABINET_NAME        256
#define CB_MAX_CAB_PATH            256
#define CB_MAX_DISK_NAME           256

/***    tcompXXX - Compression types
 *
 *  These are passed to FCIAddFile(), and are also stored in the CFFOLDER
 *  structures in cabinet files.
 *
 *  NOTE: We reserve bits for the TYPE, QUANTUM_LEVEL, and QUANTUM_MEM
 *        to provide room for future expansion.  Since this value is stored
 *        in the CFDATA records in the cabinet file, we don't want to
 *        have to change the format for existing compression configurations
 *        if we add new ones in the future.  This will allows us to read
 *        old cabinet files in the future.
 */

typedef unsigned short TCOMP; /* tcomp */

#define tcompMASK_TYPE          0x000F  // Mask for compression type
#define tcompTYPE_NONE          0x0000  // No compression
#define tcompTYPE_MSZIP         0x0001  // MSZIP
#define tcompTYPE_QUANTUM       0x0002  // Quantum
#define tcompTYPE_LZX           0x0003  // LZX
#define tcompBAD                0x000F  // Unspecified compression type

#define tcompMASK_LZX_WINDOW    0x1F00  // Mask for LZX Compression Memory
#define tcompLZX_WINDOW_LO      0x0F00  // Lowest LZX Memory (15)
#define tcompLZX_WINDOW_HI      0x1500  // Highest LZX Memory (21)
#define tcompSHIFT_LZX_WINDOW        8  // Amount to shift over to get int

#define tcompMASK_QUANTUM_LEVEL 0x00F0  // Mask for Quantum Compression Level
#define tcompQUANTUM_LEVEL_LO   0x0010  // Lowest Quantum Level (1)
#define tcompQUANTUM_LEVEL_HI   0x0070  // Highest Quantum Level (7)
#define tcompSHIFT_QUANTUM_LEVEL     4  // Amount to shift over to get int

#define tcompMASK_QUANTUM_MEM   0x1F00  // Mask for Quantum Compression Memory
#define tcompQUANTUM_MEM_LO     0x0A00  // Lowest Quantum Memory (10)
#define tcompQUANTUM_MEM_HI     0x1500  // Highest Quantum Memory (21)
#define tcompSHIFT_QUANTUM_MEM       8  // Amount to shift over to get int

#define tcompMASK_RESERVED      0xE000  // Reserved bits (high 3 bits)



#define CompressionTypeFromTCOMP(tc) \
            ((tc) & tcompMASK_TYPE)

#define CompressionLevelFromTCOMP(tc) \
            (((tc) & tcompMASK_QUANTUM_LEVEL) >> tcompSHIFT_QUANTUM_LEVEL)

#define CompressionMemoryFromTCOMP(tc) \
            (((tc) & tcompMASK_QUANTUM_MEM) >> tcompSHIFT_QUANTUM_MEM)

#define TCOMPfromTypeLevelMemory(t,l,m)           \
            (((m) << tcompSHIFT_QUANTUM_MEM  ) |  \
             ((l) << tcompSHIFT_QUANTUM_LEVEL) |  \
             ( t                             ))

#define LZXCompressionWindowFromTCOMP(tc) \
            (((tc) & tcompMASK_LZX_WINDOW) >> tcompSHIFT_LZX_WINDOW)

#define TCOMPfromLZXWindow(w)      \
            (((w) << tcompSHIFT_LZX_WINDOW ) |  \
             ( tcompTYPE_LZX ))


//** Revert to default structure packing

#ifndef _WIN64
#include <poppack.h>
#endif

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#endif // !INCLUDED_TYPES_FCI_FDI

#ifndef INCLUDED_FCI
#define INCLUDED_FCI 1

#include <basetsd.h>

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

//** Specify structure packing explicitly for clients of FCI

#ifndef _WIN64
#include <pshpack4.h>
#endif


/***    FCIERROR - Error codes returned in erf.erfOper field
 *
 */
typedef enum {
FCIERR_NONE,                // No error

FCIERR_OPEN_SRC,            // Failure opening file to be stored in cabinet
                            //  erf.erfTyp has C run-time *errno* value

FCIERR_READ_SRC,            // Failure reading file to be stored in cabinet
                            //  erf.erfTyp has C run-time *errno* value

FCIERR_ALLOC_FAIL,          // Out of memory in FCI

FCIERR_TEMP_FILE,           // Could not create a temporary file
                            //  erf.erfTyp has C run-time *errno* value

FCIERR_BAD_COMPR_TYPE,      // Unknown compression type

FCIERR_CAB_FILE,            // Could not create cabinet file
                            //  erf.erfTyp has C run-time *errno* value

FCIERR_USER_ABORT,          // Client requested abort

FCIERR_MCI_FAIL,            // Failure compressing data

} FCIERROR;


/*
 * FAT file attribute flag used by FCI/FDI to indicate that
 * the filename in the CAB is a UTF string
 */
#ifndef _A_NAME_IS_UTF
#define _A_NAME_IS_UTF  0x80
#endif

/*
 * FAT file attribute flag used by FCI/FDI to indicate that
 * the file should be executed after extraction
 */
#ifndef _A_EXEC
#define _A_EXEC         0x40
#endif


/***    HFCI - Handle to an FCI Context
 *
 */
typedef void * HFCI;


/***    CCAB - Current Cabinet
 *
 *  This structure is used for passing in the cabinet parameters to FCI,
 *  and is passed back on certain FCI callbacks to provide cabinet
 *  information to the client.
 */
typedef struct {
// longs first
    ULONG  cb;                  // size available for cabinet on this media
    ULONG  cbFolderThresh;      // Thresshold for forcing a new Folder

// then ints
    UINT   cbReserveCFHeader;   // Space to reserve in CFHEADER
    UINT   cbReserveCFFolder;   // Space to reserve in CFFOLDER
    UINT   cbReserveCFData;     // Space to reserve in CFDATA
    int    iCab;                // sequential numbers for cabinets
    int    iDisk;               // Disk number
#ifndef REMOVE_CHICAGO_M6_HACK
    int    fFailOnIncompressible; // TRUE => Fail if a block is incompressible
#endif

//  then shorts
    USHORT setID;               // Cabinet set ID

// then chars
    char   szDisk[CB_MAX_DISK_NAME];    // current disk name
    char   szCab[CB_MAX_CABINET_NAME];  // current cabinet name
    char   szCabPath[CB_MAX_CAB_PATH];  // path for creating cabinet
} CCAB; /* ccab */
typedef CCAB *PCCAB; /* pccab */


/***    FNFCIALLOC - Memory Allocation
 *      FNFCIFREE  - Memory Free
 *
 *  These are modeled after the C run-time routines malloc() and free()
 *  FCI expects error handling to be identical to these C run-time routines.
 *
 *  As long as you faithfully copy the semantics of malloc() and free(),
 *  you can supply any functions you like!
 *
 *  WARNING: You should never assume anything about the sequence of
 *           FNFCIALLOC and FNFCIFREE calls -- incremental releases of
 *           FCI may have radically different numbers of
 *           FNFCIALLOC calls and allocation sizes!
 */
//** Memory functions for FCI
typedef void HUGE * (FAR DIAMONDAPI *PFNFCIALLOC)(ULONG cb); /* pfna */
#define FNFCIALLOC(fn) void HUGE * FAR DIAMONDAPI fn(ULONG cb)

typedef void (FAR DIAMONDAPI *PFNFCIFREE)(void HUGE *memory); /* pfnf */
#define FNFCIFREE(fn) void FAR DIAMONDAPI fn(void HUGE *memory)


/***    PFNFCIOPEN  - File I/O callbacks for FCI
 *      PFNFCIREAD
 *      PFNFCIWRITE
 *      PFNFCICLOSE
 *      PFNFCISEEK
 *
 *  These are modeled after the C run-time routines _open, _read,
 *  _write, _close, and _lseek.  The values for the PFNFCIOPEN oflag
 *  and pmode calls are those defined for _open.  FCI expects error
 *  handling to be identical to these C run-time routines, except that
 *  the value of errno should be returned via *err.
 *
 *  As long as you faithfully copy these aspects, you can supply
 *  any functions you like!
 *
 *  WARNING: You should never assume you know what file is being
 *           opened at any one point in time!  It is possible
 *           that in a future implementations it may open temporary
 *           files or cabinet files in a different order.
 */
//** File I/O functions for FCI
typedef INT_PTR (FAR DIAMONDAPI *PFNFCIOPEN) (char FAR *pszFile, int oflag, int pmode, int FAR *err, void FAR *pv);
typedef UINT (FAR DIAMONDAPI *PFNFCIREAD) (INT_PTR hf, void FAR *memory, UINT cb, int FAR *err, void FAR *pv);
typedef UINT (FAR DIAMONDAPI *PFNFCIWRITE)(INT_PTR hf, void FAR *memory, UINT cb, int FAR *err, void FAR *pv);
typedef int  (FAR DIAMONDAPI *PFNFCICLOSE)(INT_PTR hf, int FAR *err, void FAR *pv);
typedef long (FAR DIAMONDAPI *PFNFCISEEK) (INT_PTR hf, long dist, int seektype, int FAR *err, void FAR *pv);
typedef int  (FAR DIAMONDAPI *PFNFCIDELETE) (char FAR *pszFile, int FAR *err, void FAR *pv);

#define FNFCIOPEN(fn) INT_PTR FAR DIAMONDAPI fn(char FAR *pszFile, int oflag, int pmode, int FAR *err, void FAR *pv)
#define FNFCIREAD(fn) UINT FAR DIAMONDAPI fn(INT_PTR hf, void FAR *memory, UINT cb, int FAR *err, void FAR *pv)
#define FNFCIWRITE(fn) UINT FAR DIAMONDAPI fn(INT_PTR hf, void FAR *memory, UINT cb, int FAR *err, void FAR *pv)
#define FNFCICLOSE(fn) int FAR DIAMONDAPI fn(INT_PTR hf, int FAR *err, void FAR *pv)
#define FNFCISEEK(fn) long FAR DIAMONDAPI fn(INT_PTR hf, long dist, int seektype, int FAR *err, void FAR *pv)
#define FNFCIDELETE(fn) int FAR DIAMONDAPI fn(char FAR *pszFile, int FAR *err, void FAR *pv)


/***    FNFCIGETNEXTCABINET - Callback used to request new cabinet info
 *
 *  Entry:
 *      pccab     - Points to copy of old ccab structure to modify
 *      cbPrevCab - Estimate of size of previous cabinet
 *      pv        - Has the caller's context pointer
 *
 *  Exit-Success:
 *      returns TRUE;
 *
 *  Exit-Failure:
 *      returns FALSE;
 */
typedef BOOL (DIAMONDAPI *PFNFCIGETNEXTCABINET)(PCCAB  pccab,
                                                ULONG  cbPrevCab,
                                                void FAR *pv); /* pfnfcignc */

#define FNFCIGETNEXTCABINET(fn) BOOL DIAMONDAPI fn(PCCAB  pccab,     \
                                                   ULONG  cbPrevCab, \
                                                   void FAR *pv)


/***    FNFCIFILEPLACED - Notify FCI client that file was placed
 *
 *  Entry:
 *      pccab         - cabinet structure to fill in, with copy of previous one
 *      pszFile       - name of file, from cabinet
 *      cbFile        - length of file
 *      fContinuation - true if this is a later segment of a continued file
 *      pv            - the context of the client
 *
 *  Exit-Success:
 *      return value anything but -1
 *
 *  Exit-Failure:
 *      return value -1 means to abort
 */
typedef int (DIAMONDAPI *PFNFCIFILEPLACED)(PCCAB pccab,
                                           char *pszFile,
                                           long  cbFile,
                                           BOOL  fContinuation,
                                           void FAR *pv); /* pfnfcifp */

#define FNFCIFILEPLACED(fn) int DIAMONDAPI fn(PCCAB pccab,         \
                                              char *pszFile,       \
                                              long  cbFile,        \
                                              BOOL  fContinuation, \
                                              void FAR *pv)


/***    FNCDIGETOPENINFO - Open source file, get date/time/attribs
 *
 *  Entry:
 *      pszName  -- complete path to filename
 *      pdate    -- location to return FAT-style date code
 *      ptime    -- location to return FAT-style time code
 *      pattribs -- location to return FAT-style attributes
 *      pv       -- client's context
 *
 *  Exit-Success:
 *      Return value is file handle of open file to read
 *
 *  Exit-Failure:
 *      Return value is -1
 */
typedef INT_PTR (DIAMONDAPI *PFNFCIGETOPENINFO)(char   *pszName,
                                                USHORT *pdate,
                                                USHORT *ptime,
                                                USHORT *pattribs,
                                                int FAR *err,
                                                void FAR *pv); /* pfnfcigoi */

#define FNFCIGETOPENINFO(fn) INT_PTR DIAMONDAPI fn(char   *pszName,  \
                                                   USHORT *pdate,    \
                                                   USHORT *ptime,    \
                                                   USHORT *pattribs, \
                                                   int FAR *err, \
                                                   void FAR *pv)
                            
/***    FNFCISTATUS - Status/Cabinet Size callback
 *
 *  Entry:
 *      typeStatus == statusFile if compressing a block into a folder
 *                      cb1 = Size of compressed block
 *                      cb2 = Size of uncompressed block
 *
 *      typeStatus == statusFolder if adding a folder to a cabinet
 *                      cb1 = Amount of folder copied to cabinet so far
 *                      cb2 = Total size of folder
 *
 *      typeStatus == statusCabinet if writing out a complete cabinet
 *                      cb1 = Estimated cabinet size that was previously
 *                              passed to fnfciGetNextCabinet().
 *                      cb2 = Actual cabinet size
 *                    NOTE: Return value is desired client size for cabinet
 *                          file.  FCI updates the maximum cabinet size
 *                          remaining using this value.  This allows a client
 *                          to generate multiple cabinets per disk, and have
 *                          FCI limit the size correctly -- the client can do
 *                          cluster size rounding on the cabinet size!
 *                          The client should either return cb2, or round cb2
 *                          up to some larger value and return that.
 *  Exit-Success:
 *      Returns anything other than -1;
 *      NOTE: See statusCabinet for special return values!
 *
 *  Exit-Failure:
 *      Returns -1 to signal that FCI should abort;
 */

#define statusFile      0   // Add File to Folder callback
#define statusFolder    1   // Add Folder to Cabinet callback
#define statusCabinet   2   // Write out a completed cabinet callback

typedef long (DIAMONDAPI *PFNFCISTATUS)(UINT   typeStatus,
                                        ULONG  cb1,
                                        ULONG  cb2,
                                        void FAR *pv); /* pfnfcis */

#define FNFCISTATUS(fn) long DIAMONDAPI fn(UINT   typeStatus, \
                                           ULONG  cb1,        \
                                           ULONG  cb2,        \
                                           void FAR *pv)


/***    FNFCIGETTEMPFILE - Callback, requests temporary file name
 *
 *  Entry:
 *      pszTempName - Buffer to receive complete tempfile name
 *      cbTempName  - Size of pszTempName buffer
 *
 *  Exit-Success:
 *      return TRUE
 *
 *  Exit-Failure:
 *      return FALSE; could not create tempfile, or buffer too small
 *
 *  Note:
 *      It is conceivable that this function may return a filename
 *      that will already exist by the time it is opened.  For this
 *      reason, the caller should make several attempts to create
 *      temporary files before giving up.
 */
typedef BOOL (DIAMONDAPI *PFNFCIGETTEMPFILE)(char *pszTempName,
                                             int   cbTempName,
                                             void FAR *pv); /* pfnfcigtf */

#define FNFCIGETTEMPFILE(fn) BOOL DIAMONDAPI fn(char *pszTempName, \
                                                int   cbTempName, \
                                                void FAR *pv)


/***    FCICreate -- create an FCI context (an open CAB, an open FOL)
 *
 *  Entry:
 *      perf      - structure where we return error codes
 *      pfnfcifp  - callback to inform caller of eventual dest of files
 *      pfna      - memory allocation function callback
 *      pfnf      - memory free function callback
 *      pfnfcigtf - temp file name generator callback
 *      pccab     - pointer to cabinet/disk name & size structure
 *
 *  Notes:
 *  (1) The alloc/free callbacks must remain valid throughout
 *      the life of the context, up to and including the call to
 *      FCIDestroy.
 *  (2) The perf pointer is stored in the compression context (HCI),
 *      and any errors from subsequent FCI calls are stored in the
 *      erf that was passed in on *this* call.
 *
 *  Exit-Success:
 *      Returns non-NULL handle to an FCI context.
 *
 *  Exit-Failure:
 *      Returns NULL, perf filled in.
 */
HFCI DIAMONDAPI FCICreate(PERF              perf,
                          PFNFCIFILEPLACED  pfnfcifp,
                          PFNFCIALLOC       pfna,
                          PFNFCIFREE        pfnf,
                          PFNFCIOPEN        pfnopen,
                          PFNFCIREAD        pfnread,
                          PFNFCIWRITE       pfnwrite,
                          PFNFCICLOSE       pfnclose,
                          PFNFCISEEK        pfnseek,
                          PFNFCIDELETE      pfndelete,
                          PFNFCIGETTEMPFILE pfnfcigtf,
                          PCCAB             pccab,
                          void FAR *        pv
                         );


/***   FCIAddFile - Add a disk file to a folder/cabinet
 *
 *  Entry:
 *      hfci          - FCI context handle
 *      pszSourceFile - Name of file to add to folder
 *      pszFileName   - Name to store into folder/cabinet
 *      fExecute      - Flag indicating execute on extract
 *      pfn_progress  - Progress callback
 *      pfnfcignc     - GetNextCabinet callback
 *      pfnfcis       - Status callback
 *      pfnfcigoi     - OpenInfo callback
 *      typeCompress  - Type of compression to use for this file
 *      pv            - pointer to caller's internal context
 *
 *  Exit-Success:
 *      returns TRUE
 *
 *  Exit-Failure:
 *      returns FALSE, error filled in
 *    
 *    This is the main function used to add file(s) to a cabinet
 *    or series of cabinets.  If the current file causes the current
 *    folder/cabinet to overflow the disk image currently being built,
 *    the cabinet will be terminated, and a new cabinet/disk name will
 *    be prompted for via a callback.  The pending folder will be trimmed
 *    of the data which has already been generated in the finished cabinet.
 */
BOOL DIAMONDAPI FCIAddFile(HFCI                  hfci,
                           char                 *pszSourceFile,
                           char                 *pszFileName,
                           BOOL                  fExecute,
                           PFNFCIGETNEXTCABINET  pfnfcignc,
                           PFNFCISTATUS          pfnfcis,
                           PFNFCIGETOPENINFO     pfnfcigoi,
                           TCOMP                 typeCompress
                          );
            

/***   FCIFlushCabinet - Complete the current cabinet under construction
 *
 *  This will cause the current cabinet (assuming it is not empty) to
 *  be gathered together and written to disk.
 *
 *  Entry:
 *      hfci        - FCI context
 *      fGetNextCab - TRUE  => Call GetNextCab to get continuation info;
 *                    FALSE => Don't call GetNextCab unless this cabinet
 *                             overflows.
 *      pfnfcignc   - callback function to get continuation cabinets
 *      pfnfcis     - callback function for progress reporting
 *      pv          - caller's internal context for callbacks
 *
 *  Exit-Success:
 *      return code TRUE
 *
 *  Exit-Failure:
 *      return code FALSE, error structure filled in
 */
BOOL DIAMONDAPI FCIFlushCabinet(HFCI                  hfci,
                                BOOL                  fGetNextCab,
                                PFNFCIGETNEXTCABINET  pfnfcignc,
                                PFNFCISTATUS          pfnfcis
                               );

                                                                  
/***   FCIFlushFolder - Complete the current folder under construction
 *
 *  This will force the termination of the current folder, which may or
 *  may not cause one or more cabinet files to be completed.
 *
 *  Entry:
 *      hfci        - FCI context
 *      GetNextCab  - callback function to get continuation cabinets
 *      pfnProgress - callback function for progress reporting
 *      pv          - caller's internal context for callbacks
 *
 *  Exit-Success:
 *      return code TRUE
 *
 *  Exit-Failure:
 *      return code FALSE, error structure filled in
 */
BOOL DIAMONDAPI FCIFlushFolder(HFCI                  hfci,
                               PFNFCIGETNEXTCABINET  pfnfcignc,
                               PFNFCISTATUS          pfnfcis
                              );

                                                                  
/***   FCIDestroy - Destroy a FCI context and delete temp files
 *
 *  Entry:
 *      hfci - FCI context
 *
 *  Exit-Success:
 *      return code TRUE
 *
 *  Exit-Failure:
 *      return code FALSE, error structure filled in
 */
BOOL DIAMONDAPI FCIDestroy (HFCI hfci);
                                                                  
//** Revert to default structure packing

#ifndef _WIN64
#include <poppack.h>
#endif

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#endif // !INCLUDED_FCI
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\faxdev.h ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    faxdev.h

Abstract:

    This file contains the prototypes, etc for the
    FAX device provider API.

--*/

#include <commctrl.h>

#ifndef _FAXDEV_
#define _FAXDEV_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// FAX status constants
//

#define FS_INITIALIZING         0x20000000
#define FS_DIALING              0x20000001
#define FS_TRANSMITTING         0x20000002
#define FS_RECEIVING            0x20000004
#define FS_COMPLETED            0x20000008
#define FS_HANDLED              0x20000010
#define FS_LINE_UNAVAILABLE     0x20000020
#define FS_BUSY                 0x20000040
#define FS_NO_ANSWER            0x20000080
#define FS_BAD_ADDRESS          0x20000100
#define FS_NO_DIAL_TONE         0x20000200
#define FS_DISCONNECTED         0x20000400
#define FS_FATAL_ERROR          0x20000800  // see the stringid for the real status
#define FS_NOT_FAX_CALL         0x20001000
#define FS_CALL_DELAYED         0x20002000
#define FS_CALL_BLACKLISTED     0x20004000
#define FS_USER_ABORT           0x20200000
#define FS_ANSWERED             0x20800000


//
// data structures
//

typedef struct _FAX_SEND {
    DWORD   SizeOfStruct;
    LPWSTR  FileName;
    LPWSTR  CallerName;
    LPWSTR  CallerNumber;
    LPWSTR  ReceiverName;
    LPWSTR  ReceiverNumber;
    BOOL    Branding;
    HCALL   CallHandle;
    DWORD   Reserved[3];
} FAX_SEND, *PFAX_SEND;

typedef struct _FAX_RECEIVE {
    DWORD   SizeOfStruct;
    LPWSTR  FileName;
    LPWSTR  ReceiverName;
    LPWSTR  ReceiverNumber;
    DWORD   Reserved[4];
} FAX_RECEIVE, *PFAX_RECEIVE;

typedef struct _FAX_DEV_STATUS {
    DWORD   SizeOfStruct;
    DWORD   StatusId;
    DWORD   StringId;
    DWORD   PageCount;
    LPWSTR  CSI;
    LPWSTR  CallerId;
    LPWSTR  RoutingInfo;
    DWORD   ErrorCode;
    DWORD   Reserved[3];
} FAX_DEV_STATUS, *PFAX_DEV_STATUS;


typedef BOOL
(CALLBACK *PFAX_SERVICE_CALLBACK)(
    IN HANDLE FaxHandle,
    IN DWORD  DeviceId,
    IN DWORD_PTR  Param1,
    IN DWORD_PTR  Param2,
    IN DWORD_PTR  Param3
    );

typedef void
(CALLBACK *PFAX_LINECALLBACK)(
    IN HANDLE FaxHandle,
    IN DWORD hDevice,
    IN DWORD dwMessage,
    IN DWORD_PTR dwInstance,
    IN DWORD_PTR dwParam1,
    IN DWORD_PTR dwParam2,
    IN DWORD_PTR dwParam3
    );



BOOL WINAPI
FaxDevInitialize(
    IN  HLINEAPP LineAppHandle,
    IN  HANDLE HeapHandle,
    OUT PFAX_LINECALLBACK *LineCallbackFunction,
    IN  PFAX_SERVICE_CALLBACK FaxServiceCallback
    );

BOOL WINAPI
FaxDevVirtualDeviceCreation(
    OUT LPDWORD DeviceCount,
    OUT LPWSTR DeviceNamePrefix,
    OUT LPDWORD DeviceIdPrefix,
    IN  HANDLE CompletionPort,
    IN  ULONG_PTR CompletionKey
    );

BOOL WINAPI
FaxDevStartJob(
    IN  HLINE LineHandle,
    IN  DWORD DeviceId,
    OUT PHANDLE FaxHandle,
    IN  HANDLE CompletionPortHandle,
    IN  ULONG_PTR CompletionKey
    );

BOOL WINAPI
FaxDevEndJob(
    IN  HANDLE FaxHandle
    );

typedef BOOL
(CALLBACK *PFAX_SEND_CALLBACK)(
    IN HANDLE FaxHandle,
    IN HCALL CallHandle,
    IN DWORD Reserved1,
    IN DWORD Reserved2
    );

BOOL WINAPI
FaxDevSend(
    IN  HANDLE FaxHandle,
    IN  PFAX_SEND FaxSend,
    IN  PFAX_SEND_CALLBACK FaxSendCallback
    );

#define FAXDEVRECEIVE_SIZE 4096

BOOL WINAPI
FaxDevReceive(
    IN  HANDLE FaxHandle,
    IN  HCALL CallHandle,
    IN OUT PFAX_RECEIVE FaxReceive
    );

#define FAXDEVREPORTSTATUS_SIZE 4096

BOOL WINAPI
FaxDevReportStatus(
    IN  HANDLE FaxHandle OPTIONAL,
    OUT PFAX_DEV_STATUS FaxStatus,
    IN  DWORD FaxStatusSize,
    OUT LPDWORD FaxStatusSizeRequired
    );

BOOL WINAPI
FaxDevAbortOperation(
    IN  HANDLE FaxHandle
    );

BOOL WINAPI
FaxDevConfigure(
    OUT HPROPSHEETPAGE *PropSheetPage
    );


typedef BOOL (WINAPI *PFAXDEVINITIALIZE)                (HLINEAPP,HANDLE,PFAX_LINECALLBACK*,PFAX_SERVICE_CALLBACK);
typedef BOOL (WINAPI *PFAXDEVVIRTUALDEVICECREATION)     (LPDWORD,LPWSTR,LPDWORD,HANDLE,ULONG_PTR);
typedef BOOL (WINAPI *PFAXDEVSTARTJOB)                  (HLINE,DWORD,PHANDLE,HANDLE,ULONG_PTR);
typedef BOOL (WINAPI *PFAXDEVENDJOB)                    (HANDLE);
typedef BOOL (WINAPI *PFAXDEVSEND)                      (HANDLE,PFAX_SEND,PFAX_SEND_CALLBACK);
typedef BOOL (WINAPI *PFAXDEVRECEIVE)                   (HANDLE,HCALL,PFAX_RECEIVE);
typedef BOOL (WINAPI *PFAXDEVREPORTSTATUS)              (HANDLE,PFAX_DEV_STATUS,DWORD,LPDWORD);
typedef BOOL (WINAPI *PFAXDEVABORTOPERATION)            (HANDLE);
typedef BOOL (WINAPI *PFAXDEVCONFIGURE)                 (HPROPSHEETPAGE*);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\fcntl.h ===
/***
*fcntl.h - file control options used by open()
*
*       Copyright (c) 1985-1997, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines constants for the file control options used
*       by the _open() function.
*       [System V]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_FCNTL
#define _INC_FCNTL

#if     !defined(_WIN32) && !defined(_MAC)
#error ERROR: Only Mac or Win32 targets supported!
#endif


#define _O_RDONLY       0x0000  /* open for reading only */
#define _O_WRONLY       0x0001  /* open for writing only */
#define _O_RDWR         0x0002  /* open for reading and writing */
#define _O_APPEND       0x0008  /* writes done at eof */

#define _O_CREAT        0x0100  /* create and open file */
#define _O_TRUNC        0x0200  /* open and truncate */
#define _O_EXCL         0x0400  /* open only if file doesn't already exist */

/* O_TEXT files have <cr><lf> sequences translated to <lf> on read()'s,
** and <lf> sequences translated to <cr><lf> on write()'s
*/

#define _O_TEXT         0x4000  /* file mode is text (translated) */
#define _O_BINARY       0x8000  /* file mode is binary (untranslated) */

/* macro to translate the C 2.0 name used to force binary mode for files */

#define _O_RAW  _O_BINARY

/* Open handle inherit bit */

#define _O_NOINHERIT    0x0080  /* child process doesn't inherit file */

/* Temporary file bit - file is deleted when last handle is closed */

#define _O_TEMPORARY    0x0040  /* temporary file bit */

/* temporary access hint */

#define _O_SHORT_LIVED  0x1000  /* temporary storage file, try not to flush */

/* sequential/random access hints */

#define _O_SEQUENTIAL   0x0020  /* file access is primarily sequential */
#define _O_RANDOM       0x0010  /* file access is primarily random */

#if     !__STDC__ || defined(_POSIX_)
/* Non-ANSI names for compatibility */
#define O_RDONLY        _O_RDONLY
#define O_WRONLY        _O_WRONLY
#define O_RDWR          _O_RDWR
#define O_APPEND        _O_APPEND
#define O_CREAT         _O_CREAT
#define O_TRUNC         _O_TRUNC
#define O_EXCL          _O_EXCL
#define O_TEXT          _O_TEXT
#define O_BINARY        _O_BINARY
#define O_RAW           _O_BINARY
#define O_TEMPORARY     _O_TEMPORARY
#define O_NOINHERIT     _O_NOINHERIT
#define O_SEQUENTIAL    _O_SEQUENTIAL
#define O_RANDOM        _O_RANDOM
#endif  /* __STDC__ */

#endif  /* _INC_FCNTL */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\faxroute.h ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    faxroute.h

Abstract:

    This file contains the prototypes, etc for the
    FAX routing extension API.


--*/

#include <commctrl.h>

#ifndef _FAXROUTE_
#define _FAXROUTE_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif


//
// microsoft routing guids
//

#define MS_FAXROUTE_PRINTING_GUID               TEXT("{aec1b37c-9af2-11d0-abf7-00c04fd91a4e}")
#define MS_FAXROUTE_INBOX_GUID                  TEXT("{9d3d0c32-9af2-11d0-abf7-00c04fd91a4e}")
#define MS_FAXROUTE_FOLDER_GUID                 TEXT("{92041a90-9af2-11d0-abf7-00c04fd91a4e}")
#define MS_FAXROUTE_EMAIL_GUID                  TEXT("{6bbf7bfe-9af2-11d0-abf7-00c04fd91a4e}")

//
// callback routines
//

typedef LONG (WINAPI *PFAXROUTEADDFILE)(IN DWORD JobId,IN LPCWSTR FileName,IN GUID *Guid);
typedef LONG (WINAPI *PFAXROUTEDELETEFILE)(IN DWORD JobId,IN LPCWSTR FileName);
typedef BOOL (WINAPI *PFAXROUTEGETFILE)(IN DWORD JobId,IN DWORD Index,OUT LPWSTR FileNameBuffer,OUT LPDWORD RequiredSize);
typedef BOOL (WINAPI *PFAXROUTEENUMFILE)(IN DWORD JobId,IN GUID *GuidOwner,IN GUID *GuidCaller,IN LPCWSTR FileName,IN OUT PVOID Context);
typedef BOOL (WINAPI *PFAXROUTEENUMFILES)(IN DWORD JobId,IN GUID *Guid,IN PFAXROUTEENUMFILE FileEnumerator,IN OUT PVOID Context);
typedef BOOL (WINAPI *PFAXROUTEMODIFYROUTINGDATA)(IN DWORD JobId,IN LPCWSTR RoutingGuid,IN LPBYTE RoutingData,IN DWORD RoutingDataSize );


typedef struct _FAX_ROUTE_CALLBACKROUTINES {
    DWORD                       SizeOfStruct;                // size of the struct set by the fax service
    PFAXROUTEADDFILE            FaxRouteAddFile;
    PFAXROUTEDELETEFILE         FaxRouteDeleteFile;
    PFAXROUTEGETFILE            FaxRouteGetFile;
    PFAXROUTEENUMFILES          FaxRouteEnumFiles;
    PFAXROUTEMODIFYROUTINGDATA  FaxRouteModifyRoutingData;
} FAX_ROUTE_CALLBACKROUTINES, *PFAX_ROUTE_CALLBACKROUTINES;


//
// routing data structure
//

typedef struct _FAX_ROUTE {
    DWORD           SizeOfStruct;       // size of the struct set by the fax service
    DWORD           JobId;              // Fax job identifier
    DWORDLONG       ElapsedTime;        // Elapsed time for whole fax job in Coordinated Universal Time (UTC)
    DWORDLONG       ReceiveTime;        // Starting time for fax job in Coordinated Universal Time (UTC)
    DWORD           PageCount;          // Number of pages received
    LPCWSTR         Csid;               // Called station identifier
    LPCWSTR         Tsid;               // Transmitting station identifier
    LPCWSTR         CallerId;           // Caller id
    LPCWSTR         RoutingInfo;        // Routing info such as DID, T.30-subaddress, etc.
    LPCWSTR         ReceiverName;       // Receiver's name
    LPCWSTR         ReceiverNumber;     // Receiver's fax number
    LPCWSTR         DeviceName;         // Device name for the line that received the fax
    DWORD           DeviceId;           // Permenant line identifier for the receiving device
    LPBYTE          RoutingInfoData;    // Routing infor data to override configured info
    DWORD           RoutingInfoDataSize;// Size of routing info data
} FAX_ROUTE, *PFAX_ROUTE;

enum FAXROUTE_ENABLE {
    QUERY_STATUS = -1,
    STATUS_DISABLE = 0,
    STATUS_ENABLE = 1
};


//
// prototypes
//

BOOL WINAPI
FaxRouteInitialize(
    IN HANDLE HeapHandle,
    IN PFAX_ROUTE_CALLBACKROUTINES FaxRouteCallbackRoutines
    );

BOOL WINAPI
FaxRouteDeviceEnable(
    IN  LPCWSTR RoutingGuid,
    IN  DWORD DeviceId,
    IN  LONG Enabled
    );

BOOL WINAPI
FaxRouteDeviceChangeNotification(
    IN  DWORD DeviceId,
    IN  BOOL  NewDevice
    );

BOOL WINAPI
FaxRouteGetRoutingInfo(
    IN  LPCWSTR RoutingGuid,
    IN  DWORD DeviceId,
    IN  LPBYTE RoutingInfo,
    OUT LPDWORD RoutingInfoSize
    );

BOOL WINAPI
FaxRouteSetRoutingInfo(
    IN  LPCWSTR RoutingGuid,
    IN  DWORD DeviceId,
    IN  const BYTE *RoutingInfo,
    IN  DWORD RoutingInfoSize
    );


typedef BOOL (WINAPI *PFAXROUTEINITIALIZE)               (IN HANDLE,IN PFAX_ROUTE_CALLBACKROUTINES);
typedef BOOL (WINAPI *PFAXROUTEMETHOD)                   (IN const FAX_ROUTE*,OUT PVOID*,OUT LPDWORD);
typedef BOOL (WINAPI *PFAXROUTEDEVICEENABLE)             (IN LPCWSTR,IN DWORD,IN LONG);
typedef BOOL (WINAPI *PFAXROUTEDEVICECHANGENOTIFICATION) (IN DWORD,IN BOOL);
typedef BOOL (WINAPI *PFAXROUTEGETROUTINGINFO)           (IN LPCWSTR,IN DWORD,OUT LPBYTE,OUT LPDWORD);
typedef BOOL (WINAPI *PFAXROUTESETROUTINGINFO)           (IN LPCWSTR,IN DWORD,IN const BYTE*,IN DWORD);



#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\fdi.h ===
/*
 *  FDI.H -- File Decompression Interface
 *
 *  Copyright (C) Microsoft Corporation 1993-1999
 *  All Rights Reserved.
 */

#ifndef INCLUDED_TYPES_FCI_FDI
#define INCLUDED_TYPES_FCI_FDI 1

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

#ifndef HUGE
#define HUGE
#endif

#ifndef FAR
#define FAR
#endif

#ifndef DIAMONDAPI
#define DIAMONDAPI __cdecl
#endif


//** Specify structure packing explicitly for clients of FDI

#ifndef _WIN64
#include <pshpack4.h>
#endif


//** Don't redefine types defined in Win16 WINDOWS.H (_INC_WINDOWS)
//   or Win32 WINDOWS.H (_WINDOWS_)
//
#if !defined(_INC_WINDOWS) && !defined(_WINDOWS_)
typedef int            BOOL;     /* f */
typedef unsigned char  BYTE;     /* b */
typedef unsigned int   UINT;     /* ui */
typedef unsigned short USHORT;   /* us */
typedef unsigned long  ULONG;    /* ul */
#endif   // _INC_WINDOWS

typedef unsigned long  CHECKSUM; /* csum */

typedef unsigned long  UOFF;     /* uoff - uncompressed offset */
typedef unsigned long  COFF;     /* coff - cabinet file offset */


#ifndef TRUE
#define TRUE    1
#endif

#ifndef FALSE
#define FALSE   0
#endif

#ifndef NULL
#define NULL    0
#endif


/***    ERF - Error structure
 *
 *  This structure returns error information from FCI/FDI.  The caller should
 *  not modify this structure.
 */
typedef struct {
    int     erfOper;            // FCI/FDI error code -- see FDIERROR_XXX
                                //  and FCIERR_XXX equates for details.

    int     erfType;            // Optional error value filled in by FCI/FDI.
                                // For FCI, this is usually the C run-time
                                // *errno* value.

    BOOL    fError;             // TRUE => error present
} ERF;      /* erf */
typedef ERF FAR *PERF;  /* perf */

#ifdef _DEBUG
// don't hide statics from map during debugging
#define STATIC      
#else // !DEBUG
#define STATIC static
#endif // !DEBUG

#define CB_MAX_CHUNK            32768U
#define CB_MAX_DISK        0x7fffffffL
#define CB_MAX_FILENAME            256
#define CB_MAX_CABINET_NAME        256
#define CB_MAX_CAB_PATH            256
#define CB_MAX_DISK_NAME           256

/***    tcompXXX - Compression types
 *
 *  These are passed to FCIAddFile(), and are also stored in the CFFOLDER
 *  structures in cabinet files.
 *
 *  NOTE: We reserve bits for the TYPE, QUANTUM_LEVEL, and QUANTUM_MEM
 *        to provide room for future expansion.  Since this value is stored
 *        in the CFDATA records in the cabinet file, we don't want to
 *        have to change the format for existing compression configurations
 *        if we add new ones in the future.  This will allows us to read
 *        old cabinet files in the future.
 */

typedef unsigned short TCOMP; /* tcomp */

#define tcompMASK_TYPE          0x000F  // Mask for compression type
#define tcompTYPE_NONE          0x0000  // No compression
#define tcompTYPE_MSZIP         0x0001  // MSZIP
#define tcompTYPE_QUANTUM       0x0002  // Quantum
#define tcompTYPE_LZX           0x0003  // LZX
#define tcompBAD                0x000F  // Unspecified compression type

#define tcompMASK_LZX_WINDOW    0x1F00  // Mask for LZX Compression Memory
#define tcompLZX_WINDOW_LO      0x0F00  // Lowest LZX Memory (15)
#define tcompLZX_WINDOW_HI      0x1500  // Highest LZX Memory (21)
#define tcompSHIFT_LZX_WINDOW        8  // Amount to shift over to get int

#define tcompMASK_QUANTUM_LEVEL 0x00F0  // Mask for Quantum Compression Level
#define tcompQUANTUM_LEVEL_LO   0x0010  // Lowest Quantum Level (1)
#define tcompQUANTUM_LEVEL_HI   0x0070  // Highest Quantum Level (7)
#define tcompSHIFT_QUANTUM_LEVEL     4  // Amount to shift over to get int

#define tcompMASK_QUANTUM_MEM   0x1F00  // Mask for Quantum Compression Memory
#define tcompQUANTUM_MEM_LO     0x0A00  // Lowest Quantum Memory (10)
#define tcompQUANTUM_MEM_HI     0x1500  // Highest Quantum Memory (21)
#define tcompSHIFT_QUANTUM_MEM       8  // Amount to shift over to get int

#define tcompMASK_RESERVED      0xE000  // Reserved bits (high 3 bits)



#define CompressionTypeFromTCOMP(tc) \
            ((tc) & tcompMASK_TYPE)

#define CompressionLevelFromTCOMP(tc) \
            (((tc) & tcompMASK_QUANTUM_LEVEL) >> tcompSHIFT_QUANTUM_LEVEL)

#define CompressionMemoryFromTCOMP(tc) \
            (((tc) & tcompMASK_QUANTUM_MEM) >> tcompSHIFT_QUANTUM_MEM)

#define TCOMPfromTypeLevelMemory(t,l,m)           \
            (((m) << tcompSHIFT_QUANTUM_MEM  ) |  \
             ((l) << tcompSHIFT_QUANTUM_LEVEL) |  \
             ( t                             ))

#define LZXCompressionWindowFromTCOMP(tc) \
            (((tc) & tcompMASK_LZX_WINDOW) >> tcompSHIFT_LZX_WINDOW)

#define TCOMPfromLZXWindow(w)      \
            (((w) << tcompSHIFT_LZX_WINDOW ) |  \
             ( tcompTYPE_LZX ))


//** Revert to default structure packing

#ifndef _WIN64
#include <poppack.h>
#endif

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#endif // !INCLUDED_TYPES_FCI_FDI

/*
 *  Concepts:
 *      A *cabinet* file contains one or more *folders*.  A folder contains
 *      one or more (pieces of) *files*.  A folder is by definition a
 *      decompression unit, i.e., to extract a file from a folder, all of
 *      the data from the start of the folder up through and including the
 *      desired file must be read and decompressed.
 *
 *      A folder can span one (or more) cabinet boundaries, and by implication
 *      a file can also span one (or more) cabinet boundaries.  Indeed, more
 *      than one file can span a cabinet boundary, since FCI concatenates
 *      files together into a single data stream before compressing (actually,
 *      at most one file will span any one cabinet boundary, but FCI does
 *      not know which file this is, since the mapping from uncompressed bytes
 *      to compressed bytes is pretty obscure.  Also, since FCI compresses
 *      in blocks of 32K (at present), any files with data in a 32K block that
 *      spans a cabinet boundary require FDI to read both cabinet files
 *      to get the two halves of the compressed block).
 *
 *  Overview:
 *      The File Decompression Interface is used to simplify the reading of
 *      cabinet files.  A setup program will proceed in a manner very
 *      similar to the pseudo code below.  An FDI context is created, the
 *      setup program calls FDICopy() for each cabinet to be processed.  For
 *      each file in the cabinet, FDICopy() calls a notification callback
 *      routine, asking the setup program if the file should be copied.
 *      This call-back approach is great because it allows the cabinet file
 *      to be read and decompressed in an optimal manner, and also makes FDI
 *      independent of the run-time environment -- FDI makes *no* C run-time
 *      calls whatsoever.  All memory allocation and file I/O functions are
 *      passed into FDI by the client.
 *
 *      main(...)
 *      {
 *          // Read INF file to construct list of desired files.   
 *          //  Ideally, these would be sorted in the same order as the
 *          //  files appear in the cabinets, so that you can just walk
 *          //  down the list in response to fdintCOPY_FILE notifications.
 *
 *          // Construct list of required cabinets. 
 *
 *          hfdi = FDICreate(...);          // Create FDI context
 *          For (cabinet in List of Cabinets) {
 *              FDICopy(hfdi,cabinet,fdiNotify,...);  // Process each cabinet
 *          }
 *          FDIDestroy(hfdi);
 *          ...
 *      }
 *
 *      // Notification callback function 
 *      fdiNotify(fdint,...)
 *      {
 *          If (User Aborted)               // Permit cancellation
 *              if (fdint == fdintCLOSE_FILE_INFO)
 *                  close open file
 *              return -1;
 *          switch (fdint) {
 *              case fdintCOPY_FILE:        // File to copy, maybe
 *                  // Check file against list of desired files 
 *                  if want to copy file
 *                      open destination file and return handle
 *                  else
 *                      return NULL;        // Skip file
 *              case fdintCLOSE_FILE_INFO:
 *                  close file
 *                  set date, time, and attributes
 *
 *              case fdintNEXT_CABINET:
 *                  if not an error callback
 *                      Tell FDI to use suggested directory name
 *                  else
 *                      Tell user what the problem was, and prompt
 *                          for a new disk and/or path.
 *                      if user aborts
 *                          Tell FDI to abort
 *                      else
 *                          return to FDI to try another cabinet
 *
 *              default:
 *                  return 0;               // more messages may be defined
 *              ...
 *      }
 *
 *  Error Handling Suggestions:
 *      Since you the client have passed in *all* of the functions that
 *      FDI uses to interact with the "outside" world, you are in prime
 *      position to understand and deal with errors.
 *
 *      The general philosophy of FDI is to pass all errors back up to
 *      the client.  FDI returns fairly generic error codes in the case
 *      where one of the callback functions (PFNOPEN, PFNREAD, etc.) fail,
 *      since it assumes that the callback function will save enough
 *      information in a static/global so that when FDICopy() returns
 *      fail, the client can examine this information and report enough
 *      detail about the problem that the user can take corrective action.
 *
 *      For very specific errors (CORRUPT_CABINET, for example), FDI returns
 *      very specific error codes.
 *
 *      THE BEST POLICY IS FOR YOUR CALLBACK ROUTINES TO AVOID RETURNING
 *      ERRORS TO FDI!
 *
 *      Examples:
 *          (1) If the disk is getting full, instead of returning an error
 *              from your PFNWRITE function, you should -- inside your
 *              PFNWRITE function -- put up a dialog telling the user to free
 *              some disk space.
 *          (2) When you get the fdintNEXT_CABINET notification, you should
 *              verify that the cabinet you return is the correct one (call
 *              FDIIsCabinet(), and make sure the setID matches the one for
 *              the current cabinet specified in the fdintCABINET_INFO, and
 *              that the disk number is one greater.
 *
 *              NOTE: FDI will continue to call fdintNEXT_CABINET until it
 *                    gets the cabinet it wants, or until you return -1
 *                    to abort the FDICopy() call.
 *
 *      The documentation below on the FDI error codes provides explicit
 *      guidance on how to avoid each error.
 *
 *      If you find you must return a failure to FDI from one of your
 *      callback functions, then FDICopy() frees all resources it allocated
 *      and closes all files.  If you can figure out how to overcome the
 *      problem, you can call FDICopy() again on the last cabinet, and
 *      skip any files that you already copied.  But, note that FDI does
 *      *not* maintain any state between FDICopy() calls, other than possibly
 *      memory allocated for the decompressor.
 *
 *      See FDIERROR for details on FDI error codes and recommended actions.
 *
 *
 *  Progress Indicator Suggestions:
 *      As above, all of the file I/O functions are supplied by you.  So,
 *      updating a progress indicator is very simple.  You keep track of
 *      the target files handles you have opened, along with the uncompressed
 *      size of the target file.  When you see writes to the handle of a
 *      target file, you use the write count to update your status!
 *      Since this method is available, there is no separate callback from
 *      FDI just for progess indication.
 */

#include <basetsd.h>

#ifndef INCLUDED_FDI
#define INCLUDED_FDI    1

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

//** Specify structure packing explicitly for clients of FDI

#ifndef _WIN64
#include <pshpack4.h>
#endif


/***    FDIERROR - Error codes returned in erf.erfOper field
 *
 *  In general, FDI will only fail if one of the passed in memory or
 *  file I/O functions fails.  Other errors are pretty unlikely, and are
 *  caused by corrupted cabinet files, passing in a file which is not a
 *  cabinet file, or cabinet files out of order.
 *
 *  Description:    Summary of error.
 *  Cause:          List of possible causes of this error.
 *  Response:       How client might respond to this error, or avoid it in
 *                  the first place.
 */
typedef enum {
    FDIERROR_NONE,
        // Description: No error
        // Cause:       Function was successfull.
        // Response:    Keep going!

    FDIERROR_CABINET_NOT_FOUND,
        // Description: Cabinet not found
        // Cause:       Bad file name or path passed to FDICopy(), or returned
        //              to fdintNEXT_CABINET.
        // Response:    To prevent this error, validate the existence of the
        //              the cabinet *before* passing the path to FDI.

    FDIERROR_NOT_A_CABINET,
        // Description: Cabinet file does not have the correct format
        // Cause:       File passed to to FDICopy(), or returned to
        //              fdintNEXT_CABINET, is too small to be a cabinet file,
        //              or does not have the cabinet signature in its first
        //              four bytes.
        // Response:    To prevent this error, call FDIIsCabinet() to check a
        //              cabinet before calling FDICopy() or returning the
        //              cabinet path to fdintNEXT_CABINET.

    FDIERROR_UNKNOWN_CABINET_VERSION,
        // Description: Cabinet file has an unknown version number.
        // Cause:       File passed to to FDICopy(), or returned to
        //              fdintNEXT_CABINET, has what looks like a cabinet file
        //              header, but the version of the cabinet file format
        //              is not one understood by this version of FDI.  The
        //              erf.erfType field is filled in with the version number
        //              found in the cabinet file.
        // Response:    To prevent this error, call FDIIsCabinet() to check a
        //              cabinet before calling FDICopy() or returning the
        //              cabinet path to fdintNEXT_CABINET.

    FDIERROR_CORRUPT_CABINET,
        // Description: Cabinet file is corrupt
        // Cause:       FDI returns this error any time it finds a problem
        //              with the logical format of a cabinet file, and any
        //              time one of the passed-in file I/O calls fails when
        //              operating on a cabinet (PFNOPEN, PFNSEEK, PFNREAD,
        //              or PFNCLOSE).  The client can distinguish these two
        //              cases based upon whether the last file I/O call
        //              failed or not.
        // Response:    Assuming this is not a real corruption problem in
        //              a cabinet file, the file I/O functions could attempt
        //              to do retries on failure (for example, if there is a
        //              temporary network connection problem).  If this does
        //              not work, and the file I/O call has to fail, then the
        //              FDI client will have to clean up and call the
        //              FDICopy() function again.

    FDIERROR_ALLOC_FAIL,
        // Description: Could not allocate enough memory
        // Cause:       FDI tried to allocate memory with the PFNALLOC
        //              function, but it failed.
        // Response:    If possible, PFNALLOC should take whatever steps
        //              are possible to allocate the memory requested.  If
        //              memory is not immediately available, it might post a
        //              dialog asking the user to free memory, for example.
        //              Note that the bulk of FDI's memory allocations are
        //              made at FDICreate() time and when the first cabinet
        //              file is opened during FDICopy().

    FDIERROR_BAD_COMPR_TYPE,
        // Description: Unknown compression type in a cabinet folder
        // Cause:       [Should never happen.]  A folder in a cabinet has an
        //              unknown compression type.  This is probably caused by
        //              a mismatch between the version of FCI.LIB used to
        //              create the cabinet and the FDI.LIB used to read the
        //              cabinet.
        // Response:    Abort.

    FDIERROR_MDI_FAIL,
        // Description: Failure decompressing data from a cabinet file
        // Cause:       The decompressor found an error in the data coming
        //              from the file cabinet.  The cabinet file was corrupted.
        //              [11-Apr-1994 bens When checksuming is turned on, this
        //              error should never occur.]
        // Response:    Probably should abort; only other choice is to cleanup
        //              and call FDICopy() again, and hope there was some
        //              intermittent data error that will not reoccur.

    FDIERROR_TARGET_FILE,
        // Description: Failure writing to target file
        // Cause:       FDI returns this error any time it gets an error back
        //              from one of the passed-in file I/O calls fails when
        //              writing to a file being extracted from a cabinet.
        // Response:    To avoid or minimize this error, the file I/O functions
        //              could attempt to avoid failing.  A common cause might
        //              be disk full -- in this case, the PFNWRITE function
        //              could have a check for free space, and put up a dialog
        //              asking the user to free some disk space.

    FDIERROR_RESERVE_MISMATCH,
        // Description: Cabinets in a set do not have the same RESERVE sizes
        // Cause:       [Should never happen]. FDI requires that the sizes of
        //              the per-cabinet, per-folder, and per-data block
        //              RESERVE sections be consistent across all the cabinets
        //              in a set.
        // Response:    Abort.

    FDIERROR_WRONG_CABINET,
        // Description: Cabinet returned on fdintNEXT_CABINET is incorrect
        // Cause:       NOTE: THIS ERROR IS NEVER RETURNED BY FDICopy()!
        //              Rather, FDICopy() keeps calling the fdintNEXT_CABINET
        //              callback until either the correct cabinet is specified,
        //              or you return ABORT.
        //              When FDICopy() is extracting a file that crosses a
        //              cabinet boundary, it calls fdintNEXT_CABINET to ask
        //              for the path to the next cabinet.  Not being very
        //              trusting, FDI then checks to make sure that the
        //              correct continuation cabinet was supplied!  It does
        //              this by checking the "setID" and "iCabinet" fields
        //              in the cabinet.  When MAKECAB.EXE creates a set of
        //              cabinets, it constructs the "setID" using the sum
        //              of the bytes of all the destination file names in
        //              the cabinet set.  FDI makes sure that the 16-bit
        //              setID of the continuation cabinet matches the
        //              cabinet file just processed.  FDI then checks that
        //              the cabinet number (iCabinet) is one more than the
        //              cabinet number for the cabinet just processed.
        // Response:    You need code in your fdintNEXT_CABINET (see below)
        //              handler to do retries if you get recalled with this
        //              error.  See the sample code (EXTRACT.C) to see how
        //              this should be handled.

    FDIERROR_USER_ABORT,
        // Description: FDI aborted.
        // Cause:       An FDI callback returnd -1 (usually).
        // Response:    Up to client.

} FDIERROR;


/*
 * FAT file attribute flag used by FCI/FDI to indicate that
 * the filename in the CAB is a UTF string
 */
#ifndef _A_NAME_IS_UTF
#define _A_NAME_IS_UTF  0x80
#endif

/*
 * FAT file attribute flag used by FCI/FDI to indicate that
 * the file should be executed after extraction
 */
#ifndef _A_EXEC
#define _A_EXEC         0x40
#endif


/***    HFDI - Handle to an FDI context
 *
 *  FDICreate() creates this, and it must be passed to all other FDI
 *  functions.
 */
typedef void FAR *HFDI; /* hfdi */


/***    FDICABINETINFO - Information about a cabinet
 *
 */
typedef struct {
    long        cbCabinet;              // Total length of cabinet file
    USHORT      cFolders;               // Count of folders in cabinet
    USHORT      cFiles;                 // Count of files in cabinet
    USHORT      setID;                  // Cabinet set ID
    USHORT      iCabinet;               // Cabinet number in set (0 based)
    BOOL        fReserve;               // TRUE => RESERVE present in cabinet
    BOOL        hasprev;                // TRUE => Cabinet is chained prev
    BOOL        hasnext;                // TRUE => Cabinet is chained next
} FDICABINETINFO; /* fdici */
typedef FDICABINETINFO FAR *PFDICABINETINFO; /* pfdici */


/***    FDIDECRYPTTYPE - PFNFDIDECRYPT command types
 *
 */
typedef enum {
    fdidtNEW_CABINET,                   // New cabinet
    fdidtNEW_FOLDER,                    // New folder
    fdidtDECRYPT,                       // Decrypt a data block
} FDIDECRYPTTYPE; /* fdidt */


/***    FDIDECRYPT - Data for PFNFDIDECRYPT function
 *
 */
typedef struct {
    FDIDECRYPTTYPE    fdidt;            // Command type (selects union below)
    void FAR         *pvUser;           // Decryption context
    union {
        struct {                        // fdidtNEW_CABINET
            void FAR *pHeaderReserve;   // RESERVE section from CFHEADER
            USHORT    cbHeaderReserve;  // Size of pHeaderReserve
            USHORT    setID;            // Cabinet set ID
            int       iCabinet;         // Cabinet number in set (0 based)
        } cabinet;

        struct {                        // fdidtNEW_FOLDER
            void FAR *pFolderReserve;   // RESERVE section from CFFOLDER
            USHORT    cbFolderReserve;  // Size of pFolderReserve
            USHORT    iFolder;          // Folder number in cabinet (0 based)
        } folder;

        struct {                        // fdidtDECRYPT
            void FAR *pDataReserve;     // RESERVE section from CFDATA
            USHORT    cbDataReserve;    // Size of pDataReserve
            void FAR *pbData;           // Data buffer
            USHORT    cbData;           // Size of data buffer
            BOOL      fSplit;           // TRUE if this is a split data block
            USHORT    cbPartial;        // 0 if this is not a split block, or
                                        //  the first piece of a split block;
                                        // Greater than 0 if this is the
                                        //  second piece of a split block.
        } decrypt;
    };
} FDIDECRYPT; /* fdid */
typedef FDIDECRYPT FAR *PFDIDECRYPT; /* pfdid */


/***    FNALLOC - Memory Allocation
 *      FNFREE  - Memory Free
 *
 *  These are modeled after the C run-time routines malloc() and free()
 *  FDI expects error handling to be identical to these C run-time routines.
 *
 *  As long as you faithfully copy the semantics of malloc() and free(),
 *  you can supply any functions you like!
 *
 *  WARNING: You should never assume anything about the sequence of
 *           PFNALLOC and PFNFREE calls -- incremental releases of
 *           FDI may have radically different numbers of
 *           PFNALLOC calls and allocation sizes!
 */
//** Memory functions for FDI
typedef void HUGE * (FAR DIAMONDAPI *PFNALLOC)(ULONG cb); /* pfna */
#define FNALLOC(fn) void HUGE * FAR DIAMONDAPI fn(ULONG cb)

typedef void (FAR DIAMONDAPI *PFNFREE)(void HUGE *pv); /* pfnf */
#define FNFREE(fn) void FAR DIAMONDAPI fn(void HUGE *pv)


/***    PFNOPEN  - File I/O callbacks for FDI
 *      PFNREAD
 *      PFNWRITE
 *      PFNCLOSE
 *      PFNSEEK
 *
 *  These are modeled after the C run-time routines _open, _read,
 *  _write, _close, and _lseek.  The values for the PFNOPEN oflag
 *  and pmode calls are those defined for _open.  FDI expects error
 *  handling to be identical to these C run-time routines.
 *
 *  As long as you faithfully copy these aspects, you can supply
 *  any functions you like!
 *
 *  WARNING: You should never assume you know what file is being
 *           opened at any one point in time!  FDI will usually
 *           stick to opening cabinet files, but it is possible
 *           that in a future implementation it may open temporary
 *           files or open cabinet files in a different order.
 *
 *  Notes for Memory Mapped File fans:
 *      You can write wrapper routines to allow FDI to work on memory
 *      mapped files.  You'll have to create your own "handle" type so that
 *      you can store the base memory address of the file and the current
 *      seek position, and then you'll allocate and fill in one of these
 *      structures and return a pointer to it in response to the PFNOPEN
 *      call and the fdintCOPY_FILE call.  Your PFNREAD and PFNWRITE
 *      functions will do memcopy(), and update the seek position in your
 *      "handle" structure.  PFNSEEK will just change the seek position
 *      in your "handle" structure.
 */
//** File I/O functions for FDI
typedef INT_PTR (FAR DIAMONDAPI *PFNOPEN) (char FAR *pszFile, int oflag, int pmode);
typedef UINT (FAR DIAMONDAPI *PFNREAD) (INT_PTR hf, void FAR *pv, UINT cb);
typedef UINT (FAR DIAMONDAPI *PFNWRITE)(INT_PTR hf, void FAR *pv, UINT cb);
typedef int  (FAR DIAMONDAPI *PFNCLOSE)(INT_PTR hf);
typedef long (FAR DIAMONDAPI *PFNSEEK) (INT_PTR hf, long dist, int seektype);

#define FNOPEN(fn) INT_PTR FAR DIAMONDAPI fn(char FAR *pszFile, int oflag, int pmode)
#define FNREAD(fn) UINT FAR DIAMONDAPI fn(INT_PTR hf, void FAR *pv, UINT cb)
#define FNWRITE(fn) UINT FAR DIAMONDAPI fn(INT_PTR hf, void FAR *pv, UINT cb)
#define FNCLOSE(fn) int FAR DIAMONDAPI fn(INT_PTR hf)
#define FNSEEK(fn) long FAR DIAMONDAPI fn(INT_PTR hf, long dist, int seektype)



/***    PFNFDIDECRYPT - FDI Decryption callback
 *
 *  If this function is passed on the FDICopy() call, then FDI calls it
 *  at various times to update the decryption state and to decrypt FCDATA
 *  blocks.
 *
 *  Common Entry Conditions:
 *      pfdid->fdidt  - Command type
 *      pfdid->pvUser - pvUser value from FDICopy() call
 *
 *  fdidtNEW_CABINET:   //** Notification of a new cabinet
 *      Entry:
 *        pfdid->cabinet.
 *          pHeaderReserve  - RESERVE section from CFHEADER
 *          cbHeaderReserve - Size of pHeaderReserve
 *          setID           - Cabinet set ID
 *          iCabinet        - Cabinet number in set (0 based)
 *      Exit-Success:
 *          returns anything but -1;
 *      Exit-Failure:
 *          returns -1; FDICopy() is aborted.
 *      Notes:
 *      (1) This call allows the decryption code to pick out any information
 *          from the cabinet header reserved area (placed there by DIACRYPT)
 *          needed to perform decryption.  If there is no such information,
 *          this call would presumably be ignored.
 *      (2) This call is made very soon after fdintCABINET_INFO.
 *
 *  fdidtNEW_FOLDER:    //** Notification of a new folder
 *      Entry:
 *        pfdid->folder.
 *          pFolderReserve  - RESERVE section from CFFOLDER
 *          cbFolderReserve - Size of pFolderReserve
 *          iFolder         - Folder number in cabinet (0 based)
 *      Exit-Success:
 *          returns anything but -1;
 *      Exit-Failure:
 *          returns -1; FDICopy() is aborted.
 *      Notes:
 *          This call allows the decryption code to pick out any information
 *          from the folder reserved area (placed there by DIACRYPT) needed
 *          to perform decryption.  If there is no such information, this
 *          call would presumably be ignored.
 *
 *  fdidtDECRYPT:       //** Decrypt a data buffer
 *      Entry:
 *        pfdid->folder.
 *          pDataReserve  - RESERVE section for this CFDATA block
 *          cbDataReserve - Size of pDataReserve
 *          pbData        - Data buffer
 *          cbData        - Size of data buffer
 *          fSplit        - TRUE if this is a split data block
 *          cbPartial     - 0 if this is not a split block, or the first
 *                              piece of a split block; Greater than 0 if
 *                              this is the second piece of a split block.
 *      Exit-Success:
 *          returns TRUE;
 *      Exit-Failure:
 *          returns FALSE; error during decrypt
 *          returns -1; FDICopy() is aborted.
 *      Notes:
 *          FCI will split CFDATA blocks across cabinet boundaries if
 *          necessary.  To provide maximum flexibility, FDI will call the
 *          fdidtDECRYPT function twice on such split blocks, once when
 *          the first portion is read, and again when the second portion
 *          is read.  And, of course, most data blocks will not be split.
 *          So, there are three cases:
 *
 *           1) fSplit == FALSE
 *              You have the entire data block, so decrypt it.
 *
 *           2) fSplit == TRUE, cbPartial == 0
 *              This is the first portion of a split data block, so cbData
 *              is the size of this portion.  You can either choose to decrypt
 *              this piece, or ignore this call and decrypt the full CFDATA
 *              block on the next (second) fdidtDECRYPT call.
 *
 *           3) fSplit == TRUE, cbPartial > 0
 *              This is the second portion of a split data block (indeed,
 *              cbPartial will have the same value as cbData did on the
 *              immediately preceeding fdidtDECRYPT call!).  If you decrypted
 *              the first portion on the first call, then you can decrypt the
 *              second portion now.  If you ignored the first call, then you
 *              can decrypt the entire buffer.
 *              NOTE: pbData points to the second portion of the split data
 *                    block in this case, *not* the entire data block.  If
 *                    you want to wait until the second piece to decrypt the
 *                    *entire* block, pbData-cbPartial is the address of the
 *                    start of the whole block, and cbData+cbPartial is its
 *                    size.
 */
typedef int (FAR DIAMONDAPI *PFNFDIDECRYPT)(PFDIDECRYPT pfdid); /* pfnfdid */
#define FNFDIDECRYPT(fn) int FAR DIAMONDAPI fn(PFDIDECRYPT pfdid)


/***    FDINOTIFICATION - Notification structure for PFNFDINOTIFY
 *
 *  See the FDINOTIFICATIONTYPE definition for information on usage and
 *  meaning of these fields.
 */
typedef struct {
// long fields
    long      cb;
    char FAR *psz1;
    char FAR *psz2;
    char FAR *psz3;                     // Points to a 256 character buffer
    void FAR *pv;                       // Value for client

// int fields
    INT_PTR   hf;

// short fields
    USHORT    date;
    USHORT    time;
    USHORT    attribs;

    USHORT    setID;                    // Cabinet set ID
    USHORT    iCabinet;                 // Cabinet number (0-based)
    USHORT    iFolder;                  // Folder number (0-based)

    FDIERROR  fdie;
} FDINOTIFICATION, FAR *PFDINOTIFICATION;  /* fdin, pfdin */


/***    FDINOTIFICATIONTYPE - FDICopy notification types
 *
 *  The notification function for FDICopy can be called with the following
 *  values for the fdint parameter.  In all cases, the pfdin->pv field is
 *  filled in with the value of the pvUser argument passed in to FDICopy().
 *
 *  A typical sequence of calls will be something like this:
 *      fdintCABINET_INFO     // Info about the cabinet
 *      fdintENUMERATE        // Starting enumeration
 *      fdintPARTIAL_FILE     // Only if this is not the first cabinet, and
 *                            // one or more files were continued from the
 *                            // previous cabinet.
 *      ...
 *      fdintPARTIAL_FILE
 *      fdintCOPY_FILE        // The first file that starts in this cabinet
 *      ...
 *      fdintCOPY_FILE        // Now let's assume you want this file...
 *      // PFNWRITE called multiple times to write to this file.
 *      fdintCLOSE_FILE_INFO  // File done, set date/time/attributes
 *
 *      fdintCOPY_FILE        // Now let's assume you want this file...
 *      // PFNWRITE called multiple times to write to this file.
 *      fdintNEXT_CABINET     // File was continued to next cabinet!
 *      fdintCABINET_INFO     // Info about the new cabinet
 *      // PFNWRITE called multiple times to write to this file.
 *      fdintCLOSE_FILE_INFO  // File done, set date/time/attributes
 *      ...
 *      fdintENUMERATE        // Ending enumeration
 *
 *  fdintCABINET_INFO:
 *        Called exactly once for each cabinet opened by FDICopy(), including
 *        continuation cabinets opened due to file(s) spanning cabinet
 *        boundaries. Primarily intended to permit EXTRACT.EXE to
 *        automatically select the next cabinet in a cabinet sequence even if
 *        not copying files that span cabinet boundaries.
 *      Entry:
 *          pfdin->psz1     = name of next cabinet
 *          pfdin->psz2     = name of next disk
 *          pfdin->psz3     = cabinet path name
 *          pfdin->setID    = cabinet set ID (a random 16-bit number)
 *          pfdin->iCabinet = Cabinet number within cabinet set (0-based)
 *      Exit-Success:
 *          Return anything but -1
 *      Exit-Failure:
 *          Returns -1 => Abort FDICopy() call
 *      Notes:
 *          This call is made *every* time a new cabinet is examined by
 *          FDICopy().  So if "foo2.cab" is examined because a file is
 *          continued from "foo1.cab", and then you call FDICopy() again
 *          on "foo2.cab", you will get *two* fdintCABINET_INFO calls all
 *          told.
 *
 *  fdintCOPY_FILE:
 *        Called for each file that *starts* in the current cabinet, giving
 *        the client the opportunity to request that the file be copied or
 *        skipped.
 *      Entry:
 *          pfdin->psz1    = file name in cabinet
 *          pfdin->cb      = uncompressed size of file
 *          pfdin->date    = file date
 *          pfdin->time    = file time
 *          pfdin->attribs = file attributes
 *          pfdin->iFolder = file's folder index
 *      Exit-Success:
 *          Return non-zero file handle for destination file; FDI writes
 *          data to this file use the PFNWRITE function supplied to FDICreate,
 *          and then calls fdintCLOSE_FILE_INFO to close the file and set
 *          the date, time, and attributes.  NOTE: This file handle returned
 *          must also be closeable by the PFNCLOSE function supplied to
 *          FDICreate, since if an error occurs while writing to this handle,
 *          FDI will use the PFNCLOSE function to close the file so that the
 *          client may delete it.
 *      Exit-Failure:
 *          Returns 0  => Skip file, do not copy
 *          Returns -1 => Abort FDICopy() call
 *
 *  fdintCLOSE_FILE_INFO:
 *        Called after all of the data has been written to a target file.
 *        This function must close the file and set the file date, time,
 *        and attributes.
 *      Entry:
 *          pfdin->psz1    = file name in cabinet
 *          pfdin->hf      = file handle
 *          pfdin->date    = file date
 *          pfdin->time    = file time
 *          pfdin->attribs = file attributes
 *          pfdin->iFolder = file's folder index
 *          pfdin->cb      = Run After Extract (0 - don't run, 1 Run)
 *      Exit-Success:
 *          Returns TRUE
 *      Exit-Failure:
 *          Returns FALSE, or -1 to abort;
 *
 *              IMPORTANT NOTE IMPORTANT:
 *                  pfdin->cb is overloaded to no longer be the size of
 *                  the file but to be a binary indicated run or not
 *
 *              IMPORTANT NOTE:
 *                  FDI assumes that the target file was closed, even if this
 *                  callback returns failure.  FDI will NOT attempt to use
 *                  the PFNCLOSE function supplied on FDICreate() to close
 *                  the file!
 *
 *  fdintPARTIAL_FILE:
 *        Called for files at the front of the cabinet that are CONTINUED
 *        from a previous cabinet.  This callback occurs only when FDICopy is
 *        started on second or subsequent cabinet in a series that has files
 *        continued from a previous cabinet.
 *      Entry:
 *          pfdin->psz1 = file name of file CONTINUED from a PREVIOUS cabinet
 *          pfdin->psz2 = name of cabinet where file starts
 *          pfdin->psz3 = name of disk where file starts
 *      Exit-Success:
 *          Return anything other than -1; enumeration continues
 *      Exit-Failure:
 *          Returns -1 => Abort FDICopy() call
 *
 *  fdintENUMERATE:
 *        Called once after a call to FDICopy() starts scanning a CAB's
 *        CFFILE entries, and again when there are no more CFFILE entries.
 *        If CAB spanning occurs, an additional call will occur after the
 *        first spanned file is completed.  If the pfdin->iFolder value is
 *        changed from zero, additional calls will occur next time it reaches
 *        zero.  If iFolder is changed to zero, FDICopy will terminate, as if
 *        there were no more CFFILE entries.  Primarily intended to allow an
 *        application with it's own file list to help FDI advance quickly to
 *        a CFFILE entry of interest.  Can also be used to allow an
 *        application to determine the cb values for each file in the CAB.
 *      Entry:
 *        pfdin->cb        = current CFFILE position
 *        pfdin->iFolder   = number of files remaining
 *        pfdin->setID     = current CAB's setID value
 *      Exit-Don't Care:
 *        Don't change anything.
 *        Return anything but -1.
 *      Exit-Forcing a skip:
 *        pfdin->cb        = desired CFFILE position
 *        pfdin->iFolder   = desired # of files remaining
 *        Return anything but -1.
 *      Exit-Stop:
 *        pfdin->iFolder    = set to 0
 *        Return anything but -1.
 *      Exit-Failure:
 *        Return -1 => Abort FDICopy call ("user aborted".)
 *      Notes:
 *        This call can be ignored by applications which want normal file
 *        searching.  The application can adjust the supplied values to
 *        force FDICopy() to continue it's search at another location, or
 *        to force FDICopy() to terminate the search, by setting iFolder to 0.
 *        (FDICopy() will report no error when terminated this way.)
 *        FDI has no means to verify the supplied cb or iFolder values.
 *        Arbitrary values are likely to cause undesirable results.  An
 *        application should cross-check pfdin->setID to be certain the
 *        external database is in sync with the CAB.  Reverse-skips are OK
 *        (but may be inefficient) unless fdintNEXT_CABINET has been called.
 *
 *  fdintNEXT_CABINET:
 *        This function is *only* called when fdintCOPY_FILE was told to copy
 *        a file in the current cabinet that is continued to a subsequent
 *        cabinet file.  It is important that the cabinet path name (psz3)
 *        be validated before returning!  This function should ensure that
 *        the cabinet exists and is readable before returning.  So, this
 *        is the function that should, for example, issue a disk change
 *        prompt and make sure the cabinet file exists.
 *
 *        When this function returns to FDI, FDI will check that the setID
 *        and iCabinet match the expected values for the next cabinet.
 *        If not, FDI will continue to call this function until the correct
 *        cabinet file is specified, or until this function returns -1 to
 *        abort the FDICopy() function.  pfdin->fdie is set to
 *        FDIERROR_WRONG_CABINET to indicate this case.
 *
 *        If you *haven't* ensured that the cabinet file is present and
 *        readable, or the cabinet file has been damaged, pfdin->fdie will
 *        receive other appropriate error codes:
 *
 *              FDIERROR_CABINET_NOT_FOUND
 *              FDIERROR_NOT_A_CABINET
 *              FDIERROR_UNKNOWN_CABINET_VERSION
 *              FDIERROR_CORRUPT_CABINET
 *              FDIERROR_BAD_COMPR_TYPE
 *              FDIERROR_RESERVE_MISMATCH
 *              FDIERROR_WRONG_CABINET
 *
 *      Entry:
 *          pfdin->psz1 = name of next cabinet where current file is continued
 *          pfdin->psz2 = name of next disk where current file is continued
 *          pfdin->psz3 = cabinet path name; FDI concatenates psz3 with psz1
 *                          to produce the fully-qualified path for the cabinet
 *                          file.  The 256-byte buffer pointed at by psz3 may
 *                          be modified, but psz1 may not!
 *          pfdin->fdie = FDIERROR_WRONG_CABINET if the previous call to
 *                        fdintNEXT_CABINET specified a cabinet file that
 *                        did not match the setID/iCabinet that was expected.
 *      Exit-Success:
 *          Return anything but -1
 *      Exit-Failure:
 *          Returns -1 => Abort FDICopy() call
 *      Notes:
 *          This call is almost always made when a target file is open and
 *          being written to, and the next cabinet is needed to get more
 *          data for the file.
 */
typedef enum {
    fdintCABINET_INFO,              // General information about cabinet
    fdintPARTIAL_FILE,              // First file in cabinet is continuation
    fdintCOPY_FILE,                 // File to be copied
    fdintCLOSE_FILE_INFO,           // close the file, set relevant info
    fdintNEXT_CABINET,              // File continued to next cabinet
    fdintENUMERATE,                 // Enumeration status
} FDINOTIFICATIONTYPE; /* fdint */

typedef INT_PTR (FAR DIAMONDAPI *PFNFDINOTIFY)(FDINOTIFICATIONTYPE fdint,
                                               PFDINOTIFICATION    pfdin); /* pfnfdin */

#define FNFDINOTIFY(fn) INT_PTR FAR DIAMONDAPI fn(FDINOTIFICATIONTYPE fdint, \
                                                  PFDINOTIFICATION    pfdin)


/*** cpuType values for FDICreate()
 *
 *  (Ignored by 32-bit FDI.)
 */
#define     cpuUNKNOWN         (-1)    /* FDI does detection */
#define     cpu80286           (0)     /* '286 opcodes only */
#define     cpu80386           (1)     /* '386 opcodes used */


/***    FDICreate - Create an FDI context
 *
 *  Entry:
 *      pfnalloc
 *      pfnfree
 *      pfnopen
 *      pfnread
 *      pfnwrite
 *      pfnclose
 *      pfnlseek
 *      cpuType  - Select CPU type (auto-detect, 286, or 386+)
 *                 NOTE: For the 32-bit FDI.LIB, this parameter is ignored!
 *      perf
 *
 *  Exit-Success:
 *      Returns non-NULL FDI context handle.
 *
 *  Exit-Failure:
 *      Returns NULL; perf filled in with error code
 *
 */
HFDI FAR DIAMONDAPI FDICreate(PFNALLOC pfnalloc,
                              PFNFREE  pfnfree,
                              PFNOPEN  pfnopen,
                              PFNREAD  pfnread,
                              PFNWRITE pfnwrite,
                              PFNCLOSE pfnclose,
                              PFNSEEK  pfnseek,
                              int      cpuType,
                              PERF     perf);


/***    FDIIsCabinet - Determines if file is a cabinet, returns info if it is
 *
 *  Entry:
 *      hfdi   - Handle to FDI context (created by FDICreate())
 *      hf     - File handle suitable for PFNREAD/PFNSEEK, positioned
 *               at offset 0 in the file to test.
 *      pfdici - Buffer to receive info about cabinet if it is one.
 *
 *  Exit-Success:
 *      Returns TRUE; file is a cabinet, pfdici filled in.
 *
 *  Exit-Failure:
 *      Returns FALSE, file is not a cabinet;  If an error occurred,
 *          perf (passed on FDICreate call!) filled in with error.
 */
BOOL FAR DIAMONDAPI FDIIsCabinet(HFDI            hfdi,
                                 INT_PTR         hf,
                                 PFDICABINETINFO pfdici);


/***    FDICopy - extracts files from a cabinet
 *
 *  Entry:
 *      hfdi        - handle to FDI context (created by FDICreate())
 *      pszCabinet  - main name of cabinet file
 *      pszCabPath  - Path to cabinet file(s)
 *      flags       - Flags to modify behavior
 *      pfnfdin     - Notification function
 *      pfnfdid     - Decryption function (pass NULL if not used)
 *      pvUser      - User specified value to pass to notification function
 *
 *  Exit-Success:
 *      Returns TRUE;
 *
 *  Exit-Failure:
 *      Returns FALSE, perf (passed on FDICreate call!) filled in with
 *          error.
 *
 *  Notes:
 *  (1) If FDICopy() fails while a target file is being written out, then
 *      FDI will use the PFNCLOSE function to close the file handle for that
 *      target file that was returned from the fdintCOPY_FILE notification.
 *      The client application is then free to delete the target file, since
 *      it will not be in a valid state (since there was an error while
 *      writing it out).
 */
BOOL FAR DIAMONDAPI FDICopy(HFDI          hfdi,
                            char FAR     *pszCabinet,
                            char FAR     *pszCabPath,
                            int           flags,
                            PFNFDINOTIFY  pfnfdin,
                            PFNFDIDECRYPT pfnfdid,
                            void FAR     *pvUser);


/***    FDIDestroy - Destroy an FDI context
 *
 *  Entry:
 *      hfdi - handle to FDI context (created by FDICreate())
 *
 *  Exit-Success:
 *      Returns TRUE;
 *
 *  Exit-Failure:
 *      Returns FALSE;
 */
BOOL FAR DIAMONDAPI FDIDestroy(HFDI hfdi);


/***    FDITruncateCabinet - truncate a cabinet, starting at folder #
 *
 *  Entry:
 *      hfdi        - handle to FDI context (created by FDICreate())
 *      pszCabinet  - full pathname of cabinet file
 *      iFolderToDelete - first folder # to delete
 *
 *  Exit-Success:
 *      Returns TRUE;
 *
 *  Exit-Failure:
 *      Returns FALSE;
 *
 *  Most likely failure is unable to open cabinet for writing.
 *
 *  NOTE:   This function relies on additional feature in the
 *          supplied PFNWRITE function, that a write of 0 bytes
 *          will truncate the file at the current position.
 */

BOOL FAR DIAMONDAPI FDITruncateCabinet(HFDI            hfdi,
                                       char *          pszCabinetName,
                                       USHORT          iFolderToDelete);


//** Revert to default structure packing
#ifndef _WIN64
#include <poppack.h>
#endif

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#endif //!INCLUDED_FDI
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\filehc.h ===
/*++

	FILEHC.H

	This file defines the public interfaces for issuing async Reads/Writes to a file
	using the fileh wrapper library.

--*/

#ifndef	_FILEHC_H_
#define	_FILEHC_H_

// Published parts of the File Handle cache !


#ifdef	__cplusplus	
extern	"C"	{
#endif

typedef	VOID
(*PFN_IO_COMPLETION)(
		IN	struct	FIO_CONTEXT*	pContext,
		IN	struct	FH_OVERLAPPED*	lpo, 
		IN	DWORD		cb, 
		IN	DWORD		dwCompletionStatus
		);



struct	FH_OVERLAPPED	{
/*++

	This structure defines the extended OVERLAPPED structure
	used by the File IO layer implemented in this module.

	The first 5 elements of this structure are identical to 
	NT's OVERLAPPED structure and have the exact same semantics.
	
	The final additional parameter is a pointer to a 
	function that will be called to complete the IO.

--*/
	UINT_PTR	Internal ;
	UINT_PTR	InternalHigh ;
	DWORD		Offset ;
	DWORD		OffsetHigh ;
	HANDLE		hEvent ;
	PFN_IO_COMPLETION	pfnCompletion ;	
	UINT_PTR	Reserved1 ;
	UINT_PTR	Reserved2 ;
	UINT_PTR	Reserved3 ;
	UINT_PTR	Reserved4 ;
} ;

typedef	struct	FH_OVERLAPPED*	PFH_OVERLAPPED ;

struct	FIO_CONTEXT	{
/*++

	This structure defines the context object
	that is used to represent file handles.

--*/
    //
    //  Temporary hack - mailmsg object assumes it can put a NULL in us !
    //
    DWORD       m_dwTempHack ;

	//
	//	The context signature !
	//
	DWORD		m_dwSignature ;

	//
	//	The users file handle !
	//
	HANDLE		m_hFile ;

	//
	//  The offset to back fill Lines header - nntp aware only
	//
	DWORD       m_dwLinesOffset;

	//
	//  Header length - nntp aware only
	//
	DWORD       m_dwHeaderLength;
} ;

typedef	FIO_CONTEXT*	PFIO_CONTEXT ;


#ifdef	_FILEHC_IMPLEMENTATION_
#define	FILEHC_EXPORT	__declspec( dllexport )	
#else
#define	FILEHC_EXPORT	__declspec( dllimport )	
#endif


//
//	Initialize the DLL for Async IO - 
//	This is a counting initialize - for each call to FIOInitialize()
//	there should be a matching call to FIOTerminate
//
FILEHC_EXPORT
BOOL	__stdcall
FIOInitialize(
    IN DWORD dwFlags
    );

//
//	Terminate the DLL's support for Async IO !
//
FILEHC_EXPORT
BOOL	__stdcall
FIOTerminate(
    VOID
    );

//
//	Do an async read against the File !
//
FILEHC_EXPORT
BOOL	__stdcall
FIOReadFile(
    IN  PFIO_CONTEXT	pContext,
    IN  LPVOID			lpBuffer,
    IN  DWORD			BytesToRead,
    IN  FH_OVERLAPPED *	lpo
    );

//
//	Do an async read against the file - pass extra args
//	so that if the FIO_CONTEXT is doing dot stuffing for the user
//	it can do so efficiently !
//
FILEHC_EXPORT
BOOL	__stdcall
FIOReadFileEx(
    IN  PFIO_CONTEXT	pContext,
    IN  LPVOID			lpBuffer,
    IN  DWORD			BytesToRead,
	IN	DWORD			BytesAvailable, // must be >= BytesToWrite - number of bytes I can screw with.
    IN  FH_OVERLAPPED *	lpo,
	IN	BOOL			fFinalWrite,	// Is this the final write ? 
	IN	BOOL			fIncludeTerminator	// if TRUE contains CRLF.CRLF terminator which shouldn't be stuffed
    );


//
//	Do an async write against the file !
//
FILEHC_EXPORT
BOOL	__stdcall
FIOWriteFile(
    IN  PFIO_CONTEXT	pContext,
    IN  LPCVOID			lpBuffer,
    IN  DWORD			BytesToWrite,
    IN  FH_OVERLAPPED * lpo
    );

//
//	Do an async write against the file - pass extra args
//	so that if the FIO_CONTEXT is doing dot stuffing for the user
//	it can do so efficiently !
//
FILEHC_EXPORT
BOOL	__stdcall
FIOWriteFileEx(
	IN	PFIO_CONTEXT	pContext,
	IN	LPVOID			lpBuffer,
	IN	DWORD			BytesToWrite,
	IN	DWORD			BytesAvailable, // must be >= BytesToWrite - number of bytes I can screw with.
	IN	FH_OVERLAPPED*	lpo,
	IN	BOOL			fFinalWrite,	// Is this the final write ? 
	IN	BOOL			fIncludeTerminator	// if TRUE contains CRLF.CRLF terminator which shouldn't be stuffed
	) ;

//
//	Callback functions which create things in the cache !
//
//	NOTE: this is equivalent to FCACHE_RICHCREATE_CALLBACK where
//
//	pfDidWeScanIt - returns FALSE
//	pfIsStuffed - return FALSE
//	pfStoredWithDots - return FALSE
//
typedef	
HANDLE	
(__stdcall	*FCACHE_CREATE_CALLBACK) (
		IN	LPSTR	lpstrName, 
		IN	LPVOID	lpvData, 
		OUT	DWORD*	cbFileSize,
		OUT	DWORD*	cbFileSizeHigh
		) ;


//
//	Callback functions which create things in the cache !
//
//	This function will be called by CacheRichCreateFile().
//
//	lpstrName - the name of the file 
//	lpvData - User provided data, provided to CacheRichCreateFile
//	cbFileSize - The function should return the size of the file through this
//	cbFileSizeHigh - place to return the High DWORD of the file size
//	pfDidWeScanIt - if THIS is true then at some point the created file has been
//		scanned for DOTs appearing at the beginning of lines
//	pfIsStuffed - This is only meaningfull if pfDidWeScanIt==TRUE, in which case
//		if this is TRUE this indicates that there are DOTs at the beginning of lines
//	pfStoredWithDots - If this is TRUE then it indicates that any DOTs that appear
//		at the beginning of lines are stored with an extra dot as required in NNTP, 
//		SMTP and POP3 protocols.  if this is FALSE then the message is stored without
//		DOT stuffing.
//
typedef	
HANDLE	
(__stdcall	*FCACHE_RICHCREATE_CALLBACK) (
		IN	LPSTR	lpstrName, 
		IN	LPVOID	lpvData, 
		OUT	DWORD*	cbFileSize, 
		OUT	DWORD*	cbFileSizeHigh,
        OUT BOOL*   pfDidWeScanIt,
        OUT BOOL*   pfIsStuffed,
		OUT	BOOL*	pfStoredWithDots, 
		OUT	BOOL*	pfStoredWithTerminatingDot
		) ;

//
//	Initialize the File Handle Cache - 
//
//	NOTE : this will automatically initialize the DLL for async
//	IO as well !
//
FILEHC_EXPORT
BOOL	__stdcall
InitializeCache() ;

//
//	Terminate the cache !
//	
//	NOTE : this will terminate the DLL for async IO as well !
//
FILEHC_EXPORT
BOOL	__stdcall
TerminateCache() ;

//
//	Associate a file with an async context !
//
FILEHC_EXPORT
PFIO_CONTEXT	__stdcall	
AssociateFile(	HANDLE	hFile	) ;

//
//	This allows the user to specify whether file stores content with extra DOTS
//	added for RFC 822 protocols (i.e. NNTP and SMTP DATA commands).
//
//	NOTE: AssociateFile() is the same as AssociateFileEx( hFile, FALSE ) ;
//
//	hFile - The file that contains message content, or in which we will write message content
//	fStoreWithDots - if TRUE then each period or DOT in the file which starts a line
//		but is NOT part of the terminating CRLF.CRLF will be stored with an extra dot
//		adjacent to it.  This is the on the wire format for NNTP for instance.
//
FILEHC_EXPORT
PFIO_CONTEXT	__stdcall
AssociateFileEx(	HANDLE	hFile,
					BOOL	fStoreWithDots, 
					BOOL	fStoredWithTerminatingDot 
					) ;

//
//	Add a reference to a context - 
//	
//	Each call to AddRefContext() must be matched by a corresponding
//	call to ReleaseContext().   Both AssociateFile and CacheCreateFile()
//	also add a single reference which must be matched by a call to ReleaseContext().
//
FILEHC_EXPORT
void	__stdcall	
AddRefContext(	PFIO_CONTEXT ) ;

//
//	Release a Context !
//
//	FIO_CONTEXT's are reference counted - the user must call
//	this for each successfull call to CacheCreateFile(), and 
//	each call to InsertFile() where fKeepReference is TRUE
//
FILEHC_EXPORT
void	__stdcall
ReleaseContext(	PFIO_CONTEXT ) ;

//
//	Close a handle associated with a non-cached FIO_CONTEXT
//
//	This is used to Close the file handle within a context.
//	This only succeeds if the FIO_CONTEXT is not cached !
//
FILEHC_EXPORT
BOOL	__stdcall
CloseNonCachedFile(	PFIO_CONTEXT	) ;

//
//	Create a file in the cache, or find an existing one !
//
//	If the file is not in the cache, the cache will call 
//	pfnCallBack with lpv to do the actual work of calling
//	CreateFile().
//
FILEHC_EXPORT
FIO_CONTEXT*	__stdcall
CacheCreateFile(	IN	LPSTR	lpstrName, 
					IN	FCACHE_CREATE_CALLBACK	pfnCallBack, 
					IN	LPVOID	lpv, 
					IN	BOOL	fAsyncContext
					) ;
					
//
//	Create a file in the cache or find an existing one, 
//	if we create the file we can add properties onto it in 
//	the cache !
//
FILEHC_EXPORT
FIO_CONTEXT*	__stdcall
CacheRichCreateFile(	IN	LPSTR	lpstrName, 
						IN	FCACHE_RICHCREATE_CALLBACK	pfnCallBack, 
						IN	LPVOID	lpv, 
						IN	BOOL	fAsyncContext
						) ;

//
//	This function allows a user to remove all files with the specified 
//	Name from the cache.  if fAllPrefixes is TRUE, we will remove all files
//	where the Name matches the beginning of the path !
//	If fAllPrefixes is FALSE then we will remove only the one file which 
//	exactly matches lpstrName !
//
FILEHC_EXPORT
void	__stdcall
CacheRemoveFiles(	IN	LPSTR	lpstrName,
					IN	BOOL	fAllPrefixes
					) ;
//
//	Insert the file into the cache !
//
//	This function will add the file handle in the FIO_CONTEXT
//	to the cache.  All searches by lpstrName will find this
//	item untill it expires from the cache.
//
//	If fKeepReference is TRUE then the user must make a call to 
//	ReleaseContext() for the inserted FIO_CONTEXT !
//
FILEHC_EXPORT
BOOL	__stdcall	
InsertFile(		IN	LPSTR	lpstrName, 
				IN	FIO_CONTEXT*	pContext,
				IN	BOOL	fKeepReference 
				) ;

//
//	Report the file size that we've cached with the handle
//
FILEHC_EXPORT
DWORD	__stdcall
GetFileSizeFromContext(	IN	FIO_CONTEXT*	pContext, 
						OUT	DWORD*			pcbFileSizeHigh
						) ;

//----------------------------------------------------------------------
// NAME CACHE NAME CACHE NAME CACHE - 
//
//	Name Cache API's
//
//

//
//	This is the function pointer provided by clients to compare 
//	keys.  This must be provided on all calls.
//
//	The function has memcmp() semantics, i.e. it must order the keys
//	consistently, and return <0 if key1 is smaller then key2, ==0 if the
//	keys match and >0 if key1 is greater then key2.
//
typedef	
int
(__stdcall	*CACHE_KEY_COMPARE)(	IN	DWORD	cbKey1, 
									IN	LPBYTE	lpbKey1,
									IN	DWORD	cbKey2, 
									IN	LPBYTE	lpbKey2
									) ;

//
//	This is the function provided by clients to compute a hash 
//	value on Keys - NOTE: The Cache will provide a hash function 
//	IF the user does not, however the internally provided hash
//	function is best only for things that appear to be regular strings.
//
typedef
DWORD
(__stdcall	*CACHE_KEY_HASH)(	IN	LPBYTE	lpbKey, 
								IN	DWORD	cbKey
								) ;

//
//	This is the generic callback function that is provided to the 
//	cache to help examine items within the cache.
//	The BOOL return value is meaningfull to the Cache API's only
//	on the following calls : 
//
//
typedef	
BOOL
(__stdcall	*CACHE_READ_CALLBACK)(	IN	DWORD	cb, 
									IN	LPBYTE	lpb, 
									IN	LPVOID	lpvContext
									) ;

//	
//	This is a callback that is called whenever we destroy an entry in 
//	the name cache - this is called once for both key and data components, 
//	and gives the client a chance to track any relationships 
//
//	NOTE : if the client does not associate 
//	data with the name, the function will only be called for the Key data.
//
typedef
void
(__stdcall	*CACHE_DESTROY_CALLBACK)(	IN	DWORD	cb, 
										IN	LPBYTE	lpb
										) ;

//
//	This is a callback this is called whenever we evaluate a security descriptor.
//	If it is not provided we will call the standard NT AccessCheck() call !
//
//	The function has the same signature as AccessCheck, however there are arguments
//	we don't use - PrivilegeSet will always be NULL and PrivilegeSetLength will always be 0 !
//
typedef
BOOL
(WINAPI	*CACHE_ACCESS_CHECK)(	IN	PSECURITY_DESCRIPTOR	pSecurityDescriptor,
								IN	HANDLE					hClientToken,
								IN	DWORD					dwDesiredAccess, 
								IN	PGENERIC_MAPPING		GenericMapping, 
								IN	PRIVILEGE_SET*			PrivilegeSet, 
								IN	LPDWORD					PrivilegeSetLength,
								IN	LPDWORD					GrantedAccess, 
								IN	LPBOOL					AccessStatus
								) ;


//
//	This is the externally exposed structure representing a Name Cache - 
//	it doesn't contain any fields usefull for a client, but must be passed
//	back into all of the name cache API's
//
struct	NAME_CACHE_CONTEXT	{
	//
	//	Signature DWORD ! - user must not touch this !
	//
	DWORD		m_dwSignature ;
} ;

typedef	struct	NAME_CACHE_CONTEXT*	PNAME_CACHE_CONTEXT ;

//
//	API's for creating/manging NAME CACHE's
//	NOTE : Name Cache's are reference counted, and if this
//	function is called twice with the same name we will 
//	Add a reference to an existing Name Cache.
//
FILEHC_EXPORT
PNAME_CACHE_CONTEXT	__stdcall
FindOrCreateNameCache(
		//
		//	Must not be NULL ! - this is CASE SENSITVE !
		//
		LPSTR	lpstrName, 
		//
		//	Must not be NULL !
		//
		CACHE_KEY_COMPARE		pfnKeyCompare, 
		//
		//	This may be NULL, in which case the cache will provide one !
		//
		CACHE_KEY_HASH			pfnKeyHash, 
		//
		//	The following two function pointers may be NULL !
		//
		CACHE_DESTROY_CALLBACK	pfnKeyDestroy, 
		CACHE_DESTROY_CALLBACK	pfnDataDestroy
		) ;

//
//	API's for releasing the NAME CACHE !
//
//	The caller must guarantee the thread safety of this call - This function must not 
//	be called if any other thread is simultanesouly executing within 
//	CacheFindContectFromName(), AssociateContextWithName(), AssociateDataWithName(), or InvalidateName() 
//
FILEHC_EXPORT
long	__stdcall
ReleaseNameCache(
		//
		//	Must not be NULL !
		//
		PNAME_CACHE_CONTEXT		pNameCache
		) ;


//
//	API's for setting options on the name cache - this can be used to change
//	how Security is evaluated !
//
FILEHC_EXPORT
BOOL	__stdcall
SetNameCacheSecurityFunction(
		//
		//	Must not be NULL !
		//
		PNAME_CACHE_CONTEXT		pNameCache, 
		//
		//	This is the function pointer that will be used to evaluate security - 
		//	this may be NULL - if it is we will use the Win32 Access Check !
		//
		CACHE_ACCESS_CHECK		pfnAccessCheck
		) ;

//
//	Find the FIO_CONTEXT that is associated with some user name.
//
//	The function returns TRUE if the Name was found in the cache.
//	FALSE if the name was not found in the cache.
//	
//	If the function returns FALSE then the pfnCallback function will not be 
//	called.
//
//	If the function returns TRUE, ppFIOContext may return a NULL pointer, 
//	if the user passed a NULL FIO_CONTEXT to AssociateContextWithName() !
//
//
FILEHC_EXPORT
BOOL	__stdcall
FindContextFromName(
					//
					//	The name cache the client wishes to use !
					//
					PNAME_CACHE_CONTEXT	pNameCache, 
					//
					//	User provides arbitrary bytes for Key to the cache item - pfnKeyCompare() used 
					//	to compare keys !
					//
					IN	LPBYTE	lpbName, 
					IN	DWORD	cbName, 
					//
					//	User provides function which is called with the key once the key comparison
					//	matches the key.  This lets the user do some extra checking that they're getting 
					//	what they want.
					//
					IN	CACHE_READ_CALLBACK	pfnCallback,
					IN	LPVOID	lpvClientContext,
					//
					//	Ask the cache to evaluate the embedded security descriptor
					//	if hToken is 0 then we ignore and security descriptor data 
					//
					IN	HANDLE		hToken,
					IN	ACCESS_MASK	accessMask,
					//
					//	We have a separate mechanism for returning the FIO_CONTEXT
					//	from the cache.
					//
					OUT	FIO_CONTEXT**	ppContext
					) ;


//
//	Find the FIO_CONTEXT that is associated with some user name.
//
//	The function returns TRUE if the Name was found in the cache.
//	FALSE if the name was not found in the cache.
//	
//	If the function returns FALSE then the pfnCallback function will not be 
//	called.
//
//	If the function returns TRUE, ppFIOContext may return a NULL pointer, 
//	if the user passed a NULL FIO_CONTEXT to AssociateContextWithName() !
//
//
FILEHC_EXPORT
BOOL	__stdcall
FindSyncContextFromName(
					//
					//	The name cache the client wishes to use !
					//
					PNAME_CACHE_CONTEXT	pNameCache, 
					//
					//	User provides arbitrary bytes for Key to the cache item - pfnKeyCompare() used 
					//	to compare keys !
					//
					IN	LPBYTE	lpbName, 
					IN	DWORD	cbName, 
					//
					//	User provides function which is called with the key once the key comparison
					//	matches the key.  This lets the user do some extra checking that they're getting 
					//	what they want.
					//
					IN	CACHE_READ_CALLBACK	pfnCallback,
					IN	LPVOID	lpvClientContext,
					//
					//	Ask the cache to evaluate the embedded security descriptor
					//	if hToken is 0 then we ignore and security descriptor data 
					//
					IN	HANDLE		hToken,
					IN	ACCESS_MASK	accessMask,
					//
					//	We have a separate mechanism for returning the FIO_CONTEXT
					//	from the cache.
					//
					OUT	FIO_CONTEXT**	ppContext
					) ;


//
//	Cache Associate context with name !
//	This insert a Name into the Name cache, that will find the specified FIO_CONTEXT !
//
//	If the name is already present in the cache, this will fail with GetLastError()==ERROR_DUP_NAME !
//
FILEHC_EXPORT
BOOL	__stdcall
AssociateContextWithName(	
					//
					//	The name cache the client wishes to use !
					//
					PNAME_CACHE_CONTEXT	pNameCache, 
					//
					//	User provides arbitrary bytes for the Name of the cache item.
					//
					IN	LPBYTE	lpbName, 
					IN	DWORD	cbName, 
					//
					//	User may provide some arbitrary data to assoicate with the name !
					//	
					IN	LPBYTE	lpbData, 
					IN	DWORD	cbData, 
					//
					//	User may provide a self relative security descriptor to 
					//	be associated with the name !
					//
					IN	PGENERIC_MAPPING		pGenericMapping,
					IN	PSECURITY_DESCRIPTOR	pSecurityDescriptor,
					//
					//	User provides the FIO_CONTEXT that the name should reference
					//
					FIO_CONTEXT*		pContext,
					//
					//	User specifies whether they wish to keep their reference on the FIO_CONTEXT
					//
					BOOL				fKeepReference
					) ;

//
//	This function allows the user to remove a single name and all associated data
//	from the name cache.
//
FILEHC_EXPORT
BOOL
InvalidateName(	
					//
					//	The name cache the client wishes to use !
					//
					PNAME_CACHE_CONTEXT	pNameCache, 
					//
					//	User provides arbitrary bytes for the Name of the cache item.
					//
					IN	LPBYTE	lpbName, 
					IN	DWORD	cbName
					) ;
	

//
//	End of Name Cache API's
//----------------------------------------------------------------------------------

//----------------------------------------------------------------------------------
//	DOT STUFFING API's
//

//
//  This function gets an FIO_CONTEXT with the requested state.
//  We may or may not create a new FIO_CONTEXT, if we do create one we'll stick 
//  it into the cache so it can be used again !
//  NOTE: if we have to do work, the user has the only reference to the resulting
//  FIO_CONTEXT which will go away when they call ReleaseContext() !
//
//	pContext - the original FIO_CONTEXT
//	lpstrName - the file name associated with pContext
//	fWantItDotStuffed - if TRUE the resulting FIO_CONTEXT should be dot stuffed !
//	fTerminatorIncluded - if this is TRUE the source FIO_CONTEXT contains a terminating
//	dot that we should be carefull not to stuff !
//
//	NOTE: We may return the same FIO_CONTEXT as the caller provided - in which case
//	an extra reference has been added that needs to be dropped with ReleaseContext() !
//
//
FILEHC_EXPORT
FIO_CONTEXT*	__stdcall
ProduceDotStuffedContext(	IN	FIO_CONTEXT*	pContext,
                            IN  LPSTR           lpstrName,
							IN  BOOL			fWantItDotStuffed // if TRUE add dots, if FALSE remove dots
							) ;

//
//	This function takes a source FIO_CONTEXT (pContextSource) and copies
//	the content into pContextDestination.
//
//	The user specifies whether the Destination FIO_CONTEXT should be dot stuffed
//	with fWantItDotStuffed, and whether the source FIO_CONTEXT includes the 
//	terminating CRLF.CRLF
//
//	The out parameter pfModified is TRUE if there were modifications when
//	Source was copied to Destination !
//
//	The function returns TRUE if successfull, FALSE otherwise !
//
FILEHC_EXPORT
BOOL	__stdcall
ProduceDotStuffedContextInContext(
							IN	FIO_CONTEXT*	pContextSource,
							IN	FIO_CONTEXT*	pContextDestination,
							IN	BOOL			fWantItDotStuffed, 
							OUT	BOOL*			pfModified
							) ;
							



//
//	Find out whether the file has a terminating 'CRLF.CRLF' sequence !
//
FILEHC_EXPORT
BOOL	__stdcall
GetIsFileDotTerminated(	IN	FIO_CONTEXT*	pContext ) ;

//
//	Set whether the file has a terminating 'CRLF.CRLF' sequence !
//
FILEHC_EXPORT
void	__stdcall
SetIsFileDotTerminated(	IN	FIO_CONTEXT*	pContext,
						IN	BOOL			fIsDotTerminated 
						) ;

//
//	Enable dot stuffing properties on the write path of the file
//	handle cache of this message !
//
//	if fEnable is FALSE then all dot stuffing behaviour is turned
//	off.
//
//	if fStripDots is TRUE the File Handle Cache will convert 
//	occurrences of "\r\n." to "\r\n" within your message.
//
//	if fStripDots is FALSE the FileHandle Cache will convert occurrences
//	of "\r\n.." to "\r\n" within your message.
//	
//
FILEHC_EXPORT
BOOL	__stdcall
SetDotStuffingOnWrites(	IN	FIO_CONTEXT*	pContext, 
						//
						//	fEnable == FALSE means ignore fStripDots, and writes are unmodified
						//
						IN	BOOL			fEnable,
						//
						//	fStripDots == TRUE means we remove dots that are dot stuffed, 
						//	fStripDots == FALSE means that we add dots to make the message dot stuffed
						//
						IN	BOOL			fStripDots
						) ;

#if 0 
//
//	This function temporarily disabled !
//
FILEHC_EXPORT
BOOL	__stdcall
SetDotStuffingOnReads(	IN	FIO_CONTEXT*	pContext,
						IN	BOOL			fEnable,
						IN	BOOL			fStripDots
						) ;
#endif

//
//	Enable dot scanning properties on the write path 
//	of the file handle cache for this file !
//
//	if fEnable is TRUE the we will examine each write
//	that goes through us to determine whether the
//	message has any occurrences of "\r\n.".
//
FILEHC_EXPORT
BOOL	__stdcall
SetDotScanningOnWrites(	IN	FIO_CONTEXT*	pContext, 
						IN	BOOL			fEnable
						) ;

//
//	
//	This function should be called when we have finished doing all writes to an FIO_CONTEXT
//	This function should be paired with SetDotStuffingOnWrites() and the fStripDots
//	parameter should be the same as when SetDotStuffingOnWrites() was called.
//
//	We will update the Dot Stuffing State of the FIO_CONTEXT and discard 
//	all dot stuffing memory and stuff that may have been required !
//
//	If this function call is paired with a call to SetDotScanningOnWrites() fStripDots should be TRUE !
//
FILEHC_EXPORT
void	__stdcall
CompleteDotStuffingOnWrites(	IN	FIO_CONTEXT*	pContext, 
								IN	BOOL			fStripDots
								) ;

//
//	This will cause us to examine each read for occurrences of 
//	"\r\n."
//
//	NOTE : the user must use ASYNC Reads for this to work - we will assert
//	if the user tries to pend any synchronous reads while we are in this state !
//
FILEHC_EXPORT
BOOL	__stdcall
SetDotScanningOnReads(	IN	FIO_CONTEXT*	pContext, 
						IN	BOOL			fEnable
						) ;
							

//
//	If any of the dot stuffing mechanism our turned on, 
//	this will get a count of the number of occurrences/modifications
//	have occurred.
//
//	if fReads is TRUE we get the count for occurrences on Read's
//	if fReads is FALSE we get the count for occurrences on Write's
//
//	if dot stuffing was turned off or not enabled somehow then
//	GetDotStuffState() will return FALSE.
//
//	NOTE: A NULL pfStuffed is not allowed !
//
FILEHC_EXPORT
BOOL	__stdcall
GetDotStuffState(		IN	FIO_CONTEXT*	pContext, 
						IN	BOOL			fReads,
						OUT	BOOL*			pfStuffed,
						OUT	BOOL*			pfStoredWithDots
						) ;

//
//	In this case we always assume that the FIO_CONTEXT is not going to be dot stuffed.
//	fRequiresStuffing == TRUE indicates that it SHOULD BE stuffed.
//	fRequiresStuffing == FALSE indicates that the message does not need dot stuffing.
//
FILEHC_EXPORT
void	__stdcall
SetDotStuffState(		IN	FIO_CONTEXT*	pContext, 
						//
						//	fIsStuffed is only relevant when fKnown == TRUE
						//
						IN	BOOL			fKnown,		// We do know the dot stuff state
						//
						//	if fKnown is TRUE then fIsStuffed is meaningfull, when thats the case
						//	if fIsStuffed is TRUE then the message 
						//
						IN	BOOL			fRequiresStuffing// if fKnown is TRUE this arg is meaningfull
						) ;


#ifdef	__cplusplus	
}
#endif



#endif	// _FILEHC_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\faxcom.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0279 */
/* at Sat Sep 25 01:00:16 1999
 */
/* Compiler settings for faxcom.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __faxcom_h__
#define __faxcom_h__

/* Forward Declarations */ 

#ifndef __IFaxTiff_FWD_DEFINED__
#define __IFaxTiff_FWD_DEFINED__
typedef interface IFaxTiff IFaxTiff;
#endif 	/* __IFaxTiff_FWD_DEFINED__ */


#ifndef __IFaxServer_FWD_DEFINED__
#define __IFaxServer_FWD_DEFINED__
typedef interface IFaxServer IFaxServer;
#endif 	/* __IFaxServer_FWD_DEFINED__ */


#ifndef __IFaxPort_FWD_DEFINED__
#define __IFaxPort_FWD_DEFINED__
typedef interface IFaxPort IFaxPort;
#endif 	/* __IFaxPort_FWD_DEFINED__ */


#ifndef __IFaxPorts_FWD_DEFINED__
#define __IFaxPorts_FWD_DEFINED__
typedef interface IFaxPorts IFaxPorts;
#endif 	/* __IFaxPorts_FWD_DEFINED__ */


#ifndef __IFaxRoutingMethod_FWD_DEFINED__
#define __IFaxRoutingMethod_FWD_DEFINED__
typedef interface IFaxRoutingMethod IFaxRoutingMethod;
#endif 	/* __IFaxRoutingMethod_FWD_DEFINED__ */


#ifndef __IFaxRoutingMethods_FWD_DEFINED__
#define __IFaxRoutingMethods_FWD_DEFINED__
typedef interface IFaxRoutingMethods IFaxRoutingMethods;
#endif 	/* __IFaxRoutingMethods_FWD_DEFINED__ */


#ifndef __IFaxStatus_FWD_DEFINED__
#define __IFaxStatus_FWD_DEFINED__
typedef interface IFaxStatus IFaxStatus;
#endif 	/* __IFaxStatus_FWD_DEFINED__ */


#ifndef __IFaxDoc_FWD_DEFINED__
#define __IFaxDoc_FWD_DEFINED__
typedef interface IFaxDoc IFaxDoc;
#endif 	/* __IFaxDoc_FWD_DEFINED__ */


#ifndef __IFaxJobs_FWD_DEFINED__
#define __IFaxJobs_FWD_DEFINED__
typedef interface IFaxJobs IFaxJobs;
#endif 	/* __IFaxJobs_FWD_DEFINED__ */


#ifndef __IFaxJob_FWD_DEFINED__
#define __IFaxJob_FWD_DEFINED__
typedef interface IFaxJob IFaxJob;
#endif 	/* __IFaxJob_FWD_DEFINED__ */


#ifndef __FaxTiff_FWD_DEFINED__
#define __FaxTiff_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxTiff FaxTiff;
#else
typedef struct FaxTiff FaxTiff;
#endif /* __cplusplus */

#endif 	/* __FaxTiff_FWD_DEFINED__ */


#ifndef __FaxServer_FWD_DEFINED__
#define __FaxServer_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxServer FaxServer;
#else
typedef struct FaxServer FaxServer;
#endif /* __cplusplus */

#endif 	/* __FaxServer_FWD_DEFINED__ */


#ifndef __FaxPort_FWD_DEFINED__
#define __FaxPort_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxPort FaxPort;
#else
typedef struct FaxPort FaxPort;
#endif /* __cplusplus */

#endif 	/* __FaxPort_FWD_DEFINED__ */


#ifndef __FaxPorts_FWD_DEFINED__
#define __FaxPorts_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxPorts FaxPorts;
#else
typedef struct FaxPorts FaxPorts;
#endif /* __cplusplus */

#endif 	/* __FaxPorts_FWD_DEFINED__ */


#ifndef __FaxRoutingMethod_FWD_DEFINED__
#define __FaxRoutingMethod_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxRoutingMethod FaxRoutingMethod;
#else
typedef struct FaxRoutingMethod FaxRoutingMethod;
#endif /* __cplusplus */

#endif 	/* __FaxRoutingMethod_FWD_DEFINED__ */


#ifndef __FaxRoutingMethods_FWD_DEFINED__
#define __FaxRoutingMethods_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxRoutingMethods FaxRoutingMethods;
#else
typedef struct FaxRoutingMethods FaxRoutingMethods;
#endif /* __cplusplus */

#endif 	/* __FaxRoutingMethods_FWD_DEFINED__ */


#ifndef __FaxStatus_FWD_DEFINED__
#define __FaxStatus_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxStatus FaxStatus;
#else
typedef struct FaxStatus FaxStatus;
#endif /* __cplusplus */

#endif 	/* __FaxStatus_FWD_DEFINED__ */


#ifndef __FaxDoc_FWD_DEFINED__
#define __FaxDoc_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxDoc FaxDoc;
#else
typedef struct FaxDoc FaxDoc;
#endif /* __cplusplus */

#endif 	/* __FaxDoc_FWD_DEFINED__ */


#ifndef __FaxJobs_FWD_DEFINED__
#define __FaxJobs_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxJobs FaxJobs;
#else
typedef struct FaxJobs FaxJobs;
#endif /* __cplusplus */

#endif 	/* __FaxJobs_FWD_DEFINED__ */


#ifndef __FaxJob_FWD_DEFINED__
#define __FaxJob_FWD_DEFINED__

#ifdef __cplusplus
typedef class FaxJob FaxJob;
#else
typedef struct FaxJob FaxJob;
#endif /* __cplusplus */

#endif 	/* __FaxJob_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __IFaxTiff_INTERFACE_DEFINED__
#define __IFaxTiff_INTERFACE_DEFINED__

/* interface IFaxTiff */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IFaxTiff;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b19bb45f-b91c-11d1-83e1-00c04fb6e984")
    IFaxTiff : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ReceiveTime( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Image( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Image( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RecipientName( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SenderName( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Routing( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CallerId( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Csid( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Tsid( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RecipientNumber( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RawReceiveTime( 
            /* [retval][out] */ VARIANT __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TiffTagString( 
            /* [in] */ WORD tagID,
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFaxTiffVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IFaxTiff __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IFaxTiff __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IFaxTiff __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IFaxTiff __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IFaxTiff __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IFaxTiff __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IFaxTiff __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ReceiveTime )( 
            IFaxTiff __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Image )( 
            IFaxTiff __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Image )( 
            IFaxTiff __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_RecipientName )( 
            IFaxTiff __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SenderName )( 
            IFaxTiff __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Routing )( 
            IFaxTiff __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CallerId )( 
            IFaxTiff __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Csid )( 
            IFaxTiff __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Tsid )( 
            IFaxTiff __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_RecipientNumber )( 
            IFaxTiff __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_RawReceiveTime )( 
            IFaxTiff __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_TiffTagString )( 
            IFaxTiff __RPC_FAR * This,
            /* [in] */ WORD tagID,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        END_INTERFACE
    } IFaxTiffVtbl;

    interface IFaxTiff
    {
        CONST_VTBL struct IFaxTiffVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxTiff_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxTiff_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxTiff_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxTiff_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxTiff_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxTiff_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxTiff_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFaxTiff_get_ReceiveTime(This,pVal)	\
    (This)->lpVtbl -> get_ReceiveTime(This,pVal)

#define IFaxTiff_get_Image(This,pVal)	\
    (This)->lpVtbl -> get_Image(This,pVal)

#define IFaxTiff_put_Image(This,newVal)	\
    (This)->lpVtbl -> put_Image(This,newVal)

#define IFaxTiff_get_RecipientName(This,pVal)	\
    (This)->lpVtbl -> get_RecipientName(This,pVal)

#define IFaxTiff_get_SenderName(This,pVal)	\
    (This)->lpVtbl -> get_SenderName(This,pVal)

#define IFaxTiff_get_Routing(This,pVal)	\
    (This)->lpVtbl -> get_Routing(This,pVal)

#define IFaxTiff_get_CallerId(This,pVal)	\
    (This)->lpVtbl -> get_CallerId(This,pVal)

#define IFaxTiff_get_Csid(This,pVal)	\
    (This)->lpVtbl -> get_Csid(This,pVal)

#define IFaxTiff_get_Tsid(This,pVal)	\
    (This)->lpVtbl -> get_Tsid(This,pVal)

#define IFaxTiff_get_RecipientNumber(This,pVal)	\
    (This)->lpVtbl -> get_RecipientNumber(This,pVal)

#define IFaxTiff_get_RawReceiveTime(This,pVal)	\
    (This)->lpVtbl -> get_RawReceiveTime(This,pVal)

#define IFaxTiff_get_TiffTagString(This,tagID,pVal)	\
    (This)->lpVtbl -> get_TiffTagString(This,tagID,pVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxTiff_get_ReceiveTime_Proxy( 
    IFaxTiff __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IFaxTiff_get_ReceiveTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxTiff_get_Image_Proxy( 
    IFaxTiff __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IFaxTiff_get_Image_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxTiff_put_Image_Proxy( 
    IFaxTiff __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IFaxTiff_put_Image_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxTiff_get_RecipientName_Proxy( 
    IFaxTiff __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IFaxTiff_get_RecipientName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxTiff_get_SenderName_Proxy( 
    IFaxTiff __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IFaxTiff_get_SenderName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxTiff_get_Routing_Proxy( 
    IFaxTiff __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IFaxTiff_get_Routing_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxTiff_get_CallerId_Proxy( 
    IFaxTiff __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IFaxTiff_get_CallerId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxTiff_get_Csid_Proxy( 
    IFaxTiff __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IFaxTiff_get_Csid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxTiff_get_Tsid_Proxy( 
    IFaxTiff __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IFaxTiff_get_Tsid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxTiff_get_RecipientNumber_Proxy( 
    IFaxTiff __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IFaxTiff_get_RecipientNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxTiff_get_RawReceiveTime_Proxy( 
    IFaxTiff __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pVal);


void __RPC_STUB IFaxTiff_get_RawReceiveTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxTiff_get_TiffTagString_Proxy( 
    IFaxTiff __RPC_FAR * This,
    /* [in] */ WORD tagID,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IFaxTiff_get_TiffTagString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFaxTiff_INTERFACE_DEFINED__ */


#ifndef __IFaxServer_INTERFACE_DEFINED__
#define __IFaxServer_INTERFACE_DEFINED__

/* interface IFaxServer */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IFaxServer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D73733C7-CC80-11D0-B225-00C04FB6C2F5")
    IFaxServer : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Connect( 
            BSTR ServerName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Disconnect( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetPorts( 
            /* [retval][out] */ VARIANT __RPC_FAR *retval) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CreateDocument( 
            BSTR FileName,
            /* [retval][out] */ VARIANT __RPC_FAR *retval) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetJobs( 
            /* [retval][out] */ VARIANT __RPC_FAR *retval) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Retries( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Retries( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RetryDelay( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_RetryDelay( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DirtyDays( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_DirtyDays( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Branding( 
            /* [retval][out] */ BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Branding( 
            /* [in] */ BOOL newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_UseDeviceTsid( 
            /* [retval][out] */ BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_UseDeviceTsid( 
            /* [in] */ BOOL newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ServerCoverpage( 
            /* [retval][out] */ BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ServerCoverpage( 
            /* [in] */ BOOL newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PauseServerQueue( 
            /* [retval][out] */ BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_PauseServerQueue( 
            /* [in] */ BOOL newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ArchiveOutboundFaxes( 
            /* [retval][out] */ BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ArchiveOutboundFaxes( 
            /* [in] */ BOOL newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ArchiveDirectory( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ArchiveDirectory( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ServerMapiProfile( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ServerMapiProfile( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DiscountRateStartHour( 
            /* [retval][out] */ short __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_DiscountRateStartHour( 
            /* [in] */ short newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DiscountRateStartMinute( 
            /* [retval][out] */ short __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_DiscountRateStartMinute( 
            /* [in] */ short newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DiscountRateEndHour( 
            /* [retval][out] */ short __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_DiscountRateEndHour( 
            /* [in] */ short newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DiscountRateEndMinute( 
            /* [retval][out] */ short __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_DiscountRateEndMinute( 
            /* [in] */ short newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFaxServerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IFaxServer __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IFaxServer __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IFaxServer __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IFaxServer __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IFaxServer __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IFaxServer __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IFaxServer __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Connect )( 
            IFaxServer __RPC_FAR * This,
            BSTR ServerName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Disconnect )( 
            IFaxServer __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPorts )( 
            IFaxServer __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateDocument )( 
            IFaxServer __RPC_FAR * This,
            BSTR FileName,
            /* [retval][out] */ VARIANT __RPC_FAR *retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetJobs )( 
            IFaxServer __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *retval);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Retries )( 
            IFaxServer __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Retries )( 
            IFaxServer __RPC_FAR * This,
            /* [in] */ long newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_RetryDelay )( 
            IFaxServer __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_RetryDelay )( 
            IFaxServer __RPC_FAR * This,
            /* [in] */ long newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DirtyDays )( 
            IFaxServer __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_DirtyDays )( 
            IFaxServer __RPC_FAR * This,
            /* [in] */ long newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Branding )( 
            IFaxServer __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Branding )( 
            IFaxServer __RPC_FAR * This,
            /* [in] */ BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_UseDeviceTsid )( 
            IFaxServer __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_UseDeviceTsid )( 
            IFaxServer __RPC_FAR * This,
            /* [in] */ BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ServerCoverpage )( 
            IFaxServer __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ServerCoverpage )( 
            IFaxServer __RPC_FAR * This,
            /* [in] */ BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_PauseServerQueue )( 
            IFaxServer __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_PauseServerQueue )( 
            IFaxServer __RPC_FAR * This,
            /* [in] */ BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ArchiveOutboundFaxes )( 
            IFaxServer __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ArchiveOutboundFaxes )( 
            IFaxServer __RPC_FAR * This,
            /* [in] */ BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ArchiveDirectory )( 
            IFaxServer __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ArchiveDirectory )( 
            IFaxServer __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ServerMapiProfile )( 
            IFaxServer __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ServerMapiProfile )( 
            IFaxServer __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DiscountRateStartHour )( 
            IFaxServer __RPC_FAR * This,
            /* [retval][out] */ short __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_DiscountRateStartHour )( 
            IFaxServer __RPC_FAR * This,
            /* [in] */ short newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DiscountRateStartMinute )( 
            IFaxServer __RPC_FAR * This,
            /* [retval][out] */ short __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_DiscountRateStartMinute )( 
            IFaxServer __RPC_FAR * This,
            /* [in] */ short newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DiscountRateEndHour )( 
            IFaxServer __RPC_FAR * This,
            /* [retval][out] */ short __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_DiscountRateEndHour )( 
            IFaxServer __RPC_FAR * This,
            /* [in] */ short newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DiscountRateEndMinute )( 
            IFaxServer __RPC_FAR * This,
            /* [retval][out] */ short __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_DiscountRateEndMinute )( 
            IFaxServer __RPC_FAR * This,
            /* [in] */ short newVal);
        
        END_INTERFACE
    } IFaxServerVtbl;

    interface IFaxServer
    {
        CONST_VTBL struct IFaxServerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxServer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxServer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxServer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxServer_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxServer_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxServer_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxServer_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFaxServer_Connect(This,ServerName)	\
    (This)->lpVtbl -> Connect(This,ServerName)

#define IFaxServer_Disconnect(This)	\
    (This)->lpVtbl -> Disconnect(This)

#define IFaxServer_GetPorts(This,retval)	\
    (This)->lpVtbl -> GetPorts(This,retval)

#define IFaxServer_CreateDocument(This,FileName,retval)	\
    (This)->lpVtbl -> CreateDocument(This,FileName,retval)

#define IFaxServer_GetJobs(This,retval)	\
    (This)->lpVtbl -> GetJobs(This,retval)

#define IFaxServer_get_Retries(This,pVal)	\
    (This)->lpVtbl -> get_Retries(This,pVal)

#define IFaxServer_put_Retries(This,newVal)	\
    (This)->lpVtbl -> put_Retries(This,newVal)

#define IFaxServer_get_RetryDelay(This,pVal)	\
    (This)->lpVtbl -> get_RetryDelay(This,pVal)

#define IFaxServer_put_RetryDelay(This,newVal)	\
    (This)->lpVtbl -> put_RetryDelay(This,newVal)

#define IFaxServer_get_DirtyDays(This,pVal)	\
    (This)->lpVtbl -> get_DirtyDays(This,pVal)

#define IFaxServer_put_DirtyDays(This,newVal)	\
    (This)->lpVtbl -> put_DirtyDays(This,newVal)

#define IFaxServer_get_Branding(This,pVal)	\
    (This)->lpVtbl -> get_Branding(This,pVal)

#define IFaxServer_put_Branding(This,newVal)	\
    (This)->lpVtbl -> put_Branding(This,newVal)

#define IFaxServer_get_UseDeviceTsid(This,pVal)	\
    (This)->lpVtbl -> get_UseDeviceTsid(This,pVal)

#define IFaxServer_put_UseDeviceTsid(This,newVal)	\
    (This)->lpVtbl -> put_UseDeviceTsid(This,newVal)

#define IFaxServer_get_ServerCoverpage(This,pVal)	\
    (This)->lpVtbl -> get_ServerCoverpage(This,pVal)

#define IFaxServer_put_ServerCoverpage(This,newVal)	\
    (This)->lpVtbl -> put_ServerCoverpage(This,newVal)

#define IFaxServer_get_PauseServerQueue(This,pVal)	\
    (This)->lpVtbl -> get_PauseServerQueue(This,pVal)

#define IFaxServer_put_PauseServerQueue(This,newVal)	\
    (This)->lpVtbl -> put_PauseServerQueue(This,newVal)

#define IFaxServer_get_ArchiveOutboundFaxes(This,pVal)	\
    (This)->lpVtbl -> get_ArchiveOutboundFaxes(This,pVal)

#define IFaxServer_put_ArchiveOutboundFaxes(This,newVal)	\
    (This)->lpVtbl -> put_ArchiveOutboundFaxes(This,newVal)

#define IFaxServer_get_ArchiveDirectory(This,pVal)	\
    (This)->lpVtbl -> get_ArchiveDirectory(This,pVal)

#define IFaxServer_put_ArchiveDirectory(This,newVal)	\
    (This)->lpVtbl -> put_ArchiveDirectory(This,newVal)

#define IFaxServer_get_ServerMapiProfile(This,pVal)	\
    (This)->lpVtbl -> get_ServerMapiProfile(This,pVal)

#define IFaxServer_put_ServerMapiProfile(This,newVal)	\
    (This)->lpVtbl -> put_ServerMapiProfile(This,newVal)

#define IFaxServer_get_DiscountRateStartHour(This,pVal)	\
    (This)->lpVtbl -> get_DiscountRateStartHour(This,pVal)

#define IFaxServer_put_DiscountRateStartHour(This,newVal)	\
    (This)->lpVtbl -> put_DiscountRateStartHour(This,newVal)

#define IFaxServer_get_DiscountRateStartMinute(This,pVal)	\
    (This)->lpVtbl -> get_DiscountRateStartMinute(This,pVal)

#define IFaxServer_put_DiscountRateStartMinute(This,newVal)	\
    (This)->lpVtbl -> put_DiscountRateStartMinute(This,newVal)

#define IFaxServer_get_DiscountRateEndHour(This,pVal)	\
    (This)->lpVtbl -> get_DiscountRateEndHour(This,pVal)

#define IFaxServer_put_DiscountRateEndHour(This,newVal)	\
    (This)->lpVtbl -> put_DiscountRateEndHour(This,newVal)

#define IFaxServer_get_DiscountRateEndMinute(This,pVal)	\
    (This)->lpVtbl -> get_DiscountRateEndMinute(This,pVal)

#define IFaxServer_put_DiscountRateEndMinute(This,newVal)	\
    (This)->lpVtbl -> put_DiscountRateEndMinute(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxServer_Connect_Proxy( 
    IFaxServer __RPC_FAR * This,
    BSTR ServerName);


void __RPC_STUB IFaxServer_Connect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxServer_Disconnect_Proxy( 
    IFaxServer __RPC_FAR * This);


void __RPC_STUB IFaxServer_Disconnect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxServer_GetPorts_Proxy( 
    IFaxServer __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *retval);


void __RPC_STUB IFaxServer_GetPorts_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxServer_CreateDocument_Proxy( 
    IFaxServer __RPC_FAR * This,
    BSTR FileName,
    /* [retval][out] */ VARIANT __RPC_FAR *retval);


void __RPC_STUB IFaxServer_CreateDocument_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxServer_GetJobs_Proxy( 
    IFaxServer __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *retval);


void __RPC_STUB IFaxServer_GetJobs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxServer_get_Retries_Proxy( 
    IFaxServer __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IFaxServer_get_Retries_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxServer_put_Retries_Proxy( 
    IFaxServer __RPC_FAR * This,
    /* [in] */ long newVal);


void __RPC_STUB IFaxServer_put_Retries_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxServer_get_RetryDelay_Proxy( 
    IFaxServer __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IFaxServer_get_RetryDelay_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxServer_put_RetryDelay_Proxy( 
    IFaxServer __RPC_FAR * This,
    /* [in] */ long newVal);


void __RPC_STUB IFaxServer_put_RetryDelay_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxServer_get_DirtyDays_Proxy( 
    IFaxServer __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IFaxServer_get_DirtyDays_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxServer_put_DirtyDays_Proxy( 
    IFaxServer __RPC_FAR * This,
    /* [in] */ long newVal);


void __RPC_STUB IFaxServer_put_DirtyDays_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxServer_get_Branding_Proxy( 
    IFaxServer __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pVal);


void __RPC_STUB IFaxServer_get_Branding_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxServer_put_Branding_Proxy( 
    IFaxServer __RPC_FAR * This,
    /* [in] */ BOOL newVal);


void __RPC_STUB IFaxServer_put_Branding_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxServer_get_UseDeviceTsid_Proxy( 
    IFaxServer __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pVal);


void __RPC_STUB IFaxServer_get_UseDeviceTsid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxServer_put_UseDeviceTsid_Proxy( 
    IFaxServer __RPC_FAR * This,
    /* [in] */ BOOL newVal);


void __RPC_STUB IFaxServer_put_UseDeviceTsid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxServer_get_ServerCoverpage_Proxy( 
    IFaxServer __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pVal);


void __RPC_STUB IFaxServer_get_ServerCoverpage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxServer_put_ServerCoverpage_Proxy( 
    IFaxServer __RPC_FAR * This,
    /* [in] */ BOOL newVal);


void __RPC_STUB IFaxServer_put_ServerCoverpage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxServer_get_PauseServerQueue_Proxy( 
    IFaxServer __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pVal);


void __RPC_STUB IFaxServer_get_PauseServerQueue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxServer_put_PauseServerQueue_Proxy( 
    IFaxServer __RPC_FAR * This,
    /* [in] */ BOOL newVal);


void __RPC_STUB IFaxServer_put_PauseServerQueue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxServer_get_ArchiveOutboundFaxes_Proxy( 
    IFaxServer __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pVal);


void __RPC_STUB IFaxServer_get_ArchiveOutboundFaxes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxServer_put_ArchiveOutboundFaxes_Proxy( 
    IFaxServer __RPC_FAR * This,
    /* [in] */ BOOL newVal);


void __RPC_STUB IFaxServer_put_ArchiveOutboundFaxes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxServer_get_ArchiveDirectory_Proxy( 
    IFaxServer __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IFaxServer_get_ArchiveDirectory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxServer_put_ArchiveDirectory_Proxy( 
    IFaxServer __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IFaxServer_put_ArchiveDirectory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxServer_get_ServerMapiProfile_Proxy( 
    IFaxServer __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IFaxServer_get_ServerMapiProfile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxServer_put_ServerMapiProfile_Proxy( 
    IFaxServer __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IFaxServer_put_ServerMapiProfile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxServer_get_DiscountRateStartHour_Proxy( 
    IFaxServer __RPC_FAR * This,
    /* [retval][out] */ short __RPC_FAR *pVal);


void __RPC_STUB IFaxServer_get_DiscountRateStartHour_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxServer_put_DiscountRateStartHour_Proxy( 
    IFaxServer __RPC_FAR * This,
    /* [in] */ short newVal);


void __RPC_STUB IFaxServer_put_DiscountRateStartHour_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxServer_get_DiscountRateStartMinute_Proxy( 
    IFaxServer __RPC_FAR * This,
    /* [retval][out] */ short __RPC_FAR *pVal);


void __RPC_STUB IFaxServer_get_DiscountRateStartMinute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxServer_put_DiscountRateStartMinute_Proxy( 
    IFaxServer __RPC_FAR * This,
    /* [in] */ short newVal);


void __RPC_STUB IFaxServer_put_DiscountRateStartMinute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxServer_get_DiscountRateEndHour_Proxy( 
    IFaxServer __RPC_FAR * This,
    /* [retval][out] */ short __RPC_FAR *pVal);


void __RPC_STUB IFaxServer_get_DiscountRateEndHour_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxServer_put_DiscountRateEndHour_Proxy( 
    IFaxServer __RPC_FAR * This,
    /* [in] */ short newVal);


void __RPC_STUB IFaxServer_put_DiscountRateEndHour_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxServer_get_DiscountRateEndMinute_Proxy( 
    IFaxServer __RPC_FAR * This,
    /* [retval][out] */ short __RPC_FAR *pVal);


void __RPC_STUB IFaxServer_get_DiscountRateEndMinute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxServer_put_DiscountRateEndMinute_Proxy( 
    IFaxServer __RPC_FAR * This,
    /* [in] */ short newVal);


void __RPC_STUB IFaxServer_put_DiscountRateEndMinute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFaxServer_INTERFACE_DEFINED__ */


#ifndef __IFaxPort_INTERFACE_DEFINED__
#define __IFaxPort_INTERFACE_DEFINED__

/* interface IFaxPort */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IFaxPort;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D73733CC-CC80-11D0-B225-00C04FB6C2F5")
    IFaxPort : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DeviceId( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Rings( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Rings( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Csid( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Csid( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Tsid( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Tsid( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Send( 
            /* [retval][out] */ BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Send( 
            /* [in] */ BOOL newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Receive( 
            /* [retval][out] */ BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Receive( 
            /* [in] */ BOOL newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Priority( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Priority( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetRoutingMethods( 
            /* [retval][out] */ VARIANT __RPC_FAR *retval) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CanModify( 
            /* [retval][out] */ BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetStatus( 
            /* [retval][out] */ VARIANT __RPC_FAR *retval) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFaxPortVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IFaxPort __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IFaxPort __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IFaxPort __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IFaxPort __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IFaxPort __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IFaxPort __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IFaxPort __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )( 
            IFaxPort __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DeviceId )( 
            IFaxPort __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Rings )( 
            IFaxPort __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Rings )( 
            IFaxPort __RPC_FAR * This,
            /* [in] */ long newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Csid )( 
            IFaxPort __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Csid )( 
            IFaxPort __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Tsid )( 
            IFaxPort __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Tsid )( 
            IFaxPort __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Send )( 
            IFaxPort __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Send )( 
            IFaxPort __RPC_FAR * This,
            /* [in] */ BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Receive )( 
            IFaxPort __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Receive )( 
            IFaxPort __RPC_FAR * This,
            /* [in] */ BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Priority )( 
            IFaxPort __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Priority )( 
            IFaxPort __RPC_FAR * This,
            /* [in] */ long newVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRoutingMethods )( 
            IFaxPort __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *retval);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CanModify )( 
            IFaxPort __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStatus )( 
            IFaxPort __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *retval);
        
        END_INTERFACE
    } IFaxPortVtbl;

    interface IFaxPort
    {
        CONST_VTBL struct IFaxPortVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxPort_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxPort_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxPort_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxPort_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxPort_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxPort_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxPort_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFaxPort_get_Name(This,pVal)	\
    (This)->lpVtbl -> get_Name(This,pVal)

#define IFaxPort_get_DeviceId(This,pVal)	\
    (This)->lpVtbl -> get_DeviceId(This,pVal)

#define IFaxPort_get_Rings(This,pVal)	\
    (This)->lpVtbl -> get_Rings(This,pVal)

#define IFaxPort_put_Rings(This,newVal)	\
    (This)->lpVtbl -> put_Rings(This,newVal)

#define IFaxPort_get_Csid(This,pVal)	\
    (This)->lpVtbl -> get_Csid(This,pVal)

#define IFaxPort_put_Csid(This,newVal)	\
    (This)->lpVtbl -> put_Csid(This,newVal)

#define IFaxPort_get_Tsid(This,pVal)	\
    (This)->lpVtbl -> get_Tsid(This,pVal)

#define IFaxPort_put_Tsid(This,newVal)	\
    (This)->lpVtbl -> put_Tsid(This,newVal)

#define IFaxPort_get_Send(This,pVal)	\
    (This)->lpVtbl -> get_Send(This,pVal)

#define IFaxPort_put_Send(This,newVal)	\
    (This)->lpVtbl -> put_Send(This,newVal)

#define IFaxPort_get_Receive(This,pVal)	\
    (This)->lpVtbl -> get_Receive(This,pVal)

#define IFaxPort_put_Receive(This,newVal)	\
    (This)->lpVtbl -> put_Receive(This,newVal)

#define IFaxPort_get_Priority(This,pVal)	\
    (This)->lpVtbl -> get_Priority(This,pVal)

#define IFaxPort_put_Priority(This,newVal)	\
    (This)->lpVtbl -> put_Priority(This,newVal)

#define IFaxPort_GetRoutingMethods(This,retval)	\
    (This)->lpVtbl -> GetRoutingMethods(This,retval)

#define IFaxPort_get_CanModify(This,pVal)	\
    (This)->lpVtbl -> get_CanModify(This,pVal)

#define IFaxPort_GetStatus(This,retval)	\
    (This)->lpVtbl -> GetStatus(This,retval)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxPort_get_Name_Proxy( 
    IFaxPort __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IFaxPort_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxPort_get_DeviceId_Proxy( 
    IFaxPort __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IFaxPort_get_DeviceId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxPort_get_Rings_Proxy( 
    IFaxPort __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IFaxPort_get_Rings_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxPort_put_Rings_Proxy( 
    IFaxPort __RPC_FAR * This,
    /* [in] */ long newVal);


void __RPC_STUB IFaxPort_put_Rings_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxPort_get_Csid_Proxy( 
    IFaxPort __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IFaxPort_get_Csid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxPort_put_Csid_Proxy( 
    IFaxPort __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IFaxPort_put_Csid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxPort_get_Tsid_Proxy( 
    IFaxPort __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IFaxPort_get_Tsid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxPort_put_Tsid_Proxy( 
    IFaxPort __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IFaxPort_put_Tsid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxPort_get_Send_Proxy( 
    IFaxPort __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pVal);


void __RPC_STUB IFaxPort_get_Send_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxPort_put_Send_Proxy( 
    IFaxPort __RPC_FAR * This,
    /* [in] */ BOOL newVal);


void __RPC_STUB IFaxPort_put_Send_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxPort_get_Receive_Proxy( 
    IFaxPort __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pVal);


void __RPC_STUB IFaxPort_get_Receive_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxPort_put_Receive_Proxy( 
    IFaxPort __RPC_FAR * This,
    /* [in] */ BOOL newVal);


void __RPC_STUB IFaxPort_put_Receive_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxPort_get_Priority_Proxy( 
    IFaxPort __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IFaxPort_get_Priority_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxPort_put_Priority_Proxy( 
    IFaxPort __RPC_FAR * This,
    /* [in] */ long newVal);


void __RPC_STUB IFaxPort_put_Priority_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxPort_GetRoutingMethods_Proxy( 
    IFaxPort __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *retval);


void __RPC_STUB IFaxPort_GetRoutingMethods_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxPort_get_CanModify_Proxy( 
    IFaxPort __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pVal);


void __RPC_STUB IFaxPort_get_CanModify_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxPort_GetStatus_Proxy( 
    IFaxPort __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *retval);


void __RPC_STUB IFaxPort_GetStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFaxPort_INTERFACE_DEFINED__ */


#ifndef __IFaxPorts_INTERFACE_DEFINED__
#define __IFaxPorts_INTERFACE_DEFINED__

/* interface IFaxPorts */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IFaxPorts;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D73733D5-CC80-11D0-B225-00C04FB6C2F5")
    IFaxPorts : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            long Index,
            /* [retval][out] */ VARIANT __RPC_FAR *pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFaxPortsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IFaxPorts __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IFaxPorts __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IFaxPorts __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IFaxPorts __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IFaxPorts __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IFaxPorts __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IFaxPorts __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            IFaxPorts __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Item )( 
            IFaxPorts __RPC_FAR * This,
            long Index,
            /* [retval][out] */ VARIANT __RPC_FAR *pVal);
        
        END_INTERFACE
    } IFaxPortsVtbl;

    interface IFaxPorts
    {
        CONST_VTBL struct IFaxPortsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxPorts_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxPorts_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxPorts_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxPorts_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxPorts_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxPorts_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxPorts_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFaxPorts_get_Count(This,pVal)	\
    (This)->lpVtbl -> get_Count(This,pVal)

#define IFaxPorts_get_Item(This,Index,pVal)	\
    (This)->lpVtbl -> get_Item(This,Index,pVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxPorts_get_Count_Proxy( 
    IFaxPorts __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IFaxPorts_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxPorts_get_Item_Proxy( 
    IFaxPorts __RPC_FAR * This,
    long Index,
    /* [retval][out] */ VARIANT __RPC_FAR *pVal);


void __RPC_STUB IFaxPorts_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFaxPorts_INTERFACE_DEFINED__ */


#ifndef __IFaxRoutingMethod_INTERFACE_DEFINED__
#define __IFaxRoutingMethod_INTERFACE_DEFINED__

/* interface IFaxRoutingMethod */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IFaxRoutingMethod;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2199F5F3-CEFC-11D0-A341-0000F800E68D")
    IFaxRoutingMethod : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DeviceId( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Enable( 
            /* [retval][out] */ BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Enable( 
            /* [in] */ BOOL newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DeviceName( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Guid( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_FunctionName( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ImageName( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_FriendlyName( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ExtensionName( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RoutingData( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFaxRoutingMethodVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IFaxRoutingMethod __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IFaxRoutingMethod __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IFaxRoutingMethod __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IFaxRoutingMethod __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IFaxRoutingMethod __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IFaxRoutingMethod __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IFaxRoutingMethod __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DeviceId )( 
            IFaxRoutingMethod __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Enable )( 
            IFaxRoutingMethod __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Enable )( 
            IFaxRoutingMethod __RPC_FAR * This,
            /* [in] */ BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DeviceName )( 
            IFaxRoutingMethod __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Guid )( 
            IFaxRoutingMethod __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_FunctionName )( 
            IFaxRoutingMethod __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ImageName )( 
            IFaxRoutingMethod __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_FriendlyName )( 
            IFaxRoutingMethod __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ExtensionName )( 
            IFaxRoutingMethod __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_RoutingData )( 
            IFaxRoutingMethod __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        END_INTERFACE
    } IFaxRoutingMethodVtbl;

    interface IFaxRoutingMethod
    {
        CONST_VTBL struct IFaxRoutingMethodVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxRoutingMethod_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxRoutingMethod_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxRoutingMethod_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxRoutingMethod_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxRoutingMethod_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxRoutingMethod_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxRoutingMethod_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFaxRoutingMethod_get_DeviceId(This,pVal)	\
    (This)->lpVtbl -> get_DeviceId(This,pVal)

#define IFaxRoutingMethod_get_Enable(This,pVal)	\
    (This)->lpVtbl -> get_Enable(This,pVal)

#define IFaxRoutingMethod_put_Enable(This,newVal)	\
    (This)->lpVtbl -> put_Enable(This,newVal)

#define IFaxRoutingMethod_get_DeviceName(This,pVal)	\
    (This)->lpVtbl -> get_DeviceName(This,pVal)

#define IFaxRoutingMethod_get_Guid(This,pVal)	\
    (This)->lpVtbl -> get_Guid(This,pVal)

#define IFaxRoutingMethod_get_FunctionName(This,pVal)	\
    (This)->lpVtbl -> get_FunctionName(This,pVal)

#define IFaxRoutingMethod_get_ImageName(This,pVal)	\
    (This)->lpVtbl -> get_ImageName(This,pVal)

#define IFaxRoutingMethod_get_FriendlyName(This,pVal)	\
    (This)->lpVtbl -> get_FriendlyName(This,pVal)

#define IFaxRoutingMethod_get_ExtensionName(This,pVal)	\
    (This)->lpVtbl -> get_ExtensionName(This,pVal)

#define IFaxRoutingMethod_get_RoutingData(This,pVal)	\
    (This)->lpVtbl -> get_RoutingData(This,pVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxRoutingMethod_get_DeviceId_Proxy( 
    IFaxRoutingMethod __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IFaxRoutingMethod_get_DeviceId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxRoutingMethod_get_Enable_Proxy( 
    IFaxRoutingMethod __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pVal);


void __RPC_STUB IFaxRoutingMethod_get_Enable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxRoutingMethod_put_Enable_Proxy( 
    IFaxRoutingMethod __RPC_FAR * This,
    /* [in] */ BOOL newVal);


void __RPC_STUB IFaxRoutingMethod_put_Enable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxRoutingMethod_get_DeviceName_Proxy( 
    IFaxRoutingMethod __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IFaxRoutingMethod_get_DeviceName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxRoutingMethod_get_Guid_Proxy( 
    IFaxRoutingMethod __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IFaxRoutingMethod_get_Guid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxRoutingMethod_get_FunctionName_Proxy( 
    IFaxRoutingMethod __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IFaxRoutingMethod_get_FunctionName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxRoutingMethod_get_ImageName_Proxy( 
    IFaxRoutingMethod __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IFaxRoutingMethod_get_ImageName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxRoutingMethod_get_FriendlyName_Proxy( 
    IFaxRoutingMethod __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IFaxRoutingMethod_get_FriendlyName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxRoutingMethod_get_ExtensionName_Proxy( 
    IFaxRoutingMethod __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IFaxRoutingMethod_get_ExtensionName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxRoutingMethod_get_RoutingData_Proxy( 
    IFaxRoutingMethod __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IFaxRoutingMethod_get_RoutingData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFaxRoutingMethod_INTERFACE_DEFINED__ */


#ifndef __IFaxRoutingMethods_INTERFACE_DEFINED__
#define __IFaxRoutingMethods_INTERFACE_DEFINED__

/* interface IFaxRoutingMethods */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IFaxRoutingMethods;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2199F5F5-CEFC-11D0-A341-0000F800E68D")
    IFaxRoutingMethods : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ long Index,
            /* [retval][out] */ VARIANT __RPC_FAR *pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFaxRoutingMethodsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IFaxRoutingMethods __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IFaxRoutingMethods __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IFaxRoutingMethods __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IFaxRoutingMethods __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IFaxRoutingMethods __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IFaxRoutingMethods __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IFaxRoutingMethods __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            IFaxRoutingMethods __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Item )( 
            IFaxRoutingMethods __RPC_FAR * This,
            /* [in] */ long Index,
            /* [retval][out] */ VARIANT __RPC_FAR *pVal);
        
        END_INTERFACE
    } IFaxRoutingMethodsVtbl;

    interface IFaxRoutingMethods
    {
        CONST_VTBL struct IFaxRoutingMethodsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxRoutingMethods_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxRoutingMethods_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxRoutingMethods_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxRoutingMethods_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxRoutingMethods_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxRoutingMethods_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxRoutingMethods_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFaxRoutingMethods_get_Count(This,pVal)	\
    (This)->lpVtbl -> get_Count(This,pVal)

#define IFaxRoutingMethods_get_Item(This,Index,pVal)	\
    (This)->lpVtbl -> get_Item(This,Index,pVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxRoutingMethods_get_Count_Proxy( 
    IFaxRoutingMethods __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IFaxRoutingMethods_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxRoutingMethods_get_Item_Proxy( 
    IFaxRoutingMethods __RPC_FAR * This,
    /* [in] */ long Index,
    /* [retval][out] */ VARIANT __RPC_FAR *pVal);


void __RPC_STUB IFaxRoutingMethods_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFaxRoutingMethods_INTERFACE_DEFINED__ */


#ifndef __IFaxStatus_INTERFACE_DEFINED__
#define __IFaxStatus_INTERFACE_DEFINED__

/* interface IFaxStatus */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IFaxStatus;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8B97E605-D054-11D0-B226-00C04FB6C2F5")
    IFaxStatus : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CallerId( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Csid( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CurrentPage( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DeviceId( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DeviceName( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DocumentName( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Send( 
            /* [retval][out] */ BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Receive( 
            /* [retval][out] */ BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Address( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RoutingString( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SenderName( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RecipientName( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DocumentSize( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Description( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PageCount( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Tsid( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_StartTime( 
            /* [retval][out] */ DATE __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SubmittedTime( 
            /* [retval][out] */ DATE __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ElapsedTime( 
            /* [retval][out] */ DATE __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Refresh( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFaxStatusVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IFaxStatus __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IFaxStatus __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IFaxStatus __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IFaxStatus __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IFaxStatus __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IFaxStatus __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IFaxStatus __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CallerId )( 
            IFaxStatus __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Csid )( 
            IFaxStatus __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CurrentPage )( 
            IFaxStatus __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DeviceId )( 
            IFaxStatus __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DeviceName )( 
            IFaxStatus __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DocumentName )( 
            IFaxStatus __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Send )( 
            IFaxStatus __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Receive )( 
            IFaxStatus __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Address )( 
            IFaxStatus __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_RoutingString )( 
            IFaxStatus __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SenderName )( 
            IFaxStatus __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_RecipientName )( 
            IFaxStatus __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DocumentSize )( 
            IFaxStatus __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Description )( 
            IFaxStatus __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_PageCount )( 
            IFaxStatus __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Tsid )( 
            IFaxStatus __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StartTime )( 
            IFaxStatus __RPC_FAR * This,
            /* [retval][out] */ DATE __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SubmittedTime )( 
            IFaxStatus __RPC_FAR * This,
            /* [retval][out] */ DATE __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ElapsedTime )( 
            IFaxStatus __RPC_FAR * This,
            /* [retval][out] */ DATE __RPC_FAR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Refresh )( 
            IFaxStatus __RPC_FAR * This);
        
        END_INTERFACE
    } IFaxStatusVtbl;

    interface IFaxStatus
    {
        CONST_VTBL struct IFaxStatusVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxStatus_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxStatus_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxStatus_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxStatus_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxStatus_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxStatus_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxStatus_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFaxStatus_get_CallerId(This,pVal)	\
    (This)->lpVtbl -> get_CallerId(This,pVal)

#define IFaxStatus_get_Csid(This,pVal)	\
    (This)->lpVtbl -> get_Csid(This,pVal)

#define IFaxStatus_get_CurrentPage(This,pVal)	\
    (This)->lpVtbl -> get_CurrentPage(This,pVal)

#define IFaxStatus_get_DeviceId(This,pVal)	\
    (This)->lpVtbl -> get_DeviceId(This,pVal)

#define IFaxStatus_get_DeviceName(This,pVal)	\
    (This)->lpVtbl -> get_DeviceName(This,pVal)

#define IFaxStatus_get_DocumentName(This,pVal)	\
    (This)->lpVtbl -> get_DocumentName(This,pVal)

#define IFaxStatus_get_Send(This,pVal)	\
    (This)->lpVtbl -> get_Send(This,pVal)

#define IFaxStatus_get_Receive(This,pVal)	\
    (This)->lpVtbl -> get_Receive(This,pVal)

#define IFaxStatus_get_Address(This,pVal)	\
    (This)->lpVtbl -> get_Address(This,pVal)

#define IFaxStatus_get_RoutingString(This,pVal)	\
    (This)->lpVtbl -> get_RoutingString(This,pVal)

#define IFaxStatus_get_SenderName(This,pVal)	\
    (This)->lpVtbl -> get_SenderName(This,pVal)

#define IFaxStatus_get_RecipientName(This,pVal)	\
    (This)->lpVtbl -> get_RecipientName(This,pVal)

#define IFaxStatus_get_DocumentSize(This,pVal)	\
    (This)->lpVtbl -> get_DocumentSize(This,pVal)

#define IFaxStatus_get_Description(This,pVal)	\
    (This)->lpVtbl -> get_Description(This,pVal)

#define IFaxStatus_get_PageCount(This,pVal)	\
    (This)->lpVtbl -> get_PageCount(This,pVal)

#define IFaxStatus_get_Tsid(This,pVal)	\
    (This)->lpVtbl -> get_Tsid(This,pVal)

#define IFaxStatus_get_StartTime(This,pVal)	\
    (This)->lpVtbl -> get_StartTime(This,pVal)

#define IFaxStatus_get_SubmittedTime(This,pVal)	\
    (This)->lpVtbl -> get_SubmittedTime(This,pVal)

#define IFaxStatus_get_ElapsedTime(This,pVal)	\
    (This)->lpVtbl -> get_ElapsedTime(This,pVal)

#define IFaxStatus_Refresh(This)	\
    (This)->lpVtbl -> Refresh(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxStatus_get_CallerId_Proxy( 
    IFaxStatus __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IFaxStatus_get_CallerId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxStatus_get_Csid_Proxy( 
    IFaxStatus __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IFaxStatus_get_Csid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxStatus_get_CurrentPage_Proxy( 
    IFaxStatus __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IFaxStatus_get_CurrentPage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxStatus_get_DeviceId_Proxy( 
    IFaxStatus __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IFaxStatus_get_DeviceId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxStatus_get_DeviceName_Proxy( 
    IFaxStatus __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IFaxStatus_get_DeviceName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxStatus_get_DocumentName_Proxy( 
    IFaxStatus __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IFaxStatus_get_DocumentName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxStatus_get_Send_Proxy( 
    IFaxStatus __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pVal);


void __RPC_STUB IFaxStatus_get_Send_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxStatus_get_Receive_Proxy( 
    IFaxStatus __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pVal);


void __RPC_STUB IFaxStatus_get_Receive_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxStatus_get_Address_Proxy( 
    IFaxStatus __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IFaxStatus_get_Address_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxStatus_get_RoutingString_Proxy( 
    IFaxStatus __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IFaxStatus_get_RoutingString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxStatus_get_SenderName_Proxy( 
    IFaxStatus __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IFaxStatus_get_SenderName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxStatus_get_RecipientName_Proxy( 
    IFaxStatus __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IFaxStatus_get_RecipientName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxStatus_get_DocumentSize_Proxy( 
    IFaxStatus __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IFaxStatus_get_DocumentSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxStatus_get_Description_Proxy( 
    IFaxStatus __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IFaxStatus_get_Description_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxStatus_get_PageCount_Proxy( 
    IFaxStatus __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IFaxStatus_get_PageCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxStatus_get_Tsid_Proxy( 
    IFaxStatus __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IFaxStatus_get_Tsid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxStatus_get_StartTime_Proxy( 
    IFaxStatus __RPC_FAR * This,
    /* [retval][out] */ DATE __RPC_FAR *pVal);


void __RPC_STUB IFaxStatus_get_StartTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxStatus_get_SubmittedTime_Proxy( 
    IFaxStatus __RPC_FAR * This,
    /* [retval][out] */ DATE __RPC_FAR *pVal);


void __RPC_STUB IFaxStatus_get_SubmittedTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxStatus_get_ElapsedTime_Proxy( 
    IFaxStatus __RPC_FAR * This,
    /* [retval][out] */ DATE __RPC_FAR *pVal);


void __RPC_STUB IFaxStatus_get_ElapsedTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxStatus_Refresh_Proxy( 
    IFaxStatus __RPC_FAR * This);


void __RPC_STUB IFaxStatus_Refresh_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFaxStatus_INTERFACE_DEFINED__ */


#ifndef __IFaxDoc_INTERFACE_DEFINED__
#define __IFaxDoc_INTERFACE_DEFINED__

/* interface IFaxDoc */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IFaxDoc;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FA21F4C5-5C4C-11D1-83CF-00C04FB6E984")
    IFaxDoc : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_FileName( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_FileName( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CoverpageName( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_CoverpageName( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SendCoverpage( 
            /* [retval][out] */ BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_SendCoverpage( 
            /* [in] */ BOOL newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ServerCoverpage( 
            /* [retval][out] */ BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ServerCoverpage( 
            /* [in] */ BOOL newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DiscountSend( 
            /* [retval][out] */ BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_DiscountSend( 
            /* [in] */ BOOL newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RecipientName( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_RecipientName( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RecipientCompany( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_RecipientCompany( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RecipientAddress( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_RecipientAddress( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RecipientCity( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_RecipientCity( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RecipientState( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_RecipientState( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RecipientZip( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_RecipientZip( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RecipientCountry( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_RecipientCountry( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RecipientTitle( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_RecipientTitle( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RecipientDepartment( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_RecipientDepartment( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RecipientOffice( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_RecipientOffice( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RecipientHomePhone( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_RecipientHomePhone( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RecipientOfficePhone( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_RecipientOfficePhone( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SenderName( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_SenderName( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SenderCompany( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_SenderCompany( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SenderAddress( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_SenderAddress( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SenderTitle( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_SenderTitle( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SenderDepartment( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_SenderDepartment( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SenderOffice( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_SenderOffice( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SenderHomePhone( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_SenderHomePhone( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SenderOfficePhone( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_SenderOfficePhone( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CoverpageNote( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_CoverpageNote( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CoverpageSubject( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_CoverpageSubject( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Tsid( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Tsid( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_BillingCode( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_BillingCode( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_EmailAddress( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_EmailAddress( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DisplayName( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_DisplayName( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Send( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_FaxNumber( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_FaxNumber( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propputref] */ HRESULT STDMETHODCALLTYPE putref_ConnectionObject( 
            /* [in] */ IDispatch __RPC_FAR *newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CallHandle( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_CallHandle( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SenderFax( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_SenderFax( 
            /* [in] */ BSTR newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFaxDocVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IFaxDoc __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IFaxDoc __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IFaxDoc __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IFaxDoc __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IFaxDoc __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IFaxDoc __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IFaxDoc __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_FileName )( 
            IFaxDoc __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_FileName )( 
            IFaxDoc __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CoverpageName )( 
            IFaxDoc __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_CoverpageName )( 
            IFaxDoc __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SendCoverpage )( 
            IFaxDoc __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_SendCoverpage )( 
            IFaxDoc __RPC_FAR * This,
            /* [in] */ BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ServerCoverpage )( 
            IFaxDoc __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ServerCoverpage )( 
            IFaxDoc __RPC_FAR * This,
            /* [in] */ BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DiscountSend )( 
            IFaxDoc __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_DiscountSend )( 
            IFaxDoc __RPC_FAR * This,
            /* [in] */ BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_RecipientName )( 
            IFaxDoc __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_RecipientName )( 
            IFaxDoc __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_RecipientCompany )( 
            IFaxDoc __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_RecipientCompany )( 
            IFaxDoc __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_RecipientAddress )( 
            IFaxDoc __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_RecipientAddress )( 
            IFaxDoc __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_RecipientCity )( 
            IFaxDoc __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_RecipientCity )( 
            IFaxDoc __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_RecipientState )( 
            IFaxDoc __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_RecipientState )( 
            IFaxDoc __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_RecipientZip )( 
            IFaxDoc __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_RecipientZip )( 
            IFaxDoc __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_RecipientCountry )( 
            IFaxDoc __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_RecipientCountry )( 
            IFaxDoc __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_RecipientTitle )( 
            IFaxDoc __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_RecipientTitle )( 
            IFaxDoc __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_RecipientDepartment )( 
            IFaxDoc __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_RecipientDepartment )( 
            IFaxDoc __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_RecipientOffice )( 
            IFaxDoc __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_RecipientOffice )( 
            IFaxDoc __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_RecipientHomePhone )( 
            IFaxDoc __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_RecipientHomePhone )( 
            IFaxDoc __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_RecipientOfficePhone )( 
            IFaxDoc __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_RecipientOfficePhone )( 
            IFaxDoc __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SenderName )( 
            IFaxDoc __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_SenderName )( 
            IFaxDoc __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SenderCompany )( 
            IFaxDoc __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_SenderCompany )( 
            IFaxDoc __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SenderAddress )( 
            IFaxDoc __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_SenderAddress )( 
            IFaxDoc __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SenderTitle )( 
            IFaxDoc __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_SenderTitle )( 
            IFaxDoc __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SenderDepartment )( 
            IFaxDoc __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_SenderDepartment )( 
            IFaxDoc __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SenderOffice )( 
            IFaxDoc __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_SenderOffice )( 
            IFaxDoc __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SenderHomePhone )( 
            IFaxDoc __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_SenderHomePhone )( 
            IFaxDoc __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SenderOfficePhone )( 
            IFaxDoc __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_SenderOfficePhone )( 
            IFaxDoc __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CoverpageNote )( 
            IFaxDoc __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_CoverpageNote )( 
            IFaxDoc __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CoverpageSubject )( 
            IFaxDoc __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_CoverpageSubject )( 
            IFaxDoc __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Tsid )( 
            IFaxDoc __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Tsid )( 
            IFaxDoc __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_BillingCode )( 
            IFaxDoc __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_BillingCode )( 
            IFaxDoc __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_EmailAddress )( 
            IFaxDoc __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_EmailAddress )( 
            IFaxDoc __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DisplayName )( 
            IFaxDoc __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_DisplayName )( 
            IFaxDoc __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Send )( 
            IFaxDoc __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_FaxNumber )( 
            IFaxDoc __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_FaxNumber )( 
            IFaxDoc __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propputref] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *putref_ConnectionObject )( 
            IFaxDoc __RPC_FAR * This,
            /* [in] */ IDispatch __RPC_FAR *newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CallHandle )( 
            IFaxDoc __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_CallHandle )( 
            IFaxDoc __RPC_FAR * This,
            /* [in] */ long newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SenderFax )( 
            IFaxDoc __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_SenderFax )( 
            IFaxDoc __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        END_INTERFACE
    } IFaxDocVtbl;

    interface IFaxDoc
    {
        CONST_VTBL struct IFaxDocVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxDoc_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxDoc_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxDoc_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxDoc_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxDoc_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxDoc_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxDoc_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFaxDoc_get_FileName(This,pVal)	\
    (This)->lpVtbl -> get_FileName(This,pVal)

#define IFaxDoc_put_FileName(This,newVal)	\
    (This)->lpVtbl -> put_FileName(This,newVal)

#define IFaxDoc_get_CoverpageName(This,pVal)	\
    (This)->lpVtbl -> get_CoverpageName(This,pVal)

#define IFaxDoc_put_CoverpageName(This,newVal)	\
    (This)->lpVtbl -> put_CoverpageName(This,newVal)

#define IFaxDoc_get_SendCoverpage(This,pVal)	\
    (This)->lpVtbl -> get_SendCoverpage(This,pVal)

#define IFaxDoc_put_SendCoverpage(This,newVal)	\
    (This)->lpVtbl -> put_SendCoverpage(This,newVal)

#define IFaxDoc_get_ServerCoverpage(This,pVal)	\
    (This)->lpVtbl -> get_ServerCoverpage(This,pVal)

#define IFaxDoc_put_ServerCoverpage(This,newVal)	\
    (This)->lpVtbl -> put_ServerCoverpage(This,newVal)

#define IFaxDoc_get_DiscountSend(This,pVal)	\
    (This)->lpVtbl -> get_DiscountSend(This,pVal)

#define IFaxDoc_put_DiscountSend(This,newVal)	\
    (This)->lpVtbl -> put_DiscountSend(This,newVal)

#define IFaxDoc_get_RecipientName(This,pVal)	\
    (This)->lpVtbl -> get_RecipientName(This,pVal)

#define IFaxDoc_put_RecipientName(This,newVal)	\
    (This)->lpVtbl -> put_RecipientName(This,newVal)

#define IFaxDoc_get_RecipientCompany(This,pVal)	\
    (This)->lpVtbl -> get_RecipientCompany(This,pVal)

#define IFaxDoc_put_RecipientCompany(This,newVal)	\
    (This)->lpVtbl -> put_RecipientCompany(This,newVal)

#define IFaxDoc_get_RecipientAddress(This,pVal)	\
    (This)->lpVtbl -> get_RecipientAddress(This,pVal)

#define IFaxDoc_put_RecipientAddress(This,newVal)	\
    (This)->lpVtbl -> put_RecipientAddress(This,newVal)

#define IFaxDoc_get_RecipientCity(This,pVal)	\
    (This)->lpVtbl -> get_RecipientCity(This,pVal)

#define IFaxDoc_put_RecipientCity(This,newVal)	\
    (This)->lpVtbl -> put_RecipientCity(This,newVal)

#define IFaxDoc_get_RecipientState(This,pVal)	\
    (This)->lpVtbl -> get_RecipientState(This,pVal)

#define IFaxDoc_put_RecipientState(This,newVal)	\
    (This)->lpVtbl -> put_RecipientState(This,newVal)

#define IFaxDoc_get_RecipientZip(This,pVal)	\
    (This)->lpVtbl -> get_RecipientZip(This,pVal)

#define IFaxDoc_put_RecipientZip(This,newVal)	\
    (This)->lpVtbl -> put_RecipientZip(This,newVal)

#define IFaxDoc_get_RecipientCountry(This,pVal)	\
    (This)->lpVtbl -> get_RecipientCountry(This,pVal)

#define IFaxDoc_put_RecipientCountry(This,newVal)	\
    (This)->lpVtbl -> put_RecipientCountry(This,newVal)

#define IFaxDoc_get_RecipientTitle(This,pVal)	\
    (This)->lpVtbl -> get_RecipientTitle(This,pVal)

#define IFaxDoc_put_RecipientTitle(This,newVal)	\
    (This)->lpVtbl -> put_RecipientTitle(This,newVal)

#define IFaxDoc_get_RecipientDepartment(This,pVal)	\
    (This)->lpVtbl -> get_RecipientDepartment(This,pVal)

#define IFaxDoc_put_RecipientDepartment(This,newVal)	\
    (This)->lpVtbl -> put_RecipientDepartment(This,newVal)

#define IFaxDoc_get_RecipientOffice(This,pVal)	\
    (This)->lpVtbl -> get_RecipientOffice(This,pVal)

#define IFaxDoc_put_RecipientOffice(This,newVal)	\
    (This)->lpVtbl -> put_RecipientOffice(This,newVal)

#define IFaxDoc_get_RecipientHomePhone(This,pVal)	\
    (This)->lpVtbl -> get_RecipientHomePhone(This,pVal)

#define IFaxDoc_put_RecipientHomePhone(This,newVal)	\
    (This)->lpVtbl -> put_RecipientHomePhone(This,newVal)

#define IFaxDoc_get_RecipientOfficePhone(This,pVal)	\
    (This)->lpVtbl -> get_RecipientOfficePhone(This,pVal)

#define IFaxDoc_put_RecipientOfficePhone(This,newVal)	\
    (This)->lpVtbl -> put_RecipientOfficePhone(This,newVal)

#define IFaxDoc_get_SenderName(This,pVal)	\
    (This)->lpVtbl -> get_SenderName(This,pVal)

#define IFaxDoc_put_SenderName(This,newVal)	\
    (This)->lpVtbl -> put_SenderName(This,newVal)

#define IFaxDoc_get_SenderCompany(This,pVal)	\
    (This)->lpVtbl -> get_SenderCompany(This,pVal)

#define IFaxDoc_put_SenderCompany(This,newVal)	\
    (This)->lpVtbl -> put_SenderCompany(This,newVal)

#define IFaxDoc_get_SenderAddress(This,pVal)	\
    (This)->lpVtbl -> get_SenderAddress(This,pVal)

#define IFaxDoc_put_SenderAddress(This,newVal)	\
    (This)->lpVtbl -> put_SenderAddress(This,newVal)

#define IFaxDoc_get_SenderTitle(This,pVal)	\
    (This)->lpVtbl -> get_SenderTitle(This,pVal)

#define IFaxDoc_put_SenderTitle(This,newVal)	\
    (This)->lpVtbl -> put_SenderTitle(This,newVal)

#define IFaxDoc_get_SenderDepartment(This,pVal)	\
    (This)->lpVtbl -> get_SenderDepartment(This,pVal)

#define IFaxDoc_put_SenderDepartment(This,newVal)	\
    (This)->lpVtbl -> put_SenderDepartment(This,newVal)

#define IFaxDoc_get_SenderOffice(This,pVal)	\
    (This)->lpVtbl -> get_SenderOffice(This,pVal)

#define IFaxDoc_put_SenderOffice(This,newVal)	\
    (This)->lpVtbl -> put_SenderOffice(This,newVal)

#define IFaxDoc_get_SenderHomePhone(This,pVal)	\
    (This)->lpVtbl -> get_SenderHomePhone(This,pVal)

#define IFaxDoc_put_SenderHomePhone(This,newVal)	\
    (This)->lpVtbl -> put_SenderHomePhone(This,newVal)

#define IFaxDoc_get_SenderOfficePhone(This,pVal)	\
    (This)->lpVtbl -> get_SenderOfficePhone(This,pVal)

#define IFaxDoc_put_SenderOfficePhone(This,newVal)	\
    (This)->lpVtbl -> put_SenderOfficePhone(This,newVal)

#define IFaxDoc_get_CoverpageNote(This,pVal)	\
    (This)->lpVtbl -> get_CoverpageNote(This,pVal)

#define IFaxDoc_put_CoverpageNote(This,newVal)	\
    (This)->lpVtbl -> put_CoverpageNote(This,newVal)

#define IFaxDoc_get_CoverpageSubject(This,pVal)	\
    (This)->lpVtbl -> get_CoverpageSubject(This,pVal)

#define IFaxDoc_put_CoverpageSubject(This,newVal)	\
    (This)->lpVtbl -> put_CoverpageSubject(This,newVal)

#define IFaxDoc_get_Tsid(This,pVal)	\
    (This)->lpVtbl -> get_Tsid(This,pVal)

#define IFaxDoc_put_Tsid(This,newVal)	\
    (This)->lpVtbl -> put_Tsid(This,newVal)

#define IFaxDoc_get_BillingCode(This,pVal)	\
    (This)->lpVtbl -> get_BillingCode(This,pVal)

#define IFaxDoc_put_BillingCode(This,newVal)	\
    (This)->lpVtbl -> put_BillingCode(This,newVal)

#define IFaxDoc_get_EmailAddress(This,pVal)	\
    (This)->lpVtbl -> get_EmailAddress(This,pVal)

#define IFaxDoc_put_EmailAddress(This,newVal)	\
    (This)->lpVtbl -> put_EmailAddress(This,newVal)

#define IFaxDoc_get_DisplayName(This,pVal)	\
    (This)->lpVtbl -> get_DisplayName(This,pVal)

#define IFaxDoc_put_DisplayName(This,newVal)	\
    (This)->lpVtbl -> put_DisplayName(This,newVal)

#define IFaxDoc_Send(This,pVal)	\
    (This)->lpVtbl -> Send(This,pVal)

#define IFaxDoc_get_FaxNumber(This,pVal)	\
    (This)->lpVtbl -> get_FaxNumber(This,pVal)

#define IFaxDoc_put_FaxNumber(This,newVal)	\
    (This)->lpVtbl -> put_FaxNumber(This,newVal)

#define IFaxDoc_putref_ConnectionObject(This,newVal)	\
    (This)->lpVtbl -> putref_ConnectionObject(This,newVal)

#define IFaxDoc_get_CallHandle(This,pVal)	\
    (This)->lpVtbl -> get_CallHandle(This,pVal)

#define IFaxDoc_put_CallHandle(This,newVal)	\
    (This)->lpVtbl -> put_CallHandle(This,newVal)

#define IFaxDoc_get_SenderFax(This,pVal)	\
    (This)->lpVtbl -> get_SenderFax(This,pVal)

#define IFaxDoc_put_SenderFax(This,newVal)	\
    (This)->lpVtbl -> put_SenderFax(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDoc_get_FileName_Proxy( 
    IFaxDoc __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IFaxDoc_get_FileName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDoc_put_FileName_Proxy( 
    IFaxDoc __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IFaxDoc_put_FileName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDoc_get_CoverpageName_Proxy( 
    IFaxDoc __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IFaxDoc_get_CoverpageName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDoc_put_CoverpageName_Proxy( 
    IFaxDoc __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IFaxDoc_put_CoverpageName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDoc_get_SendCoverpage_Proxy( 
    IFaxDoc __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pVal);


void __RPC_STUB IFaxDoc_get_SendCoverpage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDoc_put_SendCoverpage_Proxy( 
    IFaxDoc __RPC_FAR * This,
    /* [in] */ BOOL newVal);


void __RPC_STUB IFaxDoc_put_SendCoverpage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDoc_get_ServerCoverpage_Proxy( 
    IFaxDoc __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pVal);


void __RPC_STUB IFaxDoc_get_ServerCoverpage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDoc_put_ServerCoverpage_Proxy( 
    IFaxDoc __RPC_FAR * This,
    /* [in] */ BOOL newVal);


void __RPC_STUB IFaxDoc_put_ServerCoverpage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDoc_get_DiscountSend_Proxy( 
    IFaxDoc __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pVal);


void __RPC_STUB IFaxDoc_get_DiscountSend_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDoc_put_DiscountSend_Proxy( 
    IFaxDoc __RPC_FAR * This,
    /* [in] */ BOOL newVal);


void __RPC_STUB IFaxDoc_put_DiscountSend_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDoc_get_RecipientName_Proxy( 
    IFaxDoc __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IFaxDoc_get_RecipientName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDoc_put_RecipientName_Proxy( 
    IFaxDoc __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IFaxDoc_put_RecipientName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDoc_get_RecipientCompany_Proxy( 
    IFaxDoc __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IFaxDoc_get_RecipientCompany_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDoc_put_RecipientCompany_Proxy( 
    IFaxDoc __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IFaxDoc_put_RecipientCompany_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDoc_get_RecipientAddress_Proxy( 
    IFaxDoc __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IFaxDoc_get_RecipientAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDoc_put_RecipientAddress_Proxy( 
    IFaxDoc __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IFaxDoc_put_RecipientAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDoc_get_RecipientCity_Proxy( 
    IFaxDoc __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IFaxDoc_get_RecipientCity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDoc_put_RecipientCity_Proxy( 
    IFaxDoc __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IFaxDoc_put_RecipientCity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDoc_get_RecipientState_Proxy( 
    IFaxDoc __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IFaxDoc_get_RecipientState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDoc_put_RecipientState_Proxy( 
    IFaxDoc __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IFaxDoc_put_RecipientState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDoc_get_RecipientZip_Proxy( 
    IFaxDoc __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IFaxDoc_get_RecipientZip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDoc_put_RecipientZip_Proxy( 
    IFaxDoc __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IFaxDoc_put_RecipientZip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDoc_get_RecipientCountry_Proxy( 
    IFaxDoc __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IFaxDoc_get_RecipientCountry_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDoc_put_RecipientCountry_Proxy( 
    IFaxDoc __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IFaxDoc_put_RecipientCountry_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDoc_get_RecipientTitle_Proxy( 
    IFaxDoc __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IFaxDoc_get_RecipientTitle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDoc_put_RecipientTitle_Proxy( 
    IFaxDoc __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IFaxDoc_put_RecipientTitle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDoc_get_RecipientDepartment_Proxy( 
    IFaxDoc __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IFaxDoc_get_RecipientDepartment_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDoc_put_RecipientDepartment_Proxy( 
    IFaxDoc __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IFaxDoc_put_RecipientDepartment_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDoc_get_RecipientOffice_Proxy( 
    IFaxDoc __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IFaxDoc_get_RecipientOffice_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDoc_put_RecipientOffice_Proxy( 
    IFaxDoc __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IFaxDoc_put_RecipientOffice_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDoc_get_RecipientHomePhone_Proxy( 
    IFaxDoc __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IFaxDoc_get_RecipientHomePhone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDoc_put_RecipientHomePhone_Proxy( 
    IFaxDoc __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IFaxDoc_put_RecipientHomePhone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDoc_get_RecipientOfficePhone_Proxy( 
    IFaxDoc __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IFaxDoc_get_RecipientOfficePhone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDoc_put_RecipientOfficePhone_Proxy( 
    IFaxDoc __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IFaxDoc_put_RecipientOfficePhone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDoc_get_SenderName_Proxy( 
    IFaxDoc __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IFaxDoc_get_SenderName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDoc_put_SenderName_Proxy( 
    IFaxDoc __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IFaxDoc_put_SenderName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDoc_get_SenderCompany_Proxy( 
    IFaxDoc __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IFaxDoc_get_SenderCompany_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDoc_put_SenderCompany_Proxy( 
    IFaxDoc __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IFaxDoc_put_SenderCompany_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDoc_get_SenderAddress_Proxy( 
    IFaxDoc __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IFaxDoc_get_SenderAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDoc_put_SenderAddress_Proxy( 
    IFaxDoc __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IFaxDoc_put_SenderAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDoc_get_SenderTitle_Proxy( 
    IFaxDoc __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IFaxDoc_get_SenderTitle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDoc_put_SenderTitle_Proxy( 
    IFaxDoc __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IFaxDoc_put_SenderTitle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDoc_get_SenderDepartment_Proxy( 
    IFaxDoc __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IFaxDoc_get_SenderDepartment_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDoc_put_SenderDepartment_Proxy( 
    IFaxDoc __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IFaxDoc_put_SenderDepartment_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDoc_get_SenderOffice_Proxy( 
    IFaxDoc __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IFaxDoc_get_SenderOffice_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDoc_put_SenderOffice_Proxy( 
    IFaxDoc __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IFaxDoc_put_SenderOffice_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDoc_get_SenderHomePhone_Proxy( 
    IFaxDoc __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IFaxDoc_get_SenderHomePhone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDoc_put_SenderHomePhone_Proxy( 
    IFaxDoc __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IFaxDoc_put_SenderHomePhone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDoc_get_SenderOfficePhone_Proxy( 
    IFaxDoc __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IFaxDoc_get_SenderOfficePhone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDoc_put_SenderOfficePhone_Proxy( 
    IFaxDoc __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IFaxDoc_put_SenderOfficePhone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDoc_get_CoverpageNote_Proxy( 
    IFaxDoc __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IFaxDoc_get_CoverpageNote_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDoc_put_CoverpageNote_Proxy( 
    IFaxDoc __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IFaxDoc_put_CoverpageNote_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDoc_get_CoverpageSubject_Proxy( 
    IFaxDoc __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IFaxDoc_get_CoverpageSubject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDoc_put_CoverpageSubject_Proxy( 
    IFaxDoc __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IFaxDoc_put_CoverpageSubject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDoc_get_Tsid_Proxy( 
    IFaxDoc __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IFaxDoc_get_Tsid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDoc_put_Tsid_Proxy( 
    IFaxDoc __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IFaxDoc_put_Tsid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDoc_get_BillingCode_Proxy( 
    IFaxDoc __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IFaxDoc_get_BillingCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDoc_put_BillingCode_Proxy( 
    IFaxDoc __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IFaxDoc_put_BillingCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDoc_get_EmailAddress_Proxy( 
    IFaxDoc __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IFaxDoc_get_EmailAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDoc_put_EmailAddress_Proxy( 
    IFaxDoc __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IFaxDoc_put_EmailAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDoc_get_DisplayName_Proxy( 
    IFaxDoc __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IFaxDoc_get_DisplayName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDoc_put_DisplayName_Proxy( 
    IFaxDoc __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IFaxDoc_put_DisplayName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxDoc_Send_Proxy( 
    IFaxDoc __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IFaxDoc_Send_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDoc_get_FaxNumber_Proxy( 
    IFaxDoc __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IFaxDoc_get_FaxNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDoc_put_FaxNumber_Proxy( 
    IFaxDoc __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IFaxDoc_put_FaxNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propputref] */ HRESULT STDMETHODCALLTYPE IFaxDoc_putref_ConnectionObject_Proxy( 
    IFaxDoc __RPC_FAR * This,
    /* [in] */ IDispatch __RPC_FAR *newVal);


void __RPC_STUB IFaxDoc_putref_ConnectionObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDoc_get_CallHandle_Proxy( 
    IFaxDoc __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IFaxDoc_get_CallHandle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDoc_put_CallHandle_Proxy( 
    IFaxDoc __RPC_FAR * This,
    /* [in] */ long newVal);


void __RPC_STUB IFaxDoc_put_CallHandle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxDoc_get_SenderFax_Proxy( 
    IFaxDoc __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IFaxDoc_get_SenderFax_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IFaxDoc_put_SenderFax_Proxy( 
    IFaxDoc __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IFaxDoc_put_SenderFax_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFaxDoc_INTERFACE_DEFINED__ */


#ifndef __IFaxJobs_INTERFACE_DEFINED__
#define __IFaxJobs_INTERFACE_DEFINED__

/* interface IFaxJobs */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IFaxJobs;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("55DABFD3-5C9E-11D1-B791-000000000000")
    IFaxJobs : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            long Index,
            /* [retval][out] */ VARIANT __RPC_FAR *pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFaxJobsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IFaxJobs __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IFaxJobs __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IFaxJobs __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IFaxJobs __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IFaxJobs __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IFaxJobs __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IFaxJobs __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            IFaxJobs __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Item )( 
            IFaxJobs __RPC_FAR * This,
            long Index,
            /* [retval][out] */ VARIANT __RPC_FAR *pVal);
        
        END_INTERFACE
    } IFaxJobsVtbl;

    interface IFaxJobs
    {
        CONST_VTBL struct IFaxJobsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxJobs_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxJobs_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxJobs_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxJobs_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxJobs_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxJobs_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxJobs_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFaxJobs_get_Count(This,pVal)	\
    (This)->lpVtbl -> get_Count(This,pVal)

#define IFaxJobs_get_Item(This,Index,pVal)	\
    (This)->lpVtbl -> get_Item(This,Index,pVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxJobs_get_Count_Proxy( 
    IFaxJobs __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IFaxJobs_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxJobs_get_Item_Proxy( 
    IFaxJobs __RPC_FAR * This,
    long Index,
    /* [retval][out] */ VARIANT __RPC_FAR *pVal);


void __RPC_STUB IFaxJobs_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFaxJobs_INTERFACE_DEFINED__ */


#ifndef __IFaxJob_INTERFACE_DEFINED__
#define __IFaxJob_INTERFACE_DEFINED__

/* interface IFaxJob */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IFaxJob;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("55DABFD5-5C9E-11D1-B791-000000000000")
    IFaxJob : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_JobId( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Type( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_UserName( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_QueueStatus( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DeviceStatus( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PageCount( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_FaxNumber( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RecipientName( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Tsid( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SenderName( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SenderCompany( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SenderDept( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_BillingCode( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DisplayName( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DiscountSend( 
            /* [retval][out] */ BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetStatus( 
            long Command) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Refresh( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFaxJobVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IFaxJob __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IFaxJob __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IFaxJob __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IFaxJob __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IFaxJob __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IFaxJob __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IFaxJob __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_JobId )( 
            IFaxJob __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Type )( 
            IFaxJob __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_UserName )( 
            IFaxJob __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_QueueStatus )( 
            IFaxJob __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DeviceStatus )( 
            IFaxJob __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_PageCount )( 
            IFaxJob __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_FaxNumber )( 
            IFaxJob __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_RecipientName )( 
            IFaxJob __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Tsid )( 
            IFaxJob __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SenderName )( 
            IFaxJob __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SenderCompany )( 
            IFaxJob __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SenderDept )( 
            IFaxJob __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_BillingCode )( 
            IFaxJob __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DisplayName )( 
            IFaxJob __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DiscountSend )( 
            IFaxJob __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetStatus )( 
            IFaxJob __RPC_FAR * This,
            long Command);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Refresh )( 
            IFaxJob __RPC_FAR * This);
        
        END_INTERFACE
    } IFaxJobVtbl;

    interface IFaxJob
    {
        CONST_VTBL struct IFaxJobVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFaxJob_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFaxJob_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFaxJob_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFaxJob_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFaxJob_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFaxJob_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFaxJob_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFaxJob_get_JobId(This,pVal)	\
    (This)->lpVtbl -> get_JobId(This,pVal)

#define IFaxJob_get_Type(This,pVal)	\
    (This)->lpVtbl -> get_Type(This,pVal)

#define IFaxJob_get_UserName(This,pVal)	\
    (This)->lpVtbl -> get_UserName(This,pVal)

#define IFaxJob_get_QueueStatus(This,pVal)	\
    (This)->lpVtbl -> get_QueueStatus(This,pVal)

#define IFaxJob_get_DeviceStatus(This,pVal)	\
    (This)->lpVtbl -> get_DeviceStatus(This,pVal)

#define IFaxJob_get_PageCount(This,pVal)	\
    (This)->lpVtbl -> get_PageCount(This,pVal)

#define IFaxJob_get_FaxNumber(This,pVal)	\
    (This)->lpVtbl -> get_FaxNumber(This,pVal)

#define IFaxJob_get_RecipientName(This,pVal)	\
    (This)->lpVtbl -> get_RecipientName(This,pVal)

#define IFaxJob_get_Tsid(This,pVal)	\
    (This)->lpVtbl -> get_Tsid(This,pVal)

#define IFaxJob_get_SenderName(This,pVal)	\
    (This)->lpVtbl -> get_SenderName(This,pVal)

#define IFaxJob_get_SenderCompany(This,pVal)	\
    (This)->lpVtbl -> get_SenderCompany(This,pVal)

#define IFaxJob_get_SenderDept(This,pVal)	\
    (This)->lpVtbl -> get_SenderDept(This,pVal)

#define IFaxJob_get_BillingCode(This,pVal)	\
    (This)->lpVtbl -> get_BillingCode(This,pVal)

#define IFaxJob_get_DisplayName(This,pVal)	\
    (This)->lpVtbl -> get_DisplayName(This,pVal)

#define IFaxJob_get_DiscountSend(This,pVal)	\
    (This)->lpVtbl -> get_DiscountSend(This,pVal)

#define IFaxJob_SetStatus(This,Command)	\
    (This)->lpVtbl -> SetStatus(This,Command)

#define IFaxJob_Refresh(This)	\
    (This)->lpVtbl -> Refresh(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxJob_get_JobId_Proxy( 
    IFaxJob __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IFaxJob_get_JobId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxJob_get_Type_Proxy( 
    IFaxJob __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IFaxJob_get_Type_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxJob_get_UserName_Proxy( 
    IFaxJob __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IFaxJob_get_UserName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxJob_get_QueueStatus_Proxy( 
    IFaxJob __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IFaxJob_get_QueueStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxJob_get_DeviceStatus_Proxy( 
    IFaxJob __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IFaxJob_get_DeviceStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxJob_get_PageCount_Proxy( 
    IFaxJob __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IFaxJob_get_PageCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxJob_get_FaxNumber_Proxy( 
    IFaxJob __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IFaxJob_get_FaxNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxJob_get_RecipientName_Proxy( 
    IFaxJob __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IFaxJob_get_RecipientName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxJob_get_Tsid_Proxy( 
    IFaxJob __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IFaxJob_get_Tsid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxJob_get_SenderName_Proxy( 
    IFaxJob __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IFaxJob_get_SenderName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxJob_get_SenderCompany_Proxy( 
    IFaxJob __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IFaxJob_get_SenderCompany_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxJob_get_SenderDept_Proxy( 
    IFaxJob __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IFaxJob_get_SenderDept_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxJob_get_BillingCode_Proxy( 
    IFaxJob __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IFaxJob_get_BillingCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxJob_get_DisplayName_Proxy( 
    IFaxJob __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IFaxJob_get_DisplayName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IFaxJob_get_DiscountSend_Proxy( 
    IFaxJob __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pVal);


void __RPC_STUB IFaxJob_get_DiscountSend_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxJob_SetStatus_Proxy( 
    IFaxJob __RPC_FAR * This,
    long Command);


void __RPC_STUB IFaxJob_SetStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFaxJob_Refresh_Proxy( 
    IFaxJob __RPC_FAR * This);


void __RPC_STUB IFaxJob_Refresh_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFaxJob_INTERFACE_DEFINED__ */



#ifndef __FAXCOMLib_LIBRARY_DEFINED__
#define __FAXCOMLib_LIBRARY_DEFINED__

/* library FAXCOMLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_FAXCOMLib;

EXTERN_C const CLSID CLSID_FaxTiff;

#ifdef __cplusplus

class DECLSPEC_UUID("87099231-C7AF-11D0-B225-00C04FB6C2F5")
FaxTiff;
#endif

EXTERN_C const CLSID CLSID_FaxServer;

#ifdef __cplusplus

class DECLSPEC_UUID("D73733C8-CC80-11D0-B225-00C04FB6C2F5")
FaxServer;
#endif

EXTERN_C const CLSID CLSID_FaxPort;

#ifdef __cplusplus

class DECLSPEC_UUID("D73733CD-CC80-11D0-B225-00C04FB6C2F5")
FaxPort;
#endif

EXTERN_C const CLSID CLSID_FaxPorts;

#ifdef __cplusplus

class DECLSPEC_UUID("D73733D6-CC80-11D0-B225-00C04FB6C2F5")
FaxPorts;
#endif

EXTERN_C const CLSID CLSID_FaxRoutingMethod;

#ifdef __cplusplus

class DECLSPEC_UUID("2199F5F4-CEFC-11D0-A341-0000F800E68D")
FaxRoutingMethod;
#endif

EXTERN_C const CLSID CLSID_FaxRoutingMethods;

#ifdef __cplusplus

class DECLSPEC_UUID("2199F5F6-CEFC-11D0-A341-0000F800E68D")
FaxRoutingMethods;
#endif

EXTERN_C const CLSID CLSID_FaxStatus;

#ifdef __cplusplus

class DECLSPEC_UUID("8B97E606-D054-11D0-B226-00C04FB6C2F5")
FaxStatus;
#endif

EXTERN_C const CLSID CLSID_FaxDoc;

#ifdef __cplusplus

class DECLSPEC_UUID("FA21F4C6-5C4C-11D1-83CF-00C04FB6E984")
FaxDoc;
#endif

EXTERN_C const CLSID CLSID_FaxJobs;

#ifdef __cplusplus

class DECLSPEC_UUID("55DABFD4-5C9E-11D1-B791-000000000000")
FaxJobs;
#endif

EXTERN_C const CLSID CLSID_FaxJob;

#ifdef __cplusplus

class DECLSPEC_UUID("55DABFD6-5C9E-11D1-B791-000000000000")
FaxJob;
#endif
#endif /* __FAXCOMLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long __RPC_FAR *, unsigned long            , VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long __RPC_FAR *, VARIANT __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\fmi.h ===
/* fmi.h */
/*
 * (C) Copyright Data Connection Limited 1989-1992.
 * (C) Copyright Microsoft Corporation 1991.
 * All Rights Reserved.
 */

#ifndef FMIH_INCLUDED
#define FMIH_INCLUDED

#ifdef __cplusplus
extern "C" {
#endif

#ifdef WIN32_SUPPORT
  #pragma pack(1)
#endif

/*****************************************************************************/
/* The following type definitions are in os2def.h so are not needed in OS/2  */
/*****************************************************************************/
#if (defined(DOS_SUPPORT) || defined(MSWIN_SUPPORT))
#define CHAR          char      /* ch  */
typedef unsigned char UCHAR;    /* uch */
typedef unsigned short USHORT;  /* us  */
typedef unsigned long ULONG;    /* ul  */
#endif

/*****************************************************************************/
/* Type definitions for message fields                                       */
/*****************************************************************************/
typedef signed short         INTEGER;

/*****************************************************************************/
/* Macro to convert integer fields other than STARTD and ENDD, SRCI          */
/* and DESTI to In-line format                                               */
/*****************************************************************************/
#ifndef WIN32_SUPPORT
#define DOFLIP(X) ((INTEGER)((((X) & 0xff) << 8) | (((X) >> 8) & 0xff)))
#else
#ifndef ROTL
 #ifndef _CRTAPI1
  unsigned int _rotl(unsigned int, int);
 #else
  unsigned int _CRTAPI1 _rotl(unsigned int, int);
 #endif
  #define ROTL
#endif
#pragma intrinsic(_rotl)
#define DOFLIP(X)   ((INTEGER)_rotl(((unsigned short)(X))*(unsigned long)0x00010001, 8))
#endif
#define DONTFLIP(X) (X)


#ifdef NON_INTEL_BYTE_ORDER
 #define PFLIPI(X)      DONTFLIP(X)
 #define PANTIFLIPI(X)  DOFLIP(X)
#else
 #define PFLIPI(X)      DOFLIP(X)
 #define PANTIFLIPI(X)  DONTFLIP(X)
#endif


/*****************************************************************************/
/* Element offset and length definitions                                     */
/*****************************************************************************/

#define SBCBELT1 1
#define SBCBELT3 13
#define SNANBEDA 268     /* LENGTH OF BUFFER ELEMENT */

/*****************************************************************************/
/* MESSAGE TYPE DECLARATIONS - ELEMENT OPTIONS                               */
/*****************************************************************************/
     typedef
#define RHASENSE     0
#define DATAONLY     1
     signed char ELTDATAT;

     typedef CHAR     SNCHARRU[SNANBEDA];        /* LENGTH OF ELT */

/*****************************************************************************/
/* MAIN DEFINITION OF MESSAGE ELEMENT                                        */
/*****************************************************************************/

/**STRUCT+********************************************************************/
/* Structure: BUFELT                                                         */
/*                                                                           */
/* Description: Main definition of SNAPS Buffer Element                      */
/*****************************************************************************/

#ifdef WIN32_SUPPORT
 #define PTRBFELT struct bufelt *
#else
 #define PTRBFELT struct bufelt far *
#endif

     typedef struct bufelt{
                     PTRBFELT elteptr;   /* Pointer to next element in buffer*/
                     INTEGER  startd;    /* Offset (from 1) of start of data */
                     INTEGER  endd;      /* Offset (from 1) of last data byte*/
                     CHAR     trpad;
                     /*ELTDATAT*/union {
                       /*RHASENSE*/struct {unsigned char rhpad[8];
                                     signed long BBUFF0V;
                                     INTEGER  BBUFF0W;
                                     INTEGER  BBUFF0X;}BBUFF0T;
                       /*DATAONLY*/struct {SNCHARRU BBUFF0Z;
                                                      }BBUFF0Y;
                   }BBUFF0S;}
#define rh       BBUFF0S.BBUFF0T.BBUFF0V /* The RH bytes themselves          */
#define sense1   BBUFF0S.BBUFF0T.BBUFF0W /* Sense data 1 in negative response*/
#define sense2   BBUFF0S.BBUFF0T.BBUFF0X /* Sense data 2 in negative response*/
#define dataru   BBUFF0S.BBUFF0Y.BBUFF0Z /* The data bytes themselves        */
#define lccpad   BBUFF0S.BBUFF0Y.BBUFF1A /* Pad                              */
                   BUFELT;


/*****************************************************************************/
/* OPEN MESSAGE TYPE DECLARATIONS                                            */
/*****************************************************************************/

     typedef struct tpophdr{                          /* OPEN MESSAGE HEADER */
                      CHAR     openqual;
#define REQU     1
#define RSPOK    2
#define RSPERR   3
#define CONFOK   4
#define CONFERR  5
                      CHAR     opentype;
#define SSCPSEC  1
#define LUSEC    2
#define SBPUSEC  3
                      CHAR     appltype;     /* INTERFACE ID - X'02' FOR FMI */
                      CHAR     opluno;              /* INTERFACE USER NUMBER */
                      INTEGER  opresid;             /* INTERFACE USER ID     */
                      union {
                        struct {INTEGER  B03;
                                INTEGER  B04;
                                CHAR     B05;
                                CHAR     B06;}B02;
                        struct {INTEGER  B08;
                                INTEGER  B09;}B07;
                    }B01;}
#define icreditr B01.B02.B03
#define icredits B01.B02.B04
#define opninfo1 B01.B02.B05
#define opnpad1  B01.B02.B06
#define operr1   B01.B07.B08
#define operr2   B01.B07.B09
                    TPOPHDR;

/*****************************************************************************/
/* Open (SSCP) opnpad1 values                                                */
/*****************************************************************************/

#define OPEN_TEST       0               /* DON'T FORCE A CONNECTION ACTIVE   */
#define OPEN_FORCE      1               /* FORCE A CONNECTION ACTIVE         */

/*****************************************************************************/
/* Constants for operr2 field in Open(SSCP) Error Responses                  */
/*****************************************************************************/

#define CSRENOSR 0                      /* NO SERVERS FOUND                  */
#define CSRESERV 1                      /* SERVICE NOT PRESENT AT LOCALITY   */
#define CSRECNFG 2                      /* CONFIGURATION MISMATCH            */
#define CSRECBSH 3                      /* CONTROL BLOCK/RESOURCE SHORTAGE   */
#define CSREFORM 4                      /* FORMAT/PROTOCOL ERROR             */

/*****************************************************************************/
/* LINK TYPE DEFINITIONS FOR OPEN (SSCP) RESPONSE IN DATARU[38]              */
/*****************************************************************************/

#define CESLINK          3              /* SDLC LINK                         */
#define CESX25           4              /* X.25 LINK                         */
#define CESDFT          10              /* DFT LINK                          */
#define CESTR           11              /* TOKEN RING LINK                   */
#define CESTCPIP        30              /* TCP/IP LINK                       */
#define CESRELAY        31              /* FRAME RELAY LINK                  */
#define CESCHANL        32              /* CHANNEL LINK                      */
#define CESISDN         33              /* ISDN LINK                         */
#define CESETHER        34              /* ETHERNET 802.2 LINK               */

/*****************************************************************************/
/* BIND Table Index Values for the Open PLU response (in element)            */
/*****************************************************************************/

#define BIND_TABLE_INDEX_PRT    1
#define BIND_TABLE_INDEX_CRT    2

/*****************************************************************************/
/* CLOSE MESSAGE TYPE DECLARATIONS                                           */
/*****************************************************************************/

     typedef struct tpclhdr{                         /* CLOSE MESSAGE HEADER */
                      CHAR     closqual;    /* Same values as openqual       */
                      CHAR     clstype;     /* Same values as opentype       */
                      CHAR     clsctl;      /* For Close(PLU) only           */
#define CLNORMAL 1
#define CLBIND   2
#define CLCFAERR 3
#define CLPUINAC 4
#define CLLUINAC 5
#define CLLNKERR 6
#define CLBFSHRT 7
#define CLRCVCHK 8
#define CLSLUTRM 9
                      CHAR     clspad1;
                      INTEGER  clspad2;
                      INTEGER  clserr1;
                      INTEGER  clserr2;
                    }TPCLHDR;

/*****************************************************************************/
/* STATUS-ACKNOWLEDGE MESSAGE TYPE DECLARATION                               */
/*****************************************************************************/

     typedef struct tpstahdr{                   /* STATUS ACK MESSAGE HEADER */
                      CHAR     akstat;
#define ACK      1
                      CHAR     akqual;
#define ACKPOS   2
#define ACKNEG1  3
#define ACKNEG2  4
                      INTEGER  akmsgkey;
                      union {
                              INTEGER XXXXX01;
                              struct {
                                 CHAR     XXXXX02;
                                 CHAR     XXXXX03;
                                     } XXXXX04;
                            } XXXXX05;
                      INTEGER  aknumb1;
                      INTEGER  aknumb2;
                      INTEGER  akseqno;

#define akmsgtim XXXXX05.XXXXX01
#define akflags1 XXXXX05.XXXXX04.XXXXX02    /* Same values as fhflags1 below */
                                            /* Reserved for ACKNEG2          */
#define akflags2 XXXXX05.XXXXX04.XXXXX03    /* Same values as fhflags2 below */
                                            /* Crit/Non-Crit fail for ACKNEG2*/

                    }TPSTAHDR;

/*****************************************************************************/
/* STATUS-ERROR MESSAGE TYPE DECLARATION                                     */
/*****************************************************************************/

     typedef struct tpstehdr{                 /* STATUS ERROR MESSAGE HEADER */
                      CHAR     errstat;
#define STERROR  3
                      CHAR     errpad1;
                      INTEGER  errpad2;
                      INTEGER  errpad3;
                      INTEGER  errcode1;
                      INTEGER  errcode2;
                    }TPSTEHDR;

/*****************************************************************************/
/* STATUS-CONTROL MESSAGE TYPE DECLARATION                                   */
/*****************************************************************************/

     typedef struct tpstchdr{               /* STATUS CONTROL MESSAGE HEADER */
                     CHAR     ctlstat;
#define STCNTRL  2
                     CHAR     ctlqual;
#define CTLREQU  1
/* #define ACKPOS   2 */
/* #define ACKNEG1  3 */
/* #define ACKNEG2  4 */
                     CHAR     ctltype;
#define CCLEAR   1
#define CSDT     2
#define CRQR     3
#define CSTSN    4
#define CCANCEL  16
#define CLUSTAT  17
#define CSIGNAL  18
#define CRSHUTD  19
#define CBID     20
#define CCHASE   21
#define CSHUTC   22
#define CSHUTD   23
#define CRTR     24
#define CQC      32
#define CQEC     33
#define CRELQ    34
                     CHAR     ctlack;       /* Same values as fhackrqd below */
                     CHAR     ctlflag1;     /* Same values as fhflags1 below */
                     CHAR     ctlflag2;     /* Same values as fhflags2 below */
                     INTEGER  ctlnumb1;
                     INTEGER  ctlnumb2;
                     INTEGER  ctlmsgk;
                   }TPSTCHDR;

/*****************************************************************************/
/* STATUS-RESOURCE MESSAGE TYPE DECLARATION                                  */
/*****************************************************************************/

     typedef struct tpstrhdr{              /* STATUS RESOURCE MESSAGE HEADER */
                      CHAR     resstat;
#define STRESRCE 4
                      CHAR     respad;
                      INTEGER  rescred;
                    }TPSTRHDR;

/*****************************************************************************/
/* STATUS-SESSION MESSAGE TYPE DECLARATION                                   */
/*****************************************************************************/

     typedef struct tpstshdr{               /* STATUS SESSION MESSAGE HEADER */
                      CHAR     sessstat;
#define STSESSN  5
                      CHAR     sesspad;
                      INTEGER  sesscode;
#define STNOSESS 1                               /* X'01' (NO SESSION)       */
#define STLINERR 2                               /* X'02' (LINK ERROR)       */
#define STPUACT  3                               /* X'03' (PU ACTIVE)        */
#define STPUREAC 4                               /* X'04' (PU RE-ACTIVATED)  */
#define STLUACT  5                               /* X'05' (LU ACTIVE)        */
#define STLUREAC 6                               /* X'06' (LU RE-ACTIVATED)  */
#define STBETB   7                               /* BETB STATUS-SESSION CODE */
                      INTEGER  sessqual;
/* #define STPUACT  3                               X'03' (PU ACTIVE)        */
/* #define STPUREAC 4                               X'04' (PU RE-ACTIVATED)  */
#define STPUINAC 16                              /* X'10' (PU INACTIVE)      */
#define STLUINAC 17                              /* X'11' (LU INACTIVE)      */
                    }TPSTSHDR;

/*****************************************************************************/
/* STATUS-RTM     MESSAGE TYPE DECLARATION                                   */
/*****************************************************************************/

     typedef struct tpstmhdr{               /* STATUS RTM     MESSAGE HEADER */
                      CHAR     rtmstat;
#define STRTM    6
                      CHAR     strbndry;   /* set boundaries flag */
                      CHAR     strcount;   /* set counters flag */
                      CHAR     strtmdef;   /* rtm definition */
                      CHAR     strtmact;   /* rtm active flag */
                      CHAR     strtmdsp;   /* local display active flag */
                    }TPSTMHDR;

/*****************************************************************************/
/* STATUS VARIANT TYPES                                                      */
/*****************************************************************************/

     typedef struct tpashdr{                    /* APPLSTATUS MESSAGE HEADER */
                      union {
                        struct {TPSTAHDR B0G;}B0F; /* Status-Ack variant     */
                        struct {TPSTCHDR B0I;}B0H; /* Status-Control variant */
                        struct {TPSTEHDR B0K;}B0J; /* Status-Error variant   */
                        struct {TPSTRHDR B0M;}B0L; /* Status-Resource variant*/
                        struct {TPSTSHDR B0O;}B0N; /* Status-Session variant */
                        struct {TPSTMHDR X1E;}X1D; /* Status-RTM variant     */
                    }B0E;}
#define stackhdr B0E.B0F.B0G
#define stctlhdr B0E.B0H.B0I
#define sterrhdr B0E.B0J.B0K
#define streshdr B0E.B0L.B0M
#define stseshdr B0E.B0N.B0O
#define strtmhdr B0E.X1D.X1E
                    TPASHDR;

/*****************************************************************************/
/* FMI APPLDATA HERE                                                         */
/*****************************************************************************/

     typedef struct tpfmihdr{                     /* FMI DATA MESSAGE HEADER */
                     CHAR     fhackrqd;
#define NOACKREQ 0
#define ACKREQ   1
                     CHAR     fhpad1;
                     INTEGER  fhmsgkey;
                     CHAR     fhflags1;           /* BIT SIGNIFICANT */
#define AF_FMH  0x80
#define AF_BC   0x40
#define AF_EC   0x20
#define AF_COMM 0x10
#define AF_BB   0x08
#define AF_EB   0x04
#define AF_CD   0x02
#define AF_SD   0x01
                     CHAR     fhflags2;           /* BIT SIGNIFICANT */
#define AF_CODE 0x80
#define AF_ENCR 0x40
#define AF_ENPD 0x20
#define AF_QRI  0x10
#define AF_CEI  0x08
#define AF_BBIU 0x04
#define AF_EBIU 0x02
#define AF_RBI  0x01
                     INTEGER  fhpad2;
                     INTEGER  fhpad3;
                     INTEGER  fhseqno;
                   }TPFMIHDR;

/*****************************************************************************/
/* MAIN DEFINITION OF MESSAGE HEADER                                         */
/*****************************************************************************/

#ifdef WIN32_SUPPORT
 #define PTRBFHDR struct bufhdr *
#else
 #define PTRBFHDR struct bufhdr far *
#endif

     typedef struct bufhdr{
                     PTRBFHDR nxtqptr;
                     PTRBFELT hdreptr;
                     CHAR     numelts;
                     CHAR     msgtype;
#define OPENMSG  1
#define CLOSEMSG 2
#define DATAFMI  32
#define STATFMI  33
                     CHAR     srcl;
                     CHAR     srcp;
#define S3PROD   18                               /* 3270 Partner number     */
                     INTEGER  srci;
                     CHAR     destl;
                     CHAR     destp;
                     INTEGER  desti;
                     union {
                       struct {TPOPHDR  B1C;}B1B;
                       struct {TPCLHDR  B1E;}B1D;
                       struct {TPFMIHDR B1K;}B1J;
                       struct {TPASHDR  B1M;}B1L;
                     }B0Y;}
#define ophdr    B0Y.B1B.B1C
#define clhdr    B0Y.B1D.B1E
#define dfhdr    B0Y.B1J.B1K
#define sfhdr    B0Y.B1L.B1M
                     BUFHDR;

/*****************************************************************************/
/* RETURN CONSTANTS FOR SBPURCV                                              */
/*****************************************************************************/

#define CSUNORES 0 /* NO RESULT                                              */
#define CSUMSGRT 1 /* MESSAGE RETURNED                                       */
#define CSUPTHER 2 /* PATH ERROR                                             */
#define CSUTERM  3 /* TERMINATE                                              */
#define CSUBUFSH 4 /* BUFFER SHORTAGE                                        */

/*****************************************************************************/
/* PROCTYPE AND SERVTYPE PARAMETERS FOR SBPUINIT                             */
/*****************************************************************************/

#define CLIENT           2      /* client entry                              */
#define CES3270          2      /* SNAP-3270                                 */

/*****************************************************************************/
/* DL-Base return Values                                                     */
/*****************************************************************************/

#ifndef NO_ERROR
 #define NO_ERROR         0
#endif

#define CEDINNOMSG       0          /* status = no message or status         */
#define CEDINMSG         1          /* status = got message                  */
#define CEDINLLN         2          /* status = lost locality                */

/* values for SBPUINIT only */

#define DMBASE          550            /* Base level for Com Manager errors  */
#define DMLTABF         (DMBASE + 5)   /* L-table full                       */
#define DMMNWGI         (DMBASE + 12)  /* NetWkstaGetInfo call failed        */
#define DMDSTFL         (DMBASE + 13)  /* Service table full                 */
#define DMMPIPF         (DMBASE + 17)  /* Make pipe call failed              */
#define DMCOMNM         (DMBASE + 32)  /* No name found for this service     */
#define DMCOMDUP        (DMBASE + 46)  /* Duplicate COMNAME for service      */
#define DMNOTLOG        (DMBASE + 48)  /* User not logged on                 */
#define DMCFGOPN        (DMBASE + 66)  /* Failed to open the config file     */
#define DMCFREAD        (DMBASE + 68)  /* Error reading config file          */
#define DMNONAP         (DMBASE + 75)  /* NAP not up when starting service   */
#define WINBASE          950           /* Base level for Windows-only errors */
#define DMMAXAPP        (WINBASE+3)    /* Exceeded max # of concurrent apps  */

/*****************************************************************************/
/* Dmod/DL-Base entry points                                                 */
/*****************************************************************************/

#ifdef MSWIN_SUPPORT
 #ifndef APIENTRY
  #define APIENTRY WINAPI
 #endif
#endif

#ifdef OS2_SUPPORT
extern USHORT   APIENTRY  sbpuinit (HSEM FAR *, USHORT, USHORT, UCHAR FAR *);
extern USHORT   APIENTRY  sbpurcv (PTRBFHDR FAR *, INTEGER FAR*);
#endif

#ifdef WIN32_SUPPORT
extern USHORT WINAPI sbpuinit (HANDLE *, USHORT, USHORT, UCHAR *);
extern USHORT WINAPI sbpurcv (PTRBFHDR *, INTEGER *);
#endif

#ifdef MSWIN_SUPPORT
extern USHORT   WINAPI  sbpuinit (USHORT, USHORT, UCHAR FAR *);
#endif

#ifdef DOS_SUPPORT
extern USHORT   APIENTRY  sbpuinit (HSEM FAR *, USHORT, USHORT);
#endif

#ifndef WIN32_SUPPORT
extern USHORT   APIENTRY  sbpurcvx (BUFHDR FAR * FAR *, INTEGER, INTEGER);
extern VOID     APIENTRY  sbpusend (PTRBFHDR);
extern VOID     APIENTRY  sbputerm (VOID);
#else
extern USHORT WINAPI sbpurcvx (BUFHDR * *, INTEGER, INTEGER);
extern VOID   WINAPI sbpusend (PTRBFHDR);
extern VOID   WINAPI sbputerm (VOID);
#endif

#ifdef OS2_SUPPORT
extern USHORT APIENTRY sepdrout(USHORT (APIENTRY *) (BUFHDR far *, USHORT, USHORT));
#endif

#ifdef WIN32_SUPPORT
extern ULONG WINAPI sepdrout(ULONG (WINAPI *) (BUFHDR *, USHORT, USHORT));
#endif

#ifdef MSWIN_SUPPORT
extern USHORT WINAPI sepwrout(USHORT (WINAPI *) (BUFHDR far *, USHORT, USHORT));
#endif

#ifdef DOS_SUPPORT
extern USHORT APIENTRY sepdrout(USHORT (APIENTRY *) (BUFHDR far *, USHORT, USHORT));
#endif

/*****************************************************************************/
/* Buffer pool access routines                                               */
/*****************************************************************************/

#ifndef WIN32_SUPPORT
extern PTRBFHDR APIENTRY  sepdbubl (USHORT);
extern VOID     APIENTRY  sepdburl (PTRBFHDR);

extern VOID     APIENTRY  sbpibegt (PTRBFELT FAR *);
extern VOID     APIENTRY  sbpiberl (PTRBFELT FAR *);

extern VOID     APIENTRY  sepdchnk (USHORT FAR *, USHORT FAR *);
#else
extern PTRBFHDR WINAPI sepdbubl (USHORT);
extern VOID     WINAPI sepdburl (PTRBFHDR);

extern VOID     WINAPI sbpibegt (PTRBFELT *);
extern VOID     WINAPI sbpiberl (PTRBFELT *);

extern VOID     WINAPI sepdchnk (USHORT *, USHORT *);
#endif

/*****************************************************************************/
/* Structures for the 3270 user record.                                      */
/*****************************************************************************/

#define CERT3270  0x0002           /* 3270 user record type                  */
#define CECWKHAC  8                /* Length of Host Access Name             */
#define CECWKUNM  20               /* Length of 3270 user name               */
#define CECWKREM  25               /* Length of record remark                */
#define CE3MASMX  10               /* Max number of 3270 sessions            */

typedef struct tecwrksd
{
  UCHAR   cwshost[CECWKHAC + 1];   /* LU/Pool name accessed                  */
  USHORT  cwsestyp;                /* Session type (M2, M3, M4, M5, printer) */
#define CERTMOD2 0                 /* 24x80                                  */
#define CERTMOD3 1                 /* 32x80                                  */
#define CERTMOD4 2                 /* 43x80                                  */
#define CERTMOD5 3                 /* 27x132                                 */
#define CERTPRNT 4                 /* Host printer                           */
  USHORT  cwsmodov;                /* Has the user got override permission?  */
  USHORT  cwspad;                  /* 2 bytes of padding                     */
} TECWRKSD;

typedef struct tecwrkus
{
  USHORT   cwlen;                  /* Length of record                       */
  USHORT   cwtype;                 /* Type of record                         */
  UCHAR    cwname[CECWKUNM + 1];   /* User name                              */
  UCHAR    cwremark[CECWKREM + 1]; /* Comment field                          */
  UCHAR    cwstylef[9];            /* Initial style file name - no extnsn    */
  USHORT   cwvewrtm;               /* Can user view RTM info ?               */
  USHORT   cwalert;                /* Has user got ALERT permission ?        */
  USHORT   cwchghan;               /* Can change LU/Pool name accessed ?     */
  USHORT   cwmaxses;               /* Maximum number of active sessions 1-10 */
  USHORT   cwnumrec;               /* Number of sessions for user            */
  TECWRKSD cwsesdat[CE3MASMX];     /* Session information records            */
  USHORT   cwmodisf;               /* Permission to modify initial style     */
  USHORT   cwpad;                  /* 2 bytes of padding                     */
  USHORT   cwnumrmp;               /* Number of LUs/Pools in remap list      */
  TECWRKSD cwremap[1];             /* LU/Pool Remap list                     */
} TECWRKUS;

/*****************************************************************************/
/* Structures for the diagnostics record.                                    */
/*****************************************************************************/

#define CERTDIAG  0x0001           /* Diagnostics record type                */
#define CECNUMAL  20               /* Max number of ALERTs configurable      */
#define CECALRNM  52               /* Length of ALERT description 52 (arr sz)*/
#define CECALRNA  34               /* Actual length of ALERT desc is 34      */
#define CECALRPR  32               /* Length of parameter description        */
#define CECONAME  8                /* Length of connection name              */
#define CESTRLEN  128              /* Length of a string + 1                 */
#define CECCNLEN  15               /* Length of a computer name              */

typedef struct tedalert
{
  UCHAR    dalrtnam[CECALRNM + 1]; /* Description of the ALERT number        */
  UCHAR    daparam1[CECALRPR + 1]; /* Description of parameter 1             */
  UCHAR    daparam2[CECALRPR + 1]; /* Description of parameter 2             */
  UCHAR    daparam3[CECALRPR + 1]; /* Description of parameter 3             */
} TEDALERT;

typedef struct tediagns
{
  USHORT   dilen;                  /* Length of record                       */
  USHORT   ditype;                 /* Type of record                         */
  UCHAR    dinetmgt[CECONAME + 1]; /* Network Management Connection name     */
  USHORT   disrtmco;               /* Send RTM data at counter overflow      */
  USHORT   disrtmub;               /* Send RTM data at UNBIND                */
  USHORT   diwruldr;               /* RTM timers run until:                  */
#define CERTWRIT 0                 /*  0 - first data reaches screen         */
#define CERTUNLK 1                 /*  1 - host unlocks keyboard             */
#define CERTDIRE 2                 /*  2 - host lets user send               */
  USHORT   dirtmth1;               /* RTM threshold #1                       */
  USHORT   dirtmth2;               /* RTM threshold #2                       */
  USHORT   dirtmth3;               /* RTM threshold #3                       */
  USHORT   dirtmth4;               /* RTM threshold #4                       */
  TEDALERT dialerts[CECNUMAL];     /* ALERT description records              */
  UCHAR    diaudit[CESTRLEN];      /* Audit log filename                     */
  UCHAR    dierror[CESTRLEN];      /* Error log filename                     */
  USHORT   diaudlev;               /* Default audit level                    */
                                   /*   0   -   level 6                      */
                                   /*   1   -   level 8                      */
                                   /*   2   -   level 10                     */
  UCHAR    dipad[CECCNLEN + 1];    /* 16 bytes of padding                    */
} TEDIAGNS;

/*****************************************************************************/
/* Routine to access config information                                      */
/*****************************************************************************/
#ifndef WIN32_SUPPORT
USHORT APIENTRY sepdcrec(UCHAR FAR *, USHORT, USHORT FAR * );
#else
USHORT WINAPI sepdcrec(UCHAR *, USHORT, USHORT * );
#endif

/*****************************************************************************/
/* Return codes from sepdcrec                                                */
/*****************************************************************************/

#define NOCSSRVR 1                   /* No config server available           */
#define NODGNREC 2                   /* Diagnostics record not found         */
#define NOUSRREC 3                   /* No user record found for this user   */
#define BUF2SMAL 4                   /* Buffer too small                     */
#define NONOS    5                   /* Network not started                  */
#define NOTLOGON 6                   /* User not logged on to network        */
#define READERR  7                   /* File read error                      */
#define NONAP    8                   /* NAP not started                      */
#define MAXAPP   9                   /* Max # of client apps reached         */
#define ERROR_SERVER 14              /* Error on the server end of the RPC   */
#define ERROR_LOCAL_FAILURE 15       /* Error on the local end of the RPC    */

/*****************************************************************************/
/* Structure of version information block                                    */
/*****************************************************************************/

typedef struct cs_info {
  unsigned short    length;            /* length of this struct (bytes)      */
                                       /* (supplied parameter)               */
  unsigned char     major_ver;         /* CS major ver CS1.1->1, CS2.0->2    */
  unsigned char     minor_ver;         /* CS minor ver CS1.1->10 (dec)       */
  unsigned char     config_share[80];  /* name of share point of current     */
                                       /* config file = default location for */
                                       /* style file \\box\share\ (null      */
                                       /* terminated)                        */
  unsigned short    nos;               /* NOS that the LAN is running        */
#define Workstation 0
#define LANMan      1      /* Also LAN Server, unless we can differentiate   */
#define NetWare     2
} CS_INFO;

/*****************************************************************************/
/* Routine to get version information                                        */
/*****************************************************************************/
#ifndef WIN32_SUPPORT
USHORT APIENTRY sepdgetinfo(struct cs_info far * );
#else
USHORT WINAPI sepdgetinfo(struct cs_info * );
#endif

/*****************************************************************************/
/* Additional return code from sepdgetinfo.                                  */
/*****************************************************************************/
#define BADLNGTH 2


/*****************************************************************************/
/* Function definition for fmistrings dll entry point                        */
/*****************************************************************************/
int WINAPI GetFmiReturnCode (UINT,UINT,UINT,unsigned char FAR * );

/*****************************************************************************/
/* typedef for casting proc address return from GetProcAddress               */
/*****************************************************************************/
typedef int (FAR WINAPI * PGETFMISTR)(UINT, UINT, UINT, char FAR *);

/*****************************************************************************/
/* Macro for creating the first parameter for the GetFmiReturnCode call when */
/* using the error code and qualifier off a FMI status message.              */
/*****************************************************************************/
#define FMISTAT_TO_INT(code, qual)  ((INTEGER) (((code >> 8) << 8) | (qual >> 8)))

#ifdef WIN32_SUPPORT
  #pragma pack()
#endif

#ifdef __cplusplus
}
#endif

#endif
/* End of file fmi.h */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\Filtcat.h ===
struct MyCatId : public CATID
{
	inline MyCatId(const CATID &catid) {memcpy((CATID *) this, &catid, sizeof(CATID));}
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\fltdefs.h ===
/*++

Copyright (c) 1995-1999  Microsoft Corporation

Module Name:

   fltdefs.h

Abstract:

    Definitions for the WIN32 filter APIs

Author:

    Arnold Miller (arnoldm) 24-Sept-1997

Revision History:

--*/

#ifndef _FLTDEFS_H
#define _FLTDEFS_H

#if _MSC_VER > 1000
#pragma once
#endif

typedef PVOID  FILTER_HANDLE, *PFILTER_HANDLE;
typedef PVOID  INTERFACE_HANDLE, *PINTERFACE_HANDLE;

#define PFEXPORT _declspec(dllexport)

#ifdef __cplusplus
#define EXTERNCDECL EXTERN_C
#else
#define EXTERNCDECL
#endif

#define PFAPIENTRY EXTERNCDECL DWORD PFEXPORT WINAPI

typedef enum _GlobalFilter
{
    GF_FRAGMENTS = 2,        // check consistency of fragments
    GF_STRONGHOST = 8,       // check destination address of input frames
    GF_FRAGCACHE = 9         // check fragments from cache
} GLOBAL_FILTER, *PGLOBAL_FILTER;

typedef enum _PfForwardAction
{
    PF_ACTION_FORWARD = 0,
    PF_ACTION_DROP
} PFFORWARD_ACTION, *PPFFORWARD_ACTION;

typedef enum _PfAddresType
{
    PF_IPV4,
    PF_IPV6
} PFADDRESSTYPE, *PPFADDRESSTYPE;

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// The constants that should be used to set up the FILTER_INFO_STRUCTURE    //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#define FILTER_PROTO(ProtoId)   MAKELONG(MAKEWORD((ProtoId),0x00),0x00000)

#define FILTER_PROTO_ANY        FILTER_PROTO(0x00)
#define FILTER_PROTO_ICMP       FILTER_PROTO(0x01)
#define FILTER_PROTO_TCP        FILTER_PROTO(0x06)
#define FILTER_PROTO_UDP        FILTER_PROTO(0x11)

#define FILTER_TCPUDP_PORT_ANY  (WORD)0x0000

#define FILTER_ICMP_TYPE_ANY    (BYTE)0xff
#define FILTER_ICMP_CODE_ANY    (BYTE)0xff

typedef struct _PF_FILTER_DESCRIPTOR
{
    DWORD           dwFilterFlags;    // see below
    DWORD           dwRule;           // copied into the log when appropriate
    PFADDRESSTYPE   pfatType;
    PBYTE           SrcAddr;
    PBYTE           SrcMask;
    PBYTE           DstAddr;
    PBYTE           DstMask;
    DWORD           dwProtocol;
    DWORD           fLateBound;
    WORD            wSrcPort;
    WORD            wDstPort;
    WORD            wSrcPortHighRange;
    WORD            wDstPortHighRange;
}PF_FILTER_DESCRIPTOR, *PPF_FILTER_DESCRIPTOR;


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Structure for PfGetInterfaceStatistics                                   //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

typedef struct _PF_FILTER_STATS
{
    DWORD       dwNumPacketsFiltered;
    PF_FILTER_DESCRIPTOR info;
}PF_FILTER_STATS, *PPF_FILTER_STATS;

typedef struct _PF_INTERFACE_STATS
{
    PVOID               pvDriverContext;
    DWORD               dwFlags;          // none as yet (28-Sept-1997)
    DWORD               dwInDrops;
    DWORD               dwOutDrops;
    PFFORWARD_ACTION    eaInAction;
    PFFORWARD_ACTION    eaOutAction;
    DWORD               dwNumInFilters;
    DWORD               dwNumOutFilters;
    DWORD               dwFrag;
    DWORD               dwSpoof;
    DWORD               dwReserved1;
    DWORD               dwReserved2;
    LARGE_INTEGER       liSYN;
    LARGE_INTEGER       liTotalLogged;
    DWORD               dwLostLogEntries;
    PF_FILTER_STATS     FilterInfo[1];
} PF_INTERFACE_STATS, *PPF_INTERFACE_STATS;


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// The number of bytes starting at SrcAddr. If you add something to the     //
// structure make sure this remains valid                                   //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#define FILTERSIZE                                      \
    (sizeof(PF_FILTER_DESCRIPTOR) -                     \
     (DWORD)(&((PPF_FILTER_DESCRIPTOR)0)->SrcAddr))


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Flags for PF_FILTER_DESCRIPTOR                                           //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

//
// Disallows incoming SYN
//

#define FD_FLAGS_NOSYN      0x1

//
// All legal flags
//

#define FD_FLAGS_ALLFLAGS   FD_FLAGS_NOSYN


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Late bound defs. Go in fLateBound in a PF_FILTER_DESCRIPTOR and          //
// describe which other fields of the filter are affected  by a             //
// PfRebindFilters call. In general such filters are on  WAN interfaces     //
// where one or the other address may change as the connection is           //
// reconnected.                                                             //
// The assumption is that such interfaces HAVE ONLY ONE ADDRESS.            //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////


#define LB_SRC_ADDR_USE_SRCADDR_FLAG     0x00000001
#define LB_SRC_ADDR_USE_DSTADDR_FLAG     0x00000002
#define LB_DST_ADDR_USE_SRCADDR_FLAG     0x00000004
#define LB_DST_ADDR_USE_DSTADDR_FLAG     0x00000008
#define LB_SRC_MASK_LATE_FLAG            0x00000010
#define LB_DST_MASK_LATE_FLAG            0x00000020

typedef struct _PF_LATEBIND_INFO
{
    PBYTE   SrcAddr;
    PBYTE   DstAddr;
    PBYTE   Mask;
}PF_LATEBIND_INFO, *PPF_LATEBIND_INFO;

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// The format of a logged frame and defs for it.                            //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

typedef enum _PfFrameType
{
    PFFT_FILTER = 1,                  // a filter violation
    PFFT_FRAG   = 2,                  // bad fragment
    PFFT_SPOOF   = 3                  // strong host failure
} PFFRAMETYPE, *PPFFRAMETYPE;

typedef struct _pfLogFrame
{
    LARGE_INTEGER  Timestamp;
    PFFRAMETYPE    pfeTypeOfFrame;
    DWORD          dwTotalSizeUsed;      // used to find the next frame
    DWORD          dwFilterRule;         // from the filter
    WORD           wSizeOfAdditionalData;
    WORD           wSizeOfIpHeader;
    DWORD          dwInterfaceName;      // the name of the interface
    DWORD          dwIPIndex;
    BYTE           bPacketData[1];       // the frame. wsizeOfIpHeader
                                         // and wsizeOfAdditionalData
                                         // describe this
} PFLOGFRAME, *PPFLOGFRAME;

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Error codes. These extend the WIN32 errors by having errors specific to  //
// these APIs. Besides these errors, the APIs may return any of the WIN32   //
// errors.                                                                  //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////


#define ERROR_BASE  23000

#define PFERROR_NO_PF_INTERFACE    (ERROR_BASE + 0)   // never returned.
#define PFERROR_NO_FILTERS_GIVEN   (ERROR_BASE + 1)
#define PFERROR_BUFFER_TOO_SMALL   (ERROR_BASE + 2)
#define ERROR_IPV6_NOT_IMPLEMENTED (ERROR_BASE + 3)


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// The API prototypes                                                       //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

PFAPIENTRY
PfCreateInterface(
    DWORD            dwName,
    PFFORWARD_ACTION inAction,
    PFFORWARD_ACTION outAction,
    BOOL             bUseLog,
    BOOL             bMustBeUnique,
    INTERFACE_HANDLE *ppInterface
    );

PFAPIENTRY
PfDeleteInterface(
    INTERFACE_HANDLE pInterface
    );

PFAPIENTRY
PfAddFiltersToInterface(
    INTERFACE_HANDLE      ih,
    DWORD                 cInFilters,
    PPF_FILTER_DESCRIPTOR pfiltIn,
    DWORD                 cOutFilters,
    PPF_FILTER_DESCRIPTOR pfiltOut,
    PFILTER_HANDLE        pfHandle
    );

PFAPIENTRY
PfRemoveFiltersFromInterface(
    INTERFACE_HANDLE      ih,
    DWORD                 cInFilters,
    PPF_FILTER_DESCRIPTOR pfiltIn,
    DWORD                 cOutFilters,
    PPF_FILTER_DESCRIPTOR pfiltOut
    );

PFAPIENTRY
PfRemoveFilterHandles(
    INTERFACE_HANDLE   pInterface,
    DWORD              cFilters,
    PFILTER_HANDLE     pvHandles
    );


PFAPIENTRY
PfUnBindInterface(
    INTERFACE_HANDLE   pInterface
    );

PFAPIENTRY
PfBindInterfaceToIndex(
    INTERFACE_HANDLE    pInterface,
    DWORD               dwIndex,
    PFADDRESSTYPE       pfatLinkType,
    PBYTE               LinkIPAddress
    );

PFAPIENTRY
PfBindInterfaceToIPAddress(
    INTERFACE_HANDLE    pInterface,
    PFADDRESSTYPE       pfatType,
    PBYTE               IPAddress
    );

PFAPIENTRY
PfRebindFilters(
    INTERFACE_HANDLE    pInterface,
    PPF_LATEBIND_INFO   pLateBindInfo
    );

PFAPIENTRY
PfAddGlobalFilterToInterface(
    INTERFACE_HANDLE   pInterface,
    GLOBAL_FILTER      gfFilter
    );

PFAPIENTRY
PfRemoveGlobalFilterFromInterface(
    INTERFACE_HANDLE   pInterface,
    GLOBAL_FILTER      gfFilter
    );


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Log APIs. Note that there is at most one log and it must be created      //
// before any interface needing it is created. There is no way to set a     //
// log onto an existing interface. The log can be applied to any or all of  //
// the interfaces.                                                          //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

PFAPIENTRY
PfMakeLog(
    HANDLE  hEvent
    );

//
// Provide a buffer, and notification parameters, and get back
// the old buffer and status.
//

PFAPIENTRY
PfSetLogBuffer(
    PBYTE   pbBuffer,
    DWORD   dwSize,
    DWORD   dwThreshold,
    DWORD   dwEntries,
    PDWORD  pdwLoggedEntries,
    PDWORD  pdwLostEntries,
    PDWORD  pdwSizeUsed
    );

//
// Doing this will disable the log on any of the interfaces. But if
// an interface was created with the log, the actual log will not be
// completely deleted until that interface is deleted. This is a small
// point, but it might explain a mystery or two.
//

PFAPIENTRY
PfDeleteLog(
    VOID
    );


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Get statistics. Note pdwBufferSize in an IN/OUT parameter. If            //
// ERROR_INSUFFICIENT_BUFFER is returned, the common statistics are         //
// available and the correct byte count is in *pdwBufferSize. If only the   //
// interface statistics are needed, provide a buffer of size                //
// PF_INTERFACE_STATS only.                                                 //
// If the filter descriptions are also needed, then supply a large buffer,  //
// or use the returned count from the first call to allocate a buffer of    //
// sufficient size. Note that for a shared interface, this second call may  //
// fail with ERROR_INSUFFICIENT_BUFFER. This can happen if the other        //
// sharers add filters in the interim. This should not happen for a UNIQUE  //
// interface.                                                               //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////


PFAPIENTRY
PfGetInterfaceStatistics(
    INTERFACE_HANDLE    pInterface,
    PPF_INTERFACE_STATS ppfStats,
    PDWORD              pdwBufferSize,
    BOOL                fResetCounters
    );


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Test a packet.                                                           //
// This call will evaluate the packet against the given interfaces          //
// and return the filtering action.                                         //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

PFAPIENTRY
PfTestPacket(
    INTERFACE_HANDLE   pInInterface  OPTIONAL,
    INTERFACE_HANDLE   pOutInterface OPTIONAL,
    DWORD              cBytes,
    PBYTE              pbPacket,
    PPFFORWARD_ACTION  ppAction
    );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\fpieee.h ===
/***
*fpieee.h - Definitions for floating point IEEE exception handling
*
*       Copyright (c) 1991-2000, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains constant and type definitions for handling
*       floating point exceptions [ANSI/IEEE std. 754]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_FPIEEE
#define _INC_FPIEEE

#if     !defined(_WIN32) && !defined(_MAC)
#error ERROR: Only Mac or Win32 targets supported!
#endif


#ifndef __assembler     /* MIPS ONLY: Protect from assembler */

#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef __cplusplus
extern "C" {
#endif



/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

/* Define _CRTAPI1 (for compatibility with the NT SDK) */

#ifndef _CRTAPI1
#if	_MSC_VER >= 800 && _M_IX86 >= 300
#define _CRTAPI1 __cdecl
#else
#define _CRTAPI1
#endif
#endif

/*
 * Define floating point IEEE compare result values.
 */

typedef enum {
    _FpCompareEqual,
    _FpCompareGreater,
    _FpCompareLess,
    _FpCompareUnordered
} _FPIEEE_COMPARE_RESULT;

/*
 * Define floating point format and result precision values.
 */

typedef enum {
    _FpFormatFp32,
    _FpFormatFp64,
    _FpFormatFp80,
    _FpFormatFp128,
    _FpFormatI16,
    _FpFormatI32,
    _FpFormatI64,
    _FpFormatU16,
    _FpFormatU32,
    _FpFormatU64,
    _FpFormatBcd80,
    _FpFormatCompare,
    _FpFormatString
} _FPIEEE_FORMAT;

/*
 * Define operation code values.
 */

typedef enum {
    _FpCodeUnspecified,
    _FpCodeAdd,
    _FpCodeSubtract,
    _FpCodeMultiply,
    _FpCodeDivide,
    _FpCodeSquareRoot,
    _FpCodeRemainder,
    _FpCodeCompare,
    _FpCodeConvert,
    _FpCodeRound,
    _FpCodeTruncate,
    _FpCodeFloor,
    _FpCodeCeil,
    _FpCodeAcos,
    _FpCodeAsin,
    _FpCodeAtan,
    _FpCodeAtan2,
    _FpCodeCabs,
    _FpCodeCos,
    _FpCodeCosh,
    _FpCodeExp,
    _FpCodeFabs,
    _FpCodeFmod,
    _FpCodeFrexp,
    _FpCodeHypot,
    _FpCodeLdexp,
    _FpCodeLog,
    _FpCodeLog10,
    _FpCodeModf,
    _FpCodePow,
    _FpCodeSin,
    _FpCodeSinh,
    _FpCodeTan,
    _FpCodeTanh,
    _FpCodeY0,
    _FpCodeY1,
    _FpCodeYn,
    _FpCodeLogb,
    _FpCodeNextafter,
    _FpCodeNegate, 
    _FpCodeFmin,         //XMMI
    _FpCodeFmax,         //XMMI
    _FpCodeConvertTrunc, //XMMI
    _XMMIAddps,          //XMMI
    _XMMIAddss,
    _XMMISubps,
    _XMMISubss,
    _XMMIMulps,
    _XMMIMulss,
    _XMMIDivps,
    _XMMIDivss,
    _XMMISqrtps,
    _XMMISqrtss,
    _XMMIMaxps,
    _XMMIMaxss,
    _XMMIMinps,
    _XMMIMinss,
    _XMMICmpps,
    _XMMICmpss,
    _XMMIComiss,
    _XMMIUComiss,
    _XMMICvtpi2ps,
    _XMMICvtsi2ss,
    _XMMICvtps2pi,
    _XMMICvtss2si,
    _XMMICvttps2pi,
    _XMMICvttss2si,
    _XMMI2Addpd,         //XMMI2 
    _XMMI2Addsd,
    _XMMI2Subpd,
    _XMMI2Subsd,
    _XMMI2Mulpd,
    _XMMI2Mulsd,
    _XMMI2Divpd,
    _XMMI2Divsd,
    _XMMI2Sqrtpd,
    _XMMI2Sqrtsd,
    _XMMI2Maxpd,
    _XMMI2Maxsd,
    _XMMI2Minpd,
    _XMMI2Minsd,
    _XMMI2Cmppd,
    _XMMI2Cmpsd,
    _XMMI2Comisd,
    _XMMI2UComisd,
    _XMMI2Cvtpd2pi,   //66 2D
    _XMMI2Cvtsd2si,   //F2
    _XMMI2Cvttpd2pi,  //66 2C
    _XMMI2Cvttsd2si,  //F2
    _XMMI2Cvtps2pd,   //0F 5A
    _XMMI2Cvtss2sd,   //F3
    _XMMI2Cvtpd2ps,   //66
    _XMMI2Cvtsd2ss,   //F2
    _XMMI2Cvtdq2ps,   //0F 5B
    _XMMI2Cvttps2dq,  //F3
    _XMMI2Cvtps2dq,   //66
    _XMMI2Cvttpd2dq,  //66 0F E6
    _XMMI2Cvtpd2dq    //F2 
    } _FP_OPERATION_CODE;

#endif  /* #ifndef __assembler */

/*
 * Define rounding modes.
 */

#ifndef __assembler     /* MIPS ONLY: Protect from assembler */

typedef enum {
    _FpRoundNearest,
    _FpRoundMinusInfinity,
    _FpRoundPlusInfinity,
    _FpRoundChopped
} _FPIEEE_ROUNDING_MODE;

typedef enum {
    _FpPrecisionFull,
    _FpPrecision53,
    _FpPrecision24
} _FPIEEE_PRECISION;


/*
 * Define floating point context record
 */

typedef float           _FP32;
typedef double          _FP64;
typedef short           _I16;
typedef int             _I32;
typedef unsigned short  _U16;
typedef unsigned int    _U32;
typedef __int64         _Q64;


typedef struct {
    unsigned short W[5];
} _FP80;

typedef struct {
    unsigned long W[4];
} _FP128;

typedef struct {
    unsigned long W[2];
} _I64;

typedef struct {
    unsigned long W[2];
} _U64;

typedef struct {
    unsigned short W[5];
} _BCD80;

typedef struct {
    _Q64 W[2];
} _FPQ64;

typedef struct {
    union {
        _FP32        Fp32Value;
        _FP64        Fp64Value;
        _FP80        Fp80Value;
        _FP128       Fp128Value;
        _I16         I16Value;
        _I32         I32Value;
        _I64         I64Value;
        _U16         U16Value;
        _U32         U32Value;
        _U64         U64Value;
        _BCD80       Bcd80Value;
        char         *StringValue;
        int          CompareValue;
        _Q64         Q64Value;
        _FPQ64       Fpq64Value;
    } Value;

    unsigned int OperandValid : 1;
    unsigned int Format : 4;

} _FPIEEE_VALUE;


typedef struct {
    unsigned int Inexact : 1;
    unsigned int Underflow : 1;
    unsigned int Overflow : 1;
    unsigned int ZeroDivide : 1;
    unsigned int InvalidOperation : 1;
} _FPIEEE_EXCEPTION_FLAGS;


typedef struct {
    unsigned int RoundingMode : 2;
    unsigned int Precision : 3;
    unsigned int Operation :12;
    _FPIEEE_EXCEPTION_FLAGS Cause;
    _FPIEEE_EXCEPTION_FLAGS Enable;
    _FPIEEE_EXCEPTION_FLAGS Status;
    _FPIEEE_VALUE Operand1;
    _FPIEEE_VALUE Operand2;
    _FPIEEE_VALUE Result;
} _FPIEEE_RECORD, *_PFPIEEE_RECORD;


struct _EXCEPTION_POINTERS;

/*
 * Floating point IEEE exception filter routine
 */

int __cdecl _fpieee_flt(
        unsigned long,
        struct _EXCEPTION_POINTERS *,
        int (__cdecl *)(_FPIEEE_RECORD *)
        );

#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */
#endif  /* #ifndef __assembler */

#endif  /* _INC_FPIEEE */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\filter.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0279 */
/* at Fri Sep 24 19:29:17 1999
 */
/* Compiler settings for filter.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __filter_h__
#define __filter_h__

/* Forward Declarations */ 

#ifndef __IFilter_FWD_DEFINED__
#define __IFilter_FWD_DEFINED__
typedef interface IFilter IFilter;
#endif 	/* __IFilter_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "objidl.h"
#include "propidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_filter_0000 */
/* [local] */ 

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993-1999.
//
//--------------------------------------------------------------------------
#if !defined(_TAGFULLPROPSPEC_DEFINED_)
#define _TAGFULLPROPSPEC_DEFINED_
typedef struct tagFULLPROPSPEC
    {
    GUID guidPropSet;
    PROPSPEC psProperty;
    }	FULLPROPSPEC;

#endif // #if !defined(_TAGFULLPROPSPEC_DEFINED_)


extern RPC_IF_HANDLE __MIDL_itf_filter_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_filter_0000_v0_0_s_ifspec;

#ifndef __IFilter_INTERFACE_DEFINED__
#define __IFilter_INTERFACE_DEFINED__

/* interface IFilter */
/* [unique][uuid][object][local] */ 

#ifndef _tagIFILTER_INIT_DEFINED
typedef 
enum tagIFILTER_INIT
    {	IFILTER_INIT_CANON_PARAGRAPHS	= 1,
	IFILTER_INIT_HARD_LINE_BREAKS	= 2,
	IFILTER_INIT_CANON_HYPHENS	= 4,
	IFILTER_INIT_CANON_SPACES	= 8,
	IFILTER_INIT_APPLY_INDEX_ATTRIBUTES	= 16,
	IFILTER_INIT_APPLY_OTHER_ATTRIBUTES	= 32,
	IFILTER_INIT_INDEXING_ONLY	= 64,
	IFILTER_INIT_SEARCH_LINKS	= 128
    }	IFILTER_INIT;

#define _tagIFILTER_INIT_DEFINED
#define _IFILTER_INIT_DEFINED
#endif
#ifndef _tagIFILTER_FLAGS_DEFINED
typedef 
enum tagIFILTER_FLAGS
    {	IFILTER_FLAGS_OLE_PROPERTIES	= 1
    }	IFILTER_FLAGS;

#define _tagIFILTER_FLAGS_DEFINED
#define _IFILTER_FLAGS_DEFINED
#endif
#ifndef _tagCHUNKSTATE_DEFINED
typedef 
enum tagCHUNKSTATE
    {	CHUNK_TEXT	= 0x1,
	CHUNK_VALUE	= 0x2
    }	CHUNKSTATE;

#define _tagCHUNKSTATE_DEFINED
#define _CHUNKSTATE_DEFINED
#endif
#ifndef _tagCHUNK_BREAKTYPE_DEFINED
typedef 
enum tagCHUNK_BREAKTYPE
    {	CHUNK_NO_BREAK	= 0,
	CHUNK_EOW	= 1,
	CHUNK_EOS	= 2,
	CHUNK_EOP	= 3,
	CHUNK_EOC	= 4
    }	CHUNK_BREAKTYPE;

#define _tagCHUNK_BREAKTYPE_DEFINED
#define _CHUNK_BREAKTYPE_DEFINED
#endif
#ifndef _tagFILTERREGION_DEFINED
typedef struct tagFILTERREGION
    {
    ULONG idChunk;
    ULONG cwcStart;
    ULONG cwcExtent;
    }	FILTERREGION;

#define _tagFILTERREGION_DEFINED
#define _FILTERREGION_DEFINED
#endif
#ifndef _tagSTAT_CHUNK_DEFINED
typedef struct tagSTAT_CHUNK
    {
    ULONG idChunk;
    CHUNK_BREAKTYPE breakType;
    CHUNKSTATE flags;
    LCID locale;
    FULLPROPSPEC attribute;
    ULONG idChunkSource;
    ULONG cwcStartSource;
    ULONG cwcLenSource;
    }	STAT_CHUNK;

#define _tagSTAT_CHUNK_DEFINED
#define _STAT_CHUNK_DEFINED
#endif

EXTERN_C const IID IID_IFilter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("89BCB740-6119-101A-BCB7-00DD010655AF")
    IFilter : public IUnknown
    {
    public:
        virtual SCODE STDMETHODCALLTYPE Init( 
            /* [in] */ ULONG grfFlags,
            /* [in] */ ULONG cAttributes,
            /* [size_is][in] */ const FULLPROPSPEC __RPC_FAR *aAttributes,
            /* [out] */ ULONG __RPC_FAR *pFlags) = 0;
        
        virtual SCODE STDMETHODCALLTYPE GetChunk( 
            /* [out] */ STAT_CHUNK __RPC_FAR *pStat) = 0;
        
        virtual SCODE STDMETHODCALLTYPE GetText( 
            /* [out][in] */ ULONG __RPC_FAR *pcwcBuffer,
            /* [size_is][out] */ WCHAR __RPC_FAR *awcBuffer) = 0;
        
        virtual SCODE STDMETHODCALLTYPE GetValue( 
            /* [out] */ PROPVARIANT __RPC_FAR *__RPC_FAR *ppPropValue) = 0;
        
        virtual SCODE STDMETHODCALLTYPE BindRegion( 
            /* [in] */ FILTERREGION origPos,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppunk) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFilterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IFilter __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IFilter __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IFilter __RPC_FAR * This);
        
        SCODE ( STDMETHODCALLTYPE __RPC_FAR *Init )( 
            IFilter __RPC_FAR * This,
            /* [in] */ ULONG grfFlags,
            /* [in] */ ULONG cAttributes,
            /* [size_is][in] */ const FULLPROPSPEC __RPC_FAR *aAttributes,
            /* [out] */ ULONG __RPC_FAR *pFlags);
        
        SCODE ( STDMETHODCALLTYPE __RPC_FAR *GetChunk )( 
            IFilter __RPC_FAR * This,
            /* [out] */ STAT_CHUNK __RPC_FAR *pStat);
        
        SCODE ( STDMETHODCALLTYPE __RPC_FAR *GetText )( 
            IFilter __RPC_FAR * This,
            /* [out][in] */ ULONG __RPC_FAR *pcwcBuffer,
            /* [size_is][out] */ WCHAR __RPC_FAR *awcBuffer);
        
        SCODE ( STDMETHODCALLTYPE __RPC_FAR *GetValue )( 
            IFilter __RPC_FAR * This,
            /* [out] */ PROPVARIANT __RPC_FAR *__RPC_FAR *ppPropValue);
        
        SCODE ( STDMETHODCALLTYPE __RPC_FAR *BindRegion )( 
            IFilter __RPC_FAR * This,
            /* [in] */ FILTERREGION origPos,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppunk);
        
        END_INTERFACE
    } IFilterVtbl;

    interface IFilter
    {
        CONST_VTBL struct IFilterVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFilter_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFilter_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFilter_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFilter_Init(This,grfFlags,cAttributes,aAttributes,pFlags)	\
    (This)->lpVtbl -> Init(This,grfFlags,cAttributes,aAttributes,pFlags)

#define IFilter_GetChunk(This,pStat)	\
    (This)->lpVtbl -> GetChunk(This,pStat)

#define IFilter_GetText(This,pcwcBuffer,awcBuffer)	\
    (This)->lpVtbl -> GetText(This,pcwcBuffer,awcBuffer)

#define IFilter_GetValue(This,ppPropValue)	\
    (This)->lpVtbl -> GetValue(This,ppPropValue)

#define IFilter_BindRegion(This,origPos,riid,ppunk)	\
    (This)->lpVtbl -> BindRegion(This,origPos,riid,ppunk)

#endif /* COBJMACROS */


#endif 	/* C style interface */



SCODE STDMETHODCALLTYPE IFilter_Init_Proxy( 
    IFilter __RPC_FAR * This,
    /* [in] */ ULONG grfFlags,
    /* [in] */ ULONG cAttributes,
    /* [size_is][in] */ const FULLPROPSPEC __RPC_FAR *aAttributes,
    /* [out] */ ULONG __RPC_FAR *pFlags);


void __RPC_STUB IFilter_Init_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


SCODE STDMETHODCALLTYPE IFilter_GetChunk_Proxy( 
    IFilter __RPC_FAR * This,
    /* [out] */ STAT_CHUNK __RPC_FAR *pStat);


void __RPC_STUB IFilter_GetChunk_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


SCODE STDMETHODCALLTYPE IFilter_GetText_Proxy( 
    IFilter __RPC_FAR * This,
    /* [out][in] */ ULONG __RPC_FAR *pcwcBuffer,
    /* [size_is][out] */ WCHAR __RPC_FAR *awcBuffer);


void __RPC_STUB IFilter_GetText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


SCODE STDMETHODCALLTYPE IFilter_GetValue_Proxy( 
    IFilter __RPC_FAR * This,
    /* [out] */ PROPVARIANT __RPC_FAR *__RPC_FAR *ppPropValue);


void __RPC_STUB IFilter_GetValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


SCODE STDMETHODCALLTYPE IFilter_BindRegion_Proxy( 
    IFilter __RPC_FAR * This,
    /* [in] */ FILTERREGION origPos,
    /* [in] */ REFIID riid,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppunk);


void __RPC_STUB IFilter_BindRegion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFilter_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\float.h ===
/***
*float.h - constants for floating point values
*
*       Copyright (c) 1985-1997, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains defines for a number of implementation dependent
*       values which are commonly used by sophisticated numerical (floating
*       point) programs.
*       [ANSI]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_FLOAT
#define _INC_FLOAT

#if     !defined(_WIN32) && !defined(_MAC)
#error ERROR: Only Mac or Win32 targets supported!
#endif


#ifdef  __cplusplus
extern "C" {
#endif



/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

/* Define _CRTAPI1 (for compatibility with the NT SDK) */

#ifndef _CRTAPI1
#if	_MSC_VER >= 800 && _M_IX86 >= 300
#define _CRTAPI1 __cdecl
#else
#define _CRTAPI1
#endif
#endif

#define DBL_DIG         15                      /* # of decimal digits of precision */
#define DBL_EPSILON     2.2204460492503131e-016 /* smallest such that 1.0+DBL_EPSILON != 1.0 */
#define DBL_MANT_DIG    53                      /* # of bits in mantissa */
#define DBL_MAX         1.7976931348623158e+308 /* max value */
#define DBL_MAX_10_EXP  308                     /* max decimal exponent */
#define DBL_MAX_EXP     1024                    /* max binary exponent */
#define DBL_MIN         2.2250738585072014e-308 /* min positive value */
#define DBL_MIN_10_EXP  (-307)                  /* min decimal exponent */
#define DBL_MIN_EXP     (-1021)                 /* min binary exponent */
#define _DBL_RADIX      2                       /* exponent radix */
#define _DBL_ROUNDS     1                       /* addition rounding: near */

#define FLT_DIG         6                       /* # of decimal digits of precision */
#define FLT_EPSILON     1.192092896e-07F        /* smallest such that 1.0+FLT_EPSILON != 1.0 */
#define FLT_GUARD       0
#define FLT_MANT_DIG    24                      /* # of bits in mantissa */
#define FLT_MAX         3.402823466e+38F        /* max value */
#define FLT_MAX_10_EXP  38                      /* max decimal exponent */
#define FLT_MAX_EXP     128                     /* max binary exponent */
#define FLT_MIN         1.175494351e-38F        /* min positive value */
#define FLT_MIN_10_EXP  (-37)                   /* min decimal exponent */
#define FLT_MIN_EXP     (-125)                  /* min binary exponent */
#define FLT_NORMALIZE   0
#define FLT_RADIX       2                       /* exponent radix */
#define FLT_ROUNDS      1                       /* addition rounding: near */

#ifndef _M_M68K
#define LDBL_DIG        DBL_DIG                 /* # of decimal digits of precision */
#define LDBL_EPSILON    DBL_EPSILON             /* smallest such that 1.0+LDBL_EPSILON != 1.0 */
#define LDBL_MANT_DIG   DBL_MANT_DIG            /* # of bits in mantissa */
#define LDBL_MAX        DBL_MAX                 /* max value */
#define LDBL_MAX_10_EXP DBL_MAX_10_EXP          /* max decimal exponent */
#define LDBL_MAX_EXP    DBL_MAX_EXP             /* max binary exponent */
#define LDBL_MIN        DBL_MIN                 /* min positive value */
#define LDBL_MIN_10_EXP DBL_MIN_10_EXP          /* min decimal exponent */
#define LDBL_MIN_EXP    DBL_MIN_EXP             /* min binary exponent */
#define _LDBL_RADIX     DBL_RADIX               /* exponent radix */
#define _LDBL_ROUNDS    DBL_ROUNDS              /* addition rounding: near */
#else
#define LDBL_DIG        18                                      /* # of decimal digits of precision */
#define LDBL_EPSILON    1.08420217248550443412e-019L            /* smallest such that 1.0+LDBL_EPSILON != 1.0 */
#define LDBL_MANT_DIG   64                                      /* # of bits in mantissa */
#define LDBL_MAX        1.189731495357231765e+4932L             /* max value */
#define LDBL_MAX_10_EXP 4932                                    /* max decimal exponent */
#define LDBL_MAX_EXP    16384                                   /* max binary exponent */
#define LDBL_MIN        3.3621031431120935063e-4932L            /* min positive value */
#define LDBL_MIN_10_EXP (-4931)                                 /* min decimal exponent */
#define LDBL_MIN_EXP    (-16381)                                /* min binary exponent */
#define _LDBL_RADIX     2                                       /* exponent radix */
#define _LDBL_ROUNDS    1                                       /* addition rounding: near */
#endif

/* Function prototypes */

_CRTIMP unsigned int __cdecl _clearfp(void);
_CRTIMP unsigned int __cdecl _controlfp(unsigned int,unsigned int);
_CRTIMP unsigned int __cdecl _statusfp(void);
_CRTIMP void __cdecl _fpreset(void);

#ifndef _MAC
#define _clear87        _clearfp
#define _status87       _statusfp
#endif /* _MAC */

/*
 * Abstract User Control Word Mask and bit definitions
 */
#ifndef _MAC
#define _MCW_EM         0x0008001f              /* interrupt Exception Masks */
#else
#define _MCW_EM         0x0000001f              /* interrupt Exception Masks */
#endif
#define _EM_INEXACT     0x00000001              /*   inexact (precision) */
#define _EM_UNDERFLOW   0x00000002              /*   underflow */
#define _EM_OVERFLOW    0x00000004              /*   overflow */
#define _EM_ZERODIVIDE  0x00000008              /*   zero divide */
#define _EM_INVALID     0x00000010              /*   invalid */

#define _MCW_RC         0x00000300              /* Rounding Control */
#define _RC_NEAR        0x00000000              /*   near */
#define _RC_DOWN        0x00000100              /*   down */
#define _RC_UP          0x00000200              /*   up */
#define _RC_CHOP        0x00000300              /*   chop */

/*
 * Abstract User Status Word bit definitions
 */

#define _SW_INEXACT     0x00000001              /* inexact (precision) */
#define _SW_UNDERFLOW   0x00000002              /* underflow */
#define _SW_OVERFLOW    0x00000004              /* overflow */
#define _SW_ZERODIVIDE  0x00000008              /* zero divide */
#define _SW_INVALID     0x00000010              /* invalid */


/*
 * i386 specific definitions
 */
#define _MCW_PC         0x00030000              /* Precision Control */
#ifdef  _M_MPPC
/*
 * PowerMac specific definitions(no precision control)
 */
#define _PC_64          0x00000000              /*    64 bits */
#define _PC_53          0x00000000              /*    53 bits */
#define _PC_24          0x00000000              /*    24 bits */
#else
#define _PC_64          0x00000000              /*    64 bits */
#define _PC_53          0x00010000              /*    53 bits */
#define _PC_24          0x00020000              /*    24 bits */
#endif

#define _MCW_IC         0x00040000              /* Infinity Control */
#define _IC_AFFINE      0x00040000              /*   affine */
#define _IC_PROJECTIVE  0x00000000              /*   projective */

#define _EM_DENORMAL    0x00080000              /* denormal exception mask (_control87 only) */

#define _SW_DENORMAL    0x00080000              /* denormal status bit */


_CRTIMP unsigned int __cdecl _control87(unsigned int,unsigned int);


/*
 * RISC specific definitions
 */

#define _MCW_DN         0x03000000              /* Denormal Control */
#define _DN_SAVE        0x00000000              /*   save denormal results and operands */
#define _DN_FLUSH       0x01000000              /*   flush denormal results and operands to zero */
#define _DN_FLUSH_OPERANDS_SAVE_RESULTS 0x02000000  /*   flush operands to zero and save results */
#define _DN_SAVE_OPERANDS_FLUSH_RESULTS 0x03000000  /*   save operands and flush results to zero */


/* initial Control Word value */

#if     defined(_M_IX86)

#define _CW_DEFAULT ( _RC_NEAR + _PC_53 + _EM_INVALID + _EM_ZERODIVIDE + _EM_OVERFLOW + _EM_UNDERFLOW + _EM_INEXACT + _EM_DENORMAL)

#elif   defined(_MAC)

#define _CW_DEFAULT ( _RC_NEAR + _PC_64 + _EM_INVALID + _EM_ZERODIVIDE + _EM_OVERFLOW + _EM_UNDERFLOW + _EM_INEXACT )

#elif   defined(_M_MRX000) || defined (_M_ALPHA) || defined(_M_PPC)

#define _CW_DEFAULT ( _RC_NEAR + _DN_FLUSH + _EM_INVALID + _EM_ZERODIVIDE + _EM_OVERFLOW + _EM_UNDERFLOW + _EM_INEXACT )

#endif

/* Global variable holding floating point error code */

#if     defined(_MT) || defined(_DLL)
_CRTIMP extern int * __cdecl __fpecode(void);
#define _fpecode        (*__fpecode())
#else   /* ndef _MT && ndef _DLL */
extern int _fpecode;
#endif  /* _MT || _DLL */

/* invalid subconditions (_SW_INVALID also set) */

#define _SW_UNEMULATED          0x0040  /* unemulated instruction */
#define _SW_SQRTNEG             0x0080  /* square root of a neg number */
#define _SW_STACKOVERFLOW       0x0200  /* FP stack overflow */
#define _SW_STACKUNDERFLOW      0x0400  /* FP stack underflow */

/*  Floating point error signals and return codes */

#define _FPE_INVALID            0x81
#define _FPE_DENORMAL           0x82
#define _FPE_ZERODIVIDE         0x83
#define _FPE_OVERFLOW           0x84
#define _FPE_UNDERFLOW          0x85
#define _FPE_INEXACT            0x86

#define _FPE_UNEMULATED         0x87
#define _FPE_SQRTNEG            0x88
#define _FPE_STACKOVERFLOW      0x8a
#define _FPE_STACKUNDERFLOW     0x8b

#define _FPE_EXPLICITGEN        0x8c    /* raise( SIGFPE ); */


/* IEEE recommended functions */

_CRTIMP double __cdecl _copysign (double, double);
_CRTIMP double __cdecl _chgsign (double);
_CRTIMP double __cdecl _scalb(double, long);
_CRTIMP double __cdecl _logb(double);
_CRTIMP double __cdecl _nextafter(double, double);
_CRTIMP int    __cdecl _finite(double);
_CRTIMP int    __cdecl _isnan(double);
_CRTIMP int    __cdecl _fpclass(double);

#define _FPCLASS_SNAN   0x0001  /* signaling NaN */
#define _FPCLASS_QNAN   0x0002  /* quiet NaN */
#define _FPCLASS_NINF   0x0004  /* negative infinity */
#define _FPCLASS_NN     0x0008  /* negative normal */
#define _FPCLASS_ND     0x0010  /* negative denormal */
#define _FPCLASS_NZ     0x0020  /* -0 */
#define _FPCLASS_PZ     0x0040  /* +0 */
#define _FPCLASS_PD     0x0080  /* positive denormal */
#define _FPCLASS_PN     0x0100  /* positive normal */
#define _FPCLASS_PINF   0x0200  /* positive infinity */


#if     !__STDC__

/* Non-ANSI names for compatibility */

#ifndef _MAC
#define clear87         _clear87
#define status87        _status87
#define control87       _control87
#endif /* _MAC */

_CRTIMP void __cdecl fpreset(void);

#define DBL_RADIX               _DBL_RADIX
#define DBL_ROUNDS              _DBL_ROUNDS

#define LDBL_RADIX              _LDBL_RADIX
#define LDBL_ROUNDS             _LDBL_ROUNDS

#define MCW_EM                  _MCW_EM
#define EM_INVALID              _EM_INVALID
#define EM_DENORMAL             _EM_DENORMAL
#define EM_ZERODIVIDE           _EM_ZERODIVIDE
#define EM_OVERFLOW             _EM_OVERFLOW
#define EM_UNDERFLOW            _EM_UNDERFLOW
#define EM_INEXACT              _EM_INEXACT

#define MCW_IC                  _MCW_IC
#define IC_AFFINE               _IC_AFFINE
#define IC_PROJECTIVE           _IC_PROJECTIVE

#define MCW_RC                  _MCW_RC
#define RC_CHOP                 _RC_CHOP
#define RC_UP                   _RC_UP
#define RC_DOWN                 _RC_DOWN
#define RC_NEAR                 _RC_NEAR

#define MCW_PC                  _MCW_PC
#define PC_24                   _PC_24
#define PC_53                   _PC_53
#define PC_64                   _PC_64

#define CW_DEFAULT              _CW_DEFAULT

#define SW_INVALID              _SW_INVALID
#define SW_DENORMAL             _SW_DENORMAL
#define SW_ZERODIVIDE           _SW_ZERODIVIDE
#define SW_OVERFLOW             _SW_OVERFLOW
#define SW_UNDERFLOW            _SW_UNDERFLOW
#define SW_INEXACT              _SW_INEXACT

#define SW_UNEMULATED           _SW_UNEMULATED
#define SW_SQRTNEG              _SW_SQRTNEG
#define SW_STACKOVERFLOW        _SW_STACKOVERFLOW
#define SW_STACKUNDERFLOW       _SW_STACKUNDERFLOW

#define FPE_INVALID             _FPE_INVALID
#define FPE_DENORMAL            _FPE_DENORMAL
#define FPE_ZERODIVIDE          _FPE_ZERODIVIDE
#define FPE_OVERFLOW            _FPE_OVERFLOW
#define FPE_UNDERFLOW           _FPE_UNDERFLOW
#define FPE_INEXACT             _FPE_INEXACT

#define FPE_UNEMULATED          _FPE_UNEMULATED
#define FPE_SQRTNEG             _FPE_SQRTNEG
#define FPE_STACKOVERFLOW       _FPE_STACKOVERFLOW
#define FPE_STACKUNDERFLOW      _FPE_STACKUNDERFLOW

#define FPE_EXPLICITGEN         _FPE_EXPLICITGEN

#endif  /* __STDC__ */

#ifdef  __cplusplus
}
#endif

#endif  /* _INC_FLOAT */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\g711uids.h ===
/*--------------------------------------------------------------

 INTEL Corporation Proprietary Information  

 This listing is supplied under the terms of a license agreement  
 with INTEL Corporation and may not be copied nor disclosed 
 except in accordance with the terms of that agreement.

 Copyright (c) 1996 Intel Corporation.
 All rights reserved.

--------------------------------------------------------------

G711uids.h

The guids used by G711.

NOTE: GUIDs for basic companding like G711 should probably be 
standardized by MS not me.

--------------------------------------------------------------*/

// G711 Codec Filter Object
// {AF7D8180-A8F9-11cf-9A46-00AA00B7DAD1}
DEFINE_GUID(CLSID_G711Codec, 
0xaf7d8180, 0xa8f9, 0x11cf, 0x9a, 0x46, 0x0, 0xaa, 0x0, 0xb7, 0xda, 0xd1);

// G711 Codec Filter Property Page Object
// {480D5CA0-F032-11cf-A7D3-00A0C9056683}
DEFINE_GUID(CLSID_G711CodecPropertyPage, 
0x480D5CA0, 0xF032, 0x11cf, 0xA7, 0xD3, 0x0, 0xA0, 0xC9, 0x05, 0x66, 0x83);

// {827FA280-CDFC-11cf-9A9D-00AA00B7DAD1}
DEFINE_GUID(MEDIASUBTYPE_MULAWAudio, 
0x827fa280, 0xcdfc, 0x11cf, 0x9a, 0x9d, 0x0, 0xaa, 0x0, 0xb7, 0xda, 0xd1);

// {9E17EE50-CDFC-11cf-9A9D-00AA00B7DAD1}
DEFINE_GUID(MEDIASUBTYPE_ALAWAudio, 
0x9e17ee50, 0xcdfc, 0x11cf, 0x9a, 0x9d, 0x0, 0xaa, 0x0, 0xb7, 0xda, 0xd1);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\FrQuery.h ===
//***************************************************************************
//
//  Copyright (c) 1997-1999 Microsoft Corporation
//
//  FRQuery.h
//
//  Purpose: query support classes
//
//***************************************************************************

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _FRAMEWORK_QUERY_H_
#define _FRAMEWORK_QUERY_H_
#include <stdio.h>
#include <sql_1.h>
#include <comdef.h>
#include <vector>

class POLARITY CFrameworkQuery
{
public:
    CFrameworkQuery();
    ~CFrameworkQuery();

    // Finds out if a particular field was requested by the query in either
    // the Select statement, or the Where statement.  Only meaningful if we
    // are in ExecQueryAsync and the query has been sucessfully parsed.
    bool IsPropertyRequired(LPCWSTR propName);

    // Gets the class name from the query.  Only meaningful if we are
    // in ExecQueryAsync and the query has been sucessfully parsed.  It
    // is the responsibility of the caller to SysFreeString the returned
    // string.
    BSTR GetQueryClassName(void) { return SysAllocString(m_bstrtClassName); }

    // Given a property name, it will return all the values
    // that the query requests in a CHStringArray.
    // Select * from win32_directory where drive = "C:" GetValuesForProp(L"Drive") -> C:
    // Where Drive = "C:" or Drive = "D:" GetValuesForProp(L"Drive") -> C:, D:
    // Where Path = "\DOS" GetValuesForProp(L"Drive") -> (empty)
    // Where Drive <> "C:" GetValuesForProp(L"Drive") -> (empty)
    // Where Drive = "C:" or (Drive = "D:" and Mounted = true) GetValuesForProp(L"Drive") -> C:, D:
    HRESULT GetValuesForProp(LPCWSTR wszPropName, CHStringArray& achNames);

    // Here's an overloaded version in case client wants to pass in a vector of _bstr_t's
    HRESULT GetValuesForProp(LPCWSTR wszPropName, std::vector<_bstr_t>& vectorNames);

    // Returns a list of all the properties specified in the Select clause, plus.
    // all the the properties from the Where clauses.  If the returned array is empty, all
    // properties are required.
    void GetRequiredProperties(CHStringArray &saProperties);

    // Boolean indicating if all properties are being requested.
    bool AllPropertiesAreRequired(void) { return (m_csaPropertiesRequired.GetSize() == 0); }

    // Boolean indicating if only the key properties are required.
    bool KeysOnly(void) { return m_bKeysOnly; }

    // Accessor function to retrieve wql query
    const CHString &GetQuery() ;

    // Moves the values into the member variables.  Should never be called by users.
    HRESULT Init(
        
        const BSTR bstrQueryFormat, 
        const BSTR bstrQuery, 
        long lFlags,
        CHString &sNamespace
    );

    // Moves the values into the member variables.  Should never be called by users.
    HRESULT Init(

        ParsedObjectPath *pParsedObjectPath, 
        IWbemContext *pCtx, 
        LPCWSTR lpwszClassName,
        CHString &sNamespace
    );

    // Initializes the KeysOnly data member.  Should never be called by users.
    void Init2(IWbemClassObject *IClass);


protected:

    /*****************************************************************************/
    /* The rest of these data members and functions are intended for Microsoft   */
    /* internal use only. Use by third parties is unsupported and unrecommended. */
    /*****************************************************************************/

    SQL_LEVEL_1_RPN_EXPRESSION *m_pLevel1RPNExpression;
    CHStringArray m_csaPropertiesRequired;
    enum QueryTypes{eUnknown, eWQLCommand, eContextObject} m_QueryType;

    DWORD IsInList(const CHStringArray &csaArray, LPCWSTR pwszValue);

    BOOL IsReference(LPCWSTR lpwszPropertyName);
    const CHString &GetNamespace();

private:

    CHString m_sNamespace;
    long m_lFlags;
    IWbemClassObject *m_IClass;
    CHString m_sQueryFormat;

    void Reset(void);
    bool m_bKeysOnly;
    bool m_AddKeys;
    CHString m_sQuery;
    bstr_t m_bstrtClassName;

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\ftsiface.h ===
// FTSIFACE.h -- DLL interface for FTSrch.dll
// Copyright (c) 1996-1999 Microsoft Corporation

#ifndef __FTSIFACE_H__
#define __FTSIFACE_H__

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */



typedef HANDLE HINDEX;
typedef HANDLE HSEARCHER;
typedef HANDLE HCOMPRESSOR;
typedef HANDLE HHILITER;
typedef INT    ERRORCODE;
typedef struct { int base; int limit; } HILITE;

#define NO_TITLE              UINT(-1)  // ERRORCODE values
#define NOT_INDEXER           UINT(-2)
#define NOT_SEARCHER          UINT(-3)
#define NOT_COMPRESSOR        UINT(-4)
#define CANNOT_SAVE           UINT(-5)
#define OUT_OF_MEMORY         UINT(-6)
#define CANNOT_OPEN           UINT(-7)
#define CANNOT_LOAD           UINT(-8)
#define INVALID_INDEX         UINT(-9)
#define ALREADY_WEIGHED       UINT(-10)
#define NO_TEXT_SCANNED       UINT(-11)
#define ALIGNMENT_ERROR       UINT(-12)
#define INVALID_PHRASE_TABLE  UINT(-13)
#define INVALID_LCID          UINT(-14)
#define NO_INDICES_LOADED     UINT(-15)
#define INDEX_LOADED_ALREADY  UINT(-16)
#define GROUP_LOADED_ALREADY  UINT(-17)
#define DIALOG_ALREADY_ACTIVE UINT(-18)
#define EMPTY_PHRASE_TABLE    UINT(-19)
#define OUT_OF_DISK           UINT(-20)
#define DISK_READ_ERROR       UINT(-21)
#define DISK_WRITE_ERROR      UINT(-22)
#define SEARCH_ABORTED        UINT(-23)
#define UNKNOWN_EXCEPTION     UINT(-24)
#define SYSTEM_ERROR          UINT(-25)
#define NOT_HILITER			  UINT(-26)
#define INVALID_CHARSET       UINT(-27)
#define INVALID_SOURCE_NAME   UINT(-28)
#define INVALID_TIMESTAMP     UINT(-29)

#define ERR_NO_DISK_SPACE        0xE0000001  // Values reported by GetLastError
#define ERR_DISK_CREATE_ERROR    0xE0000002  //   when an explicit error result
#define ERR_DISK_OPEN_ERROR      0xE0000003  //   isn't available.
#define ERR_DISK_READ_ERROR      0xE0000004
#define ERR_DISK_WRITE_ERROR     0xE0000005
#define ERR_SYSTEM_ERROR         0xE0000006
#define ERR_ABORT_SEARCH         0xE0000007
#define ERR_INVALID_TIMESTAMP    0xE0000008
#define ERR_INVALID_SOURCE_NAME  0xE0000009
#define ERR_FILE_MAP_FAILED      0xE000000A
#define ERR_INVALID_FILE_TYPE    0xE000000B
#define ERR_DAMAGED_FILE         0xE000000C
#define ERR_FUTURE_VERSION       0xE000000D

// -------------- Index Construction Interface ---------------------------

#define TOPIC_SEARCH    0x00000001   // Options for NewIndex
#define PHRASE_SEARCH   0x00000002
#define PHRASE_FEEDBACK 0x00000004
#define VECTOR_SEARCH   0x00000008
#define WINHELP_INDEX   0x00000010
#define USE_VA_ADDR     0x00000020
#define USE_QWORD_JUMP  0x00000040

#define USE_DEFAULT     UINT(-1) // Surrogate for default charset or default lcid

HINDEX APIENTRY NewIndex(const PBYTE pbSourceName,
              UINT uiTime1, UINT uiTime2,
              UINT iCharsetDefault, UINT lcidDefault, UINT fdwOptions
             );

ERRORCODE APIENTRY ScanTopicTitle(HINDEX hinx, PBYTE pbTitle, UINT cbTitle,
                         UINT iTopic, HANDLE hTopic, UINT iCharset, UINT lcid
                        );
ERRORCODE APIENTRY ScanTopicText (HINDEX hinx, PBYTE pbText, UINT cbText, UINT iCharset, UINT lcid);
ERRORCODE APIENTRY SaveIndex     (HINDEX hinx, PSZ pszFileName);
ERRORCODE APIENTRY DeleteIndex   (HINDEX hinx);

typedef void  (__stdcall *ANIMATOR)(void);

ERRORCODE APIENTRY RegisterAnimator(ANIMATOR pAnimator, HWND hwndAnimator);

// ----------------- Querying the Validity of an Index File --------------

BOOL      APIENTRY IsValidIndex(PSZ pszFileName, UINT dwOptions);

void      APIENTRY SetDirectoryLocator(HWND hwndLocator);

// ----------------- Searcher Interface ----------------------------------

HSEARCHER APIENTRY NewSearcher();

INT       APIENTRY OpenIndex(HSEARCHER hsrch, PSZ pszIndexFileName,        // returns iIndex for index file
                               PBYTE pbSourceName, PUINT pcbSourceNameLimit, // or      -ErrorCode
                               PUINT pTime1, PUINT pTime2
                              );

ERRORCODE APIENTRY DiscardIndex  (HSEARCHER hsrch, INT iIndex);
ERRORCODE APIENTRY QueryOptions  (HSEARCHER hsrch, INT iIndex, PUINT pfdwOptions);
ERRORCODE APIENTRY SaveGroup     (HSEARCHER hsrch, PSZ pszFileName);
ERRORCODE APIENTRY LoadGroup     (HSEARCHER hsrch, PSZ pszFileName);
HWND      APIENTRY OpenDialog    (HSEARCHER hsrch, HWND hwndParent);
ERRORCODE APIENTRY DeleteSearcher(HSEARCHER hsrch);

// Messages for talking to WinHelp

#define MSG_FTS_JUMP_HASH	(WM_USER + 32)  // wParam = index, lParam = HashValue
#define MSG_FTS_JUMP_VA 	(WM_USER + 33)  // wParam = index, lParam = VirtualAddress
#define MSG_FTS_GET_TITLE	(WM_USER + 34)	// wParam = index, lParam = &pszTitle
#define MSG_FTS_JUMP_QWORD  (WM_USER + 35)  // wParam = index, lParam = address of QWordAddress structure
#define MSG_REINDEX_REQUEST (WM_USER + 36)  // wParam = unused,lParam = unused
#define MSG_FTS_WHERE_IS_IT (WM_USER + 37)	// wParam = fStartEnumeration, lParam = &pszFile
#define MSG_GET_DEFFONT 	(WM_USER + 45)	// return default font handle

typedef struct _QWordAddress
        {
            UINT   iSerial;
            HANDLE hTopic;

        } QWordAddress, *PQWordAddress;

// ------------------- Phrase Compression Interface ----------------------

HCOMPRESSOR APIENTRY NewCompressor(UINT iCharsetDefault);

ERRORCODE   APIENTRY ScanText(HCOMPRESSOR hcmp, PBYTE pbText, UINT cbText, UINT iCharset);

ERRORCODE   APIENTRY GetPhraseTable(HCOMPRESSOR hcmp, PUINT pcPhrases, PBYTE *ppbImages, PUINT pcbImages,
                           PBYTE *ppacbImageCompressed, PUINT pcbCompressed
                          );

ERRORCODE   APIENTRY SetPhraseTable(HCOMPRESSOR hcmp, PBYTE pbImages, UINT cbImages,
                           PBYTE pacbImageCompressed, UINT cbCompressed
                          );

INT APIENTRY CompressText  (HCOMPRESSOR hcmp, PBYTE pbText,       UINT cbText,       PBYTE *ppbCompressed, UINT iCharset);
INT APIENTRY DecompressText(HCOMPRESSOR hcmp, PBYTE pbCompressed, UINT cbCompressed, PBYTE  pbText                      );

ERRORCODE   APIENTRY DeleteCompressor(HCOMPRESSOR hcmp);

//----------------------- Hiliting Interface ------------------------------

HHILITER APIENTRY NewHiliter(HSEARCHER hSearch);
ERRORCODE APIENTRY DeleteHiliter(HHILITER hhil);
ERRORCODE APIENTRY ScanDisplayText(HHILITER hhil, PBYTE pbText, int cbText,
                                   UINT iCharset, LCID lcid);

ERRORCODE APIENTRY ClearDisplayText(HHILITER hhil);
int APIENTRY CountHilites(HHILITER hhil, int base, int limit);
int APIENTRY QueryHilites(HHILITER hhil, int base, int limit,
                          int cHilites, HILITE* paHilites);

#ifdef __cplusplus
}
#endif /* __cplusplus */



#endif // __FTSIFACE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\filterr.h ===
#ifndef _FILTERR_H_
#define _FILTERR_H_
#ifndef FACILITY_WINDOWS
//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//
#define FACILITY_WINDOWS                 0x8
#define FACILITY_ITF                     0x4


//
// Define the severity codes
//
#define STATUS_SEVERITY_SUCCESS          0x0
#define STATUS_SEVERITY_COFAIL           0x3
#define STATUS_SEVERITY_COERROR          0x2


//
// MessageId: NOT_AN_ERROR
//
// MessageText:
//
//  NOTE:  This dummy error message is necessary to force MC to output
//         the above defines inside the FACILITY_WINDOWS guard instead
//         of leaving it empty.
//
#define NOT_AN_ERROR                     ((HRESULT)0x00080000L)

#endif // FACILITY_WINDOWS
//
// Codes 0x1700-0x172F are reserved for FILTER
//
//
// MessageId: FILTER_E_END_OF_CHUNKS
//
// MessageText:
//
//  No more chunks of text available in object.
//
#define FILTER_E_END_OF_CHUNKS           ((HRESULT)0x80041700L)

//
// MessageId: FILTER_E_NO_MORE_TEXT
//
// MessageText:
//
//  No more text available in chunk.
//
#define FILTER_E_NO_MORE_TEXT            ((HRESULT)0x80041701L)

//
// MessageId: FILTER_E_NO_MORE_VALUES
//
// MessageText:
//
//  No more property values available in chunk.
//
#define FILTER_E_NO_MORE_VALUES          ((HRESULT)0x80041702L)

//
// MessageId: FILTER_E_ACCESS
//
// MessageText:
//
//  Unable to access object.
//
#define FILTER_E_ACCESS                  ((HRESULT)0x80041703L)

//
// MessageId: FILTER_W_MONIKER_CLIPPED
//
// MessageText:
//
//  Moniker doesn't cover entire region.
//
#define FILTER_W_MONIKER_CLIPPED         ((HRESULT)0x00041704L)

//
// MessageId: FILTER_E_NO_TEXT
//
// MessageText:
//
//  No text in current chunk.
//
#define FILTER_E_NO_TEXT                 ((HRESULT)0x80041705L)

//
// MessageId: FILTER_E_NO_VALUES
//
// MessageText:
//
//  No values in current chunk.
//
#define FILTER_E_NO_VALUES               ((HRESULT)0x80041706L)

//
// MessageId: FILTER_E_EMBEDDING_UNAVAILABLE
//
// MessageText:
//
//  Unable to bind IFilter for embedded object.
//
#define FILTER_E_EMBEDDING_UNAVAILABLE   ((HRESULT)0x80041707L)

//
// MessageId: FILTER_E_LINK_UNAVAILABLE
//
// MessageText:
//
//  Unable to bind IFilter for linked object.
//
#define FILTER_E_LINK_UNAVAILABLE        ((HRESULT)0x80041708L)

//
// MessageId: FILTER_S_LAST_TEXT
//
// MessageText:
//
//  This is the last text in the current chunk.
//
#define FILTER_S_LAST_TEXT               ((HRESULT)0x00041709L)

//
// MessageId: FILTER_S_LAST_VALUES
//
// MessageText:
//
//  This is the last value in the current chunk.
//
#define FILTER_S_LAST_VALUES             ((HRESULT)0x0004170AL)

//
// MessageId: FILTER_E_PASSWORD
//
// MessageText:
//
//  File was not filtered due to password protection.
//
#define FILTER_E_PASSWORD                ((HRESULT)0x8004170BL)

//
// MessageId: FILTER_E_UNKNOWNFORMAT
//
// MessageText:
//
//  The document format is not recognized by the flter.
//
#define FILTER_E_UNKNOWNFORMAT           ((HRESULT)0x8004170CL)

#endif // _FILTERR_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\fstream.h ===
/***
*fstream.h - definitions/declarations for filebuf and fstream classes
*
*       Copyright (c) 1991-1997, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       This file defines the classes, values, macros, and functions
*       used by the filebuf and fstream classes.
*       [AT&T C++]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifdef  __cplusplus

#ifndef _INC_FSTREAM
#define _INC_FSTREAM

#if     !defined(_WIN32) && !defined(_MAC)
#error ERROR: Only Mac or Win32 targets supported!
#endif


#ifdef  _MSC_VER
// Currently, all MS C compilers for Win32 platforms default to 8 byte
// alignment.
#pragma pack(push,8)

#include <useoldio.h>

#endif  // _MSC_VER

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


#include <iostream.h>

#ifdef  _MSC_VER
// C4514: "unreferenced inline function has been removed"
#pragma warning(disable:4514) // disable C4514 warning
// #pragma warning(default:4514)        // use this to reenable, if desired
#endif  // _MSC_VER

typedef int filedesc;

class _CRTIMP filebuf : public streambuf {
public:
static  const int       openprot;       // default share/prot mode for open

// optional share values for 3rd argument (prot) of open or constructor
static  const int       sh_none;        // exclusive mode no sharing
static  const int       sh_read;        // allow read sharing
static  const int       sh_write;       // allow write sharing
// use (sh_read | sh_write) to allow both read and write sharing

// options for setmode member function
static  const int       binary;
static  const int       text;

                        filebuf();
                        filebuf(filedesc);
                        filebuf(filedesc, char *, int);
                        ~filebuf();

        filebuf*        attach(filedesc);
        filedesc        fd() const { return (x_fd==-1) ? EOF : x_fd; }
        int             is_open() const { return (x_fd!=-1); }
        filebuf*        open(const char *, int, int = filebuf::openprot);
        filebuf*        close();
        int             setmode(int = filebuf::text);

virtual int             overflow(int=EOF);
virtual int             underflow();

virtual streambuf*      setbuf(char *, int);
virtual streampos       seekoff(streamoff, ios::seek_dir, int);
// virtual      streampos       seekpos(streampos, int);
virtual int             sync();

private:
        filedesc        x_fd;
        int             x_fOpened;
};

class _CRTIMP ifstream : public istream {
public:
        ifstream();
        ifstream(const char *, int =ios::in, int = filebuf::openprot);
        ifstream(filedesc);
        ifstream(filedesc, char *, int);
        ~ifstream();

        streambuf * setbuf(char *, int);
        filebuf* rdbuf() const { return (filebuf*) ios::rdbuf(); }

        void attach(filedesc);
        filedesc fd() const { return rdbuf()->fd(); }

        int is_open() const { return rdbuf()->is_open(); }
        void open(const char *, int =ios::in, int = filebuf::openprot);
        void close();
        int setmode(int mode = filebuf::text) { return rdbuf()->setmode(mode); }
};

class _CRTIMP ofstream : public ostream {
public:
        ofstream();
        ofstream(const char *, int =ios::out, int = filebuf::openprot);
        ofstream(filedesc);
        ofstream(filedesc, char *, int);
        ~ofstream();

        streambuf * setbuf(char *, int);
        filebuf* rdbuf() const { return (filebuf*) ios::rdbuf(); }

        void attach(filedesc);
        filedesc fd() const { return rdbuf()->fd(); }

        int is_open() const { return rdbuf()->is_open(); }
        void open(const char *, int =ios::out, int = filebuf::openprot);
        void close();
        int setmode(int mode = filebuf::text) { return rdbuf()->setmode(mode); }
};
        
class _CRTIMP fstream : public iostream {
public:
        fstream();
        fstream(const char *, int, int = filebuf::openprot);
        fstream(filedesc);
        fstream(filedesc, char *, int);
        ~fstream();

        streambuf * setbuf(char *, int);
        filebuf* rdbuf() const { return (filebuf*) ostream::rdbuf(); }

        void attach(filedesc);
        filedesc fd() const { return rdbuf()->fd(); }

        int is_open() const { return rdbuf()->is_open(); }
        void open(const char *, int, int = filebuf::openprot);
        void close();
        int setmode(int mode = filebuf::text) { return rdbuf()->setmode(mode); }
};
        
// manipulators to dynamically change file access mode (filebufs only)
inline  ios& binary(ios& _fstrm) \
   { ((filebuf*)_fstrm.rdbuf())->setmode(filebuf::binary); return _fstrm; }
inline  ios& text(ios& _fstrm) \
   { ((filebuf*)_fstrm.rdbuf())->setmode(filebuf::text); return _fstrm; }

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  // _MSC_VER

#endif  // _INC_FSTREAM

#endif  /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\FwCommon.h ===
//***************************************************************************
//
//  Copyright (c) 1996-1999 Microsoft Corporation
//
//  FWcommon.h
//
//  Purpose: Definition of EventProvider class
//
//***************************************************************************

#if _MSC_VER > 1000
#pragma once
#endif

// ALWAYS INCLUDE THIS FILE FIRST!

#ifndef _FW_COMMON_H_
#define _FW_COMMON_H_

// move warnings to level four
#pragma warning(4 : 4275 4800 4786 4251)
//	C4275: non DLL-interface classkey 'identifier' used as base for DLL-interface classkey 'identifier'
//	C4800: forcing bool variable to one or zero, possible performance loss
//	C4786: 'identifier' : identifier was truncated to 'number' characters in the debug information
//	C4251: 'identifier' : class 'type' needs to have dll-interface to export class 'type2'


#include "windows.h"

// This function gets macro'ed to GetObjectW and GetObjectA based on the
// contents of UNICODE.  However, we USE a function called GetObject.  For
// single binary support, we can't have this being macro'ed.  If the actual
// win32 api GetObject is needed, call the GetObjectW or GetObjectA directly.
#undef GetObject
#include <wbemidl.h>
#include <wmiutils.h>

// If USE_POLARITY not defined, some Framedyn.dll symbols may not resolve correctly
// It's a declspec(dllimport/dllexport) issue.
#ifndef USE_POLARITY

// For most users, this is the correct setting for POLARITY.
#define USE_POLARITY

#endif

// Required since TCHAR.H defines _ttoi64 -> atoi64, which requires oldnames.lib, which
// we don't use.
#define atoi64 _atoi64

#include <Polarity.h>

#undef _CRTIMP
#define _CRTIMP POLARITY
#include <yvals.h>
#undef _CRTIMP

#include <stllock.h>
extern POLARITY CCritSec g_cs;

#include "utillib.h"
#include "ThrdBase.h"
#include "RefPtrCo.h"
#include "MethodCo.h"
#include "FRQuery.h"
#include "wbemglue.h"
#include "instance.h"

class CFramework_Exception
{
private:

	CHString m_sErrorText;
    HRESULT m_hr;

public:

	CFramework_Exception ( LPCWSTR lpwszErrorText, HRESULT hr) : m_hr ( hr ) , m_sErrorText ( lpwszErrorText) {}
	CFramework_Exception ( LPCWSTR lpwszErrorText) : m_hr ( WBEM_S_NO_ERROR ) , m_sErrorText ( lpwszErrorText) {}
	~CFramework_Exception () {}

	HRESULT GetHRESULT() { return m_hr ; }
	CHString &GetErrorText() { return m_sErrorText; }
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\fvec.h ===
/**
*** Copyright (C) 1985-1999 Intel Corporation.  All rights reserved.
***
*** The information and source code contained herein is the exclusive
*** property of Intel Corporation and may not be disclosed, examined
*** or reproduced in whole or in part without explicit written authorization
*** from the company.
***
*** @(#)fvec.h	1.8 05/28/99 08:26:31
**/

/*
 *  Definition of a C++ class interface to Streaming SIMD Extension intrinsics.
 *
 *  
 *	File name : fvec.h  Fvec class definitions 
 *	
 *	Concept: A C++ abstraction of Streaming SIMD Extensions designed to improve
 *
 *  programmer productivity.  Speed and accuracy are sacrificed for utility. 
 *	
 *	Facilitates an easy transition to compiler intrinsics
 *	
 *	or assembly language. 
 *
 *	F32vec4:	4 packed single precision 
 *				32-bit floating point numbers 
*/

#ifndef FVEC_H_INCLUDED
#define FVEC_H_INCLUDED

#if !defined __cplusplus
	#error ERROR: This file is only supported in C++ compilations!
#endif /* !__cplusplus */

#include <xmmintrin.h> /* Streaming SIMD Extensions Intrinsics include file */
#include <assert.h>
#include <iostream.h>
#include <ivec.h>

#pragma pack(push,16) /* Must ensure class & union 16-B aligned */

/* If using MSVC5.0, explicit keyword should be used */
#if (_MSC_VER >= 1100)
        #define EXPLICIT explicit
#else
   #if (__ICL)
        #define EXPLICIT __explicit /* If MSVC4.x & ICL, use __explicit */
   #else
        #define EXPLICIT /* nothing */
        #pragma message( "explicit keyword not recognized") 
   #endif
#endif

class F32vec4
{
protected:
   	 __m128 vec;
public:
	
	/* Constructors: __m128, 4 floats, 1 float */
	F32vec4() {}
	
	/* initialize 4 SP FP with __m128 data type */	
	F32vec4(__m128 m)					{ vec = m;}

	/* initialize 4 SP FPs with 4 floats */	
	F32vec4(float f3, float f2, float f1, float f0)		{ vec= _mm_set_ps(f3,f2,f1,f0); }

	/* Explicitly initialize each of 4 SP FPs with same float */	
	EXPLICIT F32vec4(float f)	{ vec = _mm_set_ps1(f); }	

	/* Explicitly initialize each of 4 SP FPs with same double */	
	EXPLICIT F32vec4(double d)	{ vec = _mm_set_ps1((float) d); }	

	/* Assignment operations */

	F32vec4& operator =(float f) { vec = _mm_set_ps1(f); return *this; }

	F32vec4& operator =(double d) { vec = _mm_set_ps1((float) d); return *this; }

	/* Conversion functions */
	operator  __m128() const	{ return vec; }		/* Convert to __m128 */

 	/* Logical Operators */
	friend F32vec4 operator &(const F32vec4 &a, const F32vec4 &b) { return _mm_and_ps(a,b); }
	friend F32vec4 operator |(const F32vec4 &a, const F32vec4 &b) { return _mm_or_ps(a,b); }
	friend F32vec4 operator ^(const F32vec4 &a, const F32vec4 &b) { return _mm_xor_ps(a,b); }

	/* Arithmetic Operators */
	friend F32vec4 operator +(const F32vec4 &a, const F32vec4 &b) { return _mm_add_ps(a,b); }
	friend F32vec4 operator -(const F32vec4 &a, const F32vec4 &b) { return _mm_sub_ps(a,b); } 
	friend F32vec4 operator *(const F32vec4 &a, const F32vec4 &b) { return _mm_mul_ps(a,b); } 
	friend F32vec4 operator /(const F32vec4 &a, const F32vec4 &b) { return _mm_div_ps(a,b); }

	F32vec4& operator =(const F32vec4 &a) { vec = a.vec; return *this; }
	F32vec4& operator =(const __m128 &avec) { vec = avec; return *this; }
	F32vec4& operator +=(F32vec4 &a) { return *this = _mm_add_ps(vec,a); }
	F32vec4& operator -=(F32vec4 &a) { return *this = _mm_sub_ps(vec,a); }   
	F32vec4& operator *=(F32vec4 &a) { return *this = _mm_mul_ps(vec,a); } 
	F32vec4& operator /=(F32vec4 &a) { return *this = _mm_div_ps(vec,a); }
	F32vec4& operator &=(F32vec4 &a) { return *this = _mm_and_ps(vec,a); }
	F32vec4& operator |=(F32vec4 &a) { return *this = _mm_or_ps(vec,a); }
	F32vec4& operator ^=(F32vec4 &a) { return *this = _mm_xor_ps(vec,a); }

	/* Horizontal Add */
	friend float add_horizontal(F32vec4 &a) 
	{ 
		F32vec4 ftemp = _mm_add_ss(a,_mm_add_ss(_mm_shuffle_ps(a, a, 1),_mm_add_ss(_mm_shuffle_ps(a, a, 2),_mm_shuffle_ps(a, a, 3))));
		return ftemp[0];
	}
	
	/* Square Root */
	friend F32vec4 sqrt(const F32vec4 &a)		{ return _mm_sqrt_ps(a); }	 
	/* Reciprocal */
	friend F32vec4 rcp(const F32vec4 &a)		{ return _mm_rcp_ps(a); }	 
	/* Reciprocal Square Root */
	friend F32vec4 rsqrt(const F32vec4 &a)		{ return _mm_rsqrt_ps(a); }	 

	/* NewtonRaphson Reciprocal 
	   [2 * rcpps(x) - (x * rcpps(x) * rcpps(x))] */
	friend F32vec4 rcp_nr(const F32vec4 &a)
	{
		F32vec4 Ra0 = _mm_rcp_ps(a);
		return _mm_sub_ps(_mm_add_ps(Ra0, Ra0), _mm_mul_ps(_mm_mul_ps(Ra0, a), Ra0));
	}

	/*	NewtonRaphson Reciprocal Square Root 
	  	0.5 * rsqrtps * (3 - x * rsqrtps(x) * rsqrtps(x)) */		
	friend F32vec4 rsqrt_nr(const F32vec4 &a)
	{
		static const F32vec4 fvecf0pt5(0.5f);
		static const F32vec4 fvecf3pt0(3.0f);
		F32vec4 Ra0 = _mm_rsqrt_ps(a);
		return (fvecf0pt5 * Ra0) * (fvecf3pt0 - (a * Ra0) * Ra0);
	
	}

	/* Compares: Mask is returned  */
	/* Macros expand to all compare intrinsics.  Example: 
	friend F32vec4 cmpeq(const F32vec4 &a, const F32vec4 &b) 
	{ return _mm_cmpeq_ps(a,b);} */
	#define Fvec32s4_COMP(op) \
	friend F32vec4 cmp##op (const F32vec4 &a, const F32vec4 &b) { return _mm_cmp##op##_ps(a,b); }
		Fvec32s4_COMP(eq)					// expanded to cmpeq(a,b)
		Fvec32s4_COMP(lt)					// expanded to cmplt(a,b)
		Fvec32s4_COMP(le)					// expanded to cmple(a,b)	
		Fvec32s4_COMP(gt)					// expanded to cmpgt(a,b)
		Fvec32s4_COMP(ge)					// expanded to cmpge(a,b)
		Fvec32s4_COMP(neq)					// expanded to cmpneq(a,b)
		Fvec32s4_COMP(nlt)					// expanded to cmpnlt(a,b)
		Fvec32s4_COMP(nle)					// expanded to cmpnle(a,b)
		Fvec32s4_COMP(ngt)					// expanded to cmpngt(a,b)
		Fvec32s4_COMP(nge)					// expanded to cmpnge(a,b)
	#undef Fvec32s4_COMP

	/* Min and Max */
	friend F32vec4 simd_min(const F32vec4 &a, const F32vec4 &b) { return _mm_min_ps(a,b); }
	friend F32vec4 simd_max(const F32vec4 &a, const F32vec4 &b) { return _mm_max_ps(a,b); }

	/* Debug Features */
	/* Output */
	friend ostream & operator<<(ostream & os, const F32vec4 &a)	
	{
	/* To use: cout << "Elements of F32vec4 fvec are: " << fvec; */ 
	  float *fp = (float*)&a;
	  	os << "[3]:" << *(fp+3) 
			<< " [2]:" << *(fp+2) 
			<< " [1]:" << *(fp+1) 
			<< " [0]:" << *fp;
		return os;
	}
	/* Element Access Only, no modifications to elements*/
	const float& operator[](int i) const				
	{
		/* Assert enabled only during debug /DDEBUG */
		assert((0 <= i) && (i <= 3));			/* User should only access elements 0-3 */
		float *fp = (float*)&vec;
		return *(fp+i);
	}
	/* Element Access and Modification*/
	float& operator[](int i)				
	{
		/* Assert enabled only during debug /DDEBUG */
		assert((0 <= i) && (i <= 3));			/* User should only access elements 0-3 */
		float *fp = (float*)&vec;
		return *(fp+i);
	}
};

						/* Miscellaneous */
		
/* Interleave low order data elements of a and b into destination */
inline F32vec4 unpack_low(const F32vec4 &a, const F32vec4 &b) 	
{ return _mm_unpacklo_ps(a, b); }

/* Interleave high order data elements of a and b into target */
inline F32vec4 unpack_high(const F32vec4 &a, const F32vec4 &b) 	
{ return _mm_unpackhi_ps(a, b); }

/* Move Mask to Integer returns 4 bit mask formed of most significant bits of a */
inline int move_mask(const F32vec4 &a)	
{ return _mm_movemask_ps(a);}					

						/* Data Motion Functions */

/* Load Unaligned loadu_ps: Unaligned */
inline void loadu(F32vec4 &a, float *p)	
{ a = _mm_loadu_ps(p); }									

/* Store Temporal storeu_ps: Unaligned */
inline void storeu(float *p, const F32vec4 &a)	
{ _mm_storeu_ps(p, a); }							

						/* Cacheability Support */

/* Non-Temporal Store */
inline void store_nta(float *p, F32vec4 &a) 
{ _mm_stream_ps(p,a);}							

						/* Conditional Selects:*/ 
/*(a OP b)? c : d; where OP is any compare operator
Macros expand to conditional selects which use all compare intrinsics.  
Example: 
friend F32vec4 select_eq(const F32vec4 &a, const F32vec4 &b, const F32vec4 &c, const F32vec4 &d) 
{																
	F32vec4 mask = _mm_cmpeq_ps(a,b);						
	return( (mask & c) | F32vec4((_mm_andnot_ps(mask,d))));	
}
*/												

#define Fvec32s4_SELECT(op) \
inline F32vec4 select_##op (const F32vec4 &a, const F32vec4 &b, const F32vec4 &c, const F32vec4 &d) 	   \
{																\
	F32vec4 mask = _mm_cmp##op##_ps(a,b);						\
	return( (mask & c) | F32vec4((_mm_andnot_ps(mask,d))));	\
}												
Fvec32s4_SELECT(eq)			// generates select_eq(a,b)
Fvec32s4_SELECT(lt)			// generates select_lt(a,b)
Fvec32s4_SELECT(le)			// generates select_le(a,b)	
Fvec32s4_SELECT(gt)			// generates select_gt(a,b)
Fvec32s4_SELECT(ge)			// generates select_ge(a,b)
Fvec32s4_SELECT(neq)		// generates select_neq(a,b)
Fvec32s4_SELECT(nlt)		// generates select_nlt(a,b)
Fvec32s4_SELECT(nle)		// generates select_nle(a,b)
Fvec32s4_SELECT(ngt)		// generates select_ngt(a,b)
Fvec32s4_SELECT(nge)		// generates select_nge(a,b)
#undef Fvec32s4_SELECT


/* Streaming SIMD Extensions Integer Intrinsics */

/* Max and Min */
inline Is16vec4 simd_max(const Is16vec4 &a, const Is16vec4 &b)		{ return _m_pmaxsw(a,b);}
inline Is16vec4 simd_min(const Is16vec4 &a, const Is16vec4 &b)		{ return _m_pminsw(a,b);}
inline Iu8vec8 simd_max(const Iu8vec8 &a, const Iu8vec8 &b)			{ return _m_pmaxub(a,b);}
inline Iu8vec8 simd_min(const Iu8vec8 &a, const Iu8vec8 &b)			{ return _m_pminub(a,b);}

/* Average */
inline Iu16vec4 simd_avg(const Iu16vec4 &a, const Iu16vec4 &b)		{ return _m_pavgw(a,b); }
inline Iu8vec8 simd_avg(const Iu8vec8 &a, const Iu8vec8 &b)			{ return _m_pavgb(a,b); }

/* Move ByteMask To Int: returns mask formed from most sig bits	of each vec of a */
inline int move_mask(const I8vec8 &a)								{ return _m_pmovmskb(a);}

/* Packed Multiply High Unsigned */
inline Iu16vec4 mul_high(const Iu16vec4 &a, const Iu16vec4 &b)		{ return _m_pmulhuw(a,b); }

/* Byte Mask Write: Write bytes if most significant bit in each corresponding byte is set */
inline void mask_move(const I8vec8 &a, const I8vec8 &b, char *addr)	{ _m_maskmovq(a, b, addr); }

/* Data Motion: Store Non Temporal */
inline void store_nta(__m64 *p, M64 &a) { _mm_stream_pi(p,a); }			

/* Conversions between ivec <-> fvec */

/* Convert first element of F32vec4 to int with truncation */
inline int F32vec4ToInt(const F32vec4 &a)       
{
  
	return _mm_cvtt_ss2si(a); 
   
}

/* Convert two lower SP FP values of a to Is32vec2 with truncation */
inline Is32vec2 F32vec4ToIs32vec2 (const F32vec4 &a)
{ 

	__m64 result;
	result = _mm_cvtt_ps2pi(a);
	return Is32vec2(result);
     
} 

/* Convert the 32-bit int i to an SP FP value; the upper three SP FP values are passed through from a. */   
inline F32vec4 IntToF32vec4(const F32vec4 &a, int i)
{ 

	__m128 result;
	result = _mm_cvt_si2ss(a,i);
	return F32vec4(result);
 
}    

/* Convert the two 32-bit integer values in b to two SP FP values; the upper two SP FP values are passed from a. */
inline F32vec4 Is32vec2ToF32vec4(const F32vec4 &a, const Is32vec2 &b) 
{
 
	__m128 result;
	result = _mm_cvt_pi2ps(a,b);
	return F32vec4(result);
}

class F32vec1
{
protected:
   	 __m128 vec;
public:

	/* Constructors: 1 float */
	F32vec1() {}

	F32vec1(int i)		{ vec = _mm_cvt_si2ss(vec,i);};

	/* Initialize each of 4 SP FPs with same float */
	EXPLICIT F32vec1(float f)	{ vec = _mm_set_ss(f); }

	/* Initialize each of 4 SP FPs with same float */
	EXPLICIT F32vec1(double d)	{ vec = _mm_set_ss((float) d); }

	/* initialize with __m128 data type */
	F32vec1(__m128 m)	{ vec = m; }

	/* Conversion functions */
	operator  __m128() const	{ return vec; }		/* Convert to float */

 	/* Logical Operators */
	friend F32vec1 operator &(const F32vec1 &a, const F32vec1 &b) { return _mm_and_ps(a,b); }
	friend F32vec1 operator |(const F32vec1 &a, const F32vec1 &b) { return _mm_or_ps(a,b); }
	friend F32vec1 operator ^(const F32vec1 &a, const F32vec1 &b) { return _mm_xor_ps(a,b); }

	/* Arithmetic Operators */
	friend F32vec1 operator +(const F32vec1 &a, const F32vec1 &b) { return _mm_add_ss(a,b); }
	friend F32vec1 operator -(const F32vec1 &a, const F32vec1 &b) { return _mm_sub_ss(a,b); }
	friend F32vec1 operator *(const F32vec1 &a, const F32vec1 &b) { return _mm_mul_ss(a,b); }
	friend F32vec1 operator /(const F32vec1 &a, const F32vec1 &b) { return _mm_div_ss(a,b); }

	F32vec1& operator +=(F32vec1 &a) { return *this = _mm_add_ss(vec,a); }
	F32vec1& operator -=(F32vec1 &a) { return *this = _mm_sub_ss(vec,a); }
	F32vec1& operator *=(F32vec1 &a) { return *this = _mm_mul_ss(vec,a); }
	F32vec1& operator /=(F32vec1 &a) { return *this = _mm_div_ss(vec,a); }
	F32vec1& operator &=(F32vec1 &a) { return *this = _mm_and_ps(vec,a); }
	F32vec1& operator |=(F32vec1 &a) { return *this = _mm_or_ps(vec,a); }
	F32vec1& operator ^=(F32vec1 &a) { return *this = _mm_xor_ps(vec,a); }


	/* Square Root */
	friend F32vec1 sqrt(const F32vec1 &a)		{ return _mm_sqrt_ss(a); }
	/* Reciprocal */
	friend F32vec1 rcp(const F32vec1 &a)		{ return _mm_rcp_ss(a); }
	/* Reciprocal Square Root */
	friend F32vec1 rsqrt(const F32vec1 &a)		{ return _mm_rsqrt_ss(a); }

	/* NewtonRaphson Reciprocal
	   [2 * rcpss(x) - (x * rcpss(x) * rcpss(x))] */
	friend F32vec1 rcp_nr(const F32vec1 &a)
	{
		F32vec1 Ra0 = _mm_rcp_ss(a);
		return _mm_sub_ss(_mm_add_ss(Ra0, Ra0), _mm_mul_ss(_mm_mul_ss(Ra0, a), Ra0));
	}

	/*	NewtonRaphson Reciprocal Square Root
	  	0.5 * rsqrtss * (3 - x * rsqrtss(x) * rsqrtss(x)) */
	friend F32vec1 rsqrt_nr(const F32vec1 &a)
	{
		static const F32vec1 fvecf0pt5(0.5f);
		static const F32vec1 fvecf3pt0(3.0f);
		F32vec1 Ra0 = _mm_rsqrt_ss(a);
		return (fvecf0pt5 * Ra0) * (fvecf3pt0 - (a * Ra0) * Ra0);

	}

	/* Compares: Mask is returned  */
	/* Macros expand to all compare intrinsics.  Example:
	friend F32vec1 cmpeq(const F32vec1 &a, const F32vec1 &b)
	{ return _mm_cmpeq_ss(a,b);} */
	#define Fvec32s1_COMP(op) \
	friend F32vec1 cmp##op (const F32vec1 &a, const F32vec1 &b) { return _mm_cmp##op##_ss(a,b); }
		Fvec32s1_COMP(eq)					// expanded to cmpeq(a,b)
		Fvec32s1_COMP(lt)					// expanded to cmplt(a,b)
		Fvec32s1_COMP(le)					// expanded to cmple(a,b)
		Fvec32s1_COMP(gt)					// expanded to cmpgt(a,b)
		Fvec32s1_COMP(ge)					// expanded to cmpge(a,b)
		Fvec32s1_COMP(neq)					// expanded to cmpneq(a,b)
		Fvec32s1_COMP(nlt)					// expanded to cmpnlt(a,b)
		Fvec32s1_COMP(nle)					// expanded to cmpnle(a,b)
		Fvec32s1_COMP(ngt)					// expanded to cmpngt(a,b)
		Fvec32s1_COMP(nge)					// expanded to cmpnge(a,b)
	#undef Fvec32s1_COMP

	/* Min and Max */
	friend F32vec1 simd_min(const F32vec1 &a, const F32vec1 &b) { return _mm_min_ss(a,b); }
	friend F32vec1 simd_max(const F32vec1 &a, const F32vec1 &b) { return _mm_max_ss(a,b); }

	/* Debug Features */
	/* Output */
	friend ostream & operator<<(ostream & os, const F32vec1 &a)
	{
	/* To use: cout << "Elements of F32vec1 fvec are: " << fvec; */
	  float *fp = (float*)&a;
	  	os << "float:" << *fp;
		return os;
	}

};

						/* Conditional Selects:*/
/*(a OP b)? c : d; where OP is any compare operator
Macros expand to conditional selects which use all compare intrinsics.
Example:
friend F32vec1 select_eq(const F32vec1 &a, const F32vec1 &b, const F32vec1 &c, const F32vec1 &d)
{
	F32vec1 mask = _mm_cmpeq_ss(a,b);
	return( (mask & c) | F32vec1((_mm_andnot_ps(mask,d))));
}
*/

#define Fvec32s1_SELECT(op) \
inline F32vec1 select_##op (const F32vec1 &a, const F32vec1 &b, const F32vec1 &c, const F32vec1 &d) 	   \
{													   \
	F32vec1 mask = _mm_cmp##op##_ss(a,b);						                   \
	return( (mask & c) | F32vec1((_mm_andnot_ps(mask,d))));	                                           \
}
Fvec32s1_SELECT(eq)			// generates select_eq(a,b)
Fvec32s1_SELECT(lt)			// generates select_lt(a,b)
Fvec32s1_SELECT(le)			// generates select_le(a,b)
Fvec32s1_SELECT(gt)			// generates select_gt(a,b)
Fvec32s1_SELECT(ge)			// generates select_ge(a,b)
Fvec32s1_SELECT(neq)		// generates select_neq(a,b)
Fvec32s1_SELECT(nlt)		// generates select_nlt(a,b)
Fvec32s1_SELECT(nle)		// generates select_nle(a,b)
Fvec32s1_SELECT(ngt)		// generates select_ngt(a,b)
Fvec32s1_SELECT(nge)		// generates select_nge(a,b)
#undef Fvec32s1_SELECT

/* Conversions between ivec <-> fvec */

/* Convert F32vec1 to int */
inline int F32vec1ToInt(const F32vec1 &a)
{
	return _mm_cvtt_ss2si(a);
}



#pragma pack(pop) /* 16-B aligned */
#endif /* FVEC_H_INCLUDED */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\gcroot.h ===
//
//	gcroot.h - Template class that wraps GCHandle from mscorlib.dll.
//		Copyright (C) 2000-2001 Microsoft Corporation
//		All rights reserved.
//
//	Use this class to declare gc "pointers" that live in the C++ heap.
//	
//	Example:
//		struct StringList {
//			gcroot<String*> str;
//			StringList *next;
//			StringList(); // should have ctors and dtors
//			~StringList();
//		};
//
//	By convention, we maintain a 1-to-1 relationship between C++ objects
//	and the handle slots they "point" to.  Thus, two distinct C++ objects
//	always refer to two distinct handles, even if they "point" to the same
//	object.  Therefore, when the C++ object is destroyed, its handle can
//	be freed without error.
//
//	Note that we cannot currently embed a GCHandle directly in an unmanaged C++
//	class.  We therefore store an int, and use the conversion methods of
//	GCHandle to reconstitute a GCHandle from the int on demand.
//	


#if _MSC_VER > 1000
#pragma once
#endif

#if !defined(_INC_GCROOT)
#define _INC_GCROOT

#using <mscorlib.dll>

template <class T> struct gcroot {

	typedef System::Runtime::InteropServices::GCHandle GCHandle;

	// always allocate a new handle during construction (see above)
	//
	gcroot() {
		_handle = GCHandle::op_Explicit(GCHandle::Alloc(0));
	}

	// this can't be T& here because & does not yet work on managed types
	// (T should be a pointer anyway).
	//
	gcroot(T t) {
		_handle = GCHandle::op_Explicit(GCHandle::Alloc(t));
	}

	gcroot(const gcroot& r) {
		// don't copy a handle, copy what it points to (see above)
		_handle = GCHandle::op_Explicit(
						GCHandle::Alloc(
							GCHandle::op_Explicit(r._handle).Target ));
	}

	// Since C++ objects and handles are allocated 1-to-1, we can 
	// free the handle when the object is destroyed
	//
	~gcroot() {
		GCHandle g = GCHandle::op_Explicit(_handle);
		g.Free();
		_handle = 0; // should fail if reconstituted
	}

	gcroot& operator=(T t) {
		// no need to check for valid handle; was allocated in ctor
		GCHandle::op_Explicit(_handle).Target = t;
		return *this;
	}

	gcroot& operator=(const gcroot &r) {
		// no need to check for valid handle; was allocated in ctor
		T t = (T)r;
		GCHandle::op_Explicit(_handle).Target = t;
		return *this;
	}

	operator T () const {
		// gcroot is typesafe, so use static_cast
		return static_cast<T>( GCHandle::op_Explicit(_handle).Target );
	}

	// don't return T& here because & to gc pointer not yet implemented
	// (T should be a pointer anyway).
	T operator->() const {
		// gcroot is typesafe, so use static_cast
		return static_cast<T>(GCHandle::op_Explicit(_handle).Target);
	}

private:
	// Don't let anyone copy the handle value directly, or make a copy
	// by taking the address of this object and pointing to it from
	// somewhere else.  The root will be freed when the dtor of this
	// object gets called, and anyone pointing to it still will
	// cause serious harm to the Garbage Collector.
	//
	int _handle;
	T* operator& ();
};

#endif  // _INC_GCROOT
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\GenLex.h ===
/*++

Copyright (C) 1999 Microsoft Corporation

Module Name:

    GENLEX.H

Abstract:

    Generic lexer framework classes.

History:

--*/

#ifndef _GENLEX_H_
#define _GENLEX_H_

#include <Polarity.h>

class CGenLexSource
{
public:
    virtual wchar_t NextChar() = 0;
        // Return 0 on end-of-input
    virtual void Pushback(wchar_t) = 0;
    virtual void Reset() = 0;
};

class CTextLexSource : public CGenLexSource
{
    const wchar_t *m_pSrcBuf;
    const wchar_t *m_pStart;

public:
    CTextLexSource(const wchar_t *pSrc) { SetString(pSrc); }
        // Binds directly to <pSrc> buffer, but doesn't delete it.

    wchar_t NextChar()
    {
        if (!m_pSrcBuf)
            return 0;
        else
            return *m_pSrcBuf++ ? m_pSrcBuf[-1] : 0;
    }

    void Pushback(wchar_t)
    {
        if (m_pSrcBuf)
            --m_pSrcBuf;
    }

    void Reset() { m_pSrcBuf = m_pStart; }
    void SetString (const wchar_t *pSrc) { m_pSrcBuf = m_pStart = pSrc; }
};


#pragma pack(2)
struct LexEl
{
    wchar_t cFirst, cLast;
    WORD wGotoState;
    WORD wReturnTok;
    WORD wInstructions;
};
#pragma pack()


// Lexer driver instructions

#define GLEX_ACCEPT      0x1            // Add the char to the token
#define GLEX_CONSUME     0x2            // Consume the char without adding to token
#define GLEX_PUSHBACK    0x4            // Place the char back in the source buffer for next token
#define GLEX_NOT         0x8            // A match occurs if the char is NOT the one specified
#define GLEX_LINEFEED    0x10               // Increase the source linecount
#define GLEX_RETURN      0x20               // Return the indicated token to caller
#define GLEX_ANY         wchar_t(0xFFFF)    // Any character
#define GLEX_EMPTY       wchar_t(0xFFFE)   