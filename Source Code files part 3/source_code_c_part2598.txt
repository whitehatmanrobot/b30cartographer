/ double w,
            /* [in] */ double h) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Rect( 
            /* [in] */ double xPos,
            /* [in] */ double yPos,
            /* [in] */ double w,
            /* [in] */ double h) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RoundRect( 
            /* [in] */ double xPos,
            /* [in] */ double yPos,
            /* [in] */ double w,
            /* [in] */ double h,
            /* [in] */ double arcWidth,
            /* [in] */ double arcHeight) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PieRadians( 
            /* [in] */ double xPos,
            /* [in] */ double yPos,
            /* [in] */ double startAngle,
            /* [in] */ double endAngle,
            /* [in] */ double arcWidth,
            /* [in] */ double arcHeight) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PieDegrees( 
            /* [in] */ double xPos,
            /* [in] */ double yPos,
            /* [in] */ double startAngle,
            /* [in] */ double endAngle,
            /* [in] */ double arcWidth,
            /* [in] */ double arcHeight) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Text( 
            /* [in] */ BSTR str,
            /* [in] */ double xPos,
            /* [in] */ double yPos) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TextPoint( 
            /* [in] */ BSTR str,
            /* [in] */ IDAPoint2 *point) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FillPath( 
            /* [in] */ IDAPath2 *path) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DrawPath( 
            /* [in] */ IDAPath2 *path) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OverlayImage( 
            /* [in] */ IDAImage *img) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDADrawingSurfaceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDADrawingSurface * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDADrawingSurface * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDADrawingSurface * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDADrawingSurface * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDADrawingSurface * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDADrawingSurface * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDADrawingSurface * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Image )( 
            IDADrawingSurface * This,
            /* [retval][out] */ IDAImage **img);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_LineStyle )( 
            IDADrawingSurface * This,
            /* [in] */ IDALineStyle *ls);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_BorderStyle )( 
            IDADrawingSurface * This,
            /* [in] */ IDALineStyle *bs);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_FontStyle )( 
            IDADrawingSurface * This,
            /* [in] */ IDAFontStyle *fs);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ClipMatte )( 
            IDADrawingSurface * This,
            /* [in] */ IDAMatte *matte);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_MouseEventsEnabled )( 
            IDADrawingSurface * This,
            /* [in] */ VARIANT_BOOL on);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_HatchFillTransparent )( 
            IDADrawingSurface * This,
            /* [in] */ VARIANT_BOOL fillOff);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_LocalContextImage )( 
            IDADrawingSurface * This,
            /* [retval][out] */ IDAImage **img);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IDADrawingSurface * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clear )( 
            IDADrawingSurface * This);
        
        HRESULT ( STDMETHODCALLTYPE *SaveGraphicsState )( 
            IDADrawingSurface * This);
        
        HRESULT ( STDMETHODCALLTYPE *RestoreGraphicsState )( 
            IDADrawingSurface * This);
        
        HRESULT ( STDMETHODCALLTYPE *Opacity )( 
            IDADrawingSurface * This,
            /* [in] */ double opac);
        
        HRESULT ( STDMETHODCALLTYPE *OpacityAnim )( 
            IDADrawingSurface * This,
            /* [in] */ IDANumber *opac);
        
        HRESULT ( STDMETHODCALLTYPE *Crop )( 
            IDADrawingSurface * This,
            /* [in] */ double lowerLeftX,
            /* [in] */ double lowerLeftY,
            /* [in] */ double upperRightX,
            /* [in] */ double upperRightY);
        
        HRESULT ( STDMETHODCALLTYPE *CropPoints )( 
            IDADrawingSurface * This,
            /* [in] */ IDAPoint2 *min,
            /* [in] */ IDAPoint2 *max);
        
        HRESULT ( STDMETHODCALLTYPE *Transform )( 
            IDADrawingSurface * This,
            /* [in] */ IDATransform2 *xform);
        
        HRESULT ( STDMETHODCALLTYPE *LineColor )( 
            IDADrawingSurface * This,
            /* [in] */ IDAColor *clr);
        
        HRESULT ( STDMETHODCALLTYPE *LineWidth )( 
            IDADrawingSurface * This,
            /* [in] */ double w);
        
        HRESULT ( STDMETHODCALLTYPE *LineDashStyle )( 
            IDADrawingSurface * This,
            /* [in] */ DA_DASH_STYLE id);
        
        HRESULT ( STDMETHODCALLTYPE *LineEndStyle )( 
            IDADrawingSurface * This,
            /* [in] */ DA_END_STYLE id);
        
        HRESULT ( STDMETHODCALLTYPE *LineJoinStyle )( 
            IDADrawingSurface * This,
            /* [in] */ DA_JOIN_STYLE id);
        
        HRESULT ( STDMETHODCALLTYPE *BorderColor )( 
            IDADrawingSurface * This,
            /* [in] */ IDAColor *clr);
        
        HRESULT ( STDMETHODCALLTYPE *BorderWidth )( 
            IDADrawingSurface * This,
            /* [in] */ double w);
        
        HRESULT ( STDMETHODCALLTYPE *BorderDashStyle )( 
            IDADrawingSurface * This,
            /* [in] */ DA_DASH_STYLE id);
        
        HRESULT ( STDMETHODCALLTYPE *BorderEndStyle )( 
            IDADrawingSurface * This,
            /* [in] */ DA_END_STYLE obsolete);
        
        HRESULT ( STDMETHODCALLTYPE *BorderJoinStyle )( 
            IDADrawingSurface * This,
            /* [in] */ DA_JOIN_STYLE id);
        
        HRESULT ( STDMETHODCALLTYPE *Font )( 
            IDADrawingSurface * This,
            /* [in] */ BSTR FontFace,
            /* [in] */ LONG sizeInPoints,
            /* [in] */ VARIANT_BOOL Bold,
            /* [in] */ VARIANT_BOOL italic,
            /* [in] */ VARIANT_BOOL underline,
            /* [in] */ VARIANT_BOOL strikethrough);
        
        HRESULT ( STDMETHODCALLTYPE *TextureFill )( 
            IDADrawingSurface * This,
            /* [in] */ IDAImage *obsolete1,
            /* [in] */ double obsolete2,
            /* [in] */ double obsolete3);
        
        HRESULT ( STDMETHODCALLTYPE *ImageFill )( 
            IDADrawingSurface * This,
            /* [in] */ IDAImage *obsolete1,
            /* [in] */ double obsolete2,
            /* [in] */ double obsolete3);
        
        HRESULT ( STDMETHODCALLTYPE *FillTexture )( 
            IDADrawingSurface * This,
            /* [in] */ IDAImage *img);
        
        HRESULT ( STDMETHODCALLTYPE *FillImage )( 
            IDADrawingSurface * This,
            /* [in] */ IDAImage *img);
        
        HRESULT ( STDMETHODCALLTYPE *FillStyle )( 
            IDADrawingSurface * This,
            /* [in] */ int ID);
        
        HRESULT ( STDMETHODCALLTYPE *FillColor )( 
            IDADrawingSurface * This,
            /* [in] */ IDAColor *foreground);
        
        HRESULT ( STDMETHODCALLTYPE *SecondaryFillColor )( 
            IDADrawingSurface * This,
            /* [in] */ IDAColor *val);
        
        HRESULT ( STDMETHODCALLTYPE *GradientShape )( 
            IDADrawingSurface * This,
            /* [in] */ VARIANT pts);
        
        HRESULT ( STDMETHODCALLTYPE *GradientExtent )( 
            IDADrawingSurface * This,
            /* [in] */ double startx,
            /* [in] */ double starty,
            /* [in] */ double finishx,
            /* [in] */ double finishy);
        
        HRESULT ( STDMETHODCALLTYPE *GradientExtentPoints )( 
            IDADrawingSurface * This,
            /* [in] */ IDAPoint2 *startColor,
            /* [in] */ IDAPoint2 *stopColor);
        
        HRESULT ( STDMETHODCALLTYPE *GradientRolloffPower )( 
            IDADrawingSurface * This,
            /* [in] */ double power);
        
        HRESULT ( STDMETHODCALLTYPE *GradientRolloffPowerAnim )( 
            IDADrawingSurface * This,
            /* [in] */ IDANumber *power);
        
        HRESULT ( STDMETHODCALLTYPE *FixedFillScale )( 
            IDADrawingSurface * This);
        
        HRESULT ( STDMETHODCALLTYPE *HorizontalFillScale )( 
            IDADrawingSurface * This);
        
        HRESULT ( STDMETHODCALLTYPE *VerticalFillScale )( 
            IDADrawingSurface * This);
        
        HRESULT ( STDMETHODCALLTYPE *AutoSizeFillScale )( 
            IDADrawingSurface * This);
        
        HRESULT ( STDMETHODCALLTYPE *PolylineEx )( 
            IDADrawingSurface * This,
            /* [in] */ LONG numPts,
            /* [size_is][in] */ IDAPoint2 *pts[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *Polyline )( 
            IDADrawingSurface * This,
            /* [in] */ VARIANT v);
        
        HRESULT ( STDMETHODCALLTYPE *PolygonEx )( 
            IDADrawingSurface * This,
            /* [in] */ LONG numPts,
            /* [size_is][in] */ IDAPoint2 *pts[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *Polygon )( 
            IDADrawingSurface * This,
            /* [in] */ VARIANT v);
        
        HRESULT ( STDMETHODCALLTYPE *LinePoints )( 
            IDADrawingSurface * This,
            /* [in] */ IDAPoint2 *p1,
            /* [in] */ IDAPoint2 *p2);
        
        HRESULT ( STDMETHODCALLTYPE *Line )( 
            IDADrawingSurface * This,
            /* [in] */ double startX,
            /* [in] */ double startY,
            /* [in] */ double endX,
            /* [in] */ double endY);
        
        HRESULT ( STDMETHODCALLTYPE *ArcRadians )( 
            IDADrawingSurface * This,
            /* [in] */ double xPos,
            /* [in] */ double yPos,
            /* [in] */ double startAngle,
            /* [in] */ double endAngle,
            /* [in] */ double arcWidth,
            /* [in] */ double arcHeight);
        
        HRESULT ( STDMETHODCALLTYPE *ArcDegrees )( 
            IDADrawingSurface * This,
            /* [in] */ double xPos,
            /* [in] */ double yPos,
            /* [in] */ double startAngle,
            /* [in] */ double endAngle,
            /* [in] */ double arcWidth,
            /* [in] */ double arcHeight);
        
        HRESULT ( STDMETHODCALLTYPE *Oval )( 
            IDADrawingSurface * This,
            /* [in] */ double xPos,
            /* [in] */ double yPos,
            /* [in] */ double w,
            /* [in] */ double h);
        
        HRESULT ( STDMETHODCALLTYPE *Rect )( 
            IDADrawingSurface * This,
            /* [in] */ double xPos,
            /* [in] */ double yPos,
            /* [in] */ double w,
            /* [in] */ double h);
        
        HRESULT ( STDMETHODCALLTYPE *RoundRect )( 
            IDADrawingSurface * This,
            /* [in] */ double xPos,
            /* [in] */ double yPos,
            /* [in] */ double w,
            /* [in] */ double h,
            /* [in] */ double arcWidth,
            /* [in] */ double arcHeight);
        
        HRESULT ( STDMETHODCALLTYPE *PieRadians )( 
            IDADrawingSurface * This,
            /* [in] */ double xPos,
            /* [in] */ double yPos,
            /* [in] */ double startAngle,
            /* [in] */ double endAngle,
            /* [in] */ double arcWidth,
            /* [in] */ double arcHeight);
        
        HRESULT ( STDMETHODCALLTYPE *PieDegrees )( 
            IDADrawingSurface * This,
            /* [in] */ double xPos,
            /* [in] */ double yPos,
            /* [in] */ double startAngle,
            /* [in] */ double endAngle,
            /* [in] */ double arcWidth,
            /* [in] */ double arcHeight);
        
        HRESULT ( STDMETHODCALLTYPE *Text )( 
            IDADrawingSurface * This,
            /* [in] */ BSTR str,
            /* [in] */ double xPos,
            /* [in] */ double yPos);
        
        HRESULT ( STDMETHODCALLTYPE *TextPoint )( 
            IDADrawingSurface * This,
            /* [in] */ BSTR str,
            /* [in] */ IDAPoint2 *point);
        
        HRESULT ( STDMETHODCALLTYPE *FillPath )( 
            IDADrawingSurface * This,
            /* [in] */ IDAPath2 *path);
        
        HRESULT ( STDMETHODCALLTYPE *DrawPath )( 
            IDADrawingSurface * This,
            /* [in] */ IDAPath2 *path);
        
        HRESULT ( STDMETHODCALLTYPE *OverlayImage )( 
            IDADrawingSurface * This,
            /* [in] */ IDAImage *img);
        
        END_INTERFACE
    } IDADrawingSurfaceVtbl;

    interface IDADrawingSurface
    {
        CONST_VTBL struct IDADrawingSurfaceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDADrawingSurface_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDADrawingSurface_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDADrawingSurface_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDADrawingSurface_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDADrawingSurface_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDADrawingSurface_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDADrawingSurface_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDADrawingSurface_get_Image(This,img)	\
    (This)->lpVtbl -> get_Image(This,img)

#define IDADrawingSurface_put_LineStyle(This,ls)	\
    (This)->lpVtbl -> put_LineStyle(This,ls)

#define IDADrawingSurface_put_BorderStyle(This,bs)	\
    (This)->lpVtbl -> put_BorderStyle(This,bs)

#define IDADrawingSurface_put_FontStyle(This,fs)	\
    (This)->lpVtbl -> put_FontStyle(This,fs)

#define IDADrawingSurface_put_ClipMatte(This,matte)	\
    (This)->lpVtbl -> put_ClipMatte(This,matte)

#define IDADrawingSurface_put_MouseEventsEnabled(This,on)	\
    (This)->lpVtbl -> put_MouseEventsEnabled(This,on)

#define IDADrawingSurface_put_HatchFillTransparent(This,fillOff)	\
    (This)->lpVtbl -> put_HatchFillTransparent(This,fillOff)

#define IDADrawingSurface_get_LocalContextImage(This,img)	\
    (This)->lpVtbl -> get_LocalContextImage(This,img)

#define IDADrawingSurface_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IDADrawingSurface_Clear(This)	\
    (This)->lpVtbl -> Clear(This)

#define IDADrawingSurface_SaveGraphicsState(This)	\
    (This)->lpVtbl -> SaveGraphicsState(This)

#define IDADrawingSurface_RestoreGraphicsState(This)	\
    (This)->lpVtbl -> RestoreGraphicsState(This)

#define IDADrawingSurface_Opacity(This,opac)	\
    (This)->lpVtbl -> Opacity(This,opac)

#define IDADrawingSurface_OpacityAnim(This,opac)	\
    (This)->lpVtbl -> OpacityAnim(This,opac)

#define IDADrawingSurface_Crop(This,lowerLeftX,lowerLeftY,upperRightX,upperRightY)	\
    (This)->lpVtbl -> Crop(This,lowerLeftX,lowerLeftY,upperRightX,upperRightY)

#define IDADrawingSurface_CropPoints(This,min,max)	\
    (This)->lpVtbl -> CropPoints(This,min,max)

#define IDADrawingSurface_Transform(This,xform)	\
    (This)->lpVtbl -> Transform(This,xform)

#define IDADrawingSurface_LineColor(This,clr)	\
    (This)->lpVtbl -> LineColor(This,clr)

#define IDADrawingSurface_LineWidth(This,w)	\
    (This)->lpVtbl -> LineWidth(This,w)

#define IDADrawingSurface_LineDashStyle(This,id)	\
    (This)->lpVtbl -> LineDashStyle(This,id)

#define IDADrawingSurface_LineEndStyle(This,id)	\
    (This)->lpVtbl -> LineEndStyle(This,id)

#define IDADrawingSurface_LineJoinStyle(This,id)	\
    (This)->lpVtbl -> LineJoinStyle(This,id)

#define IDADrawingSurface_BorderColor(This,clr)	\
    (This)->lpVtbl -> BorderColor(This,clr)

#define IDADrawingSurface_BorderWidth(This,w)	\
    (This)->lpVtbl -> BorderWidth(This,w)

#define IDADrawingSurface_BorderDashStyle(This,id)	\
    (This)->lpVtbl -> BorderDashStyle(This,id)

#define IDADrawingSurface_BorderEndStyle(This,obsolete)	\
    (This)->lpVtbl -> BorderEndStyle(This,obsolete)

#define IDADrawingSurface_BorderJoinStyle(This,id)	\
    (This)->lpVtbl -> BorderJoinStyle(This,id)

#define IDADrawingSurface_Font(This,FontFace,sizeInPoints,Bold,italic,underline,strikethrough)	\
    (This)->lpVtbl -> Font(This,FontFace,sizeInPoints,Bold,italic,underline,strikethrough)

#define IDADrawingSurface_TextureFill(This,obsolete1,obsolete2,obsolete3)	\
    (This)->lpVtbl -> TextureFill(This,obsolete1,obsolete2,obsolete3)

#define IDADrawingSurface_ImageFill(This,obsolete1,obsolete2,obsolete3)	\
    (This)->lpVtbl -> ImageFill(This,obsolete1,obsolete2,obsolete3)

#define IDADrawingSurface_FillTexture(This,img)	\
    (This)->lpVtbl -> FillTexture(This,img)

#define IDADrawingSurface_FillImage(This,img)	\
    (This)->lpVtbl -> FillImage(This,img)

#define IDADrawingSurface_FillStyle(This,ID)	\
    (This)->lpVtbl -> FillStyle(This,ID)

#define IDADrawingSurface_FillColor(This,foreground)	\
    (This)->lpVtbl -> FillColor(This,foreground)

#define IDADrawingSurface_SecondaryFillColor(This,val)	\
    (This)->lpVtbl -> SecondaryFillColor(This,val)

#define IDADrawingSurface_GradientShape(This,pts)	\
    (This)->lpVtbl -> GradientShape(This,pts)

#define IDADrawingSurface_GradientExtent(This,startx,starty,finishx,finishy)	\
    (This)->lpVtbl -> GradientExtent(This,startx,starty,finishx,finishy)

#define IDADrawingSurface_GradientExtentPoints(This,startColor,stopColor)	\
    (This)->lpVtbl -> GradientExtentPoints(This,startColor,stopColor)

#define IDADrawingSurface_GradientRolloffPower(This,power)	\
    (This)->lpVtbl -> GradientRolloffPower(This,power)

#define IDADrawingSurface_GradientRolloffPowerAnim(This,power)	\
    (This)->lpVtbl -> GradientRolloffPowerAnim(This,power)

#define IDADrawingSurface_FixedFillScale(This)	\
    (This)->lpVtbl -> FixedFillScale(This)

#define IDADrawingSurface_HorizontalFillScale(This)	\
    (This)->lpVtbl -> HorizontalFillScale(This)

#define IDADrawingSurface_VerticalFillScale(This)	\
    (This)->lpVtbl -> VerticalFillScale(This)

#define IDADrawingSurface_AutoSizeFillScale(This)	\
    (This)->lpVtbl -> AutoSizeFillScale(This)

#define IDADrawingSurface_PolylineEx(This,numPts,pts)	\
    (This)->lpVtbl -> PolylineEx(This,numPts,pts)

#define IDADrawingSurface_Polyline(This,v)	\
    (This)->lpVtbl -> Polyline(This,v)

#define IDADrawingSurface_PolygonEx(This,numPts,pts)	\
    (This)->lpVtbl -> PolygonEx(This,numPts,pts)

#define IDADrawingSurface_Polygon(This,v)	\
    (This)->lpVtbl -> Polygon(This,v)

#define IDADrawingSurface_LinePoints(This,p1,p2)	\
    (This)->lpVtbl -> LinePoints(This,p1,p2)

#define IDADrawingSurface_Line(This,startX,startY,endX,endY)	\
    (This)->lpVtbl -> Line(This,startX,startY,endX,endY)

#define IDADrawingSurface_ArcRadians(This,xPos,yPos,startAngle,endAngle,arcWidth,arcHeight)	\
    (This)->lpVtbl -> ArcRadians(This,xPos,yPos,startAngle,endAngle,arcWidth,arcHeight)

#define IDADrawingSurface_ArcDegrees(This,xPos,yPos,startAngle,endAngle,arcWidth,arcHeight)	\
    (This)->lpVtbl -> ArcDegrees(This,xPos,yPos,startAngle,endAngle,arcWidth,arcHeight)

#define IDADrawingSurface_Oval(This,xPos,yPos,w,h)	\
    (This)->lpVtbl -> Oval(This,xPos,yPos,w,h)

#define IDADrawingSurface_Rect(This,xPos,yPos,w,h)	\
    (This)->lpVtbl -> Rect(This,xPos,yPos,w,h)

#define IDADrawingSurface_RoundRect(This,xPos,yPos,w,h,arcWidth,arcHeight)	\
    (This)->lpVtbl -> RoundRect(This,xPos,yPos,w,h,arcWidth,arcHeight)

#define IDADrawingSurface_PieRadians(This,xPos,yPos,startAngle,endAngle,arcWidth,arcHeight)	\
    (This)->lpVtbl -> PieRadians(This,xPos,yPos,startAngle,endAngle,arcWidth,arcHeight)

#define IDADrawingSurface_PieDegrees(This,xPos,yPos,startAngle,endAngle,arcWidth,arcHeight)	\
    (This)->lpVtbl -> PieDegrees(This,xPos,yPos,startAngle,endAngle,arcWidth,arcHeight)

#define IDADrawingSurface_Text(This,str,xPos,yPos)	\
    (This)->lpVtbl -> Text(This,str,xPos,yPos)

#define IDADrawingSurface_TextPoint(This,str,point)	\
    (This)->lpVtbl -> TextPoint(This,str,point)

#define IDADrawingSurface_FillPath(This,path)	\
    (This)->lpVtbl -> FillPath(This,path)

#define IDADrawingSurface_DrawPath(This,path)	\
    (This)->lpVtbl -> DrawPath(This,path)

#define IDADrawingSurface_OverlayImage(This,img)	\
    (This)->lpVtbl -> OverlayImage(This,img)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget] */ HRESULT STDMETHODCALLTYPE IDADrawingSurface_get_Image_Proxy( 
    IDADrawingSurface * This,
    /* [retval][out] */ IDAImage **img);



/* [propput] */ HRESULT STDMETHODCALLTYPE IDADrawingSurface_put_LineStyle_Proxy( 
    IDADrawingSurface * This,
    /* [in] */ IDALineStyle *ls);



/* [propput] */ HRESULT STDMETHODCALLTYPE IDADrawingSurface_put_BorderStyle_Proxy( 
    IDADrawingSurface * This,
    /* [in] */ IDALineStyle *bs);



/* [propput] */ HRESULT STDMETHODCALLTYPE IDADrawingSurface_put_FontStyle_Proxy( 
    IDADrawingSurface * This,
    /* [in] */ IDAFontStyle *fs);



/* [propput] */ HRESULT STDMETHODCALLTYPE IDADrawingSurface_put_ClipMatte_Proxy( 
    IDADrawingSurface * This,
    /* [in] */ IDAMatte *matte);



/* [propput] */ HRESULT STDMETHODCALLTYPE IDADrawingSurface_put_MouseEventsEnabled_Proxy( 
    IDADrawingSurface * This,
    /* [in] */ VARIANT_BOOL on);



/* [propput] */ HRESULT STDMETHODCALLTYPE IDADrawingSurface_put_HatchFillTransparent_Proxy( 
    IDADrawingSurface * This,
    /* [in] */ VARIANT_BOOL fillOff);



/* [propget] */ HRESULT STDMETHODCALLTYPE IDADrawingSurface_get_LocalContextImage_Proxy( 
    IDADrawingSurface * This,
    /* [retval][out] */ IDAImage **img);



HRESULT STDMETHODCALLTYPE IDADrawingSurface_Reset_Proxy( 
    IDADrawingSurface * This);



HRESULT STDMETHODCALLTYPE IDADrawingSurface_Clear_Proxy( 
    IDADrawingSurface * This);



HRESULT STDMETHODCALLTYPE IDADrawingSurface_SaveGraphicsState_Proxy( 
    IDADrawingSurface * This);



HRESULT STDMETHODCALLTYPE IDADrawingSurface_RestoreGraphicsState_Proxy( 
    IDADrawingSurface * This);



HRESULT STDMETHODCALLTYPE IDADrawingSurface_Opacity_Proxy( 
    IDADrawingSurface * This,
    /* [in] */ double opac);



HRESULT STDMETHODCALLTYPE IDADrawingSurface_OpacityAnim_Proxy( 
    IDADrawingSurface * This,
    /* [in] */ IDANumber *opac);



HRESULT STDMETHODCALLTYPE IDADrawingSurface_Crop_Proxy( 
    IDADrawingSurface * This,
    /* [in] */ double lowerLeftX,
    /* [in] */ double lowerLeftY,
    /* [in] */ double upperRightX,
    /* [in] */ double upperRightY);



HRESULT STDMETHODCALLTYPE IDADrawingSurface_CropPoints_Proxy( 
    IDADrawingSurface * This,
    /* [in] */ IDAPoint2 *min,
    /* [in] */ IDAPoint2 *max);



HRESULT STDMETHODCALLTYPE IDADrawingSurface_Transform_Proxy( 
    IDADrawingSurface * This,
    /* [in] */ IDATransform2 *xform);



HRESULT STDMETHODCALLTYPE IDADrawingSurface_LineColor_Proxy( 
    IDADrawingSurface * This,
    /* [in] */ IDAColor *clr);



HRESULT STDMETHODCALLTYPE IDADrawingSurface_LineWidth_Proxy( 
    IDADrawingSurface * This,
    /* [in] */ double w);



HRESULT STDMETHODCALLTYPE IDADrawingSurface_LineDashStyle_Proxy( 
    IDADrawingSurface * This,
    /* [in] */ DA_DASH_STYLE id);



HRESULT STDMETHODCALLTYPE IDADrawingSurface_LineEndStyle_Proxy( 
    IDADrawingSurface * This,
    /* [in] */ DA_END_STYLE id);



HRESULT STDMETHODCALLTYPE IDADrawingSurface_LineJoinStyle_Proxy( 
    IDADrawingSurface * This,
    /* [in] */ DA_JOIN_STYLE id);



HRESULT STDMETHODCALLTYPE IDADrawingSurface_BorderColor_Proxy( 
    IDADrawingSurface * This,
    /* [in] */ IDAColor *clr);



HRESULT STDMETHODCALLTYPE IDADrawingSurface_BorderWidth_Proxy( 
    IDADrawingSurface * This,
    /* [in] */ double w);



HRESULT STDMETHODCALLTYPE IDADrawingSurface_BorderDashStyle_Proxy( 
    IDADrawingSurface * This,
    /* [in] */ DA_DASH_STYLE id);



HRESULT STDMETHODCALLTYPE IDADrawingSurface_BorderEndStyle_Proxy( 
    IDADrawingSurface * This,
    /* [in] */ DA_END_STYLE obsolete);



HRESULT STDMETHODCALLTYPE IDADrawingSurface_BorderJoinStyle_Proxy( 
    IDADrawingSurface * This,
    /* [in] */ DA_JOIN_STYLE id);



HRESULT STDMETHODCALLTYPE IDADrawingSurface_Font_Proxy( 
    IDADrawingSurface * This,
    /* [in] */ BSTR FontFace,
    /* [in] */ LONG sizeInPoints,
    /* [in] */ VARIANT_BOOL Bold,
    /* [in] */ VARIANT_BOOL italic,
    /* [in] */ VARIANT_BOOL underline,
    /* [in] */ VARIANT_BOOL strikethrough);



HRESULT STDMETHODCALLTYPE IDADrawingSurface_TextureFill_Proxy( 
    IDADrawingSurface * This,
    /* [in] */ IDAImage *obsolete1,
    /* [in] */ double obsolete2,
    /* [in] */ double obsolete3);



HRESULT STDMETHODCALLTYPE IDADrawingSurface_ImageFill_Proxy( 
    IDADrawingSurface * This,
    /* [in] */ IDAImage *obsolete1,
    /* [in] */ double obsolete2,
    /* [in] */ double obsolete3);



HRESULT STDMETHODCALLTYPE IDADrawingSurface_FillTexture_Proxy( 
    IDADrawingSurface * This,
    /* [in] */ IDAImage *img);



HRESULT STDMETHODCALLTYPE IDADrawingSurface_FillImage_Proxy( 
    IDADrawingSurface * This,
    /* [in] */ IDAImage *img);



HRESULT STDMETHODCALLTYPE IDADrawingSurface_FillStyle_Proxy( 
    IDADrawingSurface * This,
    /* [in] */ int ID);



HRESULT STDMETHODCALLTYPE IDADrawingSurface_FillColor_Proxy( 
    IDADrawingSurface * This,
    /* [in] */ IDAColor *foreground);



HRESULT STDMETHODCALLTYPE IDADrawingSurface_SecondaryFillColor_Proxy( 
    IDADrawingSurface * This,
    /* [in] */ IDAColor *val);



HRESULT STDMETHODCALLTYPE IDADrawingSurface_GradientShape_Proxy( 
    IDADrawingSurface * This,
    /* [in] */ VARIANT pts);



HRESULT STDMETHODCALLTYPE IDADrawingSurface_GradientExtent_Proxy( 
    IDADrawingSurface * This,
    /* [in] */ double startx,
    /* [in] */ double starty,
    /* [in] */ double finishx,
    /* [in] */ double finishy);



HRESULT STDMETHODCALLTYPE IDADrawingSurface_GradientExtentPoints_Proxy( 
    IDADrawingSurface * This,
    /* [in] */ IDAPoint2 *startColor,
    /* [in] */ IDAPoint2 *stopColor);



HRESULT STDMETHODCALLTYPE IDADrawingSurface_GradientRolloffPower_Proxy( 
    IDADrawingSurface * This,
    /* [in] */ double power);



HRESULT STDMETHODCALLTYPE IDADrawingSurface_GradientRolloffPowerAnim_Proxy( 
    IDADrawingSurface * This,
    /* [in] */ IDANumber *power);



HRESULT STDMETHODCALLTYPE IDADrawingSurface_FixedFillScale_Proxy( 
    IDADrawingSurface * This);



HRESULT STDMETHODCALLTYPE IDADrawingSurface_HorizontalFillScale_Proxy( 
    IDADrawingSurface * This);



HRESULT STDMETHODCALLTYPE IDADrawingSurface_VerticalFillScale_Proxy( 
    IDADrawingSurface * This);



HRESULT STDMETHODCALLTYPE IDADrawingSurface_AutoSizeFillScale_Proxy( 
    IDADrawingSurface * This);



HRESULT STDMETHODCALLTYPE IDADrawingSurface_PolylineEx_Proxy( 
    IDADrawingSurface * This,
    /* [in] */ LONG numPts,
    /* [size_is][in] */ IDAPoint2 *pts[  ]);



HRESULT STDMETHODCALLTYPE IDADrawingSurface_Polyline_Proxy( 
    IDADrawingSurface * This,
    /* [in] */ VARIANT v);



HRESULT STDMETHODCALLTYPE IDADrawingSurface_PolygonEx_Proxy( 
    IDADrawingSurface * This,
    /* [in] */ LONG numPts,
    /* [size_is][in] */ IDAPoint2 *pts[  ]);



HRESULT STDMETHODCALLTYPE IDADrawingSurface_Polygon_Proxy( 
    IDADrawingSurface * This,
    /* [in] */ VARIANT v);



HRESULT STDMETHODCALLTYPE IDADrawingSurface_LinePoints_Proxy( 
    IDADrawingSurface * This,
    /* [in] */ IDAPoint2 *p1,
    /* [in] */ IDAPoint2 *p2);



HRESULT STDMETHODCALLTYPE IDADrawingSurface_Line_Proxy( 
    IDADrawingSurface * This,
    /* [in] */ double startX,
    /* [in] */ double startY,
    /* [in] */ double endX,
    /* [in] */ double endY);



HRESULT STDMETHODCALLTYPE IDADrawingSurface_ArcRadians_Proxy( 
    IDADrawingSurface * This,
    /* [in] */ double xPos,
    /* [in] */ double yPos,
    /* [in] */ double startAngle,
    /* [in] */ double endAngle,
    /* [in] */ double arcWidth,
    /* [in] */ double arcHeight);



HRESULT STDMETHODCALLTYPE IDADrawingSurface_ArcDegrees_Proxy( 
    IDADrawingSurface * This,
    /* [in] */ double xPos,
    /* [in] */ double yPos,
    /* [in] */ double startAngle,
    /* [in] */ double endAngle,
    /* [in] */ double arcWidth,
    /* [in] */ double arcHeight);



HRESULT STDMETHODCALLTYPE IDADrawingSurface_Oval_Proxy( 
    IDADrawingSurface * This,
    /* [in] */ double xPos,
    /* [in] */ double yPos,
    /* [in] */ double w,
    /* [in] */ double h);



HRESULT STDMETHODCALLTYPE IDADrawingSurface_Rect_Proxy( 
    IDADrawingSurface * This,
    /* [in] */ double xPos,
    /* [in] */ double yPos,
    /* [in] */ double w,
    /* [in] */ double h);



HRESULT STDMETHODCALLTYPE IDADrawingSurface_RoundRect_Proxy( 
    IDADrawingSurface * This,
    /* [in] */ double xPos,
    /* [in] */ double yPos,
    /* [in] */ double w,
    /* [in] */ double h,
    /* [in] */ double arcWidth,
    /* [in] */ double arcHeight);



HRESULT STDMETHODCALLTYPE IDADrawingSurface_PieRadians_Proxy( 
    IDADrawingSurface * This,
    /* [in] */ double xPos,
    /* [in] */ double yPos,
    /* [in] */ double startAngle,
    /* [in] */ double endAngle,
    /* [in] */ double arcWidth,
    /* [in] */ double arcHeight);



HRESULT STDMETHODCALLTYPE IDADrawingSurface_PieDegrees_Proxy( 
    IDADrawingSurface * This,
    /* [in] */ double xPos,
    /* [in] */ double yPos,
    /* [in] */ double startAngle,
    /* [in] */ double endAngle,
    /* [in] */ double arcWidth,
    /* [in] */ double arcHeight);



HRESULT STDMETHODCALLTYPE IDADrawingSurface_Text_Proxy( 
    IDADrawingSurface * This,
    /* [in] */ BSTR str,
    /* [in] */ double xPos,
    /* [in] */ double yPos);



HRESULT STDMETHODCALLTYPE IDADrawingSurface_TextPoint_Proxy( 
    IDADrawingSurface * This,
    /* [in] */ BSTR str,
    /* [in] */ IDAPoint2 *point);



HRESULT STDMETHODCALLTYPE IDADrawingSurface_FillPath_Proxy( 
    IDADrawingSurface * This,
    /* [in] */ IDAPath2 *path);



HRESULT STDMETHODCALLTYPE IDADrawingSurface_DrawPath_Proxy( 
    IDADrawingSurface * This,
    /* [in] */ IDAPath2 *path);



HRESULT STDMETHODCALLTYPE IDADrawingSurface_OverlayImage_Proxy( 
    IDADrawingSurface * This,
    /* [in] */ IDAImage *img);




#endif 	/* __IDADrawingSurface_INTERFACE_DEFINED__ */


#ifndef __IDAPickableResult_INTERFACE_DEFINED__
#define __IDAPickableResult_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDAPickableResult
 * at Tue Nov 11 05:16:35 1997
 * using MIDL 3.02.88
 ****************************************/
/* [dual][oleautomation][unique][object][local][helpstring][uuid] */ 



EXTERN_C const IID IID_IDAPickableResult;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("4A933703-E36F-11d0-9B99-00C04FC2F51D")
    IDAPickableResult : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Image( 
            /* [retval][out] */ IDAImage **ppImage) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Geometry( 
            /* [retval][out] */ IDAGeometry **ppGeometry) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_PickEvent( 
            /* [retval][out] */ IDAEvent **ppPickEvent) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDAPickableResultVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDAPickableResult * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDAPickableResult * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDAPickableResult * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDAPickableResult * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDAPickableResult * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDAPickableResult * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDAPickableResult * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Image )( 
            IDAPickableResult * This,
            /* [retval][out] */ IDAImage **ppImage);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Geometry )( 
            IDAPickableResult * This,
            /* [retval][out] */ IDAGeometry **ppGeometry);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PickEvent )( 
            IDAPickableResult * This,
            /* [retval][out] */ IDAEvent **ppPickEvent);
        
        END_INTERFACE
    } IDAPickableResultVtbl;

    interface IDAPickableResult
    {
        CONST_VTBL struct IDAPickableResultVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDAPickableResult_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDAPickableResult_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDAPickableResult_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDAPickableResult_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDAPickableResult_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDAPickableResult_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDAPickableResult_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDAPickableResult_get_Image(This,ppImage)	\
    (This)->lpVtbl -> get_Image(This,ppImage)

#define IDAPickableResult_get_Geometry(This,ppGeometry)	\
    (This)->lpVtbl -> get_Geometry(This,ppGeometry)

#define IDAPickableResult_get_PickEvent(This,ppPickEvent)	\
    (This)->lpVtbl -> get_PickEvent(This,ppPickEvent)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDAPickableResult_get_Image_Proxy( 
    IDAPickableResult * This,
    /* [retval][out] */ IDAImage **ppImage);



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDAPickableResult_get_Geometry_Proxy( 
    IDAPickableResult * This,
    /* [retval][out] */ IDAGeometry **ppGeometry);



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDAPickableResult_get_PickEvent_Proxy( 
    IDAPickableResult * This,
    /* [retval][out] */ IDAEvent **ppPickEvent);




#endif 	/* __IDAPickableResult_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_DABehavior;

#ifdef __cplusplus

class DECLSPEC_UUID("283807B8-2C60-11d0-A31D-00AA00B92C03")
DABehavior;
#endif

#ifndef __IDAUntilNotifier_INTERFACE_DEFINED__
#define __IDAUntilNotifier_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDAUntilNotifier
 * at Tue Nov 11 05:16:35 1997
 * using MIDL 3.02.88
 ****************************************/
/* [dual][oleautomation][unique][object][local][helpstring][uuid] */ 



EXTERN_C const IID IID_IDAUntilNotifier;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("3F3DA01A-4705-11d0-8710-00C04FC29D46")
    IDAUntilNotifier : public IDispatch
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Notify( 
            /* [in] */ IDABehavior *eventData,
            /* [in] */ IDABehavior *curRunningBvr,
            /* [in] */ IDAView *curView,
            /* [retval][out] */ IDABehavior **ppBvr) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDAUntilNotifierVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDAUntilNotifier * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDAUntilNotifier * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDAUntilNotifier * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDAUntilNotifier * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDAUntilNotifier * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDAUntilNotifier * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDAUntilNotifier * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *Notify )( 
            IDAUntilNotifier * This,
            /* [in] */ IDABehavior *eventData,
            /* [in] */ IDABehavior *curRunningBvr,
            /* [in] */ IDAView *curView,
            /* [retval][out] */ IDABehavior **ppBvr);
        
        END_INTERFACE
    } IDAUntilNotifierVtbl;

    interface IDAUntilNotifier
    {
        CONST_VTBL struct IDAUntilNotifierVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDAUntilNotifier_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDAUntilNotifier_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDAUntilNotifier_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDAUntilNotifier_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDAUntilNotifier_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDAUntilNotifier_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDAUntilNotifier_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDAUntilNotifier_Notify(This,eventData,curRunningBvr,curView,ppBvr)	\
    (This)->lpVtbl -> Notify(This,eventData,curRunningBvr,curView,ppBvr)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDAUntilNotifier_Notify_Proxy( 
    IDAUntilNotifier * This,
    /* [in] */ IDABehavior *eventData,
    /* [in] */ IDABehavior *curRunningBvr,
    /* [in] */ IDAView *curView,
    /* [retval][out] */ IDABehavior **ppBvr);




#endif 	/* __IDAUntilNotifier_INTERFACE_DEFINED__ */


#ifndef __IDABoolean_INTERFACE_DEFINED__
#define __IDABoolean_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDABoolean
 * at Tue Nov 11 05:16:35 1997
 * using MIDL 3.02.88
 ****************************************/
/* [dual][hidden][oleautomation][unique][object][local][helpstring][uuid] */ 



EXTERN_C const IID IID_IDABoolean;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("C46C1BC0-3C52-11d0-9200-848C1D000000")
    IDABoolean : public IDABehavior
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Extract( 
            /* [retval][out] */ VARIANT_BOOL *ret_0) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDABooleanVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDABoolean * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDABoolean * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDABoolean * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDABoolean * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDABoolean * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDABoolean * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDABoolean * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassName )( 
            IDABoolean * This,
            /* [retval][out] */ BSTR *pClassName);
        
        HRESULT ( STDMETHODCALLTYPE *Init )( 
            IDABoolean * This,
            /* [in] */ IDABehavior *toBvr);
        
        HRESULT ( STDMETHODCALLTYPE *Importance )( 
            IDABoolean * This,
            /* [in] */ double relativeImportance,
            /* [retval][out] */ IDABehavior **ppBvr);
        
        HRESULT ( STDMETHODCALLTYPE *RunOnce )( 
            IDABoolean * This,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *SubstituteTime )( 
            IDABoolean * This,
            /* [in] */ IDANumber *xform,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *SwitchTo )( 
            IDABoolean * This,
            /* [in] */ IDABehavior *switchTo);
        
        HRESULT ( STDMETHODCALLTYPE *SwitchToNumber )( 
            IDABoolean * This,
            /* [in] */ double numToSwitchTo);
        
        HRESULT ( STDMETHODCALLTYPE *SwitchToString )( 
            IDABoolean * This,
            /* [in] */ BSTR strToSwitchTo);
        
        HRESULT ( STDMETHODCALLTYPE *Hook )( 
            IDABoolean * This,
            /* [in] */ IDABvrHook *notifier,
            /* [retval][out] */ IDABehavior **pBvr);
        
        HRESULT ( STDMETHODCALLTYPE *Duration )( 
            IDABoolean * This,
            /* [in] */ double duration,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *DurationAnim )( 
            IDABoolean * This,
            /* [in] */ IDANumber *duration,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *Repeat )( 
            IDABoolean * This,
            /* [in] */ LONG count,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *RepeatForever )( 
            IDABoolean * This,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *IsReady )( 
            IDABoolean * This,
            /* [in] */ VARIANT_BOOL bBlock,
            /* [retval][out] */ VARIANT_BOOL *b);
        
        HRESULT ( STDMETHODCALLTYPE *Extract )( 
            IDABoolean * This,
            /* [retval][out] */ VARIANT_BOOL *ret_0);
        
        END_INTERFACE
    } IDABooleanVtbl;

    interface IDABoolean
    {
        CONST_VTBL struct IDABooleanVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDABoolean_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDABoolean_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDABoolean_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDABoolean_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDABoolean_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDABoolean_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDABoolean_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDABoolean_GetClassName(This,pClassName)	\
    (This)->lpVtbl -> GetClassName(This,pClassName)

#define IDABoolean_Init(This,toBvr)	\
    (This)->lpVtbl -> Init(This,toBvr)

#define IDABoolean_Importance(This,relativeImportance,ppBvr)	\
    (This)->lpVtbl -> Importance(This,relativeImportance,ppBvr)

#define IDABoolean_RunOnce(This,bvr)	\
    (This)->lpVtbl -> RunOnce(This,bvr)

#define IDABoolean_SubstituteTime(This,xform,bvr)	\
    (This)->lpVtbl -> SubstituteTime(This,xform,bvr)

#define IDABoolean_SwitchTo(This,switchTo)	\
    (This)->lpVtbl -> SwitchTo(This,switchTo)

#define IDABoolean_SwitchToNumber(This,numToSwitchTo)	\
    (This)->lpVtbl -> SwitchToNumber(This,numToSwitchTo)

#define IDABoolean_SwitchToString(This,strToSwitchTo)	\
    (This)->lpVtbl -> SwitchToString(This,strToSwitchTo)

#define IDABoolean_Hook(This,notifier,pBvr)	\
    (This)->lpVtbl -> Hook(This,notifier,pBvr)

#define IDABoolean_Duration(This,duration,bvr)	\
    (This)->lpVtbl -> Duration(This,duration,bvr)

#define IDABoolean_DurationAnim(This,duration,bvr)	\
    (This)->lpVtbl -> DurationAnim(This,duration,bvr)

#define IDABoolean_Repeat(This,count,bvr)	\
    (This)->lpVtbl -> Repeat(This,count,bvr)

#define IDABoolean_RepeatForever(This,bvr)	\
    (This)->lpVtbl -> RepeatForever(This,bvr)

#define IDABoolean_IsReady(This,bBlock,b)	\
    (This)->lpVtbl -> IsReady(This,bBlock,b)


#define IDABoolean_Extract(This,ret_0)	\
    (This)->lpVtbl -> Extract(This,ret_0)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDABoolean_Extract_Proxy( 
    IDABoolean * This,
    /* [retval][out] */ VARIANT_BOOL *ret_0);




#endif 	/* __IDABoolean_INTERFACE_DEFINED__ */


#ifndef __IDACamera_INTERFACE_DEFINED__
#define __IDACamera_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDACamera
 * at Tue Nov 11 05:16:35 1997
 * using MIDL 3.02.88
 ****************************************/
/* [dual][hidden][oleautomation][unique][object][local][helpstring][uuid] */ 



EXTERN_C const IID IID_IDACamera;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("C46C1BE1-3C52-11d0-9200-848C1D000000")
    IDACamera : public IDABehavior
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Transform( 
            /* [in] */ IDATransform3 *xf_0,
            /* [retval][out] */ IDACamera **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Depth( 
            /* [in] */ double depth_0,
            /* [retval][out] */ IDACamera **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DepthAnim( 
            /* [in] */ IDANumber *depth_0,
            /* [retval][out] */ IDACamera **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DepthResolution( 
            /* [in] */ double resolution_0,
            /* [retval][out] */ IDACamera **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DepthResolutionAnim( 
            /* [in] */ IDANumber *resolution_0,
            /* [retval][out] */ IDACamera **ret_1) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDACameraVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDACamera * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDACamera * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDACamera * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDACamera * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDACamera * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDACamera * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDACamera * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassName )( 
            IDACamera * This,
            /* [retval][out] */ BSTR *pClassName);
        
        HRESULT ( STDMETHODCALLTYPE *Init )( 
            IDACamera * This,
            /* [in] */ IDABehavior *toBvr);
        
        HRESULT ( STDMETHODCALLTYPE *Importance )( 
            IDACamera * This,
            /* [in] */ double relativeImportance,
            /* [retval][out] */ IDABehavior **ppBvr);
        
        HRESULT ( STDMETHODCALLTYPE *RunOnce )( 
            IDACamera * This,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *SubstituteTime )( 
            IDACamera * This,
            /* [in] */ IDANumber *xform,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *SwitchTo )( 
            IDACamera * This,
            /* [in] */ IDABehavior *switchTo);
        
        HRESULT ( STDMETHODCALLTYPE *SwitchToNumber )( 
            IDACamera * This,
            /* [in] */ double numToSwitchTo);
        
        HRESULT ( STDMETHODCALLTYPE *SwitchToString )( 
            IDACamera * This,
            /* [in] */ BSTR strToSwitchTo);
        
        HRESULT ( STDMETHODCALLTYPE *Hook )( 
            IDACamera * This,
            /* [in] */ IDABvrHook *notifier,
            /* [retval][out] */ IDABehavior **pBvr);
        
        HRESULT ( STDMETHODCALLTYPE *Duration )( 
            IDACamera * This,
            /* [in] */ double duration,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *DurationAnim )( 
            IDACamera * This,
            /* [in] */ IDANumber *duration,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *Repeat )( 
            IDACamera * This,
            /* [in] */ LONG count,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *RepeatForever )( 
            IDACamera * This,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *IsReady )( 
            IDACamera * This,
            /* [in] */ VARIANT_BOOL bBlock,
            /* [retval][out] */ VARIANT_BOOL *b);
        
        HRESULT ( STDMETHODCALLTYPE *Transform )( 
            IDACamera * This,
            /* [in] */ IDATransform3 *xf_0,
            /* [retval][out] */ IDACamera **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *Depth )( 
            IDACamera * This,
            /* [in] */ double depth_0,
            /* [retval][out] */ IDACamera **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *DepthAnim )( 
            IDACamera * This,
            /* [in] */ IDANumber *depth_0,
            /* [retval][out] */ IDACamera **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *DepthResolution )( 
            IDACamera * This,
            /* [in] */ double resolution_0,
            /* [retval][out] */ IDACamera **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *DepthResolutionAnim )( 
            IDACamera * This,
            /* [in] */ IDANumber *resolution_0,
            /* [retval][out] */ IDACamera **ret_1);
        
        END_INTERFACE
    } IDACameraVtbl;

    interface IDACamera
    {
        CONST_VTBL struct IDACameraVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDACamera_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDACamera_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDACamera_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDACamera_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDACamera_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDACamera_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDACamera_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDACamera_GetClassName(This,pClassName)	\
    (This)->lpVtbl -> GetClassName(This,pClassName)

#define IDACamera_Init(This,toBvr)	\
    (This)->lpVtbl -> Init(This,toBvr)

#define IDACamera_Importance(This,relativeImportance,ppBvr)	\
    (This)->lpVtbl -> Importance(This,relativeImportance,ppBvr)

#define IDACamera_RunOnce(This,bvr)	\
    (This)->lpVtbl -> RunOnce(This,bvr)

#define IDACamera_SubstituteTime(This,xform,bvr)	\
    (This)->lpVtbl -> SubstituteTime(This,xform,bvr)

#define IDACamera_SwitchTo(This,switchTo)	\
    (This)->lpVtbl -> SwitchTo(This,switchTo)

#define IDACamera_SwitchToNumber(This,numToSwitchTo)	\
    (This)->lpVtbl -> SwitchToNumber(This,numToSwitchTo)

#define IDACamera_SwitchToString(This,strToSwitchTo)	\
    (This)->lpVtbl -> SwitchToString(This,strToSwitchTo)

#define IDACamera_Hook(This,notifier,pBvr)	\
    (This)->lpVtbl -> Hook(This,notifier,pBvr)

#define IDACamera_Duration(This,duration,bvr)	\
    (This)->lpVtbl -> Duration(This,duration,bvr)

#define IDACamera_DurationAnim(This,duration,bvr)	\
    (This)->lpVtbl -> DurationAnim(This,duration,bvr)

#define IDACamera_Repeat(This,count,bvr)	\
    (This)->lpVtbl -> Repeat(This,count,bvr)

#define IDACamera_RepeatForever(This,bvr)	\
    (This)->lpVtbl -> RepeatForever(This,bvr)

#define IDACamera_IsReady(This,bBlock,b)	\
    (This)->lpVtbl -> IsReady(This,bBlock,b)


#define IDACamera_Transform(This,xf_0,ret_1)	\
    (This)->lpVtbl -> Transform(This,xf_0,ret_1)

#define IDACamera_Depth(This,depth_0,ret_1)	\
    (This)->lpVtbl -> Depth(This,depth_0,ret_1)

#define IDACamera_DepthAnim(This,depth_0,ret_1)	\
    (This)->lpVtbl -> DepthAnim(This,depth_0,ret_1)

#define IDACamera_DepthResolution(This,resolution_0,ret_1)	\
    (This)->lpVtbl -> DepthResolution(This,resolution_0,ret_1)

#define IDACamera_DepthResolutionAnim(This,resolution_0,ret_1)	\
    (This)->lpVtbl -> DepthResolutionAnim(This,resolution_0,ret_1)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDACamera_Transform_Proxy( 
    IDACamera * This,
    /* [in] */ IDATransform3 *xf_0,
    /* [retval][out] */ IDACamera **ret_1);



HRESULT STDMETHODCALLTYPE IDACamera_Depth_Proxy( 
    IDACamera * This,
    /* [in] */ double depth_0,
    /* [retval][out] */ IDACamera **ret_1);



HRESULT STDMETHODCALLTYPE IDACamera_DepthAnim_Proxy( 
    IDACamera * This,
    /* [in] */ IDANumber *depth_0,
    /* [retval][out] */ IDACamera **ret_1);



HRESULT STDMETHODCALLTYPE IDACamera_DepthResolution_Proxy( 
    IDACamera * This,
    /* [in] */ double resolution_0,
    /* [retval][out] */ IDACamera **ret_1);



HRESULT STDMETHODCALLTYPE IDACamera_DepthResolutionAnim_Proxy( 
    IDACamera * This,
    /* [in] */ IDANumber *resolution_0,
    /* [retval][out] */ IDACamera **ret_1);




#endif 	/* __IDACamera_INTERFACE_DEFINED__ */


#ifndef __IDAColor_INTERFACE_DEFINED__
#define __IDAColor_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDAColor
 * at Tue Nov 11 05:16:35 1997
 * using MIDL 3.02.88
 ****************************************/
/* [dual][hidden][oleautomation][unique][object][local][helpstring][uuid] */ 



EXTERN_C const IID IID_IDAColor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("C46C1BC5-3C52-11d0-9200-848C1D000000")
    IDAColor : public IDABehavior
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Red( 
            /* [retval][out] */ IDANumber **ret_0) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Green( 
            /* [retval][out] */ IDANumber **ret_0) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Blue( 
            /* [retval][out] */ IDANumber **ret_0) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Hue( 
            /* [retval][out] */ IDANumber **ret_0) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Saturation( 
            /* [retval][out] */ IDANumber **ret_0) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Lightness( 
            /* [retval][out] */ IDANumber **ret_0) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDAColorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDAColor * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDAColor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDAColor * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDAColor * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDAColor * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDAColor * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDAColor * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassName )( 
            IDAColor * This,
            /* [retval][out] */ BSTR *pClassName);
        
        HRESULT ( STDMETHODCALLTYPE *Init )( 
            IDAColor * This,
            /* [in] */ IDABehavior *toBvr);
        
        HRESULT ( STDMETHODCALLTYPE *Importance )( 
            IDAColor * This,
            /* [in] */ double relativeImportance,
            /* [retval][out] */ IDABehavior **ppBvr);
        
        HRESULT ( STDMETHODCALLTYPE *RunOnce )( 
            IDAColor * This,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *SubstituteTime )( 
            IDAColor * This,
            /* [in] */ IDANumber *xform,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *SwitchTo )( 
            IDAColor * This,
            /* [in] */ IDABehavior *switchTo);
        
        HRESULT ( STDMETHODCALLTYPE *SwitchToNumber )( 
            IDAColor * This,
            /* [in] */ double numToSwitchTo);
        
        HRESULT ( STDMETHODCALLTYPE *SwitchToString )( 
            IDAColor * This,
            /* [in] */ BSTR strToSwitchTo);
        
        HRESULT ( STDMETHODCALLTYPE *Hook )( 
            IDAColor * This,
            /* [in] */ IDABvrHook *notifier,
            /* [retval][out] */ IDABehavior **pBvr);
        
        HRESULT ( STDMETHODCALLTYPE *Duration )( 
            IDAColor * This,
            /* [in] */ double duration,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *DurationAnim )( 
            IDAColor * This,
            /* [in] */ IDANumber *duration,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *Repeat )( 
            IDAColor * This,
            /* [in] */ LONG count,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *RepeatForever )( 
            IDAColor * This,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *IsReady )( 
            IDAColor * This,
            /* [in] */ VARIANT_BOOL bBlock,
            /* [retval][out] */ VARIANT_BOOL *b);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Red )( 
            IDAColor * This,
            /* [retval][out] */ IDANumber **ret_0);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Green )( 
            IDAColor * This,
            /* [retval][out] */ IDANumber **ret_0);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Blue )( 
            IDAColor * This,
            /* [retval][out] */ IDANumber **ret_0);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Hue )( 
            IDAColor * This,
            /* [retval][out] */ IDANumber **ret_0);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Saturation )( 
            IDAColor * This,
            /* [retval][out] */ IDANumber **ret_0);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Lightness )( 
            IDAColor * This,
            /* [retval][out] */ IDANumber **ret_0);
        
        END_INTERFACE
    } IDAColorVtbl;

    interface IDAColor
    {
        CONST_VTBL struct IDAColorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDAColor_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDAColor_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDAColor_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDAColor_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDAColor_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDAColor_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDAColor_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDAColor_GetClassName(This,pClassName)	\
    (This)->lpVtbl -> GetClassName(This,pClassName)

#define IDAColor_Init(This,toBvr)	\
    (This)->lpVtbl -> Init(This,toBvr)

#define IDAColor_Importance(This,relativeImportance,ppBvr)	\
    (This)->lpVtbl -> Importance(This,relativeImportance,ppBvr)

#define IDAColor_RunOnce(This,bvr)	\
    (This)->lpVtbl -> RunOnce(This,bvr)

#define IDAColor_SubstituteTime(This,xform,bvr)	\
    (This)->lpVtbl -> SubstituteTime(This,xform,bvr)

#define IDAColor_SwitchTo(This,switchTo)	\
    (This)->lpVtbl -> SwitchTo(This,switchTo)

#define IDAColor_SwitchToNumber(This,numToSwitchTo)	\
    (This)->lpVtbl -> SwitchToNumber(This,numToSwitchTo)

#define IDAColor_SwitchToString(This,strToSwitchTo)	\
    (This)->lpVtbl -> SwitchToString(This,strToSwitchTo)

#define IDAColor_Hook(This,notifier,pBvr)	\
    (This)->lpVtbl -> Hook(This,notifier,pBvr)

#define IDAColor_Duration(This,duration,bvr)	\
    (This)->lpVtbl -> Duration(This,duration,bvr)

#define IDAColor_DurationAnim(This,duration,bvr)	\
    (This)->lpVtbl -> DurationAnim(This,duration,bvr)

#define IDAColor_Repeat(This,count,bvr)	\
    (This)->lpVtbl -> Repeat(This,count,bvr)

#define IDAColor_RepeatForever(This,bvr)	\
    (This)->lpVtbl -> RepeatForever(This,bvr)

#define IDAColor_IsReady(This,bBlock,b)	\
    (This)->lpVtbl -> IsReady(This,bBlock,b)


#define IDAColor_get_Red(This,ret_0)	\
    (This)->lpVtbl -> get_Red(This,ret_0)

#define IDAColor_get_Green(This,ret_0)	\
    (This)->lpVtbl -> get_Green(This,ret_0)

#define IDAColor_get_Blue(This,ret_0)	\
    (This)->lpVtbl -> get_Blue(This,ret_0)

#define IDAColor_get_Hue(This,ret_0)	\
    (This)->lpVtbl -> get_Hue(This,ret_0)

#define IDAColor_get_Saturation(This,ret_0)	\
    (This)->lpVtbl -> get_Saturation(This,ret_0)

#define IDAColor_get_Lightness(This,ret_0)	\
    (This)->lpVtbl -> get_Lightness(This,ret_0)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget] */ HRESULT STDMETHODCALLTYPE IDAColor_get_Red_Proxy( 
    IDAColor * This,
    /* [retval][out] */ IDANumber **ret_0);



/* [propget] */ HRESULT STDMETHODCALLTYPE IDAColor_get_Green_Proxy( 
    IDAColor * This,
    /* [retval][out] */ IDANumber **ret_0);



/* [propget] */ HRESULT STDMETHODCALLTYPE IDAColor_get_Blue_Proxy( 
    IDAColor * This,
    /* [retval][out] */ IDANumber **ret_0);



/* [propget] */ HRESULT STDMETHODCALLTYPE IDAColor_get_Hue_Proxy( 
    IDAColor * This,
    /* [retval][out] */ IDANumber **ret_0);



/* [propget] */ HRESULT STDMETHODCALLTYPE IDAColor_get_Saturation_Proxy( 
    IDAColor * This,
    /* [retval][out] */ IDANumber **ret_0);



/* [propget] */ HRESULT STDMETHODCALLTYPE IDAColor_get_Lightness_Proxy( 
    IDAColor * This,
    /* [retval][out] */ IDANumber **ret_0);




#endif 	/* __IDAColor_INTERFACE_DEFINED__ */


#ifndef __IDAGeometry_INTERFACE_DEFINED__
#define __IDAGeometry_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDAGeometry
 * at Tue Nov 11 05:16:35 1997
 * using MIDL 3.02.88
 ****************************************/
/* [dual][hidden][oleautomation][unique][object][local][helpstring][uuid] */ 



EXTERN_C const IID IID_IDAGeometry;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("C46C1BDF-3C52-11d0-9200-848C1D000000")
    IDAGeometry : public IDABehavior
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RenderSound( 
            /* [in] */ IDAMicrophone *mic_0,
            /* [retval][out] */ IDASound **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Pickable( 
            /* [retval][out] */ IDAPickableResult **ret_0) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PickableOccluded( 
            /* [retval][out] */ IDAPickableResult **ret_0) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Undetectable( 
            /* [retval][out] */ IDAGeometry **ret_0) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EmissiveColor( 
            /* [in] */ IDAColor *col_0,
            /* [retval][out] */ IDAGeometry **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DiffuseColor( 
            /* [in] */ IDAColor *col_0,
            /* [retval][out] */ IDAGeometry **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SpecularColor( 
            /* [in] */ IDAColor *col_0,
            /* [retval][out] */ IDAGeometry **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SpecularExponent( 
            /* [in] */ double power_0,
            /* [retval][out] */ IDAGeometry **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SpecularExponentAnim( 
            /* [in] */ IDANumber *power_0,
            /* [retval][out] */ IDAGeometry **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Texture( 
            /* [in] */ IDAImage *texture_0,
            /* [retval][out] */ IDAGeometry **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Opacity( 
            /* [in] */ double level_0,
            /* [retval][out] */ IDAGeometry **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OpacityAnim( 
            /* [in] */ IDANumber *level_0,
            /* [retval][out] */ IDAGeometry **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Transform( 
            /* [in] */ IDATransform3 *xf_0,
            /* [retval][out] */ IDAGeometry **ret_1) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_BoundingBox( 
            /* [retval][out] */ IDABbox3 **ret_0) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Render( 
            /* [in] */ IDACamera *cam_0,
            /* [retval][out] */ IDAImage **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LightColor( 
            /* [in] */ IDAColor *color_0,
            /* [retval][out] */ IDAGeometry **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LightAttenuationAnim( 
            /* [in] */ IDANumber *constant_0,
            /* [in] */ IDANumber *linear_1,
            /* [in] */ IDANumber *quadratic_2,
            /* [retval][out] */ IDAGeometry **ret_3) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LightAttenuation( 
            /* [in] */ double constant_0,
            /* [in] */ double linear_1,
            /* [in] */ double quadratic_2,
            /* [retval][out] */ IDAGeometry **ret_3) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDAGeometryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDAGeometry * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDAGeometry * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDAGeometry * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDAGeometry * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDAGeometry * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDAGeometry * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDAGeometry * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassName )( 
            IDAGeometry * This,
            /* [retval][out] */ BSTR *pClassName);
        
        HRESULT ( STDMETHODCALLTYPE *Init )( 
            IDAGeometry * This,
            /* [in] */ IDABehavior *toBvr);
        
        HRESULT ( STDMETHODCALLTYPE *Importance )( 
            IDAGeometry * This,
            /* [in] */ double relativeImportance,
            /* [retval][out] */ IDABehavior **ppBvr);
        
        HRESULT ( STDMETHODCALLTYPE *RunOnce )( 
            IDAGeometry * This,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *SubstituteTime )( 
            IDAGeometry * This,
            /* [in] */ IDANumber *xform,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *SwitchTo )( 
            IDAGeometry * This,
            /* [in] */ IDABehavior *switchTo);
        
        HRESULT ( STDMETHODCALLTYPE *SwitchToNumber )( 
            IDAGeometry * This,
            /* [in] */ double numToSwitchTo);
        
        HRESULT ( STDMETHODCALLTYPE *SwitchToString )( 
            IDAGeometry * This,
            /* [in] */ BSTR strToSwitchTo);
        
        HRESULT ( STDMETHODCALLTYPE *Hook )( 
            IDAGeometry * This,
            /* [in] */ IDABvrHook *notifier,
            /* [retval][out] */ IDABehavior **pBvr);
        
        HRESULT ( STDMETHODCALLTYPE *Duration )( 
            IDAGeometry * This,
            /* [in] */ double duration,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *DurationAnim )( 
            IDAGeometry * This,
            /* [in] */ IDANumber *duration,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *Repeat )( 
            IDAGeometry * This,
            /* [in] */ LONG count,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *RepeatForever )( 
            IDAGeometry * This,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *IsReady )( 
            IDAGeometry * This,
            /* [in] */ VARIANT_BOOL bBlock,
            /* [retval][out] */ VARIANT_BOOL *b);
        
        HRESULT ( STDMETHODCALLTYPE *RenderSound )( 
            IDAGeometry * This,
            /* [in] */ IDAMicrophone *mic_0,
            /* [retval][out] */ IDASound **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *Pickable )( 
            IDAGeometry * This,
            /* [retval][out] */ IDAPickableResult **ret_0);
        
        HRESULT ( STDMETHODCALLTYPE *PickableOccluded )( 
            IDAGeometry * This,
            /* [retval][out] */ IDAPickableResult **ret_0);
        
        HRESULT ( STDMETHODCALLTYPE *Undetectable )( 
            IDAGeometry * This,
            /* [retval][out] */ IDAGeometry **ret_0);
        
        HRESULT ( STDMETHODCALLTYPE *EmissiveColor )( 
            IDAGeometry * This,
            /* [in] */ IDAColor *col_0,
            /* [retval][out] */ IDAGeometry **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *DiffuseColor )( 
            IDAGeometry * This,
            /* [in] */ IDAColor *col_0,
            /* [retval][out] */ IDAGeometry **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *SpecularColor )( 
            IDAGeometry * This,
            /* [in] */ IDAColor *col_0,
            /* [retval][out] */ IDAGeometry **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *SpecularExponent )( 
            IDAGeometry * This,
            /* [in] */ double power_0,
            /* [retval][out] */ IDAGeometry **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *SpecularExponentAnim )( 
            IDAGeometry * This,
            /* [in] */ IDANumber *power_0,
            /* [retval][out] */ IDAGeometry **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *Texture )( 
            IDAGeometry * This,
            /* [in] */ IDAImage *texture_0,
            /* [retval][out] */ IDAGeometry **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *Opacity )( 
            IDAGeometry * This,
            /* [in] */ double level_0,
            /* [retval][out] */ IDAGeometry **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *OpacityAnim )( 
            IDAGeometry * This,
            /* [in] */ IDANumber *level_0,
            /* [retval][out] */ IDAGeometry **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *Transform )( 
            IDAGeometry * This,
            /* [in] */ IDATransform3 *xf_0,
            /* [retval][out] */ IDAGeometry **ret_1);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_BoundingBox )( 
            IDAGeometry * This,
            /* [retval][out] */ IDABbox3 **ret_0);
        
        HRESULT ( STDMETHODCALLTYPE *Render )( 
            IDAGeometry * This,
            /* [in] */ IDACamera *cam_0,
            /* [retval][out] */ IDAImage **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *LightColor )( 
            IDAGeometry * This,
            /* [in] */ IDAColor *color_0,
            /* [retval][out] */ IDAGeometry **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *LightAttenuationAnim )( 
            IDAGeometry * This,
            /* [in] */ IDANumber *constant_0,
            /* [in] */ IDANumber *linear_1,
            /* [in] */ IDANumber *quadratic_2,
            /* [retval][out] */ IDAGeometry **ret_3);
        
        HRESULT ( STDMETHODCALLTYPE *LightAttenuation )( 
            IDAGeometry * This,
            /* [in] */ double constant_0,
            /* [in] */ double linear_1,
            /* [in] */ double quadratic_2,
            /* [retval][out] */ IDAGeometry **ret_3);
        
        END_INTERFACE
    } IDAGeometryVtbl;

    interface IDAGeometry
    {
        CONST_VTBL struct IDAGeometryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDAGeometry_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDAGeometry_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDAGeometry_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDAGeometry_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDAGeometry_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDAGeometry_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDAGeometry_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDAGeometry_GetClassName(This,pClassName)	\
    (This)->lpVtbl -> GetClassName(This,pClassName)

#define IDAGeometry_Init(This,toBvr)	\
    (This)->lpVtbl -> Init(This,toBvr)

#define IDAGeometry_Importance(This,relativeImportance,ppBvr)	\
    (This)->lpVtbl -> Importance(This,relativeImportance,ppBvr)

#define IDAGeometry_RunOnce(This,bvr)	\
    (This)->lpVtbl -> RunOnce(This,bvr)

#define IDAGeometry_SubstituteTime(This,xform,bvr)	\
    (This)->lpVtbl -> SubstituteTime(This,xform,bvr)

#define IDAGeometry_SwitchTo(This,switchTo)	\
    (This)->lpVtbl -> SwitchTo(This,switchTo)

#define IDAGeometry_SwitchToNumber(This,numToSwitchTo)	\
    (This)->lpVtbl -> SwitchToNumber(This,numToSwitchTo)

#define IDAGeometry_SwitchToString(This,strToSwitchTo)	\
    (This)->lpVtbl -> SwitchToString(This,strToSwitchTo)

#define IDAGeometry_Hook(This,notifier,pBvr)	\
    (This)->lpVtbl -> Hook(This,notifier,pBvr)

#define IDAGeometry_Duration(This,duration,bvr)	\
    (This)->lpVtbl -> Duration(This,duration,bvr)

#define IDAGeometry_DurationAnim(This,duration,bvr)	\
    (This)->lpVtbl -> DurationAnim(This,duration,bvr)

#define IDAGeometry_Repeat(This,count,bvr)	\
    (This)->lpVtbl -> Repeat(This,count,bvr)

#define IDAGeometry_RepeatForever(This,bvr)	\
    (This)->lpVtbl -> RepeatForever(This,bvr)

#define IDAGeometry_IsReady(This,bBlock,b)	\
    (This)->lpVtbl -> IsReady(This,bBlock,b)


#define IDAGeometry_RenderSound(This,mic_0,ret_1)	\
    (This)->lpVtbl -> RenderSound(This,mic_0,ret_1)

#define IDAGeometry_Pickable(This,ret_0)	\
    (This)->lpVtbl -> Pickable(This,ret_0)

#define IDAGeometry_PickableOccluded(This,ret_0)	\
    (This)->lpVtbl -> PickableOccluded(This,ret_0)

#define IDAGeometry_Undetectable(This,ret_0)	\
    (This)->lpVtbl -> Undetectable(This,ret_0)

#define IDAGeometry_EmissiveColor(This,col_0,ret_1)	\
    (This)->lpVtbl -> EmissiveColor(This,col_0,ret_1)

#define IDAGeometry_DiffuseColor(This,col_0,ret_1)	\
    (This)->lpVtbl -> DiffuseColor(This,col_0,ret_1)

#define IDAGeometry_SpecularColor(This,col_0,ret_1)	\
    (This)->lpVtbl -> SpecularColor(This,col_0,ret_1)

#define IDAGeometry_SpecularExponent(This,power_0,ret_1)	\
    (This)->lpVtbl -> SpecularExponent(This,power_0,ret_1)

#define IDAGeometry_SpecularExponentAnim(This,power_0,ret_1)	\
    (This)->lpVtbl -> SpecularExponentAnim(This,power_0,ret_1)

#define IDAGeometry_Texture(This,texture_0,ret_1)	\
    (This)->lpVtbl -> Texture(This,texture_0,ret_1)

#define IDAGeometry_Opacity(This,level_0,ret_1)	\
    (This)->lpVtbl -> Opacity(This,level_0,ret_1)

#define IDAGeometry_OpacityAnim(This,level_0,ret_1)	\
    (This)->lpVtbl -> OpacityAnim(This,level_0,ret_1)

#define IDAGeometry_Transform(This,xf_0,ret_1)	\
    (This)->lpVtbl -> Transform(This,xf_0,ret_1)

#define IDAGeometry_get_BoundingBox(This,ret_0)	\
    (This)->lpVtbl -> get_BoundingBox(This,ret_0)

#define IDAGeometry_Render(This,cam_0,ret_1)	\
    (This)->lpVtbl -> Render(This,cam_0,ret_1)

#define IDAGeometry_LightColor(This,color_0,ret_1)	\
    (This)->lpVtbl -> LightColor(This,color_0,ret_1)

#define IDAGeometry_LightAttenuationAnim(This,constant_0,linear_1,quadratic_2,ret_3)	\
    (This)->lpVtbl -> LightAttenuationAnim(This,constant_0,linear_1,quadratic_2,ret_3)

#define IDAGeometry_LightAttenuation(This,constant_0,linear_1,quadratic_2,ret_3)	\
    (This)->lpVtbl -> LightAttenuation(This,constant_0,linear_1,quadratic_2,ret_3)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDAGeometry_RenderSound_Proxy( 
    IDAGeometry * This,
    /* [in] */ IDAMicrophone *mic_0,
    /* [retval][out] */ IDASound **ret_1);



HRESULT STDMETHODCALLTYPE IDAGeometry_Pickable_Proxy( 
    IDAGeometry * This,
    /* [retval][out] */ IDAPickableResult **ret_0);



HRESULT STDMETHODCALLTYPE IDAGeometry_PickableOccluded_Proxy( 
    IDAGeometry * This,
    /* [retval][out] */ IDAPickableResult **ret_0);



HRESULT STDMETHODCALLTYPE IDAGeometry_Undetectable_Proxy( 
    IDAGeometry * This,
    /* [retval][out] */ IDAGeometry **ret_0);



HRESULT STDMETHODCALLTYPE IDAGeometry_EmissiveColor_Proxy( 
    IDAGeometry * This,
    /* [in] */ IDAColor *col_0,
    /* [retval][out] */ IDAGeometry **ret_1);



HRESULT STDMETHODCALLTYPE IDAGeometry_DiffuseColor_Proxy( 
    IDAGeometry * This,
    /* [in] */ IDAColor *col_0,
    /* [retval][out] */ IDAGeometry **ret_1);



HRESULT STDMETHODCALLTYPE IDAGeometry_SpecularColor_Proxy( 
    IDAGeometry * This,
    /* [in] */ IDAColor *col_0,
    /* [retval][out] */ IDAGeometry **ret_1);



HRESULT STDMETHODCALLTYPE IDAGeometry_SpecularExponent_Proxy( 
    IDAGeometry * This,
    /* [in] */ double power_0,
    /* [retval][out] */ IDAGeometry **ret_1);



HRESULT STDMETHODCALLTYPE IDAGeometry_SpecularExponentAnim_Proxy( 
    IDAGeometry * This,
    /* [in] */ IDANumber *power_0,
    /* [retval][out] */ IDAGeometry **ret_1);



HRESULT STDMETHODCALLTYPE IDAGeometry_Texture_Proxy( 
    IDAGeometry * This,
    /* [in] */ IDAImage *texture_0,
    /* [retval][out] */ IDAGeometry **ret_1);



HRESULT STDMETHODCALLTYPE IDAGeometry_Opacity_Proxy( 
    IDAGeometry * This,
    /* [in] */ double level_0,
    /* [retval][out] */ IDAGeometry **ret_1);



HRESULT STDMETHODCALLTYPE IDAGeometry_OpacityAnim_Proxy( 
    IDAGeometry * This,
    /* [in] */ IDANumber *level_0,
    /* [retval][out] */ IDAGeometry **ret_1);



HRESULT STDMETHODCALLTYPE IDAGeometry_Transform_Proxy( 
    IDAGeometry * This,
    /* [in] */ IDATransform3 *xf_0,
    /* [retval][out] */ IDAGeometry **ret_1);



/* [propget] */ HRESULT STDMETHODCALLTYPE IDAGeometry_get_BoundingBox_Proxy( 
    IDAGeometry * This,
    /* [retval][out] */ IDABbox3 **ret_0);



HRESULT STDMETHODCALLTYPE IDAGeometry_Render_Proxy( 
    IDAGeometry * This,
    /* [in] */ IDACamera *cam_0,
    /* [retval][out] */ IDAImage **ret_1);



HRESULT STDMETHODCALLTYPE IDAGeometry_LightColor_Proxy( 
    IDAGeometry * This,
    /* [in] */ IDAColor *color_0,
    /* [retval][out] */ IDAGeometry **ret_1);



HRESULT STDMETHODCALLTYPE IDAGeometry_LightAttenuationAnim_Proxy( 
    IDAGeometry * This,
    /* [in] */ IDANumber *constant_0,
    /* [in] */ IDANumber *linear_1,
    /* [in] */ IDANumber *quadratic_2,
    /* [retval][out] */ IDAGeometry **ret_3);



HRESULT STDMETHODCALLTYPE IDAGeometry_LightAttenuation_Proxy( 
    IDAGeometry * This,
    /* [in] */ double constant_0,
    /* [in] */ double linear_1,
    /* [in] */ double quadratic_2,
    /* [retval][out] */ IDAGeometry **ret_3);




#endif 	/* __IDAGeometry_INTERFACE_DEFINED__ */


#ifndef __IDAImage_INTERFACE_DEFINED__
#define __IDAImage_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDAImage
 * at Tue Nov 11 05:16:35 1997
 * using MIDL 3.02.88
 ****************************************/
/* [dual][hidden][oleautomation][unique][object][local][helpstring][uuid] */ 



EXTERN_C const IID IID_IDAImage;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("C46C1BD3-3C52-11d0-9200-848C1D000000")
    IDAImage : public IDABehavior
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Pickable( 
            /* [retval][out] */ IDAPickableResult **ret_0) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PickableOccluded( 
            /* [retval][out] */ IDAPickableResult **ret_0) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ApplyBitmapEffect( 
            /* [in] */ IUnknown *effectToApply_0,
            /* [in] */ IDAEvent *firesWhenChanged_1,
            /* [retval][out] */ IDAImage **ret_2) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_BoundingBox( 
            /* [retval][out] */ IDABbox2 **ret_0) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Crop( 
            /* [in] */ IDAPoint2 *min_0,
            /* [in] */ IDAPoint2 *max_1,
            /* [retval][out] */ IDAImage **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Transform( 
            /* [in] */ IDATransform2 *xf_0,
            /* [retval][out] */ IDAImage **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OpacityAnim( 
            /* [in] */ IDANumber *opacity_0,
            /* [retval][out] */ IDAImage **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Opacity( 
            /* [in] */ double opacity_0,
            /* [retval][out] */ IDAImage **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Undetectable( 
            /* [retval][out] */ IDAImage **ret_0) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Tile( 
            /* [retval][out] */ IDAImage **ret_0) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clip( 
            /* [in] */ IDAMatte *m_0,
            /* [retval][out] */ IDAImage **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MapToUnitSquare( 
            /* [retval][out] */ IDAImage **ret_0) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ClipPolygonImageEx( 
            /* [in] */ LONG points_0size,
            /* [size_is][in] */ IDAPoint2 *points_0[  ],
            /* [retval][out] */ IDAImage **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ClipPolygonImage( 
            /* [in] */ VARIANT points_0,
            /* [retval][out] */ IDAImage **ret_1) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDAImageVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDAImage * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDAImage * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDAImage * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDAImage * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDAImage * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDAImage * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDAImage * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassName )( 
            IDAImage * This,
            /* [retval][out] */ BSTR *pClassName);
        
        HRESULT ( STDMETHODCALLTYPE *Init )( 
            IDAImage * This,
            /* [in] */ IDABehavior *toBvr);
        
        HRESULT ( STDMETHODCALLTYPE *Importance )( 
            IDAImage * This,
            /* [in] */ double relativeImportance,
            /* [retval][out] */ IDABehavior **ppBvr);
        
        HRESULT ( STDMETHODCALLTYPE *RunOnce )( 
            IDAImage * This,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *SubstituteTime )( 
            IDAImage * This,
            /* [in] */ IDANumber *xform,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *SwitchTo )( 
            IDAImage * This,
            /* [in] */ IDABehavior *switchTo);
        
        HRESULT ( STDMETHODCALLTYPE *SwitchToNumber )( 
            IDAImage * This,
            /* [in] */ double numToSwitchTo);
        
        HRESULT ( STDMETHODCALLTYPE *SwitchToString )( 
            IDAImage * This,
            /* [in] */ BSTR strToSwitchTo);
        
        HRESULT ( STDMETHODCALLTYPE *Hook )( 
            IDAImage * This,
            /* [in] */ IDABvrHook *notifier,
            /* [retval][out] */ IDABehavior **pBvr);
        
        HRESULT ( STDMETHODCALLTYPE *Duration )( 
            IDAImage * This,
            /* [in] */ double duration,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *DurationAnim )( 
            IDAImage * This,
            /* [in] */ IDANumber *duration,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *Repeat )( 
            IDAImage * This,
            /* [in] */ LONG count,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *RepeatForever )( 
            IDAImage * This,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *IsReady )( 
            IDAImage * This,
            /* [in] */ VARIANT_BOOL bBlock,
            /* [retval][out] */ VARIANT_BOOL *b);
        
        HRESULT ( STDMETHODCALLTYPE *Pickable )( 
            IDAImage * This,
            /* [retval][out] */ IDAPickableResult **ret_0);
        
        HRESULT ( STDMETHODCALLTYPE *PickableOccluded )( 
            IDAImage * This,
            /* [retval][out] */ IDAPickableResult **ret_0);
        
        HRESULT ( STDMETHODCALLTYPE *ApplyBitmapEffect )( 
            IDAImage * This,
            /* [in] */ IUnknown *effectToApply_0,
            /* [in] */ IDAEvent *firesWhenChanged_1,
            /* [retval][out] */ IDAImage **ret_2);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_BoundingBox )( 
            IDAImage * This,
            /* [retval][out] */ IDABbox2 **ret_0);
        
        HRESULT ( STDMETHODCALLTYPE *Crop )( 
            IDAImage * This,
            /* [in] */ IDAPoint2 *min_0,
            /* [in] */ IDAPoint2 *max_1,
            /* [retval][out] */ IDAImage **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *Transform )( 
            IDAImage * This,
            /* [in] */ IDATransform2 *xf_0,
            /* [retval][out] */ IDAImage **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *OpacityAnim )( 
            IDAImage * This,
            /* [in] */ IDANumber *opacity_0,
            /* [retval][out] */ IDAImage **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *Opacity )( 
            IDAImage * This,
            /* [in] */ double opacity_0,
            /* [retval][out] */ IDAImage **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *Undetectable )( 
            IDAImage * This,
            /* [retval][out] */ IDAImage **ret_0);
        
        HRESULT ( STDMETHODCALLTYPE *Tile )( 
            IDAImage * This,
            /* [retval][out] */ IDAImage **ret_0);
        
        HRESULT ( STDMETHODCALLTYPE *Clip )( 
            IDAImage * This,
            /* [in] */ IDAMatte *m_0,
            /* [retval][out] */ IDAImage **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *MapToUnitSquare )( 
            IDAImage * This,
            /* [retval][out] */ IDAImage **ret_0);
        
        HRESULT ( STDMETHODCALLTYPE *ClipPolygonImageEx )( 
            IDAImage * This,
            /* [in] */ LONG points_0size,
            /* [size_is][in] */ IDAPoint2 *points_0[  ],
            /* [retval][out] */ IDAImage **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *ClipPolygonImage )( 
            IDAImage * This,
            /* [in] */ VARIANT points_0,
            /* [retval][out] */ IDAImage **ret_1);
        
        END_INTERFACE
    } IDAImageVtbl;

    interface IDAImage
    {
        CONST_VTBL struct IDAImageVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDAImage_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDAImage_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDAImage_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDAImage_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDAImage_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDAImage_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDAImage_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDAImage_GetClassName(This,pClassName)	\
    (This)->lpVtbl -> GetClassName(This,pClassName)

#define IDAImage_Init(This,toBvr)	\
    (This)->lpVtbl -> Init(This,toBvr)

#define IDAImage_Importance(This,relativeImportance,ppBvr)	\
    (This)->lpVtbl -> Importance(This,relativeImportance,ppBvr)

#define IDAImage_RunOnce(This,bvr)	\
    (This)->lpVtbl -> RunOnce(This,bvr)

#define IDAImage_SubstituteTime(This,xform,bvr)	\
    (This)->lpVtbl -> SubstituteTime(This,xform,bvr)

#define IDAImage_SwitchTo(This,switchTo)	\
    (This)->lpVtbl -> SwitchTo(This,switchTo)

#define IDAImage_SwitchToNumber(This,numToSwitchTo)	\
    (This)->lpVtbl -> SwitchToNumber(This,numToSwitchTo)

#define IDAImage_SwitchToString(This,strToSwitchTo)	\
    (This)->lpVtbl -> SwitchToString(This,strToSwitchTo)

#define IDAImage_Hook(This,notifier,pBvr)	\
    (This)->lpVtbl -> Hook(This,notifier,pBvr)

#define IDAImage_Duration(This,duration,bvr)	\
    (This)->lpVtbl -> Duration(This,duration,bvr)

#define IDAImage_DurationAnim(This,duration,bvr)	\
    (This)->lpVtbl -> DurationAnim(This,duration,bvr)

#define IDAImage_Repeat(This,count,bvr)	\
    (This)->lpVtbl -> Repeat(This,count,bvr)

#define IDAImage_RepeatForever(This,bvr)	\
    (This)->lpVtbl -> RepeatForever(This,bvr)

#define IDAImage_IsReady(This,bBlock,b)	\
    (This)->lpVtbl -> IsReady(This,bBlock,b)


#define IDAImage_Pickable(This,ret_0)	\
    (This)->lpVtbl -> Pickable(This,ret_0)

#define IDAImage_PickableOccluded(This,ret_0)	\
    (This)->lpVtbl -> PickableOccluded(This,ret_0)

#define IDAImage_ApplyBitmapEffect(This,effectToApply_0,firesWhenChanged_1,ret_2)	\
    (This)->lpVtbl -> ApplyBitmapEffect(This,effectToApply_0,firesWhenChanged_1,ret_2)

#define IDAImage_get_BoundingBox(This,ret_0)	\
    (This)->lpVtbl -> get_BoundingBox(This,ret_0)

#define IDAImage_Crop(This,min_0,max_1,ret_2)	\
    (This)->lpVtbl -> Crop(This,min_0,max_1,ret_2)

#define IDAImage_Transform(This,xf_0,ret_1)	\
    (This)->lpVtbl -> Transform(This,xf_0,ret_1)

#define IDAImage_OpacityAnim(This,opacity_0,ret_1)	\
    (This)->lpVtbl -> OpacityAnim(This,opacity_0,ret_1)

#define IDAImage_Opacity(This,opacity_0,ret_1)	\
    (This)->lpVtbl -> Opacity(This,opacity_0,ret_1)

#define IDAImage_Undetectable(This,ret_0)	\
    (This)->lpVtbl -> Undetectable(This,ret_0)

#define IDAImage_Tile(This,ret_0)	\
    (This)->lpVtbl -> Tile(This,ret_0)

#define IDAImage_Clip(This,m_0,ret_1)	\
    (This)->lpVtbl -> Clip(This,m_0,ret_1)

#define IDAImage_MapToUnitSquare(This,ret_0)	\
    (This)->lpVtbl -> MapToUnitSquare(This,ret_0)

#define IDAImage_ClipPolygonImageEx(This,points_0size,points_0,ret_1)	\
    (This)->lpVtbl -> ClipPolygonImageEx(This,points_0size,points_0,ret_1)

#define IDAImage_ClipPolygonImage(This,points_0,ret_1)	\
    (This)->lpVtbl -> ClipPolygonImage(This,points_0,ret_1)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDAImage_Pickable_Proxy( 
    IDAImage * This,
    /* [retval][out] */ IDAPickableResult **ret_0);



HRESULT STDMETHODCALLTYPE IDAImage_PickableOccluded_Proxy( 
    IDAImage * This,
    /* [retval][out] */ IDAPickableResult **ret_0);



HRESULT STDMETHODCALLTYPE IDAImage_ApplyBitmapEffect_Proxy( 
    IDAImage * This,
    /* [in] */ IUnknown *effectToApply_0,
    /* [in] */ IDAEvent *firesWhenChanged_1,
    /* [retval][out] */ IDAImage **ret_2);



/* [propget] */ HRESULT STDMETHODCALLTYPE IDAImage_get_BoundingBox_Proxy( 
    IDAImage * This,
    /* [retval][out] */ IDABbox2 **ret_0);



HRESULT STDMETHODCALLTYPE IDAImage_Crop_Proxy( 
    IDAImage * This,
    /* [in] */ IDAPoint2 *min_0,
    /* [in] */ IDAPoint2 *max_1,
    /* [retval][out] */ IDAImage **ret_2);



HRESULT STDMETHODCALLTYPE IDAImage_Transform_Proxy( 
    IDAImage * This,
    /* [in] */ IDATransform2 *xf_0,
    /* [retval][out] */ IDAImage **ret_1);



HRESULT STDMETHODCALLTYPE IDAImage_OpacityAnim_Proxy( 
    IDAImage * This,
    /* [in] */ IDANumber *opacity_0,
    /* [retval][out] */ IDAImage **ret_1);



HRESULT STDMETHODCALLTYPE IDAImage_Opacity_Proxy( 
    IDAImage * This,
    /* [in] */ double opacity_0,
    /* [retval][out] */ IDAImage **ret_1);



HRESULT STDMETHODCALLTYPE IDAImage_Undetectable_Proxy( 
    IDAImage * This,
    /* [retval][out] */ IDAImage **ret_0);



HRESULT STDMETHODCALLTYPE IDAImage_Tile_Proxy( 
    IDAImage * This,
    /* [retval][out] */ IDAImage **ret_0);



HRESULT STDMETHODCALLTYPE IDAImage_Clip_Proxy( 
    IDAImage * This,
    /* [in] */ IDAMatte *m_0,
    /* [retval][out] */ IDAImage **ret_1);



HRESULT STDMETHODCALLTYPE IDAImage_MapToUnitSquare_Proxy( 
    IDAImage * This,
    /* [retval][out] */ IDAImage **ret_0);



HRESULT STDMETHODCALLTYPE IDAImage_ClipPolygonImageEx_Proxy( 
    IDAImage * This,
    /* [in] */ LONG points_0size,
    /* [size_is][in] */ IDAPoint2 *points_0[  ],
    /* [retval][out] */ IDAImage **ret_1);



HRESULT STDMETHODCALLTYPE IDAImage_ClipPolygonImage_Proxy( 
    IDAImage * This,
    /* [in] */ VARIANT points_0,
    /* [retval][out] */ IDAImage **ret_1);




#endif 	/* __IDAImage_INTERFACE_DEFINED__ */


#ifndef __IDAMatte_INTERFACE_DEFINED__
#define __IDAMatte_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDAMatte
 * at Tue Nov 11 05:16:35 1997
 * using MIDL 3.02.88
 ****************************************/
/* [dual][hidden][oleautomation][unique][object][local][helpstring][uuid] */ 



EXTERN_C const IID IID_IDAMatte;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("C46C1BD1-3C52-11d0-9200-848C1D000000")
    IDAMatte : public IDABehavior
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Transform( 
            /* [in] */ IDATransform2 *xf_0,
            /* [retval][out] */ IDAMatte **ret_1) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDAMatteVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDAMatte * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDAMatte * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDAMatte * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDAMatte * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDAMatte * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDAMatte * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDAMatte * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassName )( 
            IDAMatte * This,
            /* [retval][out] */ BSTR *pClassName);
        
        HRESULT ( STDMETHODCALLTYPE *Init )( 
            IDAMatte * This,
            /* [in] */ IDABehavior *toBvr);
        
        HRESULT ( STDMETHODCALLTYPE *Importance )( 
            IDAMatte * This,
            /* [in] */ double relativeImportance,
            /* [retval][out] */ IDABehavior **ppBvr);
        
        HRESULT ( STDMETHODCALLTYPE *RunOnce )( 
            IDAMatte * This,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *SubstituteTime )( 
            IDAMatte * This,
            /* [in] */ IDANumber *xform,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *SwitchTo )( 
            IDAMatte * This,
            /* [in] */ IDABehavior *switchTo);
        
        HRESULT ( STDMETHODCALLTYPE *SwitchToNumber )( 
            IDAMatte * This,
            /* [in] */ double numToSwitchTo);
        
        HRESULT ( STDMETHODCALLTYPE *SwitchToString )( 
            IDAMatte * This,
            /* [in] */ BSTR strToSwitchTo);
        
        HRESULT ( STDMETHODCALLTYPE *Hook )( 
            IDAMatte * This,
            /* [in] */ IDABvrHook *notifier,
            /* [retval][out] */ IDABehavior **pBvr);
        
        HRESULT ( STDMETHODCALLTYPE *Duration )( 
            IDAMatte * This,
            /* [in] */ double duration,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *DurationAnim )( 
            IDAMatte * This,
            /* [in] */ IDANumber *duration,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *Repeat )( 
            IDAMatte * This,
            /* [in] */ LONG count,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *RepeatForever )( 
            IDAMatte * This,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *IsReady )( 
            IDAMatte * This,
            /* [in] */ VARIANT_BOOL bBlock,
            /* [retval][out] */ VARIANT_BOOL *b);
        
        HRESULT ( STDMETHODCALLTYPE *Transform )( 
            IDAMatte * This,
            /* [in] */ IDATransform2 *xf_0,
            /* [retval][out] */ IDAMatte **ret_1);
        
        END_INTERFACE
    } IDAMatteVtbl;

    interface IDAMatte
    {
        CONST_VTBL struct IDAMatteVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDAMatte_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDAMatte_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDAMatte_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDAMatte_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDAMatte_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDAMatte_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDAMatte_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDAMatte_GetClassName(This,pClassName)	\
    (This)->lpVtbl -> GetClassName(This,pClassName)

#define IDAMatte_Init(This,toBvr)	\
    (This)->lpVtbl -> Init(This,toBvr)

#define IDAMatte_Importance(This,relativeImportance,ppBvr)	\
    (This)->lpVtbl -> Importance(This,relativeImportance,ppBvr)

#define IDAMatte_RunOnce(This,bvr)	\
    (This)->lpVtbl -> RunOnce(This,bvr)

#define IDAMatte_SubstituteTime(This,xform,bvr)	\
    (This)->lpVtbl -> SubstituteTime(This,xform,bvr)

#define IDAMatte_SwitchTo(This,switchTo)	\
    (This)->lpVtbl -> SwitchTo(This,switchTo)

#define IDAMatte_SwitchToNumber(This,numToSwitchTo)	\
    (This)->lpVtbl -> SwitchToNumber(This,numToSwitchTo)

#define IDAMatte_SwitchToString(This,strToSwitchTo)	\
    (This)->lpVtbl -> SwitchToString(This,strToSwitchTo)

#define IDAMatte_Hook(This,notifier,pBvr)	\
    (This)->lpVtbl -> Hook(This,notifier,pBvr)

#define IDAMatte_Duration(This,duration,bvr)	\
    (This)->lpVtbl -> Duration(This,duration,bvr)

#define IDAMatte_DurationAnim(This,duration,bvr)	\
    (This)->lpVtbl -> DurationAnim(This,duration,bvr)

#define IDAMatte_Repeat(This,count,bvr)	\
    (This)->lpVtbl -> Repeat(This,count,bvr)

#define IDAMatte_RepeatForever(This,bvr)	\
    (This)->lpVtbl -> RepeatForever(This,bvr)

#define IDAMatte_IsReady(This,bBlock,b)	\
    (This)->lpVtbl -> IsReady(This,bBlock,b)


#define IDAMatte_Transform(This,xf_0,ret_1)	\
    (This)->lpVtbl -> Transform(This,xf_0,ret_1)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDAMatte_Transform_Proxy( 
    IDAMatte * This,
    /* [in] */ IDATransform2 *xf_0,
    /* [retval][out] */ IDAMatte **ret_1);




#endif 	/* __IDAMatte_INTERFACE_DEFINED__ */


#ifndef __IDAMicrophone_INTERFACE_DEFINED__
#define __IDAMicrophone_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDAMicrophone
 * at Tue Nov 11 05:16:35 1997
 * using MIDL 3.02.88
 ****************************************/
/* [dual][hidden][oleautomation][unique][object][local][helpstring][uuid] */ 



EXTERN_C const IID IID_IDAMicrophone;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("C46C1BE5-3C52-11d0-9200-848C1D000000")
    IDAMicrophone : public IDABehavior
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Transform( 
            /* [in] */ IDATransform3 *xf_0,
            /* [retval][out] */ IDAMicrophone **ret_1) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDAMicrophoneVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDAMicrophone * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDAMicrophone * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDAMicrophone * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDAMicrophone * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDAMicrophone * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDAMicrophone * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDAMicrophone * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassName )( 
            IDAMicrophone * This,
            /* [retval][out] */ BSTR *pClassName);
        
        HRESULT ( STDMETHODCALLTYPE *Init )( 
            IDAMicrophone * This,
            /* [in] */ IDABehavior *toBvr);
        
        HRESULT ( STDMETHODCALLTYPE *Importance )( 
            IDAMicrophone * This,
            /* [in] */ double relativeImportance,
            /* [retval][out] */ IDABehavior **ppBvr);
        
        HRESULT ( STDMETHODCALLTYPE *RunOnce )( 
            IDAMicrophone * This,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *SubstituteTime )( 
            IDAMicrophone * This,
            /* [in] */ IDANumber *xform,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *SwitchTo )( 
            IDAMicrophone * This,
            /* [in] */ IDABehavior *switchTo);
        
        HRESULT ( STDMETHODCALLTYPE *SwitchToNumber )( 
            IDAMicrophone * This,
            /* [in] */ double numToSwitchTo);
        
        HRESULT ( STDMETHODCALLTYPE *SwitchToString )( 
            IDAMicrophone * This,
            /* [in] */ BSTR strToSwitchTo);
        
        HRESULT ( STDMETHODCALLTYPE *Hook )( 
            IDAMicrophone * This,
            /* [in] */ IDABvrHook *notifier,
            /* [retval][out] */ IDABehavior **pBvr);
        
        HRESULT ( STDMETHODCALLTYPE *Duration )( 
            IDAMicrophone * This,
            /* [in] */ double duration,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *DurationAnim )( 
            IDAMicrophone * This,
            /* [in] */ IDANumber *duration,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *Repeat )( 
            IDAMicrophone * This,
            /* [in] */ LONG count,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *RepeatForever )( 
            IDAMicrophone * This,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *IsReady )( 
            IDAMicrophone * This,
            /* [in] */ VARIANT_BOOL bBlock,
            /* [retval][out] */ VARIANT_BOOL *b);
        
        HRESULT ( STDMETHODCALLTYPE *Transform )( 
            IDAMicrophone * This,
            /* [in] */ IDATransform3 *xf_0,
            /* [retval][out] */ IDAMicrophone **ret_1);
        
        END_INTERFACE
    } IDAMicrophoneVtbl;

    interface IDAMicrophone
    {
        CONST_VTBL struct IDAMicrophoneVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDAMicrophone_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDAMicrophone_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDAMicrophone_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDAMicrophone_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDAMicrophone_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDAMicrophone_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDAMicrophone_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDAMicrophone_GetClassName(This,pClassName)	\
    (This)->lpVtbl -> GetClassName(This,pClassName)

#define IDAMicrophone_Init(This,toBvr)	\
    (This)->lpVtbl -> Init(This,toBvr)

#define IDAMicrophone_Importance(This,relativeImportance,ppBvr)	\
    (This)->lpVtbl -> Importance(This,relativeImportance,ppBvr)

#define IDAMicrophone_RunOnce(This,bvr)	\
    (This)->lpVtbl -> RunOnce(This,bvr)

#define IDAMicrophone_SubstituteTime(This,xform,bvr)	\
    (This)->lpVtbl -> SubstituteTime(This,xform,bvr)

#define IDAMicrophone_SwitchTo(This,switchTo)	\
    (This)->lpVtbl -> SwitchTo(This,switchTo)

#define IDAMicrophone_SwitchToNumber(This,numToSwitchTo)	\
    (This)->lpVtbl -> SwitchToNumber(This,numToSwitchTo)

#define IDAMicrophone_SwitchToString(This,strToSwitchTo)	\
    (This)->lpVtbl -> SwitchToString(This,strToSwitchTo)

#define IDAMicrophone_Hook(This,notifier,pBvr)	\
    (This)->lpVtbl -> Hook(This,notifier,pBvr)

#define IDAMicrophone_Duration(This,duration,bvr)	\
    (This)->lpVtbl -> Duration(This,duration,bvr)

#define IDAMicrophone_DurationAnim(This,duration,bvr)	\
    (This)->lpVtbl -> DurationAnim(This,duration,bvr)

#define IDAMicrophone_Repeat(This,count,bvr)	\
    (This)->lpVtbl -> Repeat(This,count,bvr)

#define IDAMicrophone_RepeatForever(This,bvr)	\
    (This)->lpVtbl -> RepeatForever(This,bvr)

#define IDAMicrophone_IsReady(This,bBlock,b)	\
    (This)->lpVtbl -> IsReady(This,bBlock,b)


#define IDAMicrophone_Transform(This,xf_0,ret_1)	\
    (This)->lpVtbl -> Transform(This,xf_0,ret_1)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDAMicrophone_Transform_Proxy( 
    IDAMicrophone * This,
    /* [in] */ IDATransform3 *xf_0,
    /* [retval][out] */ IDAMicrophone **ret_1);




#endif 	/* __IDAMicrophone_INTERFACE_DEFINED__ */


#ifndef __IDAMontage_INTERFACE_DEFINED__
#define __IDAMontage_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDAMontage
 * at Tue Nov 11 05:16:35 1997
 * using MIDL 3.02.88
 ****************************************/
/* [dual][hidden][oleautomation][unique][object][local][helpstring][uuid] */ 



EXTERN_C const IID IID_IDAMontage;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("C46C1BD5-3C52-11d0-9200-848C1D000000")
    IDAMontage : public IDABehavior
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Render( 
            /* [retval][out] */ IDAImage **ret_0) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDAMontageVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDAMontage * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDAMontage * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDAMontage * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDAMontage * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDAMontage * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDAMontage * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDAMontage * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassName )( 
            IDAMontage * This,
            /* [retval][out] */ BSTR *pClassName);
        
        HRESULT ( STDMETHODCALLTYPE *Init )( 
            IDAMontage * This,
            /* [in] */ IDABehavior *toBvr);
        
        HRESULT ( STDMETHODCALLTYPE *Importance )( 
            IDAMontage * This,
            /* [in] */ double relativeImportance,
            /* [retval][out] */ IDABehavior **ppBvr);
        
        HRESULT ( STDMETHODCALLTYPE *RunOnce )( 
            IDAMontage * This,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *SubstituteTime )( 
            IDAMontage * This,
            /* [in] */ IDANumber *xform,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *SwitchTo )( 
            IDAMontage * This,
            /* [in] */ IDABehavior *switchTo);
        
        HRESULT ( STDMETHODCALLTYPE *SwitchToNumber )( 
            IDAMontage * This,
            /* [in] */ double numToSwitchTo);
        
        HRESULT ( STDMETHODCALLTYPE *SwitchToString )( 
            IDAMontage * This,
            /* [in] */ BSTR strToSwitchTo);
        
        HRESULT ( STDMETHODCALLTYPE *Hook )( 
            IDAMontage * This,
            /* [in] */ IDABvrHook *notifier,
            /* [retval][out] */ IDABehavior **pBvr);
        
        HRESULT ( STDMETHODCALLTYPE *Duration )( 
            IDAMontage * This,
            /* [in] */ double duration,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *DurationAnim )( 
            IDAMontage * This,
            /* [in] */ IDANumber *duration,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *Repeat )( 
            IDAMontage * This,
            /* [in] */ LONG count,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *RepeatForever )( 
            IDAMontage * This,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *IsReady )( 
            IDAMontage * This,
            /* [in] */ VARIANT_BOOL bBlock,
            /* [retval][out] */ VARIANT_BOOL *b);
        
        HRESULT ( STDMETHODCALLTYPE *Render )( 
            IDAMontage * This,
            /* [retval][out] */ IDAImage **ret_0);
        
        END_INTERFACE
    } IDAMontageVtbl;

    interface IDAMontage
    {
        CONST_VTBL struct IDAMontageVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDAMontage_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDAMontage_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDAMontage_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDAMontage_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDAMontage_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDAMontage_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDAMontage_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDAMontage_GetClassName(This,pClassName)	\
    (This)->lpVtbl -> GetClassName(This,pClassName)

#define IDAMontage_Init(This,toBvr)	\
    (This)->lpVtbl -> Init(This,toBvr)

#define IDAMontage_Importance(This,relativeImportance,ppBvr)	\
    (This)->lpVtbl -> Importance(This,relativeImportance,ppBvr)

#define IDAMontage_RunOnce(This,bvr)	\
    (This)->lpVtbl -> RunOnce(This,bvr)

#define IDAMontage_SubstituteTime(This,xform,bvr)	\
    (This)->lpVtbl -> SubstituteTime(This,xform,bvr)

#define IDAMontage_SwitchTo(This,switchTo)	\
    (This)->lpVtbl -> SwitchTo(This,switchTo)

#define IDAMontage_SwitchToNumber(This,numToSwitchTo)	\
    (This)->lpVtbl -> SwitchToNumber(This,numToSwitchTo)

#define IDAMontage_SwitchToString(This,strToSwitchTo)	\
    (This)->lpVtbl -> SwitchToString(This,strToSwitchTo)

#define IDAMontage_Hook(This,notifier,pBvr)	\
    (This)->lpVtbl -> Hook(This,notifier,pBvr)

#define IDAMontage_Duration(This,duration,bvr)	\
    (This)->lpVtbl -> Duration(This,duration,bvr)

#define IDAMontage_DurationAnim(This,duration,bvr)	\
    (This)->lpVtbl -> DurationAnim(This,duration,bvr)

#define IDAMontage_Repeat(This,count,bvr)	\
    (This)->lpVtbl -> Repeat(This,count,bvr)

#define IDAMontage_RepeatForever(This,bvr)	\
    (This)->lpVtbl -> RepeatForever(This,bvr)

#define IDAMontage_IsReady(This,bBlock,b)	\
    (This)->lpVtbl -> IsReady(This,bBlock,b)


#define IDAMontage_Render(This,ret_0)	\
    (This)->lpVtbl -> Render(This,ret_0)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDAMontage_Render_Proxy( 
    IDAMontage * This,
    /* [retval][out] */ IDAImage **ret_0);




#endif 	/* __IDAMontage_INTERFACE_DEFINED__ */


#ifndef __IDAPath2_INTERFACE_DEFINED__
#define __IDAPath2_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDAPath2
 * at Tue Nov 11 05:16:35 1997
 * using MIDL 3.02.88
 ****************************************/
/* [dual][hidden][oleautomation][unique][object][local][helpstring][uuid] */ 



EXTERN_C const IID IID_IDAPath2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("C46C1BCF-3C52-11d0-9200-848C1D000000")
    IDAPath2 : public IDABehavior
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Transform( 
            /* [in] */ IDATransform2 *xf_0,
            /* [retval][out] */ IDAPath2 **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BoundingBox( 
            /* [in] */ IDALineStyle *style_0,
            /* [retval][out] */ IDABbox2 **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Fill( 
            /* [in] */ IDALineStyle *border_0,
            /* [in] */ IDAImage *fill_1,
            /* [retval][out] */ IDAImage **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Draw( 
            /* [in] */ IDALineStyle *border_0,
            /* [retval][out] */ IDAImage **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Close( 
            /* [retval][out] */ IDAPath2 **ret_0) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDAPath2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDAPath2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDAPath2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDAPath2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDAPath2 * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDAPath2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDAPath2 * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDAPath2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassName )( 
            IDAPath2 * This,
            /* [retval][out] */ BSTR *pClassName);
        
        HRESULT ( STDMETHODCALLTYPE *Init )( 
            IDAPath2 * This,
            /* [in] */ IDABehavior *toBvr);
        
        HRESULT ( STDMETHODCALLTYPE *Importance )( 
            IDAPath2 * This,
            /* [in] */ double relativeImportance,
            /* [retval][out] */ IDABehavior **ppBvr);
        
        HRESULT ( STDMETHODCALLTYPE *RunOnce )( 
            IDAPath2 * This,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *SubstituteTime )( 
            IDAPath2 * This,
            /* [in] */ IDANumber *xform,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *SwitchTo )( 
            IDAPath2 * This,
            /* [in] */ IDABehavior *switchTo);
        
        HRESULT ( STDMETHODCALLTYPE *SwitchToNumber )( 
            IDAPath2 * This,
            /* [in] */ double numToSwitchTo);
        
        HRESULT ( STDMETHODCALLTYPE *SwitchToString )( 
            IDAPath2 * This,
            /* [in] */ BSTR strToSwitchTo);
        
        HRESULT ( STDMETHODCALLTYPE *Hook )( 
            IDAPath2 * This,
            /* [in] */ IDABvrHook *notifier,
            /* [retval][out] */ IDABehavior **pBvr);
        
        HRESULT ( STDMETHODCALLTYPE *Duration )( 
            IDAPath2 * This,
            /* [in] */ double duration,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *DurationAnim )( 
            IDAPath2 * This,
            /* [in] */ IDANumber *duration,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *Repeat )( 
            IDAPath2 * This,
            /* [in] */ LONG count,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *RepeatForever )( 
            IDAPath2 * This,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *IsReady )( 
            IDAPath2 * This,
            /* [in] */ VARIANT_BOOL bBlock,
            /* [retval][out] */ VARIANT_BOOL *b);
        
        HRESULT ( STDMETHODCALLTYPE *Transform )( 
            IDAPath2 * This,
            /* [in] */ IDATransform2 *xf_0,
            /* [retval][out] */ IDAPath2 **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *BoundingBox )( 
            IDAPath2 * This,
            /* [in] */ IDALineStyle *style_0,
            /* [retval][out] */ IDABbox2 **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *Fill )( 
            IDAPath2 * This,
            /* [in] */ IDALineStyle *border_0,
            /* [in] */ IDAImage *fill_1,
            /* [retval][out] */ IDAImage **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *Draw )( 
            IDAPath2 * This,
            /* [in] */ IDALineStyle *border_0,
            /* [retval][out] */ IDAImage **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *Close )( 
            IDAPath2 * This,
            /* [retval][out] */ IDAPath2 **ret_0);
        
        END_INTERFACE
    } IDAPath2Vtbl;

    interface IDAPath2
    {
        CONST_VTBL struct IDAPath2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDAPath2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDAPath2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDAPath2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDAPath2_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDAPath2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDAPath2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDAPath2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDAPath2_GetClassName(This,pClassName)	\
    (This)->lpVtbl -> GetClassName(This,pClassName)

#define IDAPath2_Init(This,toBvr)	\
    (This)->lpVtbl -> Init(This,toBvr)

#define IDAPath2_Importance(This,relativeImportance,ppBvr)	\
    (This)->lpVtbl -> Importance(This,relativeImportance,ppBvr)

#define IDAPath2_RunOnce(This,bvr)	\
    (This)->lpVtbl -> RunOnce(This,bvr)

#define IDAPath2_SubstituteTime(This,xform,bvr)	\
    (This)->lpVtbl -> SubstituteTime(This,xform,bvr)

#define IDAPath2_SwitchTo(This,switchTo)	\
    (This)->lpVtbl -> SwitchTo(This,switchTo)

#define IDAPath2_SwitchToNumber(This,numToSwitchTo)	\
    (This)->lpVtbl -> SwitchToNumber(This,numToSwitchTo)

#define IDAPath2_SwitchToString(This,strToSwitchTo)	\
    (This)->lpVtbl -> SwitchToString(This,strToSwitchTo)

#define IDAPath2_Hook(This,notifier,pBvr)	\
    (This)->lpVtbl -> Hook(This,notifier,pBvr)

#define IDAPath2_Duration(This,duration,bvr)	\
    (This)->lpVtbl -> Duration(This,duration,bvr)

#define IDAPath2_DurationAnim(This,duration,bvr)	\
    (This)->lpVtbl -> DurationAnim(This,duration,bvr)

#define IDAPath2_Repeat(This,count,bvr)	\
    (This)->lpVtbl -> Repeat(This,count,bvr)

#define IDAPath2_RepeatForever(This,bvr)	\
    (This)->lpVtbl -> RepeatForever(This,bvr)

#define IDAPath2_IsReady(This,bBlock,b)	\
    (This)->lpVtbl -> IsReady(This,bBlock,b)


#define IDAPath2_Transform(This,xf_0,ret_1)	\
    (This)->lpVtbl -> Transform(This,xf_0,ret_1)

#define IDAPath2_BoundingBox(This,style_0,ret_1)	\
    (This)->lpVtbl -> BoundingBox(This,style_0,ret_1)

#define IDAPath2_Fill(This,border_0,fill_1,ret_2)	\
    (This)->lpVtbl -> Fill(This,border_0,fill_1,ret_2)

#define IDAPath2_Draw(This,border_0,ret_1)	\
    (This)->lpVtbl -> Draw(This,border_0,ret_1)

#define IDAPath2_Close(This,ret_0)	\
    (This)->lpVtbl -> Close(This,ret_0)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDAPath2_Transform_Proxy( 
    IDAPath2 * This,
    /* [in] */ IDATransform2 *xf_0,
    /* [retval][out] */ IDAPath2 **ret_1);



HRESULT STDMETHODCALLTYPE IDAPath2_BoundingBox_Proxy( 
    IDAPath2 * This,
    /* [in] */ IDALineStyle *style_0,
    /* [retval][out] */ IDABbox2 **ret_1);



HRESULT STDMETHODCALLTYPE IDAPath2_Fill_Proxy( 
    IDAPath2 * This,
    /* [in] */ IDALineStyle *border_0,
    /* [in] */ IDAImage *fill_1,
    /* [retval][out] */ IDAImage **ret_2);



HRESULT STDMETHODCALLTYPE IDAPath2_Draw_Proxy( 
    IDAPath2 * This,
    /* [in] */ IDALineStyle *border_0,
    /* [retval][out] */ IDAImage **ret_1);



HRESULT STDMETHODCALLTYPE IDAPath2_Close_Proxy( 
    IDAPath2 * This,
    /* [retval][out] */ IDAPath2 **ret_0);




#endif 	/* __IDAPath2_INTERFACE_DEFINED__ */


#ifndef __IDAPoint2_INTERFACE_DEFINED__
#define __IDAPoint2_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDAPoint2
 * at Tue Nov 11 05:16:35 1997
 * using MIDL 3.02.88
 ****************************************/
/* [dual][hidden][oleautomation][unique][object][local][helpstring][uuid] */ 



EXTERN_C const IID IID_IDAPoint2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("C46C1BC7-3C52-11d0-9200-848C1D000000")
    IDAPoint2 : public IDABehavior
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AnimateControlPosition( 
            /* [in] */ BSTR propertyPath_0,
            /* [in] */ BSTR scriptingLanguage_1,
            /* [in] */ VARIANT_BOOL invokeAsMethod_2,
            /* [in] */ double minUpdateInterval_3,
            /* [retval][out] */ IDAPoint2 **ret_4) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AnimateControlPositionPixel( 
            /* [in] */ BSTR propertyPath_0,
            /* [in] */ BSTR scriptingLanguage_1,
            /* [in] */ VARIANT_BOOL invokeAsMethod_2,
            /* [in] */ double minUpdateInterval_3,
            /* [retval][out] */ IDAPoint2 **ret_4) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_X( 
            /* [retval][out] */ IDANumber **ret_0) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Y( 
            /* [retval][out] */ IDANumber **ret_0) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_PolarCoordAngle( 
            /* [retval][out] */ IDANumber **ret_0) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_PolarCoordLength( 
            /* [retval][out] */ IDANumber **ret_0) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Transform( 
            /* [in] */ IDATransform2 *xf_0,
            /* [retval][out] */ IDAPoint2 **ret_1) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDAPoint2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDAPoint2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDAPoint2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDAPoint2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDAPoint2 * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDAPoint2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDAPoint2 * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDAPoint2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassName )( 
            IDAPoint2 * This,
            /* [retval][out] */ BSTR *pClassName);
        
        HRESULT ( STDMETHODCALLTYPE *Init )( 
            IDAPoint2 * This,
            /* [in] */ IDABehavior *toBvr);
        
        HRESULT ( STDMETHODCALLTYPE *Importance )( 
            IDAPoint2 * This,
            /* [in] */ double relativeImportance,
            /* [retval][out] */ IDABehavior **ppBvr);
        
        HRESULT ( STDMETHODCALLTYPE *RunOnce )( 
            IDAPoint2 * This,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *SubstituteTime )( 
            IDAPoint2 * This,
            /* [in] */ IDANumber *xform,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *SwitchTo )( 
            IDAPoint2 * This,
            /* [in] */ IDABehavior *switchTo);
        
        HRESULT ( STDMETHODCALLTYPE *SwitchToNumber )( 
            IDAPoint2 * This,
            /* [in] */ double numToSwitchTo);
        
        HRESULT ( STDMETHODCALLTYPE *SwitchToString )( 
            IDAPoint2 * This,
            /* [in] */ BSTR strToSwitchTo);
        
        HRESULT ( STDMETHODCALLTYPE *Hook )( 
            IDAPoint2 * This,
            /* [in] */ IDABvrHook *notifier,
            /* [retval][out] */ IDABehavior **pBvr);
        
        HRESULT ( STDMETHODCALLTYPE *Duration )( 
            IDAPoint2 * This,
            /* [in] */ double duration,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *DurationAnim )( 
            IDAPoint2 * This,
            /* [in] */ IDANumber *duration,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *Repeat )( 
            IDAPoint2 * This,
            /* [in] */ LONG count,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *RepeatForever )( 
            IDAPoint2 * This,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *IsReady )( 
            IDAPoint2 * This,
            /* [in] */ VARIANT_BOOL bBlock,
            /* [retval][out] */ VARIANT_BOOL *b);
        
        HRESULT ( STDMETHODCALLTYPE *AnimateControlPosition )( 
            IDAPoint2 * This,
            /* [in] */ BSTR propertyPath_0,
            /* [in] */ BSTR scriptingLanguage_1,
            /* [in] */ VARIANT_BOOL invokeAsMethod_2,
            /* [in] */ double minUpdateInterval_3,
            /* [retval][out] */ IDAPoint2 **ret_4);
        
        HRESULT ( STDMETHODCALLTYPE *AnimateControlPositionPixel )( 
            IDAPoint2 * This,
            /* [in] */ BSTR propertyPath_0,
            /* [in] */ BSTR scriptingLanguage_1,
            /* [in] */ VARIANT_BOOL invokeAsMethod_2,
            /* [in] */ double minUpdateInterval_3,
            /* [retval][out] */ IDAPoint2 **ret_4);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_X )( 
            IDAPoint2 * This,
            /* [retval][out] */ IDANumber **ret_0);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Y )( 
            IDAPoint2 * This,
            /* [retval][out] */ IDANumber **ret_0);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_PolarCoordAngle )( 
            IDAPoint2 * This,
            /* [retval][out] */ IDANumber **ret_0);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_PolarCoordLength )( 
            IDAPoint2 * This,
            /* [retval][out] */ IDANumber **ret_0);
        
        HRESULT ( STDMETHODCALLTYPE *Transform )( 
            IDAPoint2 * This,
            /* [in] */ IDATransform2 *xf_0,
            /* [retval][out] */ IDAPoint2 **ret_1);
        
        END_INTERFACE
    } IDAPoint2Vtbl;

    interface IDAPoint2
    {
        CONST_VTBL struct IDAPoint2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDAPoint2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDAPoint2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDAPoint2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDAPoint2_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDAPoint2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDAPoint2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDAPoint2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDAPoint2_GetClassName(This,pClassName)	\
    (This)->lpVtbl -> GetClassName(This,pClassName)

#define IDAPoint2_Init(This,toBvr)	\
    (This)->lpVtbl -> Init(This,toBvr)

#define IDAPoint2_Importance(This,relativeImportance,ppBvr)	\
    (This)->lpVtbl -> Importance(This,relativeImportance,ppBvr)

#define IDAPoint2_RunOnce(This,bvr)	\
    (This)->lpVtbl -> RunOnce(This,bvr)

#define IDAPoint2_SubstituteTime(This,xform,bvr)	\
    (This)->lpVtbl -> SubstituteTime(This,xform,bvr)

#define IDAPoint2_SwitchTo(This,switchTo)	\
    (This)->lpVtbl -> SwitchTo(This,switchTo)

#define IDAPoint2_SwitchToNumber(This,numToSwitchTo)	\
    (This)->lpVtbl -> SwitchToNumber(This,numToSwitchTo)

#define IDAPoint2_SwitchToString(This,strToSwitchTo)	\
    (This)->lpVtbl -> SwitchToString(This,strToSwitchTo)

#define IDAPoint2_Hook(This,notifier,pBvr)	\
    (This)->lpVtbl -> Hook(This,notifier,pBvr)

#define IDAPoint2_Duration(This,duration,bvr)	\
    (This)->lpVtbl -> Duration(This,duration,bvr)

#define IDAPoint2_DurationAnim(This,duration,bvr)	\
    (This)->lpVtbl -> DurationAnim(This,duration,bvr)

#define IDAPoint2_Repeat(This,count,bvr)	\
    (This)->lpVtbl -> Repeat(This,count,bvr)

#define IDAPoint2_RepeatForever(This,bvr)	\
    (This)->lpVtbl -> RepeatForever(This,bvr)

#define IDAPoint2_IsReady(This,bBlock,b)	\
    (This)->lpVtbl -> IsReady(This,bBlock,b)


#define IDAPoint2_AnimateControlPosition(This,propertyPath_0,scriptingLanguage_1,invokeAsMethod_2,minUpdateInterval_3,ret_4)	\
    (This)->lpVtbl -> AnimateControlPosition(This,propertyPath_0,scriptingLanguage_1,invokeAsMethod_2,minUpdateInterval_3,ret_4)

#define IDAPoint2_AnimateControlPositionPixel(This,propertyPath_0,scriptingLanguage_1,invokeAsMethod_2,minUpdateInterval_3,ret_4)	\
    (This)->lpVtbl -> AnimateControlPositionPixel(This,propertyPath_0,scriptingLanguage_1,invokeAsMethod_2,minUpdateInterval_3,ret_4)

#define IDAPoint2_get_X(This,ret_0)	\
    (This)->lpVtbl -> get_X(This,ret_0)

#define IDAPoint2_get_Y(This,ret_0)	\
    (This)->lpVtbl -> get_Y(This,ret_0)

#define IDAPoint2_get_PolarCoordAngle(This,ret_0)	\
    (This)->lpVtbl -> get_PolarCoordAngle(This,ret_0)

#define IDAPoint2_get_PolarCoordLength(This,ret_0)	\
    (This)->lpVtbl -> get_PolarCoordLength(This,ret_0)

#define IDAPoint2_Transform(This,xf_0,ret_1)	\
    (This)->lpVtbl -> Transform(This,xf_0,ret_1)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDAPoint2_AnimateControlPosition_Proxy( 
    IDAPoint2 * This,
    /* [in] */ BSTR propertyPath_0,
    /* [in] */ BSTR scriptingLanguage_1,
    /* [in] */ VARIANT_BOOL invokeAsMethod_2,
    /* [in] */ double minUpdateInterval_3,
    /* [retval][out] */ IDAPoint2 **ret_4);



HRESULT STDMETHODCALLTYPE IDAPoint2_AnimateControlPositionPixel_Proxy( 
    IDAPoint2 * This,
    /* [in] */ BSTR propertyPath_0,
    /* [in] */ BSTR scriptingLanguage_1,
    /* [in] */ VARIANT_BOOL invokeAsMethod_2,
    /* [in] */ double minUpdateInterval_3,
    /* [retval][out] */ IDAPoint2 **ret_4);



/* [propget] */ HRESULT STDMETHODCALLTYPE IDAPoint2_get_X_Proxy( 
    IDAPoint2 * This,
    /* [retval][out] */ IDANumber **ret_0);



/* [propget] */ HRESULT STDMETHODCALLTYPE IDAPoint2_get_Y_Proxy( 
    IDAPoint2 * This,
    /* [retval][out] */ IDANumber **ret_0);



/* [propget] */ HRESULT STDMETHODCALLTYPE IDAPoint2_get_PolarCoordAngle_Proxy( 
    IDAPoint2 * This,
    /* [retval][out] */ IDANumber **ret_0);



/* [propget] */ HRESULT STDMETHODCALLTYPE IDAPoint2_get_PolarCoordLength_Proxy( 
    IDAPoint2 * This,
    /* [retval][out] */ IDANumber **ret_0);



HRESULT STDMETHODCALLTYPE IDAPoint2_Transform_Proxy( 
    IDAPoint2 * This,
    /* [in] */ IDATransform2 *xf_0,
    /* [retval][out] */ IDAPoint2 **ret_1);




#endif 	/* __IDAPoint2_INTERFACE_DEFINED__ */


#ifndef __IDAPoint3_INTERFACE_DEFINED__
#define __IDAPoint3_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDAPoint3
 * at Tue Nov 11 05:16:35 1997
 * using MIDL 3.02.88
 ****************************************/
/* [dual][hidden][oleautomation][unique][object][local][helpstring][uuid] */ 



EXTERN_C const IID IID_IDAPoint3;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("C46C1BD7-3C52-11d0-9200-848C1D000000")
    IDAPoint3 : public IDABehavior
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Project( 
            /* [in] */ IDACamera *cam_0,
            /* [retval][out] */ IDAPoint2 **ret_1) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_X( 
            /* [retval][out] */ IDANumber **ret_0) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Y( 
            /* [retval][out] */ IDANumber **ret_0) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Z( 
            /* [retval][out] */ IDANumber **ret_0) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_SphericalCoordXYAngle( 
            /* [retval][out] */ IDANumber **ret_0) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_SphericalCoordYZAngle( 
            /* [retval][out] */ IDANumber **ret_0) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_SphericalCoordLength( 
            /* [retval][out] */ IDANumber **ret_0) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Transform( 
            /* [in] */ IDATransform3 *xf_0,
            /* [retval][out] */ IDAPoint3 **ret_1) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDAPoint3Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDAPoint3 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDAPoint3 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDAPoint3 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDAPoint3 * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDAPoint3 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDAPoint3 * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDAPoint3 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassName )( 
            IDAPoint3 * This,
            /* [retval][out] */ BSTR *pClassName);
        
        HRESULT ( STDMETHODCALLTYPE *Init )( 
            IDAPoint3 * This,
            /* [in] */ IDABehavior *toBvr);
        
        HRESULT ( STDMETHODCALLTYPE *Importance )( 
            IDAPoint3 * This,
            /* [in] */ double relativeImportance,
            /* [retval][out] */ IDABehavior **ppBvr);
        
        HRESULT ( STDMETHODCALLTYPE *RunOnce )( 
            IDAPoint3 * This,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *SubstituteTime )( 
            IDAPoint3 * This,
            /* [in] */ IDANumber *xform,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *SwitchTo )( 
            IDAPoint3 * This,
            /* [in] */ IDABehavior *switchTo);
        
        HRESULT ( STDMETHODCALLTYPE *SwitchToNumber )( 
            IDAPoint3 * This,
            /* [in] */ double numToSwitchTo);
        
        HRESULT ( STDMETHODCALLTYPE *SwitchToString )( 
            IDAPoint3 * This,
            /* [in] */ BSTR strToSwitchTo);
        
        HRESULT ( STDMETHODCALLTYPE *Hook )( 
            IDAPoint3 * This,
            /* [in] */ IDABvrHook *notifier,
            /* [retval][out] */ IDABehavior **pBvr);
        
        HRESULT ( STDMETHODCALLTYPE *Duration )( 
            IDAPoint3 * This,
            /* [in] */ double duration,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *DurationAnim )( 
            IDAPoint3 * This,
            /* [in] */ IDANumber *duration,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *Repeat )( 
            IDAPoint3 * This,
            /* [in] */ LONG count,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *RepeatForever )( 
            IDAPoint3 * This,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *IsReady )( 
            IDAPoint3 * This,
            /* [in] */ VARIANT_BOOL bBlock,
            /* [retval][out] */ VARIANT_BOOL *b);
        
        HRESULT ( STDMETHODCALLTYPE *Project )( 
            IDAPoint3 * This,
            /* [in] */ IDACamera *cam_0,
            /* [retval][out] */ IDAPoint2 **ret_1);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_X )( 
            IDAPoint3 * This,
            /* [retval][out] */ IDANumber **ret_0);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Y )( 
            IDAPoint3 * This,
            /* [retval][out] */ IDANumber **ret_0);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Z )( 
            IDAPoint3 * This,
            /* [retval][out] */ IDANumber **ret_0);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SphericalCoordXYAngle )( 
            IDAPoint3 * This,
            /* [retval][out] */ IDANumber **ret_0);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SphericalCoordYZAngle )( 
            IDAPoint3 * This,
            /* [retval][out] */ IDANumber **ret_0);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SphericalCoordLength )( 
            IDAPoint3 * This,
            /* [retval][out] */ IDANumber **ret_0);
        
        HRESULT ( STDMETHODCALLTYPE *Transform )( 
            IDAPoint3 * This,
            /* [in] */ IDATransform3 *xf_0,
            /* [retval][out] */ IDAPoint3 **ret_1);
        
        END_INTERFACE
    } IDAPoint3Vtbl;

    interface IDAPoint3
    {
        CONST_VTBL struct IDAPoint3Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDAPoint3_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDAPoint3_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDAPoint3_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDAPoint3_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDAPoint3_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDAPoint3_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDAPoint3_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDAPoint3_GetClassName(This,pClassName)	\
    (This)->lpVtbl -> GetClassName(This,pClassName)

#define IDAPoint3_Init(This,toBvr)	\
    (This)->lpVtbl -> Init(This,toBvr)

#define IDAPoint3_Importance(This,relativeImportance,ppBvr)	\
    (This)->lpVtbl -> Importance(This,relativeImportance,ppBvr)

#define IDAPoint3_RunOnce(This,bvr)	\
    (This)->lpVtbl -> RunOnce(This,bvr)

#define IDAPoint3_SubstituteTime(This,xform,bvr)	\
    (This)->lpVtbl -> SubstituteTime(This,xform,bvr)

#define IDAPoint3_SwitchTo(This,switchTo)	\
    (This)->lpVtbl -> SwitchTo(This,switchTo)

#define IDAPoint3_SwitchToNumber(This,numToSwitchTo)	\
    (This)->lpVtbl -> SwitchToNumber(This,numToSwitchTo)

#define IDAPoint3_SwitchToString(This,strToSwitchTo)	\
    (This)->lpVtbl -> SwitchToString(This,strToSwitchTo)

#define IDAPoint3_Hook(This,notifier,pBvr)	\
    (This)->lpVtbl -> Hook(This,notifier,pBvr)

#define IDAPoint3_Duration(This,duration,bvr)	\
    (This)->lpVtbl -> Duration(This,duration,bvr)

#define IDAPoint3_DurationAnim(This,duration,bvr)	\
    (This)->lpVtbl -> DurationAnim(This,duration,bvr)

#define IDAPoint3_Repeat(This,count,bvr)	\
    (This)->lpVtbl -> Repeat(This,count,bvr)

#define IDAPoint3_RepeatForever(This,bvr)	\
    (This)->lpVtbl -> RepeatForever(This,bvr)

#define IDAPoint3_IsReady(This,bBlock,b)	\
    (This)->lpVtbl -> IsReady(This,bBlock,b)


#define IDAPoint3_Project(This,cam_0,ret_1)	\
    (This)->lpVtbl -> Project(This,cam_0,ret_1)

#define IDAPoint3_get_X(This,ret_0)	\
    (This)->lpVtbl -> get_X(This,ret_0)

#define IDAPoint3_get_Y(This,ret_0)	\
    (This)->lpVtbl -> get_Y(This,ret_0)

#define IDAPoint3_get_Z(This,ret_0)	\
    (This)->lpVtbl -> get_Z(This,ret_0)

#define IDAPoint3_get_SphericalCoordXYAngle(This,ret_0)	\
    (This)->lpVtbl -> get_SphericalCoordXYAngle(This,ret_0)

#define IDAPoint3_get_SphericalCoordYZAngle(This,ret_0)	\
    (This)->lpVtbl -> get_SphericalCoordYZAngle(This,ret_0)

#define IDAPoint3_get_SphericalCoordLength(This,ret_0)	\
    (This)->lpVtbl -> get_SphericalCoordLength(This,ret_0)

#define IDAPoint3_Transform(This,xf_0,ret_1)	\
    (This)->lpVtbl -> Transform(This,xf_0,ret_1)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDAPoint3_Project_Proxy( 
    IDAPoint3 * This,
    /* [in] */ IDACamera *cam_0,
    /* [retval][out] */ IDAPoint2 **ret_1);



/* [propget] */ HRESULT STDMETHODCALLTYPE IDAPoint3_get_X_Proxy( 
    IDAPoint3 * This,
    /* [retval][out] */ IDANumber **ret_0);



/* [propget] */ HRESULT STDMETHODCALLTYPE IDAPoint3_get_Y_Proxy( 
    IDAPoint3 * This,
    /* [retval][out] */ IDANumber **ret_0);



/* [propget] */ HRESULT STDMETHODCALLTYPE IDAPoint3_get_Z_Proxy( 
    IDAPoint3 * This,
    /* [retval][out] */ IDANumber **ret_0);



/* [propget] */ HRESULT STDMETHODCALLTYPE IDAPoint3_get_SphericalCoordXYAngle_Proxy( 
    IDAPoint3 * This,
    /* [retval][out] */ IDANumber **ret_0);



/* [propget] */ HRESULT STDMETHODCALLTYPE IDAPoint3_get_SphericalCoordYZAngle_Proxy( 
    IDAPoint3 * This,
    /* [retval][out] */ IDANumber **ret_0);



/* [propget] */ HRESULT STDMETHODCALLTYPE IDAPoint3_get_SphericalCoordLength_Proxy( 
    IDAPoint3 * This,
    /* [retval][out] */ IDANumber **ret_0);



HRESULT STDMETHODCALLTYPE IDAPoint3_Transform_Proxy( 
    IDAPoint3 * This,
    /* [in] */ IDATransform3 *xf_0,
    /* [retval][out] */ IDAPoint3 **ret_1);




#endif 	/* __IDAPoint3_INTERFACE_DEFINED__ */


#ifndef __IDASound_INTERFACE_DEFINED__
#define __IDASound_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDASound
 * at Tue Nov 11 05:16:35 1997
 * using MIDL 3.02.88
 ****************************************/
/* [dual][hidden][oleautomation][unique][object][local][helpstring][uuid] */ 



EXTERN_C const IID IID_IDASound;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("C46C1BE3-3C52-11d0-9200-848C1D000000")
    IDASound : public IDABehavior
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE PhaseAnim( 
            /* [in] */ IDANumber *phaseAmt_0,
            /* [retval][out] */ IDASound **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Phase( 
            /* [in] */ double phaseAmt_0,
            /* [retval][out] */ IDASound **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RateAnim( 
            /* [in] */ IDANumber *pitchShift_0,
            /* [retval][out] */ IDASound **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Rate( 
            /* [in] */ double pitchShift_0,
            /* [retval][out] */ IDASound **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PanAnim( 
            /* [in] */ IDANumber *panAmt_0,
            /* [retval][out] */ IDASound **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Pan( 
            /* [in] */ double panAmt_0,
            /* [retval][out] */ IDASound **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GainAnim( 
            /* [in] */ IDANumber *gainAmt_0,
            /* [retval][out] */ IDASound **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Gain( 
            /* [in] */ double gainAmt_0,
            /* [retval][out] */ IDASound **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Loop( 
            /* [retval][out] */ IDASound **ret_0) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDASoundVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDASound * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDASound * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDASound * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDASound * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDASound * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDASound * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDASound * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassName )( 
            IDASound * This,
            /* [retval][out] */ BSTR *pClassName);
        
        HRESULT ( STDMETHODCALLTYPE *Init )( 
            IDASound * This,
            /* [in] */ IDABehavior *toBvr);
        
        HRESULT ( STDMETHODCALLTYPE *Importance )( 
            IDASound * This,
            /* [in] */ double relativeImportance,
            /* [retval][out] */ IDABehavior **ppBvr);
        
        HRESULT ( STDMETHODCALLTYPE *RunOnce )( 
            IDASound * This,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *SubstituteTime )( 
            IDASound * This,
            /* [in] */ IDANumber *xform,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *SwitchTo )( 
            IDASound * This,
            /* [in] */ IDABehavior *switchTo);
        
        HRESULT ( STDMETHODCALLTYPE *SwitchToNumber )( 
            IDASound * This,
            /* [in] */ double numToSwitchTo);
        
        HRESULT ( STDMETHODCALLTYPE *SwitchToString )( 
            IDASound * This,
            /* [in] */ BSTR strToSwitchTo);
        
        HRESULT ( STDMETHODCALLTYPE *Hook )( 
            IDASound * This,
            /* [in] */ IDABvrHook *notifier,
            /* [retval][out] */ IDABehavior **pBvr);
        
        HRESULT ( STDMETHODCALLTYPE *Duration )( 
            IDASound * This,
            /* [in] */ double duration,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *DurationAnim )( 
            IDASound * This,
            /* [in] */ IDANumber *duration,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *Repeat )( 
            IDASound * This,
            /* [in] */ LONG count,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *RepeatForever )( 
            IDASound * This,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *IsReady )( 
            IDASound * This,
            /* [in] */ VARIANT_BOOL bBlock,
            /* [retval][out] */ VARIANT_BOOL *b);
        
        HRESULT ( STDMETHODCALLTYPE *PhaseAnim )( 
            IDASound * This,
            /* [in] */ IDANumber *phaseAmt_0,
            /* [retval][out] */ IDASound **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *Phase )( 
            IDASound * This,
            /* [in] */ double phaseAmt_0,
            /* [retval][out] */ IDASound **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *RateAnim )( 
            IDASound * This,
            /* [in] */ IDANumber *pitchShift_0,
            /* [retval][out] */ IDASound **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *Rate )( 
            IDASound * This,
            /* [in] */ double pitchShift_0,
            /* [retval][out] */ IDASound **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *PanAnim )( 
            IDASound * This,
            /* [in] */ IDANumber *panAmt_0,
            /* [retval][out] */ IDASound **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *Pan )( 
            IDASound * This,
            /* [in] */ double panAmt_0,
            /* [retval][out] */ IDASound **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *GainAnim )( 
            IDASound * This,
            /* [in] */ IDANumber *gainAmt_0,
            /* [retval][out] */ IDASound **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *Gain )( 
            IDASound * This,
            /* [in] */ double gainAmt_0,
            /* [retval][out] */ IDASound **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *Loop )( 
            IDASound * This,
            /* [retval][out] */ IDASound **ret_0);
        
        END_INTERFACE
    } IDASoundVtbl;

    interface IDASound
    {
        CONST_VTBL struct IDASoundVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDASound_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDASound_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDASound_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDASound_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDASound_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDASound_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDASound_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDASound_GetClassName(This,pClassName)	\
    (This)->lpVtbl -> GetClassName(This,pClassName)

#define IDASound_Init(This,toBvr)	\
    (This)->lpVtbl -> Init(This,toBvr)

#define IDASound_Importance(This,relativeImportance,ppBvr)	\
    (This)->lpVtbl -> Importance(This,relativeImportance,ppBvr)

#define IDASound_RunOnce(This,bvr)	\
    (This)->lpVtbl -> RunOnce(This,bvr)

#define IDASound_SubstituteTime(This,xform,bvr)	\
    (This)->lpVtbl -> SubstituteTime(This,xform,bvr)

#define IDASound_SwitchTo(This,switchTo)	\
    (This)->lpVtbl -> SwitchTo(This,switchTo)

#define IDASound_SwitchToNumber(This,numToSwitchTo)	\
    (This)->lpVtbl -> SwitchToNumber(This,numToSwitchTo)

#define IDASound_SwitchToString(This,strToSwitchTo)	\
    (This)->lpVtbl -> SwitchToString(This,strToSwitchTo)

#define IDASound_Hook(This,notifier,pBvr)	\
    (This)->lpVtbl -> Hook(This,notifier,pBvr)

#define IDASound_Duration(This,duration,bvr)	\
    (This)->lpVtbl -> Duration(This,duration,bvr)

#define IDASound_DurationAnim(This,duration,bvr)	\
    (This)->lpVtbl -> DurationAnim(This,duration,bvr)

#define IDASound_Repeat(This,count,bvr)	\
    (This)->lpVtbl -> Repeat(This,count,bvr)

#define IDASound_RepeatForever(This,bvr)	\
    (This)->lpVtbl -> RepeatForever(This,bvr)

#define IDASound_IsReady(This,bBlock,b)	\
    (This)->lpVtbl -> IsReady(This,bBlock,b)


#define IDASound_PhaseAnim(This,phaseAmt_0,ret_1)	\
    (This)->lpVtbl -> PhaseAnim(This,phaseAmt_0,ret_1)

#define IDASound_Phase(This,phaseAmt_0,ret_1)	\
    (This)->lpVtbl -> Phase(This,phaseAmt_0,ret_1)

#define IDASound_RateAnim(This,pitchShift_0,ret_1)	\
    (This)->lpVtbl -> RateAnim(This,pitchShift_0,ret_1)

#define IDASound_Rate(This,pitchShift_0,ret_1)	\
    (This)->lpVtbl -> Rate(This,pitchShift_0,ret_1)

#define IDASound_PanAnim(This,panAmt_0,ret_1)	\
    (This)->lpVtbl -> PanAnim(This,panAmt_0,ret_1)

#define IDASound_Pan(This,panAmt_0,ret_1)	\
    (This)->lpVtbl -> Pan(This,panAmt_0,ret_1)

#define IDASound_GainAnim(This,gainAmt_0,ret_1)	\
    (This)->lpVtbl -> GainAnim(This,gainAmt_0,ret_1)

#define IDASound_Gain(This,gainAmt_0,ret_1)	\
    (This)->lpVtbl -> Gain(This,gainAmt_0,ret_1)

#define IDASound_Loop(This,ret_0)	\
    (This)->lpVtbl -> Loop(This,ret_0)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDASound_PhaseAnim_Proxy( 
    IDASound * This,
    /* [in] */ IDANumber *phaseAmt_0,
    /* [retval][out] */ IDASound **ret_1);



HRESULT STDMETHODCALLTYPE IDASound_Phase_Proxy( 
    IDASound * This,
    /* [in] */ double phaseAmt_0,
    /* [retval][out] */ IDASound **ret_1);



HRESULT STDMETHODCALLTYPE IDASound_RateAnim_Proxy( 
    IDASound * This,
    /* [in] */ IDANumber *pitchShift_0,
    /* [retval][out] */ IDASound **ret_1);



HRESULT STDMETHODCALLTYPE IDASound_Rate_Proxy( 
    IDASound * This,
    /* [in] */ double pitchShift_0,
    /* [retval][out] */ IDASound **ret_1);



HRESULT STDMETHODCALLTYPE IDASound_PanAnim_Proxy( 
    IDASound * This,
    /* [in] */ IDANumber *panAmt_0,
    /* [retval][out] */ IDASound **ret_1);



HRESULT STDMETHODCALLTYPE IDASound_Pan_Proxy( 
    IDASound * This,
    /* [in] */ double panAmt_0,
    /* [retval][out] */ IDASound **ret_1);



HRESULT STDMETHODCALLTYPE IDASound_GainAnim_Proxy( 
    IDASound * This,
    /* [in] */ IDANumber *gainAmt_0,
    /* [retval][out] */ IDASound **ret_1);



HRESULT STDMETHODCALLTYPE IDASound_Gain_Proxy( 
    IDASound * This,
    /* [in] */ double gainAmt_0,
    /* [retval][out] */ IDASound **ret_1);



HRESULT STDMETHODCALLTYPE IDASound_Loop_Proxy( 
    IDASound * This,
    /* [retval][out] */ IDASound **ret_0);




#endif 	/* __IDASound_INTERFACE_DEFINED__ */


#ifndef __IDAString_INTERFACE_DEFINED__
#define __IDAString_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDAString
 * at Tue Nov 11 05:16:35 1997
 * using MIDL 3.02.88
 ****************************************/
/* [dual][hidden][oleautomation][unique][object][local][helpstring][uuid] */ 



EXTERN_C const IID IID_IDAString;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("C46C1BC3-3C52-11d0-9200-848C1D000000")
    IDAString : public IDABehavior
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Extract( 
            /* [retval][out] */ BSTR *ret_0) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AnimateProperty( 
            /* [in] */ BSTR propertyPath_0,
            /* [in] */ BSTR scriptingLanguage_1,
            /* [in] */ VARIANT_BOOL invokeAsMethod_2,
            /* [in] */ double minUpdateInterval_3,
            /* [retval][out] */ IDAString **ret_4) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDAStringVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDAString * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDAString * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDAString * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDAString * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDAString * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDAString * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDAString * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassName )( 
            IDAString * This,
            /* [retval][out] */ BSTR *pClassName);
        
        HRESULT ( STDMETHODCALLTYPE *Init )( 
            IDAString * This,
            /* [in] */ IDABehavior *toBvr);
        
        HRESULT ( STDMETHODCALLTYPE *Importance )( 
            IDAString * This,
            /* [in] */ double relativeImportance,
            /* [retval][out] */ IDABehavior **ppBvr);
        
        HRESULT ( STDMETHODCALLTYPE *RunOnce )( 
            IDAString * This,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *SubstituteTime )( 
            IDAString * This,
            /* [in] */ IDANumber *xform,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *SwitchTo )( 
            IDAString * This,
            /* [in] */ IDABehavior *switchTo);
        
        HRESULT ( STDMETHODCALLTYPE *SwitchToNumber )( 
            IDAString * This,
            /* [in] */ double numToSwitchTo);
        
        HRESULT ( STDMETHODCALLTYPE *SwitchToString )( 
            IDAString * This,
            /* [in] */ BSTR strToSwitchTo);
        
        HRESULT ( STDMETHODCALLTYPE *Hook )( 
            IDAString * This,
            /* [in] */ IDABvrHook *notifier,
            /* [retval][out] */ IDABehavior **pBvr);
        
        HRESULT ( STDMETHODCALLTYPE *Duration )( 
            IDAString * This,
            /* [in] */ double duration,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *DurationAnim )( 
            IDAString * This,
            /* [in] */ IDANumber *duration,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *Repeat )( 
            IDAString * This,
            /* [in] */ LONG count,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *RepeatForever )( 
            IDAString * This,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *IsReady )( 
            IDAString * This,
            /* [in] */ VARIANT_BOOL bBlock,
            /* [retval][out] */ VARIANT_BOOL *b);
        
        HRESULT ( STDMETHODCALLTYPE *Extract )( 
            IDAString * This,
            /* [retval][out] */ BSTR *ret_0);
        
        HRESULT ( STDMETHODCALLTYPE *AnimateProperty )( 
            IDAString * This,
            /* [in] */ BSTR propertyPath_0,
            /* [in] */ BSTR scriptingLanguage_1,
            /* [in] */ VARIANT_BOOL invokeAsMethod_2,
            /* [in] */ double minUpdateInterval_3,
            /* [retval][out] */ IDAString **ret_4);
        
        END_INTERFACE
    } IDAStringVtbl;

    interface IDAString
    {
        CONST_VTBL struct IDAStringVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDAString_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDAString_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDAString_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDAString_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDAString_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDAString_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDAString_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDAString_GetClassName(This,pClassName)	\
    (This)->lpVtbl -> GetClassName(This,pClassName)

#define IDAString_Init(This,toBvr)	\
    (This)->lpVtbl -> Init(This,toBvr)

#define IDAString_Importance(This,relativeImportance,ppBvr)	\
    (This)->lpVtbl -> Importance(This,relativeImportance,ppBvr)

#define IDAString_RunOnce(This,bvr)	\
    (This)->lpVtbl -> RunOnce(This,bvr)

#define IDAString_SubstituteTime(This,xform,bvr)	\
    (This)->lpVtbl -> SubstituteTime(This,xform,bvr)

#define IDAString_SwitchTo(This,switchTo)	\
    (This)->lpVtbl -> SwitchTo(This,switchTo)

#define IDAString_SwitchToNumber(This,numToSwitchTo)	\
    (This)->lpVtbl -> SwitchToNumber(This,numToSwitchTo)

#define IDAString_SwitchToString(This,strToSwitchTo)	\
    (This)->lpVtbl -> SwitchToString(This,strToSwitchTo)

#define IDAString_Hook(This,notifier,pBvr)	\
    (This)->lpVtbl -> Hook(This,notifier,pBvr)

#define IDAString_Duration(This,duration,bvr)	\
    (This)->lpVtbl -> Duration(This,duration,bvr)

#define IDAString_DurationAnim(This,duration,bvr)	\
    (This)->lpVtbl -> DurationAnim(This,duration,bvr)

#define IDAString_Repeat(This,count,bvr)	\
    (This)->lpVtbl -> Repeat(This,count,bvr)

#define IDAString_RepeatForever(This,bvr)	\
    (This)->lpVtbl -> RepeatForever(This,bvr)

#define IDAString_IsReady(This,bBlock,b)	\
    (This)->lpVtbl -> IsReady(This,bBlock,b)


#define IDAString_Extract(This,ret_0)	\
    (This)->lpVtbl -> Extract(This,ret_0)

#define IDAString_AnimateProperty(This,propertyPath_0,scriptingLanguage_1,invokeAsMethod_2,minUpdateInterval_3,ret_4)	\
    (This)->lpVtbl -> AnimateProperty(This,propertyPath_0,scriptingLanguage_1,invokeAsMethod_2,minUpdateInterval_3,ret_4)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDAString_Extract_Proxy( 
    IDAString * This,
    /* [retval][out] */ BSTR *ret_0);



HRESULT STDMETHODCALLTYPE IDAString_AnimateProperty_Proxy( 
    IDAString * This,
    /* [in] */ BSTR propertyPath_0,
    /* [in] */ BSTR scriptingLanguage_1,
    /* [in] */ VARIANT_BOOL invokeAsMethod_2,
    /* [in] */ double minUpdateInterval_3,
    /* [retval][out] */ IDAString **ret_4);




#endif 	/* __IDAString_INTERFACE_DEFINED__ */


#ifndef __IDATransform2_INTERFACE_DEFINED__
#define __IDATransform2_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDATransform2
 * at Tue Nov 11 05:16:35 1997
 * using MIDL 3.02.88
 ****************************************/
/* [dual][hidden][oleautomation][unique][object][local][helpstring][uuid] */ 



EXTERN_C const IID IID_IDATransform2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("C46C1BCB-3C52-11d0-9200-848C1D000000")
    IDATransform2 : public IDABehavior
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Inverse( 
            /* [retval][out] */ IDATransform2 **ret_0) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_IsSingular( 
            /* [retval][out] */ IDABoolean **ret_0) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDATransform2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDATransform2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDATransform2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDATransform2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDATransform2 * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDATransform2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDATransform2 * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDATransform2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassName )( 
            IDATransform2 * This,
            /* [retval][out] */ BSTR *pClassName);
        
        HRESULT ( STDMETHODCALLTYPE *Init )( 
            IDATransform2 * This,
            /* [in] */ IDABehavior *toBvr);
        
        HRESULT ( STDMETHODCALLTYPE *Importance )( 
            IDATransform2 * This,
            /* [in] */ double relativeImportance,
            /* [retval][out] */ IDABehavior **ppBvr);
        
        HRESULT ( STDMETHODCALLTYPE *RunOnce )( 
            IDATransform2 * This,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *SubstituteTime )( 
            IDATransform2 * This,
            /* [in] */ IDANumber *xform,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *SwitchTo )( 
            IDATransform2 * This,
            /* [in] */ IDABehavior *switchTo);
        
        HRESULT ( STDMETHODCALLTYPE *SwitchToNumber )( 
            IDATransform2 * This,
            /* [in] */ double numToSwitchTo);
        
        HRESULT ( STDMETHODCALLTYPE *SwitchToString )( 
            IDATransform2 * This,
            /* [in] */ BSTR strToSwitchTo);
        
        HRESULT ( STDMETHODCALLTYPE *Hook )( 
            IDATransform2 * This,
            /* [in] */ IDABvrHook *notifier,
            /* [retval][out] */ IDABehavior **pBvr);
        
        HRESULT ( STDMETHODCALLTYPE *Duration )( 
            IDATransform2 * This,
            /* [in] */ double duration,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *DurationAnim )( 
            IDATransform2 * This,
            /* [in] */ IDANumber *duration,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *Repeat )( 
            IDATransform2 * This,
            /* [in] */ LONG count,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *RepeatForever )( 
            IDATransform2 * This,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *IsReady )( 
            IDATransform2 * This,
            /* [in] */ VARIANT_BOOL bBlock,
            /* [retval][out] */ VARIANT_BOOL *b);
        
        HRESULT ( STDMETHODCALLTYPE *Inverse )( 
            IDATransform2 * This,
            /* [retval][out] */ IDATransform2 **ret_0);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsSingular )( 
            IDATransform2 * This,
            /* [retval][out] */ IDABoolean **ret_0);
        
        END_INTERFACE
    } IDATransform2Vtbl;

    interface IDATransform2
    {
        CONST_VTBL struct IDATransform2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDATransform2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDATransform2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDATransform2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDATransform2_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDATransform2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDATransform2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDATransform2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDATransform2_GetClassName(This,pClassName)	\
    (This)->lpVtbl -> GetClassName(This,pClassName)

#define IDATransform2_Init(This,toBvr)	\
    (This)->lpVtbl -> Init(This,toBvr)

#define IDATransform2_Importance(This,relativeImportance,ppBvr)	\
    (This)->lpVtbl -> Importance(This,relativeImportance,ppBvr)

#define IDATransform2_RunOnce(This,bvr)	\
    (This)->lpVtbl -> RunOnce(This,bvr)

#define IDATransform2_SubstituteTime(This,xform,bvr)	\
    (This)->lpVtbl -> SubstituteTime(This,xform,bvr)

#define IDATransform2_SwitchTo(This,switchTo)	\
    (This)->lpVtbl -> SwitchTo(This,switchTo)

#define IDATransform2_SwitchToNumber(This,numToSwitchTo)	\
    (This)->lpVtbl -> SwitchToNumber(This,numToSwitchTo)

#define IDATransform2_SwitchToString(This,strToSwitchTo)	\
    (This)->lpVtbl -> SwitchToString(This,strToSwitchTo)

#define IDATransform2_Hook(This,notifier,pBvr)	\
    (This)->lpVtbl -> Hook(This,notifier,pBvr)

#define IDATransform2_Duration(This,duration,bvr)	\
    (This)->lpVtbl -> Duration(This,duration,bvr)

#define IDATransform2_DurationAnim(This,duration,bvr)	\
    (This)->lpVtbl -> DurationAnim(This,duration,bvr)

#define IDATransform2_Repeat(This,count,bvr)	\
    (This)->lpVtbl -> Repeat(This,count,bvr)

#define IDATransform2_RepeatForever(This,bvr)	\
    (This)->lpVtbl -> RepeatForever(This,bvr)

#define IDATransform2_IsReady(This,bBlock,b)	\
    (This)->lpVtbl -> IsReady(This,bBlock,b)


#define IDATransform2_Inverse(This,ret_0)	\
    (This)->lpVtbl -> Inverse(This,ret_0)

#define IDATransform2_get_IsSingular(This,ret_0)	\
    (This)->lpVtbl -> get_IsSingular(This,ret_0)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDATransform2_Inverse_Proxy( 
    IDATransform2 * This,
    /* [retval][out] */ IDATransform2 **ret_0);



/* [propget] */ HRESULT STDMETHODCALLTYPE IDATransform2_get_IsSingular_Proxy( 
    IDATransform2 * This,
    /* [retval][out] */ IDABoolean **ret_0);




#endif 	/* __IDATransform2_INTERFACE_DEFINED__ */


#ifndef __IDATransform3_INTERFACE_DEFINED__
#define __IDATransform3_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDATransform3
 * at Tue Nov 11 05:16:35 1997
 * using MIDL 3.02.88
 ****************************************/
/* [dual][hidden][oleautomation][unique][object][local][helpstring][uuid] */ 



EXTERN_C const IID IID_IDATransform3;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("C46C1BDB-3C52-11d0-9200-848C1D000000")
    IDATransform3 : public IDABehavior
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Inverse( 
            /* [retval][out] */ IDATransform3 **ret_0) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_IsSingular( 
            /* [retval][out] */ IDABoolean **ret_0) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ParallelTransform2( 
            /* [retval][out] */ IDATransform2 **ret_0) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDATransform3Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDATransform3 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDATransform3 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDATransform3 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDATransform3 * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDATransform3 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDATransform3 * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDATransform3 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassName )( 
            IDATransform3 * This,
            /* [retval][out] */ BSTR *pClassName);
        
        HRESULT ( STDMETHODCALLTYPE *Init )( 
            IDATransform3 * This,
            /* [in] */ IDABehavior *toBvr);
        
        HRESULT ( STDMETHODCALLTYPE *Importance )( 
            IDATransform3 * This,
            /* [in] */ double relativeImportance,
            /* [retval][out] */ IDABehavior **ppBvr);
        
        HRESULT ( STDMETHODCALLTYPE *RunOnce )( 
            IDATransform3 * This,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *SubstituteTime )( 
            IDATransform3 * This,
            /* [in] */ IDANumber *xform,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *SwitchTo )( 
            IDATransform3 * This,
            /* [in] */ IDABehavior *switchTo);
        
        HRESULT ( STDMETHODCALLTYPE *SwitchToNumber )( 
            IDATransform3 * This,
            /* [in] */ double numToSwitchTo);
        
        HRESULT ( STDMETHODCALLTYPE *SwitchToString )( 
            IDATransform3 * This,
            /* [in] */ BSTR strToSwitchTo);
        
        HRESULT ( STDMETHODCALLTYPE *Hook )( 
            IDATransform3 * This,
            /* [in] */ IDABvrHook *notifier,
            /* [retval][out] */ IDABehavior **pBvr);
        
        HRESULT ( STDMETHODCALLTYPE *Duration )( 
            IDATransform3 * This,
            /* [in] */ double duration,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *DurationAnim )( 
            IDATransform3 * This,
            /* [in] */ IDANumber *duration,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *Repeat )( 
            IDATransform3 * This,
            /* [in] */ LONG count,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *RepeatForever )( 
            IDATransform3 * This,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *IsReady )( 
            IDATransform3 * This,
            /* [in] */ VARIANT_BOOL bBlock,
            /* [retval][out] */ VARIANT_BOOL *b);
        
        HRESULT ( STDMETHODCALLTYPE *Inverse )( 
            IDATransform3 * This,
            /* [retval][out] */ IDATransform3 **ret_0);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsSingular )( 
            IDATransform3 * This,
            /* [retval][out] */ IDABoolean **ret_0);
        
        HRESULT ( STDMETHODCALLTYPE *ParallelTransform2 )( 
            IDATransform3 * This,
            /* [retval][out] */ IDATransform2 **ret_0);
        
        END_INTERFACE
    } IDATransform3Vtbl;

    interface IDATransform3
    {
        CONST_VTBL struct IDATransform3Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDATransform3_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDATransform3_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDATransform3_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDATransform3_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDATransform3_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDATransform3_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDATransform3_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDATransform3_GetClassName(This,pClassName)	\
    (This)->lpVtbl -> GetClassName(This,pClassName)

#define IDATransform3_Init(This,toBvr)	\
    (This)->lpVtbl -> Init(This,toBvr)

#define IDATransform3_Importance(This,relativeImportance,ppBvr)	\
    (This)->lpVtbl -> Importance(This,relativeImportance,ppBvr)

#define IDATransform3_RunOnce(This,bvr)	\
    (This)->lpVtbl -> RunOnce(This,bvr)

#define IDATransform3_SubstituteTime(This,xform,bvr)	\
    (This)->lpVtbl -> SubstituteTime(This,xform,bvr)

#define IDATransform3_SwitchTo(This,switchTo)	\
    (This)->lpVtbl -> SwitchTo(This,switchTo)

#define IDATransform3_SwitchToNumber(This,numToSwitchTo)	\
    (This)->lpVtbl -> SwitchToNumber(This,numToSwitchTo)

#define IDATransform3_SwitchToString(This,strToSwitchTo)	\
    (This)->lpVtbl -> SwitchToString(This,strToSwitchTo)

#define IDATransform3_Hook(This,notifier,pBvr)	\
    (This)->lpVtbl -> Hook(This,notifier,pBvr)

#define IDATransform3_Duration(This,duration,bvr)	\
    (This)->lpVtbl -> Duration(This,duration,bvr)

#define IDATransform3_DurationAnim(This,duration,bvr)	\
    (This)->lpVtbl -> DurationAnim(This,duration,bvr)

#define IDATransform3_Repeat(This,count,bvr)	\
    (This)->lpVtbl -> Repeat(This,count,bvr)

#define IDATransform3_RepeatForever(This,bvr)	\
    (This)->lpVtbl -> RepeatForever(This,bvr)

#define IDATransform3_IsReady(This,bBlock,b)	\
    (This)->lpVtbl -> IsReady(This,bBlock,b)


#define IDATransform3_Inverse(This,ret_0)	\
    (This)->lpVtbl -> Inverse(This,ret_0)

#define IDATransform3_get_IsSingular(This,ret_0)	\
    (This)->lpVtbl -> get_IsSingular(This,ret_0)

#define IDATransform3_ParallelTransform2(This,ret_0)	\
    (This)->lpVtbl -> ParallelTransform2(This,ret_0)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDATransform3_Inverse_Proxy( 
    IDATransform3 * This,
    /* [retval][out] */ IDATransform3 **ret_0);



/* [propget] */ HRESULT STDMETHODCALLTYPE IDATransform3_get_IsSingular_Proxy( 
    IDATransform3 * This,
    /* [retval][out] */ IDABoolean **ret_0);



HRESULT STDMETHODCALLTYPE IDATransform3_ParallelTransform2_Proxy( 
    IDATransform3 * This,
    /* [retval][out] */ IDATransform2 **ret_0);




#endif 	/* __IDATransform3_INTERFACE_DEFINED__ */


#ifndef __IDAVector2_INTERFACE_DEFINED__
#define __IDAVector2_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDAVector2
 * at Tue Nov 11 05:16:35 1997
 * using MIDL 3.02.88
 ****************************************/
/* [dual][hidden][oleautomation][unique][object][local][helpstring][uuid] */ 



EXTERN_C const IID IID_IDAVector2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("C46C1BC9-3C52-11d0-9200-848C1D000000")
    IDAVector2 : public IDABehavior
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Length( 
            /* [retval][out] */ IDANumber **ret_0) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_LengthSquared( 
            /* [retval][out] */ IDANumber **ret_0) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Normalize( 
            /* [retval][out] */ IDAVector2 **ret_0) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MulAnim( 
            /* [in] */ IDANumber *scalar_0,
            /* [retval][out] */ IDAVector2 **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Mul( 
            /* [in] */ double scalar_0,
            /* [retval][out] */ IDAVector2 **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DivAnim( 
            /* [in] */ IDANumber *scalar_0,
            /* [retval][out] */ IDAVector2 **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Div( 
            /* [in] */ double scalar_0,
            /* [retval][out] */ IDAVector2 **ret_1) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_X( 
            /* [retval][out] */ IDANumber **ret_0) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Y( 
            /* [retval][out] */ IDANumber **ret_0) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_PolarCoordAngle( 
            /* [retval][out] */ IDANumber **ret_0) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_PolarCoordLength( 
            /* [retval][out] */ IDANumber **ret_0) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Transform( 
            /* [in] */ IDATransform2 *xf_0,
            /* [retval][out] */ IDAVector2 **ret_1) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDAVector2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDAVector2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDAVector2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDAVector2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDAVector2 * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDAVector2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDAVector2 * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDAVector2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassName )( 
            IDAVector2 * This,
            /* [retval][out] */ BSTR *pClassName);
        
        HRESULT ( STDMETHODCALLTYPE *Init )( 
            IDAVector2 * This,
            /* [in] */ IDABehavior *toBvr);
        
        HRESULT ( STDMETHODCALLTYPE *Importance )( 
            IDAVector2 * This,
            /* [in] */ double relativeImportance,
            /* [retval][out] */ IDABehavior **ppBvr);
        
        HRESULT ( STDMETHODCALLTYPE *RunOnce )( 
            IDAVector2 * This,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *SubstituteTime )( 
            IDAVector2 * This,
            /* [in] */ IDANumber *xform,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *SwitchTo )( 
            IDAVector2 * This,
            /* [in] */ IDABehavior *switchTo);
        
        HRESULT ( STDMETHODCALLTYPE *SwitchToNumber )( 
            IDAVector2 * This,
            /* [in] */ double numToSwitchTo);
        
        HRESULT ( STDMETHODCALLTYPE *SwitchToString )( 
            IDAVector2 * This,
            /* [in] */ BSTR strToSwitchTo);
        
        HRESULT ( STDMETHODCALLTYPE *Hook )( 
            IDAVector2 * This,
            /* [in] */ IDABvrHook *notifier,
            /* [retval][out] */ IDABehavior **pBvr);
        
        HRESULT ( STDMETHODCALLTYPE *Duration )( 
            IDAVector2 * This,
            /* [in] */ double duration,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *DurationAnim )( 
            IDAVector2 * This,
            /* [in] */ IDANumber *duration,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *Repeat )( 
            IDAVector2 * This,
            /* [in] */ LONG count,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *RepeatForever )( 
            IDAVector2 * This,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *IsReady )( 
            IDAVector2 * This,
            /* [in] */ VARIANT_BOOL bBlock,
            /* [retval][out] */ VARIANT_BOOL *b);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Length )( 
            IDAVector2 * This,
            /* [retval][out] */ IDANumber **ret_0);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_LengthSquared )( 
            IDAVector2 * This,
            /* [retval][out] */ IDANumber **ret_0);
        
        HRESULT ( STDMETHODCALLTYPE *Normalize )( 
            IDAVector2 * This,
            /* [retval][out] */ IDAVector2 **ret_0);
        
        HRESULT ( STDMETHODCALLTYPE *MulAnim )( 
            IDAVector2 * This,
            /* [in] */ IDANumber *scalar_0,
            /* [retval][out] */ IDAVector2 **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *Mul )( 
            IDAVector2 * This,
            /* [in] */ double scalar_0,
            /* [retval][out] */ IDAVector2 **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *DivAnim )( 
            IDAVector2 * This,
            /* [in] */ IDANumber *scalar_0,
            /* [retval][out] */ IDAVector2 **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *Div )( 
            IDAVector2 * This,
            /* [in] */ double scalar_0,
            /* [retval][out] */ IDAVector2 **ret_1);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_X )( 
            IDAVector2 * This,
            /* [retval][out] */ IDANumber **ret_0);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Y )( 
            IDAVector2 * This,
            /* [retval][out] */ IDANumber **ret_0);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_PolarCoordAngle )( 
            IDAVector2 * This,
            /* [retval][out] */ IDANumber **ret_0);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_PolarCoordLength )( 
            IDAVector2 * This,
            /* [retval][out] */ IDANumber **ret_0);
        
        HRESULT ( STDMETHODCALLTYPE *Transform )( 
            IDAVector2 * This,
            /* [in] */ IDATransform2 *xf_0,
            /* [retval][out] */ IDAVector2 **ret_1);
        
        END_INTERFACE
    } IDAVector2Vtbl;

    interface IDAVector2
    {
        CONST_VTBL struct IDAVector2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDAVector2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDAVector2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDAVector2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDAVector2_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDAVector2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDAVector2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDAVector2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDAVector2_GetClassName(This,pClassName)	\
    (This)->lpVtbl -> GetClassName(This,pClassName)

#define IDAVector2_Init(This,toBvr)	\
    (This)->lpVtbl -> Init(This,toBvr)

#define IDAVector2_Importance(This,relativeImportance,ppBvr)	\
    (This)->lpVtbl -> Importance(This,relativeImportance,ppBvr)

#define IDAVector2_RunOnce(This,bvr)	\
    (This)->lpVtbl -> RunOnce(This,bvr)

#define IDAVector2_SubstituteTime(This,xform,bvr)	\
    (This)->lpVtbl -> SubstituteTime(This,xform,bvr)

#define IDAVector2_SwitchTo(This,switchTo)	\
    (This)->lpVtbl -> SwitchTo(This,switchTo)

#define IDAVector2_SwitchToNumber(This,numToSwitchTo)	\
    (This)->lpVtbl -> SwitchToNumber(This,numToSwitchTo)

#define IDAVector2_SwitchToString(This,strToSwitchTo)	\
    (This)->lpVtbl -> SwitchToString(This,strToSwitchTo)

#define IDAVector2_Hook(This,notifier,pBvr)	\
    (This)->lpVtbl -> Hook(This,notifier,pBvr)

#define IDAVector2_Duration(This,duration,bvr)	\
    (This)->lpVtbl -> Duration(This,duration,bvr)

#define IDAVector2_DurationAnim(This,duration,bvr)	\
    (This)->lpVtbl -> DurationAnim(This,duration,bvr)

#define IDAVector2_Repeat(This,count,bvr)	\
    (This)->lpVtbl -> Repeat(This,count,bvr)

#define IDAVector2_RepeatForever(This,bvr)	\
    (This)->lpVtbl -> RepeatForever(This,bvr)

#define IDAVector2_IsReady(This,bBlock,b)	\
    (This)->lpVtbl -> IsReady(This,bBlock,b)


#define IDAVector2_get_Length(This,ret_0)	\
    (This)->lpVtbl -> get_Length(This,ret_0)

#define IDAVector2_get_LengthSquared(This,ret_0)	\
    (This)->lpVtbl -> get_LengthSquared(This,ret_0)

#define IDAVector2_Normalize(This,ret_0)	\
    (This)->lpVtbl -> Normalize(This,ret_0)

#define IDAVector2_MulAnim(This,scalar_0,ret_1)	\
    (This)->lpVtbl -> MulAnim(This,scalar_0,ret_1)

#define IDAVector2_Mul(This,scalar_0,ret_1)	\
    (This)->lpVtbl -> Mul(This,scalar_0,ret_1)

#define IDAVector2_DivAnim(This,scalar_0,ret_1)	\
    (This)->lpVtbl -> DivAnim(This,scalar_0,ret_1)

#define IDAVector2_Div(This,scalar_0,ret_1)	\
    (This)->lpVtbl -> Div(This,scalar_0,ret_1)

#define IDAVector2_get_X(This,ret_0)	\
    (This)->lpVtbl -> get_X(This,ret_0)

#define IDAVector2_get_Y(This,ret_0)	\
    (This)->lpVtbl -> get_Y(This,ret_0)

#define IDAVector2_get_PolarCoordAngle(This,ret_0)	\
    (This)->lpVtbl -> get_PolarCoordAngle(This,ret_0)

#define IDAVector2_get_PolarCoordLength(This,ret_0)	\
    (This)->lpVtbl -> get_PolarCoordLength(This,ret_0)

#define IDAVector2_Transform(This,xf_0,ret_1)	\
    (This)->lpVtbl -> Transform(This,xf_0,ret_1)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget] */ HRESULT STDMETHODCALLTYPE IDAVector2_get_Length_Proxy( 
    IDAVector2 * This,
    /* [retval][out] */ IDANumber **ret_0);



/* [propget] */ HRESULT STDMETHODCALLTYPE IDAVector2_get_LengthSquared_Proxy( 
    IDAVector2 * This,
    /* [retval][out] */ IDANumber **ret_0);



HRESULT STDMETHODCALLTYPE IDAVector2_Normalize_Proxy( 
    IDAVector2 * This,
    /* [retval][out] */ IDAVector2 **ret_0);



HRESULT STDMETHODCALLTYPE IDAVector2_MulAnim_Proxy( 
    IDAVector2 * This,
    /* [in] */ IDANumber *scalar_0,
    /* [retval][out] */ IDAVector2 **ret_1);



HRESULT STDMETHODCALLTYPE IDAVector2_Mul_Proxy( 
    IDAVector2 * This,
    /* [in] */ double scalar_0,
    /* [retval][out] */ IDAVector2 **ret_1);



HRESULT STDMETHODCALLTYPE IDAVector2_DivAnim_Proxy( 
    IDAVector2 * This,
    /* [in] */ IDANumber *scalar_0,
    /* [retval][out] */ IDAVector2 **ret_1);



HRESULT STDMETHODCALLTYPE IDAVector2_Div_Proxy( 
    IDAVector2 * This,
    /* [in] */ double scalar_0,
    /* [retval][out] */ IDAVector2 **ret_1);



/* [propget] */ HRESULT STDMETHODCALLTYPE IDAVector2_get_X_Proxy( 
    IDAVector2 * This,
    /* [retval][out] */ IDANumber **ret_0);



/* [propget] */ HRESULT STDMETHODCALLTYPE IDAVector2_get_Y_Proxy( 
    IDAVector2 * This,
    /* [retval][out] */ IDANumber **ret_0);



/* [propget] */ HRESULT STDMETHODCALLTYPE IDAVector2_get_PolarCoordAngle_Proxy( 
    IDAVector2 * This,
    /* [retval][out] */ IDANumber **ret_0);



/* [propget] */ HRESULT STDMETHODCALLTYPE IDAVector2_get_PolarCoordLength_Proxy( 
    IDAVector2 * This,
    /* [retval][out] */ IDANumber **ret_0);



HRESULT STDMETHODCALLTYPE IDAVector2_Transform_Proxy( 
    IDAVector2 * This,
    /* [in] */ IDATransform2 *xf_0,
    /* [retval][out] */ IDAVector2 **ret_1);




#endif 	/* __IDAVector2_INTERFACE_DEFINED__ */


#ifndef __IDAVector3_INTERFACE_DEFINED__
#define __IDAVector3_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDAVector3
 * at Tue Nov 11 05:16:35 1997
 * using MIDL 3.02.88
 ****************************************/
/* [dual][hidden][oleautomation][unique][object][local][helpstring][uuid] */ 



EXTERN_C const IID IID_IDAVector3;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("C46C1BD9-3C52-11d0-9200-848C1D000000")
    IDAVector3 : public IDABehavior
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Length( 
            /* [retval][out] */ IDANumber **ret_0) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_LengthSquared( 
            /* [retval][out] */ IDANumber **ret_0) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Normalize( 
            /* [retval][out] */ IDAVector3 **ret_0) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MulAnim( 
            /* [in] */ IDANumber *scalar_0,
            /* [retval][out] */ IDAVector3 **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Mul( 
            /* [in] */ double scalar_0,
            /* [retval][out] */ IDAVector3 **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DivAnim( 
            /* [in] */ IDANumber *scalar_0,
            /* [retval][out] */ IDAVector3 **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Div( 
            /* [in] */ double scalar_0,
            /* [retval][out] */ IDAVector3 **ret_1) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_X( 
            /* [retval][out] */ IDANumber **ret_0) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Y( 
            /* [retval][out] */ IDANumber **ret_0) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Z( 
            /* [retval][out] */ IDANumber **ret_0) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_SphericalCoordXYAngle( 
            /* [retval][out] */ IDANumber **ret_0) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_SphericalCoordYZAngle( 
            /* [retval][out] */ IDANumber **ret_0) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_SphericalCoordLength( 
            /* [retval][out] */ IDANumber **ret_0) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Transform( 
            /* [in] */ IDATransform3 *xf_0,
            /* [retval][out] */ IDAVector3 **ret_1) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDAVector3Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDAVector3 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDAVector3 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDAVector3 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDAVector3 * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDAVector3 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDAVector3 * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDAVector3 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassName )( 
            IDAVector3 * This,
            /* [retval][out] */ BSTR *pClassName);
        
        HRESULT ( STDMETHODCALLTYPE *Init )( 
            IDAVector3 * This,
            /* [in] */ IDABehavior *toBvr);
        
        HRESULT ( STDMETHODCALLTYPE *Importance )( 
            IDAVector3 * This,
            /* [in] */ double relativeImportance,
            /* [retval][out] */ IDABehavior **ppBvr);
        
        HRESULT ( STDMETHODCALLTYPE *RunOnce )( 
            IDAVector3 * This,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *SubstituteTime )( 
            IDAVector3 * This,
            /* [in] */ IDANumber *xform,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *SwitchTo )( 
            IDAVector3 * This,
            /* [in] */ IDABehavior *switchTo);
        
        HRESULT ( STDMETHODCALLTYPE *SwitchToNumber )( 
            IDAVector3 * This,
            /* [in] */ double numToSwitchTo);
        
        HRESULT ( STDMETHODCALLTYPE *SwitchToString )( 
            IDAVector3 * This,
            /* [in] */ BSTR strToSwitchTo);
        
        HRESULT ( STDMETHODCALLTYPE *Hook )( 
            IDAVector3 * This,
            /* [in] */ IDABvrHook *notifier,
            /* [retval][out] */ IDABehavior **pBvr);
        
        HRESULT ( STDMETHODCALLTYPE *Duration )( 
            IDAVector3 * This,
            /* [in] */ double duration,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *DurationAnim )( 
            IDAVector3 * This,
            /* [in] */ IDANumber *duration,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *Repeat )( 
            IDAVector3 * This,
            /* [in] */ LONG count,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *RepeatForever )( 
            IDAVector3 * This,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *IsReady )( 
            IDAVector3 * This,
            /* [in] */ VARIANT_BOOL bBlock,
            /* [retval][out] */ VARIANT_BOOL *b);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Length )( 
            IDAVector3 * This,
            /* [retval][out] */ IDANumber **ret_0);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_LengthSquared )( 
            IDAVector3 * This,
            /* [retval][out] */ IDANumber **ret_0);
        
        HRESULT ( STDMETHODCALLTYPE *Normalize )( 
            IDAVector3 * This,
            /* [retval][out] */ IDAVector3 **ret_0);
        
        HRESULT ( STDMETHODCALLTYPE *MulAnim )( 
            IDAVector3 * This,
            /* [in] */ IDANumber *scalar_0,
            /* [retval][out] */ IDAVector3 **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *Mul )( 
            IDAVector3 * This,
            /* [in] */ double scalar_0,
            /* [retval][out] */ IDAVector3 **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *DivAnim )( 
            IDAVector3 * This,
            /* [in] */ IDANumber *scalar_0,
            /* [retval][out] */ IDAVector3 **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *Div )( 
            IDAVector3 * This,
            /* [in] */ double scalar_0,
            /* [retval][out] */ IDAVector3 **ret_1);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_X )( 
            IDAVector3 * This,
            /* [retval][out] */ IDANumber **ret_0);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Y )( 
            IDAVector3 * This,
            /* [retval][out] */ IDANumber **ret_0);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Z )( 
            IDAVector3 * This,
            /* [retval][out] */ IDANumber **ret_0);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SphericalCoordXYAngle )( 
            IDAVector3 * This,
            /* [retval][out] */ IDANumber **ret_0);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SphericalCoordYZAngle )( 
            IDAVector3 * This,
            /* [retval][out] */ IDANumber **ret_0);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SphericalCoordLength )( 
            IDAVector3 * This,
            /* [retval][out] */ IDANumber **ret_0);
        
        HRESULT ( STDMETHODCALLTYPE *Transform )( 
            IDAVector3 * This,
            /* [in] */ IDATransform3 *xf_0,
            /* [retval][out] */ IDAVector3 **ret_1);
        
        END_INTERFACE
    } IDAVector3Vtbl;

    interface IDAVector3
    {
        CONST_VTBL struct IDAVector3Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDAVector3_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDAVector3_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDAVector3_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDAVector3_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDAVector3_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDAVector3_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDAVector3_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDAVector3_GetClassName(This,pClassName)	\
    (This)->lpVtbl -> GetClassName(This,pClassName)

#define IDAVector3_Init(This,toBvr)	\
    (This)->lpVtbl -> Init(This,toBvr)

#define IDAVector3_Importance(This,relativeImportance,ppBvr)	\
    (This)->lpVtbl -> Importance(This,relativeImportance,ppBvr)

#define IDAVector3_RunOnce(This,bvr)	\
    (This)->lpVtbl -> RunOnce(This,bvr)

#define IDAVector3_SubstituteTime(This,xform,bvr)	\
    (This)->lpVtbl -> SubstituteTime(This,xform,bvr)

#define IDAVector3_SwitchTo(This,switchTo)	\
    (This)->lpVtbl -> SwitchTo(This,switchTo)

#define IDAVector3_SwitchToNumber(This,numToSwitchTo)	\
    (This)->lpVtbl -> SwitchToNumber(This,numToSwitchTo)

#define IDAVector3_SwitchToString(This,strToSwitchTo)	\
    (This)->lpVtbl -> SwitchToString(This,strToSwitchTo)

#define IDAVector3_Hook(This,notifier,pBvr)	\
    (This)->lpVtbl -> Hook(This,notifier,pBvr)

#define IDAVector3_Duration(This,duration,bvr)	\
    (This)->lpVtbl -> Duration(This,duration,bvr)

#define IDAVector3_DurationAnim(This,duration,bvr)	\
    (This)->lpVtbl -> DurationAnim(This,duration,bvr)

#define IDAVector3_Repeat(This,count,bvr)	\
    (This)->lpVtbl -> Repeat(This,count,bvr)

#define IDAVector3_RepeatForever(This,bvr)	\
    (This)->lpVtbl -> RepeatForever(This,bvr)

#define IDAVector3_IsReady(This,bBlock,b)	\
    (This)->lpVtbl -> IsReady(This,bBlock,b)


#define IDAVector3_get_Length(This,ret_0)	\
    (This)->lpVtbl -> get_Length(This,ret_0)

#define IDAVector3_get_LengthSquared(This,ret_0)	\
    (This)->lpVtbl -> get_LengthSquared(This,ret_0)

#define IDAVector3_Normalize(This,ret_0)	\
    (This)->lpVtbl -> Normalize(This,ret_0)

#define IDAVector3_MulAnim(This,scalar_0,ret_1)	\
    (This)->lpVtbl -> MulAnim(This,scalar_0,ret_1)

#define IDAVector3_Mul(This,scalar_0,ret_1)	\
    (This)->lpVtbl -> Mul(This,scalar_0,ret_1)

#define IDAVector3_DivAnim(This,scalar_0,ret_1)	\
    (This)->lpVtbl -> DivAnim(This,scalar_0,ret_1)

#define IDAVector3_Div(This,scalar_0,ret_1)	\
    (This)->lpVtbl -> Div(This,scalar_0,ret_1)

#define IDAVector3_get_X(This,ret_0)	\
    (This)->lpVtbl -> get_X(This,ret_0)

#define IDAVector3_get_Y(This,ret_0)	\
    (This)->lpVtbl -> get_Y(This,ret_0)

#define IDAVector3_get_Z(This,ret_0)	\
    (This)->lpVtbl -> get_Z(This,ret_0)

#define IDAVector3_get_SphericalCoordXYAngle(This,ret_0)	\
    (This)->lpVtbl -> get_SphericalCoordXYAngle(This,ret_0)

#define IDAVector3_get_SphericalCoordYZAngle(This,ret_0)	\
    (This)->lpVtbl -> get_SphericalCoordYZAngle(This,ret_0)

#define IDAVector3_get_SphericalCoordLength(This,ret_0)	\
    (This)->lpVtbl -> get_SphericalCoordLength(This,ret_0)

#define IDAVector3_Transform(This,xf_0,ret_1)	\
    (This)->lpVtbl -> Transform(This,xf_0,ret_1)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget] */ HRESULT STDMETHODCALLTYPE IDAVector3_get_Length_Proxy( 
    IDAVector3 * This,
    /* [retval][out] */ IDANumber **ret_0);



/* [propget] */ HRESULT STDMETHODCALLTYPE IDAVector3_get_LengthSquared_Proxy( 
    IDAVector3 * This,
    /* [retval][out] */ IDANumber **ret_0);



HRESULT STDMETHODCALLTYPE IDAVector3_Normalize_Proxy( 
    IDAVector3 * This,
    /* [retval][out] */ IDAVector3 **ret_0);



HRESULT STDMETHODCALLTYPE IDAVector3_MulAnim_Proxy( 
    IDAVector3 * This,
    /* [in] */ IDANumber *scalar_0,
    /* [retval][out] */ IDAVector3 **ret_1);



HRESULT STDMETHODCALLTYPE IDAVector3_Mul_Proxy( 
    IDAVector3 * This,
    /* [in] */ double scalar_0,
    /* [retval][out] */ IDAVector3 **ret_1);



HRESULT STDMETHODCALLTYPE IDAVector3_DivAnim_Proxy( 
    IDAVector3 * This,
    /* [in] */ IDANumber *scalar_0,
    /* [retval][out] */ IDAVector3 **ret_1);



HRESULT STDMETHODCALLTYPE IDAVector3_Div_Proxy( 
    IDAVector3 * This,
    /* [in] */ double scalar_0,
    /* [retval][out] */ IDAVector3 **ret_1);



/* [propget] */ HRESULT STDMETHODCALLTYPE IDAVector3_get_X_Proxy( 
    IDAVector3 * This,
    /* [retval][out] */ IDANumber **ret_0);



/* [propget] */ HRESULT STDMETHODCALLTYPE IDAVector3_get_Y_Proxy( 
    IDAVector3 * This,
    /* [retval][out] */ IDANumber **ret_0);



/* [propget] */ HRESULT STDMETHODCALLTYPE IDAVector3_get_Z_Proxy( 
    IDAVector3 * This,
    /* [retval][out] */ IDANumber **ret_0);



/* [propget] */ HRESULT STDMETHODCALLTYPE IDAVector3_get_SphericalCoordXYAngle_Proxy( 
    IDAVector3 * This,
    /* [retval][out] */ IDANumber **ret_0);



/* [propget] */ HRESULT STDMETHODCALLTYPE IDAVector3_get_SphericalCoordYZAngle_Proxy( 
    IDAVector3 * This,
    /* [retval][out] */ IDANumber **ret_0);



/* [propget] */ HRESULT STDMETHODCALLTYPE IDAVector3_get_SphericalCoordLength_Proxy( 
    IDAVector3 * This,
    /* [retval][out] */ IDANumber **ret_0);



HRESULT STDMETHODCALLTYPE IDAVector3_Transform_Proxy( 
    IDAVector3 * This,
    /* [in] */ IDATransform3 *xf_0,
    /* [retval][out] */ IDAVector3 **ret_1);




#endif 	/* __IDAVector3_INTERFACE_DEFINED__ */


#ifndef __IDAFontStyle_INTERFACE_DEFINED__
#define __IDAFontStyle_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDAFontStyle
 * at Tue Nov 11 05:16:35 1997
 * using MIDL 3.02.88
 ****************************************/
/* [dual][hidden][oleautomation][unique][object][local][helpstring][uuid] */ 



EXTERN_C const IID IID_IDAFontStyle;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("25B0F91D-D23D-11d0-9B85-00C04FC2F51D")
    IDAFontStyle : public IDABehavior
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Bold( 
            /* [retval][out] */ IDAFontStyle **ret_0) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Italic( 
            /* [retval][out] */ IDAFontStyle **ret_0) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Underline( 
            /* [retval][out] */ IDAFontStyle **ret_0) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Strikethrough( 
            /* [retval][out] */ IDAFontStyle **ret_0) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AntiAliasing( 
            /* [in] */ double aaStyle_0,
            /* [retval][out] */ IDAFontStyle **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Color( 
            /* [in] */ IDAColor *col_0,
            /* [retval][out] */ IDAFontStyle **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FamilyAnim( 
            /* [in] */ IDAString *face_0,
            /* [retval][out] */ IDAFontStyle **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Family( 
            /* [in] */ BSTR face_0,
            /* [retval][out] */ IDAFontStyle **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SizeAnim( 
            /* [in] */ IDANumber *size_0,
            /* [retval][out] */ IDAFontStyle **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Size( 
            /* [in] */ double size_0,
            /* [retval][out] */ IDAFontStyle **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Weight( 
            /* [in] */ double weight_0,
            /* [retval][out] */ IDAFontStyle **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WeightAnim( 
            /* [in] */ IDANumber *weight_0,
            /* [retval][out] */ IDAFontStyle **ret_1) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDAFontStyleVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDAFontStyle * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDAFontStyle * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDAFontStyle * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDAFontStyle * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDAFontStyle * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDAFontStyle * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDAFontStyle * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassName )( 
            IDAFontStyle * This,
            /* [retval][out] */ BSTR *pClassName);
        
        HRESULT ( STDMETHODCALLTYPE *Init )( 
            IDAFontStyle * This,
            /* [in] */ IDABehavior *toBvr);
        
        HRESULT ( STDMETHODCALLTYPE *Importance )( 
            IDAFontStyle * This,
            /* [in] */ double relativeImportance,
            /* [retval][out] */ IDABehavior **ppBvr);
        
        HRESULT ( STDMETHODCALLTYPE *RunOnce )( 
            IDAFontStyle * This,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *SubstituteTime )( 
            IDAFontStyle * This,
            /* [in] */ IDANumber *xform,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *SwitchTo )( 
            IDAFontStyle * This,
            /* [in] */ IDABehavior *switchTo);
        
        HRESULT ( STDMETHODCALLTYPE *SwitchToNumber )( 
            IDAFontStyle * This,
            /* [in] */ double numToSwitchTo);
        
        HRESULT ( STDMETHODCALLTYPE *SwitchToString )( 
            IDAFontStyle * This,
            /* [in] */ BSTR strToSwitchTo);
        
        HRESULT ( STDMETHODCALLTYPE *Hook )( 
            IDAFontStyle * This,
            /* [in] */ IDABvrHook *notifier,
            /* [retval][out] */ IDABehavior **pBvr);
        
        HRESULT ( STDMETHODCALLTYPE *Duration )( 
            IDAFontStyle * This,
            /* [in] */ double duration,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *DurationAnim )( 
            IDAFontStyle * This,
            /* [in] */ IDANumber *duration,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *Repeat )( 
            IDAFontStyle * This,
            /* [in] */ LONG count,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *RepeatForever )( 
            IDAFontStyle * This,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *IsReady )( 
            IDAFontStyle * This,
            /* [in] */ VARIANT_BOOL bBlock,
            /* [retval][out] */ VARIANT_BOOL *b);
        
        HRESULT ( STDMETHODCALLTYPE *Bold )( 
            IDAFontStyle * This,
            /* [retval][out] */ IDAFontStyle **ret_0);
        
        HRESULT ( STDMETHODCALLTYPE *Italic )( 
            IDAFontStyle * This,
            /* [retval][out] */ IDAFontStyle **ret_0);
        
        HRESULT ( STDMETHODCALLTYPE *Underline )( 
            IDAFontStyle * This,
            /* [retval][out] */ IDAFontStyle **ret_0);
        
        HRESULT ( STDMETHODCALLTYPE *Strikethrough )( 
            IDAFontStyle * This,
            /* [retval][out] */ IDAFontStyle **ret_0);
        
        HRESULT ( STDMETHODCALLTYPE *AntiAliasing )( 
            IDAFontStyle * This,
            /* [in] */ double aaStyle_0,
            /* [retval][out] */ IDAFontStyle **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *Color )( 
            IDAFontStyle * This,
            /* [in] */ IDAColor *col_0,
            /* [retval][out] */ IDAFontStyle **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *FamilyAnim )( 
            IDAFontStyle * This,
            /* [in] */ IDAString *face_0,
            /* [retval][out] */ IDAFontStyle **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *Family )( 
            IDAFontStyle * This,
            /* [in] */ BSTR face_0,
            /* [retval][out] */ IDAFontStyle **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *SizeAnim )( 
            IDAFontStyle * This,
            /* [in] */ IDANumber *size_0,
            /* [retval][out] */ IDAFontStyle **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *Size )( 
            IDAFontStyle * This,
            /* [in] */ double size_0,
            /* [retval][out] */ IDAFontStyle **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *Weight )( 
            IDAFontStyle * This,
            /* [in] */ double weight_0,
            /* [retval][out] */ IDAFontStyle **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *WeightAnim )( 
            IDAFontStyle * This,
            /* [in] */ IDANumber *weight_0,
            /* [retval][out] */ IDAFontStyle **ret_1);
        
        END_INTERFACE
    } IDAFontStyleVtbl;

    interface IDAFontStyle
    {
        CONST_VTBL struct IDAFontStyleVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDAFontStyle_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDAFontStyle_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDAFontStyle_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDAFontStyle_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDAFontStyle_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDAFontStyle_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDAFontStyle_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDAFontStyle_GetClassName(This,pClassName)	\
    (This)->lpVtbl -> GetClassName(This,pClassName)

#define IDAFontStyle_Init(This,toBvr)	\
    (This)->lpVtbl -> Init(This,toBvr)

#define IDAFontStyle_Importance(This,relativeImportance,ppBvr)	\
    (This)->lpVtbl -> Importance(This,relativeImportance,ppBvr)

#define IDAFontStyle_RunOnce(This,bvr)	\
    (This)->lpVtbl -> RunOnce(This,bvr)

#define IDAFontStyle_SubstituteTime(This,xform,bvr)	\
    (This)->lpVtbl -> SubstituteTime(This,xform,bvr)

#define IDAFontStyle_SwitchTo(This,switchTo)	\
    (This)->lpVtbl -> SwitchTo(This,switchTo)

#define IDAFontStyle_SwitchToNumber(This,numToSwitchTo)	\
    (This)->lpVtbl -> SwitchToNumber(This,numToSwitchTo)

#define IDAFontStyle_SwitchToString(This,strToSwitchTo)	\
    (This)->lpVtbl -> SwitchToString(This,strToSwitchTo)

#define IDAFontStyle_Hook(This,notifier,pBvr)	\
    (This)->lpVtbl -> Hook(This,notifier,pBvr)

#define IDAFontStyle_Duration(This,duration,bvr)	\
    (This)->lpVtbl -> Duration(This,duration,bvr)

#define IDAFontStyle_DurationAnim(This,duration,bvr)	\
    (This)->lpVtbl -> DurationAnim(This,duration,bvr)

#define IDAFontStyle_Repeat(This,count,bvr)	\
    (This)->lpVtbl -> Repeat(This,count,bvr)

#define IDAFontStyle_RepeatForever(This,bvr)	\
    (This)->lpVtbl -> RepeatForever(This,bvr)

#define IDAFontStyle_IsReady(This,bBlock,b)	\
    (This)->lpVtbl -> IsReady(This,bBlock,b)


#define IDAFontStyle_Bold(This,ret_0)	\
    (This)->lpVtbl -> Bold(This,ret_0)

#define IDAFontStyle_Italic(This,ret_0)	\
    (This)->lpVtbl -> Italic(This,ret_0)

#define IDAFontStyle_Underline(This,ret_0)	\
    (This)->lpVtbl -> Underline(This,ret_0)

#define IDAFontStyle_Strikethrough(This,ret_0)	\
    (This)->lpVtbl -> Strikethrough(This,ret_0)

#define IDAFontStyle_AntiAliasing(This,aaStyle_0,ret_1)	\
    (This)->lpVtbl -> AntiAliasing(This,aaStyle_0,ret_1)

#define IDAFontStyle_Color(This,col_0,ret_1)	\
    (This)->lpVtbl -> Color(This,col_0,ret_1)

#define IDAFontStyle_FamilyAnim(This,face_0,ret_1)	\
    (This)->lpVtbl -> FamilyAnim(This,face_0,ret_1)

#define IDAFontStyle_Family(This,face_0,ret_1)	\
    (This)->lpVtbl -> Family(This,face_0,ret_1)

#define IDAFontStyle_SizeAnim(This,size_0,ret_1)	\
    (This)->lpVtbl -> SizeAnim(This,size_0,ret_1)

#define IDAFontStyle_Size(This,size_0,ret_1)	\
    (This)->lpVtbl -> Size(This,size_0,ret_1)

#define IDAFontStyle_Weight(This,weight_0,ret_1)	\
    (This)->lpVtbl -> Weight(This,weight_0,ret_1)

#define IDAFontStyle_WeightAnim(This,weight_0,ret_1)	\
    (This)->lpVtbl -> WeightAnim(This,weight_0,ret_1)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDAFontStyle_Bold_Proxy( 
    IDAFontStyle * This,
    /* [retval][out] */ IDAFontStyle **ret_0);



HRESULT STDMETHODCALLTYPE IDAFontStyle_Italic_Proxy( 
    IDAFontStyle * This,
    /* [retval][out] */ IDAFontStyle **ret_0);



HRESULT STDMETHODCALLTYPE IDAFontStyle_Underline_Proxy( 
    IDAFontStyle * This,
    /* [retval][out] */ IDAFontStyle **ret_0);



HRESULT STDMETHODCALLTYPE IDAFontStyle_Strikethrough_Proxy( 
    IDAFontStyle * This,
    /* [retval][out] */ IDAFontStyle **ret_0);



HRESULT STDMETHODCALLTYPE IDAFontStyle_AntiAliasing_Proxy( 
    IDAFontStyle * This,
    /* [in] */ double aaStyle_0,
    /* [retval][out] */ IDAFontStyle **ret_1);



HRESULT STDMETHODCALLTYPE IDAFontStyle_Color_Proxy( 
    IDAFontStyle * This,
    /* [in] */ IDAColor *col_0,
    /* [retval][out] */ IDAFontStyle **ret_1);



HRESULT STDMETHODCALLTYPE IDAFontStyle_FamilyAnim_Proxy( 
    IDAFontStyle * This,
    /* [in] */ IDAString *face_0,
    /* [retval][out] */ IDAFontStyle **ret_1);



HRESULT STDMETHODCALLTYPE IDAFontStyle_Family_Proxy( 
    IDAFontStyle * This,
    /* [in] */ BSTR face_0,
    /* [retval][out] */ IDAFontStyle **ret_1);



HRESULT STDMETHODCALLTYPE IDAFontStyle_SizeAnim_Proxy( 
    IDAFontStyle * This,
    /* [in] */ IDANumber *size_0,
    /* [retval][out] */ IDAFontStyle **ret_1);



HRESULT STDMETHODCALLTYPE IDAFontStyle_Size_Proxy( 
    IDAFontStyle * This,
    /* [in] */ double size_0,
    /* [retval][out] */ IDAFontStyle **ret_1);



HRESULT STDMETHODCALLTYPE IDAFontStyle_Weight_Proxy( 
    IDAFontStyle * This,
    /* [in] */ double weight_0,
    /* [retval][out] */ IDAFontStyle **ret_1);



HRESULT STDMETHODCALLTYPE IDAFontStyle_WeightAnim_Proxy( 
    IDAFontStyle * This,
    /* [in] */ IDANumber *weight_0,
    /* [retval][out] */ IDAFontStyle **ret_1);




#endif 	/* __IDAFontStyle_INTERFACE_DEFINED__ */


#ifndef __IDALineStyle_INTERFACE_DEFINED__
#define __IDALineStyle_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDALineStyle
 * at Tue Nov 11 05:16:35 1997
 * using MIDL 3.02.88
 ****************************************/
/* [dual][hidden][oleautomation][unique][object][local][helpstring][uuid] */ 



EXTERN_C const IID IID_IDALineStyle;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("C46C1BF1-3C52-11d0-9200-848C1D000000")
    IDALineStyle : public IDABehavior
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE End( 
            /* [in] */ IDAEndStyle *sty_0,
            /* [retval][out] */ IDALineStyle **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Join( 
            /* [in] */ IDAJoinStyle *sty_0,
            /* [retval][out] */ IDALineStyle **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Dash( 
            /* [in] */ IDADashStyle *sty_0,
            /* [retval][out] */ IDALineStyle **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WidthAnim( 
            /* [in] */ IDANumber *sty_0,
            /* [retval][out] */ IDALineStyle **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE width( 
            /* [in] */ double sty_0,
            /* [retval][out] */ IDALineStyle **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AntiAliasing( 
            /* [in] */ double aaStyle_0,
            /* [retval][out] */ IDALineStyle **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Detail( 
            /* [retval][out] */ IDALineStyle **ret_0) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Color( 
            /* [in] */ IDAColor *clr_0,
            /* [retval][out] */ IDALineStyle **ret_1) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDALineStyleVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDALineStyle * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDALineStyle * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDALineStyle * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDALineStyle * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDALineStyle * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDALineStyle * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDALineStyle * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassName )( 
            IDALineStyle * This,
            /* [retval][out] */ BSTR *pClassName);
        
        HRESULT ( STDMETHODCALLTYPE *Init )( 
            IDALineStyle * This,
            /* [in] */ IDABehavior *toBvr);
        
        HRESULT ( STDMETHODCALLTYPE *Importance )( 
            IDALineStyle * This,
            /* [in] */ double relativeImportance,
            /* [retval][out] */ IDABehavior **ppBvr);
        
        HRESULT ( STDMETHODCALLTYPE *RunOnce )( 
            IDALineStyle * This,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *SubstituteTime )( 
            IDALineStyle * This,
            /* [in] */ IDANumber *xform,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *SwitchTo )( 
            IDALineStyle * This,
            /* [in] */ IDABehavior *switchTo);
        
        HRESULT ( STDMETHODCALLTYPE *SwitchToNumber )( 
            IDALineStyle * This,
            /* [in] */ double numToSwitchTo);
        
        HRESULT ( STDMETHODCALLTYPE *SwitchToString )( 
            IDALineStyle * This,
            /* [in] */ BSTR strToSwitchTo);
        
        HRESULT ( STDMETHODCALLTYPE *Hook )( 
            IDALineStyle * This,
            /* [in] */ IDABvrHook *notifier,
            /* [retval][out] */ IDABehavior **pBvr);
        
        HRESULT ( STDMETHODCALLTYPE *Duration )( 
            IDALineStyle * This,
            /* [in] */ double duration,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *DurationAnim )( 
            IDALineStyle * This,
            /* [in] */ IDANumber *duration,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *Repeat )( 
            IDALineStyle * This,
            /* [in] */ LONG count,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *RepeatForever )( 
            IDALineStyle * This,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *IsReady )( 
            IDALineStyle * This,
            /* [in] */ VARIANT_BOOL bBlock,
            /* [retval][out] */ VARIANT_BOOL *b);
        
        HRESULT ( STDMETHODCALLTYPE *End )( 
            IDALineStyle * This,
            /* [in] */ IDAEndStyle *sty_0,
            /* [retval][out] */ IDALineStyle **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *Join )( 
            IDALineStyle * This,
            /* [in] */ IDAJoinStyle *sty_0,
            /* [retval][out] */ IDALineStyle **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *Dash )( 
            IDALineStyle * This,
            /* [in] */ IDADashStyle *sty_0,
            /* [retval][out] */ IDALineStyle **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *WidthAnim )( 
            IDALineStyle * This,
            /* [in] */ IDANumber *sty_0,
            /* [retval][out] */ IDALineStyle **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *width )( 
            IDALineStyle * This,
            /* [in] */ double sty_0,
            /* [retval][out] */ IDALineStyle **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *AntiAliasing )( 
            IDALineStyle * This,
            /* [in] */ double aaStyle_0,
            /* [retval][out] */ IDALineStyle **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *Detail )( 
            IDALineStyle * This,
            /* [retval][out] */ IDALineStyle **ret_0);
        
        HRESULT ( STDMETHODCALLTYPE *Color )( 
            IDALineStyle * This,
            /* [in] */ IDAColor *clr_0,
            /* [retval][out] */ IDALineStyle **ret_1);
        
        END_INTERFACE
    } IDALineStyleVtbl;

    interface IDALineStyle
    {
        CONST_VTBL struct IDALineStyleVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDALineStyle_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDALineStyle_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDALineStyle_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDALineStyle_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDALineStyle_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDALineStyle_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDALineStyle_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDALineStyle_GetClassName(This,pClassName)	\
    (This)->lpVtbl -> GetClassName(This,pClassName)

#define IDALineStyle_Init(This,toBvr)	\
    (This)->lpVtbl -> Init(This,toBvr)

#define IDALineStyle_Importance(This,relativeImportance,ppBvr)	\
    (This)->lpVtbl -> Importance(This,relativeImportance,ppBvr)

#define IDALineStyle_RunOnce(This,bvr)	\
    (This)->lpVtbl -> RunOnce(This,bvr)

#define IDALineStyle_SubstituteTime(This,xform,bvr)	\
    (This)->lpVtbl -> SubstituteTime(This,xform,bvr)

#define IDALineStyle_SwitchTo(This,switchTo)	\
    (This)->lpVtbl -> SwitchTo(This,switchTo)

#define IDALineStyle_SwitchToNumber(This,numToSwitchTo)	\
    (This)->lpVtbl -> SwitchToNumber(This,numToSwitchTo)

#define IDALineStyle_SwitchToString(This,strToSwitchTo)	\
    (This)->lpVtbl -> SwitchToString(This,strToSwitchTo)

#define IDALineStyle_Hook(This,notifier,pBvr)	\
    (This)->lpVtbl -> Hook(This,notifier,pBvr)

#define IDALineStyle_Duration(This,duration,bvr)	\
    (This)->lpVtbl -> Duration(This,duration,bvr)

#define IDALineStyle_DurationAnim(This,duration,bvr)	\
    (This)->lpVtbl -> DurationAnim(This,duration,bvr)

#define IDALineStyle_Repeat(This,count,bvr)	\
    (This)->lpVtbl -> Repeat(This,count,bvr)

#define IDALineStyle_RepeatForever(This,bvr)	\
    (This)->lpVtbl -> RepeatForever(This,bvr)

#define IDALineStyle_IsReady(This,bBlock,b)	\
    (This)->lpVtbl -> IsReady(This,bBlock,b)


#define IDALineStyle_End(This,sty_0,ret_1)	\
    (This)->lpVtbl -> End(This,sty_0,ret_1)

#define IDALineStyle_Join(This,sty_0,ret_1)	\
    (This)->lpVtbl -> Join(This,sty_0,ret_1)

#define IDALineStyle_Dash(This,sty_0,ret_1)	\
    (This)->lpVtbl -> Dash(This,sty_0,ret_1)

#define IDALineStyle_WidthAnim(This,sty_0,ret_1)	\
    (This)->lpVtbl -> WidthAnim(This,sty_0,ret_1)

#define IDALineStyle_width(This,sty_0,ret_1)	\
    (This)->lpVtbl -> width(This,sty_0,ret_1)

#define IDALineStyle_AntiAliasing(This,aaStyle_0,ret_1)	\
    (This)->lpVtbl -> AntiAliasing(This,aaStyle_0,ret_1)

#define IDALineStyle_Detail(This,ret_0)	\
    (This)->lpVtbl -> Detail(This,ret_0)

#define IDALineStyle_Color(This,clr_0,ret_1)	\
    (This)->lpVtbl -> Color(This,clr_0,ret_1)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDALineStyle_End_Proxy( 
    IDALineStyle * This,
    /* [in] */ IDAEndStyle *sty_0,
    /* [retval][out] */ IDALineStyle **ret_1);



HRESULT STDMETHODCALLTYPE IDALineStyle_Join_Proxy( 
    IDALineStyle * This,
    /* [in] */ IDAJoinStyle *sty_0,
    /* [retval][out] */ IDALineStyle **ret_1);



HRESULT STDMETHODCALLTYPE IDALineStyle_Dash_Proxy( 
    IDALineStyle * This,
    /* [in] */ IDADashStyle *sty_0,
    /* [retval][out] */ IDALineStyle **ret_1);



HRESULT STDMETHODCALLTYPE IDALineStyle_WidthAnim_Proxy( 
    IDALineStyle * This,
    /* [in] */ IDANumber *sty_0,
    /* [retval][out] */ IDALineStyle **ret_1);



HRESULT STDMETHODCALLTYPE IDALineStyle_width_Proxy( 
    IDALineStyle * This,
    /* [in] */ double sty_0,
    /* [retval][out] */ IDALineStyle **ret_1);



HRESULT STDMETHODCALLTYPE IDALineStyle_AntiAliasing_Proxy( 
    IDALineStyle * This,
    /* [in] */ double aaStyle_0,
    /* [retval][out] */ IDALineStyle **ret_1);



HRESULT STDMETHODCALLTYPE IDALineStyle_Detail_Proxy( 
    IDALineStyle * This,
    /* [retval][out] */ IDALineStyle **ret_0);



HRESULT STDMETHODCALLTYPE IDALineStyle_Color_Proxy( 
    IDALineStyle * This,
    /* [in] */ IDAColor *clr_0,
    /* [retval][out] */ IDALineStyle **ret_1);




#endif 	/* __IDALineStyle_INTERFACE_DEFINED__ */


#ifndef __IDAEndStyle_INTERFACE_DEFINED__
#define __IDAEndStyle_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDAEndStyle
 * at Tue Nov 11 05:16:35 1997
 * using MIDL 3.02.88
 ****************************************/
/* [dual][hidden][oleautomation][unique][object][local][helpstring][uuid] */ 



EXTERN_C const IID IID_IDAEndStyle;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("C46C1BEB-3C52-11d0-9200-848C1D000000")
    IDAEndStyle : public IDABehavior
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IDAEndStyleVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDAEndStyle * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDAEndStyle * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDAEndStyle * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDAEndStyle * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDAEndStyle * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDAEndStyle * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDAEndStyle * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassName )( 
            IDAEndStyle * This,
            /* [retval][out] */ BSTR *pClassName);
        
        HRESULT ( STDMETHODCALLTYPE *Init )( 
            IDAEndStyle * This,
            /* [in] */ IDABehavior *toBvr);
        
        HRESULT ( STDMETHODCALLTYPE *Importance )( 
            IDAEndStyle * This,
            /* [in] */ double relativeImportance,
            /* [retval][out] */ IDABehavior **ppBvr);
        
        HRESULT ( STDMETHODCALLTYPE *RunOnce )( 
            IDAEndStyle * This,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *SubstituteTime )( 
            IDAEndStyle * This,
            /* [in] */ IDANumber *xform,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *SwitchTo )( 
            IDAEndStyle * This,
            /* [in] */ IDABehavior *switchTo);
        
        HRESULT ( STDMETHODCALLTYPE *SwitchToNumber )( 
            IDAEndStyle * This,
            /* [in] */ double numToSwitchTo);
        
        HRESULT ( STDMETHODCALLTYPE *SwitchToString )( 
            IDAEndStyle * This,
            /* [in] */ BSTR strToSwitchTo);
        
        HRESULT ( STDMETHODCALLTYPE *Hook )( 
            IDAEndStyle * This,
            /* [in] */ IDABvrHook *notifier,
            /* [retval][out] */ IDABehavior **pBvr);
        
        HRESULT ( STDMETHODCALLTYPE *Duration )( 
            IDAEndStyle * This,
            /* [in] */ double duration,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *DurationAnim )( 
            IDAEndStyle * This,
            /* [in] */ IDANumber *duration,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *Repeat )( 
            IDAEndStyle * This,
            /* [in] */ LONG count,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *RepeatForever )( 
            IDAEndStyle * This,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *IsReady )( 
            IDAEndStyle * This,
            /* [in] */ VARIANT_BOOL bBlock,
            /* [retval][out] */ VARIANT_BOOL *b);
        
        END_INTERFACE
    } IDAEndStyleVtbl;

    interface IDAEndStyle
    {
        CONST_VTBL struct IDAEndStyleVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDAEndStyle_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDAEndStyle_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDAEndStyle_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDAEndStyle_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDAEndStyle_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDAEndStyle_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDAEndStyle_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDAEndStyle_GetClassName(This,pClassName)	\
    (This)->lpVtbl -> GetClassName(This,pClassName)

#define IDAEndStyle_Init(This,toBvr)	\
    (This)->lpVtbl -> Init(This,toBvr)

#define IDAEndStyle_Importance(This,relativeImportance,ppBvr)	\
    (This)->lpVtbl -> Importance(This,relativeImportance,ppBvr)

#define IDAEndStyle_RunOnce(This,bvr)	\
    (This)->lpVtbl -> RunOnce(This,bvr)

#define IDAEndStyle_SubstituteTime(This,xform,bvr)	\
    (This)->lpVtbl -> SubstituteTime(This,xform,bvr)

#define IDAEndStyle_SwitchTo(This,switchTo)	\
    (This)->lpVtbl -> SwitchTo(This,switchTo)

#define IDAEndStyle_SwitchToNumber(This,numToSwitchTo)	\
    (This)->lpVtbl -> SwitchToNumber(This,numToSwitchTo)

#define IDAEndStyle_SwitchToString(This,strToSwitchTo)	\
    (This)->lpVtbl -> SwitchToString(This,strToSwitchTo)

#define IDAEndStyle_Hook(This,notifier,pBvr)	\
    (This)->lpVtbl -> Hook(This,notifier,pBvr)

#define IDAEndStyle_Duration(This,duration,bvr)	\
    (This)->lpVtbl -> Duration(This,duration,bvr)

#define IDAEndStyle_DurationAnim(This,duration,bvr)	\
    (This)->lpVtbl -> DurationAnim(This,duration,bvr)

#define IDAEndStyle_Repeat(This,count,bvr)	\
    (This)->lpVtbl -> Repeat(This,count,bvr)

#define IDAEndStyle_RepeatForever(This,bvr)	\
    (This)->lpVtbl -> RepeatForever(This,bvr)

#define IDAEndStyle_IsReady(This,bBlock,b)	\
    (This)->lpVtbl -> IsReady(This,bBlock,b)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDAEndStyle_INTERFACE_DEFINED__ */


#ifndef __IDAJoinStyle_INTERFACE_DEFINED__
#define __IDAJoinStyle_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDAJoinStyle
 * at Tue Nov 11 05:16:35 1997
 * using MIDL 3.02.88
 ****************************************/
/* [dual][hidden][oleautomation][unique][object][local][helpstring][uuid] */ 



EXTERN_C const IID IID_IDAJoinStyle;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("C46C1BED-3C52-11d0-9200-848C1D000000")
    IDAJoinStyle : public IDABehavior
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IDAJoinStyleVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDAJoinStyle * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDAJoinStyle * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDAJoinStyle * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDAJoinStyle * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDAJoinStyle * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDAJoinStyle * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDAJoinStyle * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassName )( 
            IDAJoinStyle * This,
            /* [retval][out] */ BSTR *pClassName);
        
        HRESULT ( STDMETHODCALLTYPE *Init )( 
            IDAJoinStyle * This,
            /* [in] */ IDABehavior *toBvr);
        
        HRESULT ( STDMETHODCALLTYPE *Importance )( 
            IDAJoinStyle * This,
            /* [in] */ double relativeImportance,
            /* [retval][out] */ IDABehavior **ppBvr);
        
        HRESULT ( STDMETHODCALLTYPE *RunOnce )( 
            IDAJoinStyle * This,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *SubstituteTime )( 
            IDAJoinStyle * This,
            /* [in] */ IDANumber *xform,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *SwitchTo )( 
            IDAJoinStyle * This,
            /* [in] */ IDABehavior *switchTo);
        
        HRESULT ( STDMETHODCALLTYPE *SwitchToNumber )( 
            IDAJoinStyle * This,
            /* [in] */ double numToSwitchTo);
        
        HRESULT ( STDMETHODCALLTYPE *SwitchToString )( 
            IDAJoinStyle * This,
            /* [in] */ BSTR strToSwitchTo);
        
        HRESULT ( STDMETHODCALLTYPE *Hook )( 
            IDAJoinStyle * This,
            /* [in] */ IDABvrHook *notifier,
            /* [retval][out] */ IDABehavior **pBvr);
        
        HRESULT ( STDMETHODCALLTYPE *Duration )( 
            IDAJoinStyle * This,
            /* [in] */ double duration,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *DurationAnim )( 
            IDAJoinStyle * This,
            /* [in] */ IDANumber *duration,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *Repeat )( 
            IDAJoinStyle * This,
            /* [in] */ LONG count,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *RepeatForever )( 
            IDAJoinStyle * This,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *IsReady )( 
            IDAJoinStyle * This,
            /* [in] */ VARIANT_BOOL bBlock,
            /* [retval][out] */ VARIANT_BOOL *b);
        
        END_INTERFACE
    } IDAJoinStyleVtbl;

    interface IDAJoinStyle
    {
        CONST_VTBL struct IDAJoinStyleVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDAJoinStyle_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDAJoinStyle_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDAJoinStyle_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDAJoinStyle_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDAJoinStyle_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDAJoinStyle_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDAJoinStyle_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDAJoinStyle_GetClassName(This,pClassName)	\
    (This)->lpVtbl -> GetClassName(This,pClassName)

#define IDAJoinStyle_Init(This,toBvr)	\
    (This)->lpVtbl -> Init(This,toBvr)

#define IDAJoinStyle_Importance(This,relativeImportance,ppBvr)	\
    (This)->lpVtbl -> Importance(This,relativeImportance,ppBvr)

#define IDAJoinStyle_RunOnce(This,bvr)	\
    (This)->lpVtbl -> RunOnce(This,bvr)

#define IDAJoinStyle_SubstituteTime(This,xform,bvr)	\
    (This)->lpVtbl -> SubstituteTime(This,xform,bvr)

#define IDAJoinStyle_SwitchTo(This,switchTo)	\
    (This)->lpVtbl -> SwitchTo(This,switchTo)

#define IDAJoinStyle_SwitchToNumber(This,numToSwitchTo)	\
    (This)->lpVtbl -> SwitchToNumber(This,numToSwitchTo)

#define IDAJoinStyle_SwitchToString(This,strToSwitchTo)	\
    (This)->lpVtbl -> SwitchToString(This,strToSwitchTo)

#define IDAJoinStyle_Hook(This,notifier,pBvr)	\
    (This)->lpVtbl -> Hook(This,notifier,pBvr)

#define IDAJoinStyle_Duration(This,duration,bvr)	\
    (This)->lpVtbl -> Duration(This,duration,bvr)

#define IDAJoinStyle_DurationAnim(This,duration,bvr)	\
    (This)->lpVtbl -> DurationAnim(This,duration,bvr)

#define IDAJoinStyle_Repeat(This,count,bvr)	\
    (This)->lpVtbl -> Repeat(This,count,bvr)

#define IDAJoinStyle_RepeatForever(This,bvr)	\
    (This)->lpVtbl -> RepeatForever(This,bvr)

#define IDAJoinStyle_IsReady(This,bBlock,b)	\
    (This)->lpVtbl -> IsReady(This,bBlock,b)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDAJoinStyle_INTERFACE_DEFINED__ */


#ifndef __IDADashStyle_INTERFACE_DEFINED__
#define __IDADashStyle_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDADashStyle
 * at Tue Nov 11 05:16:35 1997
 * using MIDL 3.02.88
 ****************************************/
/* [dual][hidden][oleautomation][unique][object][local][helpstring][uuid] */ 



EXTERN_C const IID IID_IDADashStyle;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("C46C1BEF-3C52-11d0-9200-848C1D000000")
    IDADashStyle : public IDABehavior
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IDADashStyleVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDADashStyle * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDADashStyle * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDADashStyle * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDADashStyle * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDADashStyle * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDADashStyle * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDADashStyle * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassName )( 
            IDADashStyle * This,
            /* [retval][out] */ BSTR *pClassName);
        
        HRESULT ( STDMETHODCALLTYPE *Init )( 
            IDADashStyle * This,
            /* [in] */ IDABehavior *toBvr);
        
        HRESULT ( STDMETHODCALLTYPE *Importance )( 
            IDADashStyle * This,
            /* [in] */ double relativeImportance,
            /* [retval][out] */ IDABehavior **ppBvr);
        
        HRESULT ( STDMETHODCALLTYPE *RunOnce )( 
            IDADashStyle * This,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *SubstituteTime )( 
            IDADashStyle * This,
            /* [in] */ IDANumber *xform,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *SwitchTo )( 
            IDADashStyle * This,
            /* [in] */ IDABehavior *switchTo);
        
        HRESULT ( STDMETHODCALLTYPE *SwitchToNumber )( 
            IDADashStyle * This,
            /* [in] */ double numToSwitchTo);
        
        HRESULT ( STDMETHODCALLTYPE *SwitchToString )( 
            IDADashStyle * This,
            /* [in] */ BSTR strToSwitchTo);
        
        HRESULT ( STDMETHODCALLTYPE *Hook )( 
            IDADashStyle * This,
            /* [in] */ IDABvrHook *notifier,
            /* [retval][out] */ IDABehavior **pBvr);
        
        HRESULT ( STDMETHODCALLTYPE *Duration )( 
            IDADashStyle * This,
            /* [in] */ double duration,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *DurationAnim )( 
            IDADashStyle * This,
            /* [in] */ IDANumber *duration,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *Repeat )( 
            IDADashStyle * This,
            /* [in] */ LONG count,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *RepeatForever )( 
            IDADashStyle * This,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *IsReady )( 
            IDADashStyle * This,
            /* [in] */ VARIANT_BOOL bBlock,
            /* [retval][out] */ VARIANT_BOOL *b);
        
        END_INTERFACE
    } IDADashStyleVtbl;

    interface IDADashStyle
    {
        CONST_VTBL struct IDADashStyleVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDADashStyle_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDADashStyle_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDADashStyle_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDADashStyle_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDADashStyle_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDADashStyle_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDADashStyle_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDADashStyle_GetClassName(This,pClassName)	\
    (This)->lpVtbl -> GetClassName(This,pClassName)

#define IDADashStyle_Init(This,toBvr)	\
    (This)->lpVtbl -> Init(This,toBvr)

#define IDADashStyle_Importance(This,relativeImportance,ppBvr)	\
    (This)->lpVtbl -> Importance(This,relativeImportance,ppBvr)

#define IDADashStyle_RunOnce(This,bvr)	\
    (This)->lpVtbl -> RunOnce(This,bvr)

#define IDADashStyle_SubstituteTime(This,xform,bvr)	\
    (This)->lpVtbl -> SubstituteTime(This,xform,bvr)

#define IDADashStyle_SwitchTo(This,switchTo)	\
    (This)->lpVtbl -> SwitchTo(This,switchTo)

#define IDADashStyle_SwitchToNumber(This,numToSwitchTo)	\
    (This)->lpVtbl -> SwitchToNumber(This,numToSwitchTo)

#define IDADashStyle_SwitchToString(This,strToSwitchTo)	\
    (This)->lpVtbl -> SwitchToString(This,strToSwitchTo)

#define IDADashStyle_Hook(This,notifier,pBvr)	\
    (This)->lpVtbl -> Hook(This,notifier,pBvr)

#define IDADashStyle_Duration(This,duration,bvr)	\
    (This)->lpVtbl -> Duration(This,duration,bvr)

#define IDADashStyle_DurationAnim(This,duration,bvr)	\
    (This)->lpVtbl -> DurationAnim(This,duration,bvr)

#define IDADashStyle_Repeat(This,count,bvr)	\
    (This)->lpVtbl -> Repeat(This,count,bvr)

#define IDADashStyle_RepeatForever(This,bvr)	\
    (This)->lpVtbl -> RepeatForever(This,bvr)

#define IDADashStyle_IsReady(This,bBlock,b)	\
    (This)->lpVtbl -> IsReady(This,bBlock,b)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDADashStyle_INTERFACE_DEFINED__ */


#ifndef __IDABbox2_INTERFACE_DEFINED__
#define __IDABbox2_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDABbox2
 * at Tue Nov 11 05:16:35 1997
 * using MIDL 3.02.88
 ****************************************/
/* [dual][hidden][oleautomation][unique][object][local][helpstring][uuid] */ 



EXTERN_C const IID IID_IDABbox2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("C46C1BCD-3C52-11d0-9200-848C1D000000")
    IDABbox2 : public IDABehavior
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Min( 
            /* [retval][out] */ IDAPoint2 **ret_0) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Max( 
            /* [retval][out] */ IDAPoint2 **ret_0) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDABbox2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDABbox2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDABbox2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDABbox2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDABbox2 * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDABbox2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDABbox2 * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDABbox2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassName )( 
            IDABbox2 * This,
            /* [retval][out] */ BSTR *pClassName);
        
        HRESULT ( STDMETHODCALLTYPE *Init )( 
            IDABbox2 * This,
            /* [in] */ IDABehavior *toBvr);
        
        HRESULT ( STDMETHODCALLTYPE *Importance )( 
            IDABbox2 * This,
            /* [in] */ double relativeImportance,
            /* [retval][out] */ IDABehavior **ppBvr);
        
        HRESULT ( STDMETHODCALLTYPE *RunOnce )( 
            IDABbox2 * This,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *SubstituteTime )( 
            IDABbox2 * This,
            /* [in] */ IDANumber *xform,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *SwitchTo )( 
            IDABbox2 * This,
            /* [in] */ IDABehavior *switchTo);
        
        HRESULT ( STDMETHODCALLTYPE *SwitchToNumber )( 
            IDABbox2 * This,
            /* [in] */ double numToSwitchTo);
        
        HRESULT ( STDMETHODCALLTYPE *SwitchToString )( 
            IDABbox2 * This,
            /* [in] */ BSTR strToSwitchTo);
        
        HRESULT ( STDMETHODCALLTYPE *Hook )( 
            IDABbox2 * This,
            /* [in] */ IDABvrHook *notifier,
            /* [retval][out] */ IDABehavior **pBvr);
        
        HRESULT ( STDMETHODCALLTYPE *Duration )( 
            IDABbox2 * This,
            /* [in] */ double duration,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *DurationAnim )( 
            IDABbox2 * This,
            /* [in] */ IDANumber *duration,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *Repeat )( 
            IDABbox2 * This,
            /* [in] */ LONG count,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *RepeatForever )( 
            IDABbox2 * This,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *IsReady )( 
            IDABbox2 * This,
            /* [in] */ VARIANT_BOOL bBlock,
            /* [retval][out] */ VARIANT_BOOL *b);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Min )( 
            IDABbox2 * This,
            /* [retval][out] */ IDAPoint2 **ret_0);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Max )( 
            IDABbox2 * This,
            /* [retval][out] */ IDAPoint2 **ret_0);
        
        END_INTERFACE
    } IDABbox2Vtbl;

    interface IDABbox2
    {
        CONST_VTBL struct IDABbox2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDABbox2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDABbox2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDABbox2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDABbox2_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDABbox2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDABbox2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDABbox2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDABbox2_GetClassName(This,pClassName)	\
    (This)->lpVtbl -> GetClassName(This,pClassName)

#define IDABbox2_Init(This,toBvr)	\
    (This)->lpVtbl -> Init(This,toBvr)

#define IDABbox2_Importance(This,relativeImportance,ppBvr)	\
    (This)->lpVtbl -> Importance(This,relativeImportance,ppBvr)

#define IDABbox2_RunOnce(This,bvr)	\
    (This)->lpVtbl -> RunOnce(This,bvr)

#define IDABbox2_SubstituteTime(This,xform,bvr)	\
    (This)->lpVtbl -> SubstituteTime(This,xform,bvr)

#define IDABbox2_SwitchTo(This,switchTo)	\
    (This)->lpVtbl -> SwitchTo(This,switchTo)

#define IDABbox2_SwitchToNumber(This,numToSwitchTo)	\
    (This)->lpVtbl -> SwitchToNumber(This,numToSwitchTo)

#define IDABbox2_SwitchToString(This,strToSwitchTo)	\
    (This)->lpVtbl -> SwitchToString(This,strToSwitchTo)

#define IDABbox2_Hook(This,notifier,pBvr)	\
    (This)->lpVtbl -> Hook(This,notifier,pBvr)

#define IDABbox2_Duration(This,duration,bvr)	\
    (This)->lpVtbl -> Duration(This,duration,bvr)

#define IDABbox2_DurationAnim(This,duration,bvr)	\
    (This)->lpVtbl -> DurationAnim(This,duration,bvr)

#define IDABbox2_Repeat(This,count,bvr)	\
    (This)->lpVtbl -> Repeat(This,count,bvr)

#define IDABbox2_RepeatForever(This,bvr)	\
    (This)->lpVtbl -> RepeatForever(This,bvr)

#define IDABbox2_IsReady(This,bBlock,b)	\
    (This)->lpVtbl -> IsReady(This,bBlock,b)


#define IDABbox2_get_Min(This,ret_0)	\
    (This)->lpVtbl -> get_Min(This,ret_0)

#define IDABbox2_get_Max(This,ret_0)	\
    (This)->lpVtbl -> get_Max(This,ret_0)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget] */ HRESULT STDMETHODCALLTYPE IDABbox2_get_Min_Proxy( 
    IDABbox2 * This,
    /* [retval][out] */ IDAPoint2 **ret_0);



/* [propget] */ HRESULT STDMETHODCALLTYPE IDABbox2_get_Max_Proxy( 
    IDABbox2 * This,
    /* [retval][out] */ IDAPoint2 **ret_0);




#endif 	/* __IDABbox2_INTERFACE_DEFINED__ */


#ifndef __IDABbox3_INTERFACE_DEFINED__
#define __IDABbox3_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDABbox3
 * at Tue Nov 11 05:16:35 1997
 * using MIDL 3.02.88
 ****************************************/
/* [dual][hidden][oleautomation][unique][object][local][helpstring][uuid] */ 



EXTERN_C const IID IID_IDABbox3;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("C46C1BDD-3C52-11d0-9200-848C1D000000")
    IDABbox3 : public IDABehavior
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Min( 
            /* [retval][out] */ IDAPoint3 **ret_0) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Max( 
            /* [retval][out] */ IDAPoint3 **ret_0) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDABbox3Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDABbox3 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDABbox3 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDABbox3 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDABbox3 * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDABbox3 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDABbox3 * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDABbox3 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassName )( 
            IDABbox3 * This,
            /* [retval][out] */ BSTR *pClassName);
        
        HRESULT ( STDMETHODCALLTYPE *Init )( 
            IDABbox3 * This,
            /* [in] */ IDABehavior *toBvr);
        
        HRESULT ( STDMETHODCALLTYPE *Importance )( 
            IDABbox3 * This,
            /* [in] */ double relativeImportance,
            /* [retval][out] */ IDABehavior **ppBvr);
        
        HRESULT ( STDMETHODCALLTYPE *RunOnce )( 
            IDABbox3 * This,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *SubstituteTime )( 
            IDABbox3 * This,
            /* [in] */ IDANumber *xform,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *SwitchTo )( 
            IDABbox3 * This,
            /* [in] */ IDABehavior *switchTo);
        
        HRESULT ( STDMETHODCALLTYPE *SwitchToNumber )( 
            IDABbox3 * This,
            /* [in] */ double numToSwitchTo);
        
        HRESULT ( STDMETHODCALLTYPE *SwitchToString )( 
            IDABbox3 * This,
            /* [in] */ BSTR strToSwitchTo);
        
        HRESULT ( STDMETHODCALLTYPE *Hook )( 
            IDABbox3 * This,
            /* [in] */ IDABvrHook *notifier,
            /* [retval][out] */ IDABehavior **pBvr);
        
        HRESULT ( STDMETHODCALLTYPE *Duration )( 
            IDABbox3 * This,
            /* [in] */ double duration,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *DurationAnim )( 
            IDABbox3 * This,
            /* [in] */ IDANumber *duration,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *Repeat )( 
            IDABbox3 * This,
            /* [in] */ LONG count,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *RepeatForever )( 
            IDABbox3 * This,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *IsReady )( 
            IDABbox3 * This,
            /* [in] */ VARIANT_BOOL bBlock,
            /* [retval][out] */ VARIANT_BOOL *b);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Min )( 
            IDABbox3 * This,
            /* [retval][out] */ IDAPoint3 **ret_0);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Max )( 
            IDABbox3 * This,
            /* [retval][out] */ IDAPoint3 **ret_0);
        
        END_INTERFACE
    } IDABbox3Vtbl;

    interface IDABbox3
    {
        CONST_VTBL struct IDABbox3Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDABbox3_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDABbox3_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDABbox3_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDABbox3_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDABbox3_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDABbox3_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDABbox3_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDABbox3_GetClassName(This,pClassName)	\
    (This)->lpVtbl -> GetClassName(This,pClassName)

#define IDABbox3_Init(This,toBvr)	\
    (This)->lpVtbl -> Init(This,toBvr)

#define IDABbox3_Importance(This,relativeImportance,ppBvr)	\
    (This)->lpVtbl -> Importance(This,relativeImportance,ppBvr)

#define IDABbox3_RunOnce(This,bvr)	\
    (This)->lpVtbl -> RunOnce(This,bvr)

#define IDABbox3_SubstituteTime(This,xform,bvr)	\
    (This)->lpVtbl -> SubstituteTime(This,xform,bvr)

#define IDABbox3_SwitchTo(This,switchTo)	\
    (This)->lpVtbl -> SwitchTo(This,switchTo)

#define IDABbox3_SwitchToNumber(This,numToSwitchTo)	\
    (This)->lpVtbl -> SwitchToNumber(This,numToSwitchTo)

#define IDABbox3_SwitchToString(This,strToSwitchTo)	\
    (This)->lpVtbl -> SwitchToString(This,strToSwitchTo)

#define IDABbox3_Hook(This,notifier,pBvr)	\
    (This)->lpVtbl -> Hook(This,notifier,pBvr)

#define IDABbox3_Duration(This,duration,bvr)	\
    (This)->lpVtbl -> Duration(This,duration,bvr)

#define IDABbox3_DurationAnim(This,duration,bvr)	\
    (This)->lpVtbl -> DurationAnim(This,duration,bvr)

#define IDABbox3_Repeat(This,count,bvr)	\
    (This)->lpVtbl -> Repeat(This,count,bvr)

#define IDABbox3_RepeatForever(This,bvr)	\
    (This)->lpVtbl -> RepeatForever(This,bvr)

#define IDABbox3_IsReady(This,bBlock,b)	\
    (This)->lpVtbl -> IsReady(This,bBlock,b)


#define IDABbox3_get_Min(This,ret_0)	\
    (This)->lpVtbl -> get_Min(This,ret_0)

#define IDABbox3_get_Max(This,ret_0)	\
    (This)->lpVtbl -> get_Max(This,ret_0)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget] */ HRESULT STDMETHODCALLTYPE IDABbox3_get_Min_Proxy( 
    IDABbox3 * This,
    /* [retval][out] */ IDAPoint3 **ret_0);



/* [propget] */ HRESULT STDMETHODCALLTYPE IDABbox3_get_Max_Proxy( 
    IDABbox3 * This,
    /* [retval][out] */ IDAPoint3 **ret_0);




#endif 	/* __IDABbox3_INTERFACE_DEFINED__ */


#ifndef __IDAPair_INTERFACE_DEFINED__
#define __IDAPair_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDAPair
 * at Tue Nov 11 05:16:35 1997
 * using MIDL 3.02.88
 ****************************************/
/* [dual][hidden][oleautomation][unique][object][local][helpstring][uuid] */ 



EXTERN_C const IID IID_IDAPair;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("C46C1BF3-3C52-11d0-9200-848C1D000000")
    IDAPair : public IDABehavior
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_First( 
            /* [retval][out] */ IDABehavior **ret_0) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Second( 
            /* [retval][out] */ IDABehavior **ret_0) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDAPairVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDAPair * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDAPair * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDAPair * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDAPair * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDAPair * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDAPair * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDAPair * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassName )( 
            IDAPair * This,
            /* [retval][out] */ BSTR *pClassName);
        
        HRESULT ( STDMETHODCALLTYPE *Init )( 
            IDAPair * This,
            /* [in] */ IDABehavior *toBvr);
        
        HRESULT ( STDMETHODCALLTYPE *Importance )( 
            IDAPair * This,
            /* [in] */ double relativeImportance,
            /* [retval][out] */ IDABehavior **ppBvr);
        
        HRESULT ( STDMETHODCALLTYPE *RunOnce )( 
            IDAPair * This,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *SubstituteTime )( 
            IDAPair * This,
            /* [in] */ IDANumber *xform,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *SwitchTo )( 
            IDAPair * This,
            /* [in] */ IDABehavior *switchTo);
        
        HRESULT ( STDMETHODCALLTYPE *SwitchToNumber )( 
            IDAPair * This,
            /* [in] */ double numToSwitchTo);
        
        HRESULT ( STDMETHODCALLTYPE *SwitchToString )( 
            IDAPair * This,
            /* [in] */ BSTR strToSwitchTo);
        
        HRESULT ( STDMETHODCALLTYPE *Hook )( 
            IDAPair * This,
            /* [in] */ IDABvrHook *notifier,
            /* [retval][out] */ IDABehavior **pBvr);
        
        HRESULT ( STDMETHODCALLTYPE *Duration )( 
            IDAPair * This,
            /* [in] */ double duration,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *DurationAnim )( 
            IDAPair * This,
            /* [in] */ IDANumber *duration,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *Repeat )( 
            IDAPair * This,
            /* [in] */ LONG count,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *RepeatForever )( 
            IDAPair * This,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *IsReady )( 
            IDAPair * This,
            /* [in] */ VARIANT_BOOL bBlock,
            /* [retval][out] */ VARIANT_BOOL *b);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_First )( 
            IDAPair * This,
            /* [retval][out] */ IDABehavior **ret_0);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Second )( 
            IDAPair * This,
            /* [retval][out] */ IDABehavior **ret_0);
        
        END_INTERFACE
    } IDAPairVtbl;

    interface IDAPair
    {
        CONST_VTBL struct IDAPairVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDAPair_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDAPair_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDAPair_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDAPair_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDAPair_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDAPair_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDAPair_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDAPair_GetClassName(This,pClassName)	\
    (This)->lpVtbl -> GetClassName(This,pClassName)

#define IDAPair_Init(This,toBvr)	\
    (This)->lpVtbl -> Init(This,toBvr)

#define IDAPair_Importance(This,relativeImportance,ppBvr)	\
    (This)->lpVtbl -> Importance(This,relativeImportance,ppBvr)

#define IDAPair_RunOnce(This,bvr)	\
    (This)->lpVtbl -> RunOnce(This,bvr)

#define IDAPair_SubstituteTime(This,xform,bvr)	\
    (This)->lpVtbl -> SubstituteTime(This,xform,bvr)

#define IDAPair_SwitchTo(This,switchTo)	\
    (This)->lpVtbl -> SwitchTo(This,switchTo)

#define IDAPair_SwitchToNumber(This,numToSwitchTo)	\
    (This)->lpVtbl -> SwitchToNumber(This,numToSwitchTo)

#define IDAPair_SwitchToString(This,strToSwitchTo)	\
    (This)->lpVtbl -> SwitchToString(This,strToSwitchTo)

#define IDAPair_Hook(This,notifier,pBvr)	\
    (This)->lpVtbl -> Hook(This,notifier,pBvr)

#define IDAPair_Duration(This,duration,bvr)	\
    (This)->lpVtbl -> Duration(This,duration,bvr)

#define IDAPair_DurationAnim(This,duration,bvr)	\
    (This)->lpVtbl -> DurationAnim(This,duration,bvr)

#define IDAPair_Repeat(This,count,bvr)	\
    (This)->lpVtbl -> Repeat(This,count,bvr)

#define IDAPair_RepeatForever(This,bvr)	\
    (This)->lpVtbl -> RepeatForever(This,bvr)

#define IDAPair_IsReady(This,bBlock,b)	\
    (This)->lpVtbl -> IsReady(This,bBlock,b)


#define IDAPair_get_First(This,ret_0)	\
    (This)->lpVtbl -> get_First(This,ret_0)

#define IDAPair_get_Second(This,ret_0)	\
    (This)->lpVtbl -> get_Second(This,ret_0)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget] */ HRESULT STDMETHODCALLTYPE IDAPair_get_First_Proxy( 
    IDAPair * This,
    /* [retval][out] */ IDABehavior **ret_0);



/* [propget] */ HRESULT STDMETHODCALLTYPE IDAPair_get_Second_Proxy( 
    IDAPair * This,
    /* [retval][out] */ IDABehavior **ret_0);




#endif 	/* __IDAPair_INTERFACE_DEFINED__ */


#ifndef __IDAEvent_INTERFACE_DEFINED__
#define __IDAEvent_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDAEvent
 * at Tue Nov 11 05:16:35 1997
 * using MIDL 3.02.88
 ****************************************/
/* [dual][hidden][oleautomation][unique][object][local][helpstring][uuid] */ 



EXTERN_C const IID IID_IDAEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("50B4791E-4731-11d0-8912-00C04FC2A0CA")
    IDAEvent : public IDABehavior
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Notify( 
            /* [in] */ IDAUntilNotifier *notifier_0,
            /* [retval][out] */ IDAEvent **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Snapshot( 
            /* [in] */ IDABehavior *b_0,
            /* [retval][out] */ IDAEvent **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AttachData( 
            /* [in] */ IDABehavior *data_0,
            /* [retval][out] */ IDAEvent **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ScriptCallback( 
            /* [in] */ BSTR scriptlet_0,
            /* [in] */ BSTR language_1,
            /* [retval][out] */ IDAEvent **ret_2) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDAEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDAEvent * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDAEvent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDAEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDAEvent * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDAEvent * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDAEvent * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDAEvent * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassName )( 
            IDAEvent * This,
            /* [retval][out] */ BSTR *pClassName);
        
        HRESULT ( STDMETHODCALLTYPE *Init )( 
            IDAEvent * This,
            /* [in] */ IDABehavior *toBvr);
        
        HRESULT ( STDMETHODCALLTYPE *Importance )( 
            IDAEvent * This,
            /* [in] */ double relativeImportance,
            /* [retval][out] */ IDABehavior **ppBvr);
        
        HRESULT ( STDMETHODCALLTYPE *RunOnce )( 
            IDAEvent * This,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *SubstituteTime )( 
            IDAEvent * This,
            /* [in] */ IDANumber *xform,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *SwitchTo )( 
            IDAEvent * This,
            /* [in] */ IDABehavior *switchTo);
        
        HRESULT ( STDMETHODCALLTYPE *SwitchToNumber )( 
            IDAEvent * This,
            /* [in] */ double numToSwitchTo);
        
        HRESULT ( STDMETHODCALLTYPE *SwitchToString )( 
            IDAEvent * This,
            /* [in] */ BSTR strToSwitchTo);
        
        HRESULT ( STDMETHODCALLTYPE *Hook )( 
            IDAEvent * This,
            /* [in] */ IDABvrHook *notifier,
            /* [retval][out] */ IDABehavior **pBvr);
        
        HRESULT ( STDMETHODCALLTYPE *Duration )( 
            IDAEvent * This,
            /* [in] */ double duration,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *DurationAnim )( 
            IDAEvent * This,
            /* [in] */ IDANumber *duration,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *Repeat )( 
            IDAEvent * This,
            /* [in] */ LONG count,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *RepeatForever )( 
            IDAEvent * This,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *IsReady )( 
            IDAEvent * This,
            /* [in] */ VARIANT_BOOL bBlock,
            /* [retval][out] */ VARIANT_BOOL *b);
        
        HRESULT ( STDMETHODCALLTYPE *Notify )( 
            IDAEvent * This,
            /* [in] */ IDAUntilNotifier *notifier_0,
            /* [retval][out] */ IDAEvent **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *Snapshot )( 
            IDAEvent * This,
            /* [in] */ IDABehavior *b_0,
            /* [retval][out] */ IDAEvent **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *AttachData )( 
            IDAEvent * This,
            /* [in] */ IDABehavior *data_0,
            /* [retval][out] */ IDAEvent **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *ScriptCallback )( 
            IDAEvent * This,
            /* [in] */ BSTR scriptlet_0,
            /* [in] */ BSTR language_1,
            /* [retval][out] */ IDAEvent **ret_2);
        
        END_INTERFACE
    } IDAEventVtbl;

    interface IDAEvent
    {
        CONST_VTBL struct IDAEventVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDAEvent_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDAEvent_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDAEvent_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDAEvent_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDAEvent_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDAEvent_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDAEvent_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDAEvent_GetClassName(This,pClassName)	\
    (This)->lpVtbl -> GetClassName(This,pClassName)

#define IDAEvent_Init(This,toBvr)	\
    (This)->lpVtbl -> Init(This,toBvr)

#define IDAEvent_Importance(This,relativeImportance,ppBvr)	\
    (This)->lpVtbl -> Importance(This,relativeImportance,ppBvr)

#define IDAEvent_RunOnce(This,bvr)	\
    (This)->lpVtbl -> RunOnce(This,bvr)

#define IDAEvent_SubstituteTime(This,xform,bvr)	\
    (This)->lpVtbl -> SubstituteTime(This,xform,bvr)

#define IDAEvent_SwitchTo(This,switchTo)	\
    (This)->lpVtbl -> SwitchTo(This,switchTo)

#define IDAEvent_SwitchToNumber(This,numToSwitchTo)	\
    (This)->lpVtbl -> SwitchToNumber(This,numToSwitchTo)

#define IDAEvent_SwitchToString(This,strToSwitchTo)	\
    (This)->lpVtbl -> SwitchToString(This,strToSwitchTo)

#define IDAEvent_Hook(This,notifier,pBvr)	\
    (This)->lpVtbl -> Hook(This,notifier,pBvr)

#define IDAEvent_Duration(This,duration,bvr)	\
    (This)->lpVtbl -> Duration(This,duration,bvr)

#define IDAEvent_DurationAnim(This,duration,bvr)	\
    (This)->lpVtbl -> DurationAnim(This,duration,bvr)

#define IDAEvent_Repeat(This,count,bvr)	\
    (This)->lpVtbl -> Repeat(This,count,bvr)

#define IDAEvent_RepeatForever(This,bvr)	\
    (This)->lpVtbl -> RepeatForever(This,bvr)

#define IDAEvent_IsReady(This,bBlock,b)	\
    (This)->lpVtbl -> IsReady(This,bBlock,b)


#define IDAEvent_Notify(This,notifier_0,ret_1)	\
    (This)->lpVtbl -> Notify(This,notifier_0,ret_1)

#define IDAEvent_Snapshot(This,b_0,ret_1)	\
    (This)->lpVtbl -> Snapshot(This,b_0,ret_1)

#define IDAEvent_AttachData(This,data_0,ret_1)	\
    (This)->lpVtbl -> AttachData(This,data_0,ret_1)

#define IDAEvent_ScriptCallback(This,scriptlet_0,language_1,ret_2)	\
    (This)->lpVtbl -> ScriptCallback(This,scriptlet_0,language_1,ret_2)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDAEvent_Notify_Proxy( 
    IDAEvent * This,
    /* [in] */ IDAUntilNotifier *notifier_0,
    /* [retval][out] */ IDAEvent **ret_1);



HRESULT STDMETHODCALLTYPE IDAEvent_Snapshot_Proxy( 
    IDAEvent * This,
    /* [in] */ IDABehavior *b_0,
    /* [retval][out] */ IDAEvent **ret_1);



HRESULT STDMETHODCALLTYPE IDAEvent_AttachData_Proxy( 
    IDAEvent * This,
    /* [in] */ IDABehavior *data_0,
    /* [retval][out] */ IDAEvent **ret_1);



HRESULT STDMETHODCALLTYPE IDAEvent_ScriptCallback_Proxy( 
    IDAEvent * This,
    /* [in] */ BSTR scriptlet_0,
    /* [in] */ BSTR language_1,
    /* [retval][out] */ IDAEvent **ret_2);




#endif 	/* __IDAEvent_INTERFACE_DEFINED__ */


#ifndef __IDAArray_INTERFACE_DEFINED__
#define __IDAArray_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDAArray
 * at Tue Nov 11 05:16:35 1997
 * using MIDL 3.02.88
 ****************************************/
/* [dual][hidden][oleautomation][unique][object][local][helpstring][uuid] */ 



EXTERN_C const IID IID_IDAArray;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("D17506C2-6B26-11d0-8914-00C04FC2A0CA")
    IDAArray : public IDABehavior
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE NthAnim( 
            /* [in] */ IDANumber *index_0,
            /* [retval][out] */ IDABehavior **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Length( 
            /* [retval][out] */ IDANumber **ret_0) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDAArrayVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDAArray * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDAArray * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDAArray * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDAArray * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDAArray * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDAArray * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDAArray * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassName )( 
            IDAArray * This,
            /* [retval][out] */ BSTR *pClassName);
        
        HRESULT ( STDMETHODCALLTYPE *Init )( 
            IDAArray * This,
            /* [in] */ IDABehavior *toBvr);
        
        HRESULT ( STDMETHODCALLTYPE *Importance )( 
            IDAArray * This,
            /* [in] */ double relativeImportance,
            /* [retval][out] */ IDABehavior **ppBvr);
        
        HRESULT ( STDMETHODCALLTYPE *RunOnce )( 
            IDAArray * This,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *SubstituteTime )( 
            IDAArray * This,
            /* [in] */ IDANumber *xform,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *SwitchTo )( 
            IDAArray * This,
            /* [in] */ IDABehavior *switchTo);
        
        HRESULT ( STDMETHODCALLTYPE *SwitchToNumber )( 
            IDAArray * This,
            /* [in] */ double numToSwitchTo);
        
        HRESULT ( STDMETHODCALLTYPE *SwitchToString )( 
            IDAArray * This,
            /* [in] */ BSTR strToSwitchTo);
        
        HRESULT ( STDMETHODCALLTYPE *Hook )( 
            IDAArray * This,
            /* [in] */ IDABvrHook *notifier,
            /* [retval][out] */ IDABehavior **pBvr);
        
        HRESULT ( STDMETHODCALLTYPE *Duration )( 
            IDAArray * This,
            /* [in] */ double duration,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *DurationAnim )( 
            IDAArray * This,
            /* [in] */ IDANumber *duration,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *Repeat )( 
            IDAArray * This,
            /* [in] */ LONG count,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *RepeatForever )( 
            IDAArray * This,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *IsReady )( 
            IDAArray * This,
            /* [in] */ VARIANT_BOOL bBlock,
            /* [retval][out] */ VARIANT_BOOL *b);
        
        HRESULT ( STDMETHODCALLTYPE *NthAnim )( 
            IDAArray * This,
            /* [in] */ IDANumber *index_0,
            /* [retval][out] */ IDABehavior **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *Length )( 
            IDAArray * This,
            /* [retval][out] */ IDANumber **ret_0);
        
        END_INTERFACE
    } IDAArrayVtbl;

    interface IDAArray
    {
        CONST_VTBL struct IDAArrayVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDAArray_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDAArray_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDAArray_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDAArray_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDAArray_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDAArray_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDAArray_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDAArray_GetClassName(This,pClassName)	\
    (This)->lpVtbl -> GetClassName(This,pClassName)

#define IDAArray_Init(This,toBvr)	\
    (This)->lpVtbl -> Init(This,toBvr)

#define IDAArray_Importance(This,relativeImportance,ppBvr)	\
    (This)->lpVtbl -> Importance(This,relativeImportance,ppBvr)

#define IDAArray_RunOnce(This,bvr)	\
    (This)->lpVtbl -> RunOnce(This,bvr)

#define IDAArray_SubstituteTime(This,xform,bvr)	\
    (This)->lpVtbl -> SubstituteTime(This,xform,bvr)

#define IDAArray_SwitchTo(This,switchTo)	\
    (This)->lpVtbl -> SwitchTo(This,switchTo)

#define IDAArray_SwitchToNumber(This,numToSwitchTo)	\
    (This)->lpVtbl -> SwitchToNumber(This,numToSwitchTo)

#define IDAArray_SwitchToString(This,strToSwitchTo)	\
    (This)->lpVtbl -> SwitchToString(This,strToSwitchTo)

#define IDAArray_Hook(This,notifier,pBvr)	\
    (This)->lpVtbl -> Hook(This,notifier,pBvr)

#define IDAArray_Duration(This,duration,bvr)	\
    (This)->lpVtbl -> Duration(This,duration,bvr)

#define IDAArray_DurationAnim(This,duration,bvr)	\
    (This)->lpVtbl -> DurationAnim(This,duration,bvr)

#define IDAArray_Repeat(This,count,bvr)	\
    (This)->lpVtbl -> Repeat(This,count,bvr)

#define IDAArray_RepeatForever(This,bvr)	\
    (This)->lpVtbl -> RepeatForever(This,bvr)

#define IDAArray_IsReady(This,bBlock,b)	\
    (This)->lpVtbl -> IsReady(This,bBlock,b)


#define IDAArray_NthAnim(This,index_0,ret_1)	\
    (This)->lpVtbl -> NthAnim(This,index_0,ret_1)

#define IDAArray_Length(This,ret_0)	\
    (This)->lpVtbl -> Length(This,ret_0)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDAArray_NthAnim_Proxy( 
    IDAArray * This,
    /* [in] */ IDANumber *index_0,
    /* [retval][out] */ IDABehavior **ret_1);



HRESULT STDMETHODCALLTYPE IDAArray_Length_Proxy( 
    IDAArray * This,
    /* [retval][out] */ IDANumber **ret_0);




#endif 	/* __IDAArray_INTERFACE_DEFINED__ */


#ifndef __IDATuple_INTERFACE_DEFINED__
#define __IDATuple_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDATuple
 * at Tue Nov 11 05:16:35 1997
 * using MIDL 3.02.88
 ****************************************/
/* [dual][hidden][oleautomation][unique][object][local][helpstring][uuid] */ 



EXTERN_C const IID IID_IDATuple;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("5DFB2650-9668-11d0-B17B-00C04FC2A0CA")
    IDATuple : public IDABehavior
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Nth( 
            /* [in] */ long index_0,
            /* [retval][out] */ IDABehavior **ret_1) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Length( 
            /* [retval][out] */ long *ret_0) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDATupleVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDATuple * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDATuple * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDATuple * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDATuple * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDATuple * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDATuple * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDATuple * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassName )( 
            IDATuple * This,
            /* [retval][out] */ BSTR *pClassName);
        
        HRESULT ( STDMETHODCALLTYPE *Init )( 
            IDATuple * This,
            /* [in] */ IDABehavior *toBvr);
        
        HRESULT ( STDMETHODCALLTYPE *Importance )( 
            IDATuple * This,
            /* [in] */ double relativeImportance,
            /* [retval][out] */ IDABehavior **ppBvr);
        
        HRESULT ( STDMETHODCALLTYPE *RunOnce )( 
            IDATuple * This,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *SubstituteTime )( 
            IDATuple * This,
            /* [in] */ IDANumber *xform,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *SwitchTo )( 
            IDATuple * This,
            /* [in] */ IDABehavior *switchTo);
        
        HRESULT ( STDMETHODCALLTYPE *SwitchToNumber )( 
            IDATuple * This,
            /* [in] */ double numToSwitchTo);
        
        HRESULT ( STDMETHODCALLTYPE *SwitchToString )( 
            IDATuple * This,
            /* [in] */ BSTR strToSwitchTo);
        
        HRESULT ( STDMETHODCALLTYPE *Hook )( 
            IDATuple * This,
            /* [in] */ IDABvrHook *notifier,
            /* [retval][out] */ IDABehavior **pBvr);
        
        HRESULT ( STDMETHODCALLTYPE *Duration )( 
            IDATuple * This,
            /* [in] */ double duration,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *DurationAnim )( 
            IDATuple * This,
            /* [in] */ IDANumber *duration,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *Repeat )( 
            IDATuple * This,
            /* [in] */ LONG count,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *RepeatForever )( 
            IDATuple * This,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *IsReady )( 
            IDATuple * This,
            /* [in] */ VARIANT_BOOL bBlock,
            /* [retval][out] */ VARIANT_BOOL *b);
        
        HRESULT ( STDMETHODCALLTYPE *Nth )( 
            IDATuple * This,
            /* [in] */ long index_0,
            /* [retval][out] */ IDABehavior **ret_1);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Length )( 
            IDATuple * This,
            /* [retval][out] */ long *ret_0);
        
        END_INTERFACE
    } IDATupleVtbl;

    interface IDATuple
    {
        CONST_VTBL struct IDATupleVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDATuple_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDATuple_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDATuple_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDATuple_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDATuple_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDATuple_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDATuple_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDATuple_GetClassName(This,pClassName)	\
    (This)->lpVtbl -> GetClassName(This,pClassName)

#define IDATuple_Init(This,toBvr)	\
    (This)->lpVtbl -> Init(This,toBvr)

#define IDATuple_Importance(This,relativeImportance,ppBvr)	\
    (This)->lpVtbl -> Importance(This,relativeImportance,ppBvr)

#define IDATuple_RunOnce(This,bvr)	\
    (This)->lpVtbl -> RunOnce(This,bvr)

#define IDATuple_SubstituteTime(This,xform,bvr)	\
    (This)->lpVtbl -> SubstituteTime(This,xform,bvr)

#define IDATuple_SwitchTo(This,switchTo)	\
    (This)->lpVtbl -> SwitchTo(This,switchTo)

#define IDATuple_SwitchToNumber(This,numToSwitchTo)	\
    (This)->lpVtbl -> SwitchToNumber(This,numToSwitchTo)

#define IDATuple_SwitchToString(This,strToSwitchTo)	\
    (This)->lpVtbl -> SwitchToString(This,strToSwitchTo)

#define IDATuple_Hook(This,notifier,pBvr)	\
    (This)->lpVtbl -> Hook(This,notifier,pBvr)

#define IDATuple_Duration(This,duration,bvr)	\
    (This)->lpVtbl -> Duration(This,duration,bvr)

#define IDATuple_DurationAnim(This,duration,bvr)	\
    (This)->lpVtbl -> DurationAnim(This,duration,bvr)

#define IDATuple_Repeat(This,count,bvr)	\
    (This)->lpVtbl -> Repeat(This,count,bvr)

#define IDATuple_RepeatForever(This,bvr)	\
    (This)->lpVtbl -> RepeatForever(This,bvr)

#define IDATuple_IsReady(This,bBlock,b)	\
    (This)->lpVtbl -> IsReady(This,bBlock,b)


#define IDATuple_Nth(This,index_0,ret_1)	\
    (This)->lpVtbl -> Nth(This,index_0,ret_1)

#define IDATuple_get_Length(This,ret_0)	\
    (This)->lpVtbl -> get_Length(This,ret_0)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDATuple_Nth_Proxy( 
    IDATuple * This,
    /* [in] */ long index_0,
    /* [retval][out] */ IDABehavior **ret_1);



/* [propget] */ HRESULT STDMETHODCALLTYPE IDATuple_get_Length_Proxy( 
    IDATuple * This,
    /* [retval][out] */ long *ret_0);




#endif 	/* __IDATuple_INTERFACE_DEFINED__ */


#ifndef __IDAUserData_INTERFACE_DEFINED__
#define __IDAUserData_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDAUserData
 * at Tue Nov 11 05:16:35 1997
 * using MIDL 3.02.88
 ****************************************/
/* [dual][hidden][oleautomation][unique][object][local][helpstring][uuid] */ 



EXTERN_C const IID IID_IDAUserData;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("AF868305-AB0B-11d0-876A-00C04FC29D46")
    IDAUserData : public IDABehavior
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Data( 
            /* [retval][out] */ IUnknown **ret_0) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDAUserDataVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDAUserData * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDAUserData * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDAUserData * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDAUserData * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDAUserData * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDAUserData * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDAUserData * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassName )( 
            IDAUserData * This,
            /* [retval][out] */ BSTR *pClassName);
        
        HRESULT ( STDMETHODCALLTYPE *Init )( 
            IDAUserData * This,
            /* [in] */ IDABehavior *toBvr);
        
        HRESULT ( STDMETHODCALLTYPE *Importance )( 
            IDAUserData * This,
            /* [in] */ double relativeImportance,
            /* [retval][out] */ IDABehavior **ppBvr);
        
        HRESULT ( STDMETHODCALLTYPE *RunOnce )( 
            IDAUserData * This,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *SubstituteTime )( 
            IDAUserData * This,
            /* [in] */ IDANumber *xform,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *SwitchTo )( 
            IDAUserData * This,
            /* [in] */ IDABehavior *switchTo);
        
        HRESULT ( STDMETHODCALLTYPE *SwitchToNumber )( 
            IDAUserData * This,
            /* [in] */ double numToSwitchTo);
        
        HRESULT ( STDMETHODCALLTYPE *SwitchToString )( 
            IDAUserData * This,
            /* [in] */ BSTR strToSwitchTo);
        
        HRESULT ( STDMETHODCALLTYPE *Hook )( 
            IDAUserData * This,
            /* [in] */ IDABvrHook *notifier,
            /* [retval][out] */ IDABehavior **pBvr);
        
        HRESULT ( STDMETHODCALLTYPE *Duration )( 
            IDAUserData * This,
            /* [in] */ double duration,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *DurationAnim )( 
            IDAUserData * This,
            /* [in] */ IDANumber *duration,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *Repeat )( 
            IDAUserData * This,
            /* [in] */ LONG count,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *RepeatForever )( 
            IDAUserData * This,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *IsReady )( 
            IDAUserData * This,
            /* [in] */ VARIANT_BOOL bBlock,
            /* [retval][out] */ VARIANT_BOOL *b);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Data )( 
            IDAUserData * This,
            /* [retval][out] */ IUnknown **ret_0);
        
        END_INTERFACE
    } IDAUserDataVtbl;

    interface IDAUserData
    {
        CONST_VTBL struct IDAUserDataVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDAUserData_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDAUserData_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDAUserData_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDAUserData_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDAUserData_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDAUserData_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDAUserData_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDAUserData_GetClassName(This,pClassName)	\
    (This)->lpVtbl -> GetClassName(This,pClassName)

#define IDAUserData_Init(This,toBvr)	\
    (This)->lpVtbl -> Init(This,toBvr)

#define IDAUserData_Importance(This,relativeImportance,ppBvr)	\
    (This)->lpVtbl -> Importance(This,relativeImportance,ppBvr)

#define IDAUserData_RunOnce(This,bvr)	\
    (This)->lpVtbl -> RunOnce(This,bvr)

#define IDAUserData_SubstituteTime(This,xform,bvr)	\
    (This)->lpVtbl -> SubstituteTime(This,xform,bvr)

#define IDAUserData_SwitchTo(This,switchTo)	\
    (This)->lpVtbl -> SwitchTo(This,switchTo)

#define IDAUserData_SwitchToNumber(This,numToSwitchTo)	\
    (This)->lpVtbl -> SwitchToNumber(This,numToSwitchTo)

#define IDAUserData_SwitchToString(This,strToSwitchTo)	\
    (This)->lpVtbl -> SwitchToString(This,strToSwitchTo)

#define IDAUserData_Hook(This,notifier,pBvr)	\
    (This)->lpVtbl -> Hook(This,notifier,pBvr)

#define IDAUserData_Duration(This,duration,bvr)	\
    (This)->lpVtbl -> Duration(This,duration,bvr)

#define IDAUserData_DurationAnim(This,duration,bvr)	\
    (This)->lpVtbl -> DurationAnim(This,duration,bvr)

#define IDAUserData_Repeat(This,count,bvr)	\
    (This)->lpVtbl -> Repeat(This,count,bvr)

#define IDAUserData_RepeatForever(This,bvr)	\
    (This)->lpVtbl -> RepeatForever(This,bvr)

#define IDAUserData_IsReady(This,bBlock,b)	\
    (This)->lpVtbl -> IsReady(This,bBlock,b)


#define IDAUserData_get_Data(This,ret_0)	\
    (This)->lpVtbl -> get_Data(This,ret_0)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget] */ HRESULT STDMETHODCALLTYPE IDAUserData_get_Data_Proxy( 
    IDAUserData * This,
    /* [retval][out] */ IUnknown **ret_0);




#endif 	/* __IDAUserData_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_DABoolean;

#ifdef __cplusplus

class DECLSPEC_UUID("C46C1BC1-3C52-11d0-9200-848C1D000000")
DABoolean;
#endif

EXTERN_C const CLSID CLSID_DACamera;

#ifdef __cplusplus

class DECLSPEC_UUID("C46C1BE2-3C52-11d0-9200-848C1D000000")
DACamera;
#endif

EXTERN_C const CLSID CLSID_DAColor;

#ifdef __cplusplus

class DECLSPEC_UUID("C46C1BC6-3C52-11d0-9200-848C1D000000")
DAColor;
#endif

EXTERN_C const CLSID CLSID_DAGeometry;

#ifdef __cplusplus

class DECLSPEC_UUID("C46C1BE0-3C52-11d0-9200-848C1D000000")
DAGeometry;
#endif

EXTERN_C const CLSID CLSID_DAImage;

#ifdef __cplusplus

class DECLSPEC_UUID("C46C1BD4-3C52-11d0-9200-848C1D000000")
DAImage;
#endif

EXTERN_C const CLSID CLSID_DAMatte;

#ifdef __cplusplus

class DECLSPEC_UUID("C46C1BD2-3C52-11d0-9200-848C1D000000")
DAMatte;
#endif

EXTERN_C const CLSID CLSID_DAMicrophone;

#ifdef __cplusplus

class DECLSPEC_UUID("C46C1BE6-3C52-11d0-9200-848C1D000000")
DAMicrophone;
#endif

EXTERN_C const CLSID CLSID_DAMontage;

#ifdef __cplusplus

class DECLSPEC_UUID("C46C1BD6-3C52-11d0-9200-848C1D000000")
DAMontage;
#endif

EXTERN_C const CLSID CLSID_DANumber;

#ifdef __cplusplus

class DECLSPEC_UUID("9CDE7341-3C20-11d0-A330-00AA00B92C03")
DANumber;
#endif

EXTERN_C const CLSID CLSID_DAPath2;

#ifdef __cplusplus

class DECLSPEC_UUID("C46C1BD0-3C52-11d0-9200-848C1D000000")
DAPath2;
#endif

EXTERN_C const CLSID CLSID_DAPoint2;

#ifdef __cplusplus

class DECLSPEC_UUID("C46C1BC8-3C52-11d0-9200-848C1D000000")
DAPoint2;
#endif

EXTERN_C const CLSID CLSID_DAPoint3;

#ifdef __cplusplus

class DECLSPEC_UUID("C46C1BD8-3C52-11d0-9200-848C1D000000")
DAPoint3;
#endif

EXTERN_C const CLSID CLSID_DASound;

#ifdef __cplusplus

class DECLSPEC_UUID("C46C1BE4-3C52-11d0-9200-848C1D000000")
DASound;
#endif

EXTERN_C const CLSID CLSID_DAString;

#ifdef __cplusplus

class DECLSPEC_UUID("C46C1BC4-3C52-11d0-9200-848C1D000000")
DAString;
#endif

EXTERN_C const CLSID CLSID_DATransform2;

#ifdef __cplusplus

class DECLSPEC_UUID("C46C1BCC-3C52-11d0-9200-848C1D000000")
DATransform2;
#endif

EXTERN_C const CLSID CLSID_DATransform3;

#ifdef __cplusplus

class DECLSPEC_UUID("C46C1BDC-3C52-11d0-9200-848C1D000000")
DATransform3;
#endif

EXTERN_C const CLSID CLSID_DAVector2;

#ifdef __cplusplus

class DECLSPEC_UUID("C46C1BCA-3C52-11d0-9200-848C1D000000")
DAVector2;
#endif

EXTERN_C const CLSID CLSID_DAVector3;

#ifdef __cplusplus

class DECLSPEC_UUID("C46C1BDA-3C52-11d0-9200-848C1D000000")
DAVector3;
#endif

EXTERN_C const CLSID CLSID_DAFontStyle;

#ifdef __cplusplus

class DECLSPEC_UUID("25B0F91C-D23D-11d0-9B85-00C04FC2F51D")
DAFontStyle;
#endif

EXTERN_C const CLSID CLSID_DALineStyle;

#ifdef __cplusplus

class DECLSPEC_UUID("C46C1BF2-3C52-11d0-9200-848C1D000000")
DALineStyle;
#endif

EXTERN_C const CLSID CLSID_DAEndStyle;

#ifdef __cplusplus

class DECLSPEC_UUID("C46C1BEC-3C52-11d0-9200-848C1D000000")
DAEndStyle;
#endif

EXTERN_C const CLSID CLSID_DAJoinStyle;

#ifdef __cplusplus

class DECLSPEC_UUID("C46C1BEE-3C52-11d0-9200-848C1D000000")
DAJoinStyle;
#endif

EXTERN_C const CLSID CLSID_DADashStyle;

#ifdef __cplusplus

class DECLSPEC_UUID("C46C1BF0-3C52-11d0-9200-848C1D000000")
DADashStyle;
#endif

EXTERN_C const CLSID CLSID_DABbox2;

#ifdef __cplusplus

class DECLSPEC_UUID("C46C1BCE-3C52-11d0-9200-848C1D000000")
DABbox2;
#endif

EXTERN_C const CLSID CLSID_DABbox3;

#ifdef __cplusplus

class DECLSPEC_UUID("C46C1BDE-3C52-11d0-9200-848C1D000000")
DABbox3;
#endif

EXTERN_C const CLSID CLSID_DAPair;

#ifdef __cplusplus

class DECLSPEC_UUID("C46C1BF4-3C52-11d0-9200-848C1D000000")
DAPair;
#endif

EXTERN_C const CLSID CLSID_DAEvent;

#ifdef __cplusplus

class DECLSPEC_UUID("50B4791F-4731-11d0-8912-00C04FC2A0CA")
DAEvent;
#endif

EXTERN_C const CLSID CLSID_DAArray;

#ifdef __cplusplus

class DECLSPEC_UUID("D17506C3-6B26-11d0-8914-00C04FC2A0CA")
DAArray;
#endif

EXTERN_C const CLSID CLSID_DATuple;

#ifdef __cplusplus

class DECLSPEC_UUID("5DFB2651-9668-11d0-B17B-00C04FC2A0CA")
DATuple;
#endif

EXTERN_C const CLSID CLSID_DAUserData;

#ifdef __cplusplus

class DECLSPEC_UUID("AF868304-AB0B-11d0-876A-00C04FC29D46")
DAUserData;
#endif

#ifndef __IDAPreferences_INTERFACE_DEFINED__
#define __IDAPreferences_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDAPreferences
 * at Tue Nov 11 05:16:35 1997
 * using MIDL 3.02.88
 ****************************************/
/* [dual][oleautomation][unique][object][local][helpstring][uuid] */ 



EXTERN_C const IID IID_IDAPreferences;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("69B5BC70-9B19-11d0-9B60-00C04FC2F51D")
    IDAPreferences : public IDispatch
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE PutPreference( 
            /* [in] */ BSTR preferenceName,
            /* [in] */ VARIANT value) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPreference( 
            /* [in] */ BSTR preferenceName,
            /* [retval][out] */ VARIANT *value) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Propagate( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDAPreferencesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDAPreferences * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDAPreferences * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDAPreferences * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDAPreferences * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDAPreferences * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDAPreferences * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDAPreferences * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *PutPreference )( 
            IDAPreferences * This,
            /* [in] */ BSTR preferenceName,
            /* [in] */ VARIANT value);
        
        HRESULT ( STDMETHODCALLTYPE *GetPreference )( 
            IDAPreferences * This,
            /* [in] */ BSTR preferenceName,
            /* [retval][out] */ VARIANT *value);
        
        HRESULT ( STDMETHODCALLTYPE *Propagate )( 
            IDAPreferences * This);
        
        END_INTERFACE
    } IDAPreferencesVtbl;

    interface IDAPreferences
    {
        CONST_VTBL struct IDAPreferencesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDAPreferences_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDAPreferences_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDAPreferences_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDAPreferences_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDAPreferences_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDAPreferences_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDAPreferences_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDAPreferences_PutPreference(This,preferenceName,value)	\
    (This)->lpVtbl -> PutPreference(This,preferenceName,value)

#define IDAPreferences_GetPreference(This,preferenceName,value)	\
    (This)->lpVtbl -> GetPreference(This,preferenceName,value)

#define IDAPreferences_Propagate(This)	\
    (This)->lpVtbl -> Propagate(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDAPreferences_PutPreference_Proxy( 
    IDAPreferences * This,
    /* [in] */ BSTR preferenceName,
    /* [in] */ VARIANT value);



HRESULT STDMETHODCALLTYPE IDAPreferences_GetPreference_Proxy( 
    IDAPreferences * This,
    /* [in] */ BSTR preferenceName,
    /* [retval][out] */ VARIANT *value);



HRESULT STDMETHODCALLTYPE IDAPreferences_Propagate_Proxy( 
    IDAPreferences * This);




#endif 	/* __IDAPreferences_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_DAView;

#ifdef __cplusplus

class DECLSPEC_UUID("283807B5-2C60-11d0-A31D-00AA00B92C03")
DAView;
#endif

#ifndef __IDASite_INTERFACE_DEFINED__
#define __IDASite_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDASite
 * at Tue Nov 11 05:16:35 1997
 * using MIDL 3.02.88
 ****************************************/
/* [dual][oleautomation][unique][object][local][helpstring][uuid] */ 



EXTERN_C const IID IID_IDASite;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("45393DF0-54B9-11cf-92A2-00AA00B8A733")
    IDASite : public IDispatch
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetStatusText( 
            /* [in] */ BSTR StatusText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReportError( 
            /* [in] */ HRESULT hr,
            /* [in] */ BSTR ErrorText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReportGC( 
            /* [in] */ VARIANT_BOOL bStarting) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDASiteVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDASite * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDASite * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDASite * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDASite * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDASite * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDASite * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDASite * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *SetStatusText )( 
            IDASite * This,
            /* [in] */ BSTR StatusText);
        
        HRESULT ( STDMETHODCALLTYPE *ReportError )( 
            IDASite * This,
            /* [in] */ HRESULT hr,
            /* [in] */ BSTR ErrorText);
        
        HRESULT ( STDMETHODCALLTYPE *ReportGC )( 
            IDASite * This,
            /* [in] */ VARIANT_BOOL bStarting);
        
        END_INTERFACE
    } IDASiteVtbl;

    interface IDASite
    {
        CONST_VTBL struct IDASiteVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDASite_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDASite_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDASite_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDASite_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDASite_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDASite_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDASite_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDASite_SetStatusText(This,StatusText)	\
    (This)->lpVtbl -> SetStatusText(This,StatusText)

#define IDASite_ReportError(This,hr,ErrorText)	\
    (This)->lpVtbl -> ReportError(This,hr,ErrorText)

#define IDASite_ReportGC(This,bStarting)	\
    (This)->lpVtbl -> ReportGC(This,bStarting)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDASite_SetStatusText_Proxy( 
    IDASite * This,
    /* [in] */ BSTR StatusText);



HRESULT STDMETHODCALLTYPE IDASite_ReportError_Proxy( 
    IDASite * This,
    /* [in] */ HRESULT hr,
    /* [in] */ BSTR ErrorText);



HRESULT STDMETHODCALLTYPE IDASite_ReportGC_Proxy( 
    IDASite * This,
    /* [in] */ VARIANT_BOOL bStarting);




#endif 	/* __IDASite_INTERFACE_DEFINED__ */


#ifndef __IDAImportationResult_INTERFACE_DEFINED__
#define __IDAImportationResult_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDAImportationResult
 * at Tue Nov 11 05:16:35 1997
 * using MIDL 3.02.88
 ****************************************/
/* [dual][oleautomation][unique][object][local][helpstring][uuid] */ 



EXTERN_C const IID IID_IDAImportationResult;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("4A933702-E36F-11d0-9B99-00C04FC2F51D")
    IDAImportationResult : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Image( 
            /* [retval][out] */ IDAImage **ppImage) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Sound( 
            /* [retval][out] */ IDASound **ppSound) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Geometry( 
            /* [retval][out] */ IDAGeometry **ppGeometry) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Duration( 
            /* [retval][out] */ IDANumber **ppDuration) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_CompletionEvent( 
            /* [retval][out] */ IDAEvent **ppCompletionEvent) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Progress( 
            /* [retval][out] */ IDANumber **ppProgress) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Size( 
            /* [retval][out] */ IDANumber **ppSizeInBytes) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDAImportationResultVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDAImportationResult * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDAImportationResult * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDAImportationResult * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDAImportationResult * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDAImportationResult * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDAImportationResult * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDAImportationResult * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Image )( 
            IDAImportationResult * This,
            /* [retval][out] */ IDAImage **ppImage);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Sound )( 
            IDAImportationResult * This,
            /* [retval][out] */ IDASound **ppSound);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Geometry )( 
            IDAImportationResult * This,
            /* [retval][out] */ IDAGeometry **ppGeometry);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Duration )( 
            IDAImportationResult * This,
            /* [retval][out] */ IDANumber **ppDuration);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CompletionEvent )( 
            IDAImportationResult * This,
            /* [retval][out] */ IDAEvent **ppCompletionEvent);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Progress )( 
            IDAImportationResult * This,
            /* [retval][out] */ IDANumber **ppProgress);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Size )( 
            IDAImportationResult * This,
            /* [retval][out] */ IDANumber **ppSizeInBytes);
        
        END_INTERFACE
    } IDAImportationResultVtbl;

    interface IDAImportationResult
    {
        CONST_VTBL struct IDAImportationResultVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDAImportationResult_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDAImportationResult_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDAImportationResult_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDAImportationResult_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDAImportationResult_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDAImportationResult_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDAImportationResult_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDAImportationResult_get_Image(This,ppImage)	\
    (This)->lpVtbl -> get_Image(This,ppImage)

#define IDAImportationResult_get_Sound(This,ppSound)	\
    (This)->lpVtbl -> get_Sound(This,ppSound)

#define IDAImportationResult_get_Geometry(This,ppGeometry)	\
    (This)->lpVtbl -> get_Geometry(This,ppGeometry)

#define IDAImportationResult_get_Duration(This,ppDuration)	\
    (This)->lpVtbl -> get_Duration(This,ppDuration)

#define IDAImportationResult_get_CompletionEvent(This,ppCompletionEvent)	\
    (This)->lpVtbl -> get_CompletionEvent(This,ppCompletionEvent)

#define IDAImportationResult_get_Progress(This,ppProgress)	\
    (This)->lpVtbl -> get_Progress(This,ppProgress)

#define IDAImportationResult_get_Size(This,ppSizeInBytes)	\
    (This)->lpVtbl -> get_Size(This,ppSizeInBytes)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDAImportationResult_get_Image_Proxy( 
    IDAImportationResult * This,
    /* [retval][out] */ IDAImage **ppImage);



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDAImportationResult_get_Sound_Proxy( 
    IDAImportationResult * This,
    /* [retval][out] */ IDASound **ppSound);



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDAImportationResult_get_Geometry_Proxy( 
    IDAImportationResult * This,
    /* [retval][out] */ IDAGeometry **ppGeometry);



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDAImportationResult_get_Duration_Proxy( 
    IDAImportationResult * This,
    /* [retval][out] */ IDANumber **ppDuration);



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDAImportationResult_get_CompletionEvent_Proxy( 
    IDAImportationResult * This,
    /* [retval][out] */ IDAEvent **ppCompletionEvent);



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDAImportationResult_get_Progress_Proxy( 
    IDAImportationResult * This,
    /* [retval][out] */ IDANumber **ppProgress);



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDAImportationResult_get_Size_Proxy( 
    IDAImportationResult * This,
    /* [retval][out] */ IDANumber **ppSizeInBytes);




#endif 	/* __IDAImportationResult_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_DAImportationResult;

#ifdef __cplusplus

class DECLSPEC_UUID("BCBB1F75-E384-11d0-9B99-00C04FC2F51D")
DAImportationResult;
#endif

EXTERN_C const CLSID CLSID_DAPickableResult;

#ifdef __cplusplus

class DECLSPEC_UUID("BCBB1F74-E384-11d0-9B99-00C04FC2F51D")
DAPickableResult;
#endif

#ifndef __IDAStatics_INTERFACE_DEFINED__
#define __IDAStatics_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDAStatics
 * at Tue Nov 11 05:16:35 1997
 * using MIDL 3.02.88
 ****************************************/
/* [dual][hidden][oleautomation][unique][object][local][helpstring][uuid] */ 



EXTERN_C const IID IID_IDAStatics;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("542FB452-5003-11cf-92A2-00AA00B8A733")
    IDAStatics : public IDispatch
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_VersionString( 
            /* [retval][out] */ BSTR *str) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Site( 
            /* [retval][out] */ IDASite **pSite) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Site( 
            /* [in] */ IDASite *pSite) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ClientSite( 
            /* [in] */ IOleClientSite *pClientSite) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ClientSite( 
            /* [retval][out] */ IOleClientSite **pClientSite) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_PixelConstructionMode( 
            /* [in] */ VARIANT_BOOL bMode) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_PixelConstructionMode( 
            /* [retval][out] */ VARIANT_BOOL *bMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TriggerEvent( 
            /* [in] */ IDAEvent *event,
            /* [in] */ IDABehavior *data) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NewDrawingSurface( 
            /* [retval][out] */ IDADrawingSurface **pds) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ImportMovie( 
            /* [in] */ BSTR url,
            /* [retval][out] */ IDAImportationResult **ppResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ImportMovieAsync( 
            /* [in] */ BSTR url,
            /* [in] */ IDAImage *pImageStandIn,
            /* [in] */ IDASound *pSoundStandIn,
            /* [retval][out] */ IDAImportationResult **ppResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ImportImage( 
            /* [in] */ BSTR url,
            /* [retval][out] */ IDAImage **ppImage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ImportImageAsync( 
            /* [in] */ BSTR url,
            /* [in] */ IDAImage *pImageStandIn,
            /* [retval][out] */ IDAImportationResult **ppResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ImportImageColorKey( 
            /* [in] */ BSTR url,
            /* [in] */ BYTE colorKeyRed,
            /* [in] */ BYTE colorKeyGreen,
            /* [in] */ BYTE colorKeyBlue,
            /* [retval][out] */ IDAImage **ppImage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ImportImageAsyncColorKey( 
            /* [in] */ BSTR url,
            /* [in] */ IDAImage *pImageStandIn,
            /* [in] */ BYTE colorKeyRed,
            /* [in] */ BYTE colorKeyGreen,
            /* [in] */ BYTE colorKeyBlue,
            /* [retval][out] */ IDAImportationResult **ppResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ImportSound( 
            /* [in] */ BSTR url,
            /* [retval][out] */ IDAImportationResult **ppResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ImportSoundAsync( 
            /* [in] */ BSTR url,
            /* [in] */ IDASound *pSoundStandIn,
            /* [retval][out] */ IDAImportationResult **ppResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ImportGeometry( 
            /* [in] */ BSTR url,
            /* [retval][out] */ IDAGeometry **ppGeometry) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ImportGeometryAsync( 
            /* [in] */ BSTR url,
            /* [in] */ IDAGeometry *pGeoStandIn,
            /* [retval][out] */ IDAImportationResult **ppResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ImportDirectDrawSurface( 
            /* [in] */ IUnknown *dds,
            /* [in] */ IDAEvent *updateEvent,
            /* [retval][out] */ IDAImage **ppImage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Cond( 
            /* [in] */ IDABoolean *c,
            /* [in] */ IDABehavior *i,
            /* [in] */ IDABehavior *e,
            /* [retval][out] */ IDABehavior **pCondBvr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DAArrayEx( 
            /* [in] */ LONG s,
            /* [size_is][in] */ IDABehavior *pBvrs[  ],
            /* [retval][out] */ IDAArray **bvr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DAArray( 
            /* [in] */ VARIANT bvrs,
            /* [retval][out] */ IDAArray **bvr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DATupleEx( 
            /* [in] */ LONG s,
            /* [size_is][in] */ IDABehavior *pBvrs[  ],
            /* [retval][out] */ IDATuple **bvr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DATuple( 
            /* [in] */ VARIANT bvrs,
            /* [retval][out] */ IDATuple **bvr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ModifiableBehavior( 
            /* [in] */ IDABehavior *orig,
            /* [retval][out] */ IDABehavior **bvr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UninitializedArray( 
            /* [in] */ IDAArray *typeTmp,
            /* [retval][out] */ IDAArray **bvr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UninitializedTuple( 
            /* [in] */ IDATuple *typeTmp,
            /* [retval][out] */ IDATuple **bvr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NumberBSplineEx( 
            /* [in] */ int degree,
            /* [in] */ LONG numKnots,
            /* [size_is][in] */ IDANumber *knots[  ],
            /* [in] */ LONG numPts,
            /* [size_is][in] */ IDANumber *ctrlPts[  ],
            /* [in] */ LONG numWts,
            /* [size_is][in] */ IDANumber *weights[  ],
            /* [in] */ IDANumber *evaluator,
            /* [retval][out] */ IDANumber **bvr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NumberBSpline( 
            /* [in] */ int degree,
            /* [in] */ VARIANT knots,
            /* [in] */ VARIANT CtrlPts,
            /* [in] */ VARIANT weights,
            /* [in] */ IDANumber *evaluator,
            /* [retval][out] */ IDANumber **bvr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Point2BSplineEx( 
            /* [in] */ int degree,
            /* [in] */ LONG numKnots,
            /* [size_is][in] */ IDANumber *knots[  ],
            /* [in] */ LONG numPts,
            /* [size_is][in] */ IDAPoint2 *ctrlPts[  ],
            /* [in] */ LONG numWts,
            /* [size_is][in] */ IDANumber *weights[  ],
            /* [in] */ IDANumber *evaluator,
            /* [retval][out] */ IDAPoint2 **bvr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Point2BSpline( 
            /* [in] */ int degree,
            /* [in] */ VARIANT knots,
            /* [in] */ VARIANT CtrlPts,
            /* [in] */ VARIANT weights,
            /* [in] */ IDANumber *evaluator,
            /* [retval][out] */ IDAPoint2 **bvr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Point3BSplineEx( 
            /* [in] */ int degree,
            /* [in] */ LONG numKnots,
            /* [size_is][in] */ IDANumber *knots[  ],
            /* [in] */ LONG numPts,
            /* [size_is][in] */ IDAPoint3 *ctrlPts[  ],
            /* [in] */ LONG numWts,
            /* [size_is][in] */ IDANumber *weights[  ],
            /* [in] */ IDANumber *evaluator,
            /* [retval][out] */ IDAPoint3 **bvr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Point3BSpline( 
            /* [in] */ int degree,
            /* [in] */ VARIANT knots,
            /* [in] */ VARIANT CtrlPts,
            /* [in] */ VARIANT weights,
            /* [in] */ IDANumber *evaluator,
            /* [retval][out] */ IDAPoint3 **bvr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Vector2BSplineEx( 
            /* [in] */ int degree,
            /* [in] */ LONG numKnots,
            /* [size_is][in] */ IDANumber *knots[  ],
            /* [in] */ LONG numPts,
            /* [size_is][in] */ IDAVector2 *ctrlPts[  ],
            /* [in] */ LONG numWts,
            /* [size_is][in] */ IDANumber *weights[  ],
            /* [in] */ IDANumber *evaluator,
            /* [retval][out] */ IDAVector2 **bvr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Vector2BSpline( 
            /* [in] */ int degree,
            /* [in] */ VARIANT knots,
            /* [in] */ VARIANT CtrlPts,
            /* [in] */ VARIANT weights,
            /* [in] */ IDANumber *evaluator,
            /* [retval][out] */ IDAVector2 **bvr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Vector3BSplineEx( 
            /* [in] */ int degree,
            /* [in] */ LONG numKnots,
            /* [size_is][in] */ IDANumber *knots[  ],
            /* [in] */ LONG numPts,
            /* [size_is][in] */ IDAVector3 *ctrlPts[  ],
            /* [in] */ LONG numWts,
            /* [size_is][in] */ IDANumber *weights[  ],
            /* [in] */ IDANumber *evaluator,
            /* [retval][out] */ IDAVector3 **bvr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Vector3BSpline( 
            /* [in] */ int degree,
            /* [in] */ VARIANT knots,
            /* [in] */ VARIANT CtrlPts,
            /* [in] */ VARIANT weights,
            /* [in] */ IDANumber *evaluator,
            /* [retval][out] */ IDAVector3 **bvr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Pow( 
            /* [in] */ IDANumber *a_0,
            /* [in] */ IDANumber *b_1,
            /* [retval][out] */ IDANumber **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Abs( 
            /* [in] */ IDANumber *a_0,
            /* [retval][out] */ IDANumber **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Sqrt( 
            /* [in] */ IDANumber *a_0,
            /* [retval][out] */ IDANumber **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Floor( 
            /* [in] */ IDANumber *a_0,
            /* [retval][out] */ IDANumber **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Round( 
            /* [in] */ IDANumber *a_0,
            /* [retval][out] */ IDANumber **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Ceiling( 
            /* [in] */ IDANumber *a_0,
            /* [retval][out] */ IDANumber **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Asin( 
            /* [in] */ IDANumber *a_0,
            /* [retval][out] */ IDANumber **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Acos( 
            /* [in] */ IDANumber *a_0,
            /* [retval][out] */ IDANumber **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Atan( 
            /* [in] */ IDANumber *a_0,
            /* [retval][out] */ IDANumber **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Sin( 
            /* [in] */ IDANumber *a_0,
            /* [retval][out] */ IDANumber **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Cos( 
            /* [in] */ IDANumber *a_0,
            /* [retval][out] */ IDANumber **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Tan( 
            /* [in] */ IDANumber *a_0,
            /* [retval][out] */ IDANumber **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Exp( 
            /* [in] */ IDANumber *a_0,
            /* [retval][out] */ IDANumber **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Ln( 
            /* [in] */ IDANumber *a_0,
            /* [retval][out] */ IDANumber **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Log10( 
            /* [in] */ IDANumber *a_0,
            /* [retval][out] */ IDANumber **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ToDegrees( 
            /* [in] */ IDANumber *a_0,
            /* [retval][out] */ IDANumber **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ToRadians( 
            /* [in] */ IDANumber *a_0,
            /* [retval][out] */ IDANumber **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Mod( 
            /* [in] */ IDANumber *a_0,
            /* [in] */ IDANumber *b_1,
            /* [retval][out] */ IDANumber **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Atan2( 
            /* [in] */ IDANumber *a_0,
            /* [in] */ IDANumber *b_1,
            /* [retval][out] */ IDANumber **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Add( 
            /* [in] */ IDANumber *a_0,
            /* [in] */ IDANumber *b_1,
            /* [retval][out] */ IDANumber **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Sub( 
            /* [in] */ IDANumber *a_0,
            /* [in] */ IDANumber *b_1,
            /* [retval][out] */ IDANumber **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Mul( 
            /* [in] */ IDANumber *a_0,
            /* [in] */ IDANumber *b_1,
            /* [retval][out] */ IDANumber **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Div( 
            /* [in] */ IDANumber *a_0,
            /* [in] */ IDANumber *b_1,
            /* [retval][out] */ IDANumber **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LT( 
            /* [in] */ IDANumber *a_0,
            /* [in] */ IDANumber *b_1,
            /* [retval][out] */ IDABoolean **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LTE( 
            /* [in] */ IDANumber *a_0,
            /* [in] */ IDANumber *b_1,
            /* [retval][out] */ IDABoolean **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GT( 
            /* [in] */ IDANumber *a_0,
            /* [in] */ IDANumber *b_1,
            /* [retval][out] */ IDABoolean **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GTE( 
            /* [in] */ IDANumber *a_0,
            /* [in] */ IDANumber *b_1,
            /* [retval][out] */ IDABoolean **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EQ( 
            /* [in] */ IDANumber *a_0,
            /* [in] */ IDANumber *b_1,
            /* [retval][out] */ IDABoolean **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NE( 
            /* [in] */ IDANumber *a_0,
            /* [in] */ IDANumber *b_1,
            /* [retval][out] */ IDABoolean **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Neg( 
            /* [in] */ IDANumber *a_0,
            /* [retval][out] */ IDANumber **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InterpolateAnim( 
            /* [in] */ IDANumber *from_0,
            /* [in] */ IDANumber *to_1,
            /* [in] */ IDANumber *duration_2,
            /* [retval][out] */ IDANumber **ret_3) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Interpolate( 
            /* [in] */ double from_0,
            /* [in] */ double to_1,
            /* [in] */ double duration_2,
            /* [retval][out] */ IDANumber **ret_3) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SlowInSlowOutAnim( 
            /* [in] */ IDANumber *from_0,
            /* [in] */ IDANumber *to_1,
            /* [in] */ IDANumber *duration_2,
            /* [in] */ IDANumber *sharpness_3,
            /* [retval][out] */ IDANumber **ret_4) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SlowInSlowOut( 
            /* [in] */ double from_0,
            /* [in] */ double to_1,
            /* [in] */ double duration_2,
            /* [in] */ double sharpness_3,
            /* [retval][out] */ IDANumber **ret_4) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SoundSource( 
            /* [in] */ IDASound *snd_0,
            /* [retval][out] */ IDAGeometry **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Mix( 
            /* [in] */ IDASound *left_0,
            /* [in] */ IDASound *right_1,
            /* [retval][out] */ IDASound **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE And( 
            /* [in] */ IDABoolean *a_0,
            /* [in] */ IDABoolean *b_1,
            /* [retval][out] */ IDABoolean **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Or( 
            /* [in] */ IDABoolean *a_0,
            /* [in] */ IDABoolean *b_1,
            /* [retval][out] */ IDABoolean **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Not( 
            /* [in] */ IDABoolean *a_0,
            /* [retval][out] */ IDABoolean **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Integral( 
            /* [in] */ IDANumber *b_0,
            /* [retval][out] */ IDANumber **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Derivative( 
            /* [in] */ IDANumber *b_0,
            /* [retval][out] */ IDANumber **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IntegralVector2( 
            /* [in] */ IDAVector2 *v_0,
            /* [retval][out] */ IDAVector2 **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IntegralVector3( 
            /* [in] */ IDAVector3 *v_0,
            /* [retval][out] */ IDAVector3 **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DerivativeVector2( 
            /* [in] */ IDAVector2 *v_0,
            /* [retval][out] */ IDAVector2 **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DerivativeVector3( 
            /* [in] */ IDAVector3 *v_0,
            /* [retval][out] */ IDAVector3 **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DerivativePoint2( 
            /* [in] */ IDAPoint2 *v_0,
            /* [retval][out] */ IDAVector2 **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DerivativePoint3( 
            /* [in] */ IDAPoint3 *v_0,
            /* [retval][out] */ IDAVector3 **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE KeyState( 
            /* [in] */ IDANumber *n_0,
            /* [retval][out] */ IDABoolean **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE KeyUp( 
            /* [in] */ LONG arg_0,
            /* [retval][out] */ IDAEvent **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE KeyDown( 
            /* [in] */ LONG arg_0,
            /* [retval][out] */ IDAEvent **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DANumber( 
            /* [in] */ double num_0,
            /* [retval][out] */ IDANumber **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DAString( 
            /* [in] */ BSTR str_0,
            /* [retval][out] */ IDAString **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DABoolean( 
            /* [in] */ VARIANT_BOOL num_0,
            /* [retval][out] */ IDABoolean **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SeededRandom( 
            /* [in] */ double arg_0,
            /* [retval][out] */ IDANumber **ret_1) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_MousePosition( 
            /* [retval][out] */ IDAPoint2 **ret_0) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_LeftButtonState( 
            /* [retval][out] */ IDABoolean **ret_0) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_RightButtonState( 
            /* [retval][out] */ IDABoolean **ret_0) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_DATrue( 
            /* [retval][out] */ IDABoolean **ret_0) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_DAFalse( 
            /* [retval][out] */ IDABoolean **ret_0) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_LocalTime( 
            /* [retval][out] */ IDANumber **ret_0) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_GlobalTime( 
            /* [retval][out] */ IDANumber **ret_0) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Pixel( 
            /* [retval][out] */ IDANumber **ret_0) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UserData( 
            /* [in] */ IUnknown *data_0,
            /* [retval][out] */ IDAUserData **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UntilNotify( 
            /* [in] */ IDABehavior *b0_0,
            /* [in] */ IDAEvent *event_1,
            /* [in] */ IDAUntilNotifier *notifier_2,
            /* [retval][out] */ IDABehavior **ret_3) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Until( 
            /* [in] */ IDABehavior *b0_0,
            /* [in] */ IDAEvent *event_1,
            /* [in] */ IDABehavior *b1_2,
            /* [retval][out] */ IDABehavior **ret_3) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UntilEx( 
            /* [in] */ IDABehavior *b0_0,
            /* [in] */ IDAEvent *event_1,
            /* [retval][out] */ IDABehavior **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Sequence( 
            /* [in] */ IDABehavior *s1_0,
            /* [in] */ IDABehavior *s2_1,
            /* [retval][out] */ IDABehavior **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FollowPath( 
            /* [in] */ IDAPath2 *path_0,
            /* [in] */ double duration_1,
            /* [retval][out] */ IDATransform2 **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FollowPathAngle( 
            /* [in] */ IDAPath2 *path_0,
            /* [in] */ double duration_1,
            /* [retval][out] */ IDATransform2 **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FollowPathAngleUpright( 
            /* [in] */ IDAPath2 *path_0,
            /* [in] */ double duration_1,
            /* [retval][out] */ IDATransform2 **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FollowPathEval( 
            /* [in] */ IDAPath2 *path_0,
            /* [in] */ IDANumber *eval_1,
            /* [retval][out] */ IDATransform2 **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FollowPathAngleEval( 
            /* [in] */ IDAPath2 *path_0,
            /* [in] */ IDANumber *eval_1,
            /* [retval][out] */ IDATransform2 **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FollowPathAngleUprightEval( 
            /* [in] */ IDAPath2 *path_0,
            /* [in] */ IDANumber *eval_1,
            /* [retval][out] */ IDATransform2 **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FollowPathAnim( 
            /* [in] */ IDAPath2 *obsoleted1_0,
            /* [in] */ IDANumber *obsoleted2_1,
            /* [retval][out] */ IDATransform2 **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FollowPathAngleAnim( 
            /* [in] */ IDAPath2 *obsoleted1_0,
            /* [in] */ IDANumber *obsoleted2_1,
            /* [retval][out] */ IDATransform2 **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FollowPathAngleUprightAnim( 
            /* [in] */ IDAPath2 *obsoleted1_0,
            /* [in] */ IDANumber *obsoleted2_1,
            /* [retval][out] */ IDATransform2 **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConcatString( 
            /* [in] */ IDAString *s1_0,
            /* [in] */ IDAString *s2_1,
            /* [retval][out] */ IDAString **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PerspectiveCamera( 
            /* [in] */ double focalDist_0,
            /* [in] */ double nearClip_1,
            /* [retval][out] */ IDACamera **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PerspectiveCameraAnim( 
            /* [in] */ IDANumber *focalDist_0,
            /* [in] */ IDANumber *nearClip_1,
            /* [retval][out] */ IDACamera **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ParallelCamera( 
            /* [in] */ double nearClip_0,
            /* [retval][out] */ IDACamera **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ParallelCameraAnim( 
            /* [in] */ IDANumber *nearClip_0,
            /* [retval][out] */ IDACamera **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ColorRgbAnim( 
            /* [in] */ IDANumber *red_0,
            /* [in] */ IDANumber *green_1,
            /* [in] */ IDANumber *blue_2,
            /* [retval][out] */ IDAColor **ret_3) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ColorRgb( 
            /* [in] */ double red_0,
            /* [in] */ double green_1,
            /* [in] */ double blue_2,
            /* [retval][out] */ IDAColor **ret_3) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ColorRgb255( 
            /* [in] */ short red_0,
            /* [in] */ short green_1,
            /* [in] */ short blue_2,
            /* [retval][out] */ IDAColor **ret_3) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ColorHsl( 
            /* [in] */ double hue_0,
            /* [in] */ double saturation_1,
            /* [in] */ double lum_2,
            /* [retval][out] */ IDAColor **ret_3) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ColorHslAnim( 
            /* [in] */ IDANumber *hue_0,
            /* [in] */ IDANumber *saturation_1,
            /* [in] */ IDANumber *lum_2,
            /* [retval][out] */ IDAColor **ret_3) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Red( 
            /* [retval][out] */ IDAColor **ret_0) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Green( 
            /* [retval][out] */ IDAColor **ret_0) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Blue( 
            /* [retval][out] */ IDAColor **ret_0) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Cyan( 
            /* [retval][out] */ IDAColor **ret_0) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Magenta( 
            /* [retval][out] */ IDAColor **ret_0) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Yellow( 
            /* [retval][out] */ IDAColor **ret_0) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Black( 
            /* [retval][out] */ IDAColor **ret_0) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_White( 
            /* [retval][out] */ IDAColor **ret_0) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Aqua( 
            /* [retval][out] */ IDAColor **ret_0) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Fuchsia( 
            /* [retval][out] */ IDAColor **ret_0) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Gray( 
            /* [retval][out] */ IDAColor **ret_0) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Lime( 
            /* [retval][out] */ IDAColor **ret_0) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Maroon( 
            /* [retval][out] */ IDAColor **ret_0) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Navy( 
            /* [retval][out] */ IDAColor **ret_0) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Olive( 
            /* [retval][out] */ IDAColor **ret_0) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Purple( 
            /* [retval][out] */ IDAColor **ret_0) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Silver( 
            /* [retval][out] */ IDAColor **ret_0) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Teal( 
            /* [retval][out] */ IDAColor **ret_0) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Predicate( 
            /* [in] */ IDABoolean *b_0,
            /* [retval][out] */ IDAEvent **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NotEvent( 
            /* [in] */ IDAEvent *event_0,
            /* [retval][out] */ IDAEvent **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AndEvent( 
            /* [in] */ IDAEvent *e1_0,
            /* [in] */ IDAEvent *e2_1,
            /* [retval][out] */ IDAEvent **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OrEvent( 
            /* [in] */ IDAEvent *e1_0,
            /* [in] */ IDAEvent *e2_1,
            /* [retval][out] */ IDAEvent **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ThenEvent( 
            /* [in] */ IDAEvent *e1_0,
            /* [in] */ IDAEvent *e2_1,
            /* [retval][out] */ IDAEvent **ret_2) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_LeftButtonDown( 
            /* [retval][out] */ IDAEvent **ret_0) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_LeftButtonUp( 
            /* [retval][out] */ IDAEvent **ret_0) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_RightButtonDown( 
            /* [retval][out] */ IDAEvent **ret_0) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_RightButtonUp( 
            /* [retval][out] */ IDAEvent **ret_0) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Always( 
            /* [retval][out] */ IDAEvent **ret_0) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Never( 
            /* [retval][out] */ IDAEvent **ret_0) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TimerAnim( 
            /* [in] */ IDANumber *n_0,
            /* [retval][out] */ IDAEvent **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Timer( 
            /* [in] */ double n_0,
            /* [retval][out] */ IDAEvent **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AppTriggeredEvent( 
            /* [retval][out] */ IDAEvent **ret_0) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ScriptCallback( 
            /* [in] */ BSTR obsolete1_0,
            /* [in] */ IDAEvent *obsolete2_1,
            /* [in] */ BSTR obsolete3_2,
            /* [retval][out] */ IDAEvent **ret_3) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_EmptyGeometry( 
            /* [retval][out] */ IDAGeometry **ret_0) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnionGeometry( 
            /* [in] */ IDAGeometry *g1_0,
            /* [in] */ IDAGeometry *g2_1,
            /* [retval][out] */ IDAGeometry **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnionGeometryArrayEx( 
            /* [in] */ LONG imgs_0size,
            /* [size_is][in] */ IDAGeometry *imgs_0[  ],
            /* [retval][out] */ IDAGeometry **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnionGeometryArray( 
            /* [in] */ VARIANT imgs_0,
            /* [retval][out] */ IDAGeometry **ret_1) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_EmptyImage( 
            /* [retval][out] */ IDAImage **ret_0) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_DetectableEmptyImage( 
            /* [retval][out] */ IDAImage **ret_0) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SolidColorImage( 
            /* [in] */ IDAColor *col_0,
            /* [retval][out] */ IDAImage **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GradientPolygonEx( 
            /* [in] */ LONG points_0size,
            /* [size_is][in] */ IDAPoint2 *points_0[  ],
            /* [in] */ LONG colors_1size,
            /* [size_is][in] */ IDAColor *colors_1[  ],
            /* [retval][out] */ IDAImage **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GradientPolygon( 
            /* [in] */ VARIANT points_0,
            /* [in] */ VARIANT colors_1,
            /* [retval][out] */ IDAImage **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RadialGradientPolygonEx( 
            /* [in] */ IDAColor *inner_0,
            /* [in] */ IDAColor *outer_1,
            /* [in] */ LONG points_2size,
            /* [size_is][in] */ IDAPoint2 *points_2[  ],
            /* [in] */ double fallOff_3,
            /* [retval][out] */ IDAImage **ret_4) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RadialGradientPolygon( 
            /* [in] */ IDAColor *inner_0,
            /* [in] */ IDAColor *outer_1,
            /* [in] */ VARIANT points_2,
            /* [in] */ double fallOff_3,
            /* [retval][out] */ IDAImage **ret_4) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RadialGradientPolygonAnimEx( 
            /* [in] */ IDAColor *inner_0,
            /* [in] */ IDAColor *outer_1,
            /* [in] */ LONG points_2size,
            /* [size_is][in] */ IDAPoint2 *points_2[  ],
            /* [in] */ IDANumber *fallOff_3,
            /* [retval][out] */ IDAImage **ret_4) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RadialGradientPolygonAnim( 
            /* [in] */ IDAColor *inner_0,
            /* [in] */ IDAColor *outer_1,
            /* [in] */ VARIANT points_2,
            /* [in] */ IDANumber *fallOff_3,
            /* [retval][out] */ IDAImage **ret_4) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GradientSquare( 
            /* [in] */ IDAColor *lowerLeft_0,
            /* [in] */ IDAColor *upperLeft_1,
            /* [in] */ IDAColor *upperRight_2,
            /* [in] */ IDAColor *lowerRight_3,
            /* [retval][out] */ IDAImage **ret_4) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RadialGradientSquare( 
            /* [in] */ IDAColor *inner_0,
            /* [in] */ IDAColor *outer_1,
            /* [in] */ double fallOff_2,
            /* [retval][out] */ IDAImage **ret_3) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RadialGradientSquareAnim( 
            /* [in] */ IDAColor *inner_0,
            /* [in] */ IDAColor *outer_1,
            /* [in] */ IDANumber *fallOff_2,
            /* [retval][out] */ IDAImage **ret_3) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RadialGradientRegularPoly( 
            /* [in] */ IDAColor *inner_0,
            /* [in] */ IDAColor *outer_1,
            /* [in] */ double numEdges_2,
            /* [in] */ double fallOff_3,
            /* [retval][out] */ IDAImage **ret_4) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RadialGradientRegularPolyAnim( 
            /* [in] */ IDAColor *inner_0,
            /* [in] */ IDAColor *outer_1,
            /* [in] */ IDANumber *numEdges_2,
            /* [in] */ IDANumber *fallOff_3,
            /* [retval][out] */ IDAImage **ret_4) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GradientHorizontal( 
            /* [in] */ IDAColor *start_0,
            /* [in] */ IDAColor *stop_1,
            /* [in] */ double fallOff_2,
            /* [retval][out] */ IDAImage **ret_3) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GradientHorizontalAnim( 
            /* [in] */ IDAColor *start_0,
            /* [in] */ IDAColor *stop_1,
            /* [in] */ IDANumber *fallOff_2,
            /* [retval][out] */ IDAImage **ret_3) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HatchHorizontal( 
            /* [in] */ IDAColor *lineClr_0,
            /* [in] */ double spacing_1,
            /* [retval][out] */ IDAImage **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HatchHorizontalAnim( 
            /* [in] */ IDAColor *lineClr_0,
            /* [in] */ IDANumber *spacing_1,
            /* [retval][out] */ IDAImage **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HatchVertical( 
            /* [in] */ IDAColor *lineClr_0,
            /* [in] */ double spacing_1,
            /* [retval][out] */ IDAImage **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HatchVerticalAnim( 
            /* [in] */ IDAColor *lineClr_0,
            /* [in] */ IDANumber *spacing_1,
            /* [retval][out] */ IDAImage **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HatchForwardDiagonal( 
            /* [in] */ IDAColor *lineClr_0,
            /* [in] */ double spacing_1,
            /* [retval][out] */ IDAImage **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HatchForwardDiagonalAnim( 
            /* [in] */ IDAColor *lineClr_0,
            /* [in] */ IDANumber *spacing_1,
            /* [retval][out] */ IDAImage **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HatchBackwardDiagonal( 
            /* [in] */ IDAColor *lineClr_0,
            /* [in] */ double spacing_1,
            /* [retval][out] */ IDAImage **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HatchBackwardDiagonalAnim( 
            /* [in] */ IDAColor *lineClr_0,
            /* [in] */ IDANumber *spacing_1,
            /* [retval][out] */ IDAImage **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HatchCross( 
            /* [in] */ IDAColor *lineClr_0,
            /* [in] */ double spacing_1,
            /* [retval][out] */ IDAImage **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HatchCrossAnim( 
            /* [in] */ IDAColor *lineClr_0,
            /* [in] */ IDANumber *spacing_1,
            /* [retval][out] */ IDAImage **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HatchDiagonalCross( 
            /* [in] */ IDAColor *lineClr_0,
            /* [in] */ double spacing_1,
            /* [retval][out] */ IDAImage **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HatchDiagonalCrossAnim( 
            /* [in] */ IDAColor *lineClr_0,
            /* [in] */ IDANumber *spacing_1,
            /* [retval][out] */ IDAImage **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Overlay( 
            /* [in] */ IDAImage *top_0,
            /* [in] */ IDAImage *bottom_1,
            /* [retval][out] */ IDAImage **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OverlayArrayEx( 
            /* [in] */ LONG imgs_0size,
            /* [size_is][in] */ IDAImage *imgs_0[  ],
            /* [retval][out] */ IDAImage **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OverlayArray( 
            /* [in] */ VARIANT imgs_0,
            /* [retval][out] */ IDAImage **ret_1) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_AmbientLight( 
            /* [retval][out] */ IDAGeometry **ret_0) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_DirectionalLight( 
            /* [retval][out] */ IDAGeometry **ret_0) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_PointLight( 
            /* [retval][out] */ IDAGeometry **ret_0) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SpotLightAnim( 
            /* [in] */ IDANumber *fullcone_0,
            /* [in] */ IDANumber *cutoff_1,
            /* [retval][out] */ IDAGeometry **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SpotLight( 
            /* [in] */ IDANumber *fullcone_0,
            /* [in] */ double cutoff_1,
            /* [retval][out] */ IDAGeometry **ret_2) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_DefaultLineStyle( 
            /* [retval][out] */ IDALineStyle **ret_0) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_EmptyLineStyle( 
            /* [retval][out] */ IDALineStyle **ret_0) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_JoinStyleBevel( 
            /* [retval][out] */ IDAJoinStyle **ret_0) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_JoinStyleRound( 
            /* [retval][out] */ IDAJoinStyle **ret_0) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_JoinStyleMiter( 
            /* [retval][out] */ IDAJoinStyle **ret_0) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_EndStyleFlat( 
            /* [retval][out] */ IDAEndStyle **ret_0) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_EndStyleSquare( 
            /* [retval][out] */ IDAEndStyle **ret_0) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_EndStyleRound( 
            /* [retval][out] */ IDAEndStyle **ret_0) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_DashStyleSolid( 
            /* [retval][out] */ IDADashStyle **ret_0) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_DashStyleDashed( 
            /* [retval][out] */ IDADashStyle **ret_0) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_DefaultMicrophone( 
            /* [retval][out] */ IDAMicrophone **ret_0) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_OpaqueMatte( 
            /* [retval][out] */ IDAMatte **ret_0) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ClearMatte( 
            /* [retval][out] */ IDAMatte **ret_0) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnionMatte( 
            /* [in] */ IDAMatte *m1_0,
            /* [in] */ IDAMatte *m2_1,
            /* [retval][out] */ IDAMatte **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IntersectMatte( 
            /* [in] */ IDAMatte *m1_0,
            /* [in] */ IDAMatte *m2_1,
            /* [retval][out] */ IDAMatte **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DifferenceMatte( 
            /* [in] */ IDAMatte *m1_0,
            /* [in] */ IDAMatte *m2_1,
            /* [retval][out] */ IDAMatte **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FillMatte( 
            /* [in] */ IDAPath2 *p_0,
            /* [retval][out] */ IDAMatte **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TextMatte( 
            /* [in] */ IDAString *str_0,
            /* [in] */ IDAFontStyle *fs_1,
            /* [retval][out] */ IDAMatte **ret_2) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_EmptyMontage( 
            /* [retval][out] */ IDAMontage **ret_0) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ImageMontage( 
            /* [in] */ IDAImage *im_0,
            /* [in] */ double depth_1,
            /* [retval][out] */ IDAMontage **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ImageMontageAnim( 
            /* [in] */ IDAImage *im_0,
            /* [in] */ IDANumber *depth_1,
            /* [retval][out] */ IDAMontage **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnionMontage( 
            /* [in] */ IDAMontage *m1_0,
            /* [in] */ IDAMontage *m2_1,
            /* [retval][out] */ IDAMontage **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Concat( 
            /* [in] */ IDAPath2 *p1_0,
            /* [in] */ IDAPath2 *p2_1,
            /* [retval][out] */ IDAPath2 **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConcatArrayEx( 
            /* [in] */ LONG paths_0size,
            /* [size_is][in] */ IDAPath2 *paths_0[  ],
            /* [retval][out] */ IDAPath2 **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConcatArray( 
            /* [in] */ VARIANT paths_0,
            /* [retval][out] */ IDAPath2 **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Line( 
            /* [in] */ IDAPoint2 *p1_0,
            /* [in] */ IDAPoint2 *p2_1,
            /* [retval][out] */ IDAPath2 **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Ray( 
            /* [in] */ IDAPoint2 *pt_0,
            /* [retval][out] */ IDAPath2 **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StringPathAnim( 
            /* [in] */ IDAString *str_0,
            /* [in] */ IDAFontStyle *fs_1,
            /* [retval][out] */ IDAPath2 **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StringPath( 
            /* [in] */ BSTR str_0,
            /* [in] */ IDAFontStyle *fs_1,
            /* [retval][out] */ IDAPath2 **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PolylineEx( 
            /* [in] */ LONG points_0size,
            /* [size_is][in] */ IDAPoint2 *points_0[  ],
            /* [retval][out] */ IDAPath2 **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Polyline( 
            /* [in] */ VARIANT points_0,
            /* [retval][out] */ IDAPath2 **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PolydrawPathEx( 
            /* [in] */ LONG points_0size,
            /* [size_is][in] */ IDAPoint2 *points_0[  ],
            /* [in] */ LONG codes_1size,
            /* [size_is][in] */ IDANumber *codes_1[  ],
            /* [retval][out] */ IDAPath2 **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PolydrawPath( 
            /* [in] */ VARIANT points_0,
            /* [in] */ VARIANT codes_1,
            /* [retval][out] */ IDAPath2 **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ArcRadians( 
            /* [in] */ double startAngle_0,
            /* [in] */ double endAngle_1,
            /* [in] */ double arcWidth_2,
            /* [in] */ double arcHeight_3,
            /* [retval][out] */ IDAPath2 **ret_4) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ArcRadiansAnim( 
            /* [in] */ IDANumber *startAngle_0,
            /* [in] */ IDANumber *endAngle_1,
            /* [in] */ IDANumber *arcWidth_2,
            /* [in] */ IDANumber *arcHeight_3,
            /* [retval][out] */ IDAPath2 **ret_4) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ArcDegrees( 
            /* [in] */ double startAngle_0,
            /* [in] */ double endAngle_1,
            /* [in] */ double arcWidth_2,
            /* [in] */ double arcHeight_3,
            /* [retval][out] */ IDAPath2 **ret_4) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PieRadians( 
            /* [in] */ double startAngle_0,
            /* [in] */ double endAngle_1,
            /* [in] */ double arcWidth_2,
            /* [in] */ double arcHeight_3,
            /* [retval][out] */ IDAPath2 **ret_4) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PieRadiansAnim( 
            /* [in] */ IDANumber *startAngle_0,
            /* [in] */ IDANumber *endAngle_1,
            /* [in] */ IDANumber *arcWidth_2,
            /* [in] */ IDANumber *arcHeight_3,
            /* [retval][out] */ IDAPath2 **ret_4) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PieDegrees( 
            /* [in] */ double startAngle_0,
            /* [in] */ double endAngle_1,
            /* [in] */ double arcWidth_2,
            /* [in] */ double arcHeight_3,
            /* [retval][out] */ IDAPath2 **ret_4) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Oval( 
            /* [in] */ double width_0,
            /* [in] */ double height_1,
            /* [retval][out] */ IDAPath2 **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OvalAnim( 
            /* [in] */ IDANumber *width_0,
            /* [in] */ IDANumber *height_1,
            /* [retval][out] */ IDAPath2 **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Rect( 
            /* [in] */ double width_0,
            /* [in] */ double height_1,
            /* [retval][out] */ IDAPath2 **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RectAnim( 
            /* [in] */ IDANumber *width_0,
            /* [in] */ IDANumber *height_1,
            /* [retval][out] */ IDAPath2 **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RoundRect( 
            /* [in] */ double width_0,
            /* [in] */ double height_1,
            /* [in] */ double cornerArcWidth_2,
            /* [in] */ double cornerArcHeight_3,
            /* [retval][out] */ IDAPath2 **ret_4) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RoundRectAnim( 
            /* [in] */ IDANumber *width_0,
            /* [in] */ IDANumber *height_1,
            /* [in] */ IDANumber *cornerArcWidth_2,
            /* [in] */ IDANumber *cornerArcHeight_3,
            /* [retval][out] */ IDAPath2 **ret_4) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CubicBSplinePathEx( 
            /* [in] */ LONG points_0size,
            /* [size_is][in] */ IDAPoint2 *points_0[  ],
            /* [in] */ LONG knots_1size,
            /* [size_is][in] */ IDANumber *knots_1[  ],
            /* [retval][out] */ IDAPath2 **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CubicBSplinePath( 
            /* [in] */ VARIANT points_0,
            /* [in] */ VARIANT knots_1,
            /* [retval][out] */ IDAPath2 **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TextPath( 
            /* [in] */ IDAString *obsolete1_0,
            /* [in] */ IDAFontStyle *obsolete2_1,
            /* [retval][out] */ IDAPath2 **ret_2) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Silence( 
            /* [retval][out] */ IDASound **ret_0) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MixArrayEx( 
            /* [in] */ LONG snds_0size,
            /* [size_is][in] */ IDASound *snds_0[  ],
            /* [retval][out] */ IDASound **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MixArray( 
            /* [in] */ VARIANT snds_0,
            /* [retval][out] */ IDASound **ret_1) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_SinSynth( 
            /* [retval][out] */ IDASound **ret_0) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_DefaultFont( 
            /* [retval][out] */ IDAFontStyle **ret_0) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FontAnim( 
            /* [in] */ IDAString *str_0,
            /* [in] */ IDANumber *size_1,
            /* [in] */ IDAColor *col_2,
            /* [retval][out] */ IDAFontStyle **ret_3) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Font( 
            /* [in] */ BSTR str_0,
            /* [in] */ double size_1,
            /* [in] */ IDAColor *col_2,
            /* [retval][out] */ IDAFontStyle **ret_3) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StringImageAnim( 
            /* [in] */ IDAString *str_0,
            /* [in] */ IDAFontStyle *fs_1,
            /* [retval][out] */ IDAImage **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StringImage( 
            /* [in] */ BSTR str_0,
            /* [in] */ IDAFontStyle *fs_1,
            /* [retval][out] */ IDAImage **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TextImageAnim( 
            /* [in] */ IDAString *obsoleted1_0,
            /* [in] */ IDAFontStyle *obsoleted2_1,
            /* [retval][out] */ IDAImage **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TextImage( 
            /* [in] */ BSTR obsoleted1_0,
            /* [in] */ IDAFontStyle *obsoleted2_1,
            /* [retval][out] */ IDAImage **ret_2) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_XVector2( 
            /* [retval][out] */ IDAVector2 **ret_0) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_YVector2( 
            /* [retval][out] */ IDAVector2 **ret_0) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ZeroVector2( 
            /* [retval][out] */ IDAVector2 **ret_0) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Origin2( 
            /* [retval][out] */ IDAPoint2 **ret_0) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Vector2Anim( 
            /* [in] */ IDANumber *x_0,
            /* [in] */ IDANumber *y_1,
            /* [retval][out] */ IDAVector2 **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Vector2( 
            /* [in] */ double x_0,
            /* [in] */ double y_1,
            /* [retval][out] */ IDAVector2 **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Point2Anim( 
            /* [in] */ IDANumber *x_0,
            /* [in] */ IDANumber *y_1,
            /* [retval][out] */ IDAPoint2 **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Point2( 
            /* [in] */ double x_0,
            /* [in] */ double y_1,
            /* [retval][out] */ IDAPoint2 **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Vector2PolarAnim( 
            /* [in] */ IDANumber *theta_0,
            /* [in] */ IDANumber *radius_1,
            /* [retval][out] */ IDAVector2 **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Vector2Polar( 
            /* [in] */ double theta_0,
            /* [in] */ double radius_1,
            /* [retval][out] */ IDAVector2 **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Vector2PolarDegrees( 
            /* [in] */ double theta_0,
            /* [in] */ double radius_1,
            /* [retval][out] */ IDAVector2 **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Point2PolarAnim( 
            /* [in] */ IDANumber *theta_0,
            /* [in] */ IDANumber *radius_1,
            /* [retval][out] */ IDAPoint2 **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Point2Polar( 
            /* [in] */ double theta_0,
            /* [in] */ double radius_1,
            /* [retval][out] */ IDAPoint2 **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DotVector2( 
            /* [in] */ IDAVector2 *v_0,
            /* [in] */ IDAVector2 *u_1,
            /* [retval][out] */ IDANumber **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NegVector2( 
            /* [in] */ IDAVector2 *v_0,
            /* [retval][out] */ IDAVector2 **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SubVector2( 
            /* [in] */ IDAVector2 *v1_0,
            /* [in] */ IDAVector2 *v2_1,
            /* [retval][out] */ IDAVector2 **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddVector2( 
            /* [in] */ IDAVector2 *v1_0,
            /* [in] */ IDAVector2 *v2_1,
            /* [retval][out] */ IDAVector2 **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddPoint2Vector( 
            /* [in] */ IDAPoint2 *p_0,
            /* [in] */ IDAVector2 *v_1,
            /* [retval][out] */ IDAPoint2 **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SubPoint2Vector( 
            /* [in] */ IDAPoint2 *p_0,
            /* [in] */ IDAVector2 *v_1,
            /* [retval][out] */ IDAPoint2 **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SubPoint2( 
            /* [in] */ IDAPoint2 *p1_0,
            /* [in] */ IDAPoint2 *p2_1,
            /* [retval][out] */ IDAVector2 **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DistancePoint2( 
            /* [in] */ IDAPoint2 *p_0,
            /* [in] */ IDAPoint2 *q_1,
            /* [retval][out] */ IDANumber **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DistanceSquaredPoint2( 
            /* [in] */ IDAPoint2 *p_0,
            /* [in] */ IDAPoint2 *q_1,
            /* [retval][out] */ IDANumber **ret_2) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_XVector3( 
            /* [retval][out] */ IDAVector3 **ret_0) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_YVector3( 
            /* [retval][out] */ IDAVector3 **ret_0) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ZVector3( 
            /* [retval][out] */ IDAVector3 **ret_0) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ZeroVector3( 
            /* [retval][out] */ IDAVector3 **ret_0) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Origin3( 
            /* [retval][out] */ IDAPoint3 **ret_0) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Vector3Anim( 
            /* [in] */ IDANumber *x_0,
            /* [in] */ IDANumber *y_1,
            /* [in] */ IDANumber *z_2,
            /* [retval][out] */ IDAVector3 **ret_3) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Vector3( 
            /* [in] */ double x_0,
            /* [in] */ double y_1,
            /* [in] */ double z_2,
            /* [retval][out] */ IDAVector3 **ret_3) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Point3Anim( 
            /* [in] */ IDANumber *x_0,
            /* [in] */ IDANumber *y_1,
            /* [in] */ IDANumber *z_2,
            /* [retval][out] */ IDAPoint3 **ret_3) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Point3( 
            /* [in] */ double x_0,
            /* [in] */ double y_1,
            /* [in] */ double z_2,
            /* [retval][out] */ IDAPoint3 **ret_3) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Vector3SphericalAnim( 
            /* [in] */ IDANumber *xyAngle_0,
            /* [in] */ IDANumber *yzAngle_1,
            /* [in] */ IDANumber *radius_2,
            /* [retval][out] */ IDAVector3 **ret_3) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Vector3Spherical( 
            /* [in] */ double xyAngle_0,
            /* [in] */ double yzAngle_1,
            /* [in] */ double radius_2,
            /* [retval][out] */ IDAVector3 **ret_3) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Point3SphericalAnim( 
            /* [in] */ IDANumber *zxAngle_0,
            /* [in] */ IDANumber *xyAngle_1,
            /* [in] */ IDANumber *radius_2,
            /* [retval][out] */ IDAPoint3 **ret_3) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Point3Spherical( 
            /* [in] */ double zxAngle_0,
            /* [in] */ double xyAngle_1,
            /* [in] */ double radius_2,
            /* [retval][out] */ IDAPoint3 **ret_3) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DotVector3( 
            /* [in] */ IDAVector3 *v_0,
            /* [in] */ IDAVector3 *u_1,
            /* [retval][out] */ IDANumber **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CrossVector3( 
            /* [in] */ IDAVector3 *v_0,
            /* [in] */ IDAVector3 *u_1,
            /* [retval][out] */ IDAVector3 **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NegVector3( 
            /* [in] */ IDAVector3 *v_0,
            /* [retval][out] */ IDAVector3 **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SubVector3( 
            /* [in] */ IDAVector3 *v1_0,
            /* [in] */ IDAVector3 *v2_1,
            /* [retval][out] */ IDAVector3 **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddVector3( 
            /* [in] */ IDAVector3 *v1_0,
            /* [in] */ IDAVector3 *v2_1,
            /* [retval][out] */ IDAVector3 **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddPoint3Vector( 
            /* [in] */ IDAPoint3 *p_0,
            /* [in] */ IDAVector3 *v_1,
            /* [retval][out] */ IDAPoint3 **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SubPoint3Vector( 
            /* [in] */ IDAPoint3 *p_0,
            /* [in] */ IDAVector3 *v_1,
            /* [retval][out] */ IDAPoint3 **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SubPoint3( 
            /* [in] */ IDAPoint3 *p1_0,
            /* [in] */ IDAPoint3 *p2_1,
            /* [retval][out] */ IDAVector3 **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DistancePoint3( 
            /* [in] */ IDAPoint3 *p_0,
            /* [in] */ IDAPoint3 *q_1,
            /* [retval][out] */ IDANumber **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DistanceSquaredPoint3( 
            /* [in] */ IDAPoint3 *p_0,
            /* [in] */ IDAPoint3 *q_1,
            /* [retval][out] */ IDANumber **ret_2) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_IdentityTransform3( 
            /* [retval][out] */ IDATransform3 **ret_0) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Translate3Anim( 
            /* [in] */ IDANumber *tx_0,
            /* [in] */ IDANumber *ty_1,
            /* [in] */ IDANumber *tz_2,
            /* [retval][out] */ IDATransform3 **ret_3) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Translate3( 
            /* [in] */ double tx_0,
            /* [in] */ double ty_1,
            /* [in] */ double tz_2,
            /* [retval][out] */ IDATransform3 **ret_3) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Translate3Rate( 
            /* [in] */ double tx_0,
            /* [in] */ double ty_1,
            /* [in] */ double tz_2,
            /* [retval][out] */ IDATransform3 **ret_3) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Translate3Vector( 
            /* [in] */ IDAVector3 *delta_0,
            /* [retval][out] */ IDATransform3 **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Translate3Point( 
            /* [in] */ IDAPoint3 *new_origin_0,
            /* [retval][out] */ IDATransform3 **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Scale3Anim( 
            /* [in] */ IDANumber *x_0,
            /* [in] */ IDANumber *y_1,
            /* [in] */ IDANumber *z_2,
            /* [retval][out] */ IDATransform3 **ret_3) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Scale3( 
            /* [in] */ double x_0,
            /* [in] */ double y_1,
            /* [in] */ double z_2,
            /* [retval][out] */ IDATransform3 **ret_3) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Scale3Rate( 
            /* [in] */ double x_0,
            /* [in] */ double y_1,
            /* [in] */ double z_2,
            /* [retval][out] */ IDATransform3 **ret_3) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Scale3Vector( 
            /* [in] */ IDAVector3 *scale_vec_0,
            /* [retval][out] */ IDATransform3 **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Scale3UniformAnim( 
            /* [in] */ IDANumber *uniform_scale_0,
            /* [retval][out] */ IDATransform3 **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Scale3Uniform( 
            /* [in] */ double uniform_scale_0,
            /* [retval][out] */ IDATransform3 **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Scale3UniformRate( 
            /* [in] */ double uniform_scale_0,
            /* [retval][out] */ IDATransform3 **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Rotate3Anim( 
            /* [in] */ IDAVector3 *axis_0,
            /* [in] */ IDANumber *angle_1,
            /* [retval][out] */ IDATransform3 **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Rotate3( 
            /* [in] */ IDAVector3 *axis_0,
            /* [in] */ double angle_1,
            /* [retval][out] */ IDATransform3 **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Rotate3Rate( 
            /* [in] */ IDAVector3 *axis_0,
            /* [in] */ double angle_1,
            /* [retval][out] */ IDATransform3 **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Rotate3Degrees( 
            /* [in] */ IDAVector3 *axis_0,
            /* [in] */ double angle_1,
            /* [retval][out] */ IDATransform3 **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Rotate3RateDegrees( 
            /* [in] */ IDAVector3 *axis_0,
            /* [in] */ double angle_1,
            /* [retval][out] */ IDATransform3 **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE XShear3Anim( 
            /* [in] */ IDANumber *a_0,
            /* [in] */ IDANumber *b_1,
            /* [retval][out] */ IDATransform3 **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE XShear3( 
            /* [in] */ double a_0,
            /* [in] */ double b_1,
            /* [retval][out] */ IDATransform3 **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE XShear3Rate( 
            /* [in] */ double a_0,
            /* [in] */ double b_1,
            /* [retval][out] */ IDATransform3 **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE YShear3Anim( 
            /* [in] */ IDANumber *c_0,
            /* [in] */ IDANumber *d_1,
            /* [retval][out] */ IDATransform3 **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE YShear3( 
            /* [in] */ double c_0,
            /* [in] */ double d_1,
            /* [retval][out] */ IDATransform3 **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE YShear3Rate( 
            /* [in] */ double c_0,
            /* [in] */ double d_1,
            /* [retval][out] */ IDATransform3 **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ZShear3Anim( 
            /* [in] */ IDANumber *e_0,
            /* [in] */ IDANumber *f_1,
            /* [retval][out] */ IDATransform3 **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ZShear3( 
            /* [in] */ double e_0,
            /* [in] */ double f_1,
            /* [retval][out] */ IDATransform3 **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ZShear3Rate( 
            /* [in] */ double e_0,
            /* [in] */ double f_1,
            /* [retval][out] */ IDATransform3 **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Transform4x4AnimEx( 
            /* [in] */ LONG m_0size,
            /* [size_is][in] */ IDANumber *m_0[  ],
            /* [retval][out] */ IDATransform3 **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Transform4x4Anim( 
            /* [in] */ VARIANT m_0,
            /* [retval][out] */ IDATransform3 **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Compose3( 
            /* [in] */ IDATransform3 *a_0,
            /* [in] */ IDATransform3 *b_1,
            /* [retval][out] */ IDATransform3 **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Compose3ArrayEx( 
            /* [in] */ LONG xfs_0size,
            /* [size_is][in] */ IDATransform3 *xfs_0[  ],
            /* [retval][out] */ IDATransform3 **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Compose3Array( 
            /* [in] */ VARIANT xfs_0,
            /* [retval][out] */ IDATransform3 **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LookAtFrom( 
            /* [in] */ IDAPoint3 *to_0,
            /* [in] */ IDAPoint3 *from_1,
            /* [in] */ IDAVector3 *up_2,
            /* [retval][out] */ IDATransform3 **ret_3) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_IdentityTransform2( 
            /* [retval][out] */ IDATransform2 **ret_0) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Translate2Anim( 
            /* [in] */ IDANumber *Tx_0,
            /* [in] */ IDANumber *Ty_1,
            /* [retval][out] */ IDATransform2 **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Translate2( 
            /* [in] */ double Tx_0,
            /* [in] */ double Ty_1,
            /* [retval][out] */ IDATransform2 **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Translate2Rate( 
            /* [in] */ double Tx_0,
            /* [in] */ double Ty_1,
            /* [retval][out] */ IDATransform2 **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Translate2Vector( 
            /* [in] */ IDAVector2 *delta_0,
            /* [retval][out] */ IDATransform2 **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Translate2Point( 
            /* [in] */ IDAPoint2 *pos_0,
            /* [retval][out] */ IDATransform2 **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Scale2Anim( 
            /* [in] */ IDANumber *x_0,
            /* [in] */ IDANumber *y_1,
            /* [retval][out] */ IDATransform2 **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Scale2( 
            /* [in] */ double x_0,
            /* [in] */ double y_1,
            /* [retval][out] */ IDATransform2 **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Scale2Rate( 
            /* [in] */ double x_0,
            /* [in] */ double y_1,
            /* [retval][out] */ IDATransform2 **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Scale2Vector2( 
            /* [in] */ IDAVector2 *obsoleteMethod_0,
            /* [retval][out] */ IDATransform2 **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Scale2Vector( 
            /* [in] */ IDAVector2 *scale_vec_0,
            /* [retval][out] */ IDATransform2 **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Scale2UniformAnim( 
            /* [in] */ IDANumber *uniform_scale_0,
            /* [retval][out] */ IDATransform2 **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Scale2Uniform( 
            /* [in] */ double uniform_scale_0,
            /* [retval][out] */ IDATransform2 **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Scale2UniformRate( 
            /* [in] */ double uniform_scale_0,
            /* [retval][out] */ IDATransform2 **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Rotate2Anim( 
            /* [in] */ IDANumber *angle_0,
            /* [retval][out] */ IDATransform2 **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Rotate2( 
            /* [in] */ double angle_0,
            /* [retval][out] */ IDATransform2 **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Rotate2Rate( 
            /* [in] */ double angle_0,
            /* [retval][out] */ IDATransform2 **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Rotate2Degrees( 
            /* [in] */ double angle_0,
            /* [retval][out] */ IDATransform2 **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Rotate2RateDegrees( 
            /* [in] */ double angle_0,
            /* [retval][out] */ IDATransform2 **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE XShear2Anim( 
            /* [in] */ IDANumber *arg_0,
            /* [retval][out] */ IDATransform2 **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE XShear2( 
            /* [in] */ double arg_0,
            /* [retval][out] */ IDATransform2 **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE XShear2Rate( 
            /* [in] */ double arg_0,
            /* [retval][out] */ IDATransform2 **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE YShear2Anim( 
            /* [in] */ IDANumber *arg_0,
            /* [retval][out] */ IDATransform2 **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE YShear2( 
            /* [in] */ double arg_0,
            /* [retval][out] */ IDATransform2 **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE YShear2Rate( 
            /* [in] */ double arg_0,
            /* [retval][out] */ IDATransform2 **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Transform3x2AnimEx( 
            /* [in] */ LONG m_0size,
            /* [size_is][in] */ IDANumber *m_0[  ],
            /* [retval][out] */ IDATransform2 **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Transform3x2Anim( 
            /* [in] */ VARIANT m_0,
            /* [retval][out] */ IDATransform2 **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Compose2( 
            /* [in] */ IDATransform2 *a_0,
            /* [in] */ IDATransform2 *b_1,
            /* [retval][out] */ IDATransform2 **ret_2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Compose2ArrayEx( 
            /* [in] */ LONG xfs_0size,
            /* [size_is][in] */ IDATransform2 *xfs_0[  ],
            /* [retval][out] */ IDATransform2 **ret_1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Compose2Array( 
            /* [in] */ VARIANT xfs_0,
            /* [retval][out] */ IDATransform2 **ret_1) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Tuple( 
            /* [in] */ VARIANT obsolete1,
            /* [retval][out] */ IDATuple **obsolete2) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Array( 
            /* [in] */ VARIANT obsolete1,
            /* [retval][out] */ IDAArray **obsolete2) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_AreBlockingImportsComplete( 
            /* [retval][out] */ VARIANT_BOOL *bComplete) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDAStaticsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDAStatics * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDAStatics * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDAStatics * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDAStatics * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDAStatics * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDAStatics * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDAStatics * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_VersionString )( 
            IDAStatics * This,
            /* [retval][out] */ BSTR *str);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Site )( 
            IDAStatics * This,
            /* [retval][out] */ IDASite **pSite);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Site )( 
            IDAStatics * This,
            /* [in] */ IDASite *pSite);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ClientSite )( 
            IDAStatics * This,
            /* [in] */ IOleClientSite *pClientSite);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ClientSite )( 
            IDAStatics * This,
            /* [retval][out] */ IOleClientSite **pClientSite);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_PixelConstructionMode )( 
            IDAStatics * This,
            /* [in] */ VARIANT_BOOL bMode);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_PixelConstructionMode )( 
            IDAStatics * This,
            /* [retval][out] */ VARIANT_BOOL *bMode);
        
        HRESULT ( STDMETHODCALLTYPE *TriggerEvent )( 
            IDAStatics * This,
            /* [in] */ IDAEvent *event,
            /* [in] */ IDABehavior *data);
        
        HRESULT ( STDMETHODCALLTYPE *NewDrawingSurface )( 
            IDAStatics * This,
            /* [retval][out] */ IDADrawingSurface **pds);
        
        HRESULT ( STDMETHODCALLTYPE *ImportMovie )( 
            IDAStatics * This,
            /* [in] */ BSTR url,
            /* [retval][out] */ IDAImportationResult **ppResult);
        
        HRESULT ( STDMETHODCALLTYPE *ImportMovieAsync )( 
            IDAStatics * This,
            /* [in] */ BSTR url,
            /* [in] */ IDAImage *pImageStandIn,
            /* [in] */ IDASound *pSoundStandIn,
            /* [retval][out] */ IDAImportationResult **ppResult);
        
        HRESULT ( STDMETHODCALLTYPE *ImportImage )( 
            IDAStatics * This,
            /* [in] */ BSTR url,
            /* [retval][out] */ IDAImage **ppImage);
        
        HRESULT ( STDMETHODCALLTYPE *ImportImageAsync )( 
            IDAStatics * This,
            /* [in] */ BSTR url,
            /* [in] */ IDAImage *pImageStandIn,
            /* [retval][out] */ IDAImportationResult **ppResult);
        
        HRESULT ( STDMETHODCALLTYPE *ImportImageColorKey )( 
            IDAStatics * This,
            /* [in] */ BSTR url,
            /* [in] */ BYTE colorKeyRed,
            /* [in] */ BYTE colorKeyGreen,
            /* [in] */ BYTE colorKeyBlue,
            /* [retval][out] */ IDAImage **ppImage);
        
        HRESULT ( STDMETHODCALLTYPE *ImportImageAsyncColorKey )( 
            IDAStatics * This,
            /* [in] */ BSTR url,
            /* [in] */ IDAImage *pImageStandIn,
            /* [in] */ BYTE colorKeyRed,
            /* [in] */ BYTE colorKeyGreen,
            /* [in] */ BYTE colorKeyBlue,
            /* [retval][out] */ IDAImportationResult **ppResult);
        
        HRESULT ( STDMETHODCALLTYPE *ImportSound )( 
            IDAStatics * This,
            /* [in] */ BSTR url,
            /* [retval][out] */ IDAImportationResult **ppResult);
        
        HRESULT ( STDMETHODCALLTYPE *ImportSoundAsync )( 
            IDAStatics * This,
            /* [in] */ BSTR url,
            /* [in] */ IDASound *pSoundStandIn,
            /* [retval][out] */ IDAImportationResult **ppResult);
        
        HRESULT ( STDMETHODCALLTYPE *ImportGeometry )( 
            IDAStatics * This,
            /* [in] */ BSTR url,
            /* [retval][out] */ IDAGeometry **ppGeometry);
        
        HRESULT ( STDMETHODCALLTYPE *ImportGeometryAsync )( 
            IDAStatics * This,
            /* [in] */ BSTR url,
            /* [in] */ IDAGeometry *pGeoStandIn,
            /* [retval][out] */ IDAImportationResult **ppResult);
        
        HRESULT ( STDMETHODCALLTYPE *ImportDirectDrawSurface )( 
            IDAStatics * This,
            /* [in] */ IUnknown *dds,
            /* [in] */ IDAEvent *updateEvent,
            /* [retval][out] */ IDAImage **ppImage);
        
        HRESULT ( STDMETHODCALLTYPE *Cond )( 
            IDAStatics * This,
            /* [in] */ IDABoolean *c,
            /* [in] */ IDABehavior *i,
            /* [in] */ IDABehavior *e,
            /* [retval][out] */ IDABehavior **pCondBvr);
        
        HRESULT ( STDMETHODCALLTYPE *DAArrayEx )( 
            IDAStatics * This,
            /* [in] */ LONG s,
            /* [size_is][in] */ IDABehavior *pBvrs[  ],
            /* [retval][out] */ IDAArray **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *DAArray )( 
            IDAStatics * This,
            /* [in] */ VARIANT bvrs,
            /* [retval][out] */ IDAArray **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *DATupleEx )( 
            IDAStatics * This,
            /* [in] */ LONG s,
            /* [size_is][in] */ IDABehavior *pBvrs[  ],
            /* [retval][out] */ IDATuple **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *DATuple )( 
            IDAStatics * This,
            /* [in] */ VARIANT bvrs,
            /* [retval][out] */ IDATuple **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *ModifiableBehavior )( 
            IDAStatics * This,
            /* [in] */ IDABehavior *orig,
            /* [retval][out] */ IDABehavior **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *UninitializedArray )( 
            IDAStatics * This,
            /* [in] */ IDAArray *typeTmp,
            /* [retval][out] */ IDAArray **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *UninitializedTuple )( 
            IDAStatics * This,
            /* [in] */ IDATuple *typeTmp,
            /* [retval][out] */ IDATuple **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *NumberBSplineEx )( 
            IDAStatics * This,
            /* [in] */ int degree,
            /* [in] */ LONG numKnots,
            /* [size_is][in] */ IDANumber *knots[  ],
            /* [in] */ LONG numPts,
            /* [size_is][in] */ IDANumber *ctrlPts[  ],
            /* [in] */ LONG numWts,
            /* [size_is][in] */ IDANumber *weights[  ],
            /* [in] */ IDANumber *evaluator,
            /* [retval][out] */ IDANumber **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *NumberBSpline )( 
            IDAStatics * This,
            /* [in] */ int degree,
            /* [in] */ VARIANT knots,
            /* [in] */ VARIANT CtrlPts,
            /* [in] */ VARIANT weights,
            /* [in] */ IDANumber *evaluator,
            /* [retval][out] */ IDANumber **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *Point2BSplineEx )( 
            IDAStatics * This,
            /* [in] */ int degree,
            /* [in] */ LONG numKnots,
            /* [size_is][in] */ IDANumber *knots[  ],
            /* [in] */ LONG numPts,
            /* [size_is][in] */ IDAPoint2 *ctrlPts[  ],
            /* [in] */ LONG numWts,
            /* [size_is][in] */ IDANumber *weights[  ],
            /* [in] */ IDANumber *evaluator,
            /* [retval][out] */ IDAPoint2 **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *Point2BSpline )( 
            IDAStatics * This,
            /* [in] */ int degree,
            /* [in] */ VARIANT knots,
            /* [in] */ VARIANT CtrlPts,
            /* [in] */ VARIANT weights,
            /* [in] */ IDANumber *evaluator,
            /* [retval][out] */ IDAPoint2 **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *Point3BSplineEx )( 
            IDAStatics * This,
            /* [in] */ int degree,
            /* [in] */ LONG numKnots,
            /* [size_is][in] */ IDANumber *knots[  ],
            /* [in] */ LONG numPts,
            /* [size_is][in] */ IDAPoint3 *ctrlPts[  ],
            /* [in] */ LONG numWts,
            /* [size_is][in] */ IDANumber *weights[  ],
            /* [in] */ IDANumber *evaluator,
            /* [retval][out] */ IDAPoint3 **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *Point3BSpline )( 
            IDAStatics * This,
            /* [in] */ int degree,
            /* [in] */ VARIANT knots,
            /* [in] */ VARIANT CtrlPts,
            /* [in] */ VARIANT weights,
            /* [in] */ IDANumber *evaluator,
            /* [retval][out] */ IDAPoint3 **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *Vector2BSplineEx )( 
            IDAStatics * This,
            /* [in] */ int degree,
            /* [in] */ LONG numKnots,
            /* [size_is][in] */ IDANumber *knots[  ],
            /* [in] */ LONG numPts,
            /* [size_is][in] */ IDAVector2 *ctrlPts[  ],
            /* [in] */ LONG numWts,
            /* [size_is][in] */ IDANumber *weights[  ],
            /* [in] */ IDANumber *evaluator,
            /* [retval][out] */ IDAVector2 **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *Vector2BSpline )( 
            IDAStatics * This,
            /* [in] */ int degree,
            /* [in] */ VARIANT knots,
            /* [in] */ VARIANT CtrlPts,
            /* [in] */ VARIANT weights,
            /* [in] */ IDANumber *evaluator,
            /* [retval][out] */ IDAVector2 **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *Vector3BSplineEx )( 
            IDAStatics * This,
            /* [in] */ int degree,
            /* [in] */ LONG numKnots,
            /* [size_is][in] */ IDANumber *knots[  ],
            /* [in] */ LONG numPts,
            /* [size_is][in] */ IDAVector3 *ctrlPts[  ],
            /* [in] */ LONG numWts,
            /* [size_is][in] */ IDANumber *weights[  ],
            /* [in] */ IDANumber *evaluator,
            /* [retval][out] */ IDAVector3 **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *Vector3BSpline )( 
            IDAStatics * This,
            /* [in] */ int degree,
            /* [in] */ VARIANT knots,
            /* [in] */ VARIANT CtrlPts,
            /* [in] */ VARIANT weights,
            /* [in] */ IDANumber *evaluator,
            /* [retval][out] */ IDAVector3 **bvr);
        
        HRESULT ( STDMETHODCALLTYPE *Pow )( 
            IDAStatics * This,
            /* [in] */ IDANumber *a_0,
            /* [in] */ IDANumber *b_1,
            /* [retval][out] */ IDANumber **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *Abs )( 
            IDAStatics * This,
            /* [in] */ IDANumber *a_0,
            /* [retval][out] */ IDANumber **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *Sqrt )( 
            IDAStatics * This,
            /* [in] */ IDANumber *a_0,
            /* [retval][out] */ IDANumber **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *Floor )( 
            IDAStatics * This,
            /* [in] */ IDANumber *a_0,
            /* [retval][out] */ IDANumber **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *Round )( 
            IDAStatics * This,
            /* [in] */ IDANumber *a_0,
            /* [retval][out] */ IDANumber **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *Ceiling )( 
            IDAStatics * This,
            /* [in] */ IDANumber *a_0,
            /* [retval][out] */ IDANumber **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *Asin )( 
            IDAStatics * This,
            /* [in] */ IDANumber *a_0,
            /* [retval][out] */ IDANumber **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *Acos )( 
            IDAStatics * This,
            /* [in] */ IDANumber *a_0,
            /* [retval][out] */ IDANumber **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *Atan )( 
            IDAStatics * This,
            /* [in] */ IDANumber *a_0,
            /* [retval][out] */ IDANumber **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *Sin )( 
            IDAStatics * This,
            /* [in] */ IDANumber *a_0,
            /* [retval][out] */ IDANumber **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *Cos )( 
            IDAStatics * This,
            /* [in] */ IDANumber *a_0,
            /* [retval][out] */ IDANumber **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *Tan )( 
            IDAStatics * This,
            /* [in] */ IDANumber *a_0,
            /* [retval][out] */ IDANumber **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *Exp )( 
            IDAStatics * This,
            /* [in] */ IDANumber *a_0,
            /* [retval][out] */ IDANumber **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *Ln )( 
            IDAStatics * This,
            /* [in] */ IDANumber *a_0,
            /* [retval][out] */ IDANumber **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *Log10 )( 
            IDAStatics * This,
            /* [in] */ IDANumber *a_0,
            /* [retval][out] */ IDANumber **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *ToDegrees )( 
            IDAStatics * This,
            /* [in] */ IDANumber *a_0,
            /* [retval][out] */ IDANumber **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *ToRadians )( 
            IDAStatics * This,
            /* [in] */ IDANumber *a_0,
            /* [retval][out] */ IDANumber **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *Mod )( 
            IDAStatics * This,
            /* [in] */ IDANumber *a_0,
            /* [in] */ IDANumber *b_1,
            /* [retval][out] */ IDANumber **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *Atan2 )( 
            IDAStatics * This,
            /* [in] */ IDANumber *a_0,
            /* [in] */ IDANumber *b_1,
            /* [retval][out] */ IDANumber **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *Add )( 
            IDAStatics * This,
            /* [in] */ IDANumber *a_0,
            /* [in] */ IDANumber *b_1,
            /* [retval][out] */ IDANumber **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *Sub )( 
            IDAStatics * This,
            /* [in] */ IDANumber *a_0,
            /* [in] */ IDANumber *b_1,
            /* [retval][out] */ IDANumber **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *Mul )( 
            IDAStatics * This,
            /* [in] */ IDANumber *a_0,
            /* [in] */ IDANumber *b_1,
            /* [retval][out] */ IDANumber **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *Div )( 
            IDAStatics * This,
            /* [in] */ IDANumber *a_0,
            /* [in] */ IDANumber *b_1,
            /* [retval][out] */ IDANumber **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *LT )( 
            IDAStatics * This,
            /* [in] */ IDANumber *a_0,
            /* [in] */ IDANumber *b_1,
            /* [retval][out] */ IDABoolean **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *LTE )( 
            IDAStatics * This,
            /* [in] */ IDANumber *a_0,
            /* [in] */ IDANumber *b_1,
            /* [retval][out] */ IDABoolean **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *GT )( 
            IDAStatics * This,
            /* [in] */ IDANumber *a_0,
            /* [in] */ IDANumber *b_1,
            /* [retval][out] */ IDABoolean **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *GTE )( 
            IDAStatics * This,
            /* [in] */ IDANumber *a_0,
            /* [in] */ IDANumber *b_1,
            /* [retval][out] */ IDABoolean **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *EQ )( 
            IDAStatics * This,
            /* [in] */ IDANumber *a_0,
            /* [in] */ IDANumber *b_1,
            /* [retval][out] */ IDABoolean **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *NE )( 
            IDAStatics * This,
            /* [in] */ IDANumber *a_0,
            /* [in] */ IDANumber *b_1,
            /* [retval][out] */ IDABoolean **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *Neg )( 
            IDAStatics * This,
            /* [in] */ IDANumber *a_0,
            /* [retval][out] */ IDANumber **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *InterpolateAnim )( 
            IDAStatics * This,
            /* [in] */ IDANumber *from_0,
            /* [in] */ IDANumber *to_1,
            /* [in] */ IDANumber *duration_2,
            /* [retval][out] */ IDANumber **ret_3);
        
        HRESULT ( STDMETHODCALLTYPE *Interpolate )( 
            IDAStatics * This,
            /* [in] */ double from_0,
            /* [in] */ double to_1,
            /* [in] */ double duration_2,
            /* [retval][out] */ IDANumber **ret_3);
        
        HRESULT ( STDMETHODCALLTYPE *SlowInSlowOutAnim )( 
            IDAStatics * This,
            /* [in] */ IDANumber *from_0,
            /* [in] */ IDANumber *to_1,
            /* [in] */ IDANumber *duration_2,
            /* [in] */ IDANumber *sharpness_3,
            /* [retval][out] */ IDANumber **ret_4);
        
        HRESULT ( STDMETHODCALLTYPE *SlowInSlowOut )( 
            IDAStatics * This,
            /* [in] */ double from_0,
            /* [in] */ double to_1,
            /* [in] */ double duration_2,
            /* [in] */ double sharpness_3,
            /* [retval][out] */ IDANumber **ret_4);
        
        HRESULT ( STDMETHODCALLTYPE *SoundSource )( 
            IDAStatics * This,
            /* [in] */ IDASound *snd_0,
            /* [retval][out] */ IDAGeometry **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *Mix )( 
            IDAStatics * This,
            /* [in] */ IDASound *left_0,
            /* [in] */ IDASound *right_1,
            /* [retval][out] */ IDASound **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *And )( 
            IDAStatics * This,
            /* [in] */ IDABoolean *a_0,
            /* [in] */ IDABoolean *b_1,
            /* [retval][out] */ IDABoolean **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *Or )( 
            IDAStatics * This,
            /* [in] */ IDABoolean *a_0,
            /* [in] */ IDABoolean *b_1,
            /* [retval][out] */ IDABoolean **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *Not )( 
            IDAStatics * This,
            /* [in] */ IDABoolean *a_0,
            /* [retval][out] */ IDABoolean **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *Integral )( 
            IDAStatics * This,
            /* [in] */ IDANumber *b_0,
            /* [retval][out] */ IDANumber **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *Derivative )( 
            IDAStatics * This,
            /* [in] */ IDANumber *b_0,
            /* [retval][out] */ IDANumber **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *IntegralVector2 )( 
            IDAStatics * This,
            /* [in] */ IDAVector2 *v_0,
            /* [retval][out] */ IDAVector2 **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *IntegralVector3 )( 
            IDAStatics * This,
            /* [in] */ IDAVector3 *v_0,
            /* [retval][out] */ IDAVector3 **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *DerivativeVector2 )( 
            IDAStatics * This,
            /* [in] */ IDAVector2 *v_0,
            /* [retval][out] */ IDAVector2 **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *DerivativeVector3 )( 
            IDAStatics * This,
            /* [in] */ IDAVector3 *v_0,
            /* [retval][out] */ IDAVector3 **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *DerivativePoint2 )( 
            IDAStatics * This,
            /* [in] */ IDAPoint2 *v_0,
            /* [retval][out] */ IDAVector2 **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *DerivativePoint3 )( 
            IDAStatics * This,
            /* [in] */ IDAPoint3 *v_0,
            /* [retval][out] */ IDAVector3 **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *KeyState )( 
            IDAStatics * This,
            /* [in] */ IDANumber *n_0,
            /* [retval][out] */ IDABoolean **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *KeyUp )( 
            IDAStatics * This,
            /* [in] */ LONG arg_0,
            /* [retval][out] */ IDAEvent **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *KeyDown )( 
            IDAStatics * This,
            /* [in] */ LONG arg_0,
            /* [retval][out] */ IDAEvent **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *DANumber )( 
            IDAStatics * This,
            /* [in] */ double num_0,
            /* [retval][out] */ IDANumber **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *DAString )( 
            IDAStatics * This,
            /* [in] */ BSTR str_0,
            /* [retval][out] */ IDAString **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *DABoolean )( 
            IDAStatics * This,
            /* [in] */ VARIANT_BOOL num_0,
            /* [retval][out] */ IDABoolean **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *SeededRandom )( 
            IDAStatics * This,
            /* [in] */ double arg_0,
            /* [retval][out] */ IDANumber **ret_1);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_MousePosition )( 
            IDAStatics * This,
            /* [retval][out] */ IDAPoint2 **ret_0);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_LeftButtonState )( 
            IDAStatics * This,
            /* [retval][out] */ IDABoolean **ret_0);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RightButtonState )( 
            IDAStatics * This,
            /* [retval][out] */ IDABoolean **ret_0);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_DATrue )( 
            IDAStatics * This,
            /* [retval][out] */ IDABoolean **ret_0);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_DAFalse )( 
            IDAStatics * This,
            /* [retval][out] */ IDABoolean **ret_0);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_LocalTime )( 
            IDAStatics * This,
            /* [retval][out] */ IDANumber **ret_0);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_GlobalTime )( 
            IDAStatics * This,
            /* [retval][out] */ IDANumber **ret_0);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Pixel )( 
            IDAStatics * This,
            /* [retval][out] */ IDANumber **ret_0);
        
        HRESULT ( STDMETHODCALLTYPE *UserData )( 
            IDAStatics * This,
            /* [in] */ IUnknown *data_0,
            /* [retval][out] */ IDAUserData **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *UntilNotify )( 
            IDAStatics * This,
            /* [in] */ IDABehavior *b0_0,
            /* [in] */ IDAEvent *event_1,
            /* [in] */ IDAUntilNotifier *notifier_2,
            /* [retval][out] */ IDABehavior **ret_3);
        
        HRESULT ( STDMETHODCALLTYPE *Until )( 
            IDAStatics * This,
            /* [in] */ IDABehavior *b0_0,
            /* [in] */ IDAEvent *event_1,
            /* [in] */ IDABehavior *b1_2,
            /* [retval][out] */ IDABehavior **ret_3);
        
        HRESULT ( STDMETHODCALLTYPE *UntilEx )( 
            IDAStatics * This,
            /* [in] */ IDABehavior *b0_0,
            /* [in] */ IDAEvent *event_1,
            /* [retval][out] */ IDABehavior **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *Sequence )( 
            IDAStatics * This,
            /* [in] */ IDABehavior *s1_0,
            /* [in] */ IDABehavior *s2_1,
            /* [retval][out] */ IDABehavior **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *FollowPath )( 
            IDAStatics * This,
            /* [in] */ IDAPath2 *path_0,
            /* [in] */ double duration_1,
            /* [retval][out] */ IDATransform2 **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *FollowPathAngle )( 
            IDAStatics * This,
            /* [in] */ IDAPath2 *path_0,
            /* [in] */ double duration_1,
            /* [retval][out] */ IDATransform2 **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *FollowPathAngleUpright )( 
            IDAStatics * This,
            /* [in] */ IDAPath2 *path_0,
            /* [in] */ double duration_1,
            /* [retval][out] */ IDATransform2 **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *FollowPathEval )( 
            IDAStatics * This,
            /* [in] */ IDAPath2 *path_0,
            /* [in] */ IDANumber *eval_1,
            /* [retval][out] */ IDATransform2 **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *FollowPathAngleEval )( 
            IDAStatics * This,
            /* [in] */ IDAPath2 *path_0,
            /* [in] */ IDANumber *eval_1,
            /* [retval][out] */ IDATransform2 **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *FollowPathAngleUprightEval )( 
            IDAStatics * This,
            /* [in] */ IDAPath2 *path_0,
            /* [in] */ IDANumber *eval_1,
            /* [retval][out] */ IDATransform2 **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *FollowPathAnim )( 
            IDAStatics * This,
            /* [in] */ IDAPath2 *obsoleted1_0,
            /* [in] */ IDANumber *obsoleted2_1,
            /* [retval][out] */ IDATransform2 **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *FollowPathAngleAnim )( 
            IDAStatics * This,
            /* [in] */ IDAPath2 *obsoleted1_0,
            /* [in] */ IDANumber *obsoleted2_1,
            /* [retval][out] */ IDATransform2 **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *FollowPathAngleUprightAnim )( 
            IDAStatics * This,
            /* [in] */ IDAPath2 *obsoleted1_0,
            /* [in] */ IDANumber *obsoleted2_1,
            /* [retval][out] */ IDATransform2 **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *ConcatString )( 
            IDAStatics * This,
            /* [in] */ IDAString *s1_0,
            /* [in] */ IDAString *s2_1,
            /* [retval][out] */ IDAString **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *PerspectiveCamera )( 
            IDAStatics * This,
            /* [in] */ double focalDist_0,
            /* [in] */ double nearClip_1,
            /* [retval][out] */ IDACamera **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *PerspectiveCameraAnim )( 
            IDAStatics * This,
            /* [in] */ IDANumber *focalDist_0,
            /* [in] */ IDANumber *nearClip_1,
            /* [retval][out] */ IDACamera **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *ParallelCamera )( 
            IDAStatics * This,
            /* [in] */ double nearClip_0,
            /* [retval][out] */ IDACamera **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *ParallelCameraAnim )( 
            IDAStatics * This,
            /* [in] */ IDANumber *nearClip_0,
            /* [retval][out] */ IDACamera **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *ColorRgbAnim )( 
            IDAStatics * This,
            /* [in] */ IDANumber *red_0,
            /* [in] */ IDANumber *green_1,
            /* [in] */ IDANumber *blue_2,
            /* [retval][out] */ IDAColor **ret_3);
        
        HRESULT ( STDMETHODCALLTYPE *ColorRgb )( 
            IDAStatics * This,
            /* [in] */ double red_0,
            /* [in] */ double green_1,
            /* [in] */ double blue_2,
            /* [retval][out] */ IDAColor **ret_3);
        
        HRESULT ( STDMETHODCALLTYPE *ColorRgb255 )( 
            IDAStatics * This,
            /* [in] */ short red_0,
            /* [in] */ short green_1,
            /* [in] */ short blue_2,
            /* [retval][out] */ IDAColor **ret_3);
        
        HRESULT ( STDMETHODCALLTYPE *ColorHsl )( 
            IDAStatics * This,
            /* [in] */ double hue_0,
            /* [in] */ double saturation_1,
            /* [in] */ double lum_2,
            /* [retval][out] */ IDAColor **ret_3);
        
        HRESULT ( STDMETHODCALLTYPE *ColorHslAnim )( 
            IDAStatics * This,
            /* [in] */ IDANumber *hue_0,
            /* [in] */ IDANumber *saturation_1,
            /* [in] */ IDANumber *lum_2,
            /* [retval][out] */ IDAColor **ret_3);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Red )( 
            IDAStatics * This,
            /* [retval][out] */ IDAColor **ret_0);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Green )( 
            IDAStatics * This,
            /* [retval][out] */ IDAColor **ret_0);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Blue )( 
            IDAStatics * This,
            /* [retval][out] */ IDAColor **ret_0);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Cyan )( 
            IDAStatics * This,
            /* [retval][out] */ IDAColor **ret_0);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Magenta )( 
            IDAStatics * This,
            /* [retval][out] */ IDAColor **ret_0);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Yellow )( 
            IDAStatics * This,
            /* [retval][out] */ IDAColor **ret_0);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Black )( 
            IDAStatics * This,
            /* [retval][out] */ IDAColor **ret_0);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_White )( 
            IDAStatics * This,
            /* [retval][out] */ IDAColor **ret_0);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Aqua )( 
            IDAStatics * This,
            /* [retval][out] */ IDAColor **ret_0);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Fuchsia )( 
            IDAStatics * This,
            /* [retval][out] */ IDAColor **ret_0);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Gray )( 
            IDAStatics * This,
            /* [retval][out] */ IDAColor **ret_0);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Lime )( 
            IDAStatics * This,
            /* [retval][out] */ IDAColor **ret_0);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Maroon )( 
            IDAStatics * This,
            /* [retval][out] */ IDAColor **ret_0);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Navy )( 
            IDAStatics * This,
            /* [retval][out] */ IDAColor **ret_0);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Olive )( 
            IDAStatics * This,
            /* [retval][out] */ IDAColor **ret_0);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Purple )( 
            IDAStatics * This,
            /* [retval][out] */ IDAColor **ret_0);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Silver )( 
            IDAStatics * This,
            /* [retval][out] */ IDAColor **ret_0);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Teal )( 
            IDAStatics * This,
            /* [retval][out] */ IDAColor **ret_0);
        
        HRESULT ( STDMETHODCALLTYPE *Predicate )( 
            IDAStatics * This,
            /* [in] */ IDABoolean *b_0,
            /* [retval][out] */ IDAEvent **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *NotEvent )( 
            IDAStatics * This,
            /* [in] */ IDAEvent *event_0,
            /* [retval][out] */ IDAEvent **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *AndEvent )( 
            IDAStatics * This,
            /* [in] */ IDAEvent *e1_0,
            /* [in] */ IDAEvent *e2_1,
            /* [retval][out] */ IDAEvent **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *OrEvent )( 
            IDAStatics * This,
            /* [in] */ IDAEvent *e1_0,
            /* [in] */ IDAEvent *e2_1,
            /* [retval][out] */ IDAEvent **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *ThenEvent )( 
            IDAStatics * This,
            /* [in] */ IDAEvent *e1_0,
            /* [in] */ IDAEvent *e2_1,
            /* [retval][out] */ IDAEvent **ret_2);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_LeftButtonDown )( 
            IDAStatics * This,
            /* [retval][out] */ IDAEvent **ret_0);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_LeftButtonUp )( 
            IDAStatics * This,
            /* [retval][out] */ IDAEvent **ret_0);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RightButtonDown )( 
            IDAStatics * This,
            /* [retval][out] */ IDAEvent **ret_0);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RightButtonUp )( 
            IDAStatics * This,
            /* [retval][out] */ IDAEvent **ret_0);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Always )( 
            IDAStatics * This,
            /* [retval][out] */ IDAEvent **ret_0);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Never )( 
            IDAStatics * This,
            /* [retval][out] */ IDAEvent **ret_0);
        
        HRESULT ( STDMETHODCALLTYPE *TimerAnim )( 
            IDAStatics * This,
            /* [in] */ IDANumber *n_0,
            /* [retval][out] */ IDAEvent **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *Timer )( 
            IDAStatics * This,
            /* [in] */ double n_0,
            /* [retval][out] */ IDAEvent **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *AppTriggeredEvent )( 
            IDAStatics * This,
            /* [retval][out] */ IDAEvent **ret_0);
        
        HRESULT ( STDMETHODCALLTYPE *ScriptCallback )( 
            IDAStatics * This,
            /* [in] */ BSTR obsolete1_0,
            /* [in] */ IDAEvent *obsolete2_1,
            /* [in] */ BSTR obsolete3_2,
            /* [retval][out] */ IDAEvent **ret_3);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_EmptyGeometry )( 
            IDAStatics * This,
            /* [retval][out] */ IDAGeometry **ret_0);
        
        HRESULT ( STDMETHODCALLTYPE *UnionGeometry )( 
            IDAStatics * This,
            /* [in] */ IDAGeometry *g1_0,
            /* [in] */ IDAGeometry *g2_1,
            /* [retval][out] */ IDAGeometry **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *UnionGeometryArrayEx )( 
            IDAStatics * This,
            /* [in] */ LONG imgs_0size,
            /* [size_is][in] */ IDAGeometry *imgs_0[  ],
            /* [retval][out] */ IDAGeometry **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *UnionGeometryArray )( 
            IDAStatics * This,
            /* [in] */ VARIANT imgs_0,
            /* [retval][out] */ IDAGeometry **ret_1);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_EmptyImage )( 
            IDAStatics * This,
            /* [retval][out] */ IDAImage **ret_0);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_DetectableEmptyImage )( 
            IDAStatics * This,
            /* [retval][out] */ IDAImage **ret_0);
        
        HRESULT ( STDMETHODCALLTYPE *SolidColorImage )( 
            IDAStatics * This,
            /* [in] */ IDAColor *col_0,
            /* [retval][out] */ IDAImage **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *GradientPolygonEx )( 
            IDAStatics * This,
            /* [in] */ LONG points_0size,
            /* [size_is][in] */ IDAPoint2 *points_0[  ],
            /* [in] */ LONG colors_1size,
            /* [size_is][in] */ IDAColor *colors_1[  ],
            /* [retval][out] */ IDAImage **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *GradientPolygon )( 
            IDAStatics * This,
            /* [in] */ VARIANT points_0,
            /* [in] */ VARIANT colors_1,
            /* [retval][out] */ IDAImage **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *RadialGradientPolygonEx )( 
            IDAStatics * This,
            /* [in] */ IDAColor *inner_0,
            /* [in] */ IDAColor *outer_1,
            /* [in] */ LONG points_2size,
            /* [size_is][in] */ IDAPoint2 *points_2[  ],
            /* [in] */ double fallOff_3,
            /* [retval][out] */ IDAImage **ret_4);
        
        HRESULT ( STDMETHODCALLTYPE *RadialGradientPolygon )( 
            IDAStatics * This,
            /* [in] */ IDAColor *inner_0,
            /* [in] */ IDAColor *outer_1,
            /* [in] */ VARIANT points_2,
            /* [in] */ double fallOff_3,
            /* [retval][out] */ IDAImage **ret_4);
        
        HRESULT ( STDMETHODCALLTYPE *RadialGradientPolygonAnimEx )( 
            IDAStatics * This,
            /* [in] */ IDAColor *inner_0,
            /* [in] */ IDAColor *outer_1,
            /* [in] */ LONG points_2size,
            /* [size_is][in] */ IDAPoint2 *points_2[  ],
            /* [in] */ IDANumber *fallOff_3,
            /* [retval][out] */ IDAImage **ret_4);
        
        HRESULT ( STDMETHODCALLTYPE *RadialGradientPolygonAnim )( 
            IDAStatics * This,
            /* [in] */ IDAColor *inner_0,
            /* [in] */ IDAColor *outer_1,
            /* [in] */ VARIANT points_2,
            /* [in] */ IDANumber *fallOff_3,
            /* [retval][out] */ IDAImage **ret_4);
        
        HRESULT ( STDMETHODCALLTYPE *GradientSquare )( 
            IDAStatics * This,
            /* [in] */ IDAColor *lowerLeft_0,
            /* [in] */ IDAColor *upperLeft_1,
            /* [in] */ IDAColor *upperRight_2,
            /* [in] */ IDAColor *lowerRight_3,
            /* [retval][out] */ IDAImage **ret_4);
        
        HRESULT ( STDMETHODCALLTYPE *RadialGradientSquare )( 
            IDAStatics * This,
            /* [in] */ IDAColor *inner_0,
            /* [in] */ IDAColor *outer_1,
            /* [in] */ double fallOff_2,
            /* [retval][out] */ IDAImage **ret_3);
        
        HRESULT ( STDMETHODCALLTYPE *RadialGradientSquareAnim )( 
            IDAStatics * This,
            /* [in] */ IDAColor *inner_0,
            /* [in] */ IDAColor *outer_1,
            /* [in] */ IDANumber *fallOff_2,
            /* [retval][out] */ IDAImage **ret_3);
        
        HRESULT ( STDMETHODCALLTYPE *RadialGradientRegularPoly )( 
            IDAStatics * This,
            /* [in] */ IDAColor *inner_0,
            /* [in] */ IDAColor *outer_1,
            /* [in] */ double numEdges_2,
            /* [in] */ double fallOff_3,
            /* [retval][out] */ IDAImage **ret_4);
        
        HRESULT ( STDMETHODCALLTYPE *RadialGradientRegularPolyAnim )( 
            IDAStatics * This,
            /* [in] */ IDAColor *inner_0,
            /* [in] */ IDAColor *outer_1,
            /* [in] */ IDANumber *numEdges_2,
            /* [in] */ IDANumber *fallOff_3,
            /* [retval][out] */ IDAImage **ret_4);
        
        HRESULT ( STDMETHODCALLTYPE *GradientHorizontal )( 
            IDAStatics * This,
            /* [in] */ IDAColor *start_0,
            /* [in] */ IDAColor *stop_1,
            /* [in] */ double fallOff_2,
            /* [retval][out] */ IDAImage **ret_3);
        
        HRESULT ( STDMETHODCALLTYPE *GradientHorizontalAnim )( 
            IDAStatics * This,
            /* [in] */ IDAColor *start_0,
            /* [in] */ IDAColor *stop_1,
            /* [in] */ IDANumber *fallOff_2,
            /* [retval][out] */ IDAImage **ret_3);
        
        HRESULT ( STDMETHODCALLTYPE *HatchHorizontal )( 
            IDAStatics * This,
            /* [in] */ IDAColor *lineClr_0,
            /* [in] */ double spacing_1,
            /* [retval][out] */ IDAImage **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *HatchHorizontalAnim )( 
            IDAStatics * This,
            /* [in] */ IDAColor *lineClr_0,
            /* [in] */ IDANumber *spacing_1,
            /* [retval][out] */ IDAImage **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *HatchVertical )( 
            IDAStatics * This,
            /* [in] */ IDAColor *lineClr_0,
            /* [in] */ double spacing_1,
            /* [retval][out] */ IDAImage **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *HatchVerticalAnim )( 
            IDAStatics * This,
            /* [in] */ IDAColor *lineClr_0,
            /* [in] */ IDANumber *spacing_1,
            /* [retval][out] */ IDAImage **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *HatchForwardDiagonal )( 
            IDAStatics * This,
            /* [in] */ IDAColor *lineClr_0,
            /* [in] */ double spacing_1,
            /* [retval][out] */ IDAImage **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *HatchForwardDiagonalAnim )( 
            IDAStatics * This,
            /* [in] */ IDAColor *lineClr_0,
            /* [in] */ IDANumber *spacing_1,
            /* [retval][out] */ IDAImage **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *HatchBackwardDiagonal )( 
            IDAStatics * This,
            /* [in] */ IDAColor *lineClr_0,
            /* [in] */ double spacing_1,
            /* [retval][out] */ IDAImage **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *HatchBackwardDiagonalAnim )( 
            IDAStatics * This,
            /* [in] */ IDAColor *lineClr_0,
            /* [in] */ IDANumber *spacing_1,
            /* [retval][out] */ IDAImage **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *HatchCross )( 
            IDAStatics * This,
            /* [in] */ IDAColor *lineClr_0,
            /* [in] */ double spacing_1,
            /* [retval][out] */ IDAImage **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *HatchCrossAnim )( 
            IDAStatics * This,
            /* [in] */ IDAColor *lineClr_0,
            /* [in] */ IDANumber *spacing_1,
            /* [retval][out] */ IDAImage **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *HatchDiagonalCross )( 
            IDAStatics * This,
            /* [in] */ IDAColor *lineClr_0,
            /* [in] */ double spacing_1,
            /* [retval][out] */ IDAImage **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *HatchDiagonalCrossAnim )( 
            IDAStatics * This,
            /* [in] */ IDAColor *lineClr_0,
            /* [in] */ IDANumber *spacing_1,
            /* [retval][out] */ IDAImage **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *Overlay )( 
            IDAStatics * This,
            /* [in] */ IDAImage *top_0,
            /* [in] */ IDAImage *bottom_1,
            /* [retval][out] */ IDAImage **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *OverlayArrayEx )( 
            IDAStatics * This,
            /* [in] */ LONG imgs_0size,
            /* [size_is][in] */ IDAImage *imgs_0[  ],
            /* [retval][out] */ IDAImage **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *OverlayArray )( 
            IDAStatics * This,
            /* [in] */ VARIANT imgs_0,
            /* [retval][out] */ IDAImage **ret_1);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_AmbientLight )( 
            IDAStatics * This,
            /* [retval][out] */ IDAGeometry **ret_0);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_DirectionalLight )( 
            IDAStatics * This,
            /* [retval][out] */ IDAGeometry **ret_0);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_PointLight )( 
            IDAStatics * This,
            /* [retval][out] */ IDAGeometry **ret_0);
        
        HRESULT ( STDMETHODCALLTYPE *SpotLightAnim )( 
            IDAStatics * This,
            /* [in] */ IDANumber *fullcone_0,
            /* [in] */ IDANumber *cutoff_1,
            /* [retval][out] */ IDAGeometry **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *SpotLight )( 
            IDAStatics * This,
            /* [in] */ IDANumber *fullcone_0,
            /* [in] */ double cutoff_1,
            /* [retval][out] */ IDAGeometry **ret_2);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_DefaultLineStyle )( 
            IDAStatics * This,
            /* [retval][out] */ IDALineStyle **ret_0);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_EmptyLineStyle )( 
            IDAStatics * This,
            /* [retval][out] */ IDALineStyle **ret_0);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_JoinStyleBevel )( 
            IDAStatics * This,
            /* [retval][out] */ IDAJoinStyle **ret_0);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_JoinStyleRound )( 
            IDAStatics * This,
            /* [retval][out] */ IDAJoinStyle **ret_0);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_JoinStyleMiter )( 
            IDAStatics * This,
            /* [retval][out] */ IDAJoinStyle **ret_0);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_EndStyleFlat )( 
            IDAStatics * This,
            /* [retval][out] */ IDAEndStyle **ret_0);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_EndStyleSquare )( 
            IDAStatics * This,
            /* [retval][out] */ IDAEndStyle **ret_0);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_EndStyleRound )( 
            IDAStatics * This,
            /* [retval][out] */ IDAEndStyle **ret_0);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_DashStyleSolid )( 
            IDAStatics * This,
            /* [retval][out] */ IDADashStyle **ret_0);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_DashStyleDashed )( 
            IDAStatics * This,
            /* [retval][out] */ IDADashStyle **ret_0);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_DefaultMicrophone )( 
            IDAStatics * This,
            /* [retval][out] */ IDAMicrophone **ret_0);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_OpaqueMatte )( 
            IDAStatics * This,
            /* [retval][out] */ IDAMatte **ret_0);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ClearMatte )( 
            IDAStatics * This,
            /* [retval][out] */ IDAMatte **ret_0);
        
        HRESULT ( STDMETHODCALLTYPE *UnionMatte )( 
            IDAStatics * This,
            /* [in] */ IDAMatte *m1_0,
            /* [in] */ IDAMatte *m2_1,
            /* [retval][out] */ IDAMatte **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *IntersectMatte )( 
            IDAStatics * This,
            /* [in] */ IDAMatte *m1_0,
            /* [in] */ IDAMatte *m2_1,
            /* [retval][out] */ IDAMatte **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *DifferenceMatte )( 
            IDAStatics * This,
            /* [in] */ IDAMatte *m1_0,
            /* [in] */ IDAMatte *m2_1,
            /* [retval][out] */ IDAMatte **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *FillMatte )( 
            IDAStatics * This,
            /* [in] */ IDAPath2 *p_0,
            /* [retval][out] */ IDAMatte **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *TextMatte )( 
            IDAStatics * This,
            /* [in] */ IDAString *str_0,
            /* [in] */ IDAFontStyle *fs_1,
            /* [retval][out] */ IDAMatte **ret_2);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_EmptyMontage )( 
            IDAStatics * This,
            /* [retval][out] */ IDAMontage **ret_0);
        
        HRESULT ( STDMETHODCALLTYPE *ImageMontage )( 
            IDAStatics * This,
            /* [in] */ IDAImage *im_0,
            /* [in] */ double depth_1,
            /* [retval][out] */ IDAMontage **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *ImageMontageAnim )( 
            IDAStatics * This,
            /* [in] */ IDAImage *im_0,
            /* [in] */ IDANumber *depth_1,
            /* [retval][out] */ IDAMontage **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *UnionMontage )( 
            IDAStatics * This,
            /* [in] */ IDAMontage *m1_0,
            /* [in] */ IDAMontage *m2_1,
            /* [retval][out] */ IDAMontage **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *Concat )( 
            IDAStatics * This,
            /* [in] */ IDAPath2 *p1_0,
            /* [in] */ IDAPath2 *p2_1,
            /* [retval][out] */ IDAPath2 **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *ConcatArrayEx )( 
            IDAStatics * This,
            /* [in] */ LONG paths_0size,
            /* [size_is][in] */ IDAPath2 *paths_0[  ],
            /* [retval][out] */ IDAPath2 **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *ConcatArray )( 
            IDAStatics * This,
            /* [in] */ VARIANT paths_0,
            /* [retval][out] */ IDAPath2 **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *Line )( 
            IDAStatics * This,
            /* [in] */ IDAPoint2 *p1_0,
            /* [in] */ IDAPoint2 *p2_1,
            /* [retval][out] */ IDAPath2 **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *Ray )( 
            IDAStatics * This,
            /* [in] */ IDAPoint2 *pt_0,
            /* [retval][out] */ IDAPath2 **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *StringPathAnim )( 
            IDAStatics * This,
            /* [in] */ IDAString *str_0,
            /* [in] */ IDAFontStyle *fs_1,
            /* [retval][out] */ IDAPath2 **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *StringPath )( 
            IDAStatics * This,
            /* [in] */ BSTR str_0,
            /* [in] */ IDAFontStyle *fs_1,
            /* [retval][out] */ IDAPath2 **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *PolylineEx )( 
            IDAStatics * This,
            /* [in] */ LONG points_0size,
            /* [size_is][in] */ IDAPoint2 *points_0[  ],
            /* [retval][out] */ IDAPath2 **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *Polyline )( 
            IDAStatics * This,
            /* [in] */ VARIANT points_0,
            /* [retval][out] */ IDAPath2 **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *PolydrawPathEx )( 
            IDAStatics * This,
            /* [in] */ LONG points_0size,
            /* [size_is][in] */ IDAPoint2 *points_0[  ],
            /* [in] */ LONG codes_1size,
            /* [size_is][in] */ IDANumber *codes_1[  ],
            /* [retval][out] */ IDAPath2 **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *PolydrawPath )( 
            IDAStatics * This,
            /* [in] */ VARIANT points_0,
            /* [in] */ VARIANT codes_1,
            /* [retval][out] */ IDAPath2 **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *ArcRadians )( 
            IDAStatics * This,
            /* [in] */ double startAngle_0,
            /* [in] */ double endAngle_1,
            /* [in] */ double arcWidth_2,
            /* [in] */ double arcHeight_3,
            /* [retval][out] */ IDAPath2 **ret_4);
        
        HRESULT ( STDMETHODCALLTYPE *ArcRadiansAnim )( 
            IDAStatics * This,
            /* [in] */ IDANumber *startAngle_0,
            /* [in] */ IDANumber *endAngle_1,
            /* [in] */ IDANumber *arcWidth_2,
            /* [in] */ IDANumber *arcHeight_3,
            /* [retval][out] */ IDAPath2 **ret_4);
        
        HRESULT ( STDMETHODCALLTYPE *ArcDegrees )( 
            IDAStatics * This,
            /* [in] */ double startAngle_0,
            /* [in] */ double endAngle_1,
            /* [in] */ double arcWidth_2,
            /* [in] */ double arcHeight_3,
            /* [retval][out] */ IDAPath2 **ret_4);
        
        HRESULT ( STDMETHODCALLTYPE *PieRadians )( 
            IDAStatics * This,
            /* [in] */ double startAngle_0,
            /* [in] */ double endAngle_1,
            /* [in] */ double arcWidth_2,
            /* [in] */ double arcHeight_3,
            /* [retval][out] */ IDAPath2 **ret_4);
        
        HRESULT ( STDMETHODCALLTYPE *PieRadiansAnim )( 
            IDAStatics * This,
            /* [in] */ IDANumber *startAngle_0,
            /* [in] */ IDANumber *endAngle_1,
            /* [in] */ IDANumber *arcWidth_2,
            /* [in] */ IDANumber *arcHeight_3,
            /* [retval][out] */ IDAPath2 **ret_4);
        
        HRESULT ( STDMETHODCALLTYPE *PieDegrees )( 
            IDAStatics * This,
            /* [in] */ double startAngle_0,
            /* [in] */ double endAngle_1,
            /* [in] */ double arcWidth_2,
            /* [in] */ double arcHeight_3,
            /* [retval][out] */ IDAPath2 **ret_4);
        
        HRESULT ( STDMETHODCALLTYPE *Oval )( 
            IDAStatics * This,
            /* [in] */ double width_0,
            /* [in] */ double height_1,
            /* [retval][out] */ IDAPath2 **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *OvalAnim )( 
            IDAStatics * This,
            /* [in] */ IDANumber *width_0,
            /* [in] */ IDANumber *height_1,
            /* [retval][out] */ IDAPath2 **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *Rect )( 
            IDAStatics * This,
            /* [in] */ double width_0,
            /* [in] */ double height_1,
            /* [retval][out] */ IDAPath2 **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *RectAnim )( 
            IDAStatics * This,
            /* [in] */ IDANumber *width_0,
            /* [in] */ IDANumber *height_1,
            /* [retval][out] */ IDAPath2 **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *RoundRect )( 
            IDAStatics * This,
            /* [in] */ double width_0,
            /* [in] */ double height_1,
            /* [in] */ double cornerArcWidth_2,
            /* [in] */ double cornerArcHeight_3,
            /* [retval][out] */ IDAPath2 **ret_4);
        
        HRESULT ( STDMETHODCALLTYPE *RoundRectAnim )( 
            IDAStatics * This,
            /* [in] */ IDANumber *width_0,
            /* [in] */ IDANumber *height_1,
            /* [in] */ IDANumber *cornerArcWidth_2,
            /* [in] */ IDANumber *cornerArcHeight_3,
            /* [retval][out] */ IDAPath2 **ret_4);
        
        HRESULT ( STDMETHODCALLTYPE *CubicBSplinePathEx )( 
            IDAStatics * This,
            /* [in] */ LONG points_0size,
            /* [size_is][in] */ IDAPoint2 *points_0[  ],
            /* [in] */ LONG knots_1size,
            /* [size_is][in] */ IDANumber *knots_1[  ],
            /* [retval][out] */ IDAPath2 **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *CubicBSplinePath )( 
            IDAStatics * This,
            /* [in] */ VARIANT points_0,
            /* [in] */ VARIANT knots_1,
            /* [retval][out] */ IDAPath2 **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *TextPath )( 
            IDAStatics * This,
            /* [in] */ IDAString *obsolete1_0,
            /* [in] */ IDAFontStyle *obsolete2_1,
            /* [retval][out] */ IDAPath2 **ret_2);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Silence )( 
            IDAStatics * This,
            /* [retval][out] */ IDASound **ret_0);
        
        HRESULT ( STDMETHODCALLTYPE *MixArrayEx )( 
            IDAStatics * This,
            /* [in] */ LONG snds_0size,
            /* [size_is][in] */ IDASound *snds_0[  ],
            /* [retval][out] */ IDASound **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *MixArray )( 
            IDAStatics * This,
            /* [in] */ VARIANT snds_0,
            /* [retval][out] */ IDASound **ret_1);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SinSynth )( 
            IDAStatics * This,
            /* [retval][out] */ IDASound **ret_0);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_DefaultFont )( 
            IDAStatics * This,
            /* [retval][out] */ IDAFontStyle **ret_0);
        
        HRESULT ( STDMETHODCALLTYPE *FontAnim )( 
            IDAStatics * This,
            /* [in] */ IDAString *str_0,
            /* [in] */ IDANumber *size_1,
            /* [in] */ IDAColor *col_2,
            /* [retval][out] */ IDAFontStyle **ret_3);
        
        HRESULT ( STDMETHODCALLTYPE *Font )( 
            IDAStatics * This,
            /* [in] */ BSTR str_0,
            /* [in] */ double size_1,
            /* [in] */ IDAColor *col_2,
            /* [retval][out] */ IDAFontStyle **ret_3);
        
        HRESULT ( STDMETHODCALLTYPE *StringImageAnim )( 
            IDAStatics * This,
            /* [in] */ IDAString *str_0,
            /* [in] */ IDAFontStyle *fs_1,
            /* [retval][out] */ IDAImage **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *StringImage )( 
            IDAStatics * This,
            /* [in] */ BSTR str_0,
            /* [in] */ IDAFontStyle *fs_1,
            /* [retval][out] */ IDAImage **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *TextImageAnim )( 
            IDAStatics * This,
            /* [in] */ IDAString *obsoleted1_0,
            /* [in] */ IDAFontStyle *obsoleted2_1,
            /* [retval][out] */ IDAImage **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *TextImage )( 
            IDAStatics * This,
            /* [in] */ BSTR obsoleted1_0,
            /* [in] */ IDAFontStyle *obsoleted2_1,
            /* [retval][out] */ IDAImage **ret_2);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_XVector2 )( 
            IDAStatics * This,
            /* [retval][out] */ IDAVector2 **ret_0);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_YVector2 )( 
            IDAStatics * This,
            /* [retval][out] */ IDAVector2 **ret_0);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ZeroVector2 )( 
            IDAStatics * This,
            /* [retval][out] */ IDAVector2 **ret_0);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Origin2 )( 
            IDAStatics * This,
            /* [retval][out] */ IDAPoint2 **ret_0);
        
        HRESULT ( STDMETHODCALLTYPE *Vector2Anim )( 
            IDAStatics * This,
            /* [in] */ IDANumber *x_0,
            /* [in] */ IDANumber *y_1,
            /* [retval][out] */ IDAVector2 **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *Vector2 )( 
            IDAStatics * This,
            /* [in] */ double x_0,
            /* [in] */ double y_1,
            /* [retval][out] */ IDAVector2 **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *Point2Anim )( 
            IDAStatics * This,
            /* [in] */ IDANumber *x_0,
            /* [in] */ IDANumber *y_1,
            /* [retval][out] */ IDAPoint2 **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *Point2 )( 
            IDAStatics * This,
            /* [in] */ double x_0,
            /* [in] */ double y_1,
            /* [retval][out] */ IDAPoint2 **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *Vector2PolarAnim )( 
            IDAStatics * This,
            /* [in] */ IDANumber *theta_0,
            /* [in] */ IDANumber *radius_1,
            /* [retval][out] */ IDAVector2 **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *Vector2Polar )( 
            IDAStatics * This,
            /* [in] */ double theta_0,
            /* [in] */ double radius_1,
            /* [retval][out] */ IDAVector2 **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *Vector2PolarDegrees )( 
            IDAStatics * This,
            /* [in] */ double theta_0,
            /* [in] */ double radius_1,
            /* [retval][out] */ IDAVector2 **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *Point2PolarAnim )( 
            IDAStatics * This,
            /* [in] */ IDANumber *theta_0,
            /* [in] */ IDANumber *radius_1,
            /* [retval][out] */ IDAPoint2 **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *Point2Polar )( 
            IDAStatics * This,
            /* [in] */ double theta_0,
            /* [in] */ double radius_1,
            /* [retval][out] */ IDAPoint2 **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *DotVector2 )( 
            IDAStatics * This,
            /* [in] */ IDAVector2 *v_0,
            /* [in] */ IDAVector2 *u_1,
            /* [retval][out] */ IDANumber **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *NegVector2 )( 
            IDAStatics * This,
            /* [in] */ IDAVector2 *v_0,
            /* [retval][out] */ IDAVector2 **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *SubVector2 )( 
            IDAStatics * This,
            /* [in] */ IDAVector2 *v1_0,
            /* [in] */ IDAVector2 *v2_1,
            /* [retval][out] */ IDAVector2 **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *AddVector2 )( 
            IDAStatics * This,
            /* [in] */ IDAVector2 *v1_0,
            /* [in] */ IDAVector2 *v2_1,
            /* [retval][out] */ IDAVector2 **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *AddPoint2Vector )( 
            IDAStatics * This,
            /* [in] */ IDAPoint2 *p_0,
            /* [in] */ IDAVector2 *v_1,
            /* [retval][out] */ IDAPoint2 **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *SubPoint2Vector )( 
            IDAStatics * This,
            /* [in] */ IDAPoint2 *p_0,
            /* [in] */ IDAVector2 *v_1,
            /* [retval][out] */ IDAPoint2 **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *SubPoint2 )( 
            IDAStatics * This,
            /* [in] */ IDAPoint2 *p1_0,
            /* [in] */ IDAPoint2 *p2_1,
            /* [retval][out] */ IDAVector2 **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *DistancePoint2 )( 
            IDAStatics * This,
            /* [in] */ IDAPoint2 *p_0,
            /* [in] */ IDAPoint2 *q_1,
            /* [retval][out] */ IDANumber **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *DistanceSquaredPoint2 )( 
            IDAStatics * This,
            /* [in] */ IDAPoint2 *p_0,
            /* [in] */ IDAPoint2 *q_1,
            /* [retval][out] */ IDANumber **ret_2);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_XVector3 )( 
            IDAStatics * This,
            /* [retval][out] */ IDAVector3 **ret_0);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_YVector3 )( 
            IDAStatics * This,
            /* [retval][out] */ IDAVector3 **ret_0);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ZVector3 )( 
            IDAStatics * This,
            /* [retval][out] */ IDAVector3 **ret_0);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ZeroVector3 )( 
            IDAStatics * This,
            /* [retval][out] */ IDAVector3 **ret_0);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Origin3 )( 
            IDAStatics * This,
            /* [retval][out] */ IDAPoint3 **ret_0);
        
        HRESULT ( STDMETHODCALLTYPE *Vector3Anim )( 
            IDAStatics * This,
            /* [in] */ IDANumber *x_0,
            /* [in] */ IDANumber *y_1,
            /* [in] */ IDANumber *z_2,
            /* [retval][out] */ IDAVector3 **ret_3);
        
        HRESULT ( STDMETHODCALLTYPE *Vector3 )( 
            IDAStatics * This,
            /* [in] */ double x_0,
            /* [in] */ double y_1,
            /* [in] */ double z_2,
            /* [retval][out] */ IDAVector3 **ret_3);
        
        HRESULT ( STDMETHODCALLTYPE *Point3Anim )( 
            IDAStatics * This,
            /* [in] */ IDANumber *x_0,
            /* [in] */ IDANumber *y_1,
            /* [in] */ IDANumber *z_2,
            /* [retval][out] */ IDAPoint3 **ret_3);
        
        HRESULT ( STDMETHODCALLTYPE *Point3 )( 
            IDAStatics * This,
            /* [in] */ double x_0,
            /* [in] */ double y_1,
            /* [in] */ double z_2,
            /* [retval][out] */ IDAPoint3 **ret_3);
        
        HRESULT ( STDMETHODCALLTYPE *Vector3SphericalAnim )( 
            IDAStatics * This,
            /* [in] */ IDANumber *xyAngle_0,
            /* [in] */ IDANumber *yzAngle_1,
            /* [in] */ IDANumber *radius_2,
            /* [retval][out] */ IDAVector3 **ret_3);
        
        HRESULT ( STDMETHODCALLTYPE *Vector3Spherical )( 
            IDAStatics * This,
            /* [in] */ double xyAngle_0,
            /* [in] */ double yzAngle_1,
            /* [in] */ double radius_2,
            /* [retval][out] */ IDAVector3 **ret_3);
        
        HRESULT ( STDMETHODCALLTYPE *Point3SphericalAnim )( 
            IDAStatics * This,
            /* [in] */ IDANumber *zxAngle_0,
            /* [in] */ IDANumber *xyAngle_1,
            /* [in] */ IDANumber *radius_2,
            /* [retval][out] */ IDAPoint3 **ret_3);
        
        HRESULT ( STDMETHODCALLTYPE *Point3Spherical )( 
            IDAStatics * This,
            /* [in] */ double zxAngle_0,
            /* [in] */ double xyAngle_1,
            /* [in] */ double radius_2,
            /* [retval][out] */ IDAPoint3 **ret_3);
        
        HRESULT ( STDMETHODCALLTYPE *DotVector3 )( 
            IDAStatics * This,
            /* [in] */ IDAVector3 *v_0,
            /* [in] */ IDAVector3 *u_1,
            /* [retval][out] */ IDANumber **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *CrossVector3 )( 
            IDAStatics * This,
            /* [in] */ IDAVector3 *v_0,
            /* [in] */ IDAVector3 *u_1,
            /* [retval][out] */ IDAVector3 **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *NegVector3 )( 
            IDAStatics * This,
            /* [in] */ IDAVector3 *v_0,
            /* [retval][out] */ IDAVector3 **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *SubVector3 )( 
            IDAStatics * This,
            /* [in] */ IDAVector3 *v1_0,
            /* [in] */ IDAVector3 *v2_1,
            /* [retval][out] */ IDAVector3 **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *AddVector3 )( 
            IDAStatics * This,
            /* [in] */ IDAVector3 *v1_0,
            /* [in] */ IDAVector3 *v2_1,
            /* [retval][out] */ IDAVector3 **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *AddPoint3Vector )( 
            IDAStatics * This,
            /* [in] */ IDAPoint3 *p_0,
            /* [in] */ IDAVector3 *v_1,
            /* [retval][out] */ IDAPoint3 **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *SubPoint3Vector )( 
            IDAStatics * This,
            /* [in] */ IDAPoint3 *p_0,
            /* [in] */ IDAVector3 *v_1,
            /* [retval][out] */ IDAPoint3 **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *SubPoint3 )( 
            IDAStatics * This,
            /* [in] */ IDAPoint3 *p1_0,
            /* [in] */ IDAPoint3 *p2_1,
            /* [retval][out] */ IDAVector3 **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *DistancePoint3 )( 
            IDAStatics * This,
            /* [in] */ IDAPoint3 *p_0,
            /* [in] */ IDAPoint3 *q_1,
            /* [retval][out] */ IDANumber **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *DistanceSquaredPoint3 )( 
            IDAStatics * This,
            /* [in] */ IDAPoint3 *p_0,
            /* [in] */ IDAPoint3 *q_1,
            /* [retval][out] */ IDANumber **ret_2);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_IdentityTransform3 )( 
            IDAStatics * This,
            /* [retval][out] */ IDATransform3 **ret_0);
        
        HRESULT ( STDMETHODCALLTYPE *Translate3Anim )( 
            IDAStatics * This,
            /* [in] */ IDANumber *tx_0,
            /* [in] */ IDANumber *ty_1,
            /* [in] */ IDANumber *tz_2,
            /* [retval][out] */ IDATransform3 **ret_3);
        
        HRESULT ( STDMETHODCALLTYPE *Translate3 )( 
            IDAStatics * This,
            /* [in] */ double tx_0,
            /* [in] */ double ty_1,
            /* [in] */ double tz_2,
            /* [retval][out] */ IDATransform3 **ret_3);
        
        HRESULT ( STDMETHODCALLTYPE *Translate3Rate )( 
            IDAStatics * This,
            /* [in] */ double tx_0,
            /* [in] */ double ty_1,
            /* [in] */ double tz_2,
            /* [retval][out] */ IDATransform3 **ret_3);
        
        HRESULT ( STDMETHODCALLTYPE *Translate3Vector )( 
            IDAStatics * This,
            /* [in] */ IDAVector3 *delta_0,
            /* [retval][out] */ IDATransform3 **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *Translate3Point )( 
            IDAStatics * This,
            /* [in] */ IDAPoint3 *new_origin_0,
            /* [retval][out] */ IDATransform3 **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *Scale3Anim )( 
            IDAStatics * This,
            /* [in] */ IDANumber *x_0,
            /* [in] */ IDANumber *y_1,
            /* [in] */ IDANumber *z_2,
            /* [retval][out] */ IDATransform3 **ret_3);
        
        HRESULT ( STDMETHODCALLTYPE *Scale3 )( 
            IDAStatics * This,
            /* [in] */ double x_0,
            /* [in] */ double y_1,
            /* [in] */ double z_2,
            /* [retval][out] */ IDATransform3 **ret_3);
        
        HRESULT ( STDMETHODCALLTYPE *Scale3Rate )( 
            IDAStatics * This,
            /* [in] */ double x_0,
            /* [in] */ double y_1,
            /* [in] */ double z_2,
            /* [retval][out] */ IDATransform3 **ret_3);
        
        HRESULT ( STDMETHODCALLTYPE *Scale3Vector )( 
            IDAStatics * This,
            /* [in] */ IDAVector3 *scale_vec_0,
            /* [retval][out] */ IDATransform3 **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *Scale3UniformAnim )( 
            IDAStatics * This,
            /* [in] */ IDANumber *uniform_scale_0,
            /* [retval][out] */ IDATransform3 **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *Scale3Uniform )( 
            IDAStatics * This,
            /* [in] */ double uniform_scale_0,
            /* [retval][out] */ IDATransform3 **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *Scale3UniformRate )( 
            IDAStatics * This,
            /* [in] */ double uniform_scale_0,
            /* [retval][out] */ IDATransform3 **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *Rotate3Anim )( 
            IDAStatics * This,
            /* [in] */ IDAVector3 *axis_0,
            /* [in] */ IDANumber *angle_1,
            /* [retval][out] */ IDATransform3 **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *Rotate3 )( 
            IDAStatics * This,
            /* [in] */ IDAVector3 *axis_0,
            /* [in] */ double angle_1,
            /* [retval][out] */ IDATransform3 **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *Rotate3Rate )( 
            IDAStatics * This,
            /* [in] */ IDAVector3 *axis_0,
            /* [in] */ double angle_1,
            /* [retval][out] */ IDATransform3 **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *Rotate3Degrees )( 
            IDAStatics * This,
            /* [in] */ IDAVector3 *axis_0,
            /* [in] */ double angle_1,
            /* [retval][out] */ IDATransform3 **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *Rotate3RateDegrees )( 
            IDAStatics * This,
            /* [in] */ IDAVector3 *axis_0,
            /* [in] */ double angle_1,
            /* [retval][out] */ IDATransform3 **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *XShear3Anim )( 
            IDAStatics * This,
            /* [in] */ IDANumber *a_0,
            /* [in] */ IDANumber *b_1,
            /* [retval][out] */ IDATransform3 **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *XShear3 )( 
            IDAStatics * This,
            /* [in] */ double a_0,
            /* [in] */ double b_1,
            /* [retval][out] */ IDATransform3 **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *XShear3Rate )( 
            IDAStatics * This,
            /* [in] */ double a_0,
            /* [in] */ double b_1,
            /* [retval][out] */ IDATransform3 **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *YShear3Anim )( 
            IDAStatics * This,
            /* [in] */ IDANumber *c_0,
            /* [in] */ IDANumber *d_1,
            /* [retval][out] */ IDATransform3 **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *YShear3 )( 
            IDAStatics * This,
            /* [in] */ double c_0,
            /* [in] */ double d_1,
            /* [retval][out] */ IDATransform3 **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *YShear3Rate )( 
            IDAStatics * This,
            /* [in] */ double c_0,
            /* [in] */ double d_1,
            /* [retval][out] */ IDATransform3 **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *ZShear3Anim )( 
            IDAStatics * This,
            /* [in] */ IDANumber *e_0,
            /* [in] */ IDANumber *f_1,
            /* [retval][out] */ IDATransform3 **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *ZShear3 )( 
            IDAStatics * This,
            /* [in] */ double e_0,
            /* [in] */ double f_1,
            /* [retval][out] */ IDATransform3 **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *ZShear3Rate )( 
            IDAStatics * This,
            /* [in] */ double e_0,
            /* [in] */ double f_1,
            /* [retval][out] */ IDATransform3 **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *Transform4x4AnimEx )( 
            IDAStatics * This,
            /* [in] */ LONG m_0size,
            /* [size_is][in] */ IDANumber *m_0[  ],
            /* [retval][out] */ IDATransform3 **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *Transform4x4Anim )( 
            IDAStatics * This,
            /* [in] */ VARIANT m_0,
            /* [retval][out] */ IDATransform3 **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *Compose3 )( 
            IDAStatics * This,
            /* [in] */ IDATransform3 *a_0,
            /* [in] */ IDATransform3 *b_1,
            /* [retval][out] */ IDATransform3 **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *Compose3ArrayEx )( 
            IDAStatics * This,
            /* [in] */ LONG xfs_0size,
            /* [size_is][in] */ IDATransform3 *xfs_0[  ],
            /* [retval][out] */ IDATransform3 **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *Compose3Array )( 
            IDAStatics * This,
            /* [in] */ VARIANT xfs_0,
            /* [retval][out] */ IDATransform3 **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *LookAtFrom )( 
            IDAStatics * This,
            /* [in] */ IDAPoint3 *to_0,
            /* [in] */ IDAPoint3 *from_1,
            /* [in] */ IDAVector3 *up_2,
            /* [retval][out] */ IDATransform3 **ret_3);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_IdentityTransform2 )( 
            IDAStatics * This,
            /* [retval][out] */ IDATransform2 **ret_0);
        
        HRESULT ( STDMETHODCALLTYPE *Translate2Anim )( 
            IDAStatics * This,
            /* [in] */ IDANumber *Tx_0,
            /* [in] */ IDANumber *Ty_1,
            /* [retval][out] */ IDATransform2 **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *Translate2 )( 
            IDAStatics * This,
            /* [in] */ double Tx_0,
            /* [in] */ double Ty_1,
            /* [retval][out] */ IDATransform2 **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *Translate2Rate )( 
            IDAStatics * This,
            /* [in] */ double Tx_0,
            /* [in] */ double Ty_1,
            /* [retval][out] */ IDATransform2 **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *Translate2Vector )( 
            IDAStatics * This,
            /* [in] */ IDAVector2 *delta_0,
            /* [retval][out] */ IDATransform2 **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *Translate2Point )( 
            IDAStatics * This,
            /* [in] */ IDAPoint2 *pos_0,
            /* [retval][out] */ IDATransform2 **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *Scale2Anim )( 
            IDAStatics * This,
            /* [in] */ IDANumber *x_0,
            /* [in] */ IDANumber *y_1,
            /* [retval][out] */ IDATransform2 **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *Scale2 )( 
            IDAStatics * This,
            /* [in] */ double x_0,
            /* [in] */ double y_1,
            /* [retval][out] */ IDATransform2 **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *Scale2Rate )( 
            IDAStatics * This,
            /* [in] */ double x_0,
            /* [in] */ double y_1,
            /* [retval][out] */ IDATransform2 **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *Scale2Vector2 )( 
            IDAStatics * This,
            /* [in] */ IDAVector2 *obsoleteMethod_0,
            /* [retval][out] */ IDATransform2 **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *Scale2Vector )( 
            IDAStatics * This,
            /* [in] */ IDAVector2 *scale_vec_0,
            /* [retval][out] */ IDATransform2 **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *Scale2UniformAnim )( 
            IDAStatics * This,
            /* [in] */ IDANumber *uniform_scale_0,
            /* [retval][out] */ IDATransform2 **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *Scale2Uniform )( 
            IDAStatics * This,
            /* [in] */ double uniform_scale_0,
            /* [retval][out] */ IDATransform2 **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *Scale2UniformRate )( 
            IDAStatics * This,
            /* [in] */ double uniform_scale_0,
            /* [retval][out] */ IDATransform2 **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *Rotate2Anim )( 
            IDAStatics * This,
            /* [in] */ IDANumber *angle_0,
            /* [retval][out] */ IDATransform2 **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *Rotate2 )( 
            IDAStatics * This,
            /* [in] */ double angle_0,
            /* [retval][out] */ IDATransform2 **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *Rotate2Rate )( 
            IDAStatics * This,
            /* [in] */ double angle_0,
            /* [retval][out] */ IDATransform2 **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *Rotate2Degrees )( 
            IDAStatics * This,
            /* [in] */ double angle_0,
            /* [retval][out] */ IDATransform2 **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *Rotate2RateDegrees )( 
            IDAStatics * This,
            /* [in] */ double angle_0,
            /* [retval][out] */ IDATransform2 **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *XShear2Anim )( 
            IDAStatics * This,
            /* [in] */ IDANumber *arg_0,
            /* [retval][out] */ IDATransform2 **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *XShear2 )( 
            IDAStatics * This,
            /* [in] */ double arg_0,
            /* [retval][out] */ IDATransform2 **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *XShear2Rate )( 
            IDAStatics * This,
            /* [in] */ double arg_0,
            /* [retval][out] */ IDATransform2 **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *YShear2Anim )( 
            IDAStatics * This,
            /* [in] */ IDANumber *arg_0,
            /* [retval][out] */ IDATransform2 **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *YShear2 )( 
            IDAStatics * This,
            /* [in] */ double arg_0,
            /* [retval][out] */ IDATransform2 **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *YShear2Rate )( 
            IDAStatics * This,
            /* [in] */ double arg_0,
            /* [retval][out] */ IDATransform2 **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *Transform3x2AnimEx )( 
            IDAStatics * This,
            /* [in] */ LONG m_0size,
            /* [size_is][in] */ IDANumber *m_0[  ],
            /* [retval][out] */ IDATransform2 **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *Transform3x2Anim )( 
            IDAStatics * This,
            /* [in] */ VARIANT m_0,
            /* [retval][out] */ IDATransform2 **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *Compose2 )( 
            IDAStatics * This,
            /* [in] */ IDATransform2 *a_0,
            /* [in] */ IDATransform2 *b_1,
            /* [retval][out] */ IDATransform2 **ret_2);
        
        HRESULT ( STDMETHODCALLTYPE *Compose2ArrayEx )( 
            IDAStatics * This,
            /* [in] */ LONG xfs_0size,
            /* [size_is][in] */ IDATransform2 *xfs_0[  ],
            /* [retval][out] */ IDATransform2 **ret_1);
        
        HRESULT ( STDMETHODCALLTYPE *Compose2Array )( 
            IDAStatics * This,
            /* [in] */ VARIANT xfs_0,
            /* [retval][out] */ IDATransform2 **ret_1);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Tuple )( 
            IDAStatics * This,
            /* [in] */ VARIANT obsolete1,
            /* [retval][out] */ IDATuple **obsolete2);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Array )( 
            IDAStatics * This,
            /* [in] */ VARIANT obsolete1,
            /* [retval][out] */ IDAArray **obsolete2);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_AreBlockingImportsComplete )( 
            IDAStatics * This,
            /* [retval][out] */ VARIANT_BOOL *bComplete);
        
        END_INTERFACE
    } IDAStaticsVtbl;

    interface IDAStatics
    {
        CONST_VTBL struct IDAStaticsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDAStatics_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDAStatics_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDAStatics_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDAStatics_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDAStatics_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDAStatics_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDAStatics_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDAStatics_get_VersionString(This,str)	\
    (This)->lpVtbl -> get_VersionString(This,str)

#define IDAStatics_get_Site(This,pSite)	\
    (This)->lpVtbl -> get_Site(This,pSite)

#define IDAStatics_put_Site(This,pSite)	\
    (This)->lpVtbl -> put_Site(This,pSite)

#define IDAStatics_put_ClientSite(This,pClientSite)	\
    (This)->lpVtbl -> put_ClientSite(This,pClientSite)

#define IDAStatics_get_ClientSite(This,pClientSite)	\
    (This)->lpVtbl -> get_ClientSite(This,pClientSite)

#define IDAStatics_put_PixelConstructionMode(This,bMode)	\
    (This)->lpVtbl -> put_PixelConstructionMode(This,bMode)

#define IDAStatics_get_PixelConstructionMode(This,bMode)	\
    (This)->lpVtbl -> get_PixelConstructionMode(This,bMode)

#define IDAStatics_TriggerEvent(This,event,data)	\
    (This)->lpVtbl -> TriggerEvent(This,event,data)

#define IDAStatics_NewDrawingSurface(This,pds)	\
    (This)->lpVtbl -> NewDrawingSurface(This,pds)

#define IDAStatics_ImportMovie(This,url,ppResult)	\
    (This)->lpVtbl -> ImportMovie(This,url,ppResult)

#define IDAStatics_ImportMovieAsync(This,url,pImageStandIn,pSoundStandIn,ppResult)	\
    (This)->lpVtbl -> ImportMovieAsync(This,url,pImageStandIn,pSoundStandIn,ppResult)

#define IDAStatics_ImportImage(This,url,ppImage)	\
    (This)->lpVtbl -> ImportImage(This,url,ppImage)

#define IDAStatics_ImportImageAsync(This,url,pImageStandIn,ppResult)	\
    (This)->lpVtbl -> ImportImageAsync(This,url,pImageStandIn,ppResult)

#define IDAStatics_ImportImageColorKey(This,url,colorKeyRed,colorKeyGreen,colorKeyBlue,ppImage)	\
    (This)->lpVtbl -> ImportImageColorKey(This,url,colorKeyRed,colorKeyGreen,colorKeyBlue,ppImage)

#define IDAStatics_ImportImageAsyncColorKey(This,url,pImageStandIn,colorKeyRed,colorKeyGreen,colorKeyBlue,ppResult)	\
    (This)->lpVtbl -> ImportImageAsyncColorKey(This,url,pImageStandIn,colorKeyRed,colorKeyGreen,colorKeyBlue,ppResult)

#define IDAStatics_ImportSound(This,url,ppResult)	\
    (This)->lpVtbl -> ImportSound(This,url,ppResult)

#define IDAStatics_ImportSoundAsync(This,url,pSoundStandIn,ppResult)	\
    (This)->lpVtbl -> ImportSoundAsync(This,url,pSoundStandIn,ppResult)

#define IDAStatics_ImportGeometry(This,url,ppGeometry)	\
    (This)->lpVtbl -> ImportGeometry(This,url,ppGeometry)

#define IDAStatics_ImportGeometryAsync(This,url,pGeoStandIn,ppResult)	\
    (This)->lpVtbl -> ImportGeometryAsync(This,url,pGeoStandIn,ppResult)

#define IDAStatics_ImportDirectDrawSurface(This,dds,updateEvent,ppImage)	\
    (This)->lpVtbl -> ImportDirectDrawSurface(This,dds,updateEvent,ppImage)

#define IDAStatics_Cond(This,c,i,e,pCondBvr)	\
    (This)->lpVtbl -> Cond(This,c,i,e,pCondBvr)

#define IDAStatics_DAArrayEx(This,s,pBvrs,bvr)	\
    (This)->lpVtbl -> DAArrayEx(This,s,pBvrs,bvr)

#define IDAStatics_DAArray(This,bvrs,bvr)	\
    (This)->lpVtbl -> DAArray(This,bvrs,bvr)

#define IDAStatics_DATupleEx(This,s,pBvrs,bvr)	\
    (This)->lpVtbl -> DATupleEx(This,s,pBvrs,bvr)

#define IDAStatics_DATuple(This,bvrs,bvr)	\
    (This)->lpVtbl -> DATuple(This,bvrs,bvr)

#define IDAStatics_ModifiableBehavior(This,orig,bvr)	\
    (This)->lpVtbl -> ModifiableBehavior(This,orig,bvr)

#define IDAStatics_UninitializedArray(This,typeTmp,bvr)	\
    (This)->lpVtbl -> UninitializedArray(This,typeTmp,bvr)

#define IDAStatics_UninitializedTuple(This,typeTmp,bvr)	\
    (This)->lpVtbl -> UninitializedTuple(This,typeTmp,bvr)

#define IDAStatics_NumberBSplineEx(This,degree,numKnots,knots,numPts,ctrlPts,numWts,weights,evaluator,bvr)	\
    (This)->lpVtbl -> NumberBSplineEx(This,degree,numKnots,knots,numPts,ctrlPts,numWts,weights,evaluator,bvr)

#define IDAStatics_NumberBSpline(This,degree,knots,CtrlPts,weights,evaluator,bvr)	\
    (This)->lpVtbl -> NumberBSpline(This,degree,knots,CtrlPts,weights,evaluator,bvr)

#define IDAStatics_Point2BSplineEx(This,degree,numKnots,knots,numPts,ctrlPts,numWts,weights,evaluator,bvr)	\
    (This)->lpVtbl -> Point2BSplineEx(This,degree,numKnots,knots,numPts,ctrlPts,numWts,weights,evaluator,bvr)

#define IDAStatics_Point2BSpline(This,degree,knots,CtrlPts,weights,evaluator,bvr)	\
    (This)->lpVtbl -> Point2BSpline(This,degree,knots,CtrlPts,weights,evaluator,bvr)

#define IDAStatics_Point3BSplineEx(This,degree,numKnots,knots,numPts,ctrlPts,numWts,weights,evaluator,bvr)	\
    (This)->lpVtbl -> Point3BSplineEx(This,degree,numKnots,knots,numPts,ctrlPts,numWts,weights,evaluator,bvr)

#define IDAStatics_Point3BSpline(This,degree,knots,CtrlPts,weights,evaluator,bvr)	\
    (This)->lpVtbl -> Point3BSpline(This,degree,knots,CtrlPts,weights,evaluator,bvr)

#define IDAStatics_Vector2BSplineEx(This,degree,numKnots,knots,numPts,ctrlPts,numWts,weights,evaluator,bvr)	\
    (This)->lpVtbl -> Vector2BSplineEx(This,degree,numKnots,knots,numPts,ctrlPts,numWts,weights,evaluator,bvr)

#define IDAStatics_Vector2BSpline(This,degree,knots,CtrlPts,weights,evaluator,bvr)	\
    (This)->lpVtbl -> Vector2BSpline(This,degree,knots,CtrlPts,weights,evaluator,bvr)

#define IDAStatics_Vector3BSplineEx(This,degree,numKnots,knots,numPts,ctrlPts,numWts,weights,evaluator,bvr)	\
    (This)->lpVtbl -> Vector3BSplineEx(This,degree,numKnots,knots,numPts,ctrlPts,numWts,weights,evaluator,bvr)

#define IDAStatics_Vector3BSpline(This,degree,knots,CtrlPts,weights,evaluator,bvr)	\
    (This)->lpVtbl -> Vector3BSpline(This,degree,knots,CtrlPts,weights,evaluator,bvr)

#define IDAStatics_Pow(This,a_0,b_1,ret_2)	\
    (This)->lpVtbl -> Pow(This,a_0,b_1,ret_2)

#define IDAStatics_Abs(This,a_0,ret_1)	\
    (This)->lpVtbl -> Abs(This,a_0,ret_1)

#define IDAStatics_Sqrt(This,a_0,ret_1)	\
    (This)->lpVtbl -> Sqrt(This,a_0,ret_1)

#define IDAStatics_Floor(This,a_0,ret_1)	\
    (This)->lpVtbl -> Floor(This,a_0,ret_1)

#define IDAStatics_Round(This,a_0,ret_1)	\
    (This)->lpVtbl -> Round(This,a_0,ret_1)

#define IDAStatics_Ceiling(This,a_0,ret_1)	\
    (This)->lpVtbl -> Ceiling(This,a_0,ret_1)

#define IDAStatics_Asin(This,a_0,ret_1)	\
    (This)->lpVtbl -> Asin(This,a_0,ret_1)

#define IDAStatics_Acos(This,a_0,ret_1)	\
    (This)->lpVtbl -> Acos(This,a_0,ret_1)

#define IDAStatics_Atan(This,a_0,ret_1)	\
    (This)->lpVtbl -> Atan(This,a_0,ret_1)

#define IDAStatics_Sin(This,a_0,ret_1)	\
    (This)->lpVtbl -> Sin(This,a_0,ret_1)

#define IDAStatics_Cos(This,a_0,ret_1)	\
    (This)->lpVtbl -> Cos(This,a_0,ret_1)

#define IDAStatics_Tan(This,a_0,ret_1)	\
    (This)->lpVtbl -> Tan(This,a_0,ret_1)

#define IDAStatics_Exp(This,a_0,ret_1)	\
    (This)->lpVtbl -> Exp(This,a_0,ret_1)

#define IDAStatics_Ln(This,a_0,ret_1)	\
    (This)->lpVtbl -> Ln(This,a_0,ret_1)

#define IDAStatics_Log10(This,a_0,ret_1)	\
    (This)->lpVtbl -> Log10(This,a_0,ret_1)

#define IDAStatics_ToDegrees(This,a_0,ret_1)	\
    (This)->lpVtbl -> ToDegrees(This,a_0,ret_1)

#define IDAStatics_ToRadians(This,a_0,ret_1)	\
    (This)->lpVtbl -> ToRadians(This,a_0,ret_1)

#define IDAStatics_Mod(This,a_0,b_1,ret_2)	\
    (This)->lpVtbl -> Mod(This,a_0,b_1,ret_2)

#define IDAStatics_Atan2(This,a_0,b_1,ret_2)	\
    (This)->lpVtbl -> Atan2(This,a_0,b_1,ret_2)

#define IDAStatics_Add(This,a_0,b_1,ret_2)	\
    (This)->lpVtbl -> Add(This,a_0,b_1,ret_2)

#define IDAStatics_Sub(This,a_0,b_1,ret_2)	\
    (This)->lpVtbl -> Sub(This,a_0,b_1,ret_2)

#define IDAStatics_Mul(This,a_0,b_1,ret_2)	\
    (This)->lpVtbl -> Mul(This,a_0,b_1,ret_2)

#define IDAStatics_Div(This,a_0,b_1,ret_2)	\
    (This)->lpVtbl -> Div(This,a_0,b_1,ret_2)

#define IDAStatics_LT(This,a_0,b_1,ret_2)	\
    (This)->lpVtbl -> LT(This,a_0,b_1,ret_2)

#define IDAStatics_LTE(This,a_0,b_1,ret_2)	\
    (This)->lpVtbl -> LTE(This,a_0,b_1,ret_2)

#define IDAStatics_GT(This,a_0,b_1,ret_2)	\
    (This)->lpVtbl -> GT(This,a_0,b_1,ret_2)

#define IDAStatics_GTE(This,a_0,b_1,ret_2)	\
    (This)->lpVtbl -> GTE(This,a_0,b_1,ret_2)

#define IDAStatics_EQ(This,a_0,b_1,ret_2)	\
    (This)->lpVtbl -> EQ(This,a_0,b_1,ret_2)

#define IDAStatics_NE(This,a_0,b_1,ret_2)	\
    (This)->lpVtbl -> NE(This,a_0,b_1,ret_2)

#define IDAStatics_Neg(This,a_0,ret_1)	\
    (This)->lpVtbl -> Neg(This,a_0,ret_1)

#define IDAStatics_InterpolateAnim(This,from_0,to_1,duration_2,ret_3)	\
    (This)->lpVtbl -> InterpolateAnim(This,from_0,to_1,duration_2,ret_3)

#define IDAStatics_Interpolate(This,from_0,to_1,duration_2,ret_3)	\
    (This)->lpVtbl -> Interpolate(This,from_0,to_1,duration_2,ret_3)

#define IDAStatics_SlowInSlowOutAnim(This,from_0,to_1,duration_2,sharpness_3,ret_4)	\
    (This)->lpVtbl -> SlowInSlowOutAnim(This,from_0,to_1,duration_2,sharpness_3,ret_4)

#define IDAStatics_SlowInSlowOut(This,from_0,to_1,duration_2,sharpness_3,ret_4)	\
    (This)->lpVtbl -> SlowInSlowOut(This,from_0,to_1,duration_2,sharpness_3,ret_4)

#define IDAStatics_SoundSource(This,snd_0,ret_1)	\
    (This)->lpVtbl -> SoundSource(This,snd_0,ret_1)

#define IDAStatics_Mix(This,left_0,right_1,ret_2)	\
    (This)->lpVtbl -> Mix(This,left_0,right_1,ret_2)

#define IDAStatics_And(This,a_0,b_1,ret_2)	\
    (This)->lpVtbl -> And(This,a_0,b_1,ret_2)

#define IDAStatics_Or(This,a_0,b_1,ret_2)	\
    (This)->lpVtbl -> Or(This,a_0,b_1,ret_2)

#define IDAStatics_Not(This,a_0,ret_1)	\
    (This)->lpVtbl -> Not(This,a_0,ret_1)

#define IDAStatics_Integral(This,b_0,ret_1)	\
    (This)->lpVtbl -> Integral(This,b_0,ret_1)

#define IDAStatics_Derivative(This,b_0,ret_1)	\
    (This)->lpVtbl -> Derivative(This,b_0,ret_1)

#define IDAStatics_IntegralVector2(This,v_0,ret_1)	\
    (This)->lpVtbl -> IntegralVector2(This,v_0,ret_1)

#define IDAStatics_IntegralVector3(This,v_0,ret_1)	\
    (This)->lpVtbl -> IntegralVector3(This,v_0,ret_1)

#define IDAStatics_DerivativeVector2(This,v_0,ret_1)	\
    (This)->lpVtbl -> DerivativeVector2(This,v_0,ret_1)

#define IDAStatics_DerivativeVector3(This,v_0,ret_1)	\
    (This)->lpVtbl -> DerivativeVector3(This,v_0,ret_1)

#define IDAStatics_DerivativePoint2(This,v_0,ret_1)	\
    (This)->lpVtbl -> DerivativePoint2(This,v_0,ret_1)

#define IDAStatics_DerivativePoint3(This,v_0,ret_1)	\
    (This)->lpVtbl -> DerivativePoint3(This,v_0,ret_1)

#define IDAStatics_KeyState(This,n_0,ret_1)	\
    (This)->lpVtbl -> KeyState(This,n_0,ret_1)

#define IDAStatics_KeyUp(This,arg_0,ret_1)	\
    (This)->lpVtbl -> KeyUp(This,arg_0,ret_1)

#define IDAStatics_KeyDown(This,arg_0,ret_1)	\
    (This)->lpVtbl -> KeyDown(This,arg_0,ret_1)

#define IDAStatics_DANumber(This,num_0,ret_1)	\
    (This)->lpVtbl -> DANumber(This,num_0,ret_1)

#define IDAStatics_DAString(This,str_0,ret_1)	\
    (This)->lpVtbl -> DAString(This,str_0,ret_1)

#define IDAStatics_DABoolean(This,num_0,ret_1)	\
    (This)->lpVtbl -> DABoolean(This,num_0,ret_1)

#define IDAStatics_SeededRandom(This,arg_0,ret_1)	\
    (This)->lpVtbl -> SeededRandom(This,arg_0,ret_1)

#define IDAStatics_get_MousePosition(This,ret_0)	\
    (This)->lpVtbl -> get_MousePosition(This,ret_0)

#define IDAStatics_get_LeftButtonState(This,ret_0)	\
    (This)->lpVtbl -> get_LeftButtonState(This,ret_0)

#define IDAStatics_get_RightButtonState(This,ret_0)	\
    (This)->lpVtbl -> get_RightButtonState(This,ret_0)

#define IDAStatics_get_DATrue(This,ret_0)	\
    (This)->lpVtbl -> get_DATrue(This,ret_0)

#define IDAStatics_get_DAFalse(This,ret_0)	\
    (This)->lpVtbl -> get_DAFalse(This,ret_0)

#define IDAStatics_get_LocalTime(This,ret_0)	\
    (This)->lpVtbl -> get_LocalTime(This,ret_0)

#define IDAStatics_get_GlobalTime(This,ret_0)	\
    (This)->lpVtbl -> get_GlobalTime(This,ret_0)

#define IDAStatics_get_Pixel(This,ret_0)	\
    (This)->lpVtbl -> get_Pixel(This,ret_0)

#define IDAStatics_UserData(This,data_0,ret_1)	\
    (This)->lpVtbl -> UserData(This,data_0,ret_1)

#define IDAStatics_UntilNotify(This,b0_0,event_1,notifier_2,ret_3)	\
    (This)->lpVtbl -> UntilNotify(This,b0_0,event_1,notifier_2,ret_3)

#define IDAStatics_Until(This,b0_0,event_1,b1_2,ret_3)	\
    (This)->lpVtbl -> Until(This,b0_0,event_1,b1_2,ret_3)

#define IDAStatics_UntilEx(This,b0_0,event_1,ret_2)	\
    (This)->lpVtbl -> UntilEx(This,b0_0,event_1,ret_2)

#define IDAStatics_Sequence(This,s1_0,s2_1,ret_2)	\
    (This)->lpVtbl -> Sequence(This,s1_0,s2_1,ret_2)

#define IDAStatics_FollowPath(This,path_0,duration_1,ret_2)	\
    (This)->lpVtbl -> FollowPath(This,path_0,duration_1,ret_2)

#define IDAStatics_FollowPathAngle(This,path_0,duration_1,ret_2)	\
    (This)->lpVtbl -> FollowPathAngle(This,path_0,duration_1,ret_2)

#define IDAStatics_FollowPathAngleUpright(This,path_0,duration_1,ret_2)	\
    (This)->lpVtbl -> FollowPathAngleUpright(This,path_0,duration_1,ret_2)

#define IDAStatics_FollowPathEval(This,path_0,eval_1,ret_2)	\
    (This)->lpVtbl -> FollowPathEval(This,path_0,eval_1,ret_2)

#define IDAStatics_FollowPathAngleEval(This,path_0,eval_1,ret_2)	\
    (This)->lpVtbl -> FollowPathAngleEval(This,path_0,eval_1,ret_2)

#define IDAStatics_FollowPathAngleUprightEval(This,path_0,eval_1,ret_2)	\
    (This)->lpVtbl -> FollowPathAngleUprightEval(This,path_0,eval_1,ret_2)

#define IDAStatics_FollowPathAnim(This,obsoleted1_0,obsoleted2_1,ret_2)	\
    (This)->lpVtbl -> FollowPathAnim(This,obsoleted1_0,obsoleted2_1,ret_2)

#define IDAStatics_FollowPathAngleAnim(This,obsoleted1_0,obsoleted2_1,ret_2)	\
    (This)->lpVtbl -> FollowPathAngleAnim(This,obsoleted1_0,obsoleted2_1,ret_2)

#define IDAStatics_FollowPathAngleUprightAnim(This,obsoleted1_0,obsoleted2_1,ret_2)	\
    (This)->lpVtbl -> FollowPathAngleUprightAnim(This,obsoleted1_0,obsoleted2_1,ret_2)

#define IDAStatics_ConcatString(This,s1_0,s2_1,ret_2)	\
    (This)->lpVtbl -> ConcatString(This,s1_0,s2_1,ret_2)

#define IDAStatics_PerspectiveCamera(This,focalDist_0,nearClip_1,ret_2)	\
    (This)->lpVtbl -> PerspectiveCamera(This,focalDist_0,nearClip_1,ret_2)

#define IDAStatics_PerspectiveCameraAnim(This,focalDist_0,nearClip_1,ret_2)	\
    (This)->lpVtbl -> PerspectiveCameraAnim(This,focalDist_0,nearClip_1,ret_2)

#define IDAStatics_ParallelCamera(This,nearClip_0,ret_1)	\
    (This)->lpVtbl -> ParallelCamera(This,nearClip_0,ret_1)

#define IDAStatics_ParallelCameraAnim(This,nearClip_0,ret_1)	\
    (This)->lpVtbl -> ParallelCameraAnim(This,nearClip_0,ret_1)

#define IDAStatics_ColorRgbAnim(This,red_0,green_1,blue_2,ret_3)	\
    (This)->lpVtbl -> ColorRgbAnim(This,red_0,green_1,blue_2,ret_3)

#define IDAStatics_ColorRgb(This,red_0,green_1,blue_2,ret_3)	\
    (This)->lpVtbl -> ColorRgb(This,red_0,green_1,blue_2,ret_3)

#define IDAStatics_ColorRgb255(This,red_0,green_1,blue_2,ret_3)	\
    (This)->lpVtbl -> ColorRgb255(This,red_0,green_1,blue_2,ret_3)

#define IDAStatics_ColorHsl(This,hue_0,saturation_1,lum_2,ret_3)	\
    (This)->lpVtbl -> ColorHsl(This,hue_0,saturation_1,lum_2,ret_3)

#define IDAStatics_ColorHslAnim(This,hue_0,saturation_1,lum_2,ret_3)	\
    (This)->lpVtbl -> ColorHslAnim(This,hue_0,saturation_1,lum_2,ret_3)

#define IDAStatics_get_Red(This,ret_0)	\
    (This)->lpVtbl -> get_Red(This,ret_0)

#define IDAStatics_get_Green(This,ret_0)	\
    (This)->lpVtbl -> get_Green(This,ret_0)

#define IDAStatics_get_Blue(This,ret_0)	\
    (This)->lpVtbl -> get_Blue(This,ret_0)

#define IDAStatics_get_Cyan(This,ret_0)	\
    (This)->lpVtbl -> get_Cyan(This,ret_0)

#define IDAStatics_get_Magenta(This,ret_0)	\
    (This)->lpVtbl -> get_Magenta(This,ret_0)

#define IDAStatics_get_Yellow(This,ret_0)	\
    (This)->lpVtbl -> get_Yellow(This,ret_0)

#define IDAStatics_get_Black(This,ret_0)	\
    (This)->lpVtbl -> get_Black(This,ret_0)

#define IDAStatics_get_White(This,ret_0)	\
    (This)->lpVtbl -> get_White(This,ret_0)

#define IDAStatics_get_Aqua(This,ret_0)	\
    (This)->lpVtbl -> get_Aqua(This,ret_0)

#define IDAStatics_get_Fuchsia(This,ret_0)	\
    (This)->lpVtbl -> get_Fuchsia(This,ret_0)

#define IDAStatics_get_Gray(This,ret_0)	\
    (This)->lpVtbl -> get_Gray(This,ret_0)

#define IDAStatics_get_Lime(This,ret_0)	\
    (This)->lpVtbl -> get_Lime(This,ret_0)

#define IDAStatics_get_Maroon(This,ret_0)	\
    (This)->lpVtbl -> get_Maroon(This,ret_0)

#define IDAStatics_get_Navy(This,ret_0)	\
    (This)->lpVtbl -> get_Navy(This,ret_0)

#define IDAStatics_get_Olive(This,ret_0)	\
    (This)->lpVtbl -> get_Olive(This,ret_0)

#define IDAStatics_get_Purple(This,ret_0)	\
    (This)->lpVtbl -> get_Purple(This,ret_0)

#define IDAStatics_get_Silver(This,ret_0)	\
    (This)->lpVtbl -> get_Silver(This,ret_0)

#define IDAStatics_get_Teal(This,ret_0)	\
    (This)->lpVtbl -> get_Teal(This,ret_0)

#define IDAStatics_Predicate(This,b_0,ret_1)	\
    (This)->lpVtbl -> Predicate(This,b_0,ret_1)

#define IDAStatics_NotEvent(This,event_0,ret_1)	\
    (This)->lpVtbl -> NotEvent(This,event_0,ret_1)

#define IDAStatics_AndEvent(This,e1_0,e2_1,ret_2)	\
    (This)->lpVtbl -> AndEvent(This,e1_0,e2_1,ret_2)

#define IDAStatics_OrEvent(This,e1_0,e2_1,ret_2)	\
    (This)->lpVtbl -> OrEvent(This,e1_0,e2_1,ret_2)

#define IDAStatics_ThenEvent(This,e1_0,e2_1,ret_2)	\
    (This)->lpVtbl -> ThenEvent(This,e1_0,e2_1,ret_2)

#define IDAStatics_get_LeftButtonDown(This,ret_0)	\
    (This)->lpVtbl -> get_LeftButtonDown(This,ret_0)

#define IDAStatics_get_LeftButtonUp(This,ret_0)	\
    (This)->lpVtbl -> get_LeftButtonUp(This,ret_0)

#define IDAStatics_get_RightButtonDown(This,ret_0)	\
    (This)->lpVtbl -> get_RightButtonDown(This,ret_0)

#define IDAStatics_get_RightButtonUp(This,ret_0)	\
    (This)->lpVtbl -> get_RightButtonUp(This,ret_0)

#define IDAStatics_get_Always(This,ret_0)	\
    (This)->lpVtbl -> get_Always(This,ret_0)

#define IDAStatics_get_Never(This,ret_0)	\
    (This)->lpVtbl -> get_Never(This,ret_0)

#define IDAStatics_TimerAnim(This,n_0,ret_1)	\
    (This)->lpVtbl -> TimerAnim(This,n_0,ret_1)

#define IDAStatics_Timer(This,n_0,ret_1)	\
    (This)->lpVtbl -> Timer(This,n_0,ret_1)

#define IDAStatics_AppTriggeredEvent(This,ret_0)	\
    (This)->lpVtbl -> AppTriggeredEvent(This,ret_0)

#define IDAStatics_ScriptCallback(This,obsolete1_0,obsolete2_1,obsolete3_2,ret_3)	\
    (This)->lpVtbl -> ScriptCallback(This,obsolete1_0,obsolete2_1,obsolete3_2,ret_3)

#define IDAStatics_get_EmptyGeometry(This,ret_0)	\
    (This)->lpVtbl -> get_EmptyGeometry(This,ret_0)

#define IDAStatics_UnionGeometry(This,g1_0,g2_1,ret_2)	\
    (This)->lpVtbl -> UnionGeometry(This,g1_0,g2_1,ret_2)

#define IDAStatics_UnionGeometryArrayEx(This,imgs_0size,imgs_0,ret_1)	\
    (This)->lpVtbl -> UnionGeometryArrayEx(This,imgs_0size,imgs_0,ret_1)

#define IDAStatics_UnionGeometryArray(This,imgs_0,ret_1)	\
    (This)->lpVtbl -> UnionGeometryArray(This,imgs_0,ret_1)

#define IDAStatics_get_EmptyImage(This,ret_0)	\
    (This)->lpVtbl -> get_EmptyImage(This,ret_0)

#define IDAStatics_get_DetectableEmptyImage(This,ret_0)	\
    (This)->lpVtbl -> get_DetectableEmptyImage(This,ret_0)

#define IDAStatics_SolidColorImage(This,col_0,ret_1)	\
    (This)->lpVtbl -> SolidColorImage(This,col_0,ret_1)

#define IDAStatics_GradientPolygonEx(This,points_0size,points_0,colors_1size,colors_1,ret_2)	\
    (This)->lpVtbl -> GradientPolygonEx(This,points_0size,points_0,colors_1size,colors_1,ret_2)

#define IDAStatics_GradientPolygon(This,points_0,colors_1,ret_2)	\
    (This)->lpVtbl -> GradientPolygon(This,points_0,colors_1,ret_2)

#define IDAStatics_RadialGradientPolygonEx(This,inner_0,outer_1,points_2size,points_2,fallOff_3,ret_4)	\
    (This)->lpVtbl -> RadialGradientPolygonEx(This,inner_0,outer_1,points_2size,points_2,fallOff_3,ret_4)

#define IDAStatics_RadialGradientPolygon(This,inner_0,outer_1,points_2,fallOff_3,ret_4)	\
    (This)->lpVtbl -> RadialGradientPolygon(This,inner_0,outer_1,points_2,fallOff_3,ret_4)

#define IDAStatics_RadialGradientPolygonAnimEx(This,inner_0,outer_1,points_2size,points_2,fallOff_3,ret_4)	\
    (This)->lpVtbl -> RadialGradientPolygonAnimEx(This,inner_0,outer_1,points_2size,points_2,fallOff_3,ret_4)

#define IDAStatics_RadialGradientPolygonAnim(This,inner_0,outer_1,points_2,fallOff_3,ret_4)	\
    (This)->lpVtbl -> RadialGradientPolygonAnim(This,inner_0,outer_1,points_2,fallOff_3,ret_4)

#define IDAStatics_GradientSquare(This,lowerLeft_0,upperLeft_1,upperRight_2,lowerRight_3,ret_4)	\
    (This)->lpVtbl -> GradientSquare(This,lowerLeft_0,upperLeft_1,upperRight_2,lowerRight_3,ret_4)

#define IDAStatics_RadialGradientSquare(This,inner_0,outer_1,fallOff_2,ret_3)	\
    (This)->lpVtbl -> RadialGradientSquare(This,inner_0,outer_1,fallOff_2,ret_3)

#define IDAStatics_RadialGradientSquareAnim(This,inner_0,outer_1,fallOff_2,ret_3)	\
    (This)->lpVtbl -> RadialGradientSquareAnim(This,inner_0,outer_1,fallOff_2,ret_3)

#define IDAStatics_RadialGradientRegularPoly(This,inner_0,outer_1,numEdges_2,fallOff_3,ret_4)	\
    (This)->lpVtbl -> RadialGradientRegularPoly(This,inner_0,outer_1,numEdges_2,fallOff_3,ret_4)

#define IDAStatics_RadialGradientRegularPolyAnim(This,inner_0,outer_1,numEdges_2,fallOff_3,ret_4)	\
    (This)->lpVtbl -> RadialGradientRegularPolyAnim(This,inner_0,outer_1,numEdges_2,fallOff_3,ret_4)

#define IDAStatics_GradientHorizontal(This,start_0,stop_1,fallOff_2,ret_3)	\
    (This)->lpVtbl -> GradientHorizontal(This,start_0,stop_1,fallOff_2,ret_3)

#define IDAStatics_GradientHorizontalAnim(This,start_0,stop_1,fallOff_2,ret_3)	\
    (This)->lpVtbl -> GradientHorizontalAnim(This,start_0,stop_1,fallOff_2,ret_3)

#define IDAStatics_HatchHorizontal(This,lineClr_0,spacing_1,ret_2)	\
    (This)->lpVtbl -> HatchHorizontal(This,lineClr_0,spacing_1,ret_2)

#define IDAStatics_HatchHorizontalAnim(This,lineClr_0,spacing_1,ret_2)	\
    (This)->lpVtbl -> HatchHorizontalAnim(This,lineClr_0,spacing_1,ret_2)

#define IDAStatics_HatchVertical(This,lineClr_0,spacing_1,ret_2)	\
    (This)->lpVtbl -> HatchVertical(This,lineClr_0,spacing_1,ret_2)

#define IDAStatics_HatchVerticalAnim(This,lineClr_0,spacing_1,ret_2)	\
    (This)->lpVtbl -> HatchVerticalAnim(This,lineClr_0,spacing_1,ret_2)

#define IDAStatics_HatchForwardDiagonal(This,lineClr_0,spacing_1,ret_2)	\
    (This)->lpVtbl -> HatchForwardDiagonal(This,lineClr_0,spacing_1,ret_2)

#define IDAStatics_HatchForwardDiagonalAnim(This,lineClr_0,spacing_1,ret_2)	\
    (This)->lpVtbl -> HatchForwardDiagonalAnim(This,lineClr_0,spacing_1,ret_2)

#define IDAStatics_HatchBackwardDiagonal(This,lineClr_0,spacing_1,ret_2)	\
    (This)->lpVtbl -> HatchBackwardDiagonal(This,lineClr_0,spacing_1,ret_2)

#define IDAStatics_HatchBackwardDiagonalAnim(This,lineClr_0,spacing_1,ret_2)	\
    (This)->lpVtbl -> HatchBackwardDiagonalAnim(This,lineClr_0,spacing_1,ret_2)

#define IDAStatics_HatchCross(This,lineClr_0,spacing_1,ret_2)	\
    (This)->lpVtbl -> HatchCross(This,lineClr_0,spacing_1,ret_2)

#define IDAStatics_HatchCrossAnim(This,lineClr_0,spacing_1,ret_2)	\
    (This)->lpVtbl -> HatchCrossAnim(This,lineClr_0,spacing_1,ret_2)

#define IDAStatics_HatchDiagonalCross(This,lineClr_0,spacing_1,ret_2)	\
    (This)->lpVtbl -> HatchDiagonalCross(This,lineClr_0,spacing_1,ret_2)

#define IDAStatics_HatchDiagonalCrossAnim(This,lineClr_0,spacing_1,ret_2)	\
    (This)->lpVtbl -> HatchDiagonalCrossAnim(This,lineClr_0,spacing_1,ret_2)

#define IDAStatics_Overlay(This,top_0,bottom_1,ret_2)	\
    (This)->lpVtbl -> Overlay(This,top_0,bottom_1,ret_2)

#define IDAStatics_OverlayArrayEx(This,imgs_0size,imgs_0,ret_1)	\
    (This)->lpVtbl -> OverlayArrayEx(This,imgs_0size,imgs_0,ret_1)

#define IDAStatics_OverlayArray(This,imgs_0,ret_1)	\
    (This)->lpVtbl -> OverlayArray(This,imgs_0,ret_1)

#define IDAStatics_get_AmbientLight(This,ret_0)	\
    (This)->lpVtbl -> get_AmbientLight(This,ret_0)

#define IDAStatics_get_DirectionalLight(This,ret_0)	\
    (This)->lpVtbl -> get_DirectionalLight(This,ret_0)

#define IDAStatics_get_PointLight(This,ret_0)	\
    (This)->lpVtbl -> get_PointLight(This,ret_0)

#define IDAStatics_SpotLightAnim(This,fullcone_0,cutoff_1,ret_2)	\
    (This)->lpVtbl -> SpotLightAnim(This,fullcone_0,cutoff_1,ret_2)

#define IDAStatics_SpotLight(This,fullcone_0,cutoff_1,ret_2)	\
    (This)->lpVtbl -> SpotLight(This,fullcone_0,cutoff_1,ret_2)

#define IDAStatics_get_DefaultLineStyle(This,ret_0)	\
    (This)->lpVtbl -> get_DefaultLineStyle(This,ret_0)

#define IDAStatics_get_EmptyLineStyle(This,ret_0)	\
    (This)->lpVtbl -> get_EmptyLineStyle(This,ret_0)

#define IDAStatics_get_JoinStyleBevel(This,ret_0)	\
    (This)->lpVtbl -> get_JoinStyleBevel(This,ret_0)

#define IDAStatics_get_JoinStyleRound(This,ret_0)	\
    (This)->lpVtbl -> get_JoinStyleRound(This,ret_0)

#define IDAStatics_get_JoinStyleMiter(This,ret_0)	\
    (This)->lpVtbl -> get_JoinStyleMiter(This,ret_0)

#define IDAStatics_get_EndStyleFlat(This,ret_0)	\
    (This)->lpVtbl -> get_EndStyleFlat(This,ret_0)

#define IDAStatics_get_EndStyleSquare(This,ret_0)	\
    (This)->lpVtbl -> get_EndStyleSquare(This,ret_0)

#define IDAStatics_get_EndStyleRound(This,ret_0)	\
    (This)->lpVtbl -> get_EndStyleRound(This,ret_0)

#define IDAStatics_get_DashStyleSolid(This,ret_0)	\
    (This)->lpVtbl -> get_DashStyleSolid(This,ret_0)

#define IDAStatics_get_DashStyleDashed(This,ret_0)	\
    (This)->lpVtbl -> get_DashStyleDashed(This,ret_0)

#define IDAStatics_get_DefaultMicrophone(This,ret_0)	\
    (This)->lpVtbl -> get_DefaultMicrophone(This,ret_0)

#define IDAStatics_get_OpaqueMatte(This,ret_0)	\
    (This)->lpVtbl -> get_OpaqueMatte(This,ret_0)

#define IDAStatics_get_ClearMatte(This,ret_0)	\
    (This)->lpVtbl -> get_ClearMatte(This,ret_0)

#define IDAStatics_UnionMatte(This,m1_0,m2_1,ret_2)	\
    (This)->lpVtbl -> UnionMatte(This,m1_0,m2_1,ret_2)

#define IDAStatics_IntersectMatte(This,m1_0,m2_1,ret_2)	\
    (This)->lpVtbl -> IntersectMatte(This,m1_0,m2_1,ret_2)

#define IDAStatics_DifferenceMatte(This,m1_0,m2_1,ret_2)	\
    (This)->lpVtbl -> DifferenceMatte(This,m1_0,m2_1,ret_2)

#define IDAStatics_FillMatte(This,p_0,ret_1)	\
    (This)->lpVtbl -> FillMatte(This,p_0,ret_1)

#define IDAStatics_TextMatte(This,str_0,fs_1,ret_2)	\
    (This)->lpVtbl -> TextMatte(This,str_0,fs_1,ret_2)

#define IDAStatics_get_EmptyMontage(This,ret_0)	\
    (This)->lpVtbl -> get_EmptyMontage(This,ret_0)

#define IDAStatics_ImageMontage(This,im_0,depth_1,ret_2)	\
    (This)->lpVtbl -> ImageMontage(This,im_0,depth_1,ret_2)

#define IDAStatics_ImageMontageAnim(This,im_0,depth_1,ret_2)	\
    (This)->lpVtbl -> ImageMontageAnim(This,im_0,depth_1,ret_2)

#define IDAStatics_UnionMontage(This,m1_0,m2_1,ret_2)	\
    (This)->lpVtbl -> UnionMontage(This,m1_0,m2_1,ret_2)

#define IDAStatics_Concat(This,p1_0,p2_1,ret_2)	\
    (This)->lpVtbl -> Concat(This,p1_0,p2_1,ret_2)

#define IDAStatics_ConcatArrayEx(This,paths_0size,paths_0,ret_1)	\
    (This)->lpVtbl -> ConcatArrayEx(This,paths_0size,paths_0,ret_1)

#define IDAStatics_ConcatArray(This,paths_0,ret_1)	\
    (This)->lpVtbl -> ConcatArray(This,paths_0,ret_1)

#define IDAStatics_Line(This,p1_0,p2_1,ret_2)	\
    (This)->lpVtbl -> Line(This,p1_0,p2_1,ret_2)

#define IDAStatics_Ray(This,pt_0,ret_1)	\
    (This)->lpVtbl -> Ray(This,pt_0,ret_1)

#define IDAStatics_StringPathAnim(This,str_0,fs_1,ret_2)	\
    (This)->lpVtbl -> StringPathAnim(This,str_0,fs_1,ret_2)

#define IDAStatics_StringPath(This,str_0,fs_1,ret_2)	\
    (This)->lpVtbl -> StringPath(This,str_0,fs_1,ret_2)

#define IDAStatics_PolylineEx(This,points_0size,points_0,ret_1)	\
    (This)->lpVtbl -> PolylineEx(This,points_0size,points_0,ret_1)

#define IDAStatics_Polyline(This,points_0,ret_1)	\
    (This)->lpVtbl -> Polyline(This,points_0,ret_1)

#define IDAStatics_PolydrawPathEx(This,points_0size,points_0,codes_1size,codes_1,ret_2)	\
    (This)->lpVtbl -> PolydrawPathEx(This,points_0size,points_0,codes_1size,codes_1,ret_2)

#define IDAStatics_PolydrawPath(This,points_0,codes_1,ret_2)	\
    (This)->lpVtbl -> PolydrawPath(This,points_0,codes_1,ret_2)

#define IDAStatics_ArcRadians(This,startAngle_0,endAngle_1,arcWidth_2,arcHeight_3,ret_4)	\
    (This)->lpVtbl -> ArcRadians(This,startAngle_0,endAngle_1,arcWidth_2,arcHeight_3,ret_4)

#define IDAStatics_ArcRadiansAnim(This,startAngle_0,endAngle_1,arcWidth_2,arcHeight_3,ret_4)	\
    (This)->lpVtbl -> ArcRadiansAnim(This,startAngle_0,endAngle_1,arcWidth_2,arcHeight_3,ret_4)

#define IDAStatics_ArcDegrees(This,startAngle_0,endAngle_1,arcWidth_2,arcHeight_3,ret_4)	\
    (This)->lpVtbl -> ArcDegrees(This,startAngle_0,endAngle_1,arcWidth_2,arcHeight_3,ret_4)

#define IDAStatics_PieRadians(This,startAngle_0,endAngle_1,arcWidth_2,arcHeight_3,ret_4)	\
    (This)->lpVtbl -> PieRadians(This,startAngle_0,endAngle_1,arcWidth_2,arcHeight_3,ret_4)

#define IDAStatics_PieRadiansAnim(This,startAngle_0,endAngle_1,arcWidth_2,arcHeight_3,ret_4)	\
    (This)->lpVtbl -> PieRadiansAnim(This,startAngle_0,endAngle_1,arcWidth_2,arcHeight_3,ret_4)

#define IDAStatics_PieDegrees(This,startAngle_0,endAngle_1,arcWidth_2,arcHeight_3,ret_4)	\
    (This)->lpVtbl -> PieDegrees(This,startAngle_0,endAngle_1,arcWidth_2,arcHeight_3,ret_4)

#define IDAStatics_Oval(This,width_0,height_1,ret_2)	\
    (This)->lpVtbl -> Oval(This,width_0,height_1,ret_2)

#define IDAStatics_OvalAnim(This,width_0,height_1,ret_2)	\
    (This)->lpVtbl -> OvalAnim(This,width_0,height_1,ret_2)

#define IDAStatics_Rect(This,width_0,height_1,ret_2)	\
    (This)->lpVtbl -> Rect(This,width_0,height_1,ret_2)

#define IDAStatics_RectAnim(This,width_0,height_1,ret_2)	\
    (This)->lpVtbl -> RectAnim(This,width_0,height_1,ret_2)

#define IDAStatics_RoundRect(This,width_0,height_1,cornerArcWidth_2,cornerArcHeight_3,ret_4)	\
    (This)->lpVtbl -> RoundRect(This,width_0,height_1,cornerArcWidth_2,cornerArcHeight_3,ret_4)

#define IDAStatics_RoundRectAnim(This,width_0,height_1,cornerArcWidth_2,cornerArcHeight_3,ret_4)	\
    (This)->lpVtbl -> RoundRectAnim(This,width_0,height_1,cornerArcWidth_2,cornerArcHeight_3,ret_4)

#define IDAStatics_CubicBSplinePathEx(This,points_0size,points_0,knots_1size,knots_1,ret_2)	\
    (This)->lpVtbl -> CubicBSplinePathEx(This,points_0size,points_0,knots_1size,knots_1,ret_2)

#define IDAStatics_CubicBSplinePath(This,points_0,knots_1,ret_2)	\
    (This)->lpVtbl -> CubicBSplinePath(This,points_0,knots_1,ret_2)

#define IDAStatics_TextPath(This,obsolete1_0,obsolete2_1,ret_2)	\
    (This)->lpVtbl -> TextPath(This,obsolete1_0,obsolete2_1,ret_2)

#define IDAStatics_get_Silence(This,ret_0)	\
    (This)->lpVtbl -> get_Silence(This,ret_0)

#define IDAStatics_MixArrayEx(This,snds_0size,snds_0,ret_1)	\
    (This)->lpVtbl -> MixArrayEx(This,snds_0size,snds_0,ret_1)

#define IDAStatics_MixArray(This,snds_0,ret_1)	\
    (This)->lpVtbl -> MixArray(This,snds_0,ret_1)

#define IDAStatics_get_SinSynth(This,ret_0)	\
    (This)->lpVtbl -> get_SinSynth(This,ret_0)

#define IDAStatics_get_DefaultFont(This,ret_0)	\
    (This)->lpVtbl -> get_DefaultFont(This,ret_0)

#define IDAStatics_FontAnim(This,str_0,size_1,col_2,ret_3)	\
    (This)->lpVtbl -> FontAnim(This,str_0,size_1,col_2,ret_3)

#define IDAStatics_Font(This,str_0,size_1,col_2,ret_3)	\
    (This)->lpVtbl -> Font(This,str_0,size_1,col_2,ret_3)

#define IDAStatics_StringImageAnim(This,str_0,fs_1,ret_2)	\
    (This)->lpVtbl -> StringImageAnim(This,str_0,fs_1,ret_2)

#define IDAStatics_StringImage(This,str_0,fs_1,ret_2)	\
    (This)->lpVtbl -> StringImage(This,str_0,fs_1,ret_2)

#define IDAStatics_TextImageAnim(This,obsoleted1_0,obsoleted2_1,ret_2)	\
    (This)->lpVtbl -> TextImageAnim(This,obsoleted1_0,obsoleted2_1,ret_2)

#define IDAStatics_TextImage(This,obsoleted1_0,obsoleted2_1,ret_2)	\
    (This)->lpVtbl -> TextImage(This,obsoleted1_0,obsoleted2_1,ret_2)

#define IDAStatics_get_XVector2(This,ret_0)	\
    (This)->lpVtbl -> get_XVector2(This,ret_0)

#define IDAStatics_get_YVector2(This,ret_0)	\
    (This)->lpVtbl -> get_YVector2(This,ret_0)

#define IDAStatics_get_ZeroVector2(This,ret_0)	\
    (This)->lpVtbl -> get_ZeroVector2(This,ret_0)

#define IDAStatics_get_Origin2(This,ret_0)	\
    (This)->lpVtbl -> get_Origin2(This,ret_0)

#define IDAStatics_Vector2Anim(This,x_0,y_1,ret_2)	\
    (This)->lpVtbl -> Vector2Anim(This,x_0,y_1,ret_2)

#define IDAStatics_Vector2(This,x_0,y_1,ret_2)	\
    (This)->lpVtbl -> Vector2(This,x_0,y_1,ret_2)

#define IDAStatics_Point2Anim(This,x_0,y_1,ret_2)	\
    (This)->lpVtbl -> Point2Anim(This,x_0,y_1,ret_2)

#define IDAStatics_Point2(This,x_0,y_1,ret_2)	\
    (This)->lpVtbl -> Point2(This,x_0,y_1,ret_2)

#define IDAStatics_Vector2PolarAnim(This,theta_0,radius_1,ret_2)	\
    (This)->lpVtbl -> Vector2PolarAnim(This,theta_0,radius_1,ret_2)

#define IDAStatics_Vector2Polar(This,theta_0,radius_1,ret_2)	\
    (This)->lpVtbl -> Vector2Polar(This,theta_0,radius_1,ret_2)

#define IDAStatics_Vector2PolarDegrees(This,theta_0,radius_1,ret_2)	\
    (This)->lpVtbl -> Vector2PolarDegrees(This,theta_0,radius_1,ret_2)

#define IDAStatics_Point2PolarAnim(This,theta_0,radius_1,ret_2)	\
    (This)->lpVtbl -> Point2PolarAnim(This,theta_0,radius_1,ret_2)

#define IDAStatics_Point2Polar(This,theta_0,radius_1,ret_2)	\
    (This)->lpVtbl -> Point2Polar(This,theta_0,radius_1,ret_2)

#define IDAStatics_DotVector2(This,v_0,u_1,ret_2)	\
    (This)->lpVtbl -> DotVector2(This,v_0,u_1,ret_2)

#define IDAStatics_NegVector2(This,v_0,ret_1)	\
    (This)->lpVtbl -> NegVector2(This,v_0,ret_1)

#define IDAStatics_SubVector2(This,v1_0,v2_1,ret_2)	\
    (This)->lpVtbl -> SubVector2(This,v1_0,v2_1,ret_2)

#define IDAStatics_AddVector2(This,v1_0,v2_1,ret_2)	\
    (This)->lpVtbl -> AddVector2(This,v1_0,v2_1,ret_2)

#define IDAStatics_AddPoint2Vector(This,p_0,v_1,ret_2)	\
    (This)->lpVtbl -> AddPoint2Vector(This,p_0,v_1,ret_2)

#define IDAStatics_SubPoint2Vector(This,p_0,v_1,ret_2)	\
    (This)->lpVtbl -> SubPoint2Vector(This,p_0,v_1,ret_2)

#define IDAStatics_SubPoint2(This,p1_0,p2_1,ret_2)	\
    (This)->lpVtbl -> SubPoint2(This,p1_0,p2_1,ret_2)

#define IDAStatics_DistancePoint2(This,p_0,q_1,ret_2)	\
    (This)->lpVtbl -> DistancePoint2(This,p_0,q_1,ret_2)

#define IDAStatics_DistanceSquaredPoint2(This,p_0,q_1,ret_2)	\
    (This)->lpVtbl -> DistanceSquaredPoint2(This,p_0,q_1,ret_2)

#define IDAStatics_get_XVector3(This,ret_0)	\
    (This)->lpVtbl -> get_XVector3(This,ret_0)

#define IDAStatics_get_YVector3(This,ret_0)	\
    (This)->lpVtbl -> get_YVector3(This,ret_0)

#define IDAStatics_get_ZVector3(This,ret_0)	\
    (This)->lpVtbl -> get_ZVector3(This,ret_0)

#define IDAStatics_get_ZeroVector3(This,ret_0)	\
    (This)->lpVtbl -> get_ZeroVector3(This,ret_0)

#define IDAStatics_get_Origin3(This,ret_0)	\
    (This)->lpVtbl -> get_Origin3(This,ret_0)

#define IDAStatics_Vector3Anim(This,x_0,y_1,z_2,ret_3)	\
    (This)->lpVtbl -> Vector3Anim(This,x_0,y_1,z_2,ret_3)

#define IDAStatics_Vector3(This,x_0,y_1,z_2,ret_3)	\
    (This)->lpVtbl -> Vector3(This,x_0,y_1,z_2,ret_3)

#define IDAStatics_Point3Anim(This,x_0,y_1,z_2,ret_3)	\
    (This)->lpVtbl -> Point3Anim(This,x_0,y_1,z_2,ret_3)

#define IDAStatics_Point3(This,x_0,y_1,z_2,ret_3)	\
    (This)->lpVtbl -> Point3(This,x_0,y_1,z_2,ret_3)

#define IDAStatics_Vector3SphericalAnim(This,xyAngle_0,yzAngle_1,radius_2,ret_3)	\
    (This)->lpVtbl -> Vector3SphericalAnim(This,xyAngle_0,yzAngle_1,radius_2,ret_3)

#define IDAStatics_Vector3Spherical(This,xyAngle_0,yzAngle_1,radius_2,ret_3)	\
    (This)->lpVtbl -> Vector3Spherical(This,xyAngle_0,yzAngle_1,radius_2,ret_3)

#define IDAStatics_Point3SphericalAnim(This,zxAngle_0,xyAngle_1,radius_2,ret_3)	\
    (This)->lpVtbl -> Point3SphericalAnim(This,zxAngle_0,xyAngle_1,radius_2,ret_3)

#define IDAStatics_Point3Spherical(This,zxAngle_0,xyAngle_1,radius_2,ret_3)	\
    (This)->lpVtbl -> Point3Spherical(This,zxAngle_0,xyAngle_1,radius_2,ret_3)

#define IDAStatics_DotVector3(This,v_0,u_1,ret_2)	\
    (This)->lpVtbl -> DotVector3(This,v_0,u_1,ret_2)

#define IDAStatics_CrossVector3(This,v_0,u_1,ret_2)	\
    (This)->lpVtbl -> CrossVector3(This,v_0,u_1,ret_2)

#define IDAStatics_NegVector3(This,v_0,ret_1)	\
    (This)->lpVtbl -> NegVector3(This,v_0,ret_1)

#define IDAStatics_SubVector3(This,v1_0,v2_1,ret_2)	\
    (This)->lpVtbl -> SubVector3(This,v1_0,v2_1,ret_2)

#define IDAStatics_AddVector3(This,v1_0,v2_1,ret_2)	\
    (This)->lpVtbl -> AddVector3(This,v1_0,v2_1,ret_2)

#define IDAStatics_AddPoint3Vector(This,p_0,v_1,ret_2)	\
    (This)->lpVtbl -> AddPoint3Vector(This,p_0,v_1,ret_2)

#define IDAStatics_SubPoint3Vector(This,p_0,v_1,ret_2)	\
    (This)->lpVtbl -> SubPoint3Vector(This,p_0,v_1,ret_2)

#define IDAStatics_SubPoint3(This,p1_0,p2_1,ret_2)	\
    (This)->lpVtbl -> SubPoint3(This,p1_0,p2_1,ret_2)

#define IDAStatics_DistancePoint3(This,p_0,q_1,ret_2)	\
    (This)->lpVtbl -> DistancePoint3(This,p_0,q_1,ret_2)

#define IDAStatics_DistanceSquaredPoint3(This,p_0,q_1,ret_2)	\
    (This)->lpVtbl -> DistanceSquaredPoint3(This,p_0,q_1,ret_2)

#define IDAStatics_get_IdentityTransform3(This,ret_0)	\
    (This)->lpVtbl -> get_IdentityTransform3(This,ret_0)

#define IDAStatics_Translate3Anim(This,tx_0,ty_1,tz_2,ret_3)	\
    (This)->lpVtbl -> Translate3Anim(This,tx_0,ty_1,tz_2,ret_3)

#define IDAStatics_Translate3(This,tx_0,ty_1,tz_2,ret_3)	\
    (This)->lpVtbl -> Translate3(This,tx_0,ty_1,tz_2,ret_3)

#define IDAStatics_Translate3Rate(This,tx_0,ty_1,tz_2,ret_3)	\
    (This)->lpVtbl -> Translate3Rate(This,tx_0,ty_1,tz_2,ret_3)

#define IDAStatics_Translate3Vector(This,delta_0,ret_1)	\
    (This)->lpVtbl -> Translate3Vector(This,delta_0,ret_1)

#define IDAStatics_Translate3Point(This,new_origin_0,ret_1)	\
    (This)->lpVtbl -> Translate3Point(This,new_origin_0,ret_1)

#define IDAStatics_Scale3Anim(This,x_0,y_1,z_2,ret_3)	\
    (This)->lpVtbl -> Scale3Anim(This,x_0,y_1,z_2,ret_3)

#define IDAStatics_Scale3(This,x_0,y_1,z_2,ret_3)	\
    (This)->lpVtbl -> Scale3(This,x_0,y_1,z_2,ret_3)

#define IDAStatics_Scale3Rate(This,x_0,y_1,z_2,ret_3)	\
    (This)->lpVtbl -> Scale3Rate(This,x_0,y_1,z_2,ret_3)

#define IDAStatics_Scale3Vector(This,scale_vec_0,ret_1)	\
    (This)->lpVtbl -> Scale3Vector(This,scale_vec_0,ret_1)

#define IDAStatics_Scale3UniformAnim(This,uniform_scale_0,ret_1)	\
    (This)->lpVtbl -> Scale3UniformAnim(This,uniform_scale_0,ret_1)

#define IDAStatics_Scale3Uniform(This,uniform_scale_0,ret_1)	\
    (This)->lpVtbl -> Scale3Uniform(This,uniform_scale_0,ret_1)

#define IDAStatics_Scale3UniformRate(This,uniform_scale_0,ret_1)	\
    (This)->lpVtbl -> Scale3UniformRate(This,uniform_scale_0,ret_1)

#define IDAStatics_Rotate3Anim(This,axis_0,angle_1,ret_2)	\
    (This)->lpVtbl -> Rotate3Anim(This,axis_0,angle_1,ret_2)

#define IDAStatics_Rotate3(This,axis_0,angle_1,ret_2)	\
    (This)->lpVtbl -> Rotate3(This,axis_0,angle_1,ret_2)

#define IDAStatics_Rotate3Rate(This,axis_0,angle_1,ret_2)	\
    (This)->lpVtbl -> Rotate3Rate(This,axis_0,angle_1,ret_2)

#define IDAStatics_Rotate3Degrees(This,axis_0,angle_1,ret_2)	\
    (This)->lpVtbl -> Rotate3Degrees(This,axis_0,angle_1,ret_2)

#define IDAStatics_Rotate3RateDegrees(This,axis_0,angle_1,ret_2)	\
    (This)->lpVtbl -> Rotate3RateDegrees(This,axis_0,angle_1,ret_2)

#define IDAStatics_XShear3Anim(This,a_0,b_1,ret_2)	\
    (This)->lpVtbl -> XShear3Anim(This,a_0,b_1,ret_2)

#define IDAStatics_XShear3(This,a_0,b_1,ret_2)	\
    (This)->lpVtbl -> XShear3(This,a_0,b_1,ret_2)

#define IDAStatics_XShear3Rate(This,a_0,b_1,ret_2)	\
    (This)->lpVtbl -> XShear3Rate(This,a_0,b_1,ret_2)

#define IDAStatics_YShear3Anim(This,c_0,d_1,ret_2)	\
    (This)->lpVtbl -> YShear3Anim(This,c_0,d_1,ret_2)

#define IDAStatics_YShear3(This,c_0,d_1,ret_2)	\
    (This)->lpVtbl -> YShear3(This,c_0,d_1,ret_2)

#define IDAStatics_YShear3Rate(This,c_0,d_1,ret_2)	\
    (This)->lpVtbl -> YShear3Rate(This,c_0,d_1,ret_2)

#define IDAStatics_ZShear3Anim(This,e_0,f_1,ret_2)	\
    (This)->lpVtbl -> ZShear3Anim(This,e_0,f_1,ret_2)

#define IDAStatics_ZShear3(This,e_0,f_1,ret_2)	\
    (This)->lpVtbl -> ZShear3(This,e_0,f_1,ret_2)

#define IDAStatics_ZShear3Rate(This,e_0,f_1,ret_2)	\
    (This)->lpVtbl -> ZShear3Rate(This,e_0,f_1,ret_2)

#define IDAStatics_Transform4x4AnimEx(This,m_0size,m_0,ret_1)	\
    (This)->lpVtbl -> Transform4x4AnimEx(This,m_0size,m_0,ret_1)

#define IDAStatics_Transform4x4Anim(This,m_0,ret_1)	\
    (This)->lpVtbl -> Transform4x4Anim(This,m_0,ret_1)

#define IDAStatics_Compose3(This,a_0,b_1,ret_2)	\
    (This)->lpVtbl -> Compose3(This,a_0,b_1,ret_2)

#define IDAStatics_Compose3ArrayEx(This,xfs_0size,xfs_0,ret_1)	\
    (This)->lpVtbl -> Compose3ArrayEx(This,xfs_0size,xfs_0,ret_1)

#define IDAStatics_Compose3Array(This,xfs_0,ret_1)	\
    (This)->lpVtbl -> Compose3Array(This,xfs_0,ret_1)

#define IDAStatics_LookAtFrom(This,to_0,from_1,up_2,ret_3)	\
    (This)->lpVtbl -> LookAtFrom(This,to_0,from_1,up_2,ret_3)

#define IDAStatics_get_IdentityTransform2(This,ret_0)	\
    (This)->lpVtbl -> get_IdentityTransform2(This,ret_0)

#define IDAStatics_Translate2Anim(This,Tx_0,Ty_1,ret_2)	\
    (This)->lpVtbl -> Translate2Anim(This,Tx_0,Ty_1,ret_2)

#define IDAStatics_Translate2(This,Tx_0,Ty_1,ret_2)	\
    (This)->lpVtbl -> Translate2(This,Tx_0,Ty_1,ret_2)

#define IDAStatics_Translate2Rate(This,Tx_0,Ty_1,ret_2)	\
    (This)->lpVtbl -> Translate2Rate(This,Tx_0,Ty_1,ret_2)

#define IDAStatics_Translate2Vector(This,delta_0,ret_1)	\
    (This)->lpVtbl -> Translate2Vector(This,delta_0,ret_1)

#define IDAStatics_Translate2Point(This,pos_0,ret_1)	\
    (This)->lpVtbl -> Translate2Point(This,pos_0,ret_1)

#define IDAStatics_Scale2Anim(This,x_0,y_1,ret_2)	\
    (This)->lpVtbl -> Scale2Anim(This,x_0,y_1,ret_2)

#define IDAStatics_Scale2(This,x_0,y_1,ret_2)	\
    (This)->lpVtbl -> Scale2(This,x_0,y_1,ret_2)

#define IDAStatics_Scale2Rate(This,x_0,y_1,ret_2)	\
    (This)->lpVtbl -> Scale2Rate(This,x_0,y_1,ret_2)

#define IDAStatics_Scale2Vector2(This,obsoleteMethod_0,ret_1)	\
    (This)->lpVtbl -> Scale2Vector2(This,obsoleteMethod_0,ret_1)

#define IDAStatics_Scale2Vector(This,scale_vec_0,ret_1)	\
    (This)->lpVtbl -> Scale2Vector(This,scale_vec_0,ret_1)

#define IDAStatics_Scale2UniformAnim(This,uniform_scale_0,ret_1)	\
    (This)->lpVtbl -> Scale2UniformAnim(This,uniform_scale_0,ret_1)

#define IDAStatics_Scale2Uniform(This,uniform_scale_0,ret_1)	\
    (This)->lpVtbl -> Scale2Uniform(This,uniform_scale_0,ret_1)

#define IDAStatics_Scale2UniformRate(This,uniform_scale_0,ret_1)	\
    (This)->lpVtbl -> Scale2UniformRate(This,uniform_scale_0,ret_1)

#define IDAStatics_Rotate2Anim(This,angle_0,ret_1)	\
    (This)->lpVtbl -> Rotate2Anim(This,angle_0,ret_1)

#define IDAStatics_Rotate2(This,angle_0,ret_1)	\
    (This)->lpVtbl -> Rotate2(This,angle_0,ret_1)

#define IDAStatics_Rotate2Rate(This,angle_0,ret_1)	\
    (This)->lpVtbl -> Rotate2Rate(This,angle_0,ret_1)

#define IDAStatics_Rotate2Degrees(This,angle_0,ret_1)	\
    (This)->lpVtbl -> Rotate2Degrees(This,angle_0,ret_1)

#define IDAStatics_Rotate2RateDegrees(This,angle_0,ret_1)	\
    (This)->lpVtbl -> Rotate2RateDegrees(This,angle_0,ret_1)

#define IDAStatics_XShear2Anim(This,arg_0,ret_1)	\
    (This)->lpVtbl -> XShear2Anim(This,arg_0,ret_1)

#define IDAStatics_XShear2(This,arg_0,ret_1)	\
    (This)->lpVtbl -> XShear2(This,arg_0,ret_1)

#define IDAStatics_XShear2Rate(This,arg_0,ret_1)	\
    (This)->lpVtbl -> XShear2Rate(This,arg_0,ret_1)

#define IDAStatics_YShear2Anim(This,arg_0,ret_1)	\
    (This)->lpVtbl -> YShear2Anim(This,arg_0,ret_1)

#define IDAStatics_YShear2(This,arg_0,ret_1)	\
    (This)->lpVtbl -> YShear2(This,arg_0,ret_1)

#define IDAStatics_YShear2Rate(This,arg_0,ret_1)	\
    (This)->lpVtbl -> YShear2Rate(This,arg_0,ret_1)

#define IDAStatics_Transform3x2AnimEx(This,m_0size,m_0,ret_1)	\
    (This)->lpVtbl -> Transform3x2AnimEx(This,m_0size,m_0,ret_1)

#define IDAStatics_Transform3x2Anim(This,m_0,ret_1)	\
    (This)->lpVtbl -> Transform3x2Anim(This,m_0,ret_1)

#define IDAStatics_Compose2(This,a_0,b_1,ret_2)	\
    (This)->lpVtbl -> Compose2(This,a_0,b_1,ret_2)

#define IDAStatics_Compose2ArrayEx(This,xfs_0size,xfs_0,ret_1)	\
    (This)->lpVtbl -> Compose2ArrayEx(This,xfs_0size,xfs_0,ret_1)

#define IDAStatics_Compose2Array(This,xfs_0,ret_1)	\
    (This)->lpVtbl -> Compose2Array(This,xfs_0,ret_1)

#define IDAStatics_Tuple(This,obsolete1,obsolete2)	\
    (This)->lpVtbl -> Tuple(This,obsolete1,obsolete2)

#define IDAStatics_Array(This,obsolete1,obsolete2)	\
    (This)->lpVtbl -> Array(This,obsolete1,obsolete2)

#define IDAStatics_get_AreBlockingImportsComplete(This,bComplete)	\
    (This)->lpVtbl -> get_AreBlockingImportsComplete(This,bComplete)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget] */ HRESULT STDMETHODCALLTYPE IDAStatics_get_VersionString_Proxy( 
    IDAStatics * This,
    /* [retval][out] */ BSTR *str);



/* [propget] */ HRESULT STDMETHODCALLTYPE IDAStatics_get_Site_Proxy( 
    IDAStatics * This,
    /* [retval][out] */ IDASite **pSite);



/* [propput] */ HRESULT STDMETHODCALLTYPE IDAStatics_put_Site_Proxy( 
    IDAStatics * This,
    /* [in] */ IDASite *pSite);



/* [propput] */ HRESULT STDMETHODCALLTYPE IDAStatics_put_ClientSite_Proxy( 
    IDAStatics * This,
    /* [in] */ IOleClientSite *pClientSite);



/* [propget] */ HRESULT STDMETHODCALLTYPE IDAStatics_get_ClientSite_Proxy( 
    IDAStatics * This,
    /* [retval][out] */ IOleClientSite **pClientSite);



/* [propput] */ HRESULT STDMETHODCALLTYPE IDAStatics_put_PixelConstructionMode_Proxy( 
    IDAStatics * This,
    /* [in] */ VARIANT_BOOL bMode);



/* [propget] */ HRESULT STDMETHODCALLTYPE IDAStatics_get_PixelConstructionMode_Proxy( 
    IDAStatics * This,
    /* [retval][out] */ VARIANT_BOOL *bMode);



HRESULT STDMETHODCALLTYPE IDAStatics_TriggerEvent_Proxy( 
    IDAStatics * This,
    /* [in] */ IDAEvent *event,
    /* [in] */ IDABehavior *data);



HRESULT STDMETHODCALLTYPE IDAStatics_NewDrawingSurface_Proxy( 
    IDAStatics * This,
    /* [retval][out] */ IDADrawingSurface **pds);



HRESULT STDMETHODCALLTYPE IDAStatics_ImportMovie_Proxy( 
    IDAStatics * This,
    /* [in] */ BSTR url,
    /* [retval][out] */ IDAImportationResult **ppResult);



HRESULT STDMETHODCALLTYPE IDAStatics_ImportMovieAsync_Proxy( 
    IDAStatics * This,
    /* [in] */ BSTR url,
    /* [in] */ IDAImage *pImageStandIn,
    /* [in] */ IDASound *pSoundStandIn,
    /* [retval][out] */ IDAImportationResult **ppResult);



HRESULT STDMETHODCALLTYPE IDAStatics_ImportImage_Proxy( 
    IDAStatics * This,
    /* [in] */ BSTR url,
    /* [retval][out] */ IDAImage **ppImage);



HRESULT STDMETHODCALLTYPE IDAStatics_ImportImageAsync_Proxy( 
    IDAStatics * This,
    /* [in] */ BSTR url,
    /* [in] */ IDAImage *pImageStandIn,
    /* [retval][out] */ IDAImportationResult **ppResult);



HRESULT STDMETHODCALLTYPE IDAStatics_ImportImageColorKey_Proxy( 
    IDAStatics * This,
    /* [in] */ BSTR url,
    /* [in] */ BYTE colorKeyRed,
    /* [in] */ BYTE colorKeyGreen,
    /* [in] */ BYTE colorKeyBlue,
    /* [retval][out] */ IDAImage **ppImage);



HRESULT STDMETHODCALLTYPE IDAStatics_ImportImageAsyncColorKey_Proxy( 
    IDAStatics * This,
    /* [in] */ BSTR url,
    /* [in] */ IDAImage *pImageStandIn,
    /* [in] */ BYTE colorKeyRed,
    /* [in] */ BYTE colorKeyGreen,
    /* [in] */ BYTE colorKeyBlue,
    /* [retval][out] */ IDAImportationResult **ppResult);



HRESULT STDMETHODCALLTYPE IDAStatics_ImportSound_Proxy( 
    IDAStatics * This,
    /* [in] */ BSTR url,
    /* [retval][out] */ IDAImportationResult **ppResult);



HRESULT STDMETHODCALLTYPE IDAStatics_ImportSoundAsync_Proxy( 
    IDAStatics * This,
    /* [in] */ BSTR url,
    /* [in] */ IDASound *pSoundStandIn,
    /* [retval][out] */ IDAImportationResult **ppResult);



HRESULT STDMETHODCALLTYPE IDAStatics_ImportGeometry_Proxy( 
    IDAStatics * This,
    /* [in] */ BSTR url,
    /* [retval][out] */ IDAGeometry **ppGeometry);



HRESULT STDMETHODCALLTYPE IDAStatics_ImportGeometryAsync_Proxy( 
    IDAStatics * This,
    /* [in] */ BSTR url,
    /* [in] */ IDAGeometry *pGeoStandIn,
    /* [retval][out] */ IDAImportationResult **ppResult);



HRESULT STDMETHODCALLTYPE IDAStatics_ImportDirectDrawSurface_Proxy( 
    IDAStatics * This,
    /* [in] */ IUnknown *dds,
    /* [in] */ IDAEvent *updateEvent,
    /* [retval][out] */ IDAImage **ppImage);



HRESULT STDMETHODCALLTYPE IDAStatics_Cond_Proxy( 
    IDAStatics * This,
    /* [in] */ IDABoolean *c,
    /* [in] */ IDABehavior *i,
    /* [in] */ IDABehavior *e,
    /* [retval][out] */ IDABehavior **pCondBvr);



HRESULT STDMETHODCALLTYPE IDAStatics_DAArrayEx_Proxy( 
    IDAStatics * This,
    /* [in] */ LONG s,
    /* [size_is][in] */ IDABehavior *pBvrs[  ],
    /* [retval][out] */ IDAArray **bvr);



HRESULT STDMETHODCALLTYPE IDAStatics_DAArray_Proxy( 
    IDAStatics * This,
    /* [in] */ VARIANT bvrs,
    /* [retval][out] */ IDAArray **bvr);



HRESULT STDMETHODCALLTYPE IDAStatics_DATupleEx_Proxy( 
    IDAStatics * This,
    /* [in] */ LONG s,
    /* [size_is][in] */ IDABehavior *pBvrs[  ],
    /* [retval][out] */ IDATuple **bvr);



HRESULT STDMETHODCALLTYPE IDAStatics_DATuple_Proxy( 
    IDAStatics * This,
    /* [in] */ VARIANT bvrs,
    /* [retval][out] */ IDATuple **bvr);



HRESULT STDMETHODCALLTYPE IDAStatics_ModifiableBehavior_Proxy( 
    IDAStatics * This,
    /* [in] */ IDABehavior *orig,
    /* [retval][out] */ IDABehavior **bvr);



HRESULT STDMETHODCALLTYPE IDAStatics_UninitializedArray_Proxy( 
    IDAStatics * This,
    /* [in] */ IDAArray *typeTmp,
    /* [retval][out] */ IDAArray **bvr);



HRESULT STDMETHODCALLTYPE IDAStatics_UninitializedTuple_Proxy( 
    IDAStatics * This,
    /* [in] */ IDATuple *typeTmp,
    /* [retval][out] */ IDATuple **bvr);



HRESULT STDMETHODCALLTYPE IDAStatics_NumberBSplineEx_Proxy( 
    IDAStatics * This,
    /* [in] */ int degree,
    /* [in] */ LONG numKnots,
    /* [size_is][in] */ IDANumber *knots[  ],
    /* [in] */ LONG numPts,
    /* [size_is][in] */ IDANumber *ctrlPts[  ],
    /* [in] */ LONG numWts,
    /* [size_is][in] */ IDANumber *weights[  ],
    /* [in] */ IDANumber *evaluator,
    /* [retval][out] */ IDANumber **bvr);



HRESULT STDMETHODCALLTYPE IDAStatics_NumberBSpline_Proxy( 
    IDAStatics * This,
    /* [in] */ int degree,
    /* [in] */ VARIANT knots,
    /* [in] */ VARIANT CtrlPts,
    /* [in] */ VARIANT weights,
    /* [in] */ IDANumber *evaluator,
    /* [retval][out] */ IDANumber **bvr);



HRESULT STDMETHODCALLTYPE IDAStatics_Point2BSplineEx_Proxy( 
    IDAStatics * This,
    /* [in] */ int degree,
    /* [in] */ LONG numKnots,
    /* [size_is][in] */ IDANumber *knots[  ],
    /* [in] */ LONG numPts,
    /* [size_is][in] */ IDAPoint2 *ctrlPts[  ],
    /* [in] */ LONG numWts,
    /* [size_is][in] */ IDANumber *weights[  ],
    /* [in] */ IDANumber *evaluator,
    /* [retval][out] */ IDAPoint2 **bvr);



HRESULT STDMETHODCALLTYPE IDAStatics_Point2BSpline_Proxy( 
    IDAStatics * This,
    /* [in] */ int degree,
    /* [in] */ VARIANT knots,
    /* [in] */ VARIANT CtrlPts,
    /* [in] */ VARIANT weights,
    /* [in] */ IDANumber *evaluator,
    /* [retval][out] */ IDAPoint2 **bvr);



HRESULT STDMETHODCALLTYPE IDAStatics_Point3BSplineEx_Proxy( 
    IDAStatics * This,
    /* [in] */ int degree,
    /* [in] */ LONG numKnots,
    /* [size_is][in] */ IDANumber *knots[  ],
    /* [in] */ LONG numPts,
    /* [size_is][in] */ IDAPoint3 *ctrlPts[  ],
    /* [in] */ LONG numWts,
    /* [size_is][in] */ IDANumber *weights[  ],
    /* [in] */ IDANumber *evaluator,
    /* [retval][out] */ IDAPoint3 **bvr);



HRESULT STDMETHODCALLTYPE IDAStatics_Point3BSpline_Proxy( 
    IDAStatics * This,
    /* [in] */ int degree,
    /* [in] */ VARIANT knots,
    /* [in] */ VARIANT CtrlPts,
    /* [in] */ VARIANT weights,
    /* [in] */ IDANumber *evaluator,
    /* [retval][out] */ IDAPoint3 **bvr);



HRESULT STDMETHODCALLTYPE IDAStatics_Vector2BSplineEx_Proxy( 
    IDAStatics * This,
    /* [in] */ int degree,
    /* [in] */ LONG numKnots,
    /* [size_is][in] */ IDANumber *knots[  ],
    /* [in] */ LONG numPts,
    /* [size_is][in] */ IDAVector2 *ctrlPts[  ],
    /* [in] */ LONG numWts,
    /* [size_is][in] */ IDANumber *weights[  ],
    /* [in] */ IDANumber *evaluator,
    /* [retval][out] */ IDAVector2 **bvr);



HRESULT STDMETHODCALLTYPE IDAStatics_Vector2BSpline_Proxy( 
    IDAStatics * This,
    /* [in] */ int degree,
    /* [in] */ VARIANT knots,
    /* [in] */ VARIANT CtrlPts,
    /* [in] */ VARIANT weights,
    /* [in] */ IDANumber *evaluator,
    /* [retval][out] */ IDAVector2 **bvr);



HRESULT STDMETHODCALLTYPE IDAStatics_Vector3BSplineEx_Proxy( 
    IDAStatics * This,
    /* [in] */ int degree,
    /* [in] */ LONG numKnots,
    /* [size_is][in] */ IDANumber *knots[  ],
    /* [in] */ LONG numPts,
    /* [size_is][in] */ IDAVector3 *ctrlPts[  ],
    /* [in] */ LONG numWts,
    /* [size_is][in] */ IDANumber *weights[  ],
    /* [in] */ IDANumber *evaluator,
    /* [retval][out] */ IDAVector3 **bvr);



HRESULT STDMETHODCALLTYPE IDAStatics_Vector3BSpline_Proxy( 
    IDAStatics * This,
    /* [in] */ int degree,
    /* [in] */ VARIANT knots,
    /* [in] */ VARIANT CtrlPts,
    /* [in] */ VARIANT weights,
    /* [in] */ IDANumber *evaluator,
    /* [retval][out] */ IDAVector3 **bvr);



HRESULT STDMETHODCALLTYPE IDAStatics_Pow_Proxy( 
    IDAStatics * This,
    /* [in] */ IDANumber *a_0,
    /* [in] */ IDANumber *b_1,
    /* [retval][out] */ IDANumber **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_Abs_Proxy( 
    IDAStatics * This,
    /* [in] */ IDANumber *a_0,
    /* [retval][out] */ IDANumber **ret_1);



HRESULT STDMETHODCALLTYPE IDAStatics_Sqrt_Proxy( 
    IDAStatics * This,
    /* [in] */ IDANumber *a_0,
    /* [retval][out] */ IDANumber **ret_1);



HRESULT STDMETHODCALLTYPE IDAStatics_Floor_Proxy( 
    IDAStatics * This,
    /* [in] */ IDANumber *a_0,
    /* [retval][out] */ IDANumber **ret_1);



HRESULT STDMETHODCALLTYPE IDAStatics_Round_Proxy( 
    IDAStatics * This,
    /* [in] */ IDANumber *a_0,
    /* [retval][out] */ IDANumber **ret_1);



HRESULT STDMETHODCALLTYPE IDAStatics_Ceiling_Proxy( 
    IDAStatics * This,
    /* [in] */ IDANumber *a_0,
    /* [retval][out] */ IDANumber **ret_1);



HRESULT STDMETHODCALLTYPE IDAStatics_Asin_Proxy( 
    IDAStatics * This,
    /* [in] */ IDANumber *a_0,
    /* [retval][out] */ IDANumber **ret_1);



HRESULT STDMETHODCALLTYPE IDAStatics_Acos_Proxy( 
    IDAStatics * This,
    /* [in] */ IDANumber *a_0,
    /* [retval][out] */ IDANumber **ret_1);



HRESULT STDMETHODCALLTYPE IDAStatics_Atan_Proxy( 
    IDAStatics * This,
    /* [in] */ IDANumber *a_0,
    /* [retval][out] */ IDANumber **ret_1);



HRESULT STDMETHODCALLTYPE IDAStatics_Sin_Proxy( 
    IDAStatics * This,
    /* [in] */ IDANumber *a_0,
    /* [retval][out] */ IDANumber **ret_1);



HRESULT STDMETHODCALLTYPE IDAStatics_Cos_Proxy( 
    IDAStatics * This,
    /* [in] */ IDANumber *a_0,
    /* [retval][out] */ IDANumber **ret_1);



HRESULT STDMETHODCALLTYPE IDAStatics_Tan_Proxy( 
    IDAStatics * This,
    /* [in] */ IDANumber *a_0,
    /* [retval][out] */ IDANumber **ret_1);



HRESULT STDMETHODCALLTYPE IDAStatics_Exp_Proxy( 
    IDAStatics * This,
    /* [in] */ IDANumber *a_0,
    /* [retval][out] */ IDANumber **ret_1);



HRESULT STDMETHODCALLTYPE IDAStatics_Ln_Proxy( 
    IDAStatics * This,
    /* [in] */ IDANumber *a_0,
    /* [retval][out] */ IDANumber **ret_1);



HRESULT STDMETHODCALLTYPE IDAStatics_Log10_Proxy( 
    IDAStatics * This,
    /* [in] */ IDANumber *a_0,
    /* [retval][out] */ IDANumber **ret_1);



HRESULT STDMETHODCALLTYPE IDAStatics_ToDegrees_Proxy( 
    IDAStatics * This,
    /* [in] */ IDANumber *a_0,
    /* [retval][out] */ IDANumber **ret_1);



HRESULT STDMETHODCALLTYPE IDAStatics_ToRadians_Proxy( 
    IDAStatics * This,
    /* [in] */ IDANumber *a_0,
    /* [retval][out] */ IDANumber **ret_1);



HRESULT STDMETHODCALLTYPE IDAStatics_Mod_Proxy( 
    IDAStatics * This,
    /* [in] */ IDANumber *a_0,
    /* [in] */ IDANumber *b_1,
    /* [retval][out] */ IDANumber **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_Atan2_Proxy( 
    IDAStatics * This,
    /* [in] */ IDANumber *a_0,
    /* [in] */ IDANumber *b_1,
    /* [retval][out] */ IDANumber **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_Add_Proxy( 
    IDAStatics * This,
    /* [in] */ IDANumber *a_0,
    /* [in] */ IDANumber *b_1,
    /* [retval][out] */ IDANumber **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_Sub_Proxy( 
    IDAStatics * This,
    /* [in] */ IDANumber *a_0,
    /* [in] */ IDANumber *b_1,
    /* [retval][out] */ IDANumber **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_Mul_Proxy( 
    IDAStatics * This,
    /* [in] */ IDANumber *a_0,
    /* [in] */ IDANumber *b_1,
    /* [retval][out] */ IDANumber **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_Div_Proxy( 
    IDAStatics * This,
    /* [in] */ IDANumber *a_0,
    /* [in] */ IDANumber *b_1,
    /* [retval][out] */ IDANumber **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_LT_Proxy( 
    IDAStatics * This,
    /* [in] */ IDANumber *a_0,
    /* [in] */ IDANumber *b_1,
    /* [retval][out] */ IDABoolean **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_LTE_Proxy( 
    IDAStatics * This,
    /* [in] */ IDANumber *a_0,
    /* [in] */ IDANumber *b_1,
    /* [retval][out] */ IDABoolean **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_GT_Proxy( 
    IDAStatics * This,
    /* [in] */ IDANumber *a_0,
    /* [in] */ IDANumber *b_1,
    /* [retval][out] */ IDABoolean **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_GTE_Proxy( 
    IDAStatics * This,
    /* [in] */ IDANumber *a_0,
    /* [in] */ IDANumber *b_1,
    /* [retval][out] */ IDABoolean **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_EQ_Proxy( 
    IDAStatics * This,
    /* [in] */ IDANumber *a_0,
    /* [in] */ IDANumber *b_1,
    /* [retval][out] */ IDABoolean **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_NE_Proxy( 
    IDAStatics * This,
    /* [in] */ IDANumber *a_0,
    /* [in] */ IDANumber *b_1,
    /* [retval][out] */ IDABoolean **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_Neg_Proxy( 
    IDAStatics * This,
    /* [in] */ IDANumber *a_0,
    /* [retval][out] */ IDANumber **ret_1);



HRESULT STDMETHODCALLTYPE IDAStatics_InterpolateAnim_Proxy( 
    IDAStatics * This,
    /* [in] */ IDANumber *from_0,
    /* [in] */ IDANumber *to_1,
    /* [in] */ IDANumber *duration_2,
    /* [retval][out] */ IDANumber **ret_3);



HRESULT STDMETHODCALLTYPE IDAStatics_Interpolate_Proxy( 
    IDAStatics * This,
    /* [in] */ double from_0,
    /* [in] */ double to_1,
    /* [in] */ double duration_2,
    /* [retval][out] */ IDANumber **ret_3);



HRESULT STDMETHODCALLTYPE IDAStatics_SlowInSlowOutAnim_Proxy( 
    IDAStatics * This,
    /* [in] */ IDANumber *from_0,
    /* [in] */ IDANumber *to_1,
    /* [in] */ IDANumber *duration_2,
    /* [in] */ IDANumber *sharpness_3,
    /* [retval][out] */ IDANumber **ret_4);



HRESULT STDMETHODCALLTYPE IDAStatics_SlowInSlowOut_Proxy( 
    IDAStatics * This,
    /* [in] */ double from_0,
    /* [in] */ double to_1,
    /* [in] */ double duration_2,
    /* [in] */ double sharpness_3,
    /* [retval][out] */ IDANumber **ret_4);



HRESULT STDMETHODCALLTYPE IDAStatics_SoundSource_Proxy( 
    IDAStatics * This,
    /* [in] */ IDASound *snd_0,
    /* [retval][out] */ IDAGeometry **ret_1);



HRESULT STDMETHODCALLTYPE IDAStatics_Mix_Proxy( 
    IDAStatics * This,
    /* [in] */ IDASound *left_0,
    /* [in] */ IDASound *right_1,
    /* [retval][out] */ IDASound **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_And_Proxy( 
    IDAStatics * This,
    /* [in] */ IDABoolean *a_0,
    /* [in] */ IDABoolean *b_1,
    /* [retval][out] */ IDABoolean **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_Or_Proxy( 
    IDAStatics * This,
    /* [in] */ IDABoolean *a_0,
    /* [in] */ IDABoolean *b_1,
    /* [retval][out] */ IDABoolean **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_Not_Proxy( 
    IDAStatics * This,
    /* [in] */ IDABoolean *a_0,
    /* [retval][out] */ IDABoolean **ret_1);



HRESULT STDMETHODCALLTYPE IDAStatics_Integral_Proxy( 
    IDAStatics * This,
    /* [in] */ IDANumber *b_0,
    /* [retval][out] */ IDANumber **ret_1);



HRESULT STDMETHODCALLTYPE IDAStatics_Derivative_Proxy( 
    IDAStatics * This,
    /* [in] */ IDANumber *b_0,
    /* [retval][out] */ IDANumber **ret_1);



HRESULT STDMETHODCALLTYPE IDAStatics_IntegralVector2_Proxy( 
    IDAStatics * This,
    /* [in] */ IDAVector2 *v_0,
    /* [retval][out] */ IDAVector2 **ret_1);



HRESULT STDMETHODCALLTYPE IDAStatics_IntegralVector3_Proxy( 
    IDAStatics * This,
    /* [in] */ IDAVector3 *v_0,
    /* [retval][out] */ IDAVector3 **ret_1);



HRESULT STDMETHODCALLTYPE IDAStatics_DerivativeVector2_Proxy( 
    IDAStatics * This,
    /* [in] */ IDAVector2 *v_0,
    /* [retval][out] */ IDAVector2 **ret_1);



HRESULT STDMETHODCALLTYPE IDAStatics_DerivativeVector3_Proxy( 
    IDAStatics * This,
    /* [in] */ IDAVector3 *v_0,
    /* [retval][out] */ IDAVector3 **ret_1);



HRESULT STDMETHODCALLTYPE IDAStatics_DerivativePoint2_Proxy( 
    IDAStatics * This,
    /* [in] */ IDAPoint2 *v_0,
    /* [retval][out] */ IDAVector2 **ret_1);



HRESULT STDMETHODCALLTYPE IDAStatics_DerivativePoint3_Proxy( 
    IDAStatics * This,
    /* [in] */ IDAPoint3 *v_0,
    /* [retval][out] */ IDAVector3 **ret_1);



HRESULT STDMETHODCALLTYPE IDAStatics_KeyState_Proxy( 
    IDAStatics * This,
    /* [in] */ IDANumber *n_0,
    /* [retval][out] */ IDABoolean **ret_1);



HRESULT STDMETHODCALLTYPE IDAStatics_KeyUp_Proxy( 
    IDAStatics * This,
    /* [in] */ LONG arg_0,
    /* [retval][out] */ IDAEvent **ret_1);



HRESULT STDMETHODCALLTYPE IDAStatics_KeyDown_Proxy( 
    IDAStatics * This,
    /* [in] */ LONG arg_0,
    /* [retval][out] */ IDAEvent **ret_1);



HRESULT STDMETHODCALLTYPE IDAStatics_DANumber_Proxy( 
    IDAStatics * This,
    /* [in] */ double num_0,
    /* [retval][out] */ IDANumber **ret_1);



HRESULT STDMETHODCALLTYPE IDAStatics_DAString_Proxy( 
    IDAStatics * This,
    /* [in] */ BSTR str_0,
    /* [retval][out] */ IDAString **ret_1);



HRESULT STDMETHODCALLTYPE IDAStatics_DABoolean_Proxy( 
    IDAStatics * This,
    /* [in] */ VARIANT_BOOL num_0,
    /* [retval][out] */ IDABoolean **ret_1);



HRESULT STDMETHODCALLTYPE IDAStatics_SeededRandom_Proxy( 
    IDAStatics * This,
    /* [in] */ double arg_0,
    /* [retval][out] */ IDANumber **ret_1);



/* [propget] */ HRESULT STDMETHODCALLTYPE IDAStatics_get_MousePosition_Proxy( 
    IDAStatics * This,
    /* [retval][out] */ IDAPoint2 **ret_0);



/* [propget] */ HRESULT STDMETHODCALLTYPE IDAStatics_get_LeftButtonState_Proxy( 
    IDAStatics * This,
    /* [retval][out] */ IDABoolean **ret_0);



/* [propget] */ HRESULT STDMETHODCALLTYPE IDAStatics_get_RightButtonState_Proxy( 
    IDAStatics * This,
    /* [retval][out] */ IDABoolean **ret_0);



/* [propget] */ HRESULT STDMETHODCALLTYPE IDAStatics_get_DATrue_Proxy( 
    IDAStatics * This,
    /* [retval][out] */ IDABoolean **ret_0);



/* [propget] */ HRESULT STDMETHODCALLTYPE IDAStatics_get_DAFalse_Proxy( 
    IDAStatics * This,
    /* [retval][out] */ IDABoolean **ret_0);



/* [propget] */ HRESULT STDMETHODCALLTYPE IDAStatics_get_LocalTime_Proxy( 
    IDAStatics * This,
    /* [retval][out] */ IDANumber **ret_0);



/* [propget] */ HRESULT STDMETHODCALLTYPE IDAStatics_get_GlobalTime_Proxy( 
    IDAStatics * This,
    /* [retval][out] */ IDANumber **ret_0);



/* [propget] */ HRESULT STDMETHODCALLTYPE IDAStatics_get_Pixel_Proxy( 
    IDAStatics * This,
    /* [retval][out] */ IDANumber **ret_0);



HRESULT STDMETHODCALLTYPE IDAStatics_UserData_Proxy( 
    IDAStatics * This,
    /* [in] */ IUnknown *data_0,
    /* [retval][out] */ IDAUserData **ret_1);



HRESULT STDMETHODCALLTYPE IDAStatics_UntilNotify_Proxy( 
    IDAStatics * This,
    /* [in] */ IDABehavior *b0_0,
    /* [in] */ IDAEvent *event_1,
    /* [in] */ IDAUntilNotifier *notifier_2,
    /* [retval][out] */ IDABehavior **ret_3);



HRESULT STDMETHODCALLTYPE IDAStatics_Until_Proxy( 
    IDAStatics * This,
    /* [in] */ IDABehavior *b0_0,
    /* [in] */ IDAEvent *event_1,
    /* [in] */ IDABehavior *b1_2,
    /* [retval][out] */ IDABehavior **ret_3);



HRESULT STDMETHODCALLTYPE IDAStatics_UntilEx_Proxy( 
    IDAStatics * This,
    /* [in] */ IDABehavior *b0_0,
    /* [in] */ IDAEvent *event_1,
    /* [retval][out] */ IDABehavior **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_Sequence_Proxy( 
    IDAStatics * This,
    /* [in] */ IDABehavior *s1_0,
    /* [in] */ IDABehavior *s2_1,
    /* [retval][out] */ IDABehavior **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_FollowPath_Proxy( 
    IDAStatics * This,
    /* [in] */ IDAPath2 *path_0,
    /* [in] */ double duration_1,
    /* [retval][out] */ IDATransform2 **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_FollowPathAngle_Proxy( 
    IDAStatics * This,
    /* [in] */ IDAPath2 *path_0,
    /* [in] */ double duration_1,
    /* [retval][out] */ IDATransform2 **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_FollowPathAngleUpright_Proxy( 
    IDAStatics * This,
    /* [in] */ IDAPath2 *path_0,
    /* [in] */ double duration_1,
    /* [retval][out] */ IDATransform2 **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_FollowPathEval_Proxy( 
    IDAStatics * This,
    /* [in] */ IDAPath2 *path_0,
    /* [in] */ IDANumber *eval_1,
    /* [retval][out] */ IDATransform2 **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_FollowPathAngleEval_Proxy( 
    IDAStatics * This,
    /* [in] */ IDAPath2 *path_0,
    /* [in] */ IDANumber *eval_1,
    /* [retval][out] */ IDATransform2 **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_FollowPathAngleUprightEval_Proxy( 
    IDAStatics * This,
    /* [in] */ IDAPath2 *path_0,
    /* [in] */ IDANumber *eval_1,
    /* [retval][out] */ IDATransform2 **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_FollowPathAnim_Proxy( 
    IDAStatics * This,
    /* [in] */ IDAPath2 *obsoleted1_0,
    /* [in] */ IDANumber *obsoleted2_1,
    /* [retval][out] */ IDATransform2 **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_FollowPathAngleAnim_Proxy( 
    IDAStatics * This,
    /* [in] */ IDAPath2 *obsoleted1_0,
    /* [in] */ IDANumber *obsoleted2_1,
    /* [retval][out] */ IDATransform2 **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_FollowPathAngleUprightAnim_Proxy( 
    IDAStatics * This,
    /* [in] */ IDAPath2 *obsoleted1_0,
    /* [in] */ IDANumber *obsoleted2_1,
    /* [retval][out] */ IDATransform2 **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_ConcatString_Proxy( 
    IDAStatics * This,
    /* [in] */ IDAString *s1_0,
    /* [in] */ IDAString *s2_1,
    /* [retval][out] */ IDAString **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_PerspectiveCamera_Proxy( 
    IDAStatics * This,
    /* [in] */ double focalDist_0,
    /* [in] */ double nearClip_1,
    /* [retval][out] */ IDACamera **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_PerspectiveCameraAnim_Proxy( 
    IDAStatics * This,
    /* [in] */ IDANumber *focalDist_0,
    /* [in] */ IDANumber *nearClip_1,
    /* [retval][out] */ IDACamera **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_ParallelCamera_Proxy( 
    IDAStatics * This,
    /* [in] */ double nearClip_0,
    /* [retval][out] */ IDACamera **ret_1);



HRESULT STDMETHODCALLTYPE IDAStatics_ParallelCameraAnim_Proxy( 
    IDAStatics * This,
    /* [in] */ IDANumber *nearClip_0,
    /* [retval][out] */ IDACamera **ret_1);



HRESULT STDMETHODCALLTYPE IDAStatics_ColorRgbAnim_Proxy( 
    IDAStatics * This,
    /* [in] */ IDANumber *red_0,
    /* [in] */ IDANumber *green_1,
    /* [in] */ IDANumber *blue_2,
    /* [retval][out] */ IDAColor **ret_3);



HRESULT STDMETHODCALLTYPE IDAStatics_ColorRgb_Proxy( 
    IDAStatics * This,
    /* [in] */ double red_0,
    /* [in] */ double green_1,
    /* [in] */ double blue_2,
    /* [retval][out] */ IDAColor **ret_3);



HRESULT STDMETHODCALLTYPE IDAStatics_ColorRgb255_Proxy( 
    IDAStatics * This,
    /* [in] */ short red_0,
    /* [in] */ short green_1,
    /* [in] */ short blue_2,
    /* [retval][out] */ IDAColor **ret_3);



HRESULT STDMETHODCALLTYPE IDAStatics_ColorHsl_Proxy( 
    IDAStatics * This,
    /* [in] */ double hue_0,
    /* [in] */ double saturation_1,
    /* [in] */ double lum_2,
    /* [retval][out] */ IDAColor **ret_3);



HRESULT STDMETHODCALLTYPE IDAStatics_ColorHslAnim_Proxy( 
    IDAStatics * This,
    /* [in] */ IDANumber *hue_0,
    /* [in] */ IDANumber *saturation_1,
    /* [in] */ IDANumber *lum_2,
    /* [retval][out] */ IDAColor **ret_3);



/* [propget] */ HRESULT STDMETHODCALLTYPE IDAStatics_get_Red_Proxy( 
    IDAStatics * This,
    /* [retval][out] */ IDAColor **ret_0);



/* [propget] */ HRESULT STDMETHODCALLTYPE IDAStatics_get_Green_Proxy( 
    IDAStatics * This,
    /* [retval][out] */ IDAColor **ret_0);



/* [propget] */ HRESULT STDMETHODCALLTYPE IDAStatics_get_Blue_Proxy( 
    IDAStatics * This,
    /* [retval][out] */ IDAColor **ret_0);



/* [propget] */ HRESULT STDMETHODCALLTYPE IDAStatics_get_Cyan_Proxy( 
    IDAStatics * This,
    /* [retval][out] */ IDAColor **ret_0);



/* [propget] */ HRESULT STDMETHODCALLTYPE IDAStatics_get_Magenta_Proxy( 
    IDAStatics * This,
    /* [retval][out] */ IDAColor **ret_0);



/* [propget] */ HRESULT STDMETHODCALLTYPE IDAStatics_get_Yellow_Proxy( 
    IDAStatics * This,
    /* [retval][out] */ IDAColor **ret_0);



/* [propget] */ HRESULT STDMETHODCALLTYPE IDAStatics_get_Black_Proxy( 
    IDAStatics * This,
    /* [retval][out] */ IDAColor **ret_0);



/* [propget] */ HRESULT STDMETHODCALLTYPE IDAStatics_get_White_Proxy( 
    IDAStatics * This,
    /* [retval][out] */ IDAColor **ret_0);



/* [propget] */ HRESULT STDMETHODCALLTYPE IDAStatics_get_Aqua_Proxy( 
    IDAStatics * This,
    /* [retval][out] */ IDAColor **ret_0);



/* [propget] */ HRESULT STDMETHODCALLTYPE IDAStatics_get_Fuchsia_Proxy( 
    IDAStatics * This,
    /* [retval][out] */ IDAColor **ret_0);



/* [propget] */ HRESULT STDMETHODCALLTYPE IDAStatics_get_Gray_Proxy( 
    IDAStatics * This,
    /* [retval][out] */ IDAColor **ret_0);



/* [propget] */ HRESULT STDMETHODCALLTYPE IDAStatics_get_Lime_Proxy( 
    IDAStatics * This,
    /* [retval][out] */ IDAColor **ret_0);



/* [propget] */ HRESULT STDMETHODCALLTYPE IDAStatics_get_Maroon_Proxy( 
    IDAStatics * This,
    /* [retval][out] */ IDAColor **ret_0);



/* [propget] */ HRESULT STDMETHODCALLTYPE IDAStatics_get_Navy_Proxy( 
    IDAStatics * This,
    /* [retval][out] */ IDAColor **ret_0);



/* [propget] */ HRESULT STDMETHODCALLTYPE IDAStatics_get_Olive_Proxy( 
    IDAStatics * This,
    /* [retval][out] */ IDAColor **ret_0);



/* [propget] */ HRESULT STDMETHODCALLTYPE IDAStatics_get_Purple_Proxy( 
    IDAStatics * This,
    /* [retval][out] */ IDAColor **ret_0);



/* [propget] */ HRESULT STDMETHODCALLTYPE IDAStatics_get_Silver_Proxy( 
    IDAStatics * This,
    /* [retval][out] */ IDAColor **ret_0);



/* [propget] */ HRESULT STDMETHODCALLTYPE IDAStatics_get_Teal_Proxy( 
    IDAStatics * This,
    /* [retval][out] */ IDAColor **ret_0);



HRESULT STDMETHODCALLTYPE IDAStatics_Predicate_Proxy( 
    IDAStatics * This,
    /* [in] */ IDABoolean *b_0,
    /* [retval][out] */ IDAEvent **ret_1);



HRESULT STDMETHODCALLTYPE IDAStatics_NotEvent_Proxy( 
    IDAStatics * This,
    /* [in] */ IDAEvent *event_0,
    /* [retval][out] */ IDAEvent **ret_1);



HRESULT STDMETHODCALLTYPE IDAStatics_AndEvent_Proxy( 
    IDAStatics * This,
    /* [in] */ IDAEvent *e1_0,
    /* [in] */ IDAEvent *e2_1,
    /* [retval][out] */ IDAEvent **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_OrEvent_Proxy( 
    IDAStatics * This,
    /* [in] */ IDAEvent *e1_0,
    /* [in] */ IDAEvent *e2_1,
    /* [retval][out] */ IDAEvent **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_ThenEvent_Proxy( 
    IDAStatics * This,
    /* [in] */ IDAEvent *e1_0,
    /* [in] */ IDAEvent *e2_1,
    /* [retval][out] */ IDAEvent **ret_2);



/* [propget] */ HRESULT STDMETHODCALLTYPE IDAStatics_get_LeftButtonDown_Proxy( 
    IDAStatics * This,
    /* [retval][out] */ IDAEvent **ret_0);



/* [propget] */ HRESULT STDMETHODCALLTYPE IDAStatics_get_LeftButtonUp_Proxy( 
    IDAStatics * This,
    /* [retval][out] */ IDAEvent **ret_0);



/* [propget] */ HRESULT STDMETHODCALLTYPE IDAStatics_get_RightButtonDown_Proxy( 
    IDAStatics * This,
    /* [retval][out] */ IDAEvent **ret_0);



/* [propget] */ HRESULT STDMETHODCALLTYPE IDAStatics_get_RightButtonUp_Proxy( 
    IDAStatics * This,
    /* [retval][out] */ IDAEvent **ret_0);



/* [propget] */ HRESULT STDMETHODCALLTYPE IDAStatics_get_Always_Proxy( 
    IDAStatics * This,
    /* [retval][out] */ IDAEvent **ret_0);



/* [propget] */ HRESULT STDMETHODCALLTYPE IDAStatics_get_Never_Proxy( 
    IDAStatics * This,
    /* [retval][out] */ IDAEvent **ret_0);



HRESULT STDMETHODCALLTYPE IDAStatics_TimerAnim_Proxy( 
    IDAStatics * This,
    /* [in] */ IDANumber *n_0,
    /* [retval][out] */ IDAEvent **ret_1);



HRESULT STDMETHODCALLTYPE IDAStatics_Timer_Proxy( 
    IDAStatics * This,
    /* [in] */ double n_0,
    /* [retval][out] */ IDAEvent **ret_1);



HRESULT STDMETHODCALLTYPE IDAStatics_AppTriggeredEvent_Proxy( 
    IDAStatics * This,
    /* [retval][out] */ IDAEvent **ret_0);



HRESULT STDMETHODCALLTYPE IDAStatics_ScriptCallback_Proxy( 
    IDAStatics * This,
    /* [in] */ BSTR obsolete1_0,
    /* [in] */ IDAEvent *obsolete2_1,
    /* [in] */ BSTR obsolete3_2,
    /* [retval][out] */ IDAEvent **ret_3);



/* [propget] */ HRESULT STDMETHODCALLTYPE IDAStatics_get_EmptyGeometry_Proxy( 
    IDAStatics * This,
    /* [retval][out] */ IDAGeometry **ret_0);



HRESULT STDMETHODCALLTYPE IDAStatics_UnionGeometry_Proxy( 
    IDAStatics * This,
    /* [in] */ IDAGeometry *g1_0,
    /* [in] */ IDAGeometry *g2_1,
    /* [retval][out] */ IDAGeometry **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_UnionGeometryArrayEx_Proxy( 
    IDAStatics * This,
    /* [in] */ LONG imgs_0size,
    /* [size_is][in] */ IDAGeometry *imgs_0[  ],
    /* [retval][out] */ IDAGeometry **ret_1);



HRESULT STDMETHODCALLTYPE IDAStatics_UnionGeometryArray_Proxy( 
    IDAStatics * This,
    /* [in] */ VARIANT imgs_0,
    /* [retval][out] */ IDAGeometry **ret_1);



/* [propget] */ HRESULT STDMETHODCALLTYPE IDAStatics_get_EmptyImage_Proxy( 
    IDAStatics * This,
    /* [retval][out] */ IDAImage **ret_0);



/* [propget] */ HRESULT STDMETHODCALLTYPE IDAStatics_get_DetectableEmptyImage_Proxy( 
    IDAStatics * This,
    /* [retval][out] */ IDAImage **ret_0);



HRESULT STDMETHODCALLTYPE IDAStatics_SolidColorImage_Proxy( 
    IDAStatics * This,
    /* [in] */ IDAColor *col_0,
    /* [retval][out] */ IDAImage **ret_1);



HRESULT STDMETHODCALLTYPE IDAStatics_GradientPolygonEx_Proxy( 
    IDAStatics * This,
    /* [in] */ LONG points_0size,
    /* [size_is][in] */ IDAPoint2 *points_0[  ],
    /* [in] */ LONG colors_1size,
    /* [size_is][in] */ IDAColor *colors_1[  ],
    /* [retval][out] */ IDAImage **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_GradientPolygon_Proxy( 
    IDAStatics * This,
    /* [in] */ VARIANT points_0,
    /* [in] */ VARIANT colors_1,
    /* [retval][out] */ IDAImage **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_RadialGradientPolygonEx_Proxy( 
    IDAStatics * This,
    /* [in] */ IDAColor *inner_0,
    /* [in] */ IDAColor *outer_1,
    /* [in] */ LONG points_2size,
    /* [size_is][in] */ IDAPoint2 *points_2[  ],
    /* [in] */ double fallOff_3,
    /* [retval][out] */ IDAImage **ret_4);



HRESULT STDMETHODCALLTYPE IDAStatics_RadialGradientPolygon_Proxy( 
    IDAStatics * This,
    /* [in] */ IDAColor *inner_0,
    /* [in] */ IDAColor *outer_1,
    /* [in] */ VARIANT points_2,
    /* [in] */ double fallOff_3,
    /* [retval][out] */ IDAImage **ret_4);



HRESULT STDMETHODCALLTYPE IDAStatics_RadialGradientPolygonAnimEx_Proxy( 
    IDAStatics * This,
    /* [in] */ IDAColor *inner_0,
    /* [in] */ IDAColor *outer_1,
    /* [in] */ LONG points_2size,
    /* [size_is][in] */ IDAPoint2 *points_2[  ],
    /* [in] */ IDANumber *fallOff_3,
    /* [retval][out] */ IDAImage **ret_4);



HRESULT STDMETHODCALLTYPE IDAStatics_RadialGradientPolygonAnim_Proxy( 
    IDAStatics * This,
    /* [in] */ IDAColor *inner_0,
    /* [in] */ IDAColor *outer_1,
    /* [in] */ VARIANT points_2,
    /* [in] */ IDANumber *fallOff_3,
    /* [retval][out] */ IDAImage **ret_4);



HRESULT STDMETHODCALLTYPE IDAStatics_GradientSquare_Proxy( 
    IDAStatics * This,
    /* [in] */ IDAColor *lowerLeft_0,
    /* [in] */ IDAColor *upperLeft_1,
    /* [in] */ IDAColor *upperRight_2,
    /* [in] */ IDAColor *lowerRight_3,
    /* [retval][out] */ IDAImage **ret_4);



HRESULT STDMETHODCALLTYPE IDAStatics_RadialGradientSquare_Proxy( 
    IDAStatics * This,
    /* [in] */ IDAColor *inner_0,
    /* [in] */ IDAColor *outer_1,
    /* [in] */ double fallOff_2,
    /* [retval][out] */ IDAImage **ret_3);



HRESULT STDMETHODCALLTYPE IDAStatics_RadialGradientSquareAnim_Proxy( 
    IDAStatics * This,
    /* [in] */ IDAColor *inner_0,
    /* [in] */ IDAColor *outer_1,
    /* [in] */ IDANumber *fallOff_2,
    /* [retval][out] */ IDAImage **ret_3);



HRESULT STDMETHODCALLTYPE IDAStatics_RadialGradientRegularPoly_Proxy( 
    IDAStatics * This,
    /* [in] */ IDAColor *inner_0,
    /* [in] */ IDAColor *outer_1,
    /* [in] */ double numEdges_2,
    /* [in] */ double fallOff_3,
    /* [retval][out] */ IDAImage **ret_4);



HRESULT STDMETHODCALLTYPE IDAStatics_RadialGradientRegularPolyAnim_Proxy( 
    IDAStatics * This,
    /* [in] */ IDAColor *inner_0,
    /* [in] */ IDAColor *outer_1,
    /* [in] */ IDANumber *numEdges_2,
    /* [in] */ IDANumber *fallOff_3,
    /* [retval][out] */ IDAImage **ret_4);



HRESULT STDMETHODCALLTYPE IDAStatics_GradientHorizontal_Proxy( 
    IDAStatics * This,
    /* [in] */ IDAColor *start_0,
    /* [in] */ IDAColor *stop_1,
    /* [in] */ double fallOff_2,
    /* [retval][out] */ IDAImage **ret_3);



HRESULT STDMETHODCALLTYPE IDAStatics_GradientHorizontalAnim_Proxy( 
    IDAStatics * This,
    /* [in] */ IDAColor *start_0,
    /* [in] */ IDAColor *stop_1,
    /* [in] */ IDANumber *fallOff_2,
    /* [retval][out] */ IDAImage **ret_3);



HRESULT STDMETHODCALLTYPE IDAStatics_HatchHorizontal_Proxy( 
    IDAStatics * This,
    /* [in] */ IDAColor *lineClr_0,
    /* [in] */ double spacing_1,
    /* [retval][out] */ IDAImage **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_HatchHorizontalAnim_Proxy( 
    IDAStatics * This,
    /* [in] */ IDAColor *lineClr_0,
    /* [in] */ IDANumber *spacing_1,
    /* [retval][out] */ IDAImage **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_HatchVertical_Proxy( 
    IDAStatics * This,
    /* [in] */ IDAColor *lineClr_0,
    /* [in] */ double spacing_1,
    /* [retval][out] */ IDAImage **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_HatchVerticalAnim_Proxy( 
    IDAStatics * This,
    /* [in] */ IDAColor *lineClr_0,
    /* [in] */ IDANumber *spacing_1,
    /* [retval][out] */ IDAImage **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_HatchForwardDiagonal_Proxy( 
    IDAStatics * This,
    /* [in] */ IDAColor *lineClr_0,
    /* [in] */ double spacing_1,
    /* [retval][out] */ IDAImage **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_HatchForwardDiagonalAnim_Proxy( 
    IDAStatics * This,
    /* [in] */ IDAColor *lineClr_0,
    /* [in] */ IDANumber *spacing_1,
    /* [retval][out] */ IDAImage **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_HatchBackwardDiagonal_Proxy( 
    IDAStatics * This,
    /* [in] */ IDAColor *lineClr_0,
    /* [in] */ double spacing_1,
    /* [retval][out] */ IDAImage **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_HatchBackwardDiagonalAnim_Proxy( 
    IDAStatics * This,
    /* [in] */ IDAColor *lineClr_0,
    /* [in] */ IDANumber *spacing_1,
    /* [retval][out] */ IDAImage **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_HatchCross_Proxy( 
    IDAStatics * This,
    /* [in] */ IDAColor *lineClr_0,
    /* [in] */ double spacing_1,
    /* [retval][out] */ IDAImage **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_HatchCrossAnim_Proxy( 
    IDAStatics * This,
    /* [in] */ IDAColor *lineClr_0,
    /* [in] */ IDANumber *spacing_1,
    /* [retval][out] */ IDAImage **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_HatchDiagonalCross_Proxy( 
    IDAStatics * This,
    /* [in] */ IDAColor *lineClr_0,
    /* [in] */ double spacing_1,
    /* [retval][out] */ IDAImage **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_HatchDiagonalCrossAnim_Proxy( 
    IDAStatics * This,
    /* [in] */ IDAColor *lineClr_0,
    /* [in] */ IDANumber *spacing_1,
    /* [retval][out] */ IDAImage **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_Overlay_Proxy( 
    IDAStatics * This,
    /* [in] */ IDAImage *top_0,
    /* [in] */ IDAImage *bottom_1,
    /* [retval][out] */ IDAImage **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_OverlayArrayEx_Proxy( 
    IDAStatics * This,
    /* [in] */ LONG imgs_0size,
    /* [size_is][in] */ IDAImage *imgs_0[  ],
    /* [retval][out] */ IDAImage **ret_1);



HRESULT STDMETHODCALLTYPE IDAStatics_OverlayArray_Proxy( 
    IDAStatics * This,
    /* [in] */ VARIANT imgs_0,
    /* [retval][out] */ IDAImage **ret_1);



/* [propget] */ HRESULT STDMETHODCALLTYPE IDAStatics_get_AmbientLight_Proxy( 
    IDAStatics * This,
    /* [retval][out] */ IDAGeometry **ret_0);



/* [propget] */ HRESULT STDMETHODCALLTYPE IDAStatics_get_DirectionalLight_Proxy( 
    IDAStatics * This,
    /* [retval][out] */ IDAGeometry **ret_0);



/* [propget] */ HRESULT STDMETHODCALLTYPE IDAStatics_get_PointLight_Proxy( 
    IDAStatics * This,
    /* [retval][out] */ IDAGeometry **ret_0);



HRESULT STDMETHODCALLTYPE IDAStatics_SpotLightAnim_Proxy( 
    IDAStatics * This,
    /* [in] */ IDANumber *fullcone_0,
    /* [in] */ IDANumber *cutoff_1,
    /* [retval][out] */ IDAGeometry **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_SpotLight_Proxy( 
    IDAStatics * This,
    /* [in] */ IDANumber *fullcone_0,
    /* [in] */ double cutoff_1,
    /* [retval][out] */ IDAGeometry **ret_2);



/* [propget] */ HRESULT STDMETHODCALLTYPE IDAStatics_get_DefaultLineStyle_Proxy( 
    IDAStatics * This,
    /* [retval][out] */ IDALineStyle **ret_0);



/* [propget] */ HRESULT STDMETHODCALLTYPE IDAStatics_get_EmptyLineStyle_Proxy( 
    IDAStatics * This,
    /* [retval][out] */ IDALineStyle **ret_0);



/* [propget] */ HRESULT STDMETHODCALLTYPE IDAStatics_get_JoinStyleBevel_Proxy( 
    IDAStatics * This,
    /* [retval][out] */ IDAJoinStyle **ret_0);



/* [propget] */ HRESULT STDMETHODCALLTYPE IDAStatics_get_JoinStyleRound_Proxy( 
    IDAStatics * This,
    /* [retval][out] */ IDAJoinStyle **ret_0);



/* [propget] */ HRESULT STDMETHODCALLTYPE IDAStatics_get_JoinStyleMiter_Proxy( 
    IDAStatics * This,
    /* [retval][out] */ IDAJoinStyle **ret_0);



/* [propget] */ HRESULT STDMETHODCALLTYPE IDAStatics_get_EndStyleFlat_Proxy( 
    IDAStatics * This,
    /* [retval][out] */ IDAEndStyle **ret_0);



/* [propget] */ HRESULT STDMETHODCALLTYPE IDAStatics_get_EndStyleSquare_Proxy( 
    IDAStatics * This,
    /* [retval][out] */ IDAEndStyle **ret_0);



/* [propget] */ HRESULT STDMETHODCALLTYPE IDAStatics_get_EndStyleRound_Proxy( 
    IDAStatics * This,
    /* [retval][out] */ IDAEndStyle **ret_0);



/* [propget] */ HRESULT STDMETHODCALLTYPE IDAStatics_get_DashStyleSolid_Proxy( 
    IDAStatics * This,
    /* [retval][out] */ IDADashStyle **ret_0);



/* [propget] */ HRESULT STDMETHODCALLTYPE IDAStatics_get_DashStyleDashed_Proxy( 
    IDAStatics * This,
    /* [retval][out] */ IDADashStyle **ret_0);



/* [propget] */ HRESULT STDMETHODCALLTYPE IDAStatics_get_DefaultMicrophone_Proxy( 
    IDAStatics * This,
    /* [retval][out] */ IDAMicrophone **ret_0);



/* [propget] */ HRESULT STDMETHODCALLTYPE IDAStatics_get_OpaqueMatte_Proxy( 
    IDAStatics * This,
    /* [retval][out] */ IDAMatte **ret_0);



/* [propget] */ HRESULT STDMETHODCALLTYPE IDAStatics_get_ClearMatte_Proxy( 
    IDAStatics * This,
    /* [retval][out] */ IDAMatte **ret_0);



HRESULT STDMETHODCALLTYPE IDAStatics_UnionMatte_Proxy( 
    IDAStatics * This,
    /* [in] */ IDAMatte *m1_0,
    /* [in] */ IDAMatte *m2_1,
    /* [retval][out] */ IDAMatte **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_IntersectMatte_Proxy( 
    IDAStatics * This,
    /* [in] */ IDAMatte *m1_0,
    /* [in] */ IDAMatte *m2_1,
    /* [retval][out] */ IDAMatte **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_DifferenceMatte_Proxy( 
    IDAStatics * This,
    /* [in] */ IDAMatte *m1_0,
    /* [in] */ IDAMatte *m2_1,
    /* [retval][out] */ IDAMatte **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_FillMatte_Proxy( 
    IDAStatics * This,
    /* [in] */ IDAPath2 *p_0,
    /* [retval][out] */ IDAMatte **ret_1);



HRESULT STDMETHODCALLTYPE IDAStatics_TextMatte_Proxy( 
    IDAStatics * This,
    /* [in] */ IDAString *str_0,
    /* [in] */ IDAFontStyle *fs_1,
    /* [retval][out] */ IDAMatte **ret_2);



/* [propget] */ HRESULT STDMETHODCALLTYPE IDAStatics_get_EmptyMontage_Proxy( 
    IDAStatics * This,
    /* [retval][out] */ IDAMontage **ret_0);



HRESULT STDMETHODCALLTYPE IDAStatics_ImageMontage_Proxy( 
    IDAStatics * This,
    /* [in] */ IDAImage *im_0,
    /* [in] */ double depth_1,
    /* [retval][out] */ IDAMontage **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_ImageMontageAnim_Proxy( 
    IDAStatics * This,
    /* [in] */ IDAImage *im_0,
    /* [in] */ IDANumber *depth_1,
    /* [retval][out] */ IDAMontage **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_UnionMontage_Proxy( 
    IDAStatics * This,
    /* [in] */ IDAMontage *m1_0,
    /* [in] */ IDAMontage *m2_1,
    /* [retval][out] */ IDAMontage **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_Concat_Proxy( 
    IDAStatics * This,
    /* [in] */ IDAPath2 *p1_0,
    /* [in] */ IDAPath2 *p2_1,
    /* [retval][out] */ IDAPath2 **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_ConcatArrayEx_Proxy( 
    IDAStatics * This,
    /* [in] */ LONG paths_0size,
    /* [size_is][in] */ IDAPath2 *paths_0[  ],
    /* [retval][out] */ IDAPath2 **ret_1);



HRESULT STDMETHODCALLTYPE IDAStatics_ConcatArray_Proxy( 
    IDAStatics * This,
    /* [in] */ VARIANT paths_0,
    /* [retval][out] */ IDAPath2 **ret_1);



HRESULT STDMETHODCALLTYPE IDAStatics_Line_Proxy( 
    IDAStatics * This,
    /* [in] */ IDAPoint2 *p1_0,
    /* [in] */ IDAPoint2 *p2_1,
    /* [retval][out] */ IDAPath2 **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_Ray_Proxy( 
    IDAStatics * This,
    /* [in] */ IDAPoint2 *pt_0,
    /* [retval][out] */ IDAPath2 **ret_1);



HRESULT STDMETHODCALLTYPE IDAStatics_StringPathAnim_Proxy( 
    IDAStatics * This,
    /* [in] */ IDAString *str_0,
    /* [in] */ IDAFontStyle *fs_1,
    /* [retval][out] */ IDAPath2 **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_StringPath_Proxy( 
    IDAStatics * This,
    /* [in] */ BSTR str_0,
    /* [in] */ IDAFontStyle *fs_1,
    /* [retval][out] */ IDAPath2 **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_PolylineEx_Proxy( 
    IDAStatics * This,
    /* [in] */ LONG points_0size,
    /* [size_is][in] */ IDAPoint2 *points_0[  ],
    /* [retval][out] */ IDAPath2 **ret_1);



HRESULT STDMETHODCALLTYPE IDAStatics_Polyline_Proxy( 
    IDAStatics * This,
    /* [in] */ VARIANT points_0,
    /* [retval][out] */ IDAPath2 **ret_1);



HRESULT STDMETHODCALLTYPE IDAStatics_PolydrawPathEx_Proxy( 
    IDAStatics * This,
    /* [in] */ LONG points_0size,
    /* [size_is][in] */ IDAPoint2 *points_0[  ],
    /* [in] */ LONG codes_1size,
    /* [size_is][in] */ IDANumber *codes_1[  ],
    /* [retval][out] */ IDAPath2 **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_PolydrawPath_Proxy( 
    IDAStatics * This,
    /* [in] */ VARIANT points_0,
    /* [in] */ VARIANT codes_1,
    /* [retval][out] */ IDAPath2 **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_ArcRadians_Proxy( 
    IDAStatics * This,
    /* [in] */ double startAngle_0,
    /* [in] */ double endAngle_1,
    /* [in] */ double arcWidth_2,
    /* [in] */ double arcHeight_3,
    /* [retval][out] */ IDAPath2 **ret_4);



HRESULT STDMETHODCALLTYPE IDAStatics_ArcRadiansAnim_Proxy( 
    IDAStatics * This,
    /* [in] */ IDANumber *startAngle_0,
    /* [in] */ IDANumber *endAngle_1,
    /* [in] */ IDANumber *arcWidth_2,
    /* [in] */ IDANumber *arcHeight_3,
    /* [retval][out] */ IDAPath2 **ret_4);



HRESULT STDMETHODCALLTYPE IDAStatics_ArcDegrees_Proxy( 
    IDAStatics * This,
    /* [in] */ double startAngle_0,
    /* [in] */ double endAngle_1,
    /* [in] */ double arcWidth_2,
    /* [in] */ double arcHeight_3,
    /* [retval][out] */ IDAPath2 **ret_4);



HRESULT STDMETHODCALLTYPE IDAStatics_PieRadians_Proxy( 
    IDAStatics * This,
    /* [in] */ double startAngle_0,
    /* [in] */ double endAngle_1,
    /* [in] */ double arcWidth_2,
    /* [in] */ double arcHeight_3,
    /* [retval][out] */ IDAPath2 **ret_4);



HRESULT STDMETHODCALLTYPE IDAStatics_PieRadiansAnim_Proxy( 
    IDAStatics * This,
    /* [in] */ IDANumber *startAngle_0,
    /* [in] */ IDANumber *endAngle_1,
    /* [in] */ IDANumber *arcWidth_2,
    /* [in] */ IDANumber *arcHeight_3,
    /* [retval][out] */ IDAPath2 **ret_4);



HRESULT STDMETHODCALLTYPE IDAStatics_PieDegrees_Proxy( 
    IDAStatics * This,
    /* [in] */ double startAngle_0,
    /* [in] */ double endAngle_1,
    /* [in] */ double arcWidth_2,
    /* [in] */ double arcHeight_3,
    /* [retval][out] */ IDAPath2 **ret_4);



HRESULT STDMETHODCALLTYPE IDAStatics_Oval_Proxy( 
    IDAStatics * This,
    /* [in] */ double width_0,
    /* [in] */ double height_1,
    /* [retval][out] */ IDAPath2 **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_OvalAnim_Proxy( 
    IDAStatics * This,
    /* [in] */ IDANumber *width_0,
    /* [in] */ IDANumber *height_1,
    /* [retval][out] */ IDAPath2 **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_Rect_Proxy( 
    IDAStatics * This,
    /* [in] */ double width_0,
    /* [in] */ double height_1,
    /* [retval][out] */ IDAPath2 **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_RectAnim_Proxy( 
    IDAStatics * This,
    /* [in] */ IDANumber *width_0,
    /* [in] */ IDANumber *height_1,
    /* [retval][out] */ IDAPath2 **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_RoundRect_Proxy( 
    IDAStatics * This,
    /* [in] */ double width_0,
    /* [in] */ double height_1,
    /* [in] */ double cornerArcWidth_2,
    /* [in] */ double cornerArcHeight_3,
    /* [retval][out] */ IDAPath2 **ret_4);



HRESULT STDMETHODCALLTYPE IDAStatics_RoundRectAnim_Proxy( 
    IDAStatics * This,
    /* [in] */ IDANumber *width_0,
    /* [in] */ IDANumber *height_1,
    /* [in] */ IDANumber *cornerArcWidth_2,
    /* [in] */ IDANumber *cornerArcHeight_3,
    /* [retval][out] */ IDAPath2 **ret_4);



HRESULT STDMETHODCALLTYPE IDAStatics_CubicBSplinePathEx_Proxy( 
    IDAStatics * This,
    /* [in] */ LONG points_0size,
    /* [size_is][in] */ IDAPoint2 *points_0[  ],
    /* [in] */ LONG knots_1size,
    /* [size_is][in] */ IDANumber *knots_1[  ],
    /* [retval][out] */ IDAPath2 **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_CubicBSplinePath_Proxy( 
    IDAStatics * This,
    /* [in] */ VARIANT points_0,
    /* [in] */ VARIANT knots_1,
    /* [retval][out] */ IDAPath2 **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_TextPath_Proxy( 
    IDAStatics * This,
    /* [in] */ IDAString *obsolete1_0,
    /* [in] */ IDAFontStyle *obsolete2_1,
    /* [retval][out] */ IDAPath2 **ret_2);



/* [propget] */ HRESULT STDMETHODCALLTYPE IDAStatics_get_Silence_Proxy( 
    IDAStatics * This,
    /* [retval][out] */ IDASound **ret_0);



HRESULT STDMETHODCALLTYPE IDAStatics_MixArrayEx_Proxy( 
    IDAStatics * This,
    /* [in] */ LONG snds_0size,
    /* [size_is][in] */ IDASound *snds_0[  ],
    /* [retval][out] */ IDASound **ret_1);



HRESULT STDMETHODCALLTYPE IDAStatics_MixArray_Proxy( 
    IDAStatics * This,
    /* [in] */ VARIANT snds_0,
    /* [retval][out] */ IDASound **ret_1);



/* [propget] */ HRESULT STDMETHODCALLTYPE IDAStatics_get_SinSynth_Proxy( 
    IDAStatics * This,
    /* [retval][out] */ IDASound **ret_0);



/* [propget] */ HRESULT STDMETHODCALLTYPE IDAStatics_get_DefaultFont_Proxy( 
    IDAStatics * This,
    /* [retval][out] */ IDAFontStyle **ret_0);



HRESULT STDMETHODCALLTYPE IDAStatics_FontAnim_Proxy( 
    IDAStatics * This,
    /* [in] */ IDAString *str_0,
    /* [in] */ IDANumber *size_1,
    /* [in] */ IDAColor *col_2,
    /* [retval][out] */ IDAFontStyle **ret_3);



HRESULT STDMETHODCALLTYPE IDAStatics_Font_Proxy( 
    IDAStatics * This,
    /* [in] */ BSTR str_0,
    /* [in] */ double size_1,
    /* [in] */ IDAColor *col_2,
    /* [retval][out] */ IDAFontStyle **ret_3);



HRESULT STDMETHODCALLTYPE IDAStatics_StringImageAnim_Proxy( 
    IDAStatics * This,
    /* [in] */ IDAString *str_0,
    /* [in] */ IDAFontStyle *fs_1,
    /* [retval][out] */ IDAImage **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_StringImage_Proxy( 
    IDAStatics * This,
    /* [in] */ BSTR str_0,
    /* [in] */ IDAFontStyle *fs_1,
    /* [retval][out] */ IDAImage **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_TextImageAnim_Proxy( 
    IDAStatics * This,
    /* [in] */ IDAString *obsoleted1_0,
    /* [in] */ IDAFontStyle *obsoleted2_1,
    /* [retval][out] */ IDAImage **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_TextImage_Proxy( 
    IDAStatics * This,
    /* [in] */ BSTR obsoleted1_0,
    /* [in] */ IDAFontStyle *obsoleted2_1,
    /* [retval][out] */ IDAImage **ret_2);



/* [propget] */ HRESULT STDMETHODCALLTYPE IDAStatics_get_XVector2_Proxy( 
    IDAStatics * This,
    /* [retval][out] */ IDAVector2 **ret_0);



/* [propget] */ HRESULT STDMETHODCALLTYPE IDAStatics_get_YVector2_Proxy( 
    IDAStatics * This,
    /* [retval][out] */ IDAVector2 **ret_0);



/* [propget] */ HRESULT STDMETHODCALLTYPE IDAStatics_get_ZeroVector2_Proxy( 
    IDAStatics * This,
    /* [retval][out] */ IDAVector2 **ret_0);



/* [propget] */ HRESULT STDMETHODCALLTYPE IDAStatics_get_Origin2_Proxy( 
    IDAStatics * This,
    /* [retval][out] */ IDAPoint2 **ret_0);



HRESULT STDMETHODCALLTYPE IDAStatics_Vector2Anim_Proxy( 
    IDAStatics * This,
    /* [in] */ IDANumber *x_0,
    /* [in] */ IDANumber *y_1,
    /* [retval][out] */ IDAVector2 **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_Vector2_Proxy( 
    IDAStatics * This,
    /* [in] */ double x_0,
    /* [in] */ double y_1,
    /* [retval][out] */ IDAVector2 **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_Point2Anim_Proxy( 
    IDAStatics * This,
    /* [in] */ IDANumber *x_0,
    /* [in] */ IDANumber *y_1,
    /* [retval][out] */ IDAPoint2 **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_Point2_Proxy( 
    IDAStatics * This,
    /* [in] */ double x_0,
    /* [in] */ double y_1,
    /* [retval][out] */ IDAPoint2 **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_Vector2PolarAnim_Proxy( 
    IDAStatics * This,
    /* [in] */ IDANumber *theta_0,
    /* [in] */ IDANumber *radius_1,
    /* [retval][out] */ IDAVector2 **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_Vector2Polar_Proxy( 
    IDAStatics * This,
    /* [in] */ double theta_0,
    /* [in] */ double radius_1,
    /* [retval][out] */ IDAVector2 **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_Vector2PolarDegrees_Proxy( 
    IDAStatics * This,
    /* [in] */ double theta_0,
    /* [in] */ double radius_1,
    /* [retval][out] */ IDAVector2 **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_Point2PolarAnim_Proxy( 
    IDAStatics * This,
    /* [in] */ IDANumber *theta_0,
    /* [in] */ IDANumber *radius_1,
    /* [retval][out] */ IDAPoint2 **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_Point2Polar_Proxy( 
    IDAStatics * This,
    /* [in] */ double theta_0,
    /* [in] */ double radius_1,
    /* [retval][out] */ IDAPoint2 **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_DotVector2_Proxy( 
    IDAStatics * This,
    /* [in] */ IDAVector2 *v_0,
    /* [in] */ IDAVector2 *u_1,
    /* [retval][out] */ IDANumber **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_NegVector2_Proxy( 
    IDAStatics * This,
    /* [in] */ IDAVector2 *v_0,
    /* [retval][out] */ IDAVector2 **ret_1);



HRESULT STDMETHODCALLTYPE IDAStatics_SubVector2_Proxy( 
    IDAStatics * This,
    /* [in] */ IDAVector2 *v1_0,
    /* [in] */ IDAVector2 *v2_1,
    /* [retval][out] */ IDAVector2 **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_AddVector2_Proxy( 
    IDAStatics * This,
    /* [in] */ IDAVector2 *v1_0,
    /* [in] */ IDAVector2 *v2_1,
    /* [retval][out] */ IDAVector2 **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_AddPoint2Vector_Proxy( 
    IDAStatics * This,
    /* [in] */ IDAPoint2 *p_0,
    /* [in] */ IDAVector2 *v_1,
    /* [retval][out] */ IDAPoint2 **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_SubPoint2Vector_Proxy( 
    IDAStatics * This,
    /* [in] */ IDAPoint2 *p_0,
    /* [in] */ IDAVector2 *v_1,
    /* [retval][out] */ IDAPoint2 **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_SubPoint2_Proxy( 
    IDAStatics * This,
    /* [in] */ IDAPoint2 *p1_0,
    /* [in] */ IDAPoint2 *p2_1,
    /* [retval][out] */ IDAVector2 **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_DistancePoint2_Proxy( 
    IDAStatics * This,
    /* [in] */ IDAPoint2 *p_0,
    /* [in] */ IDAPoint2 *q_1,
    /* [retval][out] */ IDANumber **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_DistanceSquaredPoint2_Proxy( 
    IDAStatics * This,
    /* [in] */ IDAPoint2 *p_0,
    /* [in] */ IDAPoint2 *q_1,
    /* [retval][out] */ IDANumber **ret_2);



/* [propget] */ HRESULT STDMETHODCALLTYPE IDAStatics_get_XVector3_Proxy( 
    IDAStatics * This,
    /* [retval][out] */ IDAVector3 **ret_0);



/* [propget] */ HRESULT STDMETHODCALLTYPE IDAStatics_get_YVector3_Proxy( 
    IDAStatics * This,
    /* [retval][out] */ IDAVector3 **ret_0);



/* [propget] */ HRESULT STDMETHODCALLTYPE IDAStatics_get_ZVector3_Proxy( 
    IDAStatics * This,
    /* [retval][out] */ IDAVector3 **ret_0);



/* [propget] */ HRESULT STDMETHODCALLTYPE IDAStatics_get_ZeroVector3_Proxy( 
    IDAStatics * This,
    /* [retval][out] */ IDAVector3 **ret_0);



/* [propget] */ HRESULT STDMETHODCALLTYPE IDAStatics_get_Origin3_Proxy( 
    IDAStatics * This,
    /* [retval][out] */ IDAPoint3 **ret_0);



HRESULT STDMETHODCALLTYPE IDAStatics_Vector3Anim_Proxy( 
    IDAStatics * This,
    /* [in] */ IDANumber *x_0,
    /* [in] */ IDANumber *y_1,
    /* [in] */ IDANumber *z_2,
    /* [retval][out] */ IDAVector3 **ret_3);



HRESULT STDMETHODCALLTYPE IDAStatics_Vector3_Proxy( 
    IDAStatics * This,
    /* [in] */ double x_0,
    /* [in] */ double y_1,
    /* [in] */ double z_2,
    /* [retval][out] */ IDAVector3 **ret_3);



HRESULT STDMETHODCALLTYPE IDAStatics_Point3Anim_Proxy( 
    IDAStatics * This,
    /* [in] */ IDANumber *x_0,
    /* [in] */ IDANumber *y_1,
    /* [in] */ IDANumber *z_2,
    /* [retval][out] */ IDAPoint3 **ret_3);



HRESULT STDMETHODCALLTYPE IDAStatics_Point3_Proxy( 
    IDAStatics * This,
    /* [in] */ double x_0,
    /* [in] */ double y_1,
    /* [in] */ double z_2,
    /* [retval][out] */ IDAPoint3 **ret_3);



HRESULT STDMETHODCALLTYPE IDAStatics_Vector3SphericalAnim_Proxy( 
    IDAStatics * This,
    /* [in] */ IDANumber *xyAngle_0,
    /* [in] */ IDANumber *yzAngle_1,
    /* [in] */ IDANumber *radius_2,
    /* [retval][out] */ IDAVector3 **ret_3);



HRESULT STDMETHODCALLTYPE IDAStatics_Vector3Spherical_Proxy( 
    IDAStatics * This,
    /* [in] */ double xyAngle_0,
    /* [in] */ double yzAngle_1,
    /* [in] */ double radius_2,
    /* [retval][out] */ IDAVector3 **ret_3);



HRESULT STDMETHODCALLTYPE IDAStatics_Point3SphericalAnim_Proxy( 
    IDAStatics * This,
    /* [in] */ IDANumber *zxAngle_0,
    /* [in] */ IDANumber *xyAngle_1,
    /* [in] */ IDANumber *radius_2,
    /* [retval][out] */ IDAPoint3 **ret_3);



HRESULT STDMETHODCALLTYPE IDAStatics_Point3Spherical_Proxy( 
    IDAStatics * This,
    /* [in] */ double zxAngle_0,
    /* [in] */ double xyAngle_1,
    /* [in] */ double radius_2,
    /* [retval][out] */ IDAPoint3 **ret_3);



HRESULT STDMETHODCALLTYPE IDAStatics_DotVector3_Proxy( 
    IDAStatics * This,
    /* [in] */ IDAVector3 *v_0,
    /* [in] */ IDAVector3 *u_1,
    /* [retval][out] */ IDANumber **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_CrossVector3_Proxy( 
    IDAStatics * This,
    /* [in] */ IDAVector3 *v_0,
    /* [in] */ IDAVector3 *u_1,
    /* [retval][out] */ IDAVector3 **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_NegVector3_Proxy( 
    IDAStatics * This,
    /* [in] */ IDAVector3 *v_0,
    /* [retval][out] */ IDAVector3 **ret_1);



HRESULT STDMETHODCALLTYPE IDAStatics_SubVector3_Proxy( 
    IDAStatics * This,
    /* [in] */ IDAVector3 *v1_0,
    /* [in] */ IDAVector3 *v2_1,
    /* [retval][out] */ IDAVector3 **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_AddVector3_Proxy( 
    IDAStatics * This,
    /* [in] */ IDAVector3 *v1_0,
    /* [in] */ IDAVector3 *v2_1,
    /* [retval][out] */ IDAVector3 **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_AddPoint3Vector_Proxy( 
    IDAStatics * This,
    /* [in] */ IDAPoint3 *p_0,
    /* [in] */ IDAVector3 *v_1,
    /* [retval][out] */ IDAPoint3 **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_SubPoint3Vector_Proxy( 
    IDAStatics * This,
    /* [in] */ IDAPoint3 *p_0,
    /* [in] */ IDAVector3 *v_1,
    /* [retval][out] */ IDAPoint3 **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_SubPoint3_Proxy( 
    IDAStatics * This,
    /* [in] */ IDAPoint3 *p1_0,
    /* [in] */ IDAPoint3 *p2_1,
    /* [retval][out] */ IDAVector3 **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_DistancePoint3_Proxy( 
    IDAStatics * This,
    /* [in] */ IDAPoint3 *p_0,
    /* [in] */ IDAPoint3 *q_1,
    /* [retval][out] */ IDANumber **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_DistanceSquaredPoint3_Proxy( 
    IDAStatics * This,
    /* [in] */ IDAPoint3 *p_0,
    /* [in] */ IDAPoint3 *q_1,
    /* [retval][out] */ IDANumber **ret_2);



/* [propget] */ HRESULT STDMETHODCALLTYPE IDAStatics_get_IdentityTransform3_Proxy( 
    IDAStatics * This,
    /* [retval][out] */ IDATransform3 **ret_0);



HRESULT STDMETHODCALLTYPE IDAStatics_Translate3Anim_Proxy( 
    IDAStatics * This,
    /* [in] */ IDANumber *tx_0,
    /* [in] */ IDANumber *ty_1,
    /* [in] */ IDANumber *tz_2,
    /* [retval][out] */ IDATransform3 **ret_3);



HRESULT STDMETHODCALLTYPE IDAStatics_Translate3_Proxy( 
    IDAStatics * This,
    /* [in] */ double tx_0,
    /* [in] */ double ty_1,
    /* [in] */ double tz_2,
    /* [retval][out] */ IDATransform3 **ret_3);



HRESULT STDMETHODCALLTYPE IDAStatics_Translate3Rate_Proxy( 
    IDAStatics * This,
    /* [in] */ double tx_0,
    /* [in] */ double ty_1,
    /* [in] */ double tz_2,
    /* [retval][out] */ IDATransform3 **ret_3);



HRESULT STDMETHODCALLTYPE IDAStatics_Translate3Vector_Proxy( 
    IDAStatics * This,
    /* [in] */ IDAVector3 *delta_0,
    /* [retval][out] */ IDATransform3 **ret_1);



HRESULT STDMETHODCALLTYPE IDAStatics_Translate3Point_Proxy( 
    IDAStatics * This,
    /* [in] */ IDAPoint3 *new_origin_0,
    /* [retval][out] */ IDATransform3 **ret_1);



HRESULT STDMETHODCALLTYPE IDAStatics_Scale3Anim_Proxy( 
    IDAStatics * This,
    /* [in] */ IDANumber *x_0,
    /* [in] */ IDANumber *y_1,
    /* [in] */ IDANumber *z_2,
    /* [retval][out] */ IDATransform3 **ret_3);



HRESULT STDMETHODCALLTYPE IDAStatics_Scale3_Proxy( 
    IDAStatics * This,
    /* [in] */ double x_0,
    /* [in] */ double y_1,
    /* [in] */ double z_2,
    /* [retval][out] */ IDATransform3 **ret_3);



HRESULT STDMETHODCALLTYPE IDAStatics_Scale3Rate_Proxy( 
    IDAStatics * This,
    /* [in] */ double x_0,
    /* [in] */ double y_1,
    /* [in] */ double z_2,
    /* [retval][out] */ IDATransform3 **ret_3);



HRESULT STDMETHODCALLTYPE IDAStatics_Scale3Vector_Proxy( 
    IDAStatics * This,
    /* [in] */ IDAVector3 *scale_vec_0,
    /* [retval][out] */ IDATransform3 **ret_1);



HRESULT STDMETHODCALLTYPE IDAStatics_Scale3UniformAnim_Proxy( 
    IDAStatics * This,
    /* [in] */ IDANumber *uniform_scale_0,
    /* [retval][out] */ IDATransform3 **ret_1);



HRESULT STDMETHODCALLTYPE IDAStatics_Scale3Uniform_Proxy( 
    IDAStatics * This,
    /* [in] */ double uniform_scale_0,
    /* [retval][out] */ IDATransform3 **ret_1);



HRESULT STDMETHODCALLTYPE IDAStatics_Scale3UniformRate_Proxy( 
    IDAStatics * This,
    /* [in] */ double uniform_scale_0,
    /* [retval][out] */ IDATransform3 **ret_1);



HRESULT STDMETHODCALLTYPE IDAStatics_Rotate3Anim_Proxy( 
    IDAStatics * This,
    /* [in] */ IDAVector3 *axis_0,
    /* [in] */ IDANumber *angle_1,
    /* [retval][out] */ IDATransform3 **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_Rotate3_Proxy( 
    IDAStatics * This,
    /* [in] */ IDAVector3 *axis_0,
    /* [in] */ double angle_1,
    /* [retval][out] */ IDATransform3 **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_Rotate3Rate_Proxy( 
    IDAStatics * This,
    /* [in] */ IDAVector3 *axis_0,
    /* [in] */ double angle_1,
    /* [retval][out] */ IDATransform3 **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_Rotate3Degrees_Proxy( 
    IDAStatics * This,
    /* [in] */ IDAVector3 *axis_0,
    /* [in] */ double angle_1,
    /* [retval][out] */ IDATransform3 **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_Rotate3RateDegrees_Proxy( 
    IDAStatics * This,
    /* [in] */ IDAVector3 *axis_0,
    /* [in] */ double angle_1,
    /* [retval][out] */ IDATransform3 **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_XShear3Anim_Proxy( 
    IDAStatics * This,
    /* [in] */ IDANumber *a_0,
    /* [in] */ IDANumber *b_1,
    /* [retval][out] */ IDATransform3 **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_XShear3_Proxy( 
    IDAStatics * This,
    /* [in] */ double a_0,
    /* [in] */ double b_1,
    /* [retval][out] */ IDATransform3 **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_XShear3Rate_Proxy( 
    IDAStatics * This,
    /* [in] */ double a_0,
    /* [in] */ double b_1,
    /* [retval][out] */ IDATransform3 **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_YShear3Anim_Proxy( 
    IDAStatics * This,
    /* [in] */ IDANumber *c_0,
    /* [in] */ IDANumber *d_1,
    /* [retval][out] */ IDATransform3 **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_YShear3_Proxy( 
    IDAStatics * This,
    /* [in] */ double c_0,
    /* [in] */ double d_1,
    /* [retval][out] */ IDATransform3 **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_YShear3Rate_Proxy( 
    IDAStatics * This,
    /* [in] */ double c_0,
    /* [in] */ double d_1,
    /* [retval][out] */ IDATransform3 **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_ZShear3Anim_Proxy( 
    IDAStatics * This,
    /* [in] */ IDANumber *e_0,
    /* [in] */ IDANumber *f_1,
    /* [retval][out] */ IDATransform3 **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_ZShear3_Proxy( 
    IDAStatics * This,
    /* [in] */ double e_0,
    /* [in] */ double f_1,
    /* [retval][out] */ IDATransform3 **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_ZShear3Rate_Proxy( 
    IDAStatics * This,
    /* [in] */ double e_0,
    /* [in] */ double f_1,
    /* [retval][out] */ IDATransform3 **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_Transform4x4AnimEx_Proxy( 
    IDAStatics * This,
    /* [in] */ LONG m_0size,
    /* [size_is][in] */ IDANumber *m_0[  ],
    /* [retval][out] */ IDATransform3 **ret_1);



HRESULT STDMETHODCALLTYPE IDAStatics_Transform4x4Anim_Proxy( 
    IDAStatics * This,
    /* [in] */ VARIANT m_0,
    /* [retval][out] */ IDATransform3 **ret_1);



HRESULT STDMETHODCALLTYPE IDAStatics_Compose3_Proxy( 
    IDAStatics * This,
    /* [in] */ IDATransform3 *a_0,
    /* [in] */ IDATransform3 *b_1,
    /* [retval][out] */ IDATransform3 **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_Compose3ArrayEx_Proxy( 
    IDAStatics * This,
    /* [in] */ LONG xfs_0size,
    /* [size_is][in] */ IDATransform3 *xfs_0[  ],
    /* [retval][out] */ IDATransform3 **ret_1);



HRESULT STDMETHODCALLTYPE IDAStatics_Compose3Array_Proxy( 
    IDAStatics * This,
    /* [in] */ VARIANT xfs_0,
    /* [retval][out] */ IDATransform3 **ret_1);



HRESULT STDMETHODCALLTYPE IDAStatics_LookAtFrom_Proxy( 
    IDAStatics * This,
    /* [in] */ IDAPoint3 *to_0,
    /* [in] */ IDAPoint3 *from_1,
    /* [in] */ IDAVector3 *up_2,
    /* [retval][out] */ IDATransform3 **ret_3);



/* [propget] */ HRESULT STDMETHODCALLTYPE IDAStatics_get_IdentityTransform2_Proxy( 
    IDAStatics * This,
    /* [retval][out] */ IDATransform2 **ret_0);



HRESULT STDMETHODCALLTYPE IDAStatics_Translate2Anim_Proxy( 
    IDAStatics * This,
    /* [in] */ IDANumber *Tx_0,
    /* [in] */ IDANumber *Ty_1,
    /* [retval][out] */ IDATransform2 **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_Translate2_Proxy( 
    IDAStatics * This,
    /* [in] */ double Tx_0,
    /* [in] */ double Ty_1,
    /* [retval][out] */ IDATransform2 **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_Translate2Rate_Proxy( 
    IDAStatics * This,
    /* [in] */ double Tx_0,
    /* [in] */ double Ty_1,
    /* [retval][out] */ IDATransform2 **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_Translate2Vector_Proxy( 
    IDAStatics * This,
    /* [in] */ IDAVector2 *delta_0,
    /* [retval][out] */ IDATransform2 **ret_1);



HRESULT STDMETHODCALLTYPE IDAStatics_Translate2Point_Proxy( 
    IDAStatics * This,
    /* [in] */ IDAPoint2 *pos_0,
    /* [retval][out] */ IDATransform2 **ret_1);



HRESULT STDMETHODCALLTYPE IDAStatics_Scale2Anim_Proxy( 
    IDAStatics * This,
    /* [in] */ IDANumber *x_0,
    /* [in] */ IDANumber *y_1,
    /* [retval][out] */ IDATransform2 **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_Scale2_Proxy( 
    IDAStatics * This,
    /* [in] */ double x_0,
    /* [in] */ double y_1,
    /* [retval][out] */ IDATransform2 **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_Scale2Rate_Proxy( 
    IDAStatics * This,
    /* [in] */ double x_0,
    /* [in] */ double y_1,
    /* [retval][out] */ IDATransform2 **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_Scale2Vector2_Proxy( 
    IDAStatics * This,
    /* [in] */ IDAVector2 *obsoleteMethod_0,
    /* [retval][out] */ IDATransform2 **ret_1);



HRESULT STDMETHODCALLTYPE IDAStatics_Scale2Vector_Proxy( 
    IDAStatics * This,
    /* [in] */ IDAVector2 *scale_vec_0,
    /* [retval][out] */ IDATransform2 **ret_1);



HRESULT STDMETHODCALLTYPE IDAStatics_Scale2UniformAnim_Proxy( 
    IDAStatics * This,
    /* [in] */ IDANumber *uniform_scale_0,
    /* [retval][out] */ IDATransform2 **ret_1);



HRESULT STDMETHODCALLTYPE IDAStatics_Scale2Uniform_Proxy( 
    IDAStatics * This,
    /* [in] */ double uniform_scale_0,
    /* [retval][out] */ IDATransform2 **ret_1);



HRESULT STDMETHODCALLTYPE IDAStatics_Scale2UniformRate_Proxy( 
    IDAStatics * This,
    /* [in] */ double uniform_scale_0,
    /* [retval][out] */ IDATransform2 **ret_1);



HRESULT STDMETHODCALLTYPE IDAStatics_Rotate2Anim_Proxy( 
    IDAStatics * This,
    /* [in] */ IDANumber *angle_0,
    /* [retval][out] */ IDATransform2 **ret_1);



HRESULT STDMETHODCALLTYPE IDAStatics_Rotate2_Proxy( 
    IDAStatics * This,
    /* [in] */ double angle_0,
    /* [retval][out] */ IDATransform2 **ret_1);



HRESULT STDMETHODCALLTYPE IDAStatics_Rotate2Rate_Proxy( 
    IDAStatics * This,
    /* [in] */ double angle_0,
    /* [retval][out] */ IDATransform2 **ret_1);



HRESULT STDMETHODCALLTYPE IDAStatics_Rotate2Degrees_Proxy( 
    IDAStatics * This,
    /* [in] */ double angle_0,
    /* [retval][out] */ IDATransform2 **ret_1);



HRESULT STDMETHODCALLTYPE IDAStatics_Rotate2RateDegrees_Proxy( 
    IDAStatics * This,
    /* [in] */ double angle_0,
    /* [retval][out] */ IDATransform2 **ret_1);



HRESULT STDMETHODCALLTYPE IDAStatics_XShear2Anim_Proxy( 
    IDAStatics * This,
    /* [in] */ IDANumber *arg_0,
    /* [retval][out] */ IDATransform2 **ret_1);



HRESULT STDMETHODCALLTYPE IDAStatics_XShear2_Proxy( 
    IDAStatics * This,
    /* [in] */ double arg_0,
    /* [retval][out] */ IDATransform2 **ret_1);



HRESULT STDMETHODCALLTYPE IDAStatics_XShear2Rate_Proxy( 
    IDAStatics * This,
    /* [in] */ double arg_0,
    /* [retval][out] */ IDATransform2 **ret_1);



HRESULT STDMETHODCALLTYPE IDAStatics_YShear2Anim_Proxy( 
    IDAStatics * This,
    /* [in] */ IDANumber *arg_0,
    /* [retval][out] */ IDATransform2 **ret_1);



HRESULT STDMETHODCALLTYPE IDAStatics_YShear2_Proxy( 
    IDAStatics * This,
    /* [in] */ double arg_0,
    /* [retval][out] */ IDATransform2 **ret_1);



HRESULT STDMETHODCALLTYPE IDAStatics_YShear2Rate_Proxy( 
    IDAStatics * This,
    /* [in] */ double arg_0,
    /* [retval][out] */ IDATransform2 **ret_1);



HRESULT STDMETHODCALLTYPE IDAStatics_Transform3x2AnimEx_Proxy( 
    IDAStatics * This,
    /* [in] */ LONG m_0size,
    /* [size_is][in] */ IDANumber *m_0[  ],
    /* [retval][out] */ IDATransform2 **ret_1);



HRESULT STDMETHODCALLTYPE IDAStatics_Transform3x2Anim_Proxy( 
    IDAStatics * This,
    /* [in] */ VARIANT m_0,
    /* [retval][out] */ IDATransform2 **ret_1);



HRESULT STDMETHODCALLTYPE IDAStatics_Compose2_Proxy( 
    IDAStatics * This,
    /* [in] */ IDATransform2 *a_0,
    /* [in] */ IDATransform2 *b_1,
    /* [retval][out] */ IDATransform2 **ret_2);



HRESULT STDMETHODCALLTYPE IDAStatics_Compose2ArrayEx_Proxy( 
    IDAStatics * This,
    /* [in] */ LONG xfs_0size,
    /* [size_is][in] */ IDATransform2 *xfs_0[  ],
    /* [retval][out] */ IDATransform2 **ret_1);



HRESULT STDMETHODCALLTYPE IDAStatics_Compose2Array_Proxy( 
    IDAStatics * This,
    /* [in] */ VARIANT xfs_0,
    /* [retval][out] */ IDATransform2 **ret_1);



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IDAStatics_Tuple_Proxy( 
    IDAStatics * This,
    /* [in] */ VARIANT obsolete1,
    /* [retval][out] */ IDATuple **obsolete2);



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IDAStatics_Array_Proxy( 
    IDAStatics * This,
    /* [in] */ VARIANT obsolete1,
    /* [retval][out] */ IDAArray **obsolete2);



/* [propget] */ HRESULT STDMETHODCALLTYPE IDAStatics_get_AreBlockingImportsComplete_Proxy( 
    IDAStatics * This,
    /* [retval][out] */ VARIANT_BOOL *bComplete);




#endif 	/* __IDAStatics_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_DAStatics;

#ifdef __cplusplus

class DECLSPEC_UUID("542FB453-5003-11cf-92A2-00AA00B8A733")
DAStatics;
#endif

#ifndef __IDAViewerControl_INTERFACE_DEFINED__
#define __IDAViewerControl_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDAViewerControl
 * at Tue Nov 11 05:16:35 1997
 * using MIDL 3.02.88
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_IDAViewerControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0E41257B-812D-11D0-9B4A-00C04FC2F51D")
    IDAViewerControl : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_UpdateInterval( 
            /* [retval][out] */ double *pVal) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_UpdateInterval( 
            /* [in] */ double newVal) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_View( 
            /* [retval][out] */ IDAView **ppView) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_View( 
            /* [in] */ IDAView *pView) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Image( 
            /* [retval][out] */ IDAImage **ppImage) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_Image( 
            /* [in] */ IDAImage *pImage) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_BackgroundImage( 
            /* [retval][out] */ IDAImage **ppImage) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_BackgroundImage( 
            /* [in] */ IDAImage *pImage) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Sound( 
            /* [retval][out] */ IDASound **ppSound) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_Sound( 
            /* [in] */ IDASound *pSound) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_PixelLibrary( 
            /* [retval][out] */ IDAStatics **ppStatics) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_MeterLibrary( 
            /* [retval][out] */ IDAStatics **ppStatics) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddBehaviorToRun( 
            /* [in] */ IDABehavior *pBehavior) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Start( void) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_InputImage( 
            /* [retval][out] */ IDAImage **pVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_OpaqueForHitDetect( 
            /* [retval][out] */ VARIANT_BOOL *b) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_OpaqueForHitDetect( 
            /* [in] */ VARIANT_BOOL b) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_TimerSource( 
            /* [retval][out] */ DA_TIMER_SOURCE *ts) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_TimerSource( 
            /* [in] */ DA_TIMER_SOURCE ts) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDAViewerControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDAViewerControl * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDAViewerControl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDAViewerControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDAViewerControl * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDAViewerControl * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDAViewerControl * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDAViewerControl * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UpdateInterval )( 
            IDAViewerControl * This,
            /* [retval][out] */ double *pVal);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_UpdateInterval )( 
            IDAViewerControl * This,
            /* [in] */ double newVal);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_View )( 
            IDAViewerControl * This,
            /* [retval][out] */ IDAView **ppView);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_View )( 
            IDAViewerControl * This,
            /* [in] */ IDAView *pView);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Image )( 
            IDAViewerControl * This,
            /* [retval][out] */ IDAImage **ppImage);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Image )( 
            IDAViewerControl * This,
            /* [in] */ IDAImage *pImage);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_BackgroundImage )( 
            IDAViewerControl * This,
            /* [retval][out] */ IDAImage **ppImage);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_BackgroundImage )( 
            IDAViewerControl * This,
            /* [in] */ IDAImage *pImage);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Sound )( 
            IDAViewerControl * This,
            /* [retval][out] */ IDASound **ppSound);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Sound )( 
            IDAViewerControl * This,
            /* [in] */ IDASound *pSound);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PixelLibrary )( 
            IDAViewerControl * This,
            /* [retval][out] */ IDAStatics **ppStatics);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MeterLibrary )( 
            IDAViewerControl * This,
            /* [retval][out] */ IDAStatics **ppStatics);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AddBehaviorToRun )( 
            IDAViewerControl * This,
            /* [in] */ IDABehavior *pBehavior);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Start )( 
            IDAViewerControl * This);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_InputImage )( 
            IDAViewerControl * This,
            /* [retval][out] */ IDAImage **pVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_OpaqueForHitDetect )( 
            IDAViewerControl * This,
            /* [retval][out] */ VARIANT_BOOL *b);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_OpaqueForHitDetect )( 
            IDAViewerControl * This,
            /* [in] */ VARIANT_BOOL b);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_TimerSource )( 
            IDAViewerControl * This,
            /* [retval][out] */ DA_TIMER_SOURCE *ts);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_TimerSource )( 
            IDAViewerControl * This,
            /* [in] */ DA_TIMER_SOURCE ts);
        
        END_INTERFACE
    } IDAViewerControlVtbl;

    interface IDAViewerControl
    {
        CONST_VTBL struct IDAViewerControlVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDAViewerControl_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDAViewerControl_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDAViewerControl_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDAViewerControl_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDAViewerControl_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDAViewerControl_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDAViewerControl_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDAViewerControl_get_UpdateInterval(This,pVal)	\
    (This)->lpVtbl -> get_UpdateInterval(This,pVal)

#define IDAViewerControl_put_UpdateInterval(This,newVal)	\
    (This)->lpVtbl -> put_UpdateInterval(This,newVal)

#define IDAViewerControl_get_View(This,ppView)	\
    (This)->lpVtbl -> get_View(This,ppView)

#define IDAViewerControl_put_View(This,pView)	\
    (This)->lpVtbl -> put_View(This,pView)

#define IDAViewerControl_get_Image(This,ppImage)	\
    (This)->lpVtbl -> get_Image(This,ppImage)

#define IDAViewerControl_put_Image(This,pImage)	\
    (This)->lpVtbl -> put_Image(This,pImage)

#define IDAViewerControl_get_BackgroundImage(This,ppImage)	\
    (This)->lpVtbl -> get_BackgroundImage(This,ppImage)

#define IDAViewerControl_put_BackgroundImage(This,pImage)	\
    (This)->lpVtbl -> put_BackgroundImage(This,pImage)

#define IDAViewerControl_get_Sound(This,ppSound)	\
    (This)->lpVtbl -> get_Sound(This,ppSound)

#define IDAViewerControl_put_Sound(This,pSound)	\
    (This)->lpVtbl -> put_Sound(This,pSound)

#define IDAViewerControl_get_PixelLibrary(This,ppStatics)	\
    (This)->lpVtbl -> get_PixelLibrary(This,ppStatics)

#define IDAViewerControl_get_MeterLibrary(This,ppStatics)	\
    (This)->lpVtbl -> get_MeterLibrary(This,ppStatics)

#define IDAViewerControl_AddBehaviorToRun(This,pBehavior)	\
    (This)->lpVtbl -> AddBehaviorToRun(This,pBehavior)

#define IDAViewerControl_Start(This)	\
    (This)->lpVtbl -> Start(This)

#define IDAViewerControl_get_InputImage(This,pVal)	\
    (This)->lpVtbl -> get_InputImage(This,pVal)

#define IDAViewerControl_get_OpaqueForHitDetect(This,b)	\
    (This)->lpVtbl -> get_OpaqueForHitDetect(This,b)

#define IDAViewerControl_put_OpaqueForHitDetect(This,b)	\
    (This)->lpVtbl -> put_OpaqueForHitDetect(This,b)

#define IDAViewerControl_get_TimerSource(This,ts)	\
    (This)->lpVtbl -> get_TimerSource(This,ts)

#define IDAViewerControl_put_TimerSource(This,ts)	\
    (This)->lpVtbl -> put_TimerSource(This,ts)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDAViewerControl_get_UpdateInterval_Proxy( 
    IDAViewerControl * This,
    /* [retval][out] */ double *pVal);



/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IDAViewerControl_put_UpdateInterval_Proxy( 
    IDAViewerControl * This,
    /* [in] */ double newVal);



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDAViewerControl_get_View_Proxy( 
    IDAViewerControl * This,
    /* [retval][out] */ IDAView **ppView);



/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IDAViewerControl_put_View_Proxy( 
    IDAViewerControl * This,
    /* [in] */ IDAView *pView);



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDAViewerControl_get_Image_Proxy( 
    IDAViewerControl * This,
    /* [retval][out] */ IDAImage **ppImage);



/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IDAViewerControl_put_Image_Proxy( 
    IDAViewerControl * This,
    /* [in] */ IDAImage *pImage);



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDAViewerControl_get_BackgroundImage_Proxy( 
    IDAViewerControl * This,
    /* [retval][out] */ IDAImage **ppImage);



/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IDAViewerControl_put_BackgroundImage_Proxy( 
    IDAViewerControl * This,
    /* [in] */ IDAImage *pImage);



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDAViewerControl_get_Sound_Proxy( 
    IDAViewerControl * This,
    /* [retval][out] */ IDASound **ppSound);



/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IDAViewerControl_put_Sound_Proxy( 
    IDAViewerControl * This,
    /* [in] */ IDASound *pSound);



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDAViewerControl_get_PixelLibrary_Proxy( 
    IDAViewerControl * This,
    /* [retval][out] */ IDAStatics **ppStatics);



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDAViewerControl_get_MeterLibrary_Proxy( 
    IDAViewerControl * This,
    /* [retval][out] */ IDAStatics **ppStatics);



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IDAViewerControl_AddBehaviorToRun_Proxy( 
    IDAViewerControl * This,
    /* [in] */ IDABehavior *pBehavior);



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IDAViewerControl_Start_Proxy( 
    IDAViewerControl * This);



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDAViewerControl_get_InputImage_Proxy( 
    IDAViewerControl * This,
    /* [retval][out] */ IDAImage **pVal);



/* [propget] */ HRESULT STDMETHODCALLTYPE IDAViewerControl_get_OpaqueForHitDetect_Proxy( 
    IDAViewerControl * This,
    /* [retval][out] */ VARIANT_BOOL *b);



/* [propput] */ HRESULT STDMETHODCALLTYPE IDAViewerControl_put_OpaqueForHitDetect_Proxy( 
    IDAViewerControl * This,
    /* [in] */ VARIANT_BOOL b);



/* [propget] */ HRESULT STDMETHODCALLTYPE IDAViewerControl_get_TimerSource_Proxy( 
    IDAViewerControl * This,
    /* [retval][out] */ DA_TIMER_SOURCE *ts);



/* [propput] */ HRESULT STDMETHODCALLTYPE IDAViewerControl_put_TimerSource_Proxy( 
    IDAViewerControl * This,
    /* [in] */ DA_TIMER_SOURCE ts);




#endif 	/* __IDAViewerControl_INTERFACE_DEFINED__ */


#ifndef __IDAViewerControlWindowed_INTERFACE_DEFINED__
#define __IDAViewerControlWindowed_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDAViewerControlWindowed
 * at Tue Nov 11 05:16:35 1997
 * using MIDL 3.02.88
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_IDAViewerControlWindowed;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("BA8B033E-1E91-11d1-8809-00C04FC29D46")
    IDAViewerControlWindowed : public IDAViewerControl
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IDAViewerControlWindowedVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDAViewerControlWindowed * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDAViewerControlWindowed * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDAViewerControlWindowed * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDAViewerControlWindowed * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDAViewerControlWindowed * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDAViewerControlWindowed * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDAViewerControlWindowed * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UpdateInterval )( 
            IDAViewerControlWindowed * This,
            /* [retval][out] */ double *pVal);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_UpdateInterval )( 
            IDAViewerControlWindowed * This,
            /* [in] */ double newVal);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_View )( 
            IDAViewerControlWindowed * This,
            /* [retval][out] */ IDAView **ppView);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_View )( 
            IDAViewerControlWindowed * This,
            /* [in] */ IDAView *pView);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Image )( 
            IDAViewerControlWindowed * This,
            /* [retval][out] */ IDAImage **ppImage);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Image )( 
            IDAViewerControlWindowed * This,
            /* [in] */ IDAImage *pImage);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_BackgroundImage )( 
            IDAViewerControlWindowed * This,
            /* [retval][out] */ IDAImage **ppImage);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_BackgroundImage )( 
            IDAViewerControlWindowed * This,
            /* [in] */ IDAImage *pImage);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Sound )( 
            IDAViewerControlWindowed * This,
            /* [retval][out] */ IDASound **ppSound);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Sound )( 
            IDAViewerControlWindowed * This,
            /* [in] */ IDASound *pSound);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PixelLibrary )( 
            IDAViewerControlWindowed * This,
            /* [retval][out] */ IDAStatics **ppStatics);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MeterLibrary )( 
            IDAViewerControlWindowed * This,
            /* [retval][out] */ IDAStatics **ppStatics);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AddBehaviorToRun )( 
            IDAViewerControlWindowed * This,
            /* [in] */ IDABehavior *pBehavior);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Start )( 
            IDAViewerControlWindowed * This);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_InputImage )( 
            IDAViewerControlWindowed * This,
            /* [retval][out] */ IDAImage **pVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_OpaqueForHitDetect )( 
            IDAViewerControlWindowed * This,
            /* [retval][out] */ VARIANT_BOOL *b);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_OpaqueForHitDetect )( 
            IDAViewerControlWindowed * This,
            /* [in] */ VARIANT_BOOL b);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_TimerSource )( 
            IDAViewerControlWindowed * This,
            /* [retval][out] */ DA_TIMER_SOURCE *ts);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_TimerSource )( 
            IDAViewerControlWindowed * This,
            /* [in] */ DA_TIMER_SOURCE ts);
        
        END_INTERFACE
    } IDAViewerControlWindowedVtbl;

    interface IDAViewerControlWindowed
    {
        CONST_VTBL struct IDAViewerControlWindowedVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDAViewerControlWindowed_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDAViewerControlWindowed_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDAViewerControlWindowed_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDAViewerControlWindowed_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDAViewerControlWindowed_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDAViewerControlWindowed_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDAViewerControlWindowed_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDAViewerControlWindowed_get_UpdateInterval(This,pVal)	\
    (This)->lpVtbl -> get_UpdateInterval(This,pVal)

#define IDAViewerControlWindowed_put_UpdateInterval(This,newVal)	\
    (This)->lpVtbl -> put_UpdateInterval(This,newVal)

#define IDAViewerControlWindowed_get_View(This,ppView)	\
    (This)->lpVtbl -> get_View(This,ppView)

#define IDAViewerControlWindowed_put_View(This,pView)	\
    (This)->lpVtbl -> put_View(This,pView)

#define IDAViewerControlWindowed_get_Image(This,ppImage)	\
    (This)->lpVtbl -> get_Image(This,ppImage)

#define IDAViewerControlWindowed_put_Image(This,pImage)	\
    (This)->lpVtbl -> put_Image(This,pImage)

#define IDAViewerControlWindowed_get_BackgroundImage(This,ppImage)	\
    (This)->lpVtbl -> get_BackgroundImage(This,ppImage)

#define IDAViewerControlWindowed_put_BackgroundImage(This,pImage)	\
    (This)->lpVtbl -> put_BackgroundImage(This,pImage)

#define IDAViewerControlWindowed_get_Sound(This,ppSound)	\
    (This)->lpVtbl -> get_Sound(This,ppSound)

#define IDAViewerControlWindowed_put_Sound(This,pSound)	\
    (This)->lpVtbl -> put_Sound(This,pSound)

#define IDAViewerControlWindowed_get_PixelLibrary(This,ppStatics)	\
    (This)->lpVtbl -> get_PixelLibrary(This,ppStatics)

#define IDAViewerControlWindowed_get_MeterLibrary(This,ppStatics)	\
    (This)->lpVtbl -> get_MeterLibrary(This,ppStatics)

#define IDAViewerControlWindowed_AddBehaviorToRun(This,pBehavior)	\
    (This)->lpVtbl -> AddBehaviorToRun(This,pBehavior)

#define IDAViewerControlWindowed_Start(This)	\
    (This)->lpVtbl -> Start(This)

#define IDAViewerControlWindowed_get_InputImage(This,pVal)	\
    (This)->lpVtbl -> get_InputImage(This,pVal)

#define IDAViewerControlWindowed_get_OpaqueForHitDetect(This,b)	\
    (This)->lpVtbl -> get_OpaqueForHitDetect(This,b)

#define IDAViewerControlWindowed_put_OpaqueForHitDetect(This,b)	\
    (This)->lpVtbl -> put_OpaqueForHitDetect(This,b)

#define IDAViewerControlWindowed_get_TimerSource(This,ts)	\
    (This)->lpVtbl -> get_TimerSource(This,ts)

#define IDAViewerControlWindowed_put_TimerSource(This,ts)	\
    (This)->lpVtbl -> put_TimerSource(This,ts)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDAViewerControlWindowed_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_DAViewerControl;

#ifdef __cplusplus

class DECLSPEC_UUID("B6FFC24C-7E13-11D0-9B47-00C04FC2F51D")
DAViewerControl;
#endif

EXTERN_C const CLSID CLSID_DAViewerControlWindowed;

#ifdef __cplusplus

class DECLSPEC_UUID("69AD90EF-1C20-11d1-8801-00C04FC29D46")
DAViewerControlWindowed;
#endif
#endif /* __DirectAnimation_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\DAnimId.h ===
// Copyright (C) Microsoft Corporation, 1998
//
// IDs for DANIM Events
//
// Just follow the template when adding either DISPIDs or new interfaces.
//

#ifndef __DANIMDISPID_H__
#define __DANIMDISPID_H__

// Base offset:

#define DISPID_BASE                                             0x00000000

// Interface offsets:
#define DAVIEWERCONTROL_OFFSET                                  0x1000
#define DAVIEW_OFFSET                                           0x2000

// Interface bases:
#define DISPID_DANIMEVENT_BASE                                  (DISPID_BASE + DAVIEWERCONTROL_OFFSET)
#define DISPID_VIEWEVENT_BASE                                   (DISPID_BASE + DAVIEW_OFFSET)

// DAVIEWERCONTROL DISPIDs:
#define DISPID_DANIMEVENT_START                          (DISPID_DANIMEVENT_BASE + 0x01)
#define DISPID_DANIMEVENT_MOUSEUP                        (DISPID_DANIMEVENT_BASE + 0x02)
#define DISPID_DANIMEVENT_MOUSEDOWN                      (DISPID_DANIMEVENT_BASE + 0x03)
#define DISPID_DANIMEVENT_MOUSEMOVE                      (DISPID_DANIMEVENT_BASE + 0x04)
#define DISPID_DANIMEVENT_CLICK                          (DISPID_DANIMEVENT_BASE + 0x05)
#define DISPID_DANIMEVENT_KEYPRESS                       (DISPID_DANIMEVENT_BASE + 0x06)
#define DISPID_DANIMEVENT_KEYUP                          (DISPID_DANIMEVENT_BASE + 0x07)
#define DISPID_DANIMEVENT_KEYDOWN                        (DISPID_DANIMEVENT_BASE + 0x08)
#define DISPID_DANIMEVENT_ERROR                          (DISPID_DANIMEVENT_BASE + 0x09)
#define DISPID_DANIMEVENT_STOP                           (DISPID_DANIMEVENT_BASE + 0x0A)
#define DISPID_DANIMEVENT_PAUSE                          (DISPID_DANIMEVENT_BASE + 0x0B)
#define DISPID_DANIMEVENT_RESUME                         (DISPID_DANIMEVENT_BASE + 0x0C)

//VIEW DISPIDS
#define DISPID_VIEWEVENT_START                                  (DISPID_VIEWEVENT_BASE + 0x01)
#define DISPID_VIEWEVENT_STOP                                   (DISPID_VIEWEVENT_BASE + 0x02)
#define DISPID_VIEWEVENT_ONMOUSEMOVE                            (DISPID_VIEWEVENT_BASE + 0x03)
#define DISPID_VIEWEVENT_ONMOUSEBUTTON                          (DISPID_VIEWEVENT_BASE + 0x04)
#define DISPID_VIEWEVENT_ONKEY                                  (DISPID_VIEWEVENT_BASE + 0x05)
#define DISPID_VIEWEVENT_ONFOCUS                                (DISPID_VIEWEVENT_BASE + 0x06)
#define DISPID_VIEWEVENT_PAUSE                                  (DISPID_VIEWEVENT_BASE + 0x07)
#define DISPID_VIEWEVENT_RESUME                                 (DISPID_VIEWEVENT_BASE + 0x08)
#define DISPID_VIEWEVENT_ERROR                                  (DISPID_VIEWEVENT_BASE + 0x09)

#endif  //__DANIMDISPID_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\Danim_i.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 5.02.0235 */
/* at Wed Apr 21 13:46:42 1999
 */
/* Compiler settings for Danim.Idl:
    Os (OptLev=s), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, LIBID_DirectAnimation,0x34f681d0,0x3640,0x11cf,0x92,0x94,0x00,0xaa,0x00,0xb8,0xa7,0x33);


MIDL_DEFINE_GUID(IID, IID_IDAViewSite,0x283807B3,0x2C60,0x11d0,0xA3,0x1D,0x00,0xAA,0x00,0xB9,0x2C,0x03);


MIDL_DEFINE_GUID(IID, IID_IDAView,0x283807B4,0x2C60,0x11d0,0xA3,0x1D,0x00,0xAA,0x00,0xB9,0x2C,0x03);


MIDL_DEFINE_GUID(IID, IID_IDABehavior,0x283807B7,0x2C60,0x11d0,0xA3,0x1D,0x00,0xAA,0x00,0xB9,0x2C,0x03);


MIDL_DEFINE_GUID(IID, IID_IDANumber,0x9CDE7340,0x3C20,0x11d0,0xA3,0x30,0x00,0xAA,0x00,0xB9,0x2C,0x03);


MIDL_DEFINE_GUID(IID, IID_IDABvrHook,0x3E2487C4,0x8709,0x11d0,0xB1,0x77,0x00,0xC0,0x4F,0xC2,0xA0,0xCA);


MIDL_DEFINE_GUID(IID, IID_IDADrawingSurface,0xBC0BFD34,0xD21D,0x11d0,0x93,0x85,0x00,0xC0,0x4F,0xB6,0xBD,0x36);


MIDL_DEFINE_GUID(IID, IID_IDAPickableResult,0x4A933703,0xE36F,0x11d0,0x9B,0x99,0x00,0xC0,0x4F,0xC2,0xF5,0x1D);


MIDL_DEFINE_GUID(IID, IID_IDAEvent,0x50B4791E,0x4731,0x11d0,0x89,0x12,0x00,0xC0,0x4F,0xC2,0xA0,0xCA);


MIDL_DEFINE_GUID(IID, IID_IDA2Behavior,0x9CADDC0C,0xAD56,0x11d1,0x9F,0xF8,0x00,0xC0,0x4F,0xA3,0x21,0x95);


MIDL_DEFINE_GUID(IID, IID_IDAImport,0xFC54BEAA,0x5B12,0x11d1,0x8E,0x7B,0x00,0xC0,0x4F,0xC2,0x9D,0x46);


MIDL_DEFINE_GUID(IID, IID_IDAModifiableBehavior,0xFC54BEAB,0x5B12,0x11d1,0x8E,0x7B,0x00,0xC0,0x4F,0xC2,0x9D,0x46);


MIDL_DEFINE_GUID(CLSID, CLSID_DABehavior,0x283807B8,0x2C60,0x11d0,0xA3,0x1D,0x00,0xAA,0x00,0xB9,0x2C,0x03);


MIDL_DEFINE_GUID(IID, IID_IDAUntilNotifier,0x3F3DA01A,0x4705,0x11d0,0x87,0x10,0x00,0xC0,0x4F,0xC2,0x9D,0x46);


MIDL_DEFINE_GUID(IID, IID_IDABoolean,0xC46C1BC0,0x3C52,0x11d0,0x92,0x00,0x84,0x8C,0x1D,0x00,0x00,0x00);


MIDL_DEFINE_GUID(IID, IID_IDACamera,0xC46C1BE1,0x3C52,0x11d0,0x92,0x00,0x84,0x8C,0x1D,0x00,0x00,0x00);


MIDL_DEFINE_GUID(IID, IID_IDAColor,0xC46C1BC5,0x3C52,0x11d0,0x92,0x00,0x84,0x8C,0x1D,0x00,0x00,0x00);


MIDL_DEFINE_GUID(IID, IID_IDAGeometry,0xC46C1BDF,0x3C52,0x11d0,0x92,0x00,0x84,0x8C,0x1D,0x00,0x00,0x00);


MIDL_DEFINE_GUID(IID, IID_IDAImage,0xC46C1BD3,0x3C52,0x11d0,0x92,0x00,0x84,0x8C,0x1D,0x00,0x00,0x00);


MIDL_DEFINE_GUID(IID, IID_IDAMatte,0xC46C1BD1,0x3C52,0x11d0,0x92,0x00,0x84,0x8C,0x1D,0x00,0x00,0x00);


MIDL_DEFINE_GUID(IID, IID_IDAMicrophone,0xC46C1BE5,0x3C52,0x11d0,0x92,0x00,0x84,0x8C,0x1D,0x00,0x00,0x00);


MIDL_DEFINE_GUID(IID, IID_IDAMontage,0xC46C1BD5,0x3C52,0x11d0,0x92,0x00,0x84,0x8C,0x1D,0x00,0x00,0x00);


MIDL_DEFINE_GUID(IID, IID_IDAPath2,0xC46C1BCF,0x3C52,0x11d0,0x92,0x00,0x84,0x8C,0x1D,0x00,0x00,0x00);


MIDL_DEFINE_GUID(IID, IID_IDAPoint2,0xC46C1BC7,0x3C52,0x11d0,0x92,0x00,0x84,0x8C,0x1D,0x00,0x00,0x00);


MIDL_DEFINE_GUID(IID, IID_IDAPoint3,0xC46C1BD7,0x3C52,0x11d0,0x92,0x00,0x84,0x8C,0x1D,0x00,0x00,0x00);


MIDL_DEFINE_GUID(IID, IID_IDASound,0xC46C1BE3,0x3C52,0x11d0,0x92,0x00,0x84,0x8C,0x1D,0x00,0x00,0x00);


MIDL_DEFINE_GUID(IID, IID_IDAString,0xC46C1BC3,0x3C52,0x11d0,0x92,0x00,0x84,0x8C,0x1D,0x00,0x00,0x00);


MIDL_DEFINE_GUID(IID, IID_IDATransform2,0xC46C1BCB,0x3C52,0x11d0,0x92,0x00,0x84,0x8C,0x1D,0x00,0x00,0x00);


MIDL_DEFINE_GUID(IID, IID_IDATransform3,0xC46C1BDB,0x3C52,0x11d0,0x92,0x00,0x84,0x8C,0x1D,0x00,0x00,0x00);


MIDL_DEFINE_GUID(IID, IID_IDAVector2,0xC46C1BC9,0x3C52,0x11d0,0x92,0x00,0x84,0x8C,0x1D,0x00,0x00,0x00);


MIDL_DEFINE_GUID(IID, IID_IDAVector3,0xC46C1BD9,0x3C52,0x11d0,0x92,0x00,0x84,0x8C,0x1D,0x00,0x00,0x00);


MIDL_DEFINE_GUID(IID, IID_IDAFontStyle,0x25B0F91D,0xD23D,0x11d0,0x9B,0x85,0x00,0xC0,0x4F,0xC2,0xF5,0x1D);


MIDL_DEFINE_GUID(IID, IID_IDALineStyle,0xC46C1BF1,0x3C52,0x11d0,0x92,0x00,0x84,0x8C,0x1D,0x00,0x00,0x00);


MIDL_DEFINE_GUID(IID, IID_IDAEndStyle,0xC46C1BEB,0x3C52,0x11d0,0x92,0x00,0x84,0x8C,0x1D,0x00,0x00,0x00);


MIDL_DEFINE_GUID(IID, IID_IDAJoinStyle,0xC46C1BED,0x3C52,0x11d0,0x92,0x00,0x84,0x8C,0x1D,0x00,0x00,0x00);


MIDL_DEFINE_GUID(IID, IID_IDADashStyle,0xC46C1BEF,0x3C52,0x11d0,0x92,0x00,0x84,0x8C,0x1D,0x00,0x00,0x00);


MIDL_DEFINE_GUID(IID, IID_IDABbox2,0xC46C1BCD,0x3C52,0x11d0,0x92,0x00,0x84,0x8C,0x1D,0x00,0x00,0x00);


MIDL_DEFINE_GUID(IID, IID_IDABbox3,0xC46C1BDD,0x3C52,0x11d0,0x92,0x00,0x84,0x8C,0x1D,0x00,0x00,0x00);


MIDL_DEFINE_GUID(IID, IID_IDAPair,0xC46C1BF3,0x3C52,0x11d0,0x92,0x00,0x84,0x8C,0x1D,0x00,0x00,0x00);


MIDL_DEFINE_GUID(IID, IID_IDAArray,0xD17506C2,0x6B26,0x11d0,0x89,0x14,0x00,0xC0,0x4F,0xC2,0xA0,0xCA);


MIDL_DEFINE_GUID(IID, IID_IDATuple,0x5DFB2650,0x9668,0x11d0,0xB1,0x7B,0x00,0xC0,0x4F,0xC2,0xA0,0xCA);


MIDL_DEFINE_GUID(IID, IID_IDAUserData,0xAF868305,0xAB0B,0x11d0,0x87,0x6A,0x00,0xC0,0x4F,0xC2,0x9D,0x46);


MIDL_DEFINE_GUID(IID, IID_IDA2Geometry,0xB90E5258,0x574A,0x11d1,0x8E,0x7B,0x00,0xC0,0x4F,0xC2,0x9D,0x46);


MIDL_DEFINE_GUID(IID, IID_IDA2Image,0xB90E5259,0x574A,0x11d1,0x8E,0x7B,0x00,0xC0,0x4F,0xC2,0x9D,0x46);


MIDL_DEFINE_GUID(IID, IID_IDA2FontStyle,0x960D8EFF,0xE494,0x11d1,0xAB,0x75,0x00,0xC0,0x4F,0xD9,0x2B,0x6B);


MIDL_DEFINE_GUID(IID, IID_IDA2LineStyle,0x5F00F545,0xDF18,0x11d1,0xAB,0x6F,0x00,0xC0,0x4F,0xD9,0x2B,0x6B);


MIDL_DEFINE_GUID(IID, IID_IDA2Event,0xB90E525A,0x574A,0x11d1,0x8E,0x7B,0x00,0xC0,0x4F,0xC2,0x9D,0x46);


MIDL_DEFINE_GUID(IID, IID_IDA2Array,0x2A8F0B06,0xBE2B,0x11d1,0xB2,0x19,0x00,0xC0,0x4F,0xC2,0xA0,0xCA);


MIDL_DEFINE_GUID(IID, IID_IDAPreferences,0x69B5BC70,0x9B19,0x11d0,0x9B,0x60,0x00,0xC0,0x4F,0xC2,0xF5,0x1D);


MIDL_DEFINE_GUID(IID, IID_IDA2View,0x2AE71568,0x4B34,0x11d1,0xB1,0xE3,0x00,0xC0,0x4F,0xC2,0xA0,0xCA);


MIDL_DEFINE_GUID(CLSID, CLSID_DAView,0x283807B5,0x2C60,0x11d0,0xA3,0x1D,0x00,0xAA,0x00,0xB9,0x2C,0x03);


MIDL_DEFINE_GUID(IID, IID_IDASite,0x45393DF0,0x54B9,0x11cf,0x92,0xA2,0x00,0xAA,0x00,0xB8,0xA7,0x33);


MIDL_DEFINE_GUID(IID, IID_IDAImportationResult,0x4A933702,0xE36F,0x11d0,0x9B,0x99,0x00,0xC0,0x4F,0xC2,0xF5,0x1D);


MIDL_DEFINE_GUID(IID, IID_IDADXTransformResult,0xBACD4D86,0x4A4F,0x11d1,0x9B,0xC8,0x00,0xC0,0x4F,0xC2,0xF5,0x1D);


MIDL_DEFINE_GUID(IID, IID_IDAStatics,0x542FB452,0x5003,0x11cf,0x92,0xA2,0x00,0xAA,0x00,0xB8,0xA7,0x33);


MIDL_DEFINE_GUID(IID, IID_IDA2Statics,0xFA261CF0,0xC44E,0x11d1,0x9B,0xE4,0x00,0xC0,0x4F,0xC2,0xF5,0x1D);


MIDL_DEFINE_GUID(CLSID, CLSID_DAStatics,0x542FB453,0x5003,0x11cf,0x92,0xA2,0x00,0xAA,0x00,0xB8,0xA7,0x33);


MIDL_DEFINE_GUID(IID, IID_IDAViewerControl,0x0E41257B,0x812D,0x11D0,0x9B,0x4A,0x00,0xC0,0x4F,0xC2,0xF5,0x1D);


MIDL_DEFINE_GUID(IID, IID_IDAViewerControlWindowed,0xBA8B033E,0x1E91,0x11d1,0x88,0x09,0x00,0xC0,0x4F,0xC2,0x9D,0x46);


MIDL_DEFINE_GUID(IID, IID_IDA2ViewerControl,0xF3E1B522,0xD8A6,0x11d1,0x9B,0xE5,0x00,0xC0,0x4F,0xC2,0xF5,0x1D);


MIDL_DEFINE_GUID(IID, IID_IDA2ViewerControlWindowed,0xA3034056,0xEC1C,0x11d1,0x9B,0xE8,0x00,0xC0,0x4F,0xC2,0xF5,0x1D);


MIDL_DEFINE_GUID(CLSID, CLSID_DAViewerControl,0xB6FFC24C,0x7E13,0x11D0,0x9B,0x47,0x00,0xC0,0x4F,0xC2,0xF5,0x1D);


MIDL_DEFINE_GUID(CLSID, CLSID_DAViewerControlWindowed,0x69AD90EF,0x1C20,0x11d1,0x88,0x01,0x00,0xC0,0x4F,0xC2,0x9D,0x46);


MIDL_DEFINE_GUID(CLSID, CLSID_DABoolean,0xC46C1BC1,0x3C52,0x11d0,0x92,0x00,0x84,0x8C,0x1D,0x00,0x00,0x00);


MIDL_DEFINE_GUID(CLSID, CLSID_DACamera,0xC46C1BE2,0x3C52,0x11d0,0x92,0x00,0x84,0x8C,0x1D,0x00,0x00,0x00);


MIDL_DEFINE_GUID(CLSID, CLSID_DAColor,0xC46C1BC6,0x3C52,0x11d0,0x92,0x00,0x84,0x8C,0x1D,0x00,0x00,0x00);


MIDL_DEFINE_GUID(CLSID, CLSID_DAGeometry,0xC46C1BE0,0x3C52,0x11d0,0x92,0x00,0x84,0x8C,0x1D,0x00,0x00,0x00);


MIDL_DEFINE_GUID(CLSID, CLSID_DAImage,0xC46C1BD4,0x3C52,0x11d0,0x92,0x00,0x84,0x8C,0x1D,0x00,0x00,0x00);


MIDL_DEFINE_GUID(CLSID, CLSID_DAMatte,0xC46C1BD2,0x3C52,0x11d0,0x92,0x00,0x84,0x8C,0x1D,0x00,0x00,0x00);


MIDL_DEFINE_GUID(CLSID, CLSID_DAMicrophone,0xC46C1BE6,0x3C52,0x11d0,0x92,0x00,0x84,0x8C,0x1D,0x00,0x00,0x00);


MIDL_DEFINE_GUID(CLSID, CLSID_DAMontage,0xC46C1BD6,0x3C52,0x11d0,0x92,0x00,0x84,0x8C,0x1D,0x00,0x00,0x00);


MIDL_DEFINE_GUID(CLSID, CLSID_DANumber,0x9CDE7341,0x3C20,0x11d0,0xA3,0x30,0x00,0xAA,0x00,0xB9,0x2C,0x03);


MIDL_DEFINE_GUID(CLSID, CLSID_DAPath2,0xC46C1BD0,0x3C52,0x11d0,0x92,0x00,0x84,0x8C,0x1D,0x00,0x00,0x00);


MIDL_DEFINE_GUID(CLSID, CLSID_DAPoint2,0xC46C1BC8,0x3C52,0x11d0,0x92,0x00,0x84,0x8C,0x1D,0x00,0x00,0x00);


MIDL_DEFINE_GUID(CLSID, CLSID_DAPoint3,0xC46C1BD8,0x3C52,0x11d0,0x92,0x00,0x84,0x8C,0x1D,0x00,0x00,0x00);


MIDL_DEFINE_GUID(CLSID, CLSID_DASound,0xC46C1BE4,0x3C52,0x11d0,0x92,0x00,0x84,0x8C,0x1D,0x00,0x00,0x00);


MIDL_DEFINE_GUID(CLSID, CLSID_DAString,0xC46C1BC4,0x3C52,0x11d0,0x92,0x00,0x84,0x8C,0x1D,0x00,0x00,0x00);


MIDL_DEFINE_GUID(CLSID, CLSID_DATransform2,0xC46C1BCC,0x3C52,0x11d0,0x92,0x00,0x84,0x8C,0x1D,0x00,0x00,0x00);


MIDL_DEFINE_GUID(CLSID, CLSID_DATransform3,0xC46C1BDC,0x3C52,0x11d0,0x92,0x00,0x84,0x8C,0x1D,0x00,0x00,0x00);


MIDL_DEFINE_GUID(CLSID, CLSID_DAVector2,0xC46C1BCA,0x3C52,0x11d0,0x92,0x00,0x84,0x8C,0x1D,0x00,0x00,0x00);


MIDL_DEFINE_GUID(CLSID, CLSID_DAVector3,0xC46C1BDA,0x3C52,0x11d0,0x92,0x00,0x84,0x8C,0x1D,0x00,0x00,0x00);


MIDL_DEFINE_GUID(CLSID, CLSID_DAFontStyle,0x25B0F91C,0xD23D,0x11d0,0x9B,0x85,0x00,0xC0,0x4F,0xC2,0xF5,0x1D);


MIDL_DEFINE_GUID(CLSID, CLSID_DALineStyle,0xC46C1BF2,0x3C52,0x11d0,0x92,0x00,0x84,0x8C,0x1D,0x00,0x00,0x00);


MIDL_DEFINE_GUID(CLSID, CLSID_DAEndStyle,0xC46C1BEC,0x3C52,0x11d0,0x92,0x00,0x84,0x8C,0x1D,0x00,0x00,0x00);


MIDL_DEFINE_GUID(CLSID, CLSID_DAJoinStyle,0xC46C1BEE,0x3C52,0x11d0,0x92,0x00,0x84,0x8C,0x1D,0x00,0x00,0x00);


MIDL_DEFINE_GUID(CLSID, CLSID_DADashStyle,0xC46C1BF0,0x3C52,0x11d0,0x92,0x00,0x84,0x8C,0x1D,0x00,0x00,0x00);


MIDL_DEFINE_GUID(CLSID, CLSID_DABbox2,0xC46C1BCE,0x3C52,0x11d0,0x92,0x00,0x84,0x8C,0x1D,0x00,0x00,0x00);


MIDL_DEFINE_GUID(CLSID, CLSID_DABbox3,0xC46C1BDE,0x3C52,0x11d0,0x92,0x00,0x84,0x8C,0x1D,0x00,0x00,0x00);


MIDL_DEFINE_GUID(CLSID, CLSID_DAPair,0xC46C1BF4,0x3C52,0x11d0,0x92,0x00,0x84,0x8C,0x1D,0x00,0x00,0x00);


MIDL_DEFINE_GUID(CLSID, CLSID_DAEvent,0x50B4791F,0x4731,0x11d0,0x89,0x12,0x00,0xC0,0x4F,0xC2,0xA0,0xCA);


MIDL_DEFINE_GUID(CLSID, CLSID_DAArray,0xD17506C3,0x6B26,0x11d0,0x89,0x14,0x00,0xC0,0x4F,0xC2,0xA0,0xCA);


MIDL_DEFINE_GUID(CLSID, CLSID_DATuple,0x5DFB2651,0x9668,0x11d0,0xB1,0x7B,0x00,0xC0,0x4F,0xC2,0xA0,0xCA);


MIDL_DEFINE_GUID(CLSID, CLSID_DAUserData,0xAF868304,0xAB0B,0x11d0,0x87,0x6A,0x00,0xC0,0x4F,0xC2,0x9D,0x46);


MIDL_DEFINE_GUID(CLSID, CLSID_DAImportationResult,0xBCBB1F75,0xE384,0x11d0,0x9B,0x99,0x00,0xC0,0x4F,0xC2,0xF5,0x1D);


MIDL_DEFINE_GUID(CLSID, CLSID_DAPickableResult,0xBCBB1F74,0xE384,0x11d0,0x9B,0x99,0x00,0xC0,0x4F,0xC2,0xF5,0x1D);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AXP64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 5.02.0235 */
/* at Wed Apr 21 13:46:45 1999
 */
/* Compiler settings for Danim.Idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win64 (32b run,appending), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, LIBID_DirectAnimation,0x34f681d0,0x3640,0x11cf,0x92,0x94,0x00,0xaa,0x00,0xb8,0xa7,0x33);


MIDL_DEFINE_GUID(IID, IID_IDAViewSite,0x283807B3,0x2C60,0x11d0,0xA3,0x1D,0x00,0xAA,0x00,0xB9,0x2C,0x03);


MIDL_DEFINE_GUID(IID, IID_IDAView,0x283807B4,0x2C60,0x11d0,0xA3,0x1D,0x00,0xAA,0x00,0xB9,0x2C,0x03);


MIDL_DEFINE_GUID(IID, IID_IDABehavior,0x283807B7,0x2C60,0x11d0,0xA3,0x1D,0x00,0xAA,0x00,0xB9,0x2C,0x03);


MIDL_DEFINE_GUID(IID, IID_IDANumber,0x9CDE7340,0x3C20,0x11d0,0xA3,0x30,0x00,0xAA,0x00,0xB9,0x2C,0x03);


MIDL_DEFINE_GUID(IID, IID_IDABvrHook,0x3E2487C4,0x8709,0x11d0,0xB1,0x77,0x00,0xC0,0x4F,0xC2,0xA0,0xCA);


MIDL_DEFINE_GUID(IID, IID_IDADrawingSurface,0xBC0BFD34,0xD21D,0x11d0,0x93,0x85,0x00,0xC0,0x4F,0xB6,0xBD,0x36);


MIDL_DEFINE_GUID(IID, IID_IDAPickableResult,0x4A933703,0xE36F,0x11d0,0x9B,0x99,0x00,0xC0,0x4F,0xC2,0xF5,0x1D);


MIDL_DEFINE_GUID(IID, IID_IDAEvent,0x50B4791E,0x4731,0x11d0,0x89,0x12,0x00,0xC0,0x4F,0xC2,0xA0,0xCA);


MIDL_DEFINE_GUID(IID, IID_IDA2Behavior,0x9CADDC0C,0xAD56,0x11d1,0x9F,0xF8,0x00,0xC0,0x4F,0xA3,0x21,0x95);


MIDL_DEFINE_GUID(IID, IID_IDAImport,0xFC54BEAA,0x5B12,0x11d1,0x8E,0x7B,0x00,0xC0,0x4F,0xC2,0x9D,0x46);


MIDL_DEFINE_GUID(IID, IID_IDAModifiableBehavior,0xFC54BEAB,0x5B12,0x11d1,0x8E,0x7B,0x00,0xC0,0x4F,0xC2,0x9D,0x46);


MIDL_DEFINE_GUID(CLSID, CLSID_DABehavior,0x283807B8,0x2C60,0x11d0,0xA3,0x1D,0x00,0xAA,0x00,0xB9,0x2C,0x03);


MIDL_DEFINE_GUID(IID, IID_IDAUntilNotifier,0x3F3DA01A,0x4705,0x11d0,0x87,0x10,0x00,0xC0,0x4F,0xC2,0x9D,0x46);


MIDL_DEFINE_GUID(IID, IID_IDABoolean,0xC46C1BC0,0x3C52,0x11d0,0x92,0x00,0x84,0x8C,0x1D,0x00,0x00,0x00);


MIDL_DEFINE_GUID(IID, IID_IDACamera,0xC46C1BE1,0x3C52,0x11d0,0x92,0x00,0x84,0x8C,0x1D,0x00,0x00,0x00);


MIDL_DEFINE_GUID(IID, IID_IDAColor,0xC46C1BC5,0x3C52,0x11d0,0x92,0x00,0x84,0x8C,0x1D,0x00,0x00,0x00);


MIDL_DEFINE_GUID(IID, IID_IDAGeometry,0xC46C1BDF,0x3C52,0x11d0,0x92,0x00,0x84,0x8C,0x1D,0x00,0x00,0x00);


MIDL_DEFINE_GUID(IID, IID_IDAImage,0xC46C1BD3,0x3C52,0x11d0,0x92,0x00,0x84,0x8C,0x1D,0x00,0x00,0x00);


MIDL_DEFINE_GUID(IID, IID_IDAMatte,0xC46C1BD1,0x3C52,0x11d0,0x92,0x00,0x84,0x8C,0x1D,0x00,0x00,0x00);


MIDL_DEFINE_GUID(IID, IID_IDAMicrophone,0xC46C1BE5,0x3C52,0x11d0,0x92,0x00,0x84,0x8C,0x1D,0x00,0x00,0x00);


MIDL_DEFINE_GUID(IID, IID_IDAMontage,0xC46C1BD5,0x3C52,0x11d0,0x92,0x00,0x84,0x8C,0x1D,0x00,0x00,0x00);


MIDL_DEFINE_GUID(IID, IID_IDAPath2,0xC46C1BCF,0x3C52,0x11d0,0x92,0x00,0x84,0x8C,0x1D,0x00,0x00,0x00);


MIDL_DEFINE_GUID(IID, IID_IDAPoint2,0xC46C1BC7,0x3C52,0x11d0,0x92,0x00,0x84,0x8C,0x1D,0x00,0x00,0x00);


MIDL_DEFINE_GUID(IID, IID_IDAPoint3,0xC46C1BD7,0x3C52,0x11d0,0x92,0x00,0x84,0x8C,0x1D,0x00,0x00,0x00);


MIDL_DEFINE_GUID(IID, IID_IDASound,0xC46C1BE3,0x3C52,0x11d0,0x92,0x00,0x84,0x8C,0x1D,0x00,0x00,0x00);


MIDL_DEFINE_GUID(IID, IID_IDAString,0xC46C1BC3,0x3C52,0x11d0,0x92,0x00,0x84,0x8C,0x1D,0x00,0x00,0x00);


MIDL_DEFINE_GUID(IID, IID_IDATransform2,0xC46C1BCB,0x3C52,0x11d0,0x92,0x00,0x84,0x8C,0x1D,0x00,0x00,0x00);


MIDL_DEFINE_GUID(IID, IID_IDATransform3,0xC46C1BDB,0x3C52,0x11d0,0x92,0x00,0x84,0x8C,0x1D,0x00,0x00,0x00);


MIDL_DEFINE_GUID(IID, IID_IDAVector2,0xC46C1BC9,0x3C52,0x11d0,0x92,0x00,0x84,0x8C,0x1D,0x00,0x00,0x00);


MIDL_DEFINE_GUID(IID, IID_IDAVector3,0xC46C1BD9,0x3C52,0x11d0,0x92,0x00,0x84,0x8C,0x1D,0x00,0x00,0x00);


MIDL_DEFINE_GUID(IID, IID_IDAFontStyle,0x25B0F91D,0xD23D,0x11d0,0x9B,0x85,0x00,0xC0,0x4F,0xC2,0xF5,0x1D);


MIDL_DEFINE_GUID(IID, IID_IDALineStyle,0xC46C1BF1,0x3C52,0x11d0,0x92,0x00,0x84,0x8C,0x1D,0x00,0x00,0x00);


MIDL_DEFINE_GUID(IID, IID_IDAEndStyle,0xC46C1BEB,0x3C52,0x11d0,0x92,0x00,0x84,0x8C,0x1D,0x00,0x00,0x00);


MIDL_DEFINE_GUID(IID, IID_IDAJoinStyle,0xC46C1BED,0x3C52,0x11d0,0x92,0x00,0x84,0x8C,0x1D,0x00,0x00,0x00);


MIDL_DEFINE_GUID(IID, IID_IDADashStyle,0xC46C1BEF,0x3C52,0x11d0,0x92,0x00,0x84,0x8C,0x1D,0x00,0x00,0x00);


MIDL_DEFINE_GUID(IID, IID_IDABbox2,0xC46C1BCD,0x3C52,0x11d0,0x92,0x00,0x84,0x8C,0x1D,0x00,0x00,0x00);


MIDL_DEFINE_GUID(IID, IID_IDABbox3,0xC46C1BDD,0x3C52,0x11d0,0x92,0x00,0x84,0x8C,0x1D,0x00,0x00,0x00);


MIDL_DEFINE_GUID(IID, IID_IDAPair,0xC46C1BF3,0x3C52,0x11d0,0x92,0x00,0x84,0x8C,0x1D,0x00,0x00,0x00);


MIDL_DEFINE_GUID(IID, IID_IDAArray,0xD17506C2,0x6B26,0x11d0,0x89,0x14,0x00,0xC0,0x4F,0xC2,0xA0,0xCA);


MIDL_DEFINE_GUID(IID, IID_IDATuple,0x5DFB2650,0x9668,0x11d0,0xB1,0x7B,0x00,0xC0,0x4F,0xC2,0xA0,0xCA);


MIDL_DEFINE_GUID(IID, IID_IDAUserData,0xAF868305,0xAB0B,0x11d0,0x87,0x6A,0x00,0xC0,0x4F,0xC2,0x9D,0x46);


MIDL_DEFINE_GUID(IID, IID_IDA2Geometry,0xB90E5258,0x574A,0x11d1,0x8E,0x7B,0x00,0xC0,0x4F,0xC2,0x9D,0x46);


MIDL_DEFINE_GUID(IID, IID_IDA2Image,0xB90E5259,0x574A,0x11d1,0x8E,0x7B,0x00,0xC0,0x4F,0xC2,0x9D,0x46);


MIDL_DEFINE_GUID(IID, IID_IDA2FontStyle,0x960D8EFF,0xE494,0x11d1,0xAB,0x75,0x00,0xC0,0x4F,0xD9,0x2B,0x6B);


MIDL_DEFINE_GUID(IID, IID_IDA2LineStyle,0x5F00F545,0xDF18,0x11d1,0xAB,0x6F,0x00,0xC0,0x4F,0xD9,0x2B,0x6B);


MIDL_DEFINE_GUID(IID, IID_IDA2Event,0xB90E525A,0x574A,0x11d1,0x8E,0x7B,0x00,0xC0,0x4F,0xC2,0x9D,0x46);


MIDL_DEFINE_GUID(IID, IID_IDA2Array,0x2A8F0B06,0xBE2B,0x11d1,0xB2,0x19,0x00,0xC0,0x4F,0xC2,0xA0,0xCA);


MIDL_DEFINE_GUID(IID, IID_IDAPreferences,0x69B5BC70,0x9B19,0x11d0,0x9B,0x60,0x00,0xC0,0x4F,0xC2,0xF5,0x1D);


MIDL_DEFINE_GUID(IID, IID_IDA2View,0x2AE71568,0x4B34,0x11d1,0xB1,0xE3,0x00,0xC0,0x4F,0xC2,0xA0,0xCA);


MIDL_DEFINE_GUID(CLSID, CLSID_DAView,0x283807B5,0x2C60,0x11d0,0xA3,0x1D,0x00,0xAA,0x00,0xB9,0x2C,0x03);


MIDL_DEFINE_GUID(IID, IID_IDASite,0x45393DF0,0x54B9,0x11cf,0x92,0xA2,0x00,0xAA,0x00,0xB8,0xA7,0x33);


MIDL_DEFINE_GUID(IID, IID_IDAImportationResult,0x4A933702,0xE36F,0x11d0,0x9B,0x99,0x00,0xC0,0x4F,0xC2,0xF5,0x1D);


MIDL_DEFINE_GUID(IID, IID_IDADXTransformResult,0xBACD4D86,0x4A4F,0x11d1,0x9B,0xC8,0x00,0xC0,0x4F,0xC2,0xF5,0x1D);


MIDL_DEFINE_GUID(IID, IID_IDAStatics,0x542FB452,0x5003,0x11cf,0x92,0xA2,0x00,0xAA,0x00,0xB8,0xA7,0x33);


MIDL_DEFINE_GUID(IID, IID_IDA2Statics,0xFA261CF0,0xC44E,0x11d1,0x9B,0xE4,0x00,0xC0,0x4F,0xC2,0xF5,0x1D);


MIDL_DEFINE_GUID(CLSID, CLSID_DAStatics,0x542FB453,0x5003,0x11cf,0x92,0xA2,0x00,0xAA,0x00,0xB8,0xA7,0x33);


MIDL_DEFINE_GUID(IID, IID_IDAViewerControl,0x0E41257B,0x812D,0x11D0,0x9B,0x4A,0x00,0xC0,0x4F,0xC2,0xF5,0x1D);


MIDL_DEFINE_GUID(IID, IID_IDAViewerControlWindowed,0xBA8B033E,0x1E91,0x11d1,0x88,0x09,0x00,0xC0,0x4F,0xC2,0x9D,0x46);


MIDL_DEFINE_GUID(IID, IID_IDA2ViewerControl,0xF3E1B522,0xD8A6,0x11d1,0x9B,0xE5,0x00,0xC0,0x4F,0xC2,0xF5,0x1D);


MIDL_DEFINE_GUID(IID, IID_IDA2ViewerControlWindowed,0xA3034056,0xEC1C,0x11d1,0x9B,0xE8,0x00,0xC0,0x4F,0xC2,0xF5,0x1D);


MIDL_DEFINE_GUID(CLSID, CLSID_DAViewerControl,0xB6FFC24C,0x7E13,0x11D0,0x9B,0x47,0x00,0xC0,0x4F,0xC2,0xF5,0x1D);


MIDL_DEFINE_GUID(CLSID, CLSID_DAViewerControlWindowed,0x69AD90EF,0x1C20,0x11d1,0x88,0x01,0x00,0xC0,0x4F,0xC2,0x9D,0x46);


MIDL_DEFINE_GUID(CLSID, CLSID_DABoolean,0xC46C1BC1,0x3C52,0x11d0,0x92,0x00,0x84,0x8C,0x1D,0x00,0x00,0x00);


MIDL_DEFINE_GUID(CLSID, CLSID_DACamera,0xC46C1BE2,0x3C52,0x11d0,0x92,0x00,0x84,0x8C,0x1D,0x00,0x00,0x00);


MIDL_DEFINE_GUID(CLSID, CLSID_DAColor,0xC46C1BC6,0x3C52,0x11d0,0x92,0x00,0x84,0x8C,0x1D,0x00,0x00,0x00);


MIDL_DEFINE_GUID(CLSID, CLSID_DAGeometry,0xC46C1BE0,0x3C52,0x11d0,0x92,0x00,0x84,0x8C,0x1D,0x00,0x00,0x00);


MIDL_DEFINE_GUID(CLSID, CLSID_DAImage,0xC46C1BD4,0x3C52,0x11d0,0x92,0x00,0x84,0x8C,0x1D,0x00,0x00,0x00);


MIDL_DEFINE_GUID(CLSID, CLSID_DAMatte,0xC46C1BD2,0x3C52,0x11d0,0x92,0x00,0x84,0x8C,0x1D,0x00,0x00,0x00);


MIDL_DEFINE_GUID(CLSID, CLSID_DAMicrophone,0xC46C1BE6,0x3C52,0x11d0,0x92,0x00,0x84,0x8C,0x1D,0x00,0x00,0x00);


MIDL_DEFINE_GUID(CLSID, CLSID_DAMontage,0xC46C1BD6,0x3C52,0x11d0,0x92,0x00,0x84,0x8C,0x1D,0x00,0x00,0x00);


MIDL_DEFINE_GUID(CLSID, CLSID_DANumber,0x9CDE7341,0x3C20,0x11d0,0xA3,0x30,0x00,0xAA,0x00,0xB9,0x2C,0x03);


MIDL_DEFINE_GUID(CLSID, CLSID_DAPath2,0xC46C1BD0,0x3C52,0x11d0,0x92,0x00,0x84,0x8C,0x1D,0x00,0x00,0x00);


MIDL_DEFINE_GUID(CLSID, CLSID_DAPoint2,0xC46C1BC8,0x3C52,0x11d0,0x92,0x00,0x84,0x8C,0x1D,0x00,0x00,0x00);


MIDL_DEFINE_GUID(CLSID, CLSID_DAPoint3,0xC46C1BD8,0x3C52,0x11d0,0x92,0x00,0x84,0x8C,0x1D,0x00,0x00,0x00);


MIDL_DEFINE_GUID(CLSID, CLSID_DASound,0xC46C1BE4,0x3C52,0x11d0,0x92,0x00,0x84,0x8C,0x1D,0x00,0x00,0x00);


MIDL_DEFINE_GUID(CLSID, CLSID_DAString,0xC46C1BC4,0x3C52,0x11d0,0x92,0x00,0x84,0x8C,0x1D,0x00,0x00,0x00);


MIDL_DEFINE_GUID(CLSID, CLSID_DATransform2,0xC46C1BCC,0x3C52,0x11d0,0x92,0x00,0x84,0x8C,0x1D,0x00,0x00,0x00);


MIDL_DEFINE_GUID(CLSID, CLSID_DATransform3,0xC46C1BDC,0x3C52,0x11d0,0x92,0x00,0x84,0x8C,0x1D,0x00,0x00,0x00);


MIDL_DEFINE_GUID(CLSID, CLSID_DAVector2,0xC46C1BCA,0x3C52,0x11d0,0x92,0x00,0x84,0x8C,0x1D,0x00,0x00,0x00);


MIDL_DEFINE_GUID(CLSID, CLSID_DAVector3,0xC46C1BDA,0x3C52,0x11d0,0x92,0x00,0x84,0x8C,0x1D,0x00,0x00,0x00);


MIDL_DEFINE_GUID(CLSID, CLSID_DAFontStyle,0x25B0F91C,0xD23D,0x11d0,0x9B,0x85,0x00,0xC0,0x4F,0xC2,0xF5,0x1D);


MIDL_DEFINE_GUID(CLSID, CLSID_DALineStyle,0xC46C1BF2,0x3C52,0x11d0,0x92,0x00,0x84,0x8C,0x1D,0x00,0x00,0x00);


MIDL_DEFINE_GUID(CLSID, CLSID_DAEndStyle,0xC46C1BEC,0x3C52,0x11d0,0x92,0x00,0x84,0x8C,0x1D,0x00,0x00,0x00);


MIDL_DEFINE_GUID(CLSID, CLSID_DAJoinStyle,0xC46C1BEE,0x3C52,0x11d0,0x92,0x00,0x84,0x8C,0x1D,0x00,0x00,0x00);


MIDL_DEFINE_GUID(CLSID, CLSID_DADashStyle,0xC46C1BF0,0x3C52,0x11d0,0x92,0x00,0x84,0x8C,0x1D,0x00,0x00,0x00);


MIDL_DEFINE_GUID(CLSID, CLSID_DABbox2,0xC46C1BCE,0x3C52,0x11d0,0x92,0x00,0x84,0x8C,0x1D,0x00,0x00,0x00);


MIDL_DEFINE_GUID(CLSID, CLSID_DABbox3,0xC46C1BDE,0x3C52,0x11d0,0x92,0x00,0x84,0x8C,0x1D,0x00,0x00,0x00);


MIDL_DEFINE_GUID(CLSID, CLSID_DAPair,0xC46C1BF4,0x3C52,0x11d0,0x92,0x00,0x84,0x8C,0x1D,0x00,0x00,0x00);


MIDL_DEFINE_GUID(CLSID, CLSID_DAEvent,0x50B4791F,0x4731,0x11d0,0x89,0x12,0x00,0xC0,0x4F,0xC2,0xA0,0xCA);


MIDL_DEFINE_GUID(CLSID, CLSID_DAArray,0xD17506C3,0x6B26,0x11d0,0x89,0x14,0x00,0xC0,0x4F,0xC2,0xA0,0xCA);


MIDL_DEFINE_GUID(CLSID, CLSID_DATuple,0x5DFB2651,0x9668,0x11d0,0xB1,0x7B,0x00,0xC0,0x4F,0xC2,0xA0,0xCA);


MIDL_DEFINE_GUID(CLSID, CLSID_DAUserData,0xAF868304,0xAB0B,0x11d0,0x87,0x6A,0x00,0xC0,0x4F,0xC2,0x9D,0x46);


MIDL_DEFINE_GUID(CLSID, CLSID_DAImportationResult,0xBCBB1F75,0xE384,0x11d0,0x9B,0x99,0x00,0xC0,0x4F,0xC2,0xF5,0x1D);


MIDL_DEFINE_GUID(CLSID, CLSID_DAPickableResult,0xBCBB1F74,0xE384,0x11d0,0x9B,0x99,0x00,0xC0,0x4F,0xC2,0xF5,0x1D);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AXP64)*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\d3dxmath.inl ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1998 Microsoft Corporation.  All Rights Reserved.
//
//  File:       d3dxmath.inl
//  Content:    D3DX math inline functions
//
//////////////////////////////////////////////////////////////////////////////

#ifndef __D3DXMATH_INL__
#define __D3DXMATH_INL__


//===========================================================================
//
// Inline Class Methods
//
//===========================================================================

#ifdef __cplusplus

//--------------------------
// 2D Vector
//--------------------------

D3DXINLINE 
D3DXVECTOR2::D3DXVECTOR2( const float *pf )
{
#ifdef D3DX_DEBUG
    if(!pf)
        return;
#endif

    x = pf[0];
    y = pf[1];
}

D3DXINLINE 
D3DXVECTOR2::D3DXVECTOR2( float fx, float fy )
{
    x = fx;
    y = fy;
}

// casting
D3DXINLINE 
D3DXVECTOR2::operator float* ()
{
    return (float *) &x;
}

D3DXINLINE 
D3DXVECTOR2::operator const float* () const
{
    return (const float *) &x;
}

// assignment operators
D3DXINLINE D3DXVECTOR2& 
D3DXVECTOR2::operator += ( const D3DXVECTOR2& v )
{
    x += v.x;
    y += v.y;
    return *this;
}

D3DXINLINE D3DXVECTOR2& 
D3DXVECTOR2::operator -= ( const D3DXVECTOR2& v )
{
    x -= v.x;
    y -= v.y;
    return *this;
}

D3DXINLINE D3DXVECTOR2& 
D3DXVECTOR2::operator *= ( float f )
{
    x *= f;
    y *= f;
    return *this;
}

D3DXINLINE D3DXVECTOR2& 
D3DXVECTOR2::operator /= ( float f )
{
    float fInv = 1.0f / f;
    x *= fInv;
    y *= fInv;
    return *this;
}

// unary operators
D3DXINLINE D3DXVECTOR2 
D3DXVECTOR2::operator + () const
{
    return *this;
}

D3DXINLINE D3DXVECTOR2 
D3DXVECTOR2::operator - () const
{
    return D3DXVECTOR2(-x, -y);
}

// binary operators
D3DXINLINE D3DXVECTOR2 
D3DXVECTOR2::operator + ( const D3DXVECTOR2& v ) const
{
    return D3DXVECTOR2(x + v.x, y + v.y);
}

D3DXINLINE D3DXVECTOR2 
D3DXVECTOR2::operator - ( const D3DXVECTOR2& v ) const
{
    return D3DXVECTOR2(x - v.x, y - v.y);
}

D3DXINLINE D3DXVECTOR2 
D3DXVECTOR2::operator * ( float f ) const
{
    return D3DXVECTOR2(x * f, y * f);
}

D3DXINLINE D3DXVECTOR2 
D3DXVECTOR2::operator / ( float f ) const
{
    float fInv = 1.0f / f;
    return D3DXVECTOR2(x * fInv, y * fInv);
}


D3DXINLINE D3DXVECTOR2 
operator * ( float f, const D3DXVECTOR2& v )
{
    return D3DXVECTOR2(f * v.x, f * v.y);
}

D3DXINLINE BOOL 
D3DXVECTOR2::operator == ( const D3DXVECTOR2& v ) const
{
    return x == v.x && y == v.y;
}

D3DXINLINE BOOL 
D3DXVECTOR2::operator != ( const D3DXVECTOR2& v ) const
{
    return x != v.x || y != v.y;
}




//--------------------------
// 3D Vector
//--------------------------
D3DXINLINE 
D3DXVECTOR3::D3DXVECTOR3( const float *pf )
{
#ifdef D3DX_DEBUG
    if(!pf)
        return;
#endif

    x = pf[0];
    y = pf[1];
    z = pf[2];
}

D3DXINLINE 
D3DXVECTOR3::D3DXVECTOR3( const D3DVECTOR& v )
{
    x = v.x;
    y = v.y;
    z = v.z;
}

D3DXINLINE 
D3DXVECTOR3::D3DXVECTOR3( float fx, float fy, float fz )
{
    x = fx;
    y = fy;
    z = fz;
}


// casting
D3DXINLINE 
D3DXVECTOR3::operator float* ()
{
    return (float *) &x;
}

D3DXINLINE 
D3DXVECTOR3::operator const float* () const
{
    return (const float *) &x;
}


D3DXINLINE 
D3DXVECTOR3::operator D3DVECTOR* ()
{
    return (D3DVECTOR *) &x;
}

D3DXINLINE 
D3DXVECTOR3::operator const D3DVECTOR* () const
{
    return (const D3DVECTOR *) &x;
}


D3DXINLINE 
D3DXVECTOR3::operator D3DVECTOR& ()
{
    return *((D3DVECTOR *) &x);
}

D3DXINLINE 
D3DXVECTOR3::operator const D3DVECTOR& () const
{
    return *((const D3DVECTOR *) &x);
}


// assignment operators
D3DXINLINE D3DXVECTOR3& 
D3DXVECTOR3::operator += ( const D3DXVECTOR3& v )
{
    x += v.x;
    y += v.y;
    z += v.z;
    return *this;
}

D3DXINLINE D3DXVECTOR3& 
D3DXVECTOR3::operator -= ( const D3DXVECTOR3& v )
{
    x -= v.x;
    y -= v.y;
    z -= v.z;
    return *this;
}

D3DXINLINE D3DXVECTOR3& 
D3DXVECTOR3::operator *= ( float f )
{
    x *= f;
    y *= f;
    z *= f;
    return *this;
}

D3DXINLINE D3DXVECTOR3& 
D3DXVECTOR3::operator /= ( float f )
{
    float fInv = 1.0f / f;
    x *= fInv;
    y *= fInv;
    z *= fInv;
    return *this;
}


// unary operators
D3DXINLINE D3DXVECTOR3 
D3DXVECTOR3::operator + () const
{
    return *this;
}

D3DXINLINE D3DXVECTOR3 
D3DXVECTOR3::operator - () const
{
    return D3DXVECTOR3(-x, -y, -z);
}


// binary operators
D3DXINLINE D3DXVECTOR3 
D3DXVECTOR3::operator + ( const D3DXVECTOR3& v ) const
{
    return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);
}

D3DXINLINE D3DXVECTOR3 
D3DXVECTOR3::operator - ( const D3DXVECTOR3& v ) const
{
    return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);
}

D3DXINLINE D3DXVECTOR3 
D3DXVECTOR3::operator * ( float f ) const
{
    return D3DXVECTOR3(x * f, y * f, z * f);
}

D3DXINLINE D3DXVECTOR3 
D3DXVECTOR3::operator / ( float f ) const
{
    float fInv = 1.0f / f;
    return D3DXVECTOR3(x * fInv, y * fInv, z * fInv);
}


D3DXINLINE D3DXVECTOR3 
operator * ( float f, const struct D3DXVECTOR3& v )
{
    return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);
}


D3DXINLINE BOOL 
D3DXVECTOR3::operator == ( const D3DXVECTOR3& v ) const
{
    return x == v.x && y == v.y && z == v.z;
}

D3DXINLINE BOOL 
D3DXVECTOR3::operator != ( const D3DXVECTOR3& v ) const
{
    return x != v.x || y != v.y || z != v.z;
}



//--------------------------
// 4D Vector
//--------------------------
D3DXINLINE 
D3DXVECTOR4::D3DXVECTOR4( const float *pf )
{
#ifdef D3DX_DEBUG
    if(!pf)
        return;
#endif

    x = pf[0];
    y = pf[1];
    z = pf[2];
    w = pf[3];
}

D3DXINLINE 
D3DXVECTOR4::D3DXVECTOR4( float fx, float fy, float fz, float fw )
{
    x = fx;
    y = fy;
    z = fz;
    w = fw;
}


// casting
D3DXINLINE 
D3DXVECTOR4::operator float* ()
{
    return (float *) &x;
}

D3DXINLINE 
D3DXVECTOR4::operator const float* () const
{
    return (const float *) &x;
}


// assignment operators
D3DXINLINE D3DXVECTOR4& 
D3DXVECTOR4::operator += ( const D3DXVECTOR4& v )
{
    x += v.x;
    y += v.y;
    z += v.z;
    w += v.w;
    return *this;
}

D3DXINLINE D3DXVECTOR4& 
D3DXVECTOR4::operator -= ( const D3DXVECTOR4& v )
{
    x -= v.x;
    y -= v.y;
    z -= v.z;
    w -= v.w;
    return *this;
}

D3DXINLINE D3DXVECTOR4& 
D3DXVECTOR4::operator *= ( float f )
{
    x *= f;
    y *= f;
    z *= f;
    w *= f;
    return *this;
}

D3DXINLINE D3DXVECTOR4& 
D3DXVECTOR4::operator /= ( float f )
{
    float fInv = 1.0f / f;
    x *= fInv;
    y *= fInv;
    z *= fInv;
    w *= fInv;
    return *this;
}


// unary operators
D3DXINLINE D3DXVECTOR4 
D3DXVECTOR4::operator + () const
{
    return *this;
}

D3DXINLINE D3DXVECTOR4 
D3DXVECTOR4::operator - () const
{
    return D3DXVECTOR4(-x, -y, -z, -w);
}


// binary operators
D3DXINLINE D3DXVECTOR4 
D3DXVECTOR4::operator + ( const D3DXVECTOR4& v ) const
{
    return D3DXVECTOR4(x + v.x, y + v.y, z + v.z, w + v.w);
}

D3DXINLINE D3DXVECTOR4 
D3DXVECTOR4::operator - ( const D3DXVECTOR4& v ) const
{
    return D3DXVECTOR4(x - v.x, y - v.y, z - v.z, w - v.w);
}

D3DXINLINE D3DXVECTOR4 
D3DXVECTOR4::operator * ( float f ) const
{
    return D3DXVECTOR4(x * f, y * f, z * f, w * f);
}

D3DXINLINE D3DXVECTOR4 
D3DXVECTOR4::operator / ( float f ) const
{
    float fInv = 1.0f / f;
    return D3DXVECTOR4(x * fInv, y * fInv, z * fInv, w * fInv);
}


D3DXINLINE D3DXVECTOR4 
operator * ( float f, const D3DXVECTOR4& v )
{
    return D3DXVECTOR4(f * v.x, f * v.y, f * v.z, f * v.w);
}


D3DXINLINE BOOL 
D3DXVECTOR4::operator == ( const D3DXVECTOR4& v ) const
{
    return x == v.x && y == v.y && z == v.z && w == v.w;
}

D3DXINLINE BOOL 
D3DXVECTOR4::operator != ( const D3DXVECTOR4& v ) const
{
    return x != v.x || y != v.y || z != v.z || w != v.w;
}


//--------------------------
// Matrix
//--------------------------
D3DXINLINE 
D3DXMATRIX::D3DXMATRIX( const float* pf )
{
#ifdef D3DX_DEBUG
    if(!pf)
        return;
#endif

    memcpy(&m00, pf, sizeof(D3DXMATRIX));
}

D3DXINLINE 
D3DXMATRIX::D3DXMATRIX( const D3DMATRIX& mat )
{
    memcpy(&m00, &mat, sizeof(D3DXMATRIX));
}

D3DXINLINE 
D3DXMATRIX::D3DXMATRIX( float f00, float f01, float f02, float f03,
                        float f10, float f11, float f12, float f13,
                        float f20, float f21, float f22, float f23,
                        float f30, float f31, float f32, float f33 )
{
    m00 = f00; m01 = f01; m02 = f02; m03 = f03;
    m10 = f10; m11 = f11; m12 = f12; m13 = f13;
    m20 = f20; m21 = f21; m22 = f22; m23 = f23;
    m30 = f30; m31 = f31; m32 = f32; m33 = f33;
}



// access grants
D3DXINLINE float& 
D3DXMATRIX::operator () ( UINT iRow, UINT iCol )
{
    return m[iRow][iCol];
}

D3DXINLINE float  
D3DXMATRIX::operator () ( UINT iRow, UINT iCol ) const
{
    return m[iRow][iCol];
}


// casting operators
D3DXINLINE 
D3DXMATRIX::operator float* ()
{
    return (float *) &m00;
}

D3DXINLINE 
D3DXMATRIX::operator const float* () const
{
    return (const float *) &m00;
}


D3DXINLINE 
D3DXMATRIX::operator D3DMATRIX* ()
{
    return (D3DMATRIX *) &m00;
}

D3DXINLINE 
D3DXMATRIX::operator const D3DMATRIX* () const
{
    return (const D3DMATRIX *) &m00;
}


D3DXINLINE 
D3DXMATRIX::operator D3DMATRIX& ()
{
    return *((D3DMATRIX *) &m00);
}

D3DXINLINE 
D3DXMATRIX::operator const D3DMATRIX& () const
{
    return *((const D3DMATRIX *) &m00);
}


// assignment operators
D3DXINLINE D3DXMATRIX& 
D3DXMATRIX::operator *= ( const D3DXMATRIX& mat )
{
    D3DXMatrixMultiply(this, this, &mat);
    return *this;
}

D3DXINLINE D3DXMATRIX& 
D3DXMATRIX::operator += ( const D3DXMATRIX& mat )
{
    m00 += mat.m00; m01 += mat.m01; m02 += mat.m02; m03 += mat.m03;
    m10 += mat.m10; m11 += mat.m11; m12 += mat.m12; m13 += mat.m13;
    m20 += mat.m20; m21 += mat.m21; m22 += mat.m22; m23 += mat.m23;
    m30 += mat.m30; m31 += mat.m31; m32 += mat.m32; m33 += mat.m33;
    return *this;
}

D3DXINLINE D3DXMATRIX& 
D3DXMATRIX::operator -= ( const D3DXMATRIX& mat )
{
    m00 -= mat.m00; m01 -= mat.m01; m02 -= mat.m02; m03 -= mat.m03;
    m10 -= mat.m10; m11 -= mat.m11; m12 -= mat.m12; m13 -= mat.m13;
    m20 -= mat.m20; m21 -= mat.m21; m22 -= mat.m22; m23 -= mat.m23;
    m30 -= mat.m30; m31 -= mat.m31; m32 -= mat.m32; m33 -= mat.m33;
    return *this;
}

D3DXINLINE D3DXMATRIX& 
D3DXMATRIX::operator *= ( float f )
{
    m00 *= f; m01 *= f; m02 *= f; m03 *= f;
    m10 *= f; m11 *= f; m12 *= f; m13 *= f;
    m20 *= f; m21 *= f; m22 *= f; m23 *= f;
    m30 *= f; m31 *= f; m32 *= f; m33 *= f;
    return *this;
}

D3DXINLINE D3DXMATRIX& 
D3DXMATRIX::operator /= ( float f )
{
    float fInv = 1.0f / f;
    m00 *= fInv; m01 *= fInv; m02 *= fInv; m03 *= fInv;
    m10 *= fInv; m11 *= fInv; m12 *= fInv; m13 *= fInv;
    m20 *= fInv; m21 *= fInv; m22 *= fInv; m23 *= fInv;
    m30 *= fInv; m31 *= fInv; m32 *= fInv; m33 *= fInv;
    return *this;
}


// unary operators
D3DXINLINE D3DXMATRIX 
D3DXMATRIX::operator + () const
{
    return *this;
}

D3DXINLINE D3DXMATRIX 
D3DXMATRIX::operator - () const
{
    return D3DXMATRIX(-m00, -m01, -m02, -m03,
                      -m10, -m11, -m12, -m13,
                      -m20, -m21, -m22, -m23,
                      -m30, -m31, -m32, -m33);
}


// binary operators
D3DXINLINE D3DXMATRIX 
D3DXMATRIX::operator * ( const D3DXMATRIX& mat ) const
{
    D3DXMATRIX matT;
    D3DXMatrixMultiply(&matT, this, &mat);
    return matT;
}

D3DXINLINE D3DXMATRIX 
D3DXMATRIX::operator + ( const D3DXMATRIX& mat ) const
{
    return D3DXMATRIX(m00 + mat.m00, m01 + mat.m01, m02 + mat.m02, m03 + mat.m03, 
                      m10 + mat.m10, m11 + mat.m11, m12 + mat.m12, m13 + mat.m13, 
                      m20 + mat.m20, m21 + mat.m21, m22 + mat.m22, m23 + mat.m23, 
                      m30 + mat.m30, m31 + mat.m31, m32 + mat.m32, m33 + mat.m33);
}    

D3DXINLINE D3DXMATRIX 
D3DXMATRIX::operator - ( const D3DXMATRIX& mat ) const
{
    return D3DXMATRIX(m00 - mat.m00, m01 - mat.m01, m02 - mat.m02, m03 - mat.m03, 
                      m10 - mat.m10, m11 - mat.m11, m12 - mat.m12, m13 - mat.m13, 
                      m20 - mat.m20, m21 - mat.m21, m22 - mat.m22, m23 - mat.m23, 
                      m30 - mat.m30, m31 - mat.m31, m32 - mat.m32, m33 - mat.m33);
}

D3DXINLINE D3DXMATRIX 
D3DXMATRIX::operator * ( float f ) const
{
    return D3DXMATRIX(m00 * f, m01 * f, m02 * f, m03 * f, 
                      m10 * f, m11 * f, m12 * f, m13 * f, 
                      m20 * f, m21 * f, m22 * f, m23 * f, 
                      m30 * f, m31 * f, m32 * f, m33 * f);
}

D3DXINLINE D3DXMATRIX 
D3DXMATRIX::operator / ( float f ) const
{
    float fInv = 1.0f / f;
    return D3DXMATRIX(m00 * fInv, m01 * fInv, m02 * fInv, m03 * fInv, 
                      m10 * fInv, m11 * fInv, m12 * fInv, m13 * fInv, 
                      m20 * fInv, m21 * fInv, m22 * fInv, m23 * fInv, 
                      m30 * fInv, m31 * fInv, m32 * fInv, m33 * fInv);
}


D3DXINLINE D3DXMATRIX 
operator * ( float f, const D3DXMATRIX& mat )
{
    return D3DXMATRIX(f * mat.m00, f * mat.m01, f * mat.m02, f * mat.m03, 
                      f * mat.m10, f * mat.m11, f * mat.m12, f * mat.m13, 
                      f * mat.m20, f * mat.m21, f * mat.m22, f * mat.m23, 
                      f * mat.m30, f * mat.m31, f * mat.m32, f * mat.m33);
}


D3DXINLINE BOOL 
D3DXMATRIX::operator == ( const D3DXMATRIX& mat ) const
{
    return 0 == memcmp(this, &mat, sizeof(D3DXMATRIX));
}

D3DXINLINE BOOL 
D3DXMATRIX::operator != ( const D3DXMATRIX& mat ) const
{
    return 0 != memcmp(this, &mat, sizeof(D3DXMATRIX));
}



//--------------------------
// Quaternion
//--------------------------

D3DXINLINE 
D3DXQUATERNION::D3DXQUATERNION( const float* pf )
{
#ifdef D3DX_DEBUG
    if(!pf)
        return;
#endif

    x = pf[0];
    y = pf[1];
    z = pf[2];
    w = pf[3];
}

D3DXINLINE 
D3DXQUATERNION::D3DXQUATERNION( float fx, float fy, float fz, float fw )
{
    x = fx;
    y = fy;
    z = fz;
    w = fw;
}


// casting
D3DXINLINE 
D3DXQUATERNION::operator float* ()
{
    return (float *) &x;
}

D3DXINLINE 
D3DXQUATERNION::operator const float* () const
{
    return (const float *) &x;
}


// assignment operators
D3DXINLINE D3DXQUATERNION& 
D3DXQUATERNION::operator += ( const D3DXQUATERNION& q )
{
    x += q.x;
    y += q.y;
    z += q.z;
    w += q.w;
    return *this;
}

D3DXINLINE D3DXQUATERNION& 
D3DXQUATERNION::operator -= ( const D3DXQUATERNION& q )
{
    x -= q.x;
    y -= q.y;
    z -= q.z;
    w -= q.w;
    return *this;
}

D3DXINLINE D3DXQUATERNION& 
D3DXQUATERNION::operator *= ( const D3DXQUATERNION& q )
{
    D3DXQuaternionMultiply(this, this, &q);
    return *this;
}

D3DXINLINE D3DXQUATERNION& 
D3DXQUATERNION::operator *= ( float f )
{
    x *= f;
    y *= f;
    z *= f;
    w *= f;
    return *this;
}

D3DXINLINE D3DXQUATERNION& 
D3DXQUATERNION::operator /= ( float f )
{
    float fInv = 1.0f / f;
    x *= fInv;
    y *= fInv;
    z *= fInv;
    w *= fInv;
    return *this;
}


// unary operators
D3DXINLINE D3DXQUATERNION  
D3DXQUATERNION::operator + () const
{
    return *this;
}

D3DXINLINE D3DXQUATERNION  
D3DXQUATERNION::operator - () const
{
    return D3DXQUATERNION(-x, -y, -z, -w);
}


// binary operators
D3DXINLINE D3DXQUATERNION 
D3DXQUATERNION::operator + ( const D3DXQUATERNION& q ) const
{
    return D3DXQUATERNION(x + q.x, y + q.y, z + q.z, w + q.w);
}

D3DXINLINE D3DXQUATERNION 
D3DXQUATERNION::operator - ( const D3DXQUATERNION& q ) const
{
    return D3DXQUATERNION(x - q.x, y - q.y, z - q.z, w - q.w);
}

D3DXINLINE D3DXQUATERNION 
D3DXQUATERNION::operator * ( const D3DXQUATERNION& q ) const
{
    D3DXQUATERNION qT;
    D3DXQuaternionMultiply(&qT, this, &q);
    return qT;
}

D3DXINLINE D3DXQUATERNION 
D3DXQUATERNION::operator * ( float f ) const
{
    return D3DXQUATERNION(x * f, y * f, z * f, w * f);
}

D3DXINLINE D3DXQUATERNION 
D3DXQUATERNION::operator / ( float f ) const
{
    float fInv = 1.0f / f;
    return D3DXQUATERNION(x * fInv, y * fInv, z * fInv, w * fInv);
}


D3DXINLINE D3DXQUATERNION 
operator * (float f, const D3DXQUATERNION& q )
{
    return D3DXQUATERNION(f * q.x, f * q.y, f * q.z, f * q.w);
}


D3DXINLINE BOOL 
D3DXQUATERNION::operator == ( const D3DXQUATERNION& q ) const
{
    return x == q.x && y == q.y && z == q.z && w == q.w;
}

D3DXINLINE BOOL 
D3DXQUATERNION::operator != ( const D3DXQUATERNION& q ) const
{
    return x != q.x || y != q.y || z != q.z || w != q.w;
}



//--------------------------
// Plane
//--------------------------

D3DXINLINE 
D3DXPLANE::D3DXPLANE( const float* pf )
{
#ifdef D3DX_DEBUG
    if(!pf)
        return;
#endif

    a = pf[0];
    b = pf[1];
    c = pf[2];
    d = pf[3];
}

D3DXINLINE 
D3DXPLANE::D3DXPLANE( float fa, float fb, float fc, float fd )
{
    a = fa;
    b = fb;
    c = fc;
    d = fd;
}


// casting
D3DXINLINE 
D3DXPLANE::operator float* ()
{
    return (float *) &a;
}

D3DXINLINE 
D3DXPLANE::operator const float* () const
{
    return (const float *) &a;
}


// unary operators
D3DXINLINE D3DXPLANE 
D3DXPLANE::operator + () const
{
    return *this;
}

D3DXINLINE D3DXPLANE 
D3DXPLANE::operator - () const
{
    return D3DXPLANE(-a, -b, -c, -d);
}


// binary operators
D3DXINLINE BOOL 
D3DXPLANE::operator == ( const D3DXPLANE& p ) const
{
    return a == p.a && b == p.b && c == p.c && d == p.d;
}

D3DXINLINE BOOL 
D3DXPLANE::operator != ( const D3DXPLANE& p ) const
{
    return a != p.a || b != p.b || c != p.c || d != p.d;
}




//--------------------------
// Color
//--------------------------

D3DXINLINE 
D3DXCOLOR::D3DXCOLOR( DWORD dw )
{
    const float f = 1.0f / 255.0f;
    r = f * (float) (unsigned char) (dw >> 16);
    g = f * (float) (unsigned char) (dw >>  8);
    b = f * (float) (unsigned char) (dw >>  0);
    a = f * (float) (unsigned char) (dw >> 24);
}

D3DXINLINE 
D3DXCOLOR::D3DXCOLOR( const float* pf )
{
#ifdef D3DX_DEBUG
    if(!pf)
        return;
#endif

    r = pf[0];
    g = pf[1];
    b = pf[2];
    a = pf[3];
}

D3DXINLINE 
D3DXCOLOR::D3DXCOLOR( const D3DCOLORVALUE& c )
{
    r = c.r;
    g = c.g;
    b = c.b;
    a = c.a;
}

D3DXINLINE 
D3DXCOLOR::D3DXCOLOR( float fr, float fg, float fb, float fa )
{
    r = fr;
    g = fg;
    b = fb;
    a = fa;
}


// casting
D3DXINLINE 
D3DXCOLOR::operator DWORD () const
{
    DWORD dwR = r >= 1.0f ? 0xff : r <= 0.0f ? 0x00 : (DWORD) (r * 255.0f + 0.5f);
    DWORD dwG = g >= 1.0f ? 0xff : g <= 0.0f ? 0x00 : (DWORD) (g * 255.0f + 0.5f);
    DWORD dwB = b >= 1.0f ? 0xff : b <= 0.0f ? 0x00 : (DWORD) (b * 255.0f + 0.5f);
    DWORD dwA = a >= 1.0f ? 0xff : a <= 0.0f ? 0x00 : (DWORD) (a * 255.0f + 0.5f);

    return (dwA << 24) | (dwR << 16) | (dwG << 8) | dwB;
}


D3DXINLINE 
D3DXCOLOR::operator float * ()
{
    return (float *) &r;
}

D3DXINLINE 
D3DXCOLOR::operator const float * () const
{
    return (const float *) &r;
}


D3DXINLINE 
D3DXCOLOR::operator D3DCOLORVALUE * ()
{
    return (D3DCOLORVALUE *) &r;
}

D3DXINLINE 
D3DXCOLOR::operator const D3DCOLORVALUE * () const
{
    return (const D3DCOLORVALUE *) &r;
}


D3DXINLINE 
D3DXCOLOR::operator D3DCOLORVALUE& ()
{
    return *((D3DCOLORVALUE *) &r);
}

D3DXINLINE 
D3DXCOLOR::operator const D3DCOLORVALUE& () const
{
    return *((const D3DCOLORVALUE *) &r);
}


// assignment operators
D3DXINLINE D3DXCOLOR& 
D3DXCOLOR::operator += ( const D3DXCOLOR& c )
{
    r += c.r;
    g += c.g;
    b += c.b;
    a += c.a;
    return *this;
}

D3DXINLINE D3DXCOLOR& 
D3DXCOLOR::operator -= ( const D3DXCOLOR& c )
{
    r -= c.r;
    g -= c.g;
    b -= c.b;
    a -= c.a;
    return *this;
}

D3DXINLINE D3DXCOLOR& 
D3DXCOLOR::operator *= ( float f )
{
    r *= f;
    g *= f;
    b *= f;
    a *= f;
    return *this;
}

D3DXINLINE D3DXCOLOR& 
D3DXCOLOR::operator /= ( float f )
{
    float fInv = 1.0f / f;
    r *= fInv;
    g *= fInv;
    b *= fInv;
    a *= fInv;
    return *this;
}


// unary operators
D3DXINLINE D3DXCOLOR 
D3DXCOLOR::operator + () const
{
    return *this;
}

D3DXINLINE D3DXCOLOR 
D3DXCOLOR::operator - () const
{
    return D3DXCOLOR(-r, -g, -b, -a);
}


// binary operators
D3DXINLINE D3DXCOLOR 
D3DXCOLOR::operator + ( const D3DXCOLOR& c ) const
{
    return D3DXCOLOR(r + c.r, g + c.g, b + c.b, a + c.a);
}

D3DXINLINE D3DXCOLOR 
D3DXCOLOR::operator - ( const D3DXCOLOR& c ) const
{
    return D3DXCOLOR(r - c.r, g - c.g, b - c.b, a - c.a);
}

D3DXINLINE D3DXCOLOR 
D3DXCOLOR::operator * ( float f ) const
{
    return D3DXCOLOR(r * f, g * f, b * f, a * f);
}

D3DXINLINE D3DXCOLOR 
D3DXCOLOR::operator / ( float f ) const
{
    float fInv = 1.0f / f;
    return D3DXCOLOR(r * fInv, g * fInv, b * fInv, a * fInv);
}


D3DXINLINE D3DXCOLOR 
operator * (float f, const D3DXCOLOR& c )
{
    return D3DXCOLOR(f * c.r, f * c.g, f * c.b, f * c.a);
}


D3DXINLINE BOOL 
D3DXCOLOR::operator == ( const D3DXCOLOR& c ) const
{
    return r == c.r && g == c.g && b == c.b && a == c.a;
}

D3DXINLINE BOOL 
D3DXCOLOR::operator != ( const D3DXCOLOR& c ) const
{
    return r != c.r || g != c.g || b != c.b || a != c.a;
}


#endif //__cplusplus



//===========================================================================
//
// Inline functions
//
//===========================================================================


//--------------------------
// 2D Vector
//--------------------------

D3DXINLINE float D3DXVec2Length
    ( const D3DXVECTOR2 *pV )
{
#ifdef D3DX_DEBUG
    if(!pV)
        return 0.0f;
#endif

#ifdef __cplusplus
    return sqrtf(pV->x * pV->x + pV->y * pV->y);
#else
    return (float) sqrt(pV->x * pV->x + pV->y * pV->y);
#endif 
}

D3DXINLINE float D3DXVec2LengthSq
    ( const D3DXVECTOR2 *pV )
{
#ifdef D3DX_DEBUG
    if(!pV)
        return 0.0f;
#endif

    return pV->x * pV->x + pV->y * pV->y;
}

D3DXINLINE float D3DXVec2Dot
    ( const D3DXVECTOR2 *pV1, const D3DXVECTOR2 *pV2 )
{
#ifdef D3DX_DEBUG
    if(!pV1 || !pV2)
        return 0.0f;
#endif

    return pV1->x * pV2->x + pV1->y * pV2->y;
}

D3DXINLINE float D3DXVec2CCW
    ( const D3DXVECTOR2 *pV1, const D3DXVECTOR2 *pV2 )
{
#ifdef D3DX_DEBUG
    if(!pV1 || !pV2)
        return 0.0f;
#endif

    return pV1->x * pV2->y - pV1->y * pV2->x;
}

D3DXINLINE D3DXVECTOR2* D3DXVec2Add
    ( D3DXVECTOR2 *pOut, const D3DXVECTOR2 *pV1, const D3DXVECTOR2 *pV2 )
{
#ifdef D3DX_DEBUG
    if(!pOut || !pV1 || !pV2)
        return NULL;
#endif

    pOut->x = pV1->x + pV2->x;
    pOut->y = pV1->y + pV2->y;
    return pOut;
}

D3DXINLINE D3DXVECTOR2* D3DXVec2Subtract
    ( D3DXVECTOR2 *pOut, const D3DXVECTOR2 *pV1, const D3DXVECTOR2 *pV2 )
{
#ifdef D3DX_DEBUG
    if(!pOut || !pV1 || !pV2)
        return NULL;
#endif

    pOut->x = pV1->x - pV2->x;
    pOut->y = pV1->y - pV2->y;
    return pOut;
}

D3DXINLINE D3DXVECTOR2* D3DXVec2Minimize
    ( D3DXVECTOR2 *pOut, const D3DXVECTOR2 *pV1, const D3DXVECTOR2 *pV2 )
{
#ifdef D3DX_DEBUG
    if(!pOut || !pV1 || !pV2)
        return NULL;
#endif

    pOut->x = pV1->x < pV2->x ? pV1->x : pV2->x;
    pOut->y = pV1->y < pV2->y ? pV1->y : pV2->y;
    return pOut;
}

D3DXINLINE D3DXVECTOR2* D3DXVec2Maximize
    ( D3DXVECTOR2 *pOut, const D3DXVECTOR2 *pV1, const D3DXVECTOR2 *pV2 )
{
#ifdef D3DX_DEBUG
    if(!pOut || !pV1 || !pV2)
        return NULL;
#endif

    pOut->x = pV1->x > pV2->x ? pV1->x : pV2->x;
    pOut->y = pV1->y > pV2->y ? pV1->y : pV2->y;
    return pOut;
}

D3DXINLINE D3DXVECTOR2* D3DXVec2Scale
    ( D3DXVECTOR2 *pOut, const D3DXVECTOR2 *pV, float s )
{
#ifdef D3DX_DEBUG
    if(!pOut || !pV)
        return NULL;
#endif

    pOut->x = pV->x * s;
    pOut->y = pV->y * s;
    return pOut;
}

D3DXINLINE D3DXVECTOR2* D3DXVec2Lerp
    ( D3DXVECTOR2 *pOut, const D3DXVECTOR2 *pV1, const D3DXVECTOR2 *pV2,
      float s )
{
#ifdef D3DX_DEBUG
    if(!pOut || !pV1 || !pV2)
        return NULL;
#endif

    pOut->x = pV1->x + s * (pV2->x - pV1->x);
    pOut->y = pV1->y + s * (pV2->y - pV1->y);
    return pOut;
}


//--------------------------
// 3D Vector
//--------------------------

D3DXINLINE float D3DXVec3Length
    ( const D3DXVECTOR3 *pV )
{
#ifdef D3DX_DEBUG
    if(!pV)
        return 0.0f;
#endif

#ifdef __cplusplus
    return sqrtf(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);
#else
    return (float) sqrt(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);
#endif
}

D3DXINLINE float D3DXVec3LengthSq
    ( const D3DXVECTOR3 *pV )
{
#ifdef D3DX_DEBUG
    if(!pV)
        return 0.0f;
#endif

    return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;
}

D3DXINLINE float D3DXVec3Dot
    ( const D3DXVECTOR3 *pV1, const D3DXVECTOR3 *pV2 )
{
#ifdef D3DX_DEBUG
    if(!pV1 || !pV2)
        return 0.0f;
#endif

    return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;
}

D3DXINLINE D3DXVECTOR3* D3DXVec3Cross
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV1, const D3DXVECTOR3 *pV2 )
{
    D3DXVECTOR3 v;

#ifdef D3DX_DEBUG
    if(!pOut || !pV1 || !pV2)
        return NULL;
#endif

    v.x = pV1->y * pV2->z - pV1->z * pV2->y;
    v.y = pV1->z * pV2->x - pV1->x * pV2->z;
    v.z = pV1->x * pV2->y - pV1->y * pV2->x;

    *pOut = v;
    return pOut;
}

D3DXINLINE D3DXVECTOR3* D3DXVec3Add
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV1, const D3DXVECTOR3 *pV2 )
{
#ifdef D3DX_DEBUG
    if(!pOut || !pV1 || !pV2)
        return NULL;
#endif

    pOut->x = pV1->x + pV2->x;
    pOut->y = pV1->y + pV2->y;
    pOut->z = pV1->z + pV2->z;
    return pOut;
}

D3DXINLINE D3DXVECTOR3* D3DXVec3Subtract
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV1, const D3DXVECTOR3 *pV2 )
{
#ifdef D3DX_DEBUG
    if(!pOut || !pV1 || !pV2)
        return NULL;
#endif

    pOut->x = pV1->x - pV2->x;
    pOut->y = pV1->y - pV2->y;
    pOut->z = pV1->z - pV2->z;
    return pOut;
}

D3DXINLINE D3DXVECTOR3* D3DXVec3Minimize
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV1, const D3DXVECTOR3 *pV2 )
{
#ifdef D3DX_DEBUG
    if(!pOut || !pV1 || !pV2)
        return NULL;
#endif

    pOut->x = pV1->x < pV2->x ? pV1->x : pV2->x;
    pOut->y = pV1->y < pV2->y ? pV1->y : pV2->y;
    pOut->z = pV1->z < pV2->z ? pV1->z : pV2->z;
    return pOut;
}

D3DXINLINE D3DXVECTOR3* D3DXVec3Maximize
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV1, const D3DXVECTOR3 *pV2 )
{
#ifdef D3DX_DEBUG
    if(!pOut || !pV1 || !pV2)
        return NULL;
#endif

    pOut->x = pV1->x > pV2->x ? pV1->x : pV2->x;
    pOut->y = pV1->y > pV2->y ? pV1->y : pV2->y;
    pOut->z = pV1->z > pV2->z ? pV1->z : pV2->z;
    return pOut;
}

D3DXINLINE D3DXVECTOR3* D3DXVec3Scale
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV, float s)
{
#ifdef D3DX_DEBUG
    if(!pOut || !pV)
        return NULL;
#endif

    pOut->x = pV->x * s;
    pOut->y = pV->y * s;
    pOut->z = pV->z * s;
    return pOut;
}

D3DXINLINE D3DXVECTOR3* D3DXVec3Lerp
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV1, const D3DXVECTOR3 *pV2,
      float s )
{
#ifdef D3DX_DEBUG
    if(!pOut || !pV1 || !pV2)
        return NULL;
#endif

    pOut->x = pV1->x + s * (pV2->x - pV1->x);
    pOut->y = pV1->y + s * (pV2->y - pV1->y);
    pOut->z = pV1->z + s * (pV2->z - pV1->z);
    return pOut;
}


//--------------------------
// 4D Vector
//--------------------------

D3DXINLINE float D3DXVec4Length
    ( const D3DXVECTOR4 *pV )
{
#ifdef D3DX_DEBUG
    if(!pV)
        return 0.0f;
#endif

#ifdef __cplusplus
    return sqrtf(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z + pV->w * pV->w);
#else
    return (float) sqrt(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z + pV->w * pV->w);
#endif
}

D3DXINLINE float D3DXVec4LengthSq
    ( const D3DXVECTOR4 *pV )
{
#ifdef D3DX_DEBUG
    if(!pV)
        return 0.0f;
#endif

    return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z + pV->w * pV->w;
}

D3DXINLINE float D3DXVec4Dot
    ( const D3DXVECTOR4 *pV1, const D3DXVECTOR4 *pV2 )
{
#ifdef D3DX_DEBUG
    if(!pV1 || !pV2)
        return 0.0f;
#endif

    return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z + pV1->w * pV2->w;
}

D3DXINLINE D3DXVECTOR4* D3DXVec4Add
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR4 *pV1, const D3DXVECTOR4 *pV2)
{
#ifdef D3DX_DEBUG
    if(!pOut || !pV1 || !pV2)
        return NULL;
#endif

    pOut->x = pV1->x + pV2->x;
    pOut->y = pV1->y + pV2->y;
    pOut->z = pV1->z + pV2->z;
    pOut->w = pV1->w + pV2->w;
    return pOut;
}

D3DXINLINE D3DXVECTOR4* D3DXVec4Subtract
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR4 *pV1, const D3DXVECTOR4 *pV2)
{
#ifdef D3DX_DEBUG
    if(!pOut || !pV1 || !pV2)
        return NULL;
#endif

    pOut->x = pV1->x - pV2->x;
    pOut->y = pV1->y - pV2->y;
    pOut->z = pV1->z - pV2->z;
    pOut->w = pV1->w - pV2->w;
    return pOut;
}

D3DXINLINE D3DXVECTOR4* D3DXVec4Minimize
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR4 *pV1, const D3DXVECTOR4 *pV2)
{
#ifdef D3DX_DEBUG
    if(!pOut || !pV1 || !pV2)
        return NULL;
#endif

    pOut->x = pV1->x < pV2->x ? pV1->x : pV2->x;
    pOut->y = pV1->y < pV2->y ? pV1->y : pV2->y;
    pOut->z = pV1->z < pV2->z ? pV1->z : pV2->z;
    pOut->w = pV1->w < pV2->w ? pV1->w : pV2->w;
    return pOut;
}

D3DXINLINE D3DXVECTOR4* D3DXVec4Maximize
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR4 *pV1, const D3DXVECTOR4 *pV2)
{
#ifdef D3DX_DEBUG
    if(!pOut || !pV1 || !pV2)
        return NULL;
#endif

    pOut->x = pV1->x > pV2->x ? pV1->x : pV2->x;
    pOut->y = pV1->y > pV2->y ? pV1->y : pV2->y;
    pOut->z = pV1->z > pV2->z ? pV1->z : pV2->z;
    pOut->w = pV1->w > pV2->w ? pV1->w : pV2->w;
    return pOut;
}

D3DXINLINE D3DXVECTOR4* D3DXVec4Scale
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR4 *pV, float s)
{
#ifdef D3DX_DEBUG
    if(!pOut || !pV)
        return NULL;
#endif

    pOut->x = pV->x * s;
    pOut->y = pV->y * s;
    pOut->z = pV->z * s;
    pOut->w = pV->w * s;
    return pOut;
}

D3DXINLINE D3DXVECTOR4* D3DXVec4Lerp
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR4 *pV1, const D3DXVECTOR4 *pV2,
      float s )
{
#ifdef D3DX_DEBUG
    if(!pOut || !pV1 || !pV2)
        return NULL;
#endif

    pOut->x = pV1->x + s * (pV2->x - pV1->x);
    pOut->y = pV1->y + s * (pV2->y - pV1->y);
    pOut->z = pV1->z + s * (pV2->z - pV1->z);
    pOut->w = pV1->w + s * (pV2->w - pV1->w);
    return pOut;
}


//--------------------------
// 4D Matrix
//--------------------------

D3DXINLINE D3DXMATRIX* D3DXMatrixIdentity
    ( D3DXMATRIX *pOut )
{
#ifdef D3DX_DEBUG
    if(!pOut)
        return NULL;
#endif

    pOut->m[0][1] = pOut->m[0][2] = pOut->m[0][3] = 
    pOut->m[1][0] = pOut->m[1][2] = pOut->m[1][3] = 
    pOut->m[2][0] = pOut->m[2][1] = pOut->m[2][3] = 
    pOut->m[3][0] = pOut->m[3][1] = pOut->m[3][2] = 0.0f;

    pOut->m[0][0] = pOut->m[1][1] = pOut->m[2][2] = pOut->m[3][3] = 1.0f;
    return pOut;
}


D3DXINLINE BOOL D3DXMatrixIsIdentity
    ( const D3DXMATRIX *pM )
{
#ifdef D3DX_DEBUG
    if(!pM)
        return FALSE;
#endif

    return pM->m[0][0] == 1.0f && pM->m[0][1] == 0.0f && pM->m[0][2] == 0.0f && pM->m[0][3] == 0.0f &&
           pM->m[1][0] == 0.0f && pM->m[1][1] == 1.0f && pM->m[1][2] == 0.0f && pM->m[1][3] == 0.0f &&
           pM->m[2][0] == 0.0f && pM->m[2][1] == 0.0f && pM->m[2][2] == 1.0f && pM->m[2][3] == 0.0f &&
           pM->m[3][0] == 0.0f && pM->m[3][1] == 0.0f && pM->m[3][2] == 0.0f && pM->m[3][3] == 1.0f;
}


//--------------------------
// Quaternion
//--------------------------

D3DXINLINE float D3DXQuaternionLength
    ( const D3DXQUATERNION *pQ )
{
#ifdef D3DX_DEBUG
    if(!pQ)
        return 0.0f;
#endif

#ifdef __cplusplus
    return sqrtf(pQ->x * pQ->x + pQ->y * pQ->y + pQ->z * pQ->z + pQ->w * pQ->w);
#else
    return (float) sqrt(pQ->x * pQ->x + pQ->y * pQ->y + pQ->z * pQ->z + pQ->w * pQ->w);
#endif
}

D3DXINLINE float D3DXQuaternionLengthSq
    ( const D3DXQUATERNION *pQ )
{
#ifdef D3DX_DEBUG
    if(!pQ)
        return 0.0f;
#endif

    return pQ->x * pQ->x + pQ->y * pQ->y + pQ->z * pQ->z + pQ->w * pQ->w;
}

D3DXINLINE float D3DXQuaternionDot
    ( const D3DXQUATERNION *pQ1, const D3DXQUATERNION *pQ2 )
{
#ifdef D3DX_DEBUG
    if(!pQ1 || !pQ2)
        return 0.0f;
#endif

    return pQ1->x * pQ2->x + pQ1->y * pQ2->y + pQ1->z * pQ2->z + pQ1->w * pQ2->w;
}


D3DXINLINE D3DXQUATERNION* D3DXQuaternionIdentity
    ( D3DXQUATERNION *pOut )
{
#ifdef D3DX_DEBUG
    if(!pOut)
        return NULL;
#endif

    pOut->x = pOut->y = pOut->z = 0.0f;
    pOut->w = 1.0f;
    return pOut;
}

D3DXINLINE BOOL D3DXQuaternionIsIdentity
    ( const D3DXQUATERNION *pQ )
{
#ifdef D3DX_DEBUG
    if(!pQ)
        return FALSE;
#endif

    return pQ->x == 0.0f && pQ->y == 0.0f && pQ->z == 0.0f && pQ->w == 1.0f;
}


D3DXINLINE D3DXQUATERNION* D3DXQuaternionConjugate
    ( D3DXQUATERNION *pOut, const D3DXQUATERNION *pQ )
{
#ifdef D3DX_DEBUG
    if(!pOut || !pQ)
        return NULL;
#endif

    pOut->x = -pQ->x;
    pOut->y = -pQ->y;
    pOut->z = -pQ->z;
    pOut->w =  pQ->w;
    return pOut;
}


//--------------------------
// Plane
//--------------------------

D3DXINLINE float D3DXPlaneDot
    ( const D3DXPLANE *pP, const D3DXVECTOR4 *pV)
{
#ifdef D3DX_DEBUG
    if(!pP || !pV)
        return 0.0f;
#endif

    return pP->a * pV->x + pP->b * pV->y + pP->c * pV->z + pP->d * pV->w;
}

D3DXINLINE float D3DXPlaneDotCoord
    ( const D3DXPLANE *pP, const D3DXVECTOR3 *pV)
{
#ifdef D3DX_DEBUG
    if(!pP || !pV)
        return 0.0f;
#endif

    return pP->a * pV->x + pP->b * pV->y + pP->c * pV->z + pP->d;
}

D3DXINLINE float D3DXPlaneDotNormal
    ( const D3DXPLANE *pP, const D3DXVECTOR3 *pV)
{
#ifdef D3DX_DEBUG
    if(!pP || !pV)
        return 0.0f;
#endif

    return pP->a * pV->x + pP->b * pV->y + pP->c * pV->z;
}


//--------------------------
// Color
//--------------------------

D3DXINLINE D3DXCOLOR* D3DXColorNegative
    (D3DXCOLOR *pOut, const D3DXCOLOR *pC)
{
#ifdef D3DX_DEBUG
    if(!pOut || !pC)
        return NULL;
#endif

    pOut->r = 1.0f - pC->r;
    pOut->g = 1.0f - pC->g;
    pOut->b = 1.0f - pC->b;
    pOut->a = pC->a;
    return pOut;
}

D3DXINLINE D3DXCOLOR* D3DXColorAdd        
    (D3DXCOLOR *pOut, const D3DXCOLOR *pC1, const D3DXCOLOR *pC2)
{
#ifdef D3DX_DEBUG
    if(!pOut || !pC1 || !pC2)
        return NULL;
#endif

    pOut->r = pC1->r + pC2->r;
    pOut->g = pC1->g + pC2->g;
    pOut->b = pC1->b + pC2->b;
    pOut->a = pC1->a + pC2->a;
    return pOut;
}

D3DXINLINE D3DXCOLOR* D3DXColorSubtract   
    (D3DXCOLOR *pOut, const D3DXCOLOR *pC1, const D3DXCOLOR *pC2)
{
#ifdef D3DX_DEBUG
    if(!pOut || !pC1 || !pC2)
        return NULL;
#endif

    pOut->r = pC1->r - pC2->r;
    pOut->g = pC1->g - pC2->g;
    pOut->b = pC1->b - pC2->b;
    pOut->a = pC1->a - pC2->a;
    return pOut;
}

D3DXINLINE D3DXCOLOR* D3DXColorScale      
    (D3DXCOLOR *pOut, const D3DXCOLOR *pC, float s)
{
#ifdef D3DX_DEBUG
    if(!pOut || !pC)
        return NULL;
#endif

    pOut->r = pC->r * s;
    pOut->g = pC->g * s;
    pOut->b = pC->b * s;
    pOut->a = pC->a * s;
    return pOut;
} 

D3DXINLINE D3DXCOLOR* D3DXColorModulate   
    (D3DXCOLOR *pOut, const D3DXCOLOR *pC1, const D3DXCOLOR *pC2)
{
#ifdef D3DX_DEBUG
    if(!pOut || !pC1 || !pC2)
        return NULL;
#endif

    pOut->r = pC1->r * pC2->r;
    pOut->g = pC1->g * pC2->g;
    pOut->b = pC1->b * pC2->b;
    pOut->a = pC1->a * pC2->a;
    return pOut;
}

D3DXINLINE D3DXCOLOR* D3DXColorLerp       
    (D3DXCOLOR *pOut, const D3DXCOLOR *pC1, const D3DXCOLOR *pC2, float s)
{
#ifdef D3DX_DEBUG
    if(!pOut || !pC1 || !pC2)
        return NULL;
#endif

    pOut->r = pC1->r + s * (pC2->r - pC1->r);
    pOut->g = pC1->g + s * (pC2->g - pC1->g);
    pOut->b = pC1->b + s * (pC2->b - pC1->b);
    pOut->a = pC1->a + s * (pC2->a - pC1->a);
    return pOut;
}


#endif // __D3DXMATH_INL__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\d3dxsprite.h ===
///////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:       d3dxsprite.h
//  Content:    D3DX sprite helper functions
//
//      These functions allow you to use sprites with D3DX. A "sprite" is
//      loosely defined as a 2D image that you want to transfer to the 
//      rendering target. The source image can be a texture created
//      with the help of the D3DX texture loader; though advanced users may
//      want to create their own. A helper function (PrepareDeviceForSprite)
//      is provided to make it easy to set up render states on a device. 
//      (Again, advanced users can use their own created devices.) 
//
//      There are two general techniques for sprites; the simpler one just
//      specifies a destination rectangle and a rotation anlge. A more 
//      powerful technique supports rendering to non-rectangular quads.
//
//      Both techniques support clipping, alpha, and rotation. More
//      details are below.
//
///////////////////////////////////////////////////////////////////////////

#ifndef __D3DXSPRITE_H__
#define __D3DXSPRITE_H__

#include <d3d.h>
#include <limits.h>
#include "d3dxerr.h"

#ifdef __cplusplus
extern "C" {
#endif


//-------------------------------------------------------------------------
// D3DXPrepareDeviceForSprite:
//
// Call this function to set up all the render states necessary for
// BltSprite/WarpSprite to work correctly. (Advanced users may opt to
// not call this function first; in which case Blt/WarpSprite functions
// will use whatever render/texture states were set up on the device when
// they are called.)
//
// Warning: This function modifies render states and may impact performance
// negatively on some 3D hardware if it is called too often per frame.
//
// Warning: If the render state changes (other than through calls to 
// BltSprite or WarpSprite), you will need to call this function again before 
// calling BltSprite or WarpSprite.
//
// Details: This function modifies the the rendering first texture stage and 
// it modifies some renderstates for the entire device. Here is the exact 
// list:
// 
//   SetTextureStageState(0, D3DTSS_COLORARG1,         D3DTA_TEXTURE);
//   SetTextureStageState(0, D3DTSS_COLOROP,           D3DTOP_SELECTARG1);
//   SetTextureStageState(0, D3DTSS_ALPHAARG1,         D3DTA_TEXTURE);
//   SetTextureStageState(0, D3DTSS_ALPHAARG2,         D3DTA_DIFFUSE);
//   SetTextureStageState(0, D3DTSS_ALPHAOP,           D3DTOP_MODULATE);
//   SetTextureStageState(0, D3DTSS_MINFILTER,         D3DTFN_LINEAR);
//   SetTextureStageState(0, D3DTSS_MAGFILTER,         D3DTFG_LINEAR);
// 
//   SetRenderState(D3DRENDERSTATE_SRCBLEND,           D3DBLEND_SRCALPHA);
//   SetRenderState(D3DRENDERSTATE_DESTBLEND,          D3DBLEND_INVSRCALPHA);
//   SetRenderState(D3DRENDERSTATE_ALPHABLENDENABLE,   TRUE);
//
//   Depending on the value of ZEnable parameter, this function will
//   will either call
//   SetRenderState(D3DRENDERSTATE_ZENABLE,            FALSE);
//   - or -
//   SetRenderState(D3DRENDERSTATE_ZENABLE,            TRUE);
//
// Parameters: 
//      pd3dDevice  - a pointer to the d3d device that you wish to prepare
//                    for use with D3DX Sprite Services
//      ZEnable     - a flag indicating whether you want the sprites to
//                    check and update the Z buffer as part of rendering.
//                    If ZEnable is FALSE, OR you are using
//                    alpha-blending, then it is necessary to render your
//                    sprites from back-to-front. 
//
//-------------------------------------------------------------------------

#ifdef __cplusplus
HRESULT WINAPI
    D3DXPrepareDeviceForSprite( LPDIRECT3DDEVICE7 pd3dDevice, 
                                BOOL ZEnable = FALSE);
#else
HRESULT WINAPI
    D3DXPrepareDeviceForSprite( LPDIRECT3DDEVICE7 pd3dDevice, 
                                BOOL ZEnable);
#endif



//-------------------------------------------------------------------------
// The D3DXDrawBasicSprite() function performs blitting of source images onto 
// a 3D rendering device. This function only calls SetTexture on the first 
// renderstage with the parameter (pd3dTexture) if that parameter is non-null. 
// This function assumes that D3DXPrepareDeviceForSprite has been called on 
// the device or that caller has in some other way correctly prepared the 
// renderstates.
//
// This function supports scaling, rotations, alpha-blending, and choosing 
// a source sub-rect.
// 
// Rotation angle is specified in radians. Both rotations and scales
// are applied around the center of the sprite; where the center of the
// sprite is half the width/height of the sprite, plus the offset parameter. 
//
// Use the offset parameter if you want the sprite's center to be something 
// other than the image center.
//
// The destination point indicates where you would like the center of
// the sprite to draw to.
//
// Parameters: 
//      pd3dTexture - a pointer to the surface containing the texture
//      pd3dDevice  - a pointer to the d3d device to render to. It is
//                    assumed that render states are set up. (See
//                    D3DXPrepareDeviceForSprite)
//      ppointDest  - a pointer to the target point for the sprite. The
//                    components of the vector must be in screen
//                    space.
//      alpha       - alpha value to apply to sprite. 1.0 means totally
//                    opaque; and 0.0 means totally transparent. 
//                    WARNING: If you are using alpha, then you should render
//                    from back to front in order to avoid rendering
//                    artifacts.
//      angleRad    - angle of rotation around the 'center' of the rect
//      scale       - a uniform scale that is applied to the source rect
//                    to specify the size of the image that is rendered
//      pOffset     - offset from the center of the source rect to use as the 
//                    center of rotation
//      pSourceRect - a rect that indicates what portion of the source
//                    source texture to use. If NULL is passed, then the
//                    entire source is used. If the source texture was 
//                    created via D3DX, then the rect should be specified
//                    in the coordinates of the original image (so that you
//                    don't have to worry about stretching/scaling that D3DX
//                    may have done to make the image work with your current
//                    3D Device.) Note that horizontal or vertical mirroring 
//                    may be simply accomplished by swapping the left/right 
//                    or top/bottom fields of this RECT.
//-------------------------------------------------------------------------

#ifdef __cplusplus
HRESULT WINAPI 
    D3DXDrawSpriteSimple(LPDIRECTDRAWSURFACE7  pd3dTexture, 
                         LPDIRECT3DDEVICE7     pd3dDevice, 
                         const D3DXVECTOR3     *ppointDest, 
                         float                 alpha        = 1.0f,
                         float                 scale        = 1.0f,
                         float                 angleRad     = 0.0f,
                         const D3DXVECTOR2     *pOffset     = NULL,
                         const RECT            *pSourceRect = NULL);
#else
HRESULT WINAPI 
    D3DXDrawSpriteSimple(LPDIRECTDRAWSURFACE7  pd3dTexture, 
                         LPDIRECT3DDEVICE7     pd3dDevice, 
                         D3DXVECTOR3           *ppointDest, 
                         float                 alpha,
                         float                 scale,
                         float                 angleRad,
                         D3DXVECTOR2           *pOffset,
                         RECT                  *pSourceRect);
#endif

//-------------------------------------------------------------------------
// The D3DXDrawSprite() function transforms source images onto a 3D 
// rendering device. It takes a general 4x4 matrix which is use to transform
// the points of a default rect: (left=-.5, top=-.5, right=+.5, bottom=+.5).
// (This default rect was chosen so that it was centered around the origin
// to ease setting up rotations. And it was chosen to have a width/height of one
// to ease setting up scales.)
// 
// This function only calls SetTexture on the first 
// renderstage with the parameter (pd3dTexture) if that parameter is non-null. 
// This function assumes that D3DXPrepareDeviceForSprite has been called on 
// the device or that caller has in some other way correctly prepared the 
// renderstates.
//
// This function supports alpha-blending, and choosing 
// a source sub-rect. (A value of NULL for source sub-rect means the entire
// texture is used.)
//
// Note that if the transformed points have a value for w (the homogenous
// coordinate) that is not 1, then this function will invert it and pass
// that value to D3D as the rhw field of a TLVERTEX. If the value for w is
// zero, then it use 1 as the rhw.
//
// Parameters: 
//      pd3dTexture - a pointer to the surface containing the texture
//      pd3dDevice  - a pointer to the d3d device to render to. It is
//                    assumed that render states are set up. (See
//                    D3DXPrepareDeviceForSprite)
//      pMatrixTransform - 4x4 matrix that specifies the transformation
//                    that will be applied to the default -.5 to +.5 
//                    rectangle.
//      alpha       - alpha value to apply to sprite. 1.0 means totally
//                    opaque; and 0.0 means totally transparent. 
//                    WARNING: If you are using alpha, then you should render
//                    from back to front in order to avoid rendering
//                    artifacts.Furthermore, you should avoid scenarios where 
//                    semi-transparent objects intersect.
//      pSourceRect - a rect that indicates what portion of the source
//                    source texture to use. If NULL is passed, then the
//                    entire source is used. If the source texture was 
//                    created via D3DX, then the rect should be specified
//                    in the coordinates of the original image (so that you
//                    don't have to worry about stretching/scaling that D3DX
//                    may have done to make the image work with your current
//                    3D Device.) Note that mirroring may be simply accomplished
//                    by swapping the left/right or top/bottom fields of
//                    this RECT.
// 
//-------------------------------------------------------------------------

#ifdef __cplusplus
HRESULT WINAPI 
    D3DXDrawSpriteTransform(LPDIRECTDRAWSURFACE7  pd3dTexture, 
                            LPDIRECT3DDEVICE7     pd3dDevice, 
                            const D3DXMATRIX      *pMatrixTransform, 
                            float                 alpha         = 1.0f,
                            const RECT            *pSourceRect  = NULL);
#else
HRESULT WINAPI 
    D3DXDrawSpriteTransform(LPDIRECTDRAWSURFACE7  pd3dTexture, 
                            LPDIRECT3DDEVICE7     pd3dDevice, 
                            D3DXMATRIX            *pMatrixTransform, 
                            float                 alpha,
                            RECT                  *pSourceRect);
#endif

//-------------------------------------------------------------------------
// The D3DXBuildSpriteTransform() function is a helper provided which
// creates a matrix corresponding to simple properties. This matrix is
// set up to pass directly to D3DXTransformSprite.
//
// Parameters: 
//      pMatrix     - a pointer to the result matrix
//      prectDest   - a pointer to the target rectangle for the sprite
//      angleRad    - angle of rotation around the 'center' of the rect
//      pOffset     - offset from the center of the source rect to use as the 
//                    center of rotation
// 
//-------------------------------------------------------------------------

#ifdef __cplusplus
void WINAPI
    D3DXBuildSpriteTransform(D3DXMATRIX            *pMatrix,
                             const RECT            *prectDest,
                             float                 angleRad     = 0.0f,
                             const D3DXVECTOR2     *pOffset     = NULL);
#else
void WINAPI
    D3DXBuildSpriteTransform(D3DXMATRIX            *pMatrix,
                             RECT                  *prectDest,
                             float                 angleRad,
                             D3DXVECTOR2           *pOffset);
#endif


//-------------------------------------------------------------------------
// The D3DXDrawSprite3D() function renders a texture onto a 3D quad. The
// quad ABCD is broken into two triangles ABC and ACD which are rendered
// via DrawPrim.
//
// Parameters: 
//      pd3dTexture - a pointer to the surface containing the texture
//      pd3dDevice  - a pointer to the d3d device to render to. It is
//                    assumed that render states are set up. (See
//                    D3DXPrepareDeviceForSprite)
//      quad        - array of 4 points in the following order:
//                    upper-left, upper-right, lower-right, lower-left.
//                    If these vectors contain a W, then this function
//                    will take the reciprocal of that value to pass as
//                    as the rhw (i.e. reciprocal homogenous w).
//      alpha       - alpha value to apply to sprite. 1.0 means totally
//                    opaque; and 0.0 means totally transparent. 
//                    WARNING: If you are using alpha, then you should render
//                    from back to front in order to avoid rendering
//                    artifacts.Furthermore, you should avoid scenarios where 
//                    semi-transparent objects intersect.
//      pSourceRect - a rect that indicates what portion of the source
//                    source texture to use. If NULL is passed, then the
//                    entire source is used. If the source texture was 
//                    created via D3DX, then the rect should be specified
//                    in the coordinates of the original image (so that you
//                    don't have to worry about stretching/scaling that D3DX
//                    may have done to make the image work with your current
//                    3D Device.) Note that mirroring may be simply accomplished
//                    by swapping the left/right or top/bottom fields of
//                    this RECT.
//-------------------------------------------------------------------------

#ifdef __cplusplus
HRESULT WINAPI 
    D3DXDrawSprite3D(LPDIRECTDRAWSURFACE7  pd3dTexture, 
                     LPDIRECT3DDEVICE7     pd3dDevice, 
                     const D3DXVECTOR4     quad[4], 
                     float                 alpha         = 1.0f,
                     const RECT            *pSourceRect  = NULL);
#else
HRESULT WINAPI 
    D3DXDrawSprite3D(LPDIRECTDRAWSURFACE7  pd3dTexture, 
                     LPDIRECT3DDEVICE7     pd3dDevice, 
                     D3DXVECTOR4           quad[4], 
                     float                 alpha,
                     RECT                  *pSourceRect);
#endif



#ifdef __cplusplus
} // extern "C"
#endif

#endif // __D3DXSPRITE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\datapath.h ===
/*****************************************************************************\
*                                                                             *
* DataPath.h    Obsolete DataPath header                                      *
*                                                                             *
*               Copyright 1995 - 1999 Microsoft Corp. All rights reserved.    *
*                                                                             *
\*****************************************************************************/

#ifndef __datapath_h__
#define __datapath_h__
#pragma message("WARNING: your code should #include ocidl.h instead of datapath.h")
#include <ocidl.h>
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\daogetrw.h ===
/************************************************************************
**  D A O G E T R W . H                                                 *
**                                                                      *
**  GetRows interface                                                   *
**                                                                      *
**  Warning: This file is copied from cdaost.h. Changes must be made    *
**           in both files                                              *
**                                                                      *
**                                                                      *
*************************************************************************
** Copyright (C) 1996 by Microsoft Corporation                          *
**         All Rights Reserved                                          *
************************************************************************/

#if !defined (_DAOGETRW_H_)
#define _DAOGETRW_H_

/*
	Enumerations
*/
typedef enum
	{
	DAOCOLKIND_IND = 0,
	DAOCOLKIND_STR,
	DAOCOLKIND_WSTR
	} DAOCOLKIND;

typedef enum
	{
	DAO_I2 = 0,
	DAO_I4,
	DAO_R4,
	DAO_R8,
	DAO_CURRENCY,
	DAO_DATE,
	DAO_BOOL,
	DAO_BSTR,
	DAO_LPSTR,
	DAO_LPWSTR,
	DAO_BLOB,
	DAO_BYTES,
	DAO_CHAR,
	DAO_WCHAR,
	DAO_ANYVARIANT,
	DAO_BOOKMARK,
	DAO_BYTE,
	DAO_GUID,
	DAO_DATATYPEMAX
	} DAODATATYPE;

/*
	Macros
*/
#define DAO_NOINDICATOR 0xffffffff
#define DAO_NULL        0xffffffff
#define DAO_CANTCOERCE  0xfffffffc
#define DAO_NOMAXLENGTH 0x00000000

#define DAOROWFETCH_CALLEEALLOCATES     0x00000001
#define DAOROWFETCH_DONTADVANCE         0x00000002
#define DAOROWFETCH_FORCEREFRESH        0x00000004
#define DAOROWFETCH_BINDABSOLUTE        0x00000008
#define DAOROWFETCH_ODBCNEXT			0x00000010

#define DAOBINDING_DIRECT               0x00000001
#define DAOBINDING_VARIANT              0x00000002
#define DAOBINDING_CALLBACK             0x00000004

/*
	Structures
*/
typedef struct
	{
	DWORD           dwKind;
	union
		{
		LONG        ind;
		LPCSTR      lpstr;
		LPCWSTR		lpwstr;
		};
	} DAOCOLUMNID;
typedef DAOCOLUMNID *LPDAOCOLUMNID;

// Callback for binding
EXTERN_C typedef HRESULT (STDAPICALLTYPE *LPDAOBINDFUNC)(ULONG cb, DWORD dwUser, LPVOID *ppData);
#define DAOBINDINGFUNC(f)   STDAPI f (ULONG cb, DWORD dwUser, LPVOID *ppData)

typedef struct
	{
	DAOCOLUMNID     columnID;
	ULONG           cbDataOffset;
	ULONG           cbMaxLen;
	ULONG           cbInfoOffset;
	DWORD           dwBinding;
	DWORD           dwDataType;
	DWORD           dwUser;
	} DAOCOLUMNBINDING;
typedef DAOCOLUMNBINDING *LPDAOCOLUMNBINDING;

typedef struct
	{
	ULONG           cRowsRequested;
	DWORD           dwFlags;
	LPVOID          pData;
	LPVOID          pVarData;
	ULONG           cbVarData;
	ULONG           cRowsReturned;
	} DAOFETCHROWS;
typedef DAOFETCHROWS *LPDAOFETCHROWS;

/*
	New Errors

	**NOTE: OLE standard ids to be determined.
*/
#define S_BUFFERTOOSMALL    MAKE_SCODE(SEVERITY_SUCCESS,    FACILITY_ITF,   0x1000)
#define S_ENDOFCURSOR       MAKE_SCODE(SEVERITY_SUCCESS,    FACILITY_ITF,   0x1001)
#define S_SILENTCANCEL      MAKE_SCODE(SEVERITY_SUCCESS,    FACILITY_ITF,   0x1002)
#define S_RECORDDELETED     MAKE_SCODE(SEVERITY_SUCCESS,    FACILITY_ITF,   0x1003)

#define E_ROWTOOSHORT       MAKE_SCODE(SEVERITY_ERROR,      FACILITY_ITF,   0x1000)
#define E_BADBINDINFO       MAKE_SCODE(SEVERITY_ERROR,      FACILITY_ITF,   0x1001)
#define E_COLUMNUNAVAILABLE MAKE_SCODE(SEVERITY_ERROR,      FACILITY_ITF,   0x1002)


/*
	Interfaces
*/
#undef INTERFACE
#define INTERFACE ICDAORecordset
DECLARE_INTERFACE_(ICDAORecordset, IDispatch)
	{
	STDMETHOD(GetRows)          (THIS_ LONG cRowsToSkip, LONG cCol, LPDAOCOLUMNBINDING prgBndCol, ULONG cbRowLen, LPDAOFETCHROWS pFetchRows) PURE;
	STDMETHOD(SetNotify)		(THIS_ REFIID riid, BOOL fNotify);
	STDMETHOD(GetNotify)		(THIS_ REFIID riid, BOOL *fNotify);
	STDMETHOD(OnBeforeNotify)	(THIS_ REFIID riid, DWORD cat, DWORD rsn, VARIANT v1, VARIANT v2);
	STDMETHOD(OnAfterNotify)	(THIS_ REFIID riid, DWORD cat, DWORD rsn, VARIANT v1, VARIANT v2, HRESULT hr);
	STDMETHOD(PutLock)			(THIS_ BOOL f);
	STDMETHOD(GetLock)			(THIS_ BOOL *f);
	STDMETHOD(AddGetRowsErr)    (THIS_ HRESULT hr) PURE;
	};

//Get rows errors
#define errVtoFetchBuffTooSmall	-30028	//3640	The fetch buffer was too small for the amount of data you requested.
#define errVtoEOFDuringFetch	-30029	//3641	There are fewer records remaining in the recordset than you requested.
#define errVtoSilentCancel		-30030	//3642	A cancel was performed on the operation.
#define errVtoRecordDeleted		-30031	//3643	One of the records in the recordset was deleted by another process.
#define errVtoRowLenTooSmall	-30032	//3646	The specified row length is shorter than the sum of the column lengths.
#define errVtoBadBindInfo		-30033	//3645	One of the binding parameters is incorrect.
#define errVtoColumnMissing		-30034	//3647	A column requested is not being returned to the recordset.

#endif // _DAOGETRW_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\data.h ===
/*
================================================================================
    ========================================================================
    ========================================================================

    File:           cdata.h
    Description:    headers for CData and child classes
    Created:        9/3/1997
    Author:         Matthijs Gates
    Mail:           mgates@microsoft.com

    Copyright (C) 1997  Microsoft Corporation.  All Rights Reserved.

    ========================================================================
    ========================================================================
================================================================================
*/

#if !defined(DATA_H)
#define DATA_H

#include "brtest.h"
#include "util.h"

//==============================================================================
//
//  Class:  CData
//
//------------------------------------------------------------------------------
//  Description:        root class for data.
//
//  Public methods:
//
//  Public properties:
//
//  9/3/1997
//  mgates
//
//==============================================================================
class CData
{
    CRITICAL_SECTION    m_crtCDataLock ;    // critical section lock
    INT                 m_iBufferSize ;     // buffer sizes are always in bytes !

    VOID InitCData() ;
    
    // P U B L I C

    public :
    
        CData() ;
        virtual ~CData() ;
    
        virtual BYTE    *GetBuffer() { return m_lpbBuffer ; }
        virtual INT     GetBufferSize() { return m_iBufferSize ; }
        
    // P R O T E C T E D
        
    protected :

        virtual BOOL    CDataSetBuffer(BYTE *lpbBuffer, INT iBufferSize) ;
        VOID    Lock()      { EnterCriticalSection(&m_crtCDataLock) ; }
        VOID    Unlock()    { LeaveCriticalSection(&m_crtCDataLock) ; }

        BYTE *m_lpbBuffer ;
} ;

//==============================================================================
//
//  Class:  CDataCountup
//
//------------------------------------------------------------------------------
//  Description:
//
//  Public methods:
//
//  Public properties:
//
//  9/12/1997
//  mgates
//
//==============================================================================
class CDataCountup : public CData
{
    BOOL    m_fFirst ;
    INT     m_cDword ;
    BOOL    m_fFreeze ;
    
    // P U B L I C -------------------------------------------------------------

    public :
    
        CDataCountup(INT iBufferSize = DEF_DATABUFFERSIZE) ;
        ~CDataCountup() ;
        
        virtual BYTE    *GetBuffer() ;
        BOOL SetBufferSize(INT iBufferSize) ;
        VOID Reset(INT iBaseNumber = 0) ;
        BOOL FreezeCountup(BOOL fFreeze) { m_fFreeze = fFreeze ; return TRUE ; }
        BOOL IsCountupFrozen()  { return m_fFreeze ; }
        
        enum { DEF_DATABUFFERSIZE   = 1024,
               MIN_BUFFERSIZE       = 100,
               MAX_BUFFERSIZE       = 65504     // max UDP is 65507, aligned on
                                                //  DWORD boundary is 65504
             } ;
} ;

//==============================================================================
//
//  Class:  CDataString
//
//------------------------------------------------------------------------------
//  Description:        CData derivative to hold a regular null-terminated
//                      string.
//
//  Public methods:
//                      Set()           sets the content
//                      GetBuffer()     retrieves the null-terminated string
//                      GetBufferSize() returns the length of the string,
//                                        excluding the null-terminator
//
//  Public properties:
//                      - none -
//
//  9/4/1997
//  mgates
//
//==============================================================================
class CDataString : public CData
{
    CString m_strBuffer ;
    
    // P U B L I C

    public :
    
        CDataString() { ; }
        CDataString(CString &strBuffer) : m_strBuffer(strBuffer) { ; }
        CDataString(const char *szBuffer) : m_strBuffer(szBuffer) { ; }
        ~CDataString() ;
        
        BOOL Set(CString &strBuffer) ;
        BOOL Set(const char *szBuffer) ;
        
        BYTE *GetBuffer() { return (BYTE *) m_strBuffer.GetBuffer(0) ; }
        INT GetBufferSize() { return m_strBuffer.GetLength() ; }
} ;

#endif  // DATA_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\datguids.h ===
// fe7d6c53-2dac-446a-b0bd-d73e21e924c9
DEFINE_GUID(DATAFMT_SCRIPT,0xfe7d6c53,0x2dac,0x446a,0xb0,0xbd,0xd7,0x3e,0x21,0xe9,0x24,0xc9);
// 485da097-141e-4aa5-bb3b-a5618d95d02b
DEFINE_GUID(DATAFMT_EXEC,0x485da097,0x141e,0x4aa5,0xbb,0x3b,0xa5,0x61,0x8d,0x95,0xd0,0x2b);
// 1b7639b6-6357-47d1-9a07-12452dc073e9
DEFINE_GUID(DATAFMT_UNICODE16,0x1b7639b6,0x6357,0x47d1,0x9a,0x07,0x12,0x45,0x2d,0xc0,0x73,0xe9);
// 1b49cb32-e3a4-43f0-9c94-d0197bb97114
DEFINE_GUID(DATAFMT_HTML,0x1b49cb32,0xe3a4,0x43f0,0x9c,0x94,0xd0,0x19,0x7b,0xb9,0x71,0x14);
// 369eeeab-a0e8-45ca-86a6-a83ce5697e28
DEFINE_GUID(DATAFMT_DPOF,0x369eeeab,0xa0e8,0x45ca,0x86,0xa6,0xa8,0x3c,0xe5,0x69,0x7e,0x28);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\dbdaoerr.h ===
/************************************************************************
**	D B D A O E R R . H													*														*
**																		*
**		History 														*
**		------- 														*
**	5-17-95 Added to DAO SDK				 							*
**	7-17-95 Added DBDAOERR macro, removed internal only codes																	*
**	8-30-96 Added replication and ODBC direct errors																	*
**																		*
**	The following #defines map the integer to a descriptive name
**	i.e.  3270 -> E_DAO_VtoPropNotFound									*
**																		*
**																		*
*************************************************************************
** Copyright (C) 1996 by Microsoft Corporation		 					*
**		   All Rights Reserved					 						*
************************************************************************/

#ifndef _DDAOERR_H_
#define _DDAOERR_H_

#define DBDAOERR(x) MAKE_SCODE(SEVERITY_ERROR, FACILITY_CONTROL, x)

#define E_DAO_InternalError					DBDAOERR(3000) //Reserved error (|); there is no message for this error.
#define E_DAO_InvalidParameter				DBDAOERR(3001) //Invalid argument.
#define E_DAO_CantBegin						DBDAOERR(3002) //Couldn't start session.
#define E_DAO_TransTooDeep					DBDAOERR(3003) //Couldn't start transaction; too many transactions already nested.
#define E_DAO_DatabaseNotFound				DBDAOERR(3004) //Couldn't find database '|'.
#define E_DAO_DatabaseInvalidName			DBDAOERR(3005) //'|' isn't a valid database name.
#define E_DAO_DatabaseLocked				DBDAOERR(3006) //Database '|' is exclusively locked.
#define E_DAO_DatabaseOpenError				DBDAOERR(3007) //Can't open library database '|'.
#define E_DAO_TableLocked					DBDAOERR(3008) //Table '|' is exclusively locked.
#define E_DAO_TableInUse					DBDAOERR(3009) //Couldn't lock table '|'; currently in use.
#define E_DAO_TableDuplicate				DBDAOERR(3010) //Table '|' already exists.
#define E_DAO_ObjectNotFound				DBDAOERR(3011) //Couldn't find object '|'.
#define E_DAO_ObjectDuplicate				DBDAOERR(3012) //Object '|' already exists.
#define E_DAO_CannotRename					DBDAOERR(3013) //Couldn't rename installable ISAM file.
#define E_DAO_TooManyOpenTables				DBDAOERR(3014) //Can't open any more tables.
#define E_DAO_IndexNotFound					DBDAOERR(3015) //'|' isn't an index in this table.
#define E_DAO_ColumnDoesNotFit 				DBDAOERR(3016) //Field won't fit in record.
#define E_DAO_ColumnTooBig					DBDAOERR(3017) //The size of a field is too long.
#define E_DAO_ColumnNotFound				DBDAOERR(3018) //Couldn't find field '|'.
#define E_DAO_NoCurrentIndex				DBDAOERR(3019) //Operation invalid without a current index.
#define E_DAO_RecordNoCopy					DBDAOERR(3020) //Update or CancelUpdate without AddNew or Edit.
#define E_DAO_NoCurrentRecord				DBDAOERR(3021) //No current record.
#define E_DAO_KeyDuplicate					DBDAOERR(3022) //Duplicate value in index, primary key, or relationship.  Changes were unsuccessful.
#define E_DAO_AlreadyPrepared				DBDAOERR(3023) //AddNew or Edit already used.
#define E_DAO_FileNotFound					DBDAOERR(3024) //Couldn't find file '|'.
#define E_DAO_TooManyOpenFiles				DBDAOERR(3025) //Can't open any more files.
#define E_DAO_DiskFull						DBDAOERR(3026) //Not enough space on disk.
#define E_DAO_PermissionDenied				DBDAOERR(3027) //Can't update.  Database or object is read-only.
#define E_DAO_CannotOpenSystemDb			DBDAOERR(3028) //Can't start your application. The system database is missing or opened exclusively by another user.
#define E_DAO_InvalidLogon					DBDAOERR(3029) //Not a valid account name or password.
#define E_DAO_InvalidAccountName			DBDAOERR(3030) //'|' isn't a valid account name.
#define E_DAO_InvalidPassword				DBDAOERR(3031) //Not a valid password.
#define E_DAO_InvalidOperation				DBDAOERR(3032) //Can't perform this operation.
#define E_DAO_AccessDenied					DBDAOERR(3033) //No permission for '|'.
#define E_DAO_NotInTransaction				DBDAOERR(3034) //Commit or Rollback without BeginTrans.
#define E_DAO_OutOfMemory					DBDAOERR(3035) //*
#define E_DAO_CantAllocatePage				DBDAOERR(3036) //Database has reached maximum size.
#define E_DAO_NoMoreCursors					DBDAOERR(3037) //Can't open any more tables or queries.
#define E_DAO_OutOfBuffers					DBDAOERR(3038) //*
#define E_DAO_TooManyIndexes				DBDAOERR(3039) //Couldn't create index; too many indexes already defined.
#define E_DAO_ReadVerifyFailure				DBDAOERR(3040) //Disk I/O error during read.
#define E_DAO_FilesysVersion				DBDAOERR(3041) //Can't open a database created with a previous version of your application.
#define E_DAO_NoMoreFiles					DBDAOERR(3042) //Out of MS-DOS file handles.
#define E_DAO_DiskError						DBDAOERR(3043) //Disk or network error.
#define E_DAO_InvalidPath					DBDAOERR(3044) //'|' isn't a valid path.
#define E_DAO_FileShareViolation			DBDAOERR(3045) //Couldn't use '|'; file already in use.
#define E_DAO_FileLockViolation				DBDAOERR(3046) //Couldn't save; currently locked by another user.
#define E_DAO_RecordTooBig					DBDAOERR(3047) //Record is too large.
#define E_DAO_TooManyOpenDatabases			DBDAOERR(3048) //Can't open any more databases.
#define E_DAO_InvalidDatabase				DBDAOERR(3049) //Can't open database '|'.  It may not be a database that your application recognizes, or the file may be corrupt.
#define E_DAO_FileLockingUnavailable		DBDAOERR(3050) //Couldn't lock file.
#define E_DAO_FileAccessDenied				DBDAOERR(3051) //Couldn't open file '|'.
#define E_DAO_SharingBufferExceeded			DBDAOERR(3052) //MS-DOS file sharing lock count exceeded.  You need to increase the number of locks installed with SHARE.EXE.
#define E_DAO_TaskLimitExceeded				DBDAOERR(3053) //Too many client tasks.
#define E_DAO_TooManyLongColumns			DBDAOERR(3054) //Too many Memo or OLE object fields.
#define E_DAO_InvalidFilename				DBDAOERR(3055) //Not a valid file name.
#define E_DAO_AbortSalvage					DBDAOERR(3056) //Couldn't repair this database.
#define E_DAO_LinkNotSupported				DBDAOERR(3057) //Operation not supported on attached, or linked, tables.
#define E_DAO_NullKeyDisallowed				DBDAOERR(3058) //Index or primary key can't contain a null value.
#define E_DAO_OperationCanceled				DBDAOERR(3059) //Operation canceled by user.
#define E_DAO_QueryParmTypeMismatch			DBDAOERR(3060) //Wrong data type for parameter '|'.
#define E_DAO_QueryMissingParmsM			DBDAOERR(3061) //Too few parameters. Expected |.
#define E_DAO_QueryDuplicateAliasM			DBDAOERR(3062) //Duplicate output alias '|'.
#define E_DAO_QueryDuplicateOutputM			DBDAOERR(3063) //Duplicate output destination '|'.
#define E_DAO_QueryIsBulkOp					DBDAOERR(3064) //Can't open action query '|'.
#define E_DAO_QueryIsNotBulkOp				DBDAOERR(3065) //Can't execute a non-action query.
#define E_DAO_QueryNoOutputsM				DBDAOERR(3066) //Query or table must contain at least one output field.
#define E_DAO_QueryNoInputTablesM			DBDAOERR(3067) //Query input must contain at least one table or query.
#define E_DAO_QueryInvalidAlias				DBDAOERR(3068) //Not a valid alias name.
#define E_DAO_QueryInvalidBulkInputM		DBDAOERR(3069) //The action query '|' cannot be used as a row source.
#define E_DAO_QueryUnboundRef				DBDAOERR(3070) //Can't bind name '|'.
#define E_DAO_QueryExprEvaluation			DBDAOERR(3071) //Can't evaluate expression.
#define E_DAO_EvalEBESErr					DBDAOERR(3072) //|
#define E_DAO_QueryNotUpdatable				DBDAOERR(3073) //Operation must use an updatable query.
#define E_DAO_TableRepeatInFromList			DBDAOERR(3074) //Can't repeat table name '|' in FROM clause.
#define E_DAO_QueryExprSyntax				DBDAOERR(3075) //|1 in query expression '|2'.
#define E_DAO_QbeExprSyntax					DBDAOERR(3076) //| in criteria expression.
#define E_DAO_FindExprSyntax				DBDAOERR(3077) //| in expression.
#define E_DAO_InputTableNotFound			DBDAOERR(3078) //Couldn't find input table or query '|'.
#define E_DAO_QueryAmbigRefM				DBDAOERR(3079) //Ambiguous field reference '|'.
#define E_DAO_JoinTableNotInput				DBDAOERR(3080) //Joined table '|' not listed in FROM clause.
#define E_DAO_UnaliasedSelfJoin				DBDAOERR(3081) //Can't join more than one table with the same name (|).
#define E_DAO_ColumnNotInJoinTable			DBDAOERR(3082) //JOIN operation '|' refers to a non-joined table.
#define E_DAO_QueryIsMGB					DBDAOERR(3083) //Can't use internal report query.
#define E_DAO_QueryInsIntoBulkMGB			DBDAOERR(3084) //Can't insert data with action query.
#define E_DAO_ExprUnknownFunctionM			DBDAOERR(3085) //Undefined function '|' in expression.
#define E_DAO_QueryCannotDelete				DBDAOERR(3086) //Couldn't delete from specified tables.
#define E_DAO_QueryTooManyGroupExprs		DBDAOERR(3087) //Too many expressions in GROUP BY clause.
#define E_DAO_QueryTooManyOrderExprs		DBDAOERR(3088) //Too many expressions in ORDER BY clause.
#define E_DAO_QueryTooManyDistExprs			DBDAOERR(3089) //Too many expressions in DISTINCT output.
#define E_DAO_Column2ndSysMaint				DBDAOERR(3090) //Resultant table not allowed to have more than one Counter or Autonumber field.
#define E_DAO_HavingWOGrouping				DBDAOERR(3091) //HAVING clause (|) without grouping or aggregation.
#define E_DAO_HavingOnTransform				DBDAOERR(3092) //Can't use HAVING clause in TRANSFORM statement.
#define E_DAO_OrderVsDistinct				DBDAOERR(3093) //ORDER BY clause (|) conflicts with DISTINCT.
#define E_DAO_OrderVsGroup					DBDAOERR(3094) //ORDER BY clause (|) conflicts with GROUP BY clause.
#define E_DAO_AggregateInArgument			DBDAOERR(3095) //Can't have aggregate function in expression (|).
#define E_DAO_AggregateInWhere				DBDAOERR(3096) //Can't have aggregate function in WHERE clause (|).
#define E_DAO_AggregateInOrderBy			DBDAOERR(3097) //Can't have aggregate function in ORDER BY clause (|).
#define E_DAO_AggregateInGroupBy			DBDAOERR(3098) //Can't have aggregate function in GROUP BY clause (|).
#define E_DAO_AggregateInJoin				DBDAOERR(3099) //Can't have aggregate function in JOIN operation (|).
#define E_DAO_NullInJoinKey					DBDAOERR(3100) //Can't set field '|' in join key to Null.
#define E_DAO_ValueBreaksJoin				DBDAOERR(3101) //There is no record in table '|2' with key matching field(s) '|1'.
#define E_DAO_QueryTreeCycle				DBDAOERR(3102) //Circular reference caused by '|'.
#define E_DAO_OutputAliasCycle				DBDAOERR(3103) //Circular reference caused by alias '|' in query definition's SELECT list.
#define E_DAO_QryDuplicatedFixedSetM		DBDAOERR(3104) //Can't specify Fixed Column Heading '|' in a crosstab query more than once.
#define E_DAO_NoSelectIntoColumnName		DBDAOERR(3105) //Missing destination field name in SELECT INTO statement (|).
#define E_DAO_NoUpdateColumnName			DBDAOERR(3106) //Missing destination field name in UPDATE statement (|).
#define E_DAO_QueryNoInsertPerm				DBDAOERR(3107) //Record(s) can't be added; no Insert Data permission on '|'.
#define E_DAO_QueryNoReplacePerm			DBDAOERR(3108) //Record(s) can't be edited; no Update Data permission on '|'.
#define E_DAO_QueryNoDeletePerm				DBDAOERR(3109) //Record(s) can't be deleted; no Delete Data permission on '|'.
#define E_DAO_QueryNoReadDefPerm			DBDAOERR(3110) //Couldn't read definitions; no Read Design permission for table or query '|'.
#define E_DAO_QueryNoTblCrtPerm				DBDAOERR(3111) //Couldn't create; no Create permission for table or query '|'.
#define E_DAO_QueryNoReadPerm				DBDAOERR(3112) //Record(s) can't be read; no Read Data permission on '|'.
#define E_DAO_QueryColNotUpd				DBDAOERR(3113) //Can't update '|'; field not updatable.
#define E_DAO_QueryLVInDistinct				DBDAOERR(3114) //Can't include Memo or OLE object when you select unique values (|).
#define E_DAO_QueryLVInAggregate			DBDAOERR(3115) //Can't have Memo or OLE object in aggregate argument (|).
#define E_DAO_QueryLVInHaving				DBDAOERR(3116) //Can't have Memo or OLE object in criteria (|) for aggregate function.
#define E_DAO_QueryLVInOrderBy				DBDAOERR(3117) //Can't sort on Memo or OLE object (|).
#define E_DAO_QueryLVInJoin					DBDAOERR(3118) //Can't join on Memo or OLE object (|).
#define E_DAO_QueryLVInGroupBy				DBDAOERR(3119) //Can't group on Memo or OLE object (|).
#define E_DAO_DotStarWithGrouping			DBDAOERR(3120) //Can't group on fields selected with '*' (|).
#define E_DAO_StarWithGrouping				DBDAOERR(3121) //Can't group on fields selected with '*'.
#define E_DAO_IllegalDetailRef				DBDAOERR(3122) //'|' not part of aggregate function or grouping.
#define E_DAO_StarNotAtLevel0				DBDAOERR(3123) //Can't use '*' in crosstab query.
#define E_DAO_QueryInvalidMGBInput			DBDAOERR(3124) //Can't input from internal report query (|).
#define E_DAO_InvalidName					DBDAOERR(3125) //'|' isn't a valid name.
#define E_DAO_QueryBadBracketing			DBDAOERR(3126) //Invalid bracketing of name '|'.
#define E_DAO_InsertIntoUnknownCol			DBDAOERR(3127) //INSERT INTO statement contains unknown field name '|'.
#define E_DAO_QueryNoDeleteTables			DBDAOERR(3128) //Must specify tables to delete from.
#define E_DAO_SQLSyntax						DBDAOERR(3129) //Invalid SQL statement; expected 'DELETE', 'INSERT', 'PROCEDURE', 'SELECT', or 'UPDATE'.
#define E_DAO_SQLDeleteSyntax				DBDAOERR(3130) //Syntax error in DELETE statement.
#define E_DAO_SQLFromSyntax					DBDAOERR(3131) //Syntax error in FROM clause.
#define E_DAO_SQLGroupBySyntax				DBDAOERR(3132) //Syntax error in GROUP BY clause.
#define E_DAO_SQLHavingSyntax				DBDAOERR(3133) //Syntax error in HAVING clause.
#define E_DAO_SQLInsertSyntax				DBDAOERR(3134) //Syntax error in INSERT statement.
#define E_DAO_SQLJoinSyntax					DBDAOERR(3135) //Syntax error in JOIN operation.
#define E_DAO_SQLLevelSyntax				DBDAOERR(3136) //Syntax error in LEVEL clause.
#define E_DAO_SQLMissingSemicolon			DBDAOERR(3137) //Missing semicolon (;) at end of SQL statement.
#define E_DAO_SQLOrderBySyntax				DBDAOERR(3138) //Syntax error in ORDER BY clause.
#define E_DAO_SQLParameterSyntax			DBDAOERR(3139) //Syntax error in PARAMETER clause.
#define E_DAO_SQLProcedureSyntax			DBDAOERR(3140) //Syntax error in PROCEDURE clause.
#define E_DAO_SQLSelectSyntax				DBDAOERR(3141) //Syntax error in SELECT statement.
#define E_DAO_SQLTooManyTokens				DBDAOERR(3142) //Characters found after end of SQL statement.
#define E_DAO_SQLTransformSyntax			DBDAOERR(3143) //Syntax error in TRANSFORM statement.
#define E_DAO_SQLUpdateSyntax				DBDAOERR(3144) //Syntax error in UPDATE statement.
#define E_DAO_SQLWhereSyntax				DBDAOERR(3145) //Syntax error in WHERE clause.
#define E_DAO_RmtSQLCError					DBDAOERR(3146) //ODBC--call failed.
#define E_DAO_RmtDataOverflow				DBDAOERR(3147) //*
#define E_DAO_RmtConnectFailed				DBDAOERR(3148) //*
#define E_DAO_RmtIncorrectSqlcDll			DBDAOERR(3149) //*
#define E_DAO_RmtMissingSqlcDll				DBDAOERR(3150) //*
#define E_DAO_RmtConnectFailedM				DBDAOERR(3151) //ODBC--connection to '|' failed.
#define E_DAO_RmtDrvrVer					DBDAOERR(3152) //*
#define E_DAO_RmtSrvrVer					DBDAOERR(3153) //*
#define E_DAO_RmtMissingOdbcDll				DBDAOERR(3154) //ODBC--couldn't find DLL '|'.
#define E_DAO_RmtInsertFailedM				DBDAOERR(3155) //ODBC--insert failed on attached (linked) table '|'.
#define E_DAO_RmtDeleteFailedM				DBDAOERR(3156) //ODBC--delete failed on attached (linked) table '|'.
#define E_DAO_RmtUpdateFailedM				DBDAOERR(3157) //ODBC--update failed on attached (linked) table '|'.
#define E_DAO_RecordLocked					DBDAOERR(3158) //Couldn't save record; currently locked by another user.
#define E_DAO_InvalidBookmark				DBDAOERR(3159) //Not a valid bookmark.
#define E_DAO_TableNotOpen					DBDAOERR(3160) //Table isn't open.
#define E_DAO_DecryptFail					DBDAOERR(3161) //Couldn't decrypt file.
#define E_DAO_NullInvalid					DBDAOERR(3162) //Null is invalid.
#define E_DAO_InvalidBufferSize				DBDAOERR(3163) //Couldn't perform operation; data too long for field.
#define E_DAO_ColumnNotUpdatable			DBDAOERR(3164) //Field can't be updated.
#define E_DAO_CantMakeINFFile				DBDAOERR(3165) //Couldn't open .INF file.
#define E_DAO_MissingMemoFile				DBDAOERR(3166) //Missing memo file.
#define E_DAO_RecordDeleted					DBDAOERR(3167) //Record is deleted.
#define E_DAO_INFFileError					DBDAOERR(3168) //Invalid .INF file.
#define E_DAO_ExprIllegalType				DBDAOERR(3169) //Illegal type in expression.
#define E_DAO_InstalIsamNotFound			DBDAOERR(3170) //Couldn't find installable ISAM.
#define E_DAO_NoConfigParameters			DBDAOERR(3171) //Couldn't find net path or user name.
#define E_DAO_CantAccessPdoxNetDir			DBDAOERR(3172) //Couldn't open PARADOX.NET.
#define E_DAO_NoMSysAccounts				DBDAOERR(3173) //Couldn't open table 'MSysAccounts' in the system database file.
#define E_DAO_NoMSysGroups					DBDAOERR(3174) //Couldn't open table 'MSysGroups' in the system database file.
#define E_DAO_DateOutOfRange				DBDAOERR(3175) //Date is out of range or is in an invalid format.
#define E_DAO_ImexCantOpenFile				DBDAOERR(3176) //Couldn't open file '|'.
#define E_DAO_ImexBadTableName				DBDAOERR(3177) //Not a valid table name.
#define E_DAO_ImexOutOfMemory				DBDAOERR(3178) //*
#define E_DAO_ImexEndofFile					DBDAOERR(3179) //Encountered unexpected end of file.
#define E_DAO_ImexCantWriteToFile			DBDAOERR(3180) //Couldn't write to file '|'.
#define E_DAO_ImexBadRange					DBDAOERR(3181) //Invalid range.
#define E_DAO_ImexBogusFile					DBDAOERR(3182) //Invalid file format.
#define E_DAO_TempDiskFull					DBDAOERR(3183) //Not enough space on temporary disk.
#define E_DAO_RmtLinkNotFound				DBDAOERR(3184) //Couldn't execute query; couldn't find attached, or linked, table.
#define E_DAO_RmtTooManyColumns				DBDAOERR(3185) //SELECT INTO remote database tried to produce too many fields.
#define E_DAO_ReadConflictM					DBDAOERR(3186) //Couldn't save; currently locked by user '|2' on machine '|1'.
#define E_DAO_CommitConflictM				DBDAOERR(3187) //Couldn't read; currently locked by user '|2' on machine '|1'.
#define E_DAO_SessionWriteConflict			DBDAOERR(3188) //Couldn't update; currently locked by another session on this machine.
#define E_DAO_JetSpecialTableLocked			DBDAOERR(3189) //Table '|1' is exclusively locked by user '|3' on machine '|2'.
#define E_DAO_TooManyColumns				DBDAOERR(3190) //Too many fields defined.
#define E_DAO_ColumnDuplicate				DBDAOERR(3191) //Can't define field more than once.
#define E_DAO_OutputTableNotFound			DBDAOERR(3192) //Couldn't find output table '|'.
#define E_DAO_JetNoUserName					DBDAOERR(3193) //(unknown)
#define E_DAO_JetNoMachineName				DBDAOERR(3194) //(unknown)
#define E_DAO_JetNoColumnName				DBDAOERR(3195) //(expression)
#define E_DAO_DatabaseInUse					DBDAOERR(3196) //Couldn't use '|'; database already in use.
#define E_DAO_DataHasChanged				DBDAOERR(3197) //Data has changed; operation stopped.
#define E_DAO_TooManySessions				DBDAOERR(3198) //Couldn't start session.  Too many sessions already active.
#define E_DAO_ReferenceNotFound				DBDAOERR(3199) //Couldn't find reference.
#define E_DAO_IntegrityViolMasterM			DBDAOERR(3200) //Can't delete or change record.  Since related records exist in table '|', referential integrity rules would be violated.
#define E_DAO_IntegrityViolSlaveM			DBDAOERR(3201) //Can't add or change record.  Referential integrity rules require a related record in table '|'.
#define E_DAO_ReadConflict					DBDAOERR(3202) //Couldn't save; currently locked by another user.
#define E_DAO_AggregatingHigherLevel		DBDAOERR(3203) //Can't specify subquery in expression (|).
#define E_DAO_DatabaseDuplicate				DBDAOERR(3204) //Database already exists.
#define E_DAO_QueryTooManyXvtColumn			DBDAOERR(3205) //Too many crosstab column headers (|).
#define E_DAO_SelfReference					DBDAOERR(3206) //Can't create a relationship between a field and itself.
#define E_DAO_CantUseUnkeyedTable			DBDAOERR(3207) //Operation not supported on Paradox table with no primary key.
#define E_DAO_IllegalDeletedOption			DBDAOERR(3208) //Invalid Deleted entry in the Xbase section of initialization setting.
#define E_DAO_IllegalStatsOption			DBDAOERR(3209) //Invalid Stats entry in the Xbase section of initialization setting.
#define E_DAO_ConnStrTooLong				DBDAOERR(3210) //Connection string too long.
#define E_DAO_TableInUseQM					DBDAOERR(3211) //Couldn't lock table '|'; currently in use.
#define E_DAO_JetSpecialTableInUse			DBDAOERR(3212) //Couldn't lock table '|1'; currently in use by user '|3' on machine '|2'.
#define E_DAO_IllegalDateOption				DBDAOERR(3213) //Invalid Date entry in the Xbase section of initialization setting.
#define E_DAO_IllegalMarkOption				DBDAOERR(3214) //Invalid Mark entry in the Xbase section of initialization setting.
#define E_DAO_BtrieveTooManyTasks			DBDAOERR(3215) //Too many Btrieve tasks.
#define E_DAO_QueryParmNotTableid			DBDAOERR(3216) //Parameter '|' specified where a table name is required.
#define E_DAO_QueryParmNotDatabase			DBDAOERR(3217) //Parameter '|' specified where a database name is required.
#define E_DAO_WriteConflict					DBDAOERR(3218) //Couldn't update; currently locked.
#define E_DAO_IllegalOperation				DBDAOERR(3219) //Invalid operation.
#define E_DAO_WrongCollatingSequence		DBDAOERR(3220) //Incorrect collating sequence.
#define E_DAO_BadConfigParameters			DBDAOERR(3221) //Invalid entries in the Btrieve section of initialization setting.
#define E_DAO_QueryContainsDbParm			DBDAOERR(3222) //Query can't contain a Database parameter.
#define E_DAO_QueryInvalidParmM				DBDAOERR(3223) //'|' isn't a valid parameter name.
#define E_DAO_BtrieveDDCorrupted			DBDAOERR(3224) //Can't read Btrieve data dictionary.
#define E_DAO_BtrieveDeadlock				DBDAOERR(3225) //Encountered record locking deadlock while performing Btrieve operation.
#define E_DAO_BtrieveFailure				DBDAOERR(3226) //Errors encountered while using the Btrieve DLL.
#define E_DAO_IllegalCenturyOption			DBDAOERR(3227) //Invalid Century entry in the Xbase section of initialization setting.
#define E_DAO_IllegalCollatingSeq			DBDAOERR(3228) //Invalid Collating Sequence.
#define E_DAO_NonModifiableKey				DBDAOERR(3229) //Btrieve--can't change field.
#define E_DAO_ObsoleteLockFile				DBDAOERR(3230) //Out-of-date Paradox lock file.
#define E_DAO_RmtColDataTruncated			DBDAOERR(3231) //ODBC--field would be too long; data truncated.
#define E_DAO_RmtCreateTableFailed			DBDAOERR(3232) //ODBC--couldn't create table.
#define E_DAO_RmtOdbcVer					DBDAOERR(3233) //*
#define E_DAO_RmtQueryTimeout				DBDAOERR(3234) //ODBC--remote query timeout expired.
#define E_DAO_RmtTypeIncompat				DBDAOERR(3235) //ODBC--data type not supported on server.
#define E_DAO_RmtUnexpectedNull				DBDAOERR(3236) //*
#define E_DAO_RmtUnexpectedType				DBDAOERR(3237) //*
#define E_DAO_RmtValueOutOfRange			DBDAOERR(3238) //ODBC--data out of range.
#define E_DAO_TooManyActiveUsers			DBDAOERR(3239) //Too many active users.
#define E_DAO_CantStartBtrieve				DBDAOERR(3240) //Btrieve--missing Btrieve engine.
#define E_DAO_OutOfBVResources				DBDAOERR(3241) //Btrieve--out of resources.
#define E_DAO_QueryBadUpwardRefedM			DBDAOERR(3242) //Invalid reference in SELECT statement.
#define E_DAO_ImexNoMatchingColumns			DBDAOERR(3243) //None of the import field names match fields in the appended table.
#define E_DAO_ImexPasswordProtected			DBDAOERR(3244) //Can't import password-protected spreadsheet.
#define E_DAO_ImexUnparsableRecord			DBDAOERR(3245) //Couldn't parse field names from first row of import table.
#define E_DAO_InTransaction					DBDAOERR(3246) //Operation not supported in transactions.
#define E_DAO_RmtLinkOutOfSync				DBDAOERR(3247) //ODBC--linked table definition has changed.
#define E_DAO_IllegalNetworkOption			DBDAOERR(3248) //Invalid NetworkAccess entry in initialization setting.
#define E_DAO_IllegalTimeoutOption			DBDAOERR(3249) //Invalid PageTimeout entry in initialization setting.
#define E_DAO_CantBuildKey					DBDAOERR(3250) //Couldn't build key.
#define E_DAO_FeatureNotAvailable			DBDAOERR(3251) //Operation is not supported for this type of object.
#define E_DAO_IllegalReentrancy				DBDAOERR(3252) //Can't open form whose underlying query contains a user-defined function that attempts to set or get the form's RecordsetClone property.
#define E_DAO_UNUSED						DBDAOERR(3253) //*
#define E_DAO_RmtDenyWriteIsInvalid			DBDAOERR(3254) //ODBC--Can't lock all records.
#define E_DAO_ODBCParmsChanged				DBDAOERR(3255) //*
#define E_DAO_INFIndexNotFound 				DBDAOERR(3256) //Index file not found.
#define E_DAO_SQLOwnerAccessSyntax			DBDAOERR(3257) //Syntax error in WITH OWNERACCESS OPTION declaration.
#define E_DAO_QueryAmbiguousJoins			DBDAOERR(3258) //Query contains ambiguous outer joins.
#define E_DAO_InvalidColumnType				DBDAOERR(3259) //Invalid field data type.
#define E_DAO_WriteConflictM				DBDAOERR(3260) //Couldn't update; currently locked by user '|2' on machine '|1'.
#define E_DAO_TableLockedM					DBDAOERR(3261) //|
#define E_DAO_TableInUseMUQM				DBDAOERR(3262) //|
#define E_DAO_InvalidTableId				DBDAOERR(3263) //Invalid database object.
#define E_DAO_VtoNoFields					DBDAOERR(3264) //No fields defined - cannot append Tabledef or Index.
#define E_DAO_VtoNameNotFound				DBDAOERR(3265) //Item not found in this collection.
#define E_DAO_VtoFieldInCollection			DBDAOERR(3266) //Can't append.  Field is part of a TableDefs collection.
#define E_DAO_VtoNotARecordset				DBDAOERR(3267) //Property can be set only when the field is part of a Recordset object's Fields collection.
#define E_DAO_VtoNoSetObjInDb				DBDAOERR(3268) //Can't set this property once the object is part of a collection.
#define E_DAO_VtoIndexInCollection			DBDAOERR(3269) //Can't append.  Index is part of a TableDefs collection.
#define E_DAO_VtoPropNotFound				DBDAOERR(3270) //Property not found.
#define E_DAO_VtoIllegalValue				DBDAOERR(3271) //Invalid property value.
#define E_DAO_VtoNotArray					DBDAOERR(3272) //Object isn't a collection.
#define E_DAO_VtoNoSuchMethod				DBDAOERR(3273) //Method not applicable for this object.
#define E_DAO_NotExternalFormat				DBDAOERR(3274) //External table isn't in the expected format.
#define E_DAO_UnexpectedEngineReturn		DBDAOERR(3275) //Unexpected error from external database driver (|).
#define E_DAO_InvalidDatabaseId				DBDAOERR(3276) //Invalid database ID.
#define E_DAO_TooManyKeys					DBDAOERR(3277) //Can't have more than 10 fields in an index.
#define E_DAO_NotInitialized				DBDAOERR(3278) //Database engine hasn't been initialized.
#define E_DAO_AlreadyInitialized			DBDAOERR(3279) //Database engine has already been initialized.
#define E_DAO_ColumnInUse					DBDAOERR(3280) //Can't delete a field that is part of an index or is needed by the system.
#define E_DAO_IndexInUse					DBDAOERR(3281) //Can't delete this index.  It is either the current index or is used in a relationship.
#define E_DAO_TableNotEmpty					DBDAOERR(3282) //Can't create field or index in a table that is already defined.
#define E_DAO_IndexHasPrimary				DBDAOERR(3283) //Primary key already exists.
#define E_DAO_IndexDuplicate				DBDAOERR(3284) //Index already exists.
#define E_DAO_IndexInvalidDef				DBDAOERR(3285) //Invalid index definition.
#define E_DAO_WrongMemoFileType				DBDAOERR(3286) //Format of memo file doesn't match specified external database format.
#define E_DAO_ColumnCannotIndex				DBDAOERR(3287) //Can't create index on the given field.
#define E_DAO_IndexHasNoPrimary				DBDAOERR(3288) //Paradox index is not primary.
#define E_DAO_DDLConstraintSyntax			DBDAOERR(3289) //Syntax error in CONSTRAINT clause.
#define E_DAO_DDLCreateTableSyntax			DBDAOERR(3290) //Syntax error in CREATE TABLE statement.
#define E_DAO_DDLCreateIndexSyntax			DBDAOERR(3291) //Syntax error in CREATE INDEX statement.
#define E_DAO_DDLColumnDefSyntax			DBDAOERR(3292) //Syntax error in field definition.
#define E_DAO_DDLAlterTableSyntax			DBDAOERR(3293) //Syntax error in ALTER TABLE statement.
#define E_DAO_DDLDropIndexSyntax			DBDAOERR(3294) //Syntax error in DROP INDEX statement.
#define E_DAO_DDLDropSyntax					DBDAOERR(3295) //Syntax error in DROP TABLE or DROP INDEX.
#define E_DAO_V11NotSupported				DBDAOERR(3296) //Join expression not supported.
#define E_DAO_ImexNothingToImport			DBDAOERR(3297) //Couldn't import table or query.  No records found, or all records contain errors.
#define E_DAO_RmtTableAmbiguous				DBDAOERR(3298) //There are several tables with that name.  Please specify owner in the format 'owner.table'.
#define E_DAO_JetODBCConformanceError		DBDAOERR(3299) //ODBC Specification Conformance Error (|).  This error should be reported to the ODBC driver vendor.
#define E_DAO_IllegalRelationship			DBDAOERR(3300) //Can't create a relationship.
#define E_DAO_DBVerFeatureNotAvailable		DBDAOERR(3301) //Can't perform this operation; features in this version are not available in databases with older formats.
#define E_DAO_RulesLoaded					DBDAOERR(3302) //Can't change a rule while the rules for this table are in use.
#define E_DAO_ColumnInRelationship			DBDAOERR(3303) //Can't delete this field.  It's part of one or more relationships.
#define E_DAO_InvalidPin					DBDAOERR(3304) //You must enter a personal identifier (PID) consisting of at least four and no more than 20 characters and digits.
#define E_DAO_RmtBogusConnStr				DBDAOERR(3305) //Invalid connection string in pass-through query.
#define E_DAO_SingleColumnExpected			DBDAOERR(3306) //At most one field can be returned from a subquery that doesn't use the EXISTS keyword.
#define E_DAO_ColumnCountMismatch			DBDAOERR(3307) //The number of columns in the two selected tables or queries of a union query don't match.
#define E_DAO_InvalidTopArgumentM			DBDAOERR(3308) //Invalid TOP argument in select query.
#define E_DAO_PropertyTooLarge				DBDAOERR(3309) //Property setting can't be larger than 2 KB.
#define E_DAO_JPMInvalidForV1x				DBDAOERR(3310) //This property isn't supported for external data sources or for databases created in a previous version.
#define E_DAO_PropertyExists				DBDAOERR(3311) //Property specified already exists.
#define E_DAO_TLVNativeUserTablesOnly		DBDAOERR(3312) //Validation rules and default values can't be placed on system or attached (linked) tables.
#define E_DAO_TLVInvalidColumn				DBDAOERR(3313) //Can't place this validation expression on this field.
#define E_DAO_TLVNoNullM					DBDAOERR(3314) //Field '|' can't contain a null value.
#define E_DAO_TLVNoBlankM					DBDAOERR(3315) //Field '|' can't be a zero-length string.
#define E_DAO_TLVRuleViolationM				DBDAOERR(3316) //|
#define E_DAO_TLVRuleVioNoMessage			DBDAOERR(3317) //One or more values entered is prohibited by the validation rule '|2' set for '|1'.
#define E_DAO_QueryTopNotAllowedM			DBDAOERR(3318) //Top not allowed in delete queries.
#define E_DAO_SQLUnionSyntax				DBDAOERR(3319) //Syntax error in union query.
#define E_DAO_TLVExprSyntaxM				DBDAOERR(3320) //| in table-level validation expression.
#define E_DAO_NoDbInConnStr					DBDAOERR(3321) //No database specified in connection string or IN clause.
#define E_DAO_QueryBadValueListM			DBDAOERR(3322) //Crosstab query contains one or more invalid fixed column headings.
#define E_DAO_QueryIsNotRowReturning		DBDAOERR(3323) //The query can not be used as a row source.
#define E_DAO_QueryIsDDL					DBDAOERR(3324) //This query is a DDL query and cannot be used as a row source.
#define E_DAO_SPTReturnedNoRecords			DBDAOERR(3325) //Pass-through query with ReturnsRecords property set to True did not return any records.
#define E_DAO_QueryIsSnapshot				DBDAOERR(3326) //This Recordset is not updatable.
#define E_DAO_QueryExprOutput				DBDAOERR(3327) //Field '|' is based on an expression and can't be edited.
#define E_DAO_QueryTableRO					DBDAOERR(3328) //Table '|2' is read-only.
#define E_DAO_QueryRowDeleted				DBDAOERR(3329) //Record in table '|' was deleted by another user.
#define E_DAO_QueryRowLocked				DBDAOERR(3330) //Record in table '|' is locked by another user.
#define E_DAO_QueryFixupChanged				DBDAOERR(3331) //To make changes to this field, first save the record.
#define E_DAO_QueryCantFillIn				DBDAOERR(3332) //Can't enter value into blank field on 'one' side of outer join.
#define E_DAO_QueryWouldOrphan				DBDAOERR(3333) //Records in table '|' would have no record on the 'one' side.
#define E_DAO_V10Format						DBDAOERR(3334) //Can be present only in version 1.0 format.
#define E_DAO_InvalidDelete					DBDAOERR(3335) //DeleteOnly called with non-zero cbData.
#define E_DAO_IllegalIndexDDFOption			DBDAOERR(3336) //Btrieve: Invalid IndexDDF option in initialization setting.
#define E_DAO_IllegalDataCodePage			DBDAOERR(3337) //Invalid DataCodePage option in initialization setting.
#define E_DAO_XtrieveEnvironmentError		DBDAOERR(3338) //Btrieve: Xtrieve options aren't correct in initialization setting.
#define E_DAO_IllegalIndexNumberOption		DBDAOERR(3339) //Btrieve: Invalid IndexDeleteRenumber option in initialization setting.
#define E_DAO_QueryIsCorruptM				DBDAOERR(3340) //Query '|' is corrupt.
#define E_DAO_IncorrectJoinKeyM				DBDAOERR(3341) //Current field must match join key '|' on 'one' side of outer join because it has been updated.
#define E_DAO_QueryLVInSubqueryM			DBDAOERR(3342) //Invalid Memo or OLE object in subquery '|'.
#define E_DAO_InvalidDatabaseM				DBDAOERR(3343) //Unrecognized database format '|'.
#define E_DAO_TLVCouldNotBindRef			DBDAOERR(3344) //Unknown or invalid reference '|1' in validation expression or default value in table '|2'.
#define E_DAO_CouldNotBindRef				DBDAOERR(3345) //Unknown or invalid field reference '|'.
#define E_DAO_QueryWrongNumDestCol			DBDAOERR(3346) //Number of query values and destination fields aren't the same.
#define E_DAO_QueryPKeyNotOutput			DBDAOERR(3347) //Can't add record(s); primary key for table '|' not in recordset.
#define E_DAO_QueryJKeyNotOutput			DBDAOERR(3348) //Can't add record(s); join key of table '|' not in recordset.
#define E_DAO_NumericFieldOverflow			DBDAOERR(3349) //Numeric field overflow.
#define E_DAO_InvalidObject					DBDAOERR(3350) //Object is invalid for operation.
#define E_DAO_OrderVsUnion					DBDAOERR(3351) //ORDER BY expression (|) uses non-output fields.
#define E_DAO_NoInsertColumnNameM			DBDAOERR(3352) //No destination field name in INSERT INTO statement (|).
#define E_DAO_MissingDDFFile				DBDAOERR(3353) //Btrieve: Can't find file FIELD.DDF.
#define E_DAO_SingleRecordExpected			DBDAOERR(3354) //At most one record can be returned by this subquery.
#define E_DAO_DefaultExprSyntax				DBDAOERR(3355) //Syntax error in default value.
#define E_DAO_ExclusiveDBConflict			DBDAOERR(3356) //The database is opened by user '|2' on machine '|1'.
#define E_DAO_QueryIsNotDDL					DBDAOERR(3357) //This query is not a properly formed data-definition query.
#define E_DAO_SysDatabaseOpenError			DBDAOERR(3358) //Can't open Microsoft Jet engine system database.
#define E_DAO_SQLInvalidSPT					DBDAOERR(3359) //Pass-through query must contain at least one character.
#define E_DAO_QueryTooComplex				DBDAOERR(3360) //Query is too complex.
#define E_DAO_SetOpInvalidInSubquery		DBDAOERR(3361) //Unions not allowed in a subquery.
#define E_DAO_RmtMultiRowUpdate				DBDAOERR(3362) //Single-row update/delete affected more than one row of an attached (linked) table.  Unique index contains duplicate values.
#define E_DAO_QueryNoJoinedRecord			DBDAOERR(3363) //Record(s) can't be added; no corresponding record on the 'one' side.
#define E_DAO_QueryLVInSetOp				DBDAOERR(3364) //Can't use Memo or OLE object field '|' in SELECT clause of a union query.
#define E_DAO_VtoInvalidOnRemote			DBDAOERR(3365) //Property value not valid for REMOTE objects.
#define E_DAO_VtoNoFieldsRel				DBDAOERR(3366) //Can't append a relation with no fields defined.
#define E_DAO_VtoObjectInCollection			DBDAOERR(3367) //Can't append.  Object already in collection.
#define E_DAO_DDLDiffNumRelCols				DBDAOERR(3368) //Relationship must be on the same number of fields with the same data types.
#define E_DAO_DDLIndexColNotFound			DBDAOERR(3369) //Can't find field in index definition.
#define E_DAO_DDLPermissionDenied			DBDAOERR(3370) //Can't modify the design of table '|'.  It's in a read-only database.
#define E_DAO_DDLObjectNotFound				DBDAOERR(3371) //Can't find table or constraint.
#define E_DAO_DDLIndexNotFound				DBDAOERR(3372) //No such index '|2' on table '|1'.
#define E_DAO_DDLNoPkeyOnRefdTable			DBDAOERR(3373) //Can't create relationship.  Referenced table '|' doesn't have a primary key.
#define E_DAO_DDLColumnsNotUnique			DBDAOERR(3374) //The specified fields are not uniquely indexed in table '|'.
#define E_DAO_DDLIndexDuplicate				DBDAOERR(3375) //Table '|1' already has an index named '|2'
#define E_DAO_DDLTableNotFound				DBDAOERR(3376) //Table '|' doesn't exist.
#define E_DAO_DDLRelNotFound				DBDAOERR(3377) //No such relationship '|2' on table '|1'.
#define E_DAO_DDLRelDuplicate				DBDAOERR(3378) //There is already a relationship named '|' in the current database.
#define E_DAO_DDLIntegrityViolation			DBDAOERR(3379) //Can't create relationships to enforce referential integrity.  Existing data in table '|2' violates referential integrity rules with related table '|1'.
#define E_DAO_DDLColumnDuplicate			DBDAOERR(3380) //Field '|2' already exists in table '|1'.
#define E_DAO_DDLColumnNotFound				DBDAOERR(3381) //There is no field named '|2' in table '|1'.
#define E_DAO_DDLColumnTooBig				DBDAOERR(3382) //The size of field '|' is too long.
#define E_DAO_DDLColumnInRel				DBDAOERR(3383) //Can't delete field '|'.  It's part of one or more relationships.
#define E_DAO_VtoCantDeleteBuiltIn			DBDAOERR(3384) //Can't delete a built-in property.
#define E_DAO_VtoUDPsDontSupportNull		DBDAOERR(3385) //User-defined properties don't support a Null value.
#define E_DAO_VtoMissingRequiredParm		DBDAOERR(3386) //Property '|' must be set before using this method.
#define E_DAO_JetJetInitInvalidPath			DBDAOERR(3387) //Can't find TEMP directory.
#define E_DAO_TLVExprUnknownFunctionM		DBDAOERR(3388) //Unknown function '|2' in validation expression or default value on '|1'.
#define E_DAO_QueryNotSupported				DBDAOERR(3389) //Query support unavailable.
#define E_DAO_AccountDuplicate				DBDAOERR(3390) //Account name already exists.
#define E_DAO_JetwrnPropCouldNotSave		DBDAOERR(3391) //An error has occurred.  Properties were not saved.
#define E_DAO_RelNoPrimaryIndexM			DBDAOERR(3392) //There is no primary key in table '|'.
#define E_DAO_QueryKeyTooBig				DBDAOERR(3393) //Can't perform join, group, sort, or indexed restriction. A value being searched or sorted on is too long.
#define E_DAO_PropMustBeDDL					DBDAOERR(3394) //Can't save property; property is a schema property.
#define E_DAO_IllegalRIConstraint			DBDAOERR(3395) //Invalid referential integrity constraint.
#define E_DAO_RIViolationMasterCM			DBDAOERR(3396) //Can't perform cascading operation.  Since related records exist in table '|', referential integrity rules would be violated.
#define E_DAO_RIViolationSlaveCM			DBDAOERR(3397) //Can't perform cascading operation.  There must be a related record in table '|'.
#define E_DAO_RIKeyNullDisallowedCM			DBDAOERR(3398) //Can't perform cascading operation.  It would result in a null key in table '|'.
#define E_DAO_RIKeyDuplicateCM				DBDAOERR(3399) //Can't perform cascading operation.  It would result in a duplicate key in table '|'.
#define E_DAO_RIUpdateTwiceCM				DBDAOERR(3400) //Can't perform cascading operation.  It would result in two updates on field '|2' in table '|1'.
#define E_DAO_RITLVNoNullCM					DBDAOERR(3401) //Can't perform cascading operation.  It would cause field '|' to become null, which is not allowed.
#define E_DAO_RITLVNoBlankCM				DBDAOERR(3402) //Can't perform cascading operation.  It would cause field '|' to become a zero-length string, which is not allowed.
#define E_DAO_RITLVRuleViolationCM			DBDAOERR(3403) //Can't perform cascading operation:  '|'
#define E_DAO_RITLVRuleVioCNoMessage		DBDAOERR(3404) //Can't perform cascading operation.  The value entered is prohibited by the validation rule '|2' set for '|1'.
#define E_DAO_TLVRuleEvalEBESErr			DBDAOERR(3405) //Error '|' in validation rule.
#define E_DAO_TLVDefaultEvalEBESErr			DBDAOERR(3406) //Error '|' in default value.
#define E_DAO_BadMSysConf					DBDAOERR(3407) //The server's MSysConf table exists, but is in an incorrect format.  Contact your system administrator.
#define E_DAO_TooManyFindSessions			DBDAOERR(3408) //Too many FastFind Sessions were invoked.
#define E_DAO_InvalidColumnM				DBDAOERR(3409) //Invalid field name '|' in definition of index or relationship.
#define E_DAO_REPReadOnly					DBDAOERR(3410) //*
#define E_DAO_RIInvalidBufferSizeCM			DBDAOERR(3411) //Invalid entry.  Can't perform cascading operation specified in table '|1' because value entered is too big for field '|2'.
#define E_DAO_RIWriteConflictCM				DBDAOERR(3412) //|
#define E_DAO_JetSpecialRIWriteConflictCM	DBDAOERR(3413) //Can't perform cascading update on table '|1' because it is currently in use by user '|3' on machine '|2'.
#define E_DAO_RISessWriteConflictCM			DBDAOERR(3414) //Can't perform cascading update on table '|' because it is currently in use.
#define E_DAO_NoBlank						DBDAOERR(3415) //Zero-length string is valid only in a text or Memo field.
#define E_DAO_FutureError					DBDAOERR(3416) //|
#define E_DAO_QueryInvalidBulkInput			DBDAOERR(3417) //An action query cannot be used as a row source.
#define E_DAO_NetCtrlMismatch				DBDAOERR(3418) //Can't open '|'.  Another user has the table open using a different network control file or locking style.
#define E_DAO_4xTableWith3xLocking			DBDAOERR(3419) //Can't open this Paradox 4.x or Paradox 5.x table because ParadoxNetStyle is set to 3.x in the initialization setting.
#define E_DAO_VtoObjectNotSet				DBDAOERR(3420) //Object is invalid or not set.
#define E_DAO_VtoDataConvError				DBDAOERR(3421) //Data type conversion error.
#define E_DAO_TableNotLocked				DBDAOERR(3422) //Can't modify table structure.  Another user has the table open
#define E_DAO_RmtDriverNotSupported			DBDAOERR(3423) //You cannot use ODBC to attach an external Microsoft Access or ISAM database table to your database
#define E_DAO_InvalidLanguageId				DBDAOERR(3424) //Can't create database; Invalid locale
#define E_DAO_VtoInvalidOpDuringCallback	DBDAOERR(3425) //This method or property is not currently available on this Recordset
#define E_DAO_VtoActionCancelled			DBDAOERR(3426) //The action was cancelled by an associated object
#define E_DAO_VtoOleAutoFailed				DBDAOERR(3427) //Error in DAO automation
#define E_DAO_DatabaseCorrupted_Cmpct		DBDAOERR(3428) //The Jet database engine has encountered a problem in your database.  To correct the problem, you must repair and compact the database
#define E_DAO_IncompatibleIIsam				DBDAOERR(3429) //Incompatible installable ISAM version
#define E_DAO_OLEInitializeFailure			DBDAOERR(3430) //While loading the Excel installable ISAM, OLE was unable to initialize
#define E_DAO_OLENotCompoundFile			DBDAOERR(3431) //This is not an Excel 5 file
#define E_DAO_OLEFailure					DBDAOERR(3432) //Error opening an Excel 5 file
#define E_DAO_IllegalIisamIniOption			DBDAOERR(3433) //Invalid parameter in [Excel ISAM] section of the initialization file
#define E_DAO_TableFull						DBDAOERR(3434) //Can't expand named range
#define E_DAO_TableCantClear				DBDAOERR(3435) //Cannot delete Excel cells
#define E_DAO_CreateFailed					DBDAOERR(3436) //Failure creating file
#define E_DAO_DatabaseFull					DBDAOERR(3437) //Excel spreadsheet is full
#define E_DAO_SpecAndColumnMismatch			DBDAOERR(3438) //File specification and data do not match
#define E_DAO_CantOpenWordMergeFiles		DBDAOERR(3439) //Can't attach or import Word mail merge file
#define E_DAO_FileHasNoColumns				DBDAOERR(3440) //Text file has no columns
#define E_DAO_AmbiguousDelimiters			DBDAOERR(3441) //Text file specification field separator matches decimal seperator or text delimiter
#define E_DAO_FileSpecErrorM				DBDAOERR(3442) //Error in entry |2 of section [|1] in schema.ini
#define E_DAO_NoSpecForFixedFormatM			DBDAOERR(3443) //Can't create fixed width text file without column specification in section [|2] of schema.ini
#define E_DAO_WidthMissInFixedSpecM			DBDAOERR(3444) //Column width required for column |2 in section [|1] of schema.ini
#define E_DAO_VtoWrongDllVersion			DBDAOERR(3445) //Incorrect version of JET DLL found
#define E_DAO_VtoMissingVBA					DBDAOERR(3446) //Could not locate a VBA related file
#define E_DAO_VtoVBAFailed					DBDAOERR(3447) //Failed to initialize VBA
#define E_DAO_VtoOLEFailed					DBDAOERR(3448) //An OLE system function failed
#define E_DAO_InvalidCountry				DBDAOERR(3449) //Missing country code
#define E_DAO_QueryIncompleteRowM			DBDAOERR(3450) //Syntax error in query.  Incomplete query clause
#define E_DAO_QueryParmTypeNotAllowed		DBDAOERR(3451) //Illegal reference in query
#define E_DAO_REPDBNotMaster				DBDAOERR(3452) //You can't make changes to the design of the database at this replica.
#define E_DAO_REPCantRelate					DBDAOERR(3453) //You can't establish or maintain an enforced relationship between a replicated table and a local table.
#define E_DAO_REPNotOwner					DBDAOERR(3454) //*
#define E_DAO_CantMakeReplicable			DBDAOERR(3455) //Can't make the database replicable.
#define E_DAO_CantMakeObjectReplicable		DBDAOERR(3456) //Can't make the |2 object in |1 container replicable.
#define E_DAO_REPCantKeepLocal				DBDAOERR(3457) //You can't set the KeepLocal property for an object that is already replicated.
#define E_DAO_REPCantKeepDBLocal			DBDAOERR(3458) //The KeepLocal property cannot be set on a database; it can be set only on the objects in a database.
#define E_DAO_CantUnreplDatabase			DBDAOERR(3459) //After a database has been replicated, you cannot remove the replication features from the database.
#define E_DAO_ReplConflict					DBDAOERR(3460) //The operation you attempted conflicts with an existing operation involving this member of the replica set.
#define E_DAO_REPSetRepid					DBDAOERR(3461) //The replication property you are attempting to set or delete is read-only and can't be changed.
#define E_DAO_TransportLoadFailure			DBDAOERR(3462) //Failure to load a DLL.
#define E_DAO_TransportLoadFailureM			DBDAOERR(3463) //Can't find the .dll '|2'.
#define E_DAO_TypeMismatchM					DBDAOERR(3464) //Data type mismatch in criteria expression.
#define E_DAO_DiskIOM						DBDAOERR(3465) //The disk drive you are attempting to access is unreadable.
#define E_DAO_FileAccessDeniedM				DBDAOERR(3466) //*
#define E_DAO_InvalidPathM					DBDAOERR(3467) //*
#define E_DAO_TranspAccessDeniedM			DBDAOERR(3468) //Access was denied while accessing dropbox folder '|2'.
#define E_DAO_TransportDiskFullM			DBDAOERR(3469) //The disk for dropbox folder '|2' is full.
#define E_DAO_TransportDiskIOM				DBDAOERR(3470) //Disk failure accessing dropbox folder '|2'.
#define E_DAO_LogWriteFail					DBDAOERR(3471) //Failure to write to the Synchronizer log file.
#define E_DAO_LogDiskFullM					DBDAOERR(3472) //Disk full for path '|1'.
#define E_DAO_LogDiskIOM					DBDAOERR(3473) //Disk failure while accessing log file '|1'.
#define E_DAO_LogFileAccessDeniedM			DBDAOERR(3474) //Can't open the log file '|1' for writing.
#define E_DAO_LogFileShareViolationM		DBDAOERR(3475) //Sharing violation while attempting to open log file '|1' in Deny Write mode.
#define E_DAO_TransportInvalidPathM			DBDAOERR(3476) //Invalid dropbox path '|2'.
#define E_DAO_TranspInvalidAddressM			DBDAOERR(3477) //Dropbox address '|2' is syntactically invalid.
#define E_DAO_RepNotPartial					DBDAOERR(3478) //The replica is not a partial replica.
#define E_DAO_RepPartial					DBDAOERR(3479) //Can't designate a partial replica as the Design Master for the replica set.
#define E_DAO_PARTInvalidRelNameM			DBDAOERR(3480) //The relationship '|' in the partial filter expression is invalid.
#define E_DAO_PARTInvalidTableNameM			DBDAOERR(3481) //The table name '|' in the partial filter expression is invalid.
#define E_DAO_REPInvalidFilter				DBDAOERR(3482) //The filter expression for the partial replica is invalid.
#define E_DAO_TranspInvalidPasswordM		DBDAOERR(3483) //The password supplied for the dropbox folder '|2' is invalid.
#define E_DAO_TransDestInvalidPassword		DBDAOERR(3484) //The password used by the Synchronizer to write to a destination dropbox folder is invalid.
#define E_DAO_REPDBNotRep					DBDAOERR(3485) //The object can't be replicated because the database is not replicated.
#define E_DAO_REPSecondGuid					DBDAOERR(3486) //You can't add a second Replication ID AutoNumber field to a table.
#define E_DAO_REPOnlyBuiltin				DBDAOERR(3487) //The database you are attempting to replicate can't be converted.
#define E_DAO_REPNoSuchRepid				DBDAOERR(3488) //The value specified is not a ReplicaID for any member in the replica set.
#define E_DAO_REPObjectNotRep				DBDAOERR(3489) //The object specified can't be replicated because it is missing a  necessary resource.
#define E_DAO_CantCreateReplica				DBDAOERR(3490) //Can't create a new replica because the '|2' object in '|1' container could not be replicated.
#define E_DAO_MustOpenDbExclusive			DBDAOERR(3491) //The database must be opened in exclusive mode before it can be replicated.
#define E_DAO_CantDoSchemaChange			DBDAOERR(3492) //The synchronization failed because a design change could not be applied to one of the replicas.
#define E_DAO_UnableToSetParam				DBDAOERR(3493) //Can't set the specified Registry parameter for the Synchronizer.
#define E_DAO_UnableToGetParam				DBDAOERR(3494) //Unable to retrieve the specified Registry parameter for the Synchronizer.
#define E_DAO_REPNoSuchSchedule				DBDAOERR(3495) //There are no scheduled synchronizations between the two Synchronizers.
#define E_DAO_REPNoSuchExchange				DBDAOERR(3496) //Replication Manager cannot find the ExchangeID in the MSysExchangeLog table.
#define E_DAO_REPCantSetSchedule			DBDAOERR(3497) //Unable to set a schedule for the Synchronizer.
#define E_DAO_REPCantGetSchedule			DBDAOERR(3498) //*
#define E_DAO_REPCantGetDBPath				DBDAOERR(3499) //Can't retrieve the full path information for a member of the replica set.
#define E_DAO_REPCantSetExchange			DBDAOERR(3500) //You cannot specify two different Synchronizers to manage the same replica.
#define E_DAO_REPNotUpdated					DBDAOERR(3501) //*
#define E_DAO_REPNotManaged					DBDAOERR(3502) //The Design Master or replica is not being managed by a Synchronizer.
#define E_DAO_ValueNotSet					DBDAOERR(3503) //The Synchronizer's Registry has no value set for the key you queried.
#define E_DAO_REPInvalidTID					DBDAOERR(3504) //The Synchronizer ID does not match an existing ID in the MSysTranspAddress table.
#define E_DAO_REPFilterNotFound				DBDAOERR(3505) //You attempted to delete or get information about a partial filter that does not exist in MSysFilters.
#define E_DAO_OpenLog						DBDAOERR(3506) //The Synchronizer is unable to open the Synchronizer log.
#define E_DAO_WriteLog						DBDAOERR(3507) //Failure writing to the Synchronizer log.
#define E_DAO_NoTransport					DBDAOERR(3508) //There is no active transport for the Synchronizer.
#define E_DAO_TransportNotFound				DBDAOERR(3509) //Could not find a valid transport for this Synchronizer.
#define E_DAO_ReplicaAlreadyLocked			DBDAOERR(3510) //The member of the replica set you are attempting to synchronize is currently being used in another synchronization.
#define E_DAO_DBAccess						DBDAOERR(3511) //*
#define E_DAO_TransportReadFailure			DBDAOERR(3512) //Failed to read the dropbox folder.
#define E_DAO_TransportWriteFailure			DBDAOERR(3513) //Failed to write to the dropbox folder.
#define E_DAO_NoExchange					DBDAOERR(3514) //Synchronizer could not find any scheduled or on-demand synchronizations to process.
#define E_DAO_SysClock						DBDAOERR(3515) //The Microsoft Jet database engine could not read the system clock on your computer.
#define E_DAO_NoTransportAddress			DBDAOERR(3516) //Destination synchronizer is not configured to support indirect synchronronization, and the destination replica is unavailable for direct synchronization
#define E_DAO_NoMessage						DBDAOERR(3517) //Synchronizer could not find any messages to process.
#define E_DAO_TransporterNotFound			DBDAOERR(3518) //Could not find Synchronizer in the MSysTranspAddress table.
#define E_DAO_TransportSendFailure			DBDAOERR(3519) //Failed to send a message.
#define E_DAO_ReplicaNotFound				DBDAOERR(3520) //The replica name or ID does not match a currently managed member of the replica set.
#define E_DAO_OutOfSynch					DBDAOERR(3521) //Two members of the replica set cannot be synchronized because there is no common point to start the synchronization.
#define E_DAO_ExchangeNotFound				DBDAOERR(3522) //Synchronizer cannot find the record of a specific synchronization in the MSysExchangeLog table.
#define E_DAO_SchemaNotFound				DBDAOERR(3523) //Synchronizer cannot find a specific version number in the MSysSchChange table.
#define E_DAO_SchemaHistMismatch			DBDAOERR(3524) //The history of design changes in the replica does not match the history in the Design Master.
#define E_DAO_MessageDBAccess				DBDAOERR(3525) //Synchronizer could not access the message database.
#define E_DAO_ObjectAlreadyExists			DBDAOERR(3526) //The name selected for the system object is already in use.
#define E_DAO_ObjectDoesntExist				DBDAOERR(3527) //The Synchronizer or Replication Manager could not find the system object.
#define E_DAO_NoNewData						DBDAOERR(3528) //There is no new data in shared memory for the Synchronizer or Replication Manager to read.
#define E_DAO_PrevDataNotRead				DBDAOERR(3529) //The Synchronizer or Replication Manager found unread data in the shared memory. The existing data will be overwritten.
#define E_DAO_ClientAlreadyExists			DBDAOERR(3530) //The Synchronizer is already serving a client.
#define E_DAO_WaitTimeout					DBDAOERR(3531) //The wait period for an event has timed out.
#define E_DAO_ServerInitialization			DBDAOERR(3532) //Synchronizer could not be initialized.
#define E_DAO_ObjectAbandoned				DBDAOERR(3533) //The system object used by a process still exists after the process has stopped.
#define E_DAO_NoEvent						DBDAOERR(3534) //Synchronizer looked for a system event but did not find one to report to the client.
#define E_DAO_ClientSentTerm				DBDAOERR(3535) //Client has asked the Synchronizer to terminate operation.
#define E_DAO_InvalidMessage				DBDAOERR(3536) //Synchronizer received an invalid message for a member of the replica set that it manages.
#define E_DAO_NoClient						DBDAOERR(3537) //The Synchronizer's client is no longer present and cannot be notified.
#define E_DAO_TooManyTasks					DBDAOERR(3538) //Cannot initialize Synchronizer because there are too many applications running.
#define E_DAO_SysDiskIO						DBDAOERR(3539) //A system error has occurred or your swap file has reached its limit.
#define E_DAO_PageFile						DBDAOERR(3540) //Your swap file has reached its limit or is corrupted.
#define E_DAO_ProcessStillActive			DBDAOERR(3541) //Synchronizer could not be shut down properly and is still active.
#define E_DAO_ProcessAborted				DBDAOERR(3542) //Process stopped when attempting to terminate Synchronizer client.
#define E_DAO_TransporterNotSetup			DBDAOERR(3543) //Synchronizer has not been set up.
#define E_DAO_ServerAlreadyRunning			DBDAOERR(3544) //Synchronizer is already running.
#define E_DAO_DiffReplicaSet				DBDAOERR(3545) //The two replicas you are attempting to synchronize are from different replica sets.
#define E_DAO_BadExchangeType				DBDAOERR(3546) //The type of synchronization you are attempting is not valid.
#define E_DAO_NoReplica						DBDAOERR(3547) //Synchronizer could not find a replica from the correct set to complete the synchronization.
#define E_DAO_GuidMismatch					DBDAOERR(3548) //GUIDs do not match or the requested GUID could not be found.
#define E_DAO_FilenameTooLong				DBDAOERR(3549) //The file name you provided is too long.
#define E_DAO_NoGuidIndex					DBDAOERR(3550) //There is no index on the GUID column.
#define E_DAO_UnableToDeleteParam			DBDAOERR(3551) //Unable to delete the specified Registry parameter for the Synchronizer.
#define E_DAO_ValueTooBig					DBDAOERR(3552) //The size of the Registry parameter exceeds the maximum allowed.
#define E_DAO_REPGuidCreateFailure			DBDAOERR(3553) //The GUID could not be created.
#define E_DAO_REPDBMovedCopied				DBDAOERR(3554) //*
#define E_DAO_REPNoValidNick				DBDAOERR(3555) //All valid nicknames for replicas are already in use.
#define E_DAO_TransportDestInvalidPath		DBDAOERR(3556) //Invalid path for destination dropbox folder.
#define E_DAO_TransDestInvalidAddress		DBDAOERR(3557) //Invalid address for destination dropbox folder.
#define E_DAO_TransportDestDiskIO			DBDAOERR(3558) //Disk I/O error at destination dropbox folder.
#define E_DAO_TransportDestDiskFull			DBDAOERR(3559) //Failure to write because destination disk is full.
#define E_DAO_REPSameReplicaID				DBDAOERR(3560) //The two members of the replica set you are attempting to synchronize have the same ReplicaID.
#define E_DAO_REPBothMasters				DBDAOERR(3561) //The two members of the replica set you are attempting to synchronize are both Design Masters.
#define E_DAO_TransDestAccessDenied			DBDAOERR(3562) //Access denied at destination dropbox folder.
#define E_DAO_TransportSrcAccess			DBDAOERR(3563) //Fatal error accessing a local dropbox folder.
#define E_DAO_TransportSrcFileNotFound		DBDAOERR(3564) //Synchronizer can't find the source file for messages.
#define E_DAO_TransSrcSharingViolation		DBDAOERR(3565) //There is a sharing violation in the source dropbox folder because the message database is open in another application.
#define E_DAO_NetworkIO						DBDAOERR(3566) //Network I/O error.
#define E_DAO_TransportWrongMessage			DBDAOERR(3567) //Message in dropbox folder belongs to the wrong Synchronizer.
#define E_DAO_TransportDeleteFailure		DBDAOERR(3568) //Synchronizer could not delete a file.
#define E_DAO_RepRemoved					DBDAOERR(3569) //This member of the replica set has been logically removed from the set and is no longer available.
#define E_DAO_FiltersChanged				DBDAOERR(3570) //The filters defining a partial replica are out of synch with each other.
#define E_DAO_LimitedUpdate					DBDAOERR(3571) //The attempt  to set a column in a partial replica violated a rule governing partial replicas.
#define E_DAO_TempDiskIO					DBDAOERR(3572) //A disk I/O error occurred while reading or writing to the TEMP directory.
#define E_DAO_DirNotManaged					DBDAOERR(3573) //The directory you queried for a list of replicas is not a managed directory.
#define E_DAO_RepidChanged					DBDAOERR(3574) //The ReplicaID for this member of the replica set was reassigned during a move or copy procedure.
#define E_DAO_DiskFullM						DBDAOERR(3575) //The disk drive you are attempting to write to is full.
#define E_DAO_ShareViolationM				DBDAOERR(3576) //The database you are attempting to open is already in use by another application.
#define E_DAO_UpdateReplCol					DBDAOERR(3577) //Can't update replication system column.
#define E_DAO_GetDbinfoM					DBDAOERR(3578) //Failure to replicate database; can't determine whether the database is open in exclusive mode.
#define E_DAO_MakeRepTablesM				DBDAOERR(3579) //Could not create replication system tables needed to make the database replicable.
#define E_DAO_AddReplicaInfoM				DBDAOERR(3580) //Could not add rows needed to make the database replicable.
#define E_DAO_OpenRepTablesM				DBDAOERR(3581) //Can't open replication system table '|' because the table is already in use.
#define E_DAO_CreateReplicaObjectM			DBDAOERR(3582) //Cannot make a new replica because the |2 object in |1 container could not be made replicable.
#define E_DAO_MakeObjectReplM				DBDAOERR(3583) //Cannot make the |2 object in |1 container replicable.
#define E_DAO_OutOfMemoryM					DBDAOERR(3584) //Insufficient memory to complete operation.
#define E_DAO_RepTooManyColumnsM			DBDAOERR(3585) //Can't replicate the table; the number of columns exceeds the maximum allowed.
#define E_DAO_PARTFilterExprSyntaxM			DBDAOERR(3586) //Syntax error in partial filter expression on table |1.
#define E_DAO_PARTUnknownTokenM				DBDAOERR(3587) //Invalid expression in the ReplicaFilter property.
#define E_DAO_PARTExprEvaluationM			DBDAOERR(3588) //Error when evaluating the partial filter expression.
#define E_DAO_PARTExprUnknownFuncM			DBDAOERR(3589) //The partial filter expression contains an unknown function.
#define E_DAO_LimitedUpdateM				DBDAOERR(3590) //Violates the rules for partial replicas.
#define E_DAO_LogInvalidPathM				DBDAOERR(3591) //Log file path '|1' is invalid.
#define E_DAO_REPPasswdNotAllowed			DBDAOERR(3592) //You can't replicate a password-protected database or set password protection on a replicated database.
#define E_DAO_BadSingleMasterAttrib			DBDAOERR(3593) //You can't change the data master attribute for the replica set.
#define E_DAO_BadMultiMasterAttrib			DBDAOERR(3594) //You can't change the data master attribute for the replica set.  It allows data changes only at the Design Master.
#define E_DAO_REPCantRepair					DBDAOERR(3595) //The system tables in your replica are no longer reliable and the replica should not be used.
#define E_DAO_NoDataIncluded				DBDAOERR(3596) //*
#define E_DAO_SenderNotFound				DBDAOERR(3597) //*
#define E_DAO_CouldnotFindService			DBDAOERR(3598) //*
#define E_DAO_UnableToStartService			DBDAOERR(3599) //*
#define E_DAO_ExprAggIllegalOnGuid			DBDAOERR(3600) //Aggregation expressions cannot use GUIDs.
#define E_DAO_RefreshReplicaList			DBDAOERR(3601) //*
#define E_DAO_MoreWorkNeeded				DBDAOERR(3602) //*
#define E_DAO_SenderTooOld					DBDAOERR(3603) //*
#define E_DAO_RepAccess						DBDAOERR(3604) //*
#define E_DAO_REPDbNotReplicableM			DBDAOERR(3605) //Synchronizing with a non-replicated database is not allowed. The '|' database is not a Design Master or replica.
#define E_DAO_DaemonDied					DBDAOERR(3606) //*
#define E_DAO_REPCantDelete					DBDAOERR(3607) //The replication property you are attempting to delete is read-only and cannot be removed.
#define E_DAO_IndexCantBuild				DBDAOERR(3608) //Record length is too long for an indexed Paradox table.
#define E_DAO_RelNoPrimaryIndex				DBDAOERR(3609) //No unique index found for the referenced field of the primary table.
#define E_DAO_QuerySameSrcDestTableM		DBDAOERR(3610) //Same table '|' referenced as both the source and destination in make-table query.
#define E_DAO_InvalidDDLObject				DBDAOERR(3611) //Can't execute data definition statements on linked data sources.
#define E_DAO_QueryMGBWithSubquery			DBDAOERR(3612) //Multi-level GROUP BY clause is not allowed in a subquery.
#define E_DAO_SQLLinkNotSupported			DBDAOERR(3613) //Can't create a relationship on linked ODBC tables.
#define E_DAO_InvalidFindOnGUID				DBDAOERR(3614) //GUID not allowed in Find method criteria expression.
#define E_DAO_QueryJoinExprInComp			DBDAOERR(3615) //Type mismatch in JOIN expression.
#define E_DAO_UpdateNotAvailable			DBDAOERR(3616) //Updating data in a linked table is not supported by this ISAM.
#define E_DAO_DeleteNotAvailable			DBDAOERR(3617) //Deleting data in a linked table is not supported by this ISAM.
#define E_DAO_ExceptTableCreateFail			DBDAOERR(3618) //Exceptions table could not be created on import/export.
#define E_DAO_ExceptTableWriteFail			DBDAOERR(3619) //Records could not be added to exceptions table.
#define E_DAO_ExcelOLEConnectLost			DBDAOERR(3620) //The connection for viewing your linked Microsoft Excel worksheet was lost.
#define E_DAO_CantChangeDbPwdOnShared		DBDAOERR(3621) //Can't change password on a shared open database.
#define E_DAO_RmtMustCheckTimeStamp			DBDAOERR(3622) //You must use the dbSeeChanges option with OpenRecordset when accessing a SQL Server table that has an IDENTITY column.
#define E_DAO_NotWithBoundFileM				DBDAOERR(3623) //Cannot access the FoxPro 3.0 bound DBF file '|'.
#define E_DAO_CommitConflict				DBDAOERR(3624) //Couldn't read the record; currently locked by another user.
#define E_DAO_NoSuchSpecM					DBDAOERR(3625) //The text file specification '|' does not exist.  You can't import, export, or link using the specification.
#define E_DAO_TooManyIndexesM				DBDAOERR(3626) //The operation failed.  There are too many indexes on table '|'.  Delete some of the indexes on the table and try the operation again.
#define E_DAO_TransExeNotFound				DBDAOERR(3627) //Cannot find the executable file for the Synchronizer (mstran35.exe).
#define E_DAO_RemRepNotManaged				DBDAOERR(3628) //Partner replica is not managed by a Synchronizer.
#define E_DAO_FSDropboxShared				DBDAOERR(3629) //Synchronizer '|1' is also using the same File System dropbox '|2'.
#define E_DAO_FSDropboxSharedM				DBDAOERR(3630) //Synchronizer '|1' is also using the same File System dropbox '|2'.
#define E_DAO_RepInvalidTableInFilter		DBDAOERR(3631) //Invalid Table Name In Filter
#define E_DAO_InetNotEnabled				DBDAOERR(3632) //Internet Transport not enabled on the remote Synchronizer.
#define E_DAO_VtoDllLoadFailed				DBDAOERR(3633) //Can't load DLL:  '|'
#define E_DAO_REPDBIsPartial				DBDAOERR(3634) //Cannot create a replica using a partial replica.
#define E_DAO_CantCreatePartialSys			DBDAOERR(3635) //Cannot create partial replica of a system database.
#define E_DAO_CantPopulateWithErrors		DBDAOERR(3636) //Cannot populate the replica or change the replica's filter because the replica has conflicts or data errors.
#define E_DAO_QueryEmbeddedVarTab			DBDAOERR(3637) //Cannot use the crosstab of a non-fixed column as a subquery.
#define E_DAO_SrcCntrlDB					DBDAOERR(3638) //A Source Controlled database cannot be made replicable.
#define E_DAO_CantCreateSysReplica			DBDAOERR(3639) //Cannot create a replica of a System database.
#define E_DAO_VtoFetchBuffTooSmall			DBDAOERR(3640) //The fetch buffer was too small for the amount of data you requested.
#define E_DAO_VtoEOFDuringFetch				DBDAOERR(3641) //There are fewer records remaining in the recordset than you requested.
#define E_DAO_VtoSilentCancel				DBDAOERR(3642) //A cancel was performed on the operation.
#define E_DAO_VtoRecordDeleted				DBDAOERR(3643) //One of the records in the recordset was deleted by another process.
#define E_DAO_3644							DBDAOERR(3644) //*
#define E_DAO_VtoBadBindInfo				DBDAOERR(3645) //One of the binding parameters is incorrect.
#define E_DAO_VtoRowLenTooSmall				DBDAOERR(3646) //The specified row length is shorter than the sum of the column lengths.
#define E_DAO_VtoColumnMissing				DBDAOERR(3647) //A column requested is not being returned to the recordset.
#define E_DAO_BothPartials					DBDAOERR(3648) //Cannot synchronize a partial replica with another partial replica.
#define E_DAO_InvalidCodePage				DBDAOERR(3649) //The language-specific code page was not specified or could not be found.
#define E_DAO_InetTooSlow					DBDAOERR(3650) //Either the Internet is very slow OR there is some problem in the replication manager setup on the internet server machine.
#define E_DAO_InetInvalidAddress			DBDAOERR(3651) //Invalid internet address.
#define E_DAO_InetLoginFailure				DBDAOERR(3652) //Internet login failure.
#define E_DAO_InetNotSetup					DBDAOERR(3653) //Internet not set up.
#define E_DAO_InetInternalFailure			DBDAOERR(3654) //Internal internet failure.
#define E_DAO_InetServicesUnavailable		DBDAOERR(3655) //The wininet.dll can't be loaded or initialized.
#define E_DAO_PARTExprEvaluation			DBDAOERR(3656) //Error in evaluating a partial expression
#define E_DAO_PARTFilterEvalM				DBDAOERR(3657) //Error in evaluating the boolean filter expression for table '|1'.
#define E_DAO_PARTBinaryNotAllowedM			DBDAOERR(3658) //Binary column '|' cannot be used in a boolean filter.
#define E_DAO_PARTUnenforcedRelM			DBDAOERR(3659) //Relationship '|1' is unenforced. Relationship in a partial filter expression must be enforced.
#define E_DAO_ExchangeFailed				DBDAOERR(3660) //Requested exchange failed because '|1'
#define E_DAO_ExchangeFailedM				DBDAOERR(3661) //Requested exchange failed because '|1'
#define E_DAO_VtoRSNeedsBatchCursorLib		DBDAOERR(3662) //*
#define E_DAO_VtoNeedDiffCursorLibrary		DBDAOERR(3663) //This operation requires a different cursor library.
#define E_DAO_VtoStillConnecting			DBDAOERR(3664) //An asynchronous OpenConnection call is not yet complete, and you cannot yet reference the returned Connection object until it is complete.
#define E_DAO_AccessDeniedRepl				DBDAOERR(3665) //You cannot modify the replication system object '1'
#define E_DAO_AccessDeniedReplM				DBDAOERR(3666) //You cannot modify the replication system object '1'
#define E_DAO_VtoOtherOperBlocking			DBDAOERR(3667) //A different operation is preventing this operation from being executed.
#define E_DAO_VtoNoActiveConnection			DBDAOERR(3668) //Can not perform this operation because there is no active connection.
#define E_DAO_VtoExecCancelled				DBDAOERR(3669) //Execution cancelled.
#define E_DAO_VtoCursorNotValid				DBDAOERR(3670) //Cursor is not valid.
#define E_DAO_VtoCanNotFindTable			DBDAOERR(3671) //Can not find table to update.
#define E_DAO_VtoCanNotFindCursLib			DBDAOERR(3672) //Failed to load RDOCURS.DLL.

#endif // def _DBDAOERR.H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\dbdao.h ===
/************************************************************************
**      D B D A O . H                                                   *
**                                                                      *
*************************************************************************
** Copyright (C) 1996 by Microsoft Corporation			                *
**                 All Rights Reserved                                  *
************************************************************************/
/*
	DBDAO.H

	Class definitions for ddao SDK.  

This is a part of the Microsoft Data Access Objects SDK library.
See the  DAO SDK help information for detailed information regarding the
Microsoft Data Access Objects SDK product.

*/

#ifndef _DBDAO_H_
#define _DBDAO_H_

// Ignore warning "non dll-interface class 'X' used as base for dll-interface class 'Y'
#pragma warning( disable : 4275 )

//DAO must be built with an MFC version >= 4.2 (or you'll get memory problems with CStrings)

#if _MFC_VER < 0x0420
#error The DAOSDK 3.5 libraries will not operate correctly if built with MFC older than 4.2
#endif

#ifndef DAO35
#define DAO35
#endif

#include <dbdaoint.h>
#include <daogetrw.h>
#include <dbdaoid.h>

// Decorations
#define CONSTRUCTOR
#define DESTRUCTOR

//Disable export
#ifndef DLLEXPORT
#define DLLEXPORT __declspec( dllexport )
#endif

//Macro to convert HRESULT to IDA 
#define DBERR(x) SCODE_CODE(GetScode(x))

// Include internal DAO definitions
#include <_dbdao.h>

//      DAO Recordset::GetRowsEx() binding definitions

#define dbBindIndexINT  1
#define dbBindIndexSTR  2

#define dbBindI2                DAO_I2                  // long
#define dbBindI4                DAO_I4                  // short
#define dbBindR4                DAO_R4                  // float
#define dbBindR8                DAO_R8                  // double
#define dbBindCY                DAO_CURRENCY			// Currency
#define dbBindDATE              DAO_DATE                // DATE
#define dbBindBOOL              DAO_BOOL                // VARIANT_BOOL
#define dbBindUI1               DAO_CHAR                // unsigned char
#define dbBindVARIANT			DAO_ANYVARIANT			// VARIANT
#define dbBindWCHAR             DAO_WCHAR               // wchar_t[] (inline)

#define dbBindBookmark			DAO_BOOKMARK			// bookmark psuedo field
#define dbBindLPSTR				DAO_LPSTR				// \0 string in pvVarBuffer
#define dbBindLPWSTR			DAO_LPWSTR				// wide string in pvVarBuffer
#define dbBindBlob				DAO_BLOB				// 

#ifdef _UNICODE
#define dbBindSTRING    dbBindWCHAR     
#define dbBindLPSTRING	dbBindLPWSTR
#else
#define dbBindSTRING    dbBindUI1
#define dbBindLPSTRING	dbBindLPSTR
#endif

//      Binding structure (Used with GetRowsEX)

typedef struct
	{
	DWORD   dwBindIndexType;
	union
		{
		LONG    i;
		LPCTSTR pstr;
		};

	DWORD   dwType;
	DWORD   dwOffset;
	DWORD   cb;

	} DAORSETBINDING, *LPDAORSETBINDING;



/*****************************************************************************
* Forwards
*/
class COleVariant;
class CdbBookmark;
class CdbException;
class CdbOleObject;
class CdbObject;
class CdbError;
class CdbProperty;
class CdbDBEngine;
class CdbWorkspace;
class CdbDatabase;
class CdbConnection;
class CdbRecordset;
class CdbGetRowsEx;
class CdbQueryDef;
class CdbTableDef;
class CdbField;
class CdbRelation;
class CdbIndex;
class CdbUser;
class CdbGroup;
class CdbDocument;
class CdbContainer;
class CdbParameter;
class CdbCollection;
class CdbErrors;
class CdbProperties;
class CdbWorkspaces;
class CdbDatabases;
class CdbConnections;
class CdbRecordsets;
class CdbQueryDefs;
class CdbTableDefs;
class CdbFields;
class CdbRelations;
class CdbIndexes;
class CdbUsers;
class CdbGroups;
class CdbDocuments;
class CdbContainers;
class CdbParameters;


/*****************************************************************************
* CdbException
*/
class DLLEXPORT CdbException 
	{
public:
	CONSTRUCTOR                     CdbException            (HRESULT hr);

	HRESULT                         m_hr;
	};


/*****************************************************************************
* CdbBookmark
*/
class DLLEXPORT CdbBookmark : public COleVariant
	{
	public:

	CONSTRUCTOR                     CdbBookmark                     (LPSAFEARRAY psa);
	CONSTRUCTOR                     CdbBookmark                     ();
	CONSTRUCTOR                     CdbBookmark                     (const CdbBookmark &);
	CdbBookmark &                   operator =                      (const CdbBookmark &);
	operator                        LPSAFEARRAY                     (VOID);
	};


/*****************************************************************************
* CdbIndexFields (special case for index fields)
*/
class DLLEXPORT CdbIndexFields : public CdbFields
	{
	public:
	CdbField                                Item                            (LPCTSTR pstr);
	CdbField                                Item                            (LONG i);
	CdbObject                               ObItem                          (LPCTSTR pstr);
	CdbObject                               ObItem                          (LONG i);
	};


/*****************************************************************************
* CdbLastOLEError
*/
class DLLEXPORT CdbLastOLEError : public CdbOleObject
	{
	public:

	CONSTRUCTOR                             CdbLastOLEError         (VOID);

	CString                                 GetSource                       (VOID);
	CString                                 GetDescription          (VOID);
	CString                                 GetHelpFile                     (VOID);
	DWORD                                   GetHelpContext          (VOID);
	};

/*****************************************************************************
* CdbDBEngine
*/
class DLLEXPORT CdbDBEngine : public CdbObject
	{
	public:

	// Administration
	CONSTRUCTOR                     CdbDBEngine             (DAODBEngine *peng, BOOL bAddRef=FALSE);
	CONSTRUCTOR                     CdbDBEngine             (BOOL bPrivate=FALSE, BOOL bStart=TRUE, LPCTSTR pstrIniPath=NULL, LPCTSTR pstrDefUser=NULL, LPCTSTR pstrDefPW=NULL, LONG lType=dbUseJet);
	CONSTRUCTOR                     CdbDBEngine             (const CdbDBEngine &);
	CdbDBEngine &           operator =                      (const CdbDBEngine &);
	inline CdbWorkspace     operator []                     (LONG lIndex);
	inline CdbWorkspace     operator []                     (LPCTSTR pstrIndex);
	VOID                            OnInterfaceChange       (VOID);

	// Properties
	VOID                            SetDefaultPassword      (LPCTSTR pstr);
	VOID                            SetDefaultUser          (LPCTSTR pstr);
	VOID                            SetIniPath              (LPCTSTR pstr);
	CString                         GetIniPath              (VOID);
	VOID							SetDefaultType			(LONG l);
	LONG							GetDefaultType			(VOID);
	VOID                            SetLoginTimeout         (SHORT s);
	SHORT                           GetLoginTimeout         (VOID);
	CString                         GetVersion              (VOID);
	CString                         GetSystemDB             (VOID);
	VOID                            SetSystemDB             (LPCTSTR pstr);

	// Methods
	CdbWorkspace					CreateWorkspace         (LPCTSTR pstrName, LPCTSTR pstrUser, LPCTSTR pstrPassword, LONG lType=-1);
	CdbDatabase                     OpenDatabase            (LPCTSTR pstrName, BOOL bExclusive, BOOL bReadOnly=FALSE, LPCTSTR pstrConnect=NULL);
	CdbDatabase                     OpenDatabase            (LPCTSTR pstrName, LONG lOption=0L, BOOL bReadOnly=FALSE, LPCTSTR pstrConnect=NULL);
	CdbConnection					OpenConnection			(LPCTSTR pstrName, LONG lOption=-1L, BOOL bReadOnly=FALSE, LPCTSTR pstrConnect=NULL);
	VOID                            CompactDatabase			(LPCTSTR pstrOldDatabase, LPCTSTR pstrNewDatabase, LPCTSTR pstrDstConnect = NULL, LONG lOptions=-1, LPCTSTR pstrSrcConnect = NULL);
	VOID                            RepairDatabase          (LPCTSTR pstrDatabase);
	VOID                            RegisterDatabase        (LPCTSTR pstrDatabase, LPCTSTR pstrDriver, BOOL bSilent, LPCTSTR pstrAttributes);
	VOID                            Idle                    (LONG lOptions=-1);
	VOID                            Start                   (VOID);
	VOID							SetOption				(long lOption, LPVARIANT pvValue);
	

	// Collections
	CdbWorkspaces					Workspaces;
	CdbErrors                       Errors;

	private:
	BOOL                            m_bStarted;
	};

/*****************************************************************************
* CdbWorkspace
*/
class DLLEXPORT CdbWorkspace : public CdbObject
	{
	public:

	// Administration
	CONSTRUCTOR                     CdbWorkspace            (VOID);
	CONSTRUCTOR                     CdbWorkspace            (DAOWorkspace *pwrk, BOOL bAddRef=FALSE);
	CONSTRUCTOR                     CdbWorkspace            (const CdbWorkspace &);
	CdbWorkspace &          operator =                      (const CdbWorkspace &);
	inline CdbDatabase      operator []                     (LONG lIndex);
	inline CdbDatabase      operator []                     (LPCTSTR pstrIndex);
	VOID                            OnInterfaceChange       (VOID);

	// Properties
	CString                         GetName                         (VOID);
	VOID                            SetName                         (LPCTSTR pstr);
	CString                         GetUserName                     (VOID);
	BOOL                            GetIsolateODBCTrans				(VOID);
	VOID                            SetIsolateODBCTrans				(BOOL b);
	LONG							GetType							(VOID);
	LONG							GetDefaultCursorDriver			(VOID);
	VOID							SetDefaultCursorDriver			(LONG l);
	LONG							GetLoginTimeout					(VOID);
	VOID							SetLoginTimeout					(LONG l);

	// Methods
	VOID                            BeginTrans                      (VOID);
	VOID                            CommitTrans                     (LONG lOptions=-1);
	VOID                            Close                           (VOID);
	VOID                            Rollback                        (VOID);
	CdbDatabase                     OpenDatabase            (LPCTSTR pstrName, BOOL bExclusive, BOOL bReadOnly=FALSE, LPCTSTR pstrConnect=NULL);
	CdbDatabase                     OpenDatabase            (LPCTSTR pstrName, LONG lOption=0L, BOOL bReadOnly=FALSE, LPCTSTR pstrConnect=NULL);
	CdbConnection					OpenConnection			(LPCTSTR pstrName, LONG lOption=-1L, BOOL bReadOnly=FALSE, LPCTSTR pstrConnect=NULL);
	CdbDatabase                     CreateDatabase          (LPCTSTR pstrName, LPCTSTR pstrConnect, LONG lOption=-1);
	CdbUser                         CreateUser                      (LPCTSTR pstrName=NULL, LPCTSTR pstrPID=NULL, LPCTSTR pstrPassword=NULL);
	CdbGroup                        CreateGroup                     (LPCTSTR pstrName=NULL, LPCTSTR pstrPID=NULL);

	// Collections
	CdbDatabases					Databases;
	CdbConnections					Connections;
	CdbUsers                        Users;
	CdbGroups                       Groups;
	};

/*****************************************************************************
* CdbDatabase
*/
class DLLEXPORT CdbDatabase : public CdbObject
	{
	public:

	// Administration
	CONSTRUCTOR                     CdbDatabase                     (VOID);
	CONSTRUCTOR                     CdbDatabase                     (DAODatabase *pdb, BOOL bAddRef=FALSE);
	CONSTRUCTOR                     CdbDatabase                     (const CdbDatabase &);
	CdbDatabase &           operator =                      (const CdbDatabase &);
	inline CdbTableDef      operator []                     (LONG lIndex);
	inline CdbTableDef      operator []                     (LPCTSTR pstrIndex);
	VOID                            OnInterfaceChange       (VOID);

	// Properties
	LONG                    GetCollatingOrder       (VOID);
	CString                 GetConnect              (VOID);
	VOID					SetConnect				(LPCTSTR pstrConnect);
	CString                 GetName                 (VOID);
	SHORT                   GetQueryTimeout         (VOID);
	VOID                    SetQueryTimeout         (SHORT s);
	BOOL                    GetTransactions         (VOID);
	BOOL                    GetUpdatable            (VOID);
	CString                 GetVersion              (VOID);
	LONG                    GetRecordsAffected      (VOID);
	CdbConnection			GetConnection			(VOID);
	//Replication properties
	CString					GetReplicaID			(VOID);
	CString					GetDesignMasterID		(VOID);
	VOID					SetDesignMasterID		(LPCTSTR pstrMasterID);


	// Methods
	VOID                    Close                   (VOID);
	VOID                    Execute                 (LPCTSTR pstrQuery, LONG lOption=-1);
	CdbRecordset            OpenRecordset           (LPCTSTR pstrName, LONG lType=-1, LONG lOptions=-1, LONG lLockEdit=-1);
	CdbProperty             CreateProperty          (LPCTSTR pstrName=NULL, LONG lType=-1, LPVARIANT pvValue=NULL, BOOL bDDL=FALSE);
	CdbRelation             CreateRelation          (LPCTSTR pstrName=NULL, LPCTSTR pstrTable=NULL, LPCTSTR pstrForiegn=NULL, LONG lAttributes=-1);
	CdbTableDef             CreateTableDef          (LPCTSTR pstrName=NULL, LONG lAttributes=-1, LPCTSTR pstrSource=NULL, LPCTSTR pstrConnect=NULL);
	CdbQueryDef             CreateQueryDef          (LPCTSTR pstrName=NULL, LPCTSTR pstrSQL=NULL);
	VOID					NewPassword				(LPCTSTR pstrOld, LPCTSTR pstrNew);
	//Replication methods
	VOID                    Synchronize				(LPCTSTR pstrReplica, LONG lType=-1);
	VOID                    MakeReplica				(LPCTSTR pstrPath, LPCTSTR pstrDescription, LONG lOptions=-1);
	VOID					PopulatePartial			(LPCTSTR pstrDbPathName);

	// Collections
	CdbTableDefs            TableDefs;
	CdbQueryDefs            QueryDefs;
	CdbRelations            Relations;
	CdbContainers           Containers;
	CdbRecordsets           Recordsets;
	};

/*****************************************************************************
* CdbConnection
*/
class DLLEXPORT CdbConnection : public CdbObject
	{
	public:

	// Administration
	CONSTRUCTOR                     CdbConnection           (VOID);
	CONSTRUCTOR                     CdbConnection           (DAOConnection *pconn, BOOL bAddRef=FALSE);
	CONSTRUCTOR                     CdbConnection           (const CdbConnection &);
	CdbConnection &					operator =              (const CdbConnection &);
	inline CdbQueryDef				operator []             (LONG lIndex);
	inline CdbQueryDef				operator []             (LPCTSTR pstrIndex);
	VOID                            OnInterfaceChange       (VOID);

	// Properties
	CString                         GetConnect              (VOID);
	CString                         GetName                 (VOID);
	CdbDatabase						GetDatabase				(VOID);
	SHORT                           GetQueryTimeout         (VOID);
	VOID                            SetQueryTimeout         (SHORT s);
	LONG							GetRecordsAffected		(VOID);
	BOOL							GetStillExecuting		(VOID);
	BOOL							GetTransactions         (VOID);
	BOOL                            GetUpdatable            (VOID);

	// Methods
	VOID                            Cancel					(VOID);
	VOID                            Close                   (VOID);
	CdbQueryDef						CreateQueryDef          (LPCTSTR pstrName=NULL, LPCTSTR pstrSQL=NULL);
	VOID                            Execute                 (LPCTSTR pstrQuery, LONG lOption=-1);
	CdbRecordset					OpenRecordset           (LPCTSTR pstrName, LONG lType=-1, LONG lOptions=-1, LONG lLockEdit=-1);

	// Collections
	CdbQueryDefs            QueryDefs;
	CdbRecordsets           Recordsets;
	};

/*****************************************************************************
* CdbRecordset
*/
class DLLEXPORT CdbRecordset : public CdbObject
	{
	public:

	// Administration
	CONSTRUCTOR                     CdbRecordset            (VOID);
	CONSTRUCTOR                     CdbRecordset            (DAORecordset *prs, BOOL bAddRef=FALSE);
	CONSTRUCTOR                     CdbRecordset            (const CdbRecordset &);
	CdbRecordset &          operator =                      (const CdbRecordset &);
	inline CdbField     operator []                     (LONG lIndex);
	inline CdbField     operator []                     (LPCTSTR pstrIndex);
	VOID                            OnInterfaceChange       (VOID);
	VOID                            SetGetRowsExInt			(VOID);

	// Properties
	BOOL                            GetBOF                          (VOID);
	CdbBookmark                     GetBookmark                     (VOID);
	VOID                            SetBookmark                     (class CdbBookmark);
	BOOL                            GetBookmarkable         (VOID);
	COleDateTime                    GetDateCreated          (VOID);
	COleDateTime                    GetLastUpdated          (VOID);
	BOOL                            GetEOF                          (VOID);
	CString                         GetFilter                       (VOID);
	VOID                            SetFilter                       (LPCTSTR pstr);
	CString                         GetIndex                        (VOID);
	VOID                            SetIndex                        (LPCTSTR pstr);
	CdbBookmark                     GetLastModified         (VOID);
	BOOL                            GetLockEdits            (VOID);
	VOID                            SetLockEdits            (BOOL b);
	CString                         GetName                         (VOID);
	BOOL                            GetNoMatch                      (VOID);
	CString                         GetSort                         (VOID);
	VOID                            SetSort                         (LPCTSTR pstr);
	BOOL                            GetTransactions         (VOID);
	SHORT                           GetType                         (VOID);
	LONG                            GetRecordCount          (VOID);
	BOOL                            GetUpdatable            (VOID);
	BOOL                            GetRestartable          (VOID);
	CString                         GetValidationText       (VOID);
	CString                         GetValidationRule       (VOID);
	CdbBookmark                     GetCacheStart           (VOID);
	VOID                            SetCacheStart           (CdbBookmark &pbm);
	LONG                            GetCacheSize            (VOID);
	VOID                            SetCacheSize            (LONG l);
	FLOAT                           GetPercentPosition      (VOID);
	VOID                            SetPercentPosition      (FLOAT f);
	LONG                            GetAbsolutePosition     (VOID);
	VOID                            SetAbsolutePosition     (LONG l);
	SHORT                           GetEditMode				(VOID);
	LONG                            GetUpdateOptions		(VOID);
	VOID                            SetUpdateOptions		(LONG l);
	SHORT                           GetRecordStatus			(VOID);
	BOOL							GetStillExecuting		(VOID);
	LONG                            GetBatchSize			(VOID);
	VOID                            SetBatchSize			(LONG l);
	LONG                            GetBatchCollisionCount	(VOID);
	COleVariant						GetBatchCollisions		(VOID);
	CdbConnection					GetConnection			(VOID);

	// Methods
	VOID                            CancelUpdate            (short sType = dbUpdateRegular);
	VOID                            AddNew                          (VOID);
	VOID                            Close                           (VOID);
	CdbRecordset					OpenRecordset           (LONG lType=-1, LONG lOption=-1);
	VOID                            Delete                          (VOID);
	VOID                            Edit                            (VOID);
	VOID                            FindFirst                       (LPCTSTR pstrCriteria);
	VOID                            FindLast                        (LPCTSTR pstrCriteria);
	VOID                            FindNext                        (LPCTSTR pstrCriteria);
	VOID                            FindPrevious            (LPCTSTR pstrCriteria);
	VOID                            MoveFirst                       (VOID);
	VOID                            MoveLast                        (LONG lOptions=-1);
	VOID                            MoveNext                        (VOID);
	VOID                            MovePrevious            (VOID);
	VOID                            Seek                            (LPCTSTR pstrComparison, LONG lNumFields, COleVariant cKey, ...);
	VOID                            Update                          (short sType = dbUpdateRegular, VARIANT_BOOL bForce = FALSE);
	CdbRecordset					Clone                           (VOID);
	VOID                            Requery                         (CdbQueryDef *pq = NULL);
	VOID                            Move                            (LONG lRows, CdbBookmark *bm=NULL);
	VOID                            FillCache                       (LONG lRows=-1, CdbBookmark *pbm=NULL);
	CdbQueryDef                     CopyQueryDef					(VOID);
	COleVariant                     GetRows                         (LONG lRows=-1);
	LONG                            GetRowsEx                       (LPVOID pvBuffer, LONG cbRow, LPDAORSETBINDING prb, LONG cBinding, LPVOID pvVarBuffer = NULL, LONG cbVarBuffer = 0, LONG lRows = -1);
	VOID                            Cancel							(VOID);
	BOOL							NextRecordset					(VOID);

	inline VOID						GetFieldV                       (COleVariant &vIndex, COleVariant &vValue);
	inline VOID                     SetFieldV                       (COleVariant &vIndex, LPVARIANT pv);


	COleVariant                     GetField                        (LPCTSTR pstrIndex);
	COleVariant                     GetField                        (LONG lIndex);
	COleVariant						GetField                        (COleVariant &vIndex);
	COleVariant						GetField                        (CString &str){return GetField((LPCTSTR)str);}

	VOID                            SetField                        (LPCTSTR pstrIndex, LPVARIANT pv);
	VOID                            SetField                        (LONG lIndex, LPVARIANT pv);
	VOID							SetField                        (COleVariant &vIndex, LPVARIANT pv);
	VOID							SetField                        (CString &str, LPVARIANT pv){SetField((LPCTSTR)str, pv);}

	// Collections
	CdbFields                       Fields;
protected:
	// GetRowsEx interface
	CdbGetRowsEx            m_GetRowsInt;
	};


/*****************************************************************************
* CdbField
*/
class DLLEXPORT CdbField : public CdbObject
	{
	public:

	// Administration
	CONSTRUCTOR                     CdbField                        (VOID);
	CONSTRUCTOR                     CdbField                        (DAOField *pfld, BOOL bAddRef=FALSE);
	CONSTRUCTOR                     CdbField                        (const CdbField &);
	CdbField &                      operator =                      (const CdbField &);
	VOID                            OnInterfaceChange       (VOID);

	// Properties
	LONG                            GetCollatingOrder       (VOID);
	SHORT                           GetType                         (VOID);
	VOID                            SetType                         (SHORT s);
	CString                         GetName                         (VOID);
	VOID                            SetName                         (LPCTSTR pstr);
	LONG                            GetSize                         (VOID);
	VOID                            SetSize                         (LONG l);
	CString                         GetSourceField          (VOID);
	CString                         GetSourceTable          (VOID);
	COleVariant                     GetValue                 (VOID);

	VOID                            SetValue                (LPVARIANT pv);
	LONG                            GetAttributes           (VOID);
	VOID                            SetAttributes           (LONG l);
	SHORT                           GetOrdinalPosition      (VOID);
	VOID                            SetOrdinalPosition      (SHORT s);
	CString                         GetValidationText       (VOID);
	VOID                            SetValidationText       (LPCTSTR pstr);
	BOOL                            GetValidateOnSet        (VOID);
	VOID                            SetValidateOnSet        (BOOL b);
	CString                         GetValidationRule       (VOID);
	VOID                            SetValidationRule       (LPCTSTR pstr);
	CString		                    GetDefaultValue         (VOID);
	VOID                            SetDefaultValue         (LPCTSTR pstr);
	VOID                            SetDefaultValue         (LPVARIANT pv);
	BOOL                            GetRequired             (VOID);
	VOID                            SetRequired             (BOOL b);
	BOOL                            GetAllowZeroLength      (VOID);
	VOID                            SetAllowZeroLength      (BOOL b);
	BOOL                            GetDataUpdatable		(VOID);
	CString                         GetForeignName          (VOID);
	VOID                            SetForeignName          (LPCTSTR pstr);
	COleVariant                     GetOriginalValue		(VOID);
	COleVariant                     GetVisibleValue			(VOID);

	// Methods
	VOID                            AppendChunk                     (LPVARIANT pv);
	COleVariant                     GetChunk                        (LONG lOffset, LONG lBytes);
	LONG                            FieldSize                       (VOID);
	CdbProperty                     CreateProperty          (LPCTSTR pstrName=NULL, LONG lType=-1, LPVARIANT pvValue=NULL, BOOL bDDL=FALSE);
	};

/*****************************************************************************
* CdbQueryDef
*/
class DLLEXPORT CdbQueryDef : public CdbObject
	{
	public:

	// Administration
	CONSTRUCTOR                     CdbQueryDef             (VOID);
	CONSTRUCTOR                     CdbQueryDef             (DAOQueryDef *pqd, BOOL bAddRef=FALSE);
	CONSTRUCTOR                     CdbQueryDef             (const CdbQueryDef &);
	CdbQueryDef &           operator =                      (const CdbQueryDef &);
	inline CdbField         operator []                     (LONG lIndex);
	inline CdbField         operator []                     (LPCTSTR pstrIndex);
	VOID                            OnInterfaceChange       (VOID);

	// Properties
	COleDateTime                    GetDateCreated          (VOID);
	COleDateTime                    GetLastUpdated          (VOID);
	CString                         GetName                 (VOID);
	VOID                            SetName                 (LPCTSTR pstr);
	SHORT                           GetODBCTimeout          (VOID);
	VOID                            SetODBCTimeout          (SHORT s);
	SHORT                           GetType                 (VOID);
	CString                         GetSQL                  (VOID);
	VOID                            SetSQL                  (LPCTSTR pstr);
	BOOL                            GetUpdatable            (VOID);
	CString                         GetConnect              (VOID);
	VOID                            SetConnect              (LPCTSTR pstr);
	BOOL                            GetReturnsRecords       (VOID);
	VOID                            SetReturnsRecords       (BOOL b);
	LONG                            GetRecordsAffected      (VOID);
	LONG                            GetMaxRecords			(VOID);
	VOID                            SetMaxRecords			(LONG l);
	BOOL							GetStillExecuting		(VOID);
	LONG                            GetCacheSize			(VOID);
	VOID                            SetCacheSize			(LONG l);
	COleVariant						GetPrepare				(VOID);
	VOID                            SetPrepare				(LPVARIANT pv);

	// Methods
	CdbRecordset					OpenRecordset           (LONG lType=-1, LONG lOption=-1, LONG lLockEdit=-1);
	VOID                            Execute                 (LONG lOption=-1);
	CdbProperty                     CreateProperty          (LPCTSTR pstrName=NULL, LONG lType=-1, LPVARIANT pvValue=NULL, BOOL bDDL=FALSE);
	VOID							Close					(VOID);
	VOID							Cancel					(VOID);

	// Collections
	CdbFields                       Fields;
	CdbParameters					Parameters;
	};

/*****************************************************************************
* CdbTableDef
*/
class DLLEXPORT CdbTableDef : public CdbObject
	{
	public:

	// Administration
	CONSTRUCTOR                     CdbTableDef                     (VOID);
	CONSTRUCTOR                     CdbTableDef                     (DAOTableDef *ptd, BOOL bAddRef=FALSE);
	CONSTRUCTOR                     CdbTableDef                     (const CdbTableDef &);
	CdbTableDef &           operator =                      (const CdbTableDef &);
	inline CdbField         operator []                     (LONG lIndex);
	inline CdbField         operator []                     (LPCTSTR pstrIndex);
	VOID                            OnInterfaceChange       (VOID);

	// Properties
	LONG                            GetAttributes           (VOID);
	VOID                            SetAttributes           (LONG l);
	CString                         GetConnect                      (VOID);
	VOID                            SetConnect                      (LPCTSTR pstr);
	COleDateTime                    GetDateCreated          (VOID);
	COleDateTime                    GetLastUpdated          (VOID);
	CString                         GetName                         (VOID);
	VOID                            SetName                         (LPCTSTR pstr);
	CString                         GetSourceTableName      (VOID);
	VOID                            SetSourceTableName      (LPCTSTR pstr);
	BOOL                            GetUpdatable            (VOID);
	CString                         GetValidationText       (VOID);
	VOID                            SetValidationText       (LPCTSTR pstr);
	CString                         GetValidationRule       (VOID);
	VOID                            SetValidationRule       (LPCTSTR pstr);
	LONG                            GetRecordCount          (VOID);
	CString							GetConflictTable		(VOID);
	COleVariant						GetReplicaFilter		(VOID);
	VOID							SetReplicaFilter		(LPVARIANT pv);

	// Methods
	CdbRecordset					OpenRecordset           (LONG lType=-1, LONG lOption=-1);
	VOID                            RefreshLink                     (VOID);
	CdbField                        CreateField                     (LPCTSTR pstrName=NULL, LONG lType=-1, LONG lSize=-1);
	CdbIndex                        CreateIndex                     (LPCTSTR pstrName=NULL);
	CdbProperty                     CreateProperty          (LPCTSTR pstrName=NULL, LONG lType=-1, LPVARIANT pvValue=NULL, BOOL bDDL=FALSE);

	// Collections
	CdbFields                       Fields;
	CdbIndexes                      Indexes;
	};

/*****************************************************************************
* CdbIndex
*/
class DLLEXPORT CdbIndex : public CdbObject
	{
	public:

	// Administration
	CONSTRUCTOR                     CdbIndex                        (VOID);
	CONSTRUCTOR                     CdbIndex                        (DAOIndex *pidx, BOOL bAddRef=FALSE);
	CONSTRUCTOR                     CdbIndex                        (const CdbIndex &);
	CdbIndex &                      operator =                      (const CdbIndex &);
	inline CdbField         operator []             (LONG lIndex);
	inline CdbField         operator []             (LPCTSTR pstrIndex);
	VOID                            OnInterfaceChange       (VOID);

	// Properties
	CString                         GetName                         (VOID);
	VOID                            SetName                         (LPCTSTR pstr);
	BOOL                            GetForeign                      (VOID);
	BOOL                            GetUnique                       (VOID);
	VOID                            SetUnique                       (BOOL b);
	BOOL                            GetClustered            (VOID);
	VOID                            SetClustered            (BOOL b);
	BOOL                            GetRequired                     (VOID);
	VOID                            SetRequired                     (BOOL b);
	BOOL                            GetIgnoreNulls          (VOID);
	VOID                            SetIgnoreNulls          (BOOL b);
	BOOL                            GetPrimary                      (VOID);
	VOID                            SetPrimary                      (BOOL b);
	LONG                            GetDistinctCount        (VOID);

	// Methods
	CdbField                        CreateField                     (LPCTSTR pstrName=NULL, LONG lType=-1, LONG lSize=-1);
	CdbProperty                     CreateProperty          (LPCTSTR pstrName=NULL, LONG lType=-1, LPVARIANT pvValue=NULL, BOOL bDDL=FALSE);

	// Collections
	CdbIndexFields          Fields;
	};

/*****************************************************************************
* CdbParameter
*/
class DLLEXPORT CdbParameter : public CdbObject
	{
	public:

	// Administration
	CONSTRUCTOR                     CdbParameter            (VOID);
	CONSTRUCTOR                     CdbParameter            (DAOParameter *pprm, BOOL bAddRef=FALSE);
	CONSTRUCTOR                     CdbParameter            (const CdbParameter &);
	CdbParameter &          operator =                      (const CdbParameter &);
	VOID                            OnInterfaceChange       (VOID);

	// Properties
	CString                         GetName					(VOID);
	COleVariant                     GetValue				(VOID);
	VOID                            SetValue				(LPVARIANT pv);
	SHORT                           GetType					(VOID);
	VOID							SetType					(SHORT i);
	SHORT							GetDirection			(VOID);
	VOID							SetDirection			(SHORT i);
	};

/*****************************************************************************
* CdbRelation
*/
class DLLEXPORT CdbRelation : public CdbObject
	{
	public:

	// Administration
	CONSTRUCTOR                     CdbRelation                     (VOID);
	CONSTRUCTOR                     CdbRelation                     (DAORelation *prl, BOOL bAddRef=FALSE);
	CONSTRUCTOR                     CdbRelation                     (const CdbRelation &);
	CdbRelation &           operator =                      (const CdbRelation &);
	inline CdbField         operator []                     (LONG lIndex);
	inline CdbField         operator []                     (LPCTSTR pstrIndex);
	VOID                            OnInterfaceChange       (VOID);

	// Properties
	CString                         GetName                         (VOID);
	VOID                            SetName                         (LPCTSTR pstr);
	CString                         GetTable                        (VOID);
	VOID                            SetTable                        (LPCTSTR pstr);
	CString                         GetForeignTable         (VOID);
	VOID                            SetForeignTable         (LPCTSTR pstr);
	LONG                            GetAttributes           (VOID);
	VOID                            SetAttributes           (LONG);
	BOOL							GetPartialReplica		(VOID);
	VOID							SetPartialReplica		(BOOL b);

	// Methods
	CdbField                        CreateField                     (LPCTSTR pstrName=NULL, LONG lType=-1, LONG lSize=-1);

	// Collections
	CdbFields                       Fields;
	};

/*****************************************************************************
* CdbUser
*/
class DLLEXPORT CdbUser : public CdbObject
	{
	public:

	// Administration
	CONSTRUCTOR                     CdbUser                         (VOID);
	CONSTRUCTOR                     CdbUser                         (DAOUser *pusr, BOOL bAddRef=FALSE);
	CONSTRUCTOR                     CdbUser                         (const CdbUser &);
	CdbUser &                       operator =                      (const CdbUser &);
	inline CdbGroup         operator []                     (LONG lIndex);
	inline CdbGroup         operator []                     (LPCTSTR pstrIndex);
	VOID                            OnInterfaceChange       (VOID);

	// Properties
	CString                         GetName                         (VOID);
	VOID                            SetName                         (LPCTSTR pstr);
	VOID                            SetPID                          (LPCTSTR pstr);
	VOID                            SetPassword                     (LPCTSTR pstr);

	// Methods
	VOID                            NewPassword                     (LPCTSTR pstrOld, LPCTSTR pstrNew);
	CdbGroup                        CreateGroup                     (LPCTSTR pstrName=NULL, LPCTSTR pstrPID=NULL);

	// Collections
	CdbGroups                       Groups;
	};

/*****************************************************************************
* CdbGroup
*/
class DLLEXPORT CdbGroup : public CdbObject
	{
	public:

	// Administration
	CONSTRUCTOR                     CdbGroup                        (VOID);
	CONSTRUCTOR                     CdbGroup                        (DAOGroup *pgrp, BOOL bAddRef=FALSE);
	CONSTRUCTOR                     CdbGroup                        (const CdbGroup &);
	CdbGroup &                      operator =                      (const CdbGroup &);
	inline CdbUser          operator []                     (LONG lIndex);
	inline CdbUser          operator []                     (LPCTSTR pstrIndex);
	VOID                            OnInterfaceChange       (VOID);

	// Properties
	CString                         GetName                         (VOID);
	VOID                            SetName                         (LPCTSTR pstr);
	VOID                            SetPID                          (LPCTSTR pstr);

	// Methods
	CdbUser                         CreateUser                      (LPCTSTR pstrName=NULL, LPCTSTR pstrPID=NULL, LPCTSTR pstrPassword=NULL);

	// Collections
	CdbUsers                        Users;
	};

/*****************************************************************************
* CdbDocument
*/
class DLLEXPORT CdbDocument : public CdbObject
	{
	public:

	// Administration
	CONSTRUCTOR                     CdbDocument                     (VOID);
	CONSTRUCTOR                     CdbDocument                     (DAODocument *pdoc, BOOL bAddRef=FALSE);
	CONSTRUCTOR                     CdbDocument                     (const CdbDocument &);
	CdbDocument &           operator =                      (const CdbDocument &);
	VOID                            OnInterfaceChange       (VOID);

	// Properties
	CString                         GetName                         (VOID);
	CString                         GetOwner                        (VOID);
	VOID                            SetOwner                        (LPCTSTR pstr);
	CString                         GetContainer            (VOID);
	CString                         GetUserName                     (VOID);
	VOID                            SetUserName                     (LPCTSTR pstr);
	LONG                            GetPermissions          (VOID);
	VOID                            SetPermissions          (LONG l);
	COleDateTime                    GetDateCreated          (VOID);
	COleDateTime                    GetLastUpdated          (VOID);
	LONG							GetAllPermissions		(VOID);
	//Methods
	CdbProperty						CreateProperty          (LPCTSTR pstrName=NULL, LONG lType=-1, LPVARIANT pvValue=NULL, BOOL bDDL=FALSE);
	};

/*****************************************************************************
* CdbContainer
*/
class DLLEXPORT CdbContainer : public CdbObject
	{
	public:

	// Administration
	CONSTRUCTOR                     CdbContainer            (VOID);
	CONSTRUCTOR                     CdbContainer            (DAOContainer *pctn, BOOL bAddRef=FALSE);
	CONSTRUCTOR                     CdbContainer            (const CdbContainer &);
	CdbContainer &          operator =                      (const CdbContainer &);
	inline CdbDocument      operator []                     (LONG lIndex);
	inline CdbDocument      operator []                     (LPCTSTR pstrIndex);
	VOID                            OnInterfaceChange       (VOID);

	// Properties
	CString                         GetName                         (VOID);
	CString                         GetOwner                        (VOID);
	VOID                            SetOwner                        (LPCTSTR pstr);
	CString                         GetUserName                     (VOID);
	VOID                            SetUserName                     (LPCTSTR pstr);
	LONG                            GetPermissions          (VOID);
	VOID                            SetPermissions          (LONG l);
	BOOL                            GetInherit                      (VOID);
	VOID                            SetInherit                      (BOOL b);
	LONG							GetAllPermissions		(VOID);

	// Collections
	CdbDocuments            Documents;
	};

/*****************************************************************************
* CdbError
*/
class DLLEXPORT CdbError : public CdbObject
	{
	public:

	// Administration
	CONSTRUCTOR                     CdbError                        (VOID);
	CONSTRUCTOR                     CdbError                        (DAOError *perr, BOOL bAddRef=FALSE);
	CONSTRUCTOR                     CdbError                        (const CdbError &);
	CdbError &                      operator =                      (const CdbError &);
	VOID                            OnInterfaceChange       (VOID);

	// Properties
	LONG                            GetNumber                       (VOID);
	CString                         GetSource                       (VOID);
	CString                         GetDescription          (VOID);
	CString                         GetHelpFile                     (VOID);
	LONG                            GetHelpContext          (VOID);
	};

/*****************************************************************************
* CdbProperty
*/
class DLLEXPORT CdbProperty : public CdbObject
	{
	public:

	// Administration
	CONSTRUCTOR                     CdbProperty                     (VOID);
	CONSTRUCTOR                     CdbProperty                     (DAOProperty *pprp, BOOL bAddRef=FALSE);
	CONSTRUCTOR                     CdbProperty                     (const CdbProperty &);
	CdbProperty &           operator =                      (const CdbProperty &);

	// Properties
	COleVariant                     GetValue                        (VOID);
	VOID                            SetValue                        (LPVARIANT pv);
	CString                         GetName                         (VOID);
	VOID                            SetName                         (LPCTSTR pstrName);
	SHORT                           GetType                         (VOID);
	VOID                            SetType                         (SHORT sType);
	BOOL                            GetInherited            (VOID);
	};


/*****************************************************************************
*  Inline functions
*/
inline BOOL	CdbOleObject::Exists(void)
	{ 
	return (m_punkInterface ? TRUE : FALSE);
	}

/*****************************************************************************
*  Recordset GetField functions
*/


inline VOID				CdbRecordset::GetFieldV(
	COleVariant &vIndex,
	COleVariant &vValue)
{
	DAORecordset *  prs     = (DAORecordset *)GetInterface();

	if (!prs)
		{
		DAOVINIT(vValue);
		return;
		}

	DAOMFC_CALL(prs->get_Collect(vIndex, &vValue));

	return;
}

inline VOID				CdbRecordset::SetFieldV(
	COleVariant &vIndex, 
	LPVARIANT pv)
{
	DAORecordset *  prs     = (DAORecordset *)GetInterface();

	if (!prs)
		return;

	DAOMFC_CALL(prs->put_Collect(vIndex, *pv));
}


/*****************************************************************************
* Default collection operators
*/
inline CdbWorkspace CdbDBEngine::operator []
	(LONG lIndex)
{
return Workspaces[lIndex];
}

inline CdbWorkspace CdbDBEngine::operator []
	(LPCTSTR pstrIndex)
{
return Workspaces[pstrIndex];
}


inline CdbDatabase CdbWorkspace::operator []
	(LONG lIndex)
{
return Databases[lIndex];
}

inline CdbDatabase CdbWorkspace::operator []
	(LPCTSTR pstrIndex)
{
return Databases[pstrIndex];
}

inline CdbTableDef      CdbDatabase::operator []
	(LONG lIndex)
{
return TableDefs[lIndex];
}

inline CdbTableDef      CdbDatabase::operator []
	(LPCTSTR pstrIndex)
{
return TableDefs[pstrIndex];
}

inline CdbQueryDef      CdbConnection::operator []
	(LONG lIndex)
{
return QueryDefs[lIndex];
}

inline CdbQueryDef      CdbConnection::operator []
	(LPCTSTR pstrIndex)
{
return QueryDefs[pstrIndex];
}

inline CdbField      CdbRecordset::operator []
	(LONG lIndex)
{
return Fields[lIndex];
}

inline CdbField      CdbRecordset::operator []
	(LPCTSTR pstrIndex)
{
return Fields[pstrIndex];
}



inline CdbField CdbTableDef::operator []        
	(LONG lIndex)
{
return Fields[lIndex];
}

inline CdbField CdbTableDef::operator []        
	(LPCTSTR pstrIndex)
{
return Fields[pstrIndex];
}

inline CdbField CdbQueryDef::operator []        
	(LONG lIndex)
{
return Fields[lIndex];
}

inline CdbField CdbQueryDef::operator []        
	(LPCTSTR pstrIndex)
{
return Fields[pstrIndex];
}

inline CdbField CdbIndex::operator []   
	(LONG lIndex)
{
return Fields[lIndex];
}

inline CdbField CdbIndex::operator []   
	(LPCTSTR pstrIndex)
{
return Fields[pstrIndex];
}

inline CdbField CdbRelation::operator []
	(LONG lIndex)
{
return Fields[lIndex];
}

inline CdbField CdbRelation::operator []
	(LPCTSTR pstrIndex)
{
return Fields[pstrIndex];
}

inline CdbGroup CdbUser::operator []
	(LONG lIndex)
{
return Groups[lIndex];
}

inline CdbGroup CdbUser::operator []
	(LPCTSTR pstrIndex)
{
return Groups[pstrIndex];
}

inline CdbUser CdbGroup::operator []
	(LONG lIndex)
{
return Users[lIndex];
}

inline CdbUser CdbGroup::operator []
	(LPCTSTR pstrIndex)
{
return Users[pstrIndex];
}

inline CdbDocument CdbContainer::operator []
	(LONG lIndex)
{
return Documents[lIndex];
}

inline CdbDocument CdbContainer::operator []
	(LPCTSTR pstrIndex)
{
return Documents[pstrIndex];
}

/*****************************************************************************
*  Use different DAO interface for wide (UNICODE) versions
*/

#ifdef _UNICODE

#define dbIID_IDAODBEngine IID_IDAODBEngineW
#define dbIID_IDAOError IID_IDAOErrorW
#define dbIID_IDAOErrors IID_IDAOErrorsW
#define dbIID_IDAOProperty IID_IDAOPropertyW
#define dbIID_IDAOProperties IID_IDAOPropertiesW
#define dbIID_IDAORecordset IID_IDAORecordsetW
#define dbIID_IDAORecordsets IID_IDAORecordsetsW
#define dbIID_IDAOWorkspace IID_IDAOWorkspaceW
#define dbIID_IDAOWorkspaces IID_IDAOWorkspacesW
#define dbIID_IDAOConnection IID_IDAOConnectionW
#define dbIID_IDAOConnections IID_IDAOConnectionsW
#define dbIID_IDAOTableDef IID_IDAOTableDefW
#define dbIID_IDAOTableDefs IID_IDAOTableDefsW
#define dbIID_IDAOField IID_IDAOFieldW
#define dbIID_IDAOFields IID_IDAOFieldsW
#define dbIID_IDAOIndex IID_IDAOIndexW
#define dbIID_IDAOIndexes IID_IDAOIndexesW
#define dbIID_IDAOIndexFields IID_IDAOIndexFieldsW
#define dbIID_IDAOGroup IID_IDAOGroupW
#define dbIID_IDAOGroups IID_IDAOGroupsW
#define dbIID_IDAOUser IID_IDAOUserW
#define dbIID_IDAOUsers IID_IDAOUsersW
#define dbIID_IDAODatabase IID_IDAODatabaseW
#define dbIID_IDAODatabases IID_IDAODatabasesW
#define dbIID_IDAOQueryDef IID_IDAOQueryDefW
#define dbIID_IDAOQueryDefs IID_IDAOQueryDefsW
#define dbIID_IDAOParameter IID_IDAOParameterW
#define dbIID_IDAOParameters IID_IDAOParametersW
#define dbIID_IDAORelation IID_IDAORelationW
#define dbIID_IDAORelations IID_IDAORelationsW
#define dbIID_IDAOContainer IID_IDAOContainerW
#define dbIID_IDAOContainers IID_IDAOContainersW
#define dbIID_IDAODocument IID_IDAODocumentW
#define dbIID_IDAODocuments IID_IDAODocumentsW

#else

#define dbIID_IDAODBEngine IID_IDAODBEngine
#define dbIID_IDAOError IID_IDAOError
#define dbIID_IDAOErrors IID_IDAOErrors
#define dbIID_IDAOProperty IID_IDAOProperty
#define dbIID_IDAOProperties IID_IDAOProperties
#define dbIID_IDAORecordset IID_IDAORecordset
#define dbIID_IDAORecordsets IID_IDAORecordsets
#define dbIID_IDAOWorkspace IID_IDAOWorkspace
#define dbIID_IDAOWorkspaces IID_IDAOWorkspaces
#define dbIID_IDAOConnection IID_IDAOConnection
#define dbIID_IDAOConnections IID_IDAOConnections
#define dbIID_IDAOTableDef IID_IDAOTableDef
#define dbIID_IDAOTableDefs IID_IDAOTableDefs
#define dbIID_IDAOField IID_IDAOField
#define dbIID_IDAOFields IID_IDAOFields
#define dbIID_IDAOIndex IID_IDAOIndex
#define dbIID_IDAOIndexes IID_IDAOIndexes
#define dbIID_IDAOIndexFields IID_IDAOIndexFields
#define dbIID_IDAOGroup IID_IDAOGroup
#define dbIID_IDAOGroups IID_IDAOGroups
#define dbIID_IDAOUser IID_IDAOUser
#define dbIID_IDAOUsers IID_IDAOUsers
#define dbIID_IDAODatabase IID_IDAODatabase
#define dbIID_IDAODatabases IID_IDAODatabases
#define dbIID_IDAOQueryDef IID_IDAOQueryDef
#define dbIID_IDAOQueryDefs IID_IDAOQueryDefs
#define dbIID_IDAOParameter IID_IDAOParameter
#define dbIID_IDAOParameters IID_IDAOParameters
#define dbIID_IDAORelation IID_IDAORelation
#define dbIID_IDAORelations IID_IDAORelations
#define dbIID_IDAOContainer IID_IDAOContainer
#define dbIID_IDAOContainers IID_IDAOContainers
#define dbIID_IDAODocument IID_IDAODocument
#define dbIID_IDAODocuments IID_IDAODocuments

#endif



#endif // _DBDAO_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\dbcsstr.h ===
/**********************************************
*     Microsoft System Management Server      *
*     Copyright(c) Microsoft Corp., 1994      *
**********************************************/

/* DBCS definitions
//    dbcsstr.h - Definistions about DBCS
//
// Purpose:
//    contains DBCS unique table and
//    definition of checking for DBCS character.
//
// Revision History:
//    02/14/94    MSKK Tetsua Initial version
//    03/22/94    MSKK Atsusk
//                     change strupr to _strupr, strlwr to _strlwr, and so on.
*/

#ifndef _DBCSSTR_INCLUDED_
#define _DBCSSTR_INCLUDED_

#ifdef __cplusplus
extern "C" {
#endif

extern  unsigned char _DBCSLeadByteTable[];

#ifdef __TURBOC__
  #if (__TURBOC__ < 0x300)
    #define _OS2
    #define _far far
  #endif
#endif

#if defined(_M_I86MM) || defined(_M_I86LM)    /* for MSC */ \
 || defined(__MEDIUM__) || defined(__LARGE__) /* for TC/BC */   /* far code */
#define __FAR__ _far
#else
#define __FAR__
#endif

int __FAR__ WHATISCHAR( const char __FAR__ *, const unsigned int );
int __FAR__ _GetSystemDrive( void );


char __FAR__ * __FAR__ __mbsncpy( char __FAR__ *, const char __FAR__ *, int );
char __FAR__ * __FAR__ __mbsncat( char __FAR__ *, const char __FAR__ *, int );
int __FAR__ __mbsicmp( const char __FAR__ *, const char __FAR__ * );
int __FAR__ __mbsnicmp( const char __FAR__ *, const char __FAR__ *, int );


#define ISDBCS(c) ((_DBCSLeadByteTable)[(unsigned char) (c)])
#ifndef _CHAR_DBCS_INCLUDED_
#define _CHAR_DBCS_INCLUDED_
#define CHAR_SBCS 0
#define CHAR_DBCS_LEAD  1
#define CHAR_DBCS_TAIL  2
#endif  /* _CHAR_DBCS_INCLUDED_ */

//JAPAN start
/* for Single Byte Japanese Character */
#define ISKANA(c) (0x0A0 <= (c) && 0x0DF >= (c))
//JAPAN end


/*
// The following string functions should use
// multi-bytes string functions.
// So, we should defined the followings.
*/

#if defined(_NTWIN) || defined(_NTCONSOLE) || defined(WIN32)
#include  <mbstring.h>
#define strstr(s1,s2) (char *)_mbsstr((unsigned char *)s1, (unsigned char *)s2)
#define strchr(s1,i1) (char *)_mbschr((unsigned char *)s1, i1)
#define strtok(s1,s2) (char *)_mbstok((unsigned char *)s1, (unsigned char *)s2)
#define strcspn(s1,s2)  _mbscspn((unsigned char *)s1, (unsigned char *)s2)
#define strpbrk(s1,s2)  (char *)_mbspbrk((unsigned char *)s1, (unsigned char *)s2)
#define strspn(s1,s2) _mbsspn((unsigned char *)s1, (unsigned char *)s2)
#define _strupr(s1) (char *)_mbsupr((unsigned char *)s1)
#define _strlwr(s1) (char *)_mbslwr((unsigned char *)s1)
#define _strrev(s1) (char *)_mbsrev((unsigned char *)s1)
#define _stricmp(s1,s2) _mbsicmp((unsigned char *)s1, (unsigned char *)s2)
#define _strcmpi(s1,s2) _mbsicmp((unsigned char *)s1, (unsigned char *)s2)
#define strrchr(s1,i1)  (char *)_mbsrchr((unsigned char *)s1, i1)
/*
#define _strnicmp _mbsnicmp
#define strlen  _mbslen
#define strcat  _mbscat
#define strcpy  _mbscpy
#define strcmp  _mbscmp
#define _strset _mbsset
#define strncat _mbsncat
#define strncpy _mbsncpy
#define strncmp _mbsncmp
#define _strnset  _mbsnset
*/
#elif (defined(_DOS) || defined(_WINDOWS)) && !defined(_OS2)
#include  <mbstring.h>
#define strstr  _mbsstr
#define strchr  _mbschr
#define strtok  _mbstok
#define strcspn _mbscspn
#define strpbrk _mbspbrk
#define strspn  _mbsspn
#define _strupr _mbsupr
#define _strlwr _mbslwr
#define _strrev _mbsrev
#define _stricmp  _mbsicmp
#define _strcmpi  _mbsicmp
#define strrchr _mbsrchr
#define _fstrstr  _fmbsstr
#define _fstrchr  _fmbschr
#define _fstrtok  _fmbstok
#define _fstrupr _fmbsupr
#define _fstrlwr _fmbslwr
#define _fstricmp  _fmbsicmp
#define _fstrcmpi  _fmbsicmp
#define _fstrrchr _fmbsrchr
/*
#define _strnicmp _mbsnicmp
#define strlen  _mbslen
#define strcat  _mbscat
#define strcpy  _mbscpy
#define strcmp  _mbscmp
#define _strset _mbsset
#define strncat _mbsncat
#define strncpy _mbsncpy
#define strncmp _mbsncmp
#define _strnset  _mbsnset
*/
#elif defined(_OS2)
#include  <jstring.h>
#define strstr
#define strchr  jstrchr
#define strtok  jstrtok
#define strcspn
#define strpbrk
#define strspn
#define _strupr
#define _strlwr
#define _strrev
#define stricmp __mbsicmp
#define strcmpi __mbsicmp
#define _strnicmp
#define strrchr
/*
#define strlen  _mbslen
#define strcat  _mbscat
#define strcpy  _mbscpy
#define strcmp  _mbscmp
#define _strset _mbsset
#define strncat _mbsncat
#define strncpy _mbsncpy
#define strncmp _mbsncmp
#define _strnset  _mbsnset
*/
#else
#error not defined _DOS, _OS2, or _NTWIN
#endif

#ifdef __cplusplus
}
#endif

#endif  /* _DBCSSTR_INCLUDED_ */

/*** End of 'dbcsstr.h' ***/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\dapimsg.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) Microsoft Corp. 1986-1996. All Rights Reserved.

Abstract:

    This file contains the message definitions for the Microsoft Exchange DAPI.DLL.

--*/

//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//


//
// Define the severity codes
//
#define STATUS_SEVERITY_WARNING          0x2
#define STATUS_SEVERITY_SUCCESS          0x0
#define STATUS_SEVERITY_MASK             0x3
#define STATUS_SEVERITY_INFORMATIONAL    0x1
#define STATUS_SEVERITY_ERROR            0x3


//
// MessageId: BERR_SUCCESS
//
// MessageText:
//
//  No error encountered.
//
#define BERR_SUCCESS                     0x00000000L

//
// MessageId: DAPI_FUNCTION_DAPI
//
// MessageText:
//
//  Directory API%0
//
#define DAPI_FUNCTION_DAPI               0x00000001L

//
// MessageId: DAPI_FUNCTION_BIMPORT
//
// MessageText:
//
//  Directory Import%0
//
#define DAPI_FUNCTION_BIMPORT            0x00000002L

//
// MessageId: DAPI_FUNCTION_BEXPORT
//
// MessageText:
//
//  Directory Export%0
//
#define DAPI_FUNCTION_BEXPORT            0x00000003L

//
// MessageId: DAPI_FUNCTION_NTEXPORT
//
// MessageText:
//
//  NT User Extractor%0
//
#define DAPI_FUNCTION_NTEXPORT           0x00000004L

//
// MessageId: DAPI_FUNCTION_NWEXPORT
//
// MessageText:
//
//  NetWare User Extractor%0
//
#define DAPI_FUNCTION_NWEXPORT           0x00000005L

// Progress-bar stuff
//
// MessageId: DAPIMSG_DISPLAY_CURRENT
//
// MessageText:
//
//  Currently processing:  %1%0
//
#define DAPIMSG_DISPLAY_CURRENT          0x00000006L

//
// MessageId: DAPIMSG_DISPLAY_CREATE
//
// MessageText:
//
//  Creating %2:  %1%0
//
#define DAPIMSG_DISPLAY_CREATE           0x00000007L

//
// MessageId: DAPIMSG_DISPLAY_MODIFY
//
// MessageText:
//
//  Modifying %2:  %1%0
//
#define DAPIMSG_DISPLAY_MODIFY           0x00000008L

//
// MessageId: DAPIMSG_DISPLAY_DELETE
//
// MessageText:
//
//  Deleting %2:  %1%0
//
#define DAPIMSG_DISPLAY_DELETE           0x00000009L

//
// MessageId: DAPIMSG_DISPLAY_EXPORTING
//
// MessageText:
//
//  Exporting %2:  %1%0
//
#define DAPIMSG_DISPLAY_EXPORTING        0x0000000AL

//
// MessageId: DAPIMSG_DISPLAY_EXTRACTING
//
// MessageText:
//
//  Extracting user account:  %1%0
//
#define DAPIMSG_DISPLAY_EXTRACTING       0x0000000BL

//
// MessageId: BIMPMSG_INITIALIZING
//
// MessageText:
//
//  Initializing -- Please wait...%0
//
#define BIMPMSG_INITIALIZING             0x0000000CL

//
// MessageId: DAPIMSG_READING
//
// MessageText:
//
//  Reading Users -- Please wait...%0
//
#define DAPIMSG_READING                  0x0000000DL

//
// MessageId: DAPIMSG_PROGRESS_TITLE
//
// MessageText:
//
//  Directory API%0
//
#define DAPIMSG_PROGRESS_TITLE           0x0000000EL

//
// MessageId: BIMPMSG_PROGRESS_TITLE
//
// MessageText:
//
//  Directory Import from %1%0
//
#define BIMPMSG_PROGRESS_TITLE           0x0000000FL

//
// MessageId: BEXPMSG_PROGRESS_TITLE
//
// MessageText:
//
//  Directory Export to %1%0
//
#define BEXPMSG_PROGRESS_TITLE           0x00000010L

//
// MessageId: NTEXPMSG_PROGRESS_TITLE
//
// MessageText:
//
//  Windows NT User Extraction to %1%0
//
#define NTEXPMSG_PROGRESS_TITLE          0x00000011L

//
// MessageId: NWEXPMSG_PROGRESS_TITLE
//
// MessageText:
//
//  NetWare User Extraction to %1%0
//
#define NWEXPMSG_PROGRESS_TITLE          0x00000012L

// >>> The following group of messages are used for start/stop logging and
// >>> for posting completion-notification message boxes for ALL bimport
// >>> processes (bimport, bexport, ntexport, nwexport).
// >>> NOTE:  !!!!PLEASE PLEASE PLEASE be VERY careful about rearranging
// >>>        ANY of the messages in this group.  
// Common strings
//
// MessageId: DAPI_MSG_COMPLETE_TITLE
//
// MessageText:
//
//  %1 Complete%0
//
#define DAPI_MSG_COMPLETE_TITLE          0x00000013L

//
// MessageId: DAPI_MSG_ONE_WARNING
//
// MessageText:
//
//  One warning event was encountered but not logged.
//
#define DAPI_MSG_ONE_WARNING             0x00000014L

//
// MessageId: DAPI_MSG_ONE_WARNING_REPORTED
//
// MessageText:
//
//  One warning description was recorded in the system's application event log.
//
#define DAPI_MSG_ONE_WARNING_REPORTED    0x00000015L

//
// MessageId: DAPI_MSG_WARNINGS
//
// MessageText:
//
//  %1!lu! warning events were encountered but not logged.
//
#define DAPI_MSG_WARNINGS                0x00000016L

//
// MessageId: DAPI_MSG_WARNINGS_REPORTED
//
// MessageText:
//
//  %1!lu! warning descriptions were recorded in the system's application event log.
//
#define DAPI_MSG_WARNINGS_REPORTED       0x00000017L

//
// MessageId: DAPI_MSG_NOERRORS
//
// MessageText:
//
//  No errors were encountered.
//
#define DAPI_MSG_NOERRORS                0x00000018L

//
// MessageId: DAPI_MSG_ONE_ERROR
//
// MessageText:
//
//  One error event was encountered but not logged.
//
#define DAPI_MSG_ONE_ERROR               0x00000019L

//
// MessageId: DAPI_MSG_ONE_ERROR_REPORTED
//
// MessageText:
//
//  One error description was recorded in the system's application event log.
//
#define DAPI_MSG_ONE_ERROR_REPORTED      0x0000001AL

//
// MessageId: DAPI_MSG_ERRORS
//
// MessageText:
//
//  %1!lu! error events were encountered but not logged.
//
#define DAPI_MSG_ERRORS                  0x0000001BL

//
// MessageId: DAPI_MSG_ERRORS_REPORTED
//
// MessageText:
//
//  %1!lu! error descriptions were recorded in the system's application event log.
//
#define DAPI_MSG_ERRORS_REPORTED         0x0000001CL

//
// MessageId: DAPI_MSG_ERRORS_COPIED
//
// MessageText:
//
//  The file %1 contains copies of all object descriptions containing errors.
//
#define DAPI_MSG_ERRORS_COPIED           0x0000001DL

//
// MessageId: DAPI_MSG_PASSWORD_FILE
//
// MessageText:
//
//  %nPlease see %1 for a list of created Windows NT Accounts.
//
#define DAPI_MSG_PASSWORD_FILE           0x0000001EL

// Directory Import start/stop messages
//
// MessageId: BIMPORT_STARTED
//
// MessageText:
//
//  Starting directory import from import file %1.
//
#define BIMPORT_STARTED                  0x4000001FL

//
// MessageId: BIMPORT_COMPLETE
//
// MessageText:
//
//  The directory import from file %1 is complete.
//
#define BIMPORT_COMPLETE                 0x40000020L

//
// MessageId: BIMPORT_COMPLETE_NOFILE
//
// MessageText:
//
//  The directory import is complete.
//
#define BIMPORT_COMPLETE_NOFILE          0x40000021L

//
// MessageId: BIMPORT_CANCELLED
//
// MessageText:
//
//  The directory import from file %1 was canceled by user request.
//
#define BIMPORT_CANCELLED                0x80000022L

//
// MessageId: BIMPORT_CANCELLED_NOFILE
//
// MessageText:
//
//  The directory import was canceled by user request.
//
#define BIMPORT_CANCELLED_NOFILE         0x80000023L

// Directory Export start/stop messages
//
// MessageId: BEXPORT_STARTED
//
// MessageText:
//
//  Starting the directory export to file %1.
//
#define BEXPORT_STARTED                  0x40000024L

//
// MessageId: BEXPORT_COMPLETE
//
// MessageText:
//
//  The directory export to file %1 is complete.
//
#define BEXPORT_COMPLETE                 0x40000025L

//
// MessageId: BEXPORT_COMPLETE_NOFILE
//
// MessageText:
//
//  The directory export is complete.
//
#define BEXPORT_COMPLETE_NOFILE          0x40000026L

//
// MessageId: BEXPORT_CANCELLED
//
// MessageText:
//
//  The directory export to file %1 was canceled by user request.
//
#define BEXPORT_CANCELLED                0x80000027L

//
// MessageId: BEXPORT_CANCELLED_NOFILE
//
// MessageText:
//
//  The directory export was canceled by user request.
//
#define BEXPORT_CANCELLED_NOFILE         0x80000028L

//
// MessageId: BEXPORT_STARTED_NOFILE
//
// MessageText:
//
//  Starting the directory export.
//
#define BEXPORT_STARTED_NOFILE           0x40000029L

// NTExport start/stop/completion messages
//
// MessageId: NTEXPORT_STARTED
//
// MessageText:
//
//  Starting the extraction of Windows NT user account information to file %1.
//
#define NTEXPORT_STARTED                 0x4000002AL

//
// MessageId: NTEXPORT_COMPLETE
//
// MessageText:
//
//  Extraction of Windows NT user account information to file %1 is complete.
//
#define NTEXPORT_COMPLETE                0x4000002BL

//
// MessageId: NTEXPORT_COMPLETE_NOFILE
//
// MessageText:
//
//  Extraction of Windows NT user account information is complete.
//
#define NTEXPORT_COMPLETE_NOFILE         0x4000002CL

//
// MessageId: NTEXPORT_CANCELLED
//
// MessageText:
//
//  Extraction of Windows NT user account information to file %1 was canceled by user request.
//
#define NTEXPORT_CANCELLED               0x8000002DL

//
// MessageId: NTEXPORT_CANCELLED_NOFILE
//
// MessageText:
//
//  Extraction of Windows NT user account information was canceled by user request.
//
#define NTEXPORT_CANCELLED_NOFILE        0x8000002EL

//
// MessageId: NTEXPORT_STARTED_NOFILE
//
// MessageText:
//
//  Starting the extraction of Windows NT user account information.
//
#define NTEXPORT_STARTED_NOFILE          0x4000002FL

// NWExport start/stop/completion messages
//
// MessageId: NWEXPORT_STARTED
//
// MessageText:
//
//  Starting the extraction of NetWare user account information to file %1.
//
#define NWEXPORT_STARTED                 0x40000030L

//
// MessageId: NWEXPORT_COMPLETE
//
// MessageText:
//
//  Extraction of NetWare user account information to file %1 is complete.
//
#define NWEXPORT_COMPLETE                0x40000031L

//
// MessageId: NWEXPORT_COMPLETE_NOFILE
//
// MessageText:
//
//  Extraction of NetWare user account information is complete.
//
#define NWEXPORT_COMPLETE_NOFILE         0x40000032L

//
// MessageId: NWEXPORT_CANCELLED
//
// MessageText:
//
//  Extraction of NetWare user account information to file %1 was canceled by user request.
//
#define NWEXPORT_CANCELLED               0x80000033L

//
// MessageId: NWEXPORT_CANCELLED_NOFILE
//
// MessageText:
//
//  Extraction of NetWare user account information was canceled by user request.
//
#define NWEXPORT_CANCELLED_NOFILE        0x80000034L

//
// MessageId: NWEXPORT_STARTED_NOFILE
//
// MessageText:
//
//  Starting the extraction of NetWare user account information.
//
#define NWEXPORT_STARTED_NOFILE          0x40000035L

// <<<< End of block containing start/stop/completion messages
// -------------------     DAPI Errors              -----------------------
//
// MessageId: BERR_GENERAL_FAILURE
//
// MessageText:
//
//  A general failure occurred.
//
#define BERR_GENERAL_FAILURE             0xC0000080L

//
// MessageId: DAPI_E_BAD_HANDLE
//
// MessageText:
//
//  A bad DAPI handle supplied to call.
//
#define DAPI_E_BAD_HANDLE                0xC0000081L    

//
// MessageId: DAPI_E_HEADER_MUST_BE_TEXT
//
// MessageText:
//
//  Header values must be specified as text strings.
//
#define DAPI_E_HEADER_MUST_BE_TEXT       0xC0000082L    

//
// MessageId: PDC_NOT_FOUND
//
// MessageText:
//
//  Unable to find the primary domain controller for domain %1.
//
#define PDC_NOT_FOUND                    0xC0000083L

//
// MessageId: PDC_NOT_RESPONDING
//
// MessageText:
//
//  Primary domain controller %1 is not responding.
//
#define PDC_NOT_RESPONDING               0xC0000084L

// -------------------     messages for BIMPORT     -----------------------
//
// MessageId: BIMPMSG_PROMPT_LOG_FULL
//
// MessageText:
//
//  The application event log is full. If you continue, you should increase the maximum log size or additional error information may not be written to the log. If you cancel, existing operations will not be undone.%n%nDo you want to continue with the %1?
//
#define BIMPMSG_PROMPT_LOG_FULL          0x00000085L

//
// MessageId: BIMPMSG_PROMPT_LOG_ERROR
//
// MessageText:
//
//  The following error was encountered when attempting to log an event in the application event log:
//  %2
//  
//  If you continue, additional error information may not be written to the log. 
//  If you cancel, existing operations will not be undone.
//  
//  Do you wish to continue with the %1?
//
#define BIMPMSG_PROMPT_LOG_ERROR         0x00000086L

//
// MessageId: BIMPMSG_PROMPT_LOG_FILE_ERROR
//
// MessageText:
//
//  An error was encountered when writing to the log file %1. If you continue, additional error information will not be written to the log file. If you cancel, completed operations will not be undone. %n%nDo you want to continue with the %2?
//
#define BIMPMSG_PROMPT_LOG_FILE_ERROR    0x00000087L

//
// MessageId: BWARN_ACCNT_EXISTS
//
// MessageText:
//
//  A Windows NT account for user %1 already exists.
//
#define BWARN_ACCNT_EXISTS               0x80000088L

//
// MessageId: BWARN_OVERRIDE_PDC_NOT_FOUND
//
// MessageText:
//
//  Windows NT account %1 could not be created because the primary domain controller (PDC) could not be found for domain %2.
//
#define BWARN_OVERRIDE_PDC_NOT_FOUND     0x80000089L

//
// MessageId: BWARN_DELETE_TARGET_DOES_NOT_EXIST
//
// MessageText:
//
//  Object %1 that was specified for deletion does not exist.
//
#define BWARN_DELETE_TARGET_DOES_NOT_EXIST 0x8000008AL

//
// MessageId: BWARN_DELETE_ACCOUNT_NOT_FOUND
//
// MessageText:
//
//  The Windows NT security account, %1\%2, was not found and could not be deleted.
//
#define BWARN_DELETE_ACCOUNT_NOT_FOUND   0x8000008BL

//
// MessageId: BWARN_DELETE_DOMAIN_NOT_FOUND
//
// MessageText:
//
//  The Windows NT security account, %1\%2, could not be deleted because the NT security domain controller could not be found.
//
#define BWARN_DELETE_DOMAIN_NOT_FOUND    0x8000008CL

//
// MessageId: BWARN_ASSOC_ACCOUNT_NOT_FOUND
//
// MessageText:
//
//  The Assoc-NT-Account value %2 specified for mailbox %1 could not be found.
//
#define BWARN_ASSOC_ACCOUNT_NOT_FOUND    0x8000008DL

//
// MessageId: BWARN_NO_OBJ_PERM_ADMIN_ACCOUNT
//
// MessageText:
//
//  Obj-Perm-Admin value %3 specified for %2 %1 was not found. This user could not be granted permissions administrator privileges on the %2.
//
#define BWARN_NO_OBJ_PERM_ADMIN_ACCOUNT  0x8000008EL

//
// MessageId: BWARN_NO_OBJ_ADMIN_ACCOUNT
//
// MessageText:
//
//  Obj-Admin value %3 specified for %2 %1 was not found. This user could not be granted administrator privileges on the %2.
//
#define BWARN_NO_OBJ_ADMIN_ACCOUNT       0x8000008FL

//
// MessageId: BWARN_NO_OBJ_USER_ACCOUNT
//
// MessageText:
//
//  Obj-User value %3 specified for %2 %1 was not found. This user will not have access to the %2.
//
#define BWARN_NO_OBJ_USER_ACCOUNT        0x80000090L

//
// MessageId: BWARN_NO_DEFAULT_ACCOUNT
//
// MessageText:
//
//  User access privileges could not be assigned to %2 %1. No user accounts were specified, and the default Windows NT account, %3, could not be found.
//
#define BWARN_NO_DEFAULT_ACCOUNT         0x80000091L

//
// MessageId: BWARN_COULD_NOT_CREATE_SD
//
// MessageText:
//
//  Microsoft Windows error %2 was encountered while attempting to create a Windows NT security descriptor for mailbox object %1.
//
#define BWARN_COULD_NOT_CREATE_SD        0x80000092L

//
// MessageId: DAPI_MISSING_EXCHANGE_CP
//
// MessageText:
//
//  Missing a code page (20261 or 1252) required for proper character translation when reading and writing objects in the directory.  Some characters may not map properly. Verify that these are installed on your system.
//
#define DAPI_MISSING_EXCHANGE_CP         0x40000093L

//
// MessageId: BWARN_RENAMED_OUTPUT_FILE
//
// MessageText:
//
//  File %1 already existed and was renamed to %2.
//
#define BWARN_RENAMED_OUTPUT_FILE        0x40000094L

//
// MessageId: BWARN_RENAMED_IMPORT_FILE
//
// MessageText:
//
//  The specified import file, %1, conflicts with a constructed output file and was renamed to %2.
//
#define BWARN_RENAMED_IMPORT_FILE        0x80000095L

//
// MessageId: BWARN_DEL_ATTR
//
// MessageText:
//
//  Entry %1 did not contain property %2 so the property could not be deleted.
//
#define BWARN_DEL_ATTR                   0x80000096L

//
// MessageId: BWARN_THREAD_FAILED
//
// MessageText:
//
//  Microsoft Windows error %1 occurred when attempting to create a processing thread.
//
#define BWARN_THREAD_FAILED              0x80000097L

//
// MessageId: BWARN_ATTRIBUTE_DUPLICATE
//
// MessageText:
//
//  %1 has been specified more than once in the attribute list. Only the first instance will be used when writing to the directory.
//
#define BWARN_ATTRIBUTE_DUPLICATE        0x80000098L

//
// MessageId: BWARN_ATTRIBUTE_READONLY
//
// MessageText:
//
//  The attribute %1 is read-only. Values specified for this attribute will be ignored when writing to the Directory.
//
#define BWARN_ATTRIBUTE_READONLY         0x80000099L

//
// MessageId: BWARN_ATTRIBUTE_NOT_IMPORTABLE
//
// MessageText:
//
//  The attribute %1 is not directly importable.
//
#define BWARN_ATTRIBUTE_NOT_IMPORTABLE   0xC000009AL

//
// MessageId: BWARN_NO_RAW_MODE_TEMPLATE
//
// MessageText:
//
//  Template objects do not apply when in raw mode.
//
#define BWARN_NO_RAW_MODE_TEMPLATE       0x8000009BL

//
// MessageId: BWARN_OVERSIZE_ATT_FILE
//
// MessageText:
//
//  The attribute value data length exceeded the Microsoft Excel limit of 255 characters. The data was written to file %1.
//
#define BWARN_OVERSIZE_ATT_FILE          0x8000009CL

//
// MessageId: DAPI_ERR_WRONG_SYNTAX
//
// MessageText:
//
//  The value type specified for attribute %1 is incorrect.
//
#define DAPI_ERR_WRONG_SYNTAX            0xC000009DL

//
// MessageId: DAPI_E_INVALID_CODEPAGE
//
// MessageText:
//
//  The specified code page has not been installed on the system.
//
#define DAPI_E_INVALID_CODEPAGE          0xC000009EL

//
// MessageId: DAPI_E_OBJECT_NOT_FOUND
//
// MessageText:
//
//  Unable to find object %1.
//
#define DAPI_E_OBJECT_NOT_FOUND          0xC000009FL

//
// MessageId: DAPI_E_NO_OBJECT
//
// MessageText:
//
//  No object specified.
//
#define DAPI_E_NO_OBJECT                 0xC00000A0L

//
// MessageId: DAPI_E_CREATE_FILE
//
// MessageText:
//
//  Unable to create the export file %1. %2
//
#define DAPI_E_CREATE_FILE               0xC00000A1L

//
// MessageId: DAPI_W_HIER_RECALC_FAILED
//
// MessageText:
//
//  Unable to recalculate the Address Book hierarchy after performing the %2 operation on the %1 container.
//
#define DAPI_W_HIER_RECALC_FAILED        0x800000A2L

//
// MessageId: DAPI_W_EXP_FILE_OVERWRITTEN
//
// MessageText:
//
//  The export file %1 already exists and is being overwritten.
//
#define DAPI_W_EXP_FILE_OVERWRITTEN      0x800000A3L

//
// MessageId: DAPI_W_NO_VALUES
//
// MessageText:
//
//  No values specified for DAPIWrite.
//
#define DAPI_W_NO_VALUES                 0x800000A4L

//
// MessageId: DAPI_W_RDN_MAPPED
//
// MessageText:
//
//  One or more characters specified for the %2 are not valid.  The object name was changed from %1 to %3.
//
#define DAPI_W_RDN_MAPPED                0x800000A5L

//
// MessageId: DAPI_W_IMP_VALUE_MAPPED
//
// MessageText:
//
//  One or more characters specified for the %2 attribute of object %1 are not valid.  The value was changed from %3 to %4.
//
#define DAPI_W_IMP_VALUE_MAPPED          0x800000A6L

//
// MessageId: DAPI_W_EXP_VALUE_MAPPED
//
// MessageText:
//
//  One or more characters in the %2 attribute of %1 could not be mapped to the export code page. The system default character was used.
//
#define DAPI_W_EXP_VALUE_MAPPED          0x800000A7L

//
// MessageId: DAPI_W_BACKSLASH_DROPPED
//
// MessageText:
//
//  One or more backslash characters specified in the %2 attribute of %1 were mapped out on import. The value was changed from %3 to %4. The backslash character may be specified by doubling it (i.e., \\).
//
#define DAPI_W_BACKSLASH_DROPPED         0x800000A8L

//
// MessageId: DAPI_W_STRING_TOO_LONG
//
// MessageText:
//
//  A value specified for the %2 attribute of object %1 exceeded the limit of %3 %4.  The string was truncated to fit.
//
#define DAPI_W_STRING_TOO_LONG           0x800000A9L

//
// MessageId: DAPI_W_NO_DL_OWNER_ACCOUNT
//
// MessageText:
//
//  There is no primary Windows NT Account associated with the object specified as the owner of distribution list %1.
//
#define DAPI_W_NO_DL_OWNER_ACCOUNT       0x800000AAL

//
// MessageId: DAPI_W_SERVER_SYNCH_IN_PROGRESS
//
// MessageText:
//
//  The Microsoft Exchange Directory server, %1, is currently synchronizing with other servers in the site.  Write operations are not recommended at this time.
//
#define DAPI_W_SERVER_SYNCH_IN_PROGRESS  0x800000ABL

//
// MessageId: BERR_SIGNATURE_MISMATCH
//
// MessageText:
//
//  A version mismatch was detected between DAPI.DLL and the program. %1 cannot proceed.
//
#define BERR_SIGNATURE_MISMATCH          0xC00000ACL

//
// MessageId: BERR_INVALID_BASEPOINT
//
// MessageText:
//
//  The object name specified for basepoint %1 is not valid.
//
#define BERR_INVALID_BASEPOINT           0xC00000ADL

//
// MessageId: BERR_NO_SUCH_BASEPOINT
//
// MessageText:
//
//  The basepoint object %1 does not exist in the directory.
//
#define BERR_NO_SUCH_BASEPOINT           0xC00000AEL

//
// MessageId: BERR_INVALID_CONTAINER
//
// MessageText:
//
//  The object name specified for the container %1 is not valid.
//
#define BERR_INVALID_CONTAINER           0xC00000AFL

//
// MessageId: BERR_NO_SUCH_CONTAINER
//
// MessageText:
//
//  The specified container %1 does not exist in the directory.
//
#define BERR_NO_SUCH_CONTAINER           0xC00000B0L

//
// MessageId: BERR_DEFAULT_USER_ERROR
//
// MessageText:
//
//  The object name specified for the create object template %1 is not valid.
//
#define BERR_DEFAULT_USER_ERROR          0xC00000B1L

//
// MessageId: BERR_NO_WORKSPACE
//
// MessageText:
//
//  No object management (OM) workspace is available.
//
#define BERR_NO_WORKSPACE                0xC00000B2L

//
// MessageId: BERR_DUA_UNAVAILABLE
//
// MessageText:
//
//  Unable to initialize directory user agent (DUA) workspace.
//
#define BERR_DUA_UNAVAILABLE             0xC00000B3L

//
// MessageId: BERR_NEGOTIATE_FAILURE
//
// MessageText:
//
//  Could not negotiate directory user agent (DUA) features. %1
//
#define BERR_NEGOTIATE_FAILURE           0xC00000B4L

//
// MessageId: BERR_DSA_BIND_FAILURE
//
// MessageText:
//
//  Could not bind to the Microsoft Exchange Directory server %2.  %1
//
#define BERR_DSA_BIND_FAILURE            0xC00000B5L

//
// MessageId: BERR_DEFAULT_BIND_FAILURE
//
// MessageText:
//
//  No Microsoft Exchange Directory server is available.
//
#define BERR_DEFAULT_BIND_FAILURE        0xC00000B6L

//
// MessageId: BERR_ILLEGAL_DSANAME
//
// MessageText:
//
//  The Microsoft Exchange Directory server Name, %1, is illegal.
//
#define BERR_ILLEGAL_DSANAME             0xC00000B7L

//
// MessageId: BERR_SERVER_NOT_WRITABLE
//
// MessageText:
//
//  The Microsoft Exchange Directory server, %1, is not currently writable.  Try the operation again later.
//
#define BERR_SERVER_NOT_WRITABLE         0xC00000B8L

//
// MessageId: BERR_DSA_UNBIND_FAILURE
//
// MessageText:
//
//  Could not unbind from the directory service. %1
//
#define BERR_DSA_UNBIND_FAILURE          0xC00000B9L

//
// MessageId: BERR_SCHEMA_LOAD_FAILED
//
// MessageText:
//
//  An initialization failure occurred. The directory schema could not be read from messaging site %1.
//
#define BERR_SCHEMA_LOAD_FAILED          0xC00000BAL

//
// MessageId: BERR_XOM_SCHEMA_READ
//
// MessageText:
//
//  An initialization failure occurred. Object management (OM) error %1 was encountered while attempting to read the schema.
//
#define BERR_XOM_SCHEMA_READ             0xC00000BBL

//
// MessageId: BERR_XDS_SCHEMA_READ
//
// MessageText:
//
//  An initialization failure occurred while attempting to read the schema.  %1
//
#define BERR_XDS_SCHEMA_READ             0xC00000BCL

//
// MessageId: BERR_ATTRIBUTES_UNAVAILABLE
//
// MessageText:
//
//  An initialization failure occurred. Unable to read attributes from the schema.
//
#define BERR_ATTRIBUTES_UNAVAILABLE      0xC00000BDL

//
// MessageId: BERR_ATTRIBUTE_PROPERTY_UNAVAILABLE
//
// MessageText:
//
//  An initialization failure occurred. The attribute-schema object %1 does not contain the %2 attribute.
//
#define BERR_ATTRIBUTE_PROPERTY_UNAVAILABLE 0xC00000BEL

//
// MessageId: BERR_INIT_ATTR_UNKNOWN
//
// MessageText:
//
//  Attribute %1 is not defined in the directory schema and so is not supported for import.
//
#define BERR_INIT_ATTR_UNKNOWN           0xC00000BFL

//
// MessageId: BERR_UNREC_OBJECT_TYPE
//
// MessageText:
//
//  An internal error occurred. The directory schema contained an unrecognized type value. Attribute %1.
//
#define BERR_UNREC_OBJECT_TYPE           0xC00000C0L

//
// MessageId: BERR_OBJECT_TYPE_NOT_IMPLEMENTED
//
// MessageText:
//
//  Attribute %1 cannot be processed because its object type is not yet implemented.
//
#define BERR_OBJECT_TYPE_NOT_IMPLEMENTED 0xC00000C1L

//
// MessageId: BERR_UNREC_ATTR_SYNTAX
//
// MessageText:
//
//  An internal error occurred. The directory schema contains an unrecognized syntax value. Attribute %1.
//
#define BERR_UNREC_ATTR_SYNTAX           0xC00000C2L

//
// MessageId: BERR_ATTR_SYNTAX_NOT_IMPLEMENTED
//
// MessageText:
//
//  An internal error occurred. Attribute %1 cannot be processed because its object management (OM) syntax is not yet implemented.
//
#define BERR_ATTR_SYNTAX_NOT_IMPLEMENTED 0xC00000C3L

//
// MessageId: BERR_VALUE_SYNTAX_NOT_IMPLEMENTED
//
// MessageText:
//
//  Unable to convert the attribute value to a string because syntax %1 is not yet implemented.
//
#define BERR_VALUE_SYNTAX_NOT_IMPLEMENTED 0xC00000C4L

//
// MessageId: BERR_UNREC_VALUE_SYNTAX
//
// MessageText:
//
//  Unable to convert the attribute value to a string because syntax %1 is not recognized.
//
#define BERR_UNREC_VALUE_SYNTAX          0xC00000C5L

//
// MessageId: BERR_VALUE_OBJECT_TYPE_NOT_IMPLEMENTED
//
// MessageText:
//
//  Unable to convert the attribute value to a string because object type %1 is not yet implemented.
//
#define BERR_VALUE_OBJECT_TYPE_NOT_IMPLEMENTED 0xC00000C6L

//
// MessageId: BERR_UNREC_VALUE_OBJECT_TYPE
//
// MessageText:
//
//  Unable to convert the attribute value to a string because the object type is not recognized.
//
#define BERR_UNREC_VALUE_OBJECT_TYPE     0xC00000C7L

//
// MessageId: BERR_INIT_CLASS_UNKNOWN
//
// MessageText:
//
//  Unable to initialize because class ID %1 was not found in the descriptors read from the schema.
//
#define BERR_INIT_CLASS_UNKNOWN          0xC00000C8L

//
// MessageId: BERR_CLASSES_UNAVAILABLE
//
// MessageText:
//
//  Unable to initialize because the object class descriptions could not be read from the schema.
//
#define BERR_CLASSES_UNAVAILABLE         0xC00000C9L

//
// MessageId: BERR_CLASS_PROPERTY_UNAVAILABLE
//
// MessageText:
//
//  Unable to initialize because the class schema object %1 does not contain the %2 attribute.
//
#define BERR_CLASS_PROPERTY_UNAVAILABLE  0xC00000CAL

//
// MessageId: BERR_CLASS_ATTRIBUTE_MISSING
//
// MessageText:
//
//  Unable to initialize because at least one of the schema attributes specified in the %2 attribute of the class schema object %1 is not defined.
//
#define BERR_CLASS_ATTRIBUTE_MISSING     0xC00000CBL

//
// MessageId: BERR_NO_IMPORT_FILE
//
// MessageText:
//
//  There is no file specified for directory import.
//
#define BERR_NO_IMPORT_FILE              0xC00000CCL

//
// MessageId: BERR_NO_EXPORT_FILE
//
// MessageText:
//
//  There is no file specified for the export operation.
//
#define BERR_NO_EXPORT_FILE              0xC00000CDL

//
// MessageId: BERR_INVALID_IMPORT_FILE
//
// MessageText:
//
//  Unable to open import file %1. %2
//
#define BERR_INVALID_IMPORT_FILE         0xC00000CEL

//
// MessageId: BERR_INVALID_EXPORT_FILE
//
// MessageText:
//
//  Unable to export to file %1. %2
//
#define BERR_INVALID_EXPORT_FILE         0xC00000CFL

//
// MessageId: BERR_FILE_IS_UNICODE
//
// MessageText:
//
//  The specified file is Unicode. Code page override is not valid.
//
#define BERR_FILE_IS_UNICODE             0xC00000D0L

//
// MessageId: BERR_FILE_IS_NOT_UNICODE
//
// MessageText:
//
//  The specified file is not Unicode.
//
#define BERR_FILE_IS_NOT_UNICODE         0xC00000D1L

//
// MessageId: BERR_INVALID_FILENAME
//
// MessageText:
//
//  The filename %1 is not valid.
//
#define BERR_INVALID_FILENAME            0xC00000D2L

//
// MessageId: BERR_CANT_RENAME_IMP_FILE
//
// MessageText:
//
//  The specified import file %1 conflicts with a constructed output filename, but could not be renamed for import.
//
#define BERR_CANT_RENAME_IMP_FILE        0xC00000D3L

//
// MessageId: BERR_CANT_RENAME_EXPORT_FILE
//
// MessageText:
//
//  The export file %1 could not be accessed. The file may be opened by another application or the path may not be valid.
//
#define BERR_CANT_RENAME_EXPORT_FILE     0xC00000D4L

//
// MessageId: BERR_FILE_IS_DIRECTORY
//
// MessageText:
//
//  The specified file %1 names a directory.
//
#define BERR_FILE_IS_DIRECTORY           0xC00000D5L

//
// MessageId: BERR_FILE_IS_READONLY
//
// MessageText:
//
//  Unable to create output file %1. The file exists and is read only.
//
#define BERR_FILE_IS_READONLY            0xC00000D6L

//
// MessageId: BERR_CREATE_LOG_FAILED
//
// MessageText:
//
//  Unable to create the directory import error log file %1.
//
#define BERR_CREATE_LOG_FAILED           0xC00000D7L

//
// MessageId: BERR_CREATE_PSW_FAILED
//
// MessageText:
//
//  Unable to create the directory import password file %1.
//
#define BERR_CREATE_PSW_FAILED           0xC00000D8L

//
// MessageId: BERR_WRITE_PSW_ERROR
//
// MessageText:
//
//  The system reported the following error while attempting to write to the created account file %1. %n%2
//
#define BERR_WRITE_PSW_ERROR             0xC00000D9L

//
// MessageId: BERR_MISSING_OBJ_CLASS
//
// MessageText:
//
//  The Obj-Class value must be specified on each import line.
//
#define BERR_MISSING_OBJ_CLASS           0xC00000DAL

//
// MessageId: BERR_RDN_MISSING
//
// MessageText:
//
//  The %1 attribute is required to identify %2 objects.
//
#define BERR_RDN_MISSING                 0xC00000DBL

//
// MessageId: BERR_MISQUOTED_IMPORT_LINE
//
// MessageText:
//
//  An incorrect use of the quotation mark delimiter was encountered on the import line.
//
#define BERR_MISQUOTED_IMPORT_LINE       0xC00000DCL

//
// MessageId: BERR_ILLEGAL_MODE
//
// MessageText:
//
//  %1 is not recognized as a legal import mode.
//
#define BERR_ILLEGAL_MODE                0xC00000DDL

//
// MessageId: BERR_MODE_COLUMN
//
// MessageText:
//
//  %1 can be specified only in the second column.
//
#define BERR_MODE_COLUMN                 0xC00000DEL

//
// MessageId: BERR_OUT_OF_MEMORY
//
// MessageText:
//
//  Out of memory error encountered.
//
#define BERR_OUT_OF_MEMORY               0xC00000DFL

//
// MessageId: BERR_FILE_READ_FAILURE
//
// MessageText:
//
//  The following error occurred while attempting to read from the import file:  %1
//
#define BERR_FILE_READ_FAILURE           0xC00000E0L

//
// MessageId: BERR_MISSING_COMMON_NAME_HEADER
//
// MessageText:
//
//  The import file %1 is not valid because the Common Name column is missing.
//
#define BERR_MISSING_COMMON_NAME_HEADER  0xC00000E1L

//
// MessageId: BERR_MISSING_OBJ_CLASS_HEADER
//
// MessageText:
//
//  The import file %1 is not valid. The first column header must be Obj-Class.  The first column header found was %2. Confirm that the column delimiter, '%3', is correct for the file.
//
#define BERR_MISSING_OBJ_CLASS_HEADER    0xC00000E2L

//
// MessageId: BERR_HEADER_MISQUOTED
//
// MessageText:
//
//  Import file %1 is not valid because quotation mark delimiters were used improperly in the header line.
//
#define BERR_HEADER_MISQUOTED            0xC00000E3L

//
// MessageId: BERR_INVALID_OBJ_CLASS
//
// MessageText:
//
//  %1 is not recognized as a legal Obj-Class value.
//
#define BERR_INVALID_OBJ_CLASS           0xC00000E4L

//
// MessageId: BERR_PROXY_INIT_ERROR
//
// MessageText:
//
//  The following error was reported while trying to initialize the e-mail address generating subsystem. %1
//
#define BERR_PROXY_INIT_ERROR            0xC00000E5L

//
// MessageId: BERR_NO_PROXY_SEPARATOR
//
// MessageText:
//
//  Import object %1 was not processed because the e-mail address type separator, :, was not found in the specified %3 value: %2.
//
#define BERR_NO_PROXY_SEPARATOR          0xC00000E6L

//
// MessageId: BERR_NO_PROXY_PREFIX
//
// MessageText:
//
//  Import object %1 was not processed because no e-mail address type was specified for %3 string: %2
//
#define BERR_NO_PROXY_PREFIX             0xC00000E7L

//
// MessageId: BERR_ILLEGAL_PROXY_PREFIX_LEN
//
// MessageText:
//
//  Unable to process import object %1. The e-mail address type must be eight characters or less. %2
//
#define BERR_ILLEGAL_PROXY_PREFIX_LEN    0xC00000E8L

//
// MessageId: BERR_DUPLICATE_PROXY
//
// MessageText:
//
//  Unable to process object %1 because the specified e-mail address %2 has the same type as one or more other e-mail addresses specified for the same object.
//
#define BERR_DUPLICATE_PROXY             0xC00000E9L

//
// MessageId: BERR_PROXY_GENERAL_FAILURE
//
// MessageText:
//
//  Unable to process object %1 because the Microsoft Exchange System Attendant encountered errors while attempting to generate or validate e-mail addresses. For more information, see the event log on server %2.
//
#define BERR_PROXY_GENERAL_FAILURE       0xC00000EAL

//
// MessageId: BERR_PROXY_TARGET_INVALID
//
// MessageText:
//
//  Unable to process custom recipient %1 because the target address is not valid. %2
//
#define BERR_PROXY_TARGET_INVALID        0xC00000EBL

//
// MessageId: BERR_PROXY_TARGET_NOT_UNIQUE
//
// MessageText:
//
//  Unable to process custom recipient %1 because target address %2 has already been assigned to Address Book entry %3.
//
#define BERR_PROXY_TARGET_NOT_UNIQUE     0xC00000ECL

//
// MessageId: BERR_PROXY_INVALID
//
// MessageText:
//
//  The e-mail address specified for import object %1 is not valid. %2
//
#define BERR_PROXY_INVALID               0xC00000EDL

//
// MessageId: BERR_PROXY_NOT_UNIQUE
//
// MessageText:
//
//  The e-mail address specified for import object %1 is not unique. %2 has already been assigned to Address Book entry %3.
//
#define BERR_PROXY_NOT_UNIQUE            0xC00000EEL

//
// MessageId: BERR_PROXY_GENERIC
//
// MessageText:
//
//  The Microsoft Exchange System Attendant reported %3 when attempting to generate or validate e-mail addresses for %1.  For more information, see the event log on server %2 for details.
//
#define BERR_PROXY_GENERIC               0xC00000EFL

//
// MessageId: BERR_PROXY_SYSTEM
//
// MessageText:
//
//  The following error was encountered when attempting to generate or validate e-mail addresses for %1. %2
//
#define BERR_PROXY_SYSTEM                0xC00000F0L

//
// MessageId: BERR_CREATE_DEL_ERROR
//
// MessageText:
//
//  Object %1 was not built because the string ~DEL may only be used with existing objects.
//
#define BERR_CREATE_DEL_ERROR            0xC00000F1L

//
// MessageId: BERR_OM_ERROR
//
// MessageText:
//
//  Object management (OM) error %1 was reported.
//
#define BERR_OM_ERROR                    0xC00000F2L

//
// MessageId: BERR_ATTRIBUTE_OR_VALUE_EXISTS
//
// MessageText:
//
//  A duplicate value was specified for attribute %2 on object %1.
//
#define BERR_ATTRIBUTE_OR_VALUE_EXISTS   0xC00000F3L

//
// MessageId: BERR_CONSTRAINT_VIOLATION
//
// MessageText:
//
//  Unable to complete the operation on object %1 because a value specified for attribute %2 is out of range.
//
#define BERR_CONSTRAINT_VIOLATION        0xC00000F4L

//
// MessageId: BERR_INVALID_SYNTAX
//
// MessageText:
//
//  Unable to complete the operation on object %1 because the syntax specified for a value for attribute %2 is not valid.
//
#define BERR_INVALID_SYNTAX              0xC00000F5L

//
// MessageId: BERR_NO_SUCH_ATTRIBUTE_OR_VALUE
//
// MessageText:
//
//  The attribute %2 is not defined on object %1 and could not be read.
//
#define BERR_NO_SUCH_ATTRIBUTE_OR_VALUE  0xC00000F6L

//
// MessageId: BERR_ACCNT_LM_INIT_ERROR
//
// MessageText:
//
//  Unable to create Windows NT accounts because network error %1 occurred while initializing.
//
#define BERR_ACCNT_LM_INIT_ERROR         0xC00000F7L

//
// MessageId: BERR_LM_INIT_ERROR
//
// MessageText:
//
//  Could not initialize -- Net error %1 reported during initialization.
//
#define BERR_LM_INIT_ERROR               0xC00000F8L

//
// MessageId: BERR_LM_ERROR
//
// MessageText:
//
//  Network error %1 occurred.
//
#define BERR_LM_ERROR                    0xC00000F9L

//
// MessageId: BERR_ACCNT_PDC_GONE
//
// MessageText:
//
//  The primary domain controller for domain %1 is no longer available.
//
#define BERR_ACCNT_PDC_GONE              0xC00000FAL

//
// MessageId: BERR_ACCNT_LM_ERROR
//
// MessageText:
//
//  Unable to create a Windows NT account for user %1. %2
//
#define BERR_ACCNT_LM_ERROR              0xC00000FBL

//
// MessageId: BERR_ACCNT_WIN_ERROR
//
// MessageText:
//
//  Unable to create a Windows NT account for user %1. %2
//
#define BERR_ACCNT_WIN_ERROR             0xC00000FCL

//
// MessageId: BERR_ACCNT_TOO_LONG
//
// MessageText:
//
//  Unable to create a Windows NT account %2 for mailbox %1 because Windows NT account names cannot exceed 20 characters.
//
#define BERR_ACCNT_TOO_LONG              0xC00000FDL

//
// MessageId: BERR_ILLEGAL_ACCNT_CHARS
//
// MessageText:
//
//  Unable to create Windows NT account %2 for mailbox %1 because it contains the illegal character(s) %3.
//
#define BERR_ILLEGAL_ACCNT_CHARS         0xC00000FEL

//
// MessageId: BERR_LM_DELETE_ACCOUNT
//
// MessageText:
//
//  A network error occurred when attempting to delete Windows NT security account %1.
//
#define BERR_LM_DELETE_ACCOUNT           0xC00000FFL

//
// MessageId: BERR_WIN_DELETE_ACCOUNT
//
// MessageText:
//
//  Unable to delete the Windows NT account for user %1. %2.
//
#define BERR_WIN_DELETE_ACCOUNT          0xC0000100L

//
// MessageId: BERR_DEL_ACCOUNT_LOOKUP_FAILED
//
// MessageText:
//
//  An error occurred while attempting to lookup the Assoc-NT-Account value for object %1. Neither the security account nor the object was deleted.
//
#define BERR_DEL_ACCOUNT_LOOKUP_FAILED   0xC0000101L

//
// MessageId: BERR_ACCOUNT_LOOKUP_FAILED
//
// MessageText:
//
//  An error occurred while attempting to lookup the Assoc-NT-Account value for object %1.
//
#define BERR_ACCOUNT_LOOKUP_FAILED       0x80000102L

//
// MessageId: BERR_ACCNT_WIN_INIT_ERROR
//
// MessageText:
//
//  Unable to create Windows NT accounts because Windows reports error %1.
//
#define BERR_ACCNT_WIN_INIT_ERROR        0xC0000103L

//
// MessageId: BERR_WIN_INIT_ERROR
//
// MessageText:
//
//  Unable to initialize because Windows reports error %1.
//
#define BERR_WIN_INIT_ERROR              0xC0000104L

//
// MessageId: BERR_REGISTER_ERROR
//
// MessageText:
//
//  Unable to initialize because Windows reports error %1 occurred while attempting to register with the system.
//
#define BERR_REGISTER_ERROR              0xC0000105L

//
// MessageId: BERR_WIN_ERROR
//
// MessageText:
//
//  Windows reports error %1.
//
#define BERR_WIN_ERROR                   0xC0000106L

//
// MessageId: BERR_NO_ATTRIBUTES_SPECIFIED
//
// MessageText:
//
//  No attributes are specified.
//
#define BERR_NO_ATTRIBUTES_SPECIFIED     0xC0000107L

//
// MessageId: BERR_ATTRIBUTE_UNKNOWN
//
// MessageText:
//
//  The attribute %1 is unknown.
//
#define BERR_ATTRIBUTE_UNKNOWN           0xC0000108L

//
// MessageId: BERR_ATTRIBUTE_NOT_IMPORTABLE
//
// MessageText:
//
//  Attribute %1 cannot be imported.
//
#define BERR_ATTRIBUTE_NOT_IMPORTABLE    0xC0000109L

//
// MessageId: BERR_CANT_DELETE_REQUIRED_ATTRIBUTE
//
// MessageText:
//
//  Unable to process object %1. The required attribute %2 may not be deleted.
//
#define BERR_CANT_DELETE_REQUIRED_ATTRIBUTE 0xC000010AL

//
// MessageId: BERR_CANT_DELETE_ATTRIBUTE
//
// MessageText:
//
//  Unable to process object %1. Attribute %2 may not be deleted.
//
#define BERR_CANT_DELETE_ATTRIBUTE       0xC000010BL

//
// MessageId: BERR_DELETE_KEY_MUST_BE_SINGLE
//
// MessageText:
//
//  Unable to process object %1. ~DEL may not be specified with other values for multi-valued attribute %2.
//
#define BERR_DELETE_KEY_MUST_BE_SINGLE   0xC000010CL

//
// MessageId: BERR_COULD_NOT_EMPTY_MAILBOX
//
// MessageText:
//
//  Error %2 occurred while attempting to throw away %1's mail.
//
#define BERR_COULD_NOT_EMPTY_MAILBOX     0xC000010DL

//
// MessageId: BERR_MALFORMED_OCTET_STRING
//
// MessageText:
//
//  Unable to process object %1 because the octet string specified for attribute %2 is incorrect.
//
#define BERR_MALFORMED_OCTET_STRING      0xC000010EL

//
// MessageId: BERR_ILLEGAL_CHAR_IN_NUMBER
//
// MessageText:
//
//  Unable to process object %1 because the character specified in value for attribute %2 is not valid.
//
#define BERR_ILLEGAL_CHAR_IN_NUMBER      0xC000010FL

//
// MessageId: BERR_ILLEGAL_CHAR_IN_HEX_NUMBER
//
// MessageText:
//
//  Unable to process object %1 because the character specified in value for attribute %2 is not valid.
//
#define BERR_ILLEGAL_CHAR_IN_HEX_NUMBER  0xC0000110L

//
// MessageId: BERR_CANNOT_BUILD_DN
//
// MessageText:
//
//  Could not build DN string from components:  BasePoint == %1, Container == %2, ObjName == %3.
//
#define BERR_CANNOT_BUILD_DN             0xC0000111L

//
// MessageId: BERR_MALFORMED_DN_STRING
//
// MessageText:
//
//  Unable to process object %1 because DN string %2 is not valid.
//
#define BERR_MALFORMED_DN_STRING         0xC0000112L

//
// MessageId: BERR_UNKNOWN_RDN
//
// MessageText:
//
//  Unable to process object %1 because RDN string %2 is not valid.
//
#define BERR_UNKNOWN_RDN                 0xC0000113L

//
// MessageId: BERR_BADLY_SPECIFIED_DN
//
// MessageText:
//
//  DN string %1 is not valid.
//
#define BERR_BADLY_SPECIFIED_DN          0xC0000114L

//
// MessageId: BERR_MALFORMED_DN_OBJECT
//
// MessageText:
//
//  The distinguished name (DN) object read from the directory information tree (DIT) is not valid.
//
#define BERR_MALFORMED_DN_OBJECT         0xC0000115L

//
// MessageId: BERR_ACCNT_PDC_DISAPPEARED
//
// MessageText:
//
//  Unable to create a Windows NT account for user %1. The primary domain controller for domain %2 is not responding.
//
#define BERR_ACCNT_PDC_DISAPPEARED       0xC0000116L

//
// MessageId: BERR_XOM_REVOKE_MEMBERSHIP
//
// MessageText:
//
//  Object management (OM) error %1 was encountered when attempting to remove object %2 from a distribution list.
//
#define BERR_XOM_REVOKE_MEMBERSHIP       0xC0000117L

//
// MessageId: BERR_XDS_ERROR
//
// MessageText:
//
//  The directory service reported the following error: %1
//
#define BERR_XDS_ERROR                   0xC0000118L

//
// MessageId: BERR_XDS_CREATE
//
// MessageText:
//
//  Could not create object %2 because the directory service reported the following error: %1
//
#define BERR_XDS_CREATE                  0xC0000119L

//
// MessageId: BERR_XDS_MODIFY
//
// MessageText:
//
//  Could not modify object %2 because the directory service reported the following error: %1
//
#define BERR_XDS_MODIFY                  0xC000011AL

//
// MessageId: BERR_XDS_REMOVE
//
// MessageText:
//
//  Could not remove object %2 because the directory service reported the following error: %1
//
#define BERR_XDS_REMOVE                  0xC000011BL

//
// MessageId: BERR_XDS_DL_MEMBERSHIP
//
// MessageText:
//
//  Could not modify the DL membership of object %2 because the directory service reported the following error:  %1
//
#define BERR_XDS_DL_MEMBERSHIP           0xC000011CL

//
// MessageId: BERR_OBJECT_MEMBERSHIP_ERROR
//
// MessageText:
//
//  Unable to add object %1 to distribution list %2.
//
#define BERR_OBJECT_MEMBERSHIP_ERROR     0xC000011DL

//
// MessageId: BERR_CREATE_PATH_NOT_FOUND
//
// MessageText:
//
//  Unable to create object %1 because one or more objects in the directory path %2 do not exist.
//
#define BERR_CREATE_PATH_NOT_FOUND       0xC000011EL

//
// MessageId: BERR_CREATE_TARGET_EXISTS
//
// MessageText:
//
//  Unable to create object %1 because it already exists.
//
#define BERR_CREATE_TARGET_EXISTS        0xC000011FL

//
// MessageId: BERR_MOD_TARGET_NOT_FOUND
//
// MessageText:
//
//  Unable to modify object %1 because it could not be found.
//
#define BERR_MOD_TARGET_NOT_FOUND        0xC0000120L

//
// MessageId: BERR_MOD_CLASS_MISMATCH
//
// MessageText:
//
//  Entry %1 could not be modified as a %2 because it already exists as a %3 object.
//
#define BERR_MOD_CLASS_MISMATCH          0xC0000121L

//
// MessageId: BERR_DEL_CLASS_MISMATCH
//
// MessageText:
//
//  Unable to delete the %3 %1 because the entry already exists as a %2 in the directory.
//
#define BERR_DEL_CLASS_MISMATCH          0xC0000122L

//
// MessageId: BERR_INCORRECT_FIELD_COUNT
//
// MessageText:
//
//  Unable to process object %1 because the import line must contain the same number of fields as the header line. %2 were expected. %3 were found.
//
#define BERR_INCORRECT_FIELD_COUNT       0xC0000123L

//
// MessageId: BERR_MISSING_REQUIRED_ATTRIBUTE
//
// MessageText:
//
//  Unable to create %3 %1 because the required %2 attribute was not specified.
//
#define BERR_MISSING_REQUIRED_ATTRIBUTE  0xC0000124L

//
// MessageId: BERR_ONLY_SINGLE_CONTAINER
//
// MessageText:
//
//  Only a single container can be specified for the import object %1.
//
#define BERR_ONLY_SINGLE_CONTAINER       0xC0000125L

//
// MessageId: BERR_CANNOT_LOG_ERROR
//
// MessageText:
//
//  The directory import encountered Windows Error %2!lu! when attempting to record the following message in the system event log: %1
//
#define BERR_CANNOT_LOG_ERROR            0xC0000126L

//
// MessageId: BERR_INCLUDE_FAIL
//
// MessageText:
//
//  Unable to open or read the attribute value include file %1.
//
#define BERR_INCLUDE_FAIL                0xC0000127L

//
// MessageId: BERR_BAD_FILE_PTR
//
// MessageText:
//
//  The attribute value file pointer %1 was not specified correctly.
//
#define BERR_BAD_FILE_PTR                0xC0000128L

//
// MessageId: BERR_HOME_SERVER_UNKNOWN
//
// MessageText:
//
//  Unable to process object %1 because the specified home server %2 does not exist.
//
#define BERR_HOME_SERVER_UNKNOWN         0xC0000129L

//
// MessageId: BERR_HOME_SERVER_NO_MTA
//
// MessageText:
//
//  Unable to process object %1 because there is no Microsoft Exchange MTA installed on the specified home server %2.
//
#define BERR_HOME_SERVER_NO_MTA          0xC000012AL

//
// MessageId: BERR_HOME_SERVER_NO_PRIVATE_STORE
//
// MessageText:
//
//  Unable to process object %1 because there is no Microsoft Exchange private information store installed on the specified home server %2.
//
#define BERR_HOME_SERVER_NO_PRIVATE_STORE 0xC000012BL

// -------------------     messages for BEXPORT     -----------------------
//
// MessageId: BEXPORT_WRITE_ERROR
//
// MessageText:
//
//  The directory export was stopped because the following error occurred when attempting to write an object description to the file: %n%1
//
#define BEXPORT_WRITE_ERROR              0xC000012CL

//
// MessageId: BEXPORT_UNKNOWN_CLASS
//
// MessageText:
//
//  The class %1 is not known and could not be exported.
//
#define BEXPORT_UNKNOWN_CLASS            0xC000012DL

//
// MessageId: BEXPORT_NOSEARCHINFO_WARN
//
// MessageText:
//
//  No entries were found for the specified object class %1.
//
#define BEXPORT_NOSEARCHINFO_WARN        0x8000012EL

// -------------------     messages for NTEXPORT     -----------------------
//
// MessageId: NTEXPORT_DC_NOT_FOUND
//
// MessageText:
//
//  The domain controller could not be found for domain %1.
//
#define NTEXPORT_DC_NOT_FOUND            0xC000012FL

//
// MessageId: NTEXPORT_USER_ENUM_ERROR
//
// MessageText:
//
//  The following error occurred when attempting to read Windows NT user accounts from server %1. %2
//
#define NTEXPORT_USER_ENUM_ERROR         0xC0000130L

//
// MessageId: NTEXPORT_SERVER_NOT_FOUND
//
// MessageText:
//
//  NTExport could not find specified server, %1.
//
#define NTEXPORT_SERVER_NOT_FOUND        0xC0000131L

//
// MessageId: NETEXPORT_WRITE_ERROR
//
// MessageText:
//
//  The user extraction was halted because the following error occurred when attempting to write a user account description to the file:%n  %1
//
#define NETEXPORT_WRITE_ERROR            0xC0000132L

// -------------------     messages for NWExport     -----------------------
//
// MessageId: NWEXPORT_NWDLL_LOAD_FAILED
//
// MessageText:
//
//  Unable to load the Netware DLL %1.
//
#define NWEXPORT_NWDLL_LOAD_FAILED       0xC0000133L

//
// MessageId: NWEXPORT_LOGIN_FAILED
//
// MessageText:
//
//  NWExport could not log user %2 onto the file server %1.
//
#define NWEXPORT_LOGIN_FAILED            0xC0000134L

//
// MessageId: NWEXPORT_ATTACH_FAILED
//
// MessageText:
//
//  NWExport encountered an error attaching to the file server %1.
//
#define NWEXPORT_ATTACH_FAILED           0xC0000135L

//
// MessageId: NWEXPORT_LOGOUT_FAILED
//
// MessageText:
//
//  NWExport encountered an error logging out from the file server.
//
#define NWEXPORT_LOGOUT_FAILED           0xC0000136L

//
// MessageId: NWEXPORT_DETACHED_FAILED
//
// MessageText:
//
//  NWExport encountered an error detaching from the file server.
//
#define NWEXPORT_DETACHED_FAILED         0xC0000137L

//
// MessageId: NWEXPORT_NO_USER
//
// MessageText:
//
//  NetWare user extract could not continue because no user was specified for log on to the file server.
//
#define NWEXPORT_NO_USER                 0xC0000138L

// MessageIDs added with Exchange 4.0a
//
// MessageId: DAPI_E_ANR_MULTIPLE_MATCH
//
// MessageText:
//
//  More than one object was found matching the specified search name %1.
//
#define DAPI_E_ANR_MULTIPLE_MATCH        0xC0001000L

//
// MessageId: DAPI_E_ANR_NO_MATCH
//
// MessageText:
//
//  No objects were found matching the specified search name %1.
//
#define DAPI_E_ANR_NO_MATCH              0xC0001001L

//
// MessageId: DAPI_E_MULTIPLE_MATCH_ON_ATT
//
// MessageText:
//
//  More than one object was found matching the alias %3 specified for the %4 attribute on %2 %1.
//
#define DAPI_E_MULTIPLE_MATCH_ON_ATT     0xC0001002L

//
// MessageId: DAPI_E_NO_MATCH_ON_ATT
//
// MessageText:
//
//  No objects were found matching the alias %3 specified for the %4 attribute on %2 %1.
//
#define DAPI_E_NO_MATCH_ON_ATT           0xC0001003L

// ----------------------------     Substitutions ----------------------------
// From this point on, all messages are substitutions for use in other messages
//
// MessageId: IDS_SPACE
//
// MessageText:
//
//  <space>%0
//
#define IDS_SPACE                        0x0000F000L

//
// MessageId: IDS_TAB
//
// MessageText:
//
//  <tab>%0
//
#define IDS_TAB                          0x0000F001L

//
// MessageId: IDS_CHARACTERS
//
// MessageText:
//
//  characters%0
//
#define IDS_CHARACTERS                   0x0000F002L

//
// MessageId: IDS_OCTETS
//
// MessageText:
//
//  octets%0
//
#define IDS_OCTETS                       0x0000F003L

// -------------------     substitutions for Proxy rrors     ----------------------
// Messages w/ ID in range from 0xf080-0xf0ff are assumed to be substitution strings
// used to fill the %3 position of the BERR_PROXY_GENERIC message

//
// MessageId: PROXY_SUBST_GENERAL_FAILURE
//
// MessageText:
//
//  GENERAL_FAILURE%0
//
#define PROXY_SUBST_GENERAL_FAILURE      0x4000F080L

//
// MessageId: PROXY_SUBST_FAILURES
//
// MessageText:
//
//  SOME_PROXIES_FAILED%0
//
#define PROXY_SUBST_FAILURES             0x4000F081L

//
// MessageId: PROXY_SUBST_TARGET_INVALID
//
// MessageText:
//
//  TARGET_ADDRESS_NOT_VALID%0
//
#define PROXY_SUBST_TARGET_INVALID       0x4000F082L

//
// MessageId: PROXY_SUBST_TARGET_NOT_UNIQUE
//
// MessageText:
//
//  TARGET_ADDRESS_NOT_UNIQUE%0
//
#define PROXY_SUBST_TARGET_NOT_UNIQUE    0x4000F083L

//
// MessageId: PROXY_SUBST_DLL_NOT_IMPLEMENTED
//
// MessageText:
//
//  DLL_NOT_IMPLEMENTED%0
//
#define PROXY_SUBST_DLL_NOT_IMPLEMENTED  0x4000F084L

//
// MessageId: PROXY_SUBST_OOM
//
// MessageText:
//
//  OUT_OF_MEMORY%0
//
#define PROXY_SUBST_OOM                  0x4000F085L

//
// MessageId: PROXY_SUBST_DLL_ERROR
//
// MessageText:
//
//  GENERAL_FAILURE%0
//
#define PROXY_SUBST_DLL_ERROR            0x4000F086L

//
// MessageId: PROXY_SUBST_DLL_PROTOCOL
//
// MessageText:
//
//  PROTOCOL_ERROR%0
//
#define PROXY_SUBST_DLL_PROTOCOL         0x4000F087L

//
// MessageId: PROXY_SUBST_SYNTAX
//
// MessageText:
//
//  SYNTAX_ERROR%0
//
#define PROXY_SUBST_SYNTAX               0x4000F088L

//
// MessageId: PROXY_SUBST_EOF
//
// MessageText:
//
//  END_OF_FILE%0
//
#define PROXY_SUBST_EOF                  0x4000F089L

//
// MessageId: PROXY_SUBST_SOFTWARE
//
// MessageText:
//
//  SOFTWARE_ERROR%0
//
#define PROXY_SUBST_SOFTWARE             0x4000F08AL

//
// MessageId: PROXY_SUBST_CONFIGURATION
//
// MessageText:
//
//  CONFIGURATION_ERROR%0
//
#define PROXY_SUBST_CONFIGURATION        0x4000F08BL

//
// MessageId: PROXY_SUBST_CONTENTION
//
// MessageText:
//
//  CONTENTION_ERROR%0
//
#define PROXY_SUBST_CONTENTION           0x4000F08CL

//
// MessageId: PROXY_SUBST_NOT_FOUND
//
// MessageText:
//
//  DLL_NOT_FOUND%0
//
#define PROXY_SUBST_NOT_FOUND            0x4000F08DL

//
// MessageId: PROXY_SUBST_
//
// MessageText:
//
//  OUT_OF_DISK_SPACE%0
//
#define PROXY_SUBST_                     0x4000F08EL

//
// MessageId: PROXY_SUBST_EXCEPTION
//
// MessageText:
//
//  EXCEPTION_ENCOUNTERED%0
//
#define PROXY_SUBST_EXCEPTION            0x4000F08FL

//
// MessageId: PROXY_SUBST_DEFAULT
//
// MessageText:
//
//  GENERAL_FAILURE%0
//
#define PROXY_SUBST_DEFAULT              0x4000F090L

//
// MessageId: PROXY_SUBST_INVALID
//
// MessageText:
//
//  PROXY_NOT_VALID%0
//
#define PROXY_SUBST_INVALID              0x4000F091L

//
// MessageId: PROXY_SUBST_NOT_UNIQUE
//
// MessageText:
//
//  PROXY_NOT_UNIQUE%0
//
#define PROXY_SUBST_NOT_UNIQUE           0x4000F092L

//
// MessageId: PROXY_SUBST_DUPLICATE
//
// MessageText:
//
//  DUPLICATE_PROXY_SPECIFIED%0
//
#define PROXY_SUBST_DUPLICATE            0x4000F093L

// -------------------     messages for OM Errors     ----------------------
// Messages w/ ID in range from 0xf100-0xf1ff are assumed to be OM problem descriptions
// used as substitutions into other event messages

//
// MessageId: XOM_ERRORS
//
// MessageText:
//
//  OM_ERRORS%0
//
#define XOM_ERRORS                       0x4000F100L

//
// MessageId: ENCODING_INVALID
//
// MessageText:
//
//  ENCODING_INVALID%0
//
#define ENCODING_INVALID                 0x4000F101L

//
// MessageId: FUNCTION_DECLINED
//
// MessageText:
//
//  FUNCTION_DECLINED%0
//
#define FUNCTION_DECLINED                0x4000F102L

//
// MessageId: FUNCTION_INTERRUPTED
//
// MessageText:
//
//  FUNCTION_INTERRUPTED%0
//
#define FUNCTION_INTERRUPTED             0x4000F103L

//
// MessageId: MEMORY_INSUFFICIENT
//
// MessageText:
//
//  MEMORY_INSUFFICIENT%0
//
#define MEMORY_INSUFFICIENT              0x4000F104L

//
// MessageId: NETWORK_ERROR
//
// MessageText:
//
//  NETWORK_ERROR%0
//
#define NETWORK_ERROR                    0x4000F105L

//
// MessageId: NO_SUCH_CLASS
//
// MessageText:
//
//  NO_SUCH_CLASS%0
//
#define NO_SUCH_CLASS                    0x4000F106L

//
// MessageId: NO_SUCH_EXCLUSION
//
// MessageText:
//
//  NO_SUCH_EXCLUSION%0
//
#define NO_SUCH_EXCLUSION                0x4000F107L

//
// MessageId: NO_SUCH_MODIFICATION
//
// MessageText:
//
//  NO_SUCH_MODIFICATION%0
//
#define NO_SUCH_MODIFICATION             0x4000F108L

//
// MessageId: NO_SUCH_RULES
//
// MessageText:
//
//  NO_SUCH_RULES%0
//
#define NO_SUCH_RULES                    0x4000F109L

//
// MessageId: NO_SUCH_SYNTAX
//
// MessageText:
//
//  NO_SUCH_SYNTAX%0
//
#define NO_SUCH_SYNTAX                   0x4000F10AL

//
// MessageId: NO_SUCH_TYPE
//
// MessageText:
//
//  NO_SUCH_TYPE%0
//
#define NO_SUCH_TYPE                     0x4000F10BL

//
// MessageId: NO_SUCH_WORKSPACE
//
// MessageText:
//
//  NO_SUCH_WORKSPACE%0
//
#define NO_SUCH_WORKSPACE                0x4000F10CL

//
// MessageId: NOT_AN_ENCODING
//
// MessageText:
//
//  NOT_AN_ENCODING%0
//
#define NOT_AN_ENCODING                  0x4000F10DL

//
// MessageId: NOT_CONCRETE
//
// MessageText:
//
//  NOT_CONCRETE%0
//
#define NOT_CONCRETE                     0x4000F10EL

//
// MessageId: NOT_PRESENT
//
// MessageText:
//
//  NOT_PRESENT%0
//
#define NOT_PRESENT                      0x4000F10FL

//
// MessageId: NOT_PRIVATE
//
// MessageText:
//
//  NOT_PRIVATE%0
//
#define NOT_PRIVATE                      0x4000F110L

//
// MessageId: NOT_THE_SERVICES
//
// MessageText:
//
//  NOT_THE_SERVICES%0
//
#define NOT_THE_SERVICES                 0x4000F111L

//
// MessageId: PERMANENT_ERROR
//
// MessageText:
//
//  PERMANENT_ERROR%0
//
#define PERMANENT_ERROR                  0x4000F112L

//
// MessageId: POINTER_INVALID
//
// MessageText:
//
//  POINTER_INVALID%0
//
#define POINTER_INVALID                  0x4000F113L

//
// MessageId: SYSTEM_ERROR
//
// MessageText:
//
//  SYSTEM_ERROR%0
//
#define SYSTEM_ERROR                     0x4000F114L

//
// MessageId: TEMPORARY_ERROR
//
// MessageText:
//
//  TEMPORARY_ERROR%0
//
#define TEMPORARY_ERROR                  0x4000F115L

//
// MessageId: TOO_MANY_VALUES
//
// MessageText:
//
//  TOO_MANY_VALUES%0
//
#define TOO_MANY_VALUES                  0x4000F116L

//
// MessageId: VALUES_NOT_ADJACENT
//
// MessageText:
//
//  VALUES_NOT_ADJACENT%0
//
#define VALUES_NOT_ADJACENT              0x4000F117L

//
// MessageId: WRONG_VALUE_LENGTH
//
// MessageText:
//
//  WRONG_VALUE_LENGTH%0
//
#define WRONG_VALUE_LENGTH               0x4000F118L

//
// MessageId: WRONG_VALUE_MAKEUP
//
// MessageText:
//
//  WRONG_VALUE_MAKEUP%0
//
#define WRONG_VALUE_MAKEUP               0x4000F119L

//
// MessageId: WRONG_VALUE_NUMBER
//
// MessageText:
//
//  WRONG_VALUE_NUMBER%0
//
#define WRONG_VALUE_NUMBER               0x4000F11AL

//
// MessageId: WRONG_VALUE_POSITION
//
// MessageText:
//
//  WRONG_VALUE_POSITION%0
//
#define WRONG_VALUE_POSITION             0x4000F11BL

//
// MessageId: WRONG_VALUE_SYNTAX
//
// MessageText:
//
//  WRONG_VALUE_SYNTAX%0
//
#define WRONG_VALUE_SYNTAX               0x4000F11CL

//
// MessageId: WRONG_VALUE_TYPE
//
// MessageText:
//
//  WRONG_VALUE_TYPE%0
//
#define WRONG_VALUE_TYPE                 0x4000F11DL

//
// MessageId: BEYOND_LAST_OM_ERROR
//
// MessageText:
//
//  one beyond the last XOM problem%0
//
#define BEYOND_LAST_OM_ERROR             0x4000F11EL

// -------------------     messages for DS errors     ----------------------
// Messages w/ ID in range from 0xf200-0xf2ff are assumed to be XDS problems

//
// MessageId: XDS_PROBLEMS
//
// MessageText:
//
//  DS_SUCCESS%0
//
#define XDS_PROBLEMS                     0x4000F200L

//
// MessageId: DS_PROBLEM_ADMIN_LIMIT_EXCEEDED
//
// MessageText:
//
//  The maximum number of administrative connections to the server has been exceeded. Try again later or connect to a different server.
//
#define DS_PROBLEM_ADMIN_LIMIT_EXCEEDED  0x4000F201L

//
// MessageId: DS_PROBLEM_AFFECTS_MULTIPLE_DSAS
//
// MessageText:
//
//  This change affects more than one directory.
//
#define DS_PROBLEM_AFFECTS_MULTIPLE_DSAS 0x4000F202L

//
// MessageId: DS_PROBLEM_ALIAS_DEREFERENCING_PROBLEM
//
// MessageText:
//
//  The object referenced by this alias is not available.
//
#define DS_PROBLEM_ALIAS_DEREFERENCING_PROBLEM 0x4000F203L

//
// MessageId: DS_PROBLEM_ALIAS_PROBLEM
//
// MessageText:
//
//  There is a problem with the object referenced by this alias.
//
#define DS_PROBLEM_ALIAS_PROBLEM         0x4000F204L

//
// MessageId: DS_PROBLEM_ATTRIBUTE_OR_VALUE_EXISTS
//
// MessageText:
//
//  An internal processing error has occurred: the attribute or value exists. Try restarting the application or the Microsoft Exchange Server computer, or both.
//
#define DS_PROBLEM_ATTRIBUTE_OR_VALUE_EXISTS 0x4000F205L

//
// MessageId: DS_PROBLEM_BAD_ARGUMENT
//
// MessageText:
//
//  An internal processing error has occurred: invalid argument. Try restarting the application or the Microsoft Exchange Server computer, or both.
//
#define DS_PROBLEM_BAD_ARGUMENT          0x4000F206L

//
// MessageId: DS_PROBLEM_BAD_CLASS
//
// MessageText:
//
//  An internal processing error has occurred: invalid object class. Try restarting the application or the Microsoft Exchange Server computer, or both.
//
#define DS_PROBLEM_BAD_CLASS             0x4000F207L

//
// MessageId: DS_PROBLEM_BAD_CONTEXT
//
// MessageText:
//
//  An internal processing error has occurred: invalid context. Try restarting the application or the Microsoft Exchange Server computer, or both.
//
#define DS_PROBLEM_BAD_CONTEXT           0x4000F208L

//
// MessageId: DS_PROBLEM_BAD_NAME
//
// MessageText:
//
//  An internal processing error has occurred: invalid name. Try restarting the application or the Microsoft Exchange Server computer, or both.
//
#define DS_PROBLEM_BAD_NAME              0x4000F209L

//
// MessageId: DS_PROBLEM_BAD_SESSION
//
// MessageText:
//
//  An internal processing error has occurred: invalid session. Try restarting the application or the Microsoft Exchange Server computer, or both.
//
#define DS_PROBLEM_BAD_SESSION           0x4000F20AL

//
// MessageId: DS_PROBLEM_BAD_WORKSPACE
//
// MessageText:
//
//  An internal processing error has occurred: invalid workspace. Try restarting the application or the Microsoft Exchange Server computer, or both.
//
#define DS_PROBLEM_BAD_WORKSPACE         0x4000F20BL

//
// MessageId: DS_PROBLEM_BUSY
//
// MessageText:
//
//  The directory is busy. Wait a few minutes and try again.
//
#define DS_PROBLEM_BUSY                  0x4000F20CL

//
// MessageId: DS_PROBLEM_CANNOT_ABANDON
//
// MessageText:
//
//  An internal processing error has occurred: cannot abandon the operation. Try restarting the application or the Microsoft Exchange Server computer, or both.
//
#define DS_PROBLEM_CANNOT_ABANDON        0x4000F20DL

//
// MessageId: DS_PROBLEM_CHAINING_REQUIRED
//
// MessageText:
//
//  You must make a connection to the Microsoft Exchange Server computer.
//
#define DS_PROBLEM_CHAINING_REQUIRED     0x4000F20EL

//
// MessageId: DS_PROBLEM_COMMUNICATIONS_PROBLEM
//
// MessageText:
//
//  The Microsoft Exchange Server computer does not respond.
//
#define DS_PROBLEM_COMMUNICATIONS_PROBLEM 0x4000F20FL

//
// MessageId: DS_PROBLEM_CONSTRAINT_VIOLATION
//
// MessageText:
//
//  The value specified for an attribute is either too big, too small, or not valid.
//
#define DS_PROBLEM_CONSTRAINT_VIOLATION  0x4000F210L

//
// MessageId: DS_PROBLEM_DIT_ERROR
//
// MessageText:
//
//  An internal processing error has occurred: directory information tree error. Try restarting the application or the Microsoft Exchange Server computer, or both.
//
#define DS_PROBLEM_DIT_ERROR             0x4000F211L

//
// MessageId: DS_PROBLEM_ENTRY_EXISTS
//
// MessageText:
//
//  This entry already exists. You can modify the existing entry.
//
#define DS_PROBLEM_ENTRY_EXISTS          0x4000F212L

//
// MessageId: DS_PROBLEM_INAPPROP_AUTHENTICATION
//
// MessageText:
//
//  An internal processing error has occurred: inappropriate authentication. Try restarting the application or the Microsoft Exchange Server computer, or both.
//
#define DS_PROBLEM_INAPPROP_AUTHENTICATION 0x4000F213L

//
// MessageId: DS_PROBLEM_INAPPROP_MATCHING
//
// MessageText:
//
//  An internal processing error has occurred: inappropriate matching. Try restarting the application or the Microsoft Exchange Server computer, or both.
//
#define DS_PROBLEM_INAPPROP_MATCHING     0x4000F214L

//
// MessageId: DS_PROBLEM_INSUFFICIENT_ACCESS_RIGHTS
//
// MessageText:
//
//  You do not have the permissions required to complete the operation.
//
#define DS_PROBLEM_INSUFFICIENT_ACCESS_RIGHTS 0x4000F215L

//
// MessageId: DS_PROBLEM_INVALID_ATTRIBUTE_SYNTAX
//
// MessageText:
//
//  An internal processing error has occurred: invalid attribute syntax. Try restarting the application or the Microsoft Exchange Server computer, or both.
//
#define DS_PROBLEM_INVALID_ATTRIBUTE_SYNTAX 0x4000F216L

//
// MessageId: DS_PROBLEM_INVALID_ATTRIBUTE_VALUE
//
// MessageText:
//
//  An internal processing error has occurred: invalid attribute value. Try restarting the application or the Microsoft Exchange Server computer, or both.
//
#define DS_PROBLEM_INVALID_ATTRIBUTE_VALUE 0x4000F217L

//
// MessageId: DS_PROBLEM_INVALID_CREDENTIALS
//
// MessageText:
//
//  An internal processing error has occurred: invalid credentials. Try restarting the application or the Microsoft Exchange Server computer, or both.
//
#define DS_PROBLEM_INVALID_CREDENTIALS   0x4000F218L

//
// MessageId: DS_PROBLEM_INVALID_REF
//
// MessageText:
//
//  An internal processing error has occurred: invalid reference. Try restarting the application or the Microsoft Exchange Server computer, or both.
//
#define DS_PROBLEM_INVALID_REF           0x4000F219L

//
// MessageId: DS_PROBLEM_INVALID_SIGNATURE
//
// MessageText:
//
//  An internal processing error has occurred: invalid object signature. Try restarting the application or the Microsoft Exchange Server computer, or both.
//
#define DS_PROBLEM_INVALID_SIGNATURE     0x4000F21AL

//
// MessageId: DS_PROBLEM_LOOP_DETECTED
//
// MessageText:
//
//  An internal processing error has occurred: loop detected. Try restarting the application or the Microsoft Exchange Server computer, or both.
//
#define DS_PROBLEM_LOOP_DETECTED         0x4000F21BL

//
// MessageId: DS_PROBLEM_MISCELLANEOUS
//
// MessageText:
//
//  An internal processing error has occurred: unknown directory error. Try restarting the application or the Microsoft Exchange Server computer, or both.
//
#define DS_PROBLEM_MISCELLANEOUS         0x4000F21CL

//
// MessageId: DS_PROBLEM_MISSING_TYPE
//
// MessageText:
//
//  An internal processing error has occurred: missing type. Try restarting the application or the Microsoft Exchange Server computer, or both.
//
#define DS_PROBLEM_MISSING_TYPE          0x4000F21DL

//
// MessageId: DS_PROBLEM_MIXED_SYNCHRONOUS
//
// MessageText:
//
//  The directory is currently performing a replication operation which prevents completion of this operation. Wait a few minutes and then try again.
//
#define DS_PROBLEM_MIXED_SYNCHRONOUS     0x4000F21EL

//
// MessageId: DS_PROBLEM_NAMING_VIOLATION
//
// MessageText:
//
//  An internal processing error has occurred: naming violation. Try restarting the application or the Microsoft Exchange Server computer, or both.
//
#define DS_PROBLEM_NAMING_VIOLATION      0x4000F21FL

//
// MessageId: DS_PROBLEM_NO_INFORMATION
//
// MessageText:
//
//  An internal processing error has occurred: required information is not available. Try restarting the application or the Microsoft Exchange Server computer, or both.
//
#define DS_PROBLEM_NO_INFORMATION        0x4000F220L

//
// MessageId: DS_PROBLEM_NO_SUCH_ATTRIBUTE_OR_VALUE
//
// MessageText:
//
//  The attribute does not exist.
//
#define DS_PROBLEM_NO_SUCH_ATTRIBUTE_OR_VALUE 0x4000F221L

//
// MessageId: DS_PROBLEM_NO_SUCH_OBJECT
//
// MessageText:
//
//  The object does not exist.
//
#define DS_PROBLEM_NO_SUCH_OBJECT        0x4000F222L

//
// MessageId: DS_PROBLEM_NO_SUCH_OPERATION
//
// MessageText:
//
//  An internal processing error has occurred: invalid operation. Try restarting the application or the Microsoft Exchange Server computer, or both.
//
#define DS_PROBLEM_NO_SUCH_OPERATION     0x4000F223L

//
// MessageId: DS_PROBLEM_NOT_ALLOWED_ON_NON_LEAF
//
// MessageText:
//
//  The operation is not valid on a non-leaf node.
//
#define DS_PROBLEM_NOT_ALLOWED_ON_NON_LEAF 0x4000F224L

//
// MessageId: DS_PROBLEM_NOT_ALLOWED_ON_RDN
//
// MessageText:
//
//  The operation is not allowed on a relative distinguished name.
//
#define DS_PROBLEM_NOT_ALLOWED_ON_RDN    0x4000F225L

//
// MessageId: DS_PROBLEM_NOT_SUPPORTED
//
// MessageText:
//
//  An internal processing error has occurred: operation is not supported. Try restarting the application or the Microsoft Exchange Server computer, or both.
//
#define DS_PROBLEM_NOT_SUPPORTED         0x4000F226L

//
// MessageId: DS_PROBLEM_OBJECT_CLASS_MOD_PROHIB
//
// MessageText:
//
//  An internal processing error has occurred: object classes cannot be modified. Try restarting the application or the Microsoft Exchange Server computer, or both.
//
#define DS_PROBLEM_OBJECT_CLASS_MOD_PROHIB 0x4000F227L

//
// MessageId: DS_PROBLEM_OBJECT_CLASS_VIOLATION
//
// MessageText:
//
//  An internal processing error has occurred: object class violation. Try restarting the application or the Microsoft Exchange Server computer, or both.
//
#define DS_PROBLEM_OBJECT_CLASS_VIOLATION 0x4000F228L

//
// MessageId: DS_PROBLEM_OUT_OF_SCOPE
//
// MessageText:
//
//  An internal processing error has occurred: out of scope. Try restarting the application or the Microsoft Exchange Server computer, or both.
//
#define DS_PROBLEM_OUT_OF_SCOPE          0x4000F229L

//
// MessageId: DS_PROBLEM_PROTECTION_REQUIRED
//
// MessageText:
//
//  An internal processing error has occurred: protection required. Try restarting the application or the Microsoft Exchange Server computer, or both.
//
#define DS_PROBLEM_PROTECTION_REQUIRED   0x4000F22AL

//
// MessageId: DS_PROBLEM_TIME_LIMIT_EXCEEDED
//
// MessageText:
//
//  An internal processing error has occurred: time limit exceeded. Try restarting the application or the Microsoft Exchange Server computer, or both.
//
#define DS_PROBLEM_TIME_LIMIT_EXCEEDED   0x4000F22BL

//
// MessageId: DS_PROBLEM_TOO_LATE
//
// MessageText:
//
//  An internal processing error has occurred: time exceeded. Try restarting the application or the Microsoft Exchange Server computer, or both.
//
#define DS_PROBLEM_TOO_LATE              0x4000F22CL

//
// MessageId: DS_PROBLEM_TOO_MANY_OPERATIONS
//
// MessageText:
//
//  The maximum number of operations has been reached.
//
#define DS_PROBLEM_TOO_MANY_OPERATIONS   0x4000F22DL

//
// MessageId: DS_PROBLEM_TOO_MANY_SESSIONS
//
// MessageText:
//
//  The maximum number of sessions has been reached.
//
#define DS_PROBLEM_TOO_MANY_SESSIONS     0x4000F22EL

//
// MessageId: DS_PROBLEM_UNABLE_TO_PROCEED
//
// MessageText:
//
//  An internal processing error has occurred: directory unable to proceed. Try restarting the application or the Microsoft Exchange Server computer, or both.
//
#define DS_PROBLEM_UNABLE_TO_PROCEED     0x4000F22FL

//
// MessageId: DS_PROBLEM_UNAVAILABLE
//
// MessageText:
//
//  An internal processing error has occurred: information not available. Try restarting the application or the Microsoft Exchange Server computer, or both.
//
#define DS_PROBLEM_UNAVAILABLE           0x4000F230L

//
// MessageId: DS_PROBLEM_UNAVAILABLE_CRIT_EXT
//
// MessageText:
//
//  An internal processing error has occurred: unavailable Crit. Ext. Try restarting the application or the Microsoft Exchange Server computer, or both.
//
#define DS_PROBLEM_UNAVAILABLE_CRIT_EXT  0x4000F231L

//
// MessageId: DS_PROBLEM_UNDEFINED_ATTRIBUTE_TYPE
//
// MessageText:
//
//  An internal processing error has occurred: undefined attribute type. Try restarting the application or the Microsoft Exchange Server computer, or both.
//
#define DS_PROBLEM_UNDEFINED_ATTRIBUTE_TYPE 0x4000F232L

//
// MessageId: DS_PROBLEM_UNWILLING_TO_PERFORM
//
// MessageText:
//
//  An internal processing error has occurred: cannot perform operation. Try restarting the application or the Microsoft Exchange Server computer, or both.
//
#define DS_PROBLEM_UNWILLING_TO_PERFORM  0x4000F233L

//
// MessageId: DS_PROBLEM_NOT_ON_CURRENT_SITE
//
// MessageText:
//
//  Changes cannot be written to this directory object. Try connecting to a Microsoft Exchange Server computer in the same site as this object.
//
#define DS_PROBLEM_NOT_ON_CURRENT_SITE   0x4000F234L

//
// MessageId: DS_FULL_DRIVE
//
// MessageText:
//
//  There is not enough space on the device.
//
#define DS_FULL_DRIVE                    0x4000F235L

//
// MessageId: DS_OUT_OF_MEMORY
//
// MessageText:
//
//  The server does not have enough memory.
//
#define DS_OUT_OF_MEMORY                 0x4000F236L

//
// MessageId: DS_SYSTEM_ERROR
//
// MessageText:
//
//  An internal processing error has occurred: system error. Try restarting the application or the Microsoft Exchange Server computer, or both.
//
#define DS_SYSTEM_ERROR                  0x4000F237L
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\dbdaoid.h ===
/************************************************************************
**	D B D A O I D . H													*
**																		*
**		History 														*
**		------- 														*
**	09-05-93   	peterdi		Creation 			 						*
**	09-17-93	wolfma		GUID's added								*
**																		*
**	OLE DAO component class id definitions								*
**	DAO has been allocated the GUID::Data1 range of 0x00025eXX			*
**																		*
*************************************************************************
** Copyright (C) 1992 and 1993 by Microsoft Corporation		 			*
**		   All Rights Reserved					 						*
** Information Contained Herein Is Proprietary and Confidential.	 	*
************************************************************************/

/*
	NOTES:

	*	Do not reuse the defunct GUIDs specified at the bottom of this file.

	*	All UNICODE OLE Automation interface IDs must be the same as the ANSI
		interface IDs with exception that Data1 is offset +1.
		(This is so that wide interfaces can be generated automatically)

	*	All UNICODE IID_... names must be the same as the ANSI IID_... name
		with a "W" appended to the end.

	(peterdi)

	*	For versions 3.5, 4.0 and beyond, DAO was assigned a new range of
		GUIDs for our use.  DEFINE-DAOGUID replaces the standard macro
		DEFINE-OLEGUID and applies the DAO base range to the id being
		defined.  DAO 3.5 has reserved 0x00000000 - 0x000000FF.  If more
		are needed they must not conflict with DAO 4.0's range which is
		based at 0x00000100.

	*	Since 3.5 uses a completely different base range I've dispensed
		with the list of defunct GUIDs from previous versions.  The list
		at the bottom of this file is now restriced to only defunct GUIDS
		for the 3.5 version.

	(markbue)


	*	The pre-3.5 GUIDs have been redefined with "30" added to the ID. For example:

			IID_IDAOIndex becomes IID30_IDAOIndex

		This way both the 30 and 3.5 GUIDs can be used at once (see bugs 1214, 1271) jcm 5/96
*/

// Because this file is consumed by an AWK script DO NOT use DEFINE_ OLEGUID or DEFINE_ DAOGUID
// in comments (change to DEFINE-OLEGUID or DEFINE-DAOGUID) - 1/97 jcm


// This is a gross little hack which allows VBA programmers access to context sensative help
// from within SQL strings -- click the help button on SELECT from a SQL string and it will
// jump to the help topic.  This has absolutely nothing to do with DAO and should be removed
// from our code.  But for now, we're hosting this poor little orphan so be nice and don't
// kick it out yet.... [mab June '96]
DEFINE_OLEGUID(LIBID_CJETSQLHELP,		0x00025f01, 0, 0);


// Define a local macro which will build GUIDS in the assigned DAO range.  We cannot
// use the standard DEFINE-OLEGUID macro because it assigns from a different base range
// than what we have been assigned.  [mab 9/27/95]
#define DEFINE_DAOGUID(name, l) \
    DEFINE_GUID(name, l, 0, 0x10, 0x80,0,0,0xAA,0,0x6D,0x2E,0xA4)


// Type library
DEFINE_OLEGUID(LIBID_CDAO,				0x00025e01, 0, 0);
DEFINE_OLEGUID(LIBID_CDAO25,			0x00025e04, 0, 0);

// Old BETA Type library IDs 
DEFINE_DAOGUID(BETA_LIBID_CDAO,				0x00000001);
DEFINE_DAOGUID(BETA_LIBID_CDAO25,			0x00000002);

// StdObject
DEFINE_DAOGUID(IID_IDAOStdObject,		0x0000000A);

// StdCollection
DEFINE_DAOGUID(IID_IDAOStdCollection,	0x0000000C);

// Creatable Classes
DEFINE_DAOGUID(CLSID_CDAODBEngine,		0x00000100);
DEFINE_DAOGUID(CLSID_CDAOPrivDBEngine,	0x00000101);
DEFINE_DAOGUID(CLSID_CDAOConnection,	0x00000102);
DEFINE_DAOGUID(CLSID_CDAOTableDef,		0x00000103);
DEFINE_DAOGUID(CLSID_CDAOField, 		0x00000104);
DEFINE_DAOGUID(CLSID_CDAOIndex, 		0x00000105);
DEFINE_DAOGUID(CLSID_CDAOGroup, 		0x00000106);
DEFINE_DAOGUID(CLSID_CDAOUser,			0x00000107);
DEFINE_DAOGUID(CLSID_CDAOQueryDef,		0x00000108);
DEFINE_DAOGUID(CLSID_CDAORelation,		0x00000109);

//DAO3.5 creatable objects
DEFINE_DAOGUID(CLSID35_CDAODBEngine,		0x00000010);
DEFINE_DAOGUID(CLSID35_CDAOPrivDBEngine,	0x00000011);
DEFINE_DAOGUID(CLSID35_CDAOConnection,	0x00000012);
DEFINE_DAOGUID(CLSID35_CDAOTableDef,		0x00000013);
DEFINE_DAOGUID(CLSID35_CDAOField, 		0x00000014);
DEFINE_DAOGUID(CLSID35_CDAOIndex, 		0x00000015);
DEFINE_DAOGUID(CLSID35_CDAOGroup, 		0x00000016);
DEFINE_DAOGUID(CLSID35_CDAOUser,			0x00000017);
DEFINE_DAOGUID(CLSID35_CDAOQueryDef,		0x00000018);
DEFINE_DAOGUID(CLSID35_CDAORelation,		0x00000019);

/*	Do not currently support creating these CDAO objects
 * CLSID_CDAOWorkspace
 * CLSID_CDAODatabase
 * CLSID_CDAORecordset
 * CLSID_CDAOParameter
 * CLSID_CDAOProperty
 * CLSID_CDAOContainer
 * CLSID_CDAODocument
 */

// DBEngine
DEFINE_DAOGUID(IID_IDAODBEngine,		0x00000020);
DEFINE_DAOGUID(IID_IDAODBEngineW,		0x00000021);

// Error
DEFINE_DAOGUID(IID_IDAOError,			0x00000022);
DEFINE_DAOGUID(IID_IDAOErrorW,			0x00000023);
DEFINE_DAOGUID(IID_IDAOErrors,			0x00000024);
DEFINE_DAOGUID(IID_IDAOErrorsW,			0x00000025);

// Property
DEFINE_DAOGUID(IID_IDAOProperty,		0x00000026);
DEFINE_DAOGUID(IID_IDAOPropertyW,		0x00000027);
DEFINE_DAOGUID(IID_IDAOProperties,		0x00000028);
DEFINE_DAOGUID(IID_IDAOPropertiesW,		0x00000029);

// Recordset
DEFINE_DAOGUID(IID_IDAORecordset,		0x00000030);
DEFINE_DAOGUID(IID_IDAORecordsetW,		0x00000031);
DEFINE_DAOGUID(IID_IDAORecordsets,		0x00000032);
DEFINE_DAOGUID(IID_IDAORecordsetsW,		0x00000033);
DEFINE_OLEGUID(IID_ICDAORecordset,		0x00025e31, 0, 0);	//same as it was in 3.0
//DEFINE-DAOGUID(IID_ICDAORecordset,		0x000000C0);
//DEFINE-DAOGUID(IID_ICRDORecordset,		0x000000C1);

// Workspace
DEFINE_DAOGUID(IID_IDAOWorkspace,		0x00000038);
DEFINE_DAOGUID(IID_IDAOWorkspaceW,		0x00000039);
DEFINE_DAOGUID(IID_IDAOWorkspaces,		0x0000003A);
DEFINE_DAOGUID(IID_IDAOWorkspacesW,		0x0000003B);

// Connection
DEFINE_DAOGUID(IID_IDAOConnection,		0x00000040);
DEFINE_DAOGUID(IID_IDAOConnectionW,		0x00000041);
DEFINE_DAOGUID(IID_IDAOConnections,		0x00000042);
DEFINE_DAOGUID(IID_IDAOConnectionsW,	0x00000043);

// TableDef
DEFINE_DAOGUID(IID_IDAOTableDef,		0x00000048);
DEFINE_DAOGUID(IID_IDAOTableDefW,		0x00000049);
DEFINE_DAOGUID(IID_IDAOTableDefs,		0x0000004A);
DEFINE_DAOGUID(IID_IDAOTableDefsW,		0x0000004B);

// Field
DEFINE_DAOGUID(IID_IDAOField,			0x00000050);
DEFINE_DAOGUID(IID_IDAOFieldW,			0x00000051);
DEFINE_DAOGUID(IID_IDAOFields,			0x00000052);
DEFINE_DAOGUID(IID_IDAOFieldsW,			0x00000053);

// Index
DEFINE_DAOGUID(IID_IDAOIndex,			0x00000058);
DEFINE_DAOGUID(IID_IDAOIndexW,			0x00000059);
DEFINE_DAOGUID(IID_IDAOIndexes,			0x0000005A);
DEFINE_DAOGUID(IID_IDAOIndexesW,		0x0000005B);
//UNDONE:  Can we get rid of this?  The Index Fields problem should
// be able to go away since 3.5 doesn't support 2.x syntaxes.
DEFINE_DAOGUID(IID_IDAOIndexFields,		0x0000005C);
DEFINE_DAOGUID(IID_IDAOIndexFieldsW,	0x0000005D);

// Group
DEFINE_DAOGUID(IID_IDAOGroup,			0x00000060);
DEFINE_DAOGUID(IID_IDAOGroupW,			0x00000061);
DEFINE_DAOGUID(IID_IDAOGroups,			0x00000062);
DEFINE_DAOGUID(IID_IDAOGroupsW,			0x00000063);

// User
DEFINE_DAOGUID(IID_IDAOUser,			0x00000068);
DEFINE_DAOGUID(IID_IDAOUserW,			0x00000069);
DEFINE_DAOGUID(IID_IDAOUsers,			0x0000006A);
DEFINE_DAOGUID(IID_IDAOUsersW,			0x0000006B);

// Database
DEFINE_DAOGUID(IID_IDAODatabase,		0x00000070);
DEFINE_DAOGUID(IID_IDAODatabaseW,		0x00000071);
DEFINE_DAOGUID(IID_IDAODatabases,		0x00000072);
DEFINE_DAOGUID(IID_IDAODatabasesW,		0x00000073);

// QueryDef
DEFINE_DAOGUID(IID_IDAOQueryDef,		0x00000078);
DEFINE_DAOGUID(IID_IDAOQueryDefW,		0x00000079);
DEFINE_DAOGUID(IID_IDAOQueryDefs,		0x0000007A);
DEFINE_DAOGUID(IID_IDAOQueryDefsW,		0x0000007B);

// Parameter
DEFINE_DAOGUID(IID_IDAOParameter,		0x00000080);
DEFINE_DAOGUID(IID_IDAOParameterW,		0x00000081);
DEFINE_DAOGUID(IID_IDAOParameters,		0x00000082);
DEFINE_DAOGUID(IID_IDAOParametersW,		0x00000083);

// Relation
DEFINE_DAOGUID(IID_IDAORelation,		0x00000088);
DEFINE_DAOGUID(IID_IDAORelationW,		0x00000089);
DEFINE_DAOGUID(IID_IDAORelations,		0x0000008A);
DEFINE_DAOGUID(IID_IDAORelationsW,		0x0000008B);

// Container
DEFINE_DAOGUID(IID_IDAOContainer,		0x00000090);
DEFINE_DAOGUID(IID_IDAOContainerW,		0x00000091);
DEFINE_DAOGUID(IID_IDAOContainers,		0x00000092);
DEFINE_DAOGUID(IID_IDAOContainersW,		0x00000093);

// Document
DEFINE_DAOGUID(IID_IDAODocument,		0x00000098);
DEFINE_DAOGUID(IID_IDAODocumentW,		0x00000099);
DEFINE_DAOGUID(IID_IDAODocuments,		0x0000009A);
DEFINE_DAOGUID(IID_IDAODocumentsW,		0x0000009B);

// Collections (how are these used?  mab 9/27/95)
DEFINE_DAOGUID(IID_IDAOCollection,		0x000000A0);
DEFINE_DAOGUID(IID_IDAODynaCollection,	0x000000A2);

// Connection points (how are these used?  mab 9/27/95)
DEFINE_DAOGUID(IID_IDAOQueryCP,			0x000000B0);	// Connection point
DEFINE_DAOGUID(IID_IDAOQueryAS,			0x000000B2);	// Advise sink interface

// A few private interfaces, mostly for use by Access.
DEFINE_DAOGUID(IID_ICDAOJETDBEngine,	0x000000A0);	//Access uses this.
DEFINE_DAOGUID(IID_ICDAOJETError,		0x000000A1);
DEFINE_DAOGUID(IID_ICDAOJETRecordset,	0x000000A2);
DEFINE_DAOGUID(IID_ICDAOJETWorkspace,	0x000000A3);
DEFINE_DAOGUID(IID_ICDAOJETField,		0x000000A4);
DEFINE_DAOGUID(IID_ICDAOJETDatabase,	0x000000A5);

//UNDONE:  These are defunct interfaces, not supported by DAO 3.4, so
// we should remove them completely.  For now, I'll just give them very
// large GUIDS in our assigned range.  [mab 9/27/95]

// Snapshot
DEFINE_DAOGUID(IID_IDAOSnapshot,		0x000000FD);

// Table
DEFINE_DAOGUID(IID_IDAOTable,			0x000000FE);

// Dynaset
DEFINE_DAOGUID(IID_IDAODynaset,			0x000000FF);

/**************************************
* Disconnect Interfaces
*
*	TODO:  Need confirmation from Dave Stutz
*/
DEFINE_GUID(IID_IDisconnect,	0xB196B288,0xBAB4,0x101A,0xB6,0x9C,0x00,0xAA,0x00,0x34,0x1D,0x07);
DEFINE_GUID(IID_IDisconnectAll,	0xB196B289,0xBAB4,0x101A,0xB6,0x9C,0x00,0xAA,0x00,0x34,0x1D,0x07);

/**************************************
* Data Source Control Interfaces
*
*	TODO:  Need to get these from VB!
*/
//UNDONE:  ? Why do we need to get these from vb?  They should
// be getting them from us shouldn't they?  I'll comment out the
// old GUIDs here but I'm changing them to the new range. [mab 9/27/95]
//DEFINE-OLEGUID(IID_IDSCAdviseSink,		0x00025EFEL, 0, 0);
//DEFINE-OLEGUID(IID_IDSCConnectionPoint,	0x00025EFFL, 0, 0);
DEFINE_DAOGUID(IID_IDSCAdviseSink,		0x000000E0);
DEFINE_DAOGUID(IID_IDSCConnectionPoint,	0x000000E2);

// Database connection points
DEFINE_DAOGUID(IID_IDBAdviseSink,		0x000000E8);
DEFINE_DAOGUID(IID_IDBConnectionPoint,	0x000000EA);

/* Defunct GUIDS!!!! Do not reuse!!!!
 * DAO versions 2.5 and 3.0 used DEFINE_OLEGUID to create guids in the
 * standard Microsoft OLE range.  We now have own private range and use
 * DEFINE-DAOGUID to generate them.  Rather list explicitly all the old
 * GUIDS for 2.5 and 3.0 we will simply declare that all GUIDS generated
 * by the standard DEFINE_OLEGUID with a Data1 value in the range of
 * 0x00025EF00 through 0x00025EFFF are hereby defunct.
 *
 * Listed below will be only the guids which have been retired from the
 * DEFINE-DAOGUID range.  [mab 9/27/95]
 */

// <There are no defunct guids yet.  Remeber to remove this comment when
// you do retire some guids!>



// Type library
DEFINE_OLEGUID(LIBID30_CDAO,				0x00025e01, 0, 0);
DEFINE_OLEGUID(LIBID30_CDAO25,			0x00025e04, 0, 0);

// StdObject
DEFINE_OLEGUID(IID30_IDAOStdObject,		0x00025e02, 0, 0);

// StdCollection
DEFINE_OLEGUID(IID30_IDAOStdCollection,	0x00025e03, 0, 0);

/*
	NOTES:

	* Two sets of CLSIDs exist for the DBEngine object.
	* DBEngine and DBEngine30.  The 30 extension means
	* that this engine should load the 3.0 typelibrary
	* from the registry.  Otherwise, load the 2.5/3.0
	* compatability type library

	(daxh)
*/

// DBEngine
DEFINE_OLEGUID(CLSID30_CDAODBEngine,		0x00025e15, 0, 0);
DEFINE_OLEGUID(IID30_IDAODBEngine,		0x00025e16, 0, 0);
DEFINE_OLEGUID(IID30_IDAODBEngineW,		0x00025e17, 0, 0);
DEFINE_OLEGUID(IID30_ICDAOJETDBEngine,	0x00025e18, 0, 0);
DEFINE_OLEGUID(CLSID30_CDAOPrivDBEngine,	0x00025e19, 0, 0);

// Error
DEFINE_OLEGUID(IID30_IDAOError,			0x00025e1d, 0, 0);
DEFINE_OLEGUID(IID30_IDAOErrorW,			0x00025e1e, 0, 0);
DEFINE_OLEGUID(IID30_IDAOErrors,			0x00025e1f, 0, 0);
DEFINE_OLEGUID(IID30_IDAOErrorsW,			0x00025e20, 0, 0);
DEFINE_OLEGUID(IID30_ICDAOJETError,		0x00025e21, 0, 0);	//used by Access, goes away post 3.0

// Property
DEFINE_OLEGUID(IID30_IDAOProperty,		0x00025e25, 0, 0);
DEFINE_OLEGUID(IID30_IDAOPropertyW,		0x00025e26, 0, 0);
DEFINE_OLEGUID(IID30_IDAOProperties,		0x00025e27, 0, 0);
DEFINE_OLEGUID(IID30_IDAOPropertiesW,		0x00025e28, 0, 0);

// Recordset
DEFINE_OLEGUID(IID30_IDAORecordset,		0x00025e2d, 0, 0);
DEFINE_OLEGUID(IID30_IDAORecordsetW,		0x00025e2e, 0, 0);
DEFINE_OLEGUID(IID30_IDAORecordsets,		0x00025e2f, 0, 0);
DEFINE_OLEGUID(IID30_IDAORecordsetsW,		0x00025e30, 0, 0);
DEFINE_OLEGUID(IID30_ICDAORecordset,		0x00025e31, 0, 0);	//NOTE: No change for 3.1 or 3.5
DEFINE_OLEGUID(IID30_ICDAOJETRecordset,	0x00025e32, 0, 0);

// Snapshot
DEFINE_OLEGUID(IID30_IDAOSnapshot,		0x00025e33, 0, 0);

// Table
DEFINE_OLEGUID(IID30_IDAOTable,			0x00025e34, 0, 0);

// Dynaset
DEFINE_OLEGUID(IID30_IDAODynaset,			0x00025e35, 0, 0);

// Workspace
DEFINE_OLEGUID(IID30_IDAOWorkspace,		0x00025e3a, 0, 0);
DEFINE_OLEGUID(IID30_IDAOWorkspaceW,		0x00025e3b, 0, 0);
DEFINE_OLEGUID(IID30_IDAOWorkspaces,		0x00025e3c, 0, 0);
DEFINE_OLEGUID(IID30_IDAOWorkspacesW,		0x00025e3d, 0, 0);
DEFINE_OLEGUID(IID30_ICDAOJETWorkspace,	0x00025e3e, 0, 0);

// Connection (new to 3.1)
DEFINE_OLEGUID(CLSID30_CDAOConnection,	0x00025eb1, 0, 0);
DEFINE_OLEGUID(IID30_IDAOConnection,		0x00025eb2, 0, 0);
DEFINE_OLEGUID(IID30_IDAOConnectionW,		0x00025eb3, 0, 0);
DEFINE_OLEGUID(IID30_IDAOConnections,		0x00025eb4, 0, 0);
DEFINE_OLEGUID(IID30_IDAOConnectionsW,	0x00025eb5, 0, 0);

// TableDef
DEFINE_OLEGUID(CLSID30_CDAOTableDef,		0x00025e43, 0, 0);
DEFINE_OLEGUID(IID30_IDAOTableDef,		0x00025e44, 0, 0);
DEFINE_OLEGUID(IID30_IDAOTableDefW,		0x00025e45, 0, 0);
DEFINE_OLEGUID(IID30_IDAOTableDefs,		0x00025e46, 0, 0);
DEFINE_OLEGUID(IID30_IDAOTableDefsW,		0x00025e47, 0, 0);

// Field
DEFINE_OLEGUID(CLSID30_CDAOField, 		0x00025e4c, 0, 0);
DEFINE_OLEGUID(IID30_IDAOField,			0x00025e4d, 0, 0);
DEFINE_OLEGUID(IID30_IDAOFieldW,			0x00025e4e, 0, 0);
DEFINE_OLEGUID(IID30_IDAOFields,			0x00025e4f, 0, 0);
DEFINE_OLEGUID(IID30_IDAOFieldsW,			0x00025e50, 0, 0);
//DEFINE-OLEGUID(IID30_ICDAOJETField,		0x00025e51, 0, 0);	//used by Access, goes away post 3.0
DEFINE_OLEGUID(IID30_ICDAOJETField,		0x00025e49, 0, 0);	//used by Access, goes away post 3.0

// Index
DEFINE_OLEGUID(CLSID30_CDAOIndex, 		0x00025e55, 0, 0);
DEFINE_OLEGUID(IID30_IDAOIndex,			0x00025e56, 0, 0);
DEFINE_OLEGUID(IID30_IDAOIndexW,			0x00025ed7, 0, 0);
DEFINE_OLEGUID(IID30_IDAOIndexes,			0x00025e58, 0, 0);
DEFINE_OLEGUID(IID30_IDAOIndexesW,		0x00025e59, 0, 0);
DEFINE_OLEGUID(IID30_IDAOIndexFields,		0x00025e5a, 0, 0);
DEFINE_OLEGUID(IID30_IDAOIndexFieldsW,	0x00025e5b, 0, 0);

// Group
DEFINE_OLEGUID(CLSID30_CDAOGroup, 		0x00025e5f, 0, 0);
DEFINE_OLEGUID(IID30_IDAOGroup,			0x00025e60, 0, 0);
DEFINE_OLEGUID(IID30_IDAOGroupW,			0x00025e61, 0, 0);
DEFINE_OLEGUID(IID30_IDAOGroups,			0x00025e62, 0, 0);
DEFINE_OLEGUID(IID30_IDAOGroupsW,			0x00025e63, 0, 0);

// User
DEFINE_OLEGUID(CLSID30_CDAOUser,			0x00025e68, 0, 0);
DEFINE_OLEGUID(IID30_IDAOUser,			0x00025e69, 0, 0);
DEFINE_OLEGUID(IID30_IDAOUserW,			0x00025e6a, 0, 0);
DEFINE_OLEGUID(IID30_IDAOUsers,			0x00025e6b, 0, 0);
DEFINE_OLEGUID(IID30_IDAOUsersW,			0x00025e6c, 0, 0);

// Database
DEFINE_OLEGUID(IID30_IDAODatabase,		0x00025e71, 0, 0);
DEFINE_OLEGUID(IID30_IDAODatabaseW,		0x00025e72, 0, 0);
DEFINE_OLEGUID(IID30_IDAODatabases,		0x00025e73, 0, 0);
DEFINE_OLEGUID(IID30_IDAODatabasesW,		0x00025e74, 0, 0);
DEFINE_OLEGUID(IID30_ICDAOJETDatabase,	0x00025e75, 0, 0);

// QueryDef
DEFINE_OLEGUID(CLSID30_CDAOQueryDef,		0x00025e7a, 0, 0);
DEFINE_OLEGUID(IID30_IDAOQueryDef,		0x00025e7b, 0, 0);
DEFINE_OLEGUID(IID30_IDAOQueryDefW,		0x00025e7c, 0, 0);
DEFINE_OLEGUID(IID30_IDAOQueryDefs,		0x00025e7d, 0, 0);
DEFINE_OLEGUID(IID30_IDAOQueryDefsW,		0x00025e7e, 0, 0);

// Parameter
DEFINE_OLEGUID(IID30_IDAOParameter,		0x00025e83, 0, 0);
DEFINE_OLEGUID(IID30_IDAOParameterW,		0x00025e84, 0, 0);
DEFINE_OLEGUID(IID30_IDAOParameters,		0x00025e85, 0, 0);
DEFINE_OLEGUID(IID30_IDAOParametersW,		0x00025e86, 0, 0);

// Relation
DEFINE_OLEGUID(CLSID30_CDAORelation,		0x00025e8b, 0, 0);
DEFINE_OLEGUID(IID30_IDAORelation,		0x00025e8c, 0, 0);
DEFINE_OLEGUID(IID30_IDAORelationW,		0x00025e8d, 0, 0);
DEFINE_OLEGUID(IID30_IDAORelations,		0x00025e8e, 0, 0);
DEFINE_OLEGUID(IID30_IDAORelationsW,		0x00025e8f, 0, 0);

// Container
DEFINE_OLEGUID(IID30_IDAOContainer,		0x00025e94, 0, 0);
DEFINE_OLEGUID(IID30_IDAOContainerW,		0x00025e95, 0, 0);
DEFINE_OLEGUID(IID30_IDAOContainers,		0x00025e96, 0, 0);
DEFINE_OLEGUID(IID30_IDAOContainersW,		0x00025e97, 0, 0);

// Document
DEFINE_OLEGUID(IID30_IDAODocument,		0x00025e9c, 0, 0);
DEFINE_OLEGUID(IID30_IDAODocumentW,		0x00025e9d, 0, 0);
DEFINE_OLEGUID(IID30_IDAODocuments,		0x00025e9e, 0, 0);
DEFINE_OLEGUID(IID30_IDAODocumentsW,		0x00025e9f, 0, 0);

// Collections
DEFINE_OLEGUID(IID30_IDAOCollection,		0x00025ea4, 0, 0);
DEFINE_OLEGUID(IID30_IDAODynaCollection,	0x00025ea5, 0, 0);

// Connection points
DEFINE_OLEGUID(IID30_IDAOQueryCP,			0x00025eaa, 0, 0);	// Connection point
DEFINE_OLEGUID(IID30_IDAOQueryAS,			0x00025eab, 0, 0);	// Advise sink interface

/**************************************
* Disconnect Interfaces
*
*	TODO:  Need confirmation from Dave Stutz
*/
DEFINE_GUID(IID30_IDisconnect,	0xB196B288,0xBAB4,0x101A,0xB6,0x9C,0x00,0xAA,0x00,0x34,0x1D,0x07);
DEFINE_GUID(IID30_IDisconnectAll,	0xB196B289,0xBAB4,0x101A,0xB6,0x9C,0x00,0xAA,0x00,0x34,0x1D,0x07);

/**************************************
* Data Source Control Interfaces
*
*	TODO:  Need to get these from VB!
*/
DEFINE_OLEGUID(IID30_IDSCAdviseSink,		0x00025EFEL, 0, 0);
DEFINE_OLEGUID(IID30_IDSCConnectionPoint,	0x00025EFFL, 0, 0);

// Database connection points
DEFINE_OLEGUID(IID30_IDBAdviseSink,		0x00025EFCL, 0, 0);
DEFINE_OLEGUID(IID30_IDBConnectionPoint,	0x00025EFDL, 0, 0);

/* Defunct GUIDS!!!! Do not reuse!!!!
*(LIBID_CDAO,    0x00025e00, 0, 0);
*(CLSID_CDAODBEngine,  0x00025e11, 0, 0);
*/

/*	Do not currently support creating these CDAO objects
*(CLSID_CDAOWorkspace,  0x00025exx, 0, 0);
*(CLSID_CDAODatabase,  0x00025exx, 0, 0);
*(CLSID_CDAORecordset,  0x00025exx, 0, 0);
*(CLSID_CDAOParameter,  0x00025exx, 0, 0);
*(CLSID_CDAOProperty,  0x00025exx, 0, 0);
*(CLSID_CDAOContainer,  0x00025exx, 0, 0);
*(CLSID_CDAODocument,  0x00025exx, 0, 0);
*/

/* OLD ids
*(CLSID_CDAODBEngineConfig,0x00025e10, 0, 0);
*(IID_IDAODBEngineConfig, 0x00025e30, 0, 0);
*(IID_DDAODBEngineConfig, 0x00025e50, 0, 0);
*/

/* Dispinterfaces no longer used
*(IID_DDAODynaset,   0x00025e66, 0, 0);
*(IID_DDAOTable,   0x00025e64, 0, 0);
*(IID_DDAOSnapshot,  0x00025e65, 0, 0);
*(IID_DDAORecordsets,  0x00025e6b, 0, 0);
*(IID_DDAORecordset,   0x00025e56, 0, 0);
*(IID_DDAOProperties,  0x00025e75, 0, 0);
*(IID_DDAOProperty,  0x00025e5d, 0, 0);
*(IID_DDAOErrors,   0x00025e63, 0, 0);
*(IID_DDAOError,   0x00025e62, 0, 0);
*(IID_DDAODBEngine,  0x00025e51, 0, 0);
*(IID_DDAOWorkspace,   0x00025e52, 0, 0);
*(IID_DDAODatabase,  0x00025e53, 0, 0);
*(IID_DDAOTableDef,  0x00025e54, 0, 0);
*(IID_DDAOQueryDef,  0x00025e55, 0, 0);
*(IID_DDAOField,    0x00025e57, 0, 0);
*(IID_DDAOIndex,    0x00025e58, 0, 0);
*(IID_DDAOParameter,   0x00025e59, 0, 0);
*(IID_DDAOUser,   0x00025e5a, 0, 0);
*(IID_DDAOGroup,    0x00025e5b, 0, 0);
*(IID_DDAORelation,  0x00025e5c, 0, 0);
*(IID_DDAOContainer,   0x00025e5e, 0, 0);
*(IID_DDAODocument,  0x00025e5f, 0, 0);
*(IID_DDAOCollection,  0x00025e60, 0, 0);
*(IID_DDAODynaCollection, 0x00025e61, 0, 0);
*(IID_DDAOWorkspaces,  0x00025e67, 0, 0);
*(IID_DDAODatabases,  0x00025e68, 0, 0);
*(IID_DDAOTableDefs,  0x00025e69, 0, 0);
*(IID_DDAOQueryDefs,  0x00025e6a, 0, 0);
*(IID_DDAOFields,   0x00025e6c, 0, 0);
*(IID_DDAOIndexFields,  0x00025e6d, 0, 0);
*(IID_DDAOIndexes,   0x00025e6e, 0, 0);
*(IID_DDAOParameters,  0x00025e6f, 0, 0);
*(IID_DDAOUsers,   0x00025e70, 0, 0);
*(IID_DDAOGroups,   0x00025e71, 0, 0);
*(IID_DDAORelations,  0x00025e72, 0, 0);
*(IID_DDAOContainers,  0x00025e73, 0, 0);
*(IID_DDAODocuments,  0x00025e74, 0, 0);
*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\db2oledb.h ===
/*
    db2oledb.h
    Constant values for the Microsoft OLE DB Provider for DB2
    Version 05.00 (DBPROP_PROVIDERVER)
    Copyright (c) 1998, Microsoft Corporation.  All rights reserved.
*/

#ifndef __db2oledb_h__
#define __db2oledb_h__

#ifdef _DB2OLEDB_

extern const OLEDBDECLSPEC  CLSID CLSID_DB2ErrorLookup = {0x0DC5D5B6,0x21CB,0x11d2,{0x9C,0x5B,0x00,0x60,0xB0,0x3C,0x55,0x95}};;

extern const OLEDBDECLSPEC CLSID CLSID_DB2OLEDB = {0x0DC5D5B5,0x21CB,0x11d2,{0x9C,0x5B,0x00,0x60,0xB0,0x3C,0x55,0x95}};

extern const OLEDBDECLSPEC IID DB2OLEDB_DBPROPSET_DBINIT = { 0xd5a7c608, 0x37f8, 0x11d2, { 0x84, 0xf3, 0x0, 0x0, 0xf8, 0x7a, 0x53, 0xf8 }};

extern const OLEDBDECLSPEC CLSID CLSID_ConnPage = {0xD518F731,0x1EA9,0x11D3,{0xA6,0xE7,0x00,0x80,0xC7,0x1B,0x80,0x71}};

extern const OLEDBDECLSPEC CLSID CLSID_AdvPage = {0xF859C891,0x1EA9,0x11D3,{0xA6,0xE7,0x00,0x80,0xC7,0x1B,0x80,0x71}};

#endif
////////////////////////////////////////////////////////////////////////////////
// DB2OLEDB_DBPROPSET_DBINIT property enumeration


enum SNAOLEDB_DBPROPENUM
{
	DBPROP_DB2OLEDB_REMOTELU	= 0x02,         /* APPC Remote LU Alias. For SNA NETTYPE. */
	DBPROP_DB2OLEDB_LOCALLU		= 0x03,         /* APPC Local LU Alias. For SNA NETTYPE. */
	DBPROP_DB2OLEDB_APPCMODE	= 0x04,         /* APPC Mode Name. For SNA NETTYPE. */
	DBPROP_DB2OLEDB_NETTYPE		= 0x05,         /* Network Transport Library "SNA" or "TCPIP" */
	DBPROP_DB2OLEDB_HOSTCCSID	= 0x06,         /* Host CCSID. See Host Integration Server docs for supported values. */
	DBPROP_DB2OLEDB_PCCODEPAGE	= 0x07,         /* PC Code Page. See Host Integration Server docs for supported values. */
    DBPROP_DB2OLEDB_NETADDRESS  = 0x08,         /* Network Address. For TCPIP NETTYPE.  IP address or hostname */
    DBPROP_DB2OLEDB_NETPORT     = 0x09,         /* Network Port. For TCPIP NETTYPE. */

	DBPROP_DB2OLEDB_PACKAGECOL	= 0x30,         /* Package Collection */
	DBPROP_DB2OLEDB_CATALOGCOL	= 0x31,         /* Default Schema */
	DBPROP_DB2OLEDB_TPNAME		= 0x33,         /* Alternate TP Name. For SNA NETTYPE. */
	DBPROP_DB2OLEDB_UNITSOFWORK	= 0x36,         /* Units of Work */

	DBPROP_DB2OLEDB_BINASCHAR	= 0xa1,         /* Process Binary as Character */
};

/* Native Error Codes: */
#define DB2OLEDB_ERROR                      -1
#define DB2OLEDB_ERROR_SEND                 -2
#define DB2OLEDB_ERROR_RECEIVE              -3
#define DB2OLEDB_INVALID_POINTER            -4
#define DB2OLEDB_INVALID_PARAM              -5
#define DB2OLEDB_INVALID_DATA               -6
#define DB2OLEDB_INVALID_CONVERSION         -7
#define DB2OLEDB_INVALID_USER               -8
#define DB2OLEDB_ERROR_WRITE                -9
#define DB2OLEDB_ERROR_READ                 -10
#define DB2OLEDB_FILE_NOT_FOUND             -11
#define DB2OLEDB_INDEX_NOT_FOUND            -12
#define DB2OLEDB_RECORD_NOT_FOUND           -13
#define DB2OLEDB_KEY_NOT_FOUND              -14
#define DB2OLEDB_INVALID_FORMAT             -15
#define DB2OLEDB_MAX_CONNECTIONS            -16
#define DB2OLEDB_NOT_CONNECTED              -17
#define DB2OLEDB_NETWORK_ERROR              -18
#define DB2OLEDB_INVALID_DATASOURCE         -19
#define DB2OLEDB_ACCESS_DENIED              -20
#define DB2OLEDB_FILE_NOT_OPENED            -21
#define DB2OLEDB_MEMORY_ALLOC               -22
#define DB2OLEDB_DATA_NOT_FOUND             -23
#define DB2OLEDB_INDEX_EXISTS               -24
#define DB2OLEDB_FUNCTION_NOT_SUPPORTED     -25
#define DB2OLEDB_NO_CACHE                   -26
#define DB2OLEDB_FILE_LENGTH                -27
#define DB2OLEDB_INVALID_CONN_ID            -28
#define DB2OLEDB_INVALID_FILE_ID            -29
#define DB2OLEDB_INVALID_FILENAME           -30
#define DB2OLEDB_LOCAL_FILE_ERROR           -31
#define DB2OLEDB_INVALID_VIEW_ID            -32
#define DB2OLEDB_INVALID_VIEW               -33
#define DB2OLEDB_DISK_FULL                  -34
#define DB2OLEDB_DEST_FILE_CHANGED          -35
#define DB2OLEDB_FTX_FAILED                 -36
#define DB2OLEDB_FTX_ABORTED_BY_HOST        -37
#define DB2OLEDB_CONNECTION_LOST            -38
#define DB2OLEDB_CONNECTION_BUSY            -39
#define DB2OLEDB_HOST_NOT_RESPONDING        -40
#define DB2OLEDB_INVALID_DATA_CONV          -41
#define DB2OLEDB_DATA_TYPE_NOT_SUPPORTED    -42
#define DB2OLEDB_TIMEOUT                    -43
#define DB2OLEDB_DDMAGENT_NOT_LOADED        -44
#define DB2OLEDB_COMPONENT_MISSING          -45
#define DB2OLEDB_DCONV_DLL_NOT_FOUND        -46
#define DB2OLEDB_INVALID_STMT_HANDLE        -47
#define DB2OLEDB_VALUE_NOT_SUPPORTED        -48
#define DB2OLEDB_INTERNAL_ERROR             -50
#define DB2OLEDB_TOO_MANY_STATEMENTS        -51
#define DB2OLEDB_ENLIST_NO_XLN              -52  /* DTC hr = 0x8004D108 */
#define DB2OLEDB_ENLIST_DUP_TRAN            -53  /* DTC hr = 0x8004D10B */
#define DB2OLEDB_ENLIST_LU_BUSY             -54  /* DTC hr = 0x8004D10C */
#define DB2OLEDB_ENLIST_NO_RESYNCSVC        -55  /* DTC hr = 0x8004D10D */
#define DB2OLEDB_ENLIST_LU_DOWN             -56  /* DTC hr = 0x8004D10E, or D10A */
#define DB2OLEDB_ENLIST_LU_RECOVERING       -57  /* DTC hr = 0x8004D10F */
#define DB2OLEDB_ENLIST_XLN_MISMATCH        -58  /* DTC hr = 0x8004D110 */
#define DB2OLEDB_DTC_INIT_FAIL              -59  /* TP_START prc = AP_CANT_CONTACT_DTC */
#define DB2OLEDB_DUW_UNPROTECTED            -60  /* cfg = DUW, but no Enlist */
#define DB2OLEDB_SQL_ERROR                  -99
/* 
    DDM originated error codes
    The last segment of the constant identifier is the DDM Code Point name returned from the host
    Refer to IBM Publication: SC21-9526 DDM Architecture Reference
*/
#define DB2OLEDB_DDM_ERROR_START    -256
#define DB2OLEDB_DDM_ABNUOWRM    	(DB2OLEDB_DDM_ERROR_START-0)        /* -256 */
#define DB2OLEDB_DDM_ACCATHRM    	(DB2OLEDB_DDM_ERROR_START-1) 
#define DB2OLEDB_DDM_ACCINTRM    	(DB2OLEDB_DDM_ERROR_START-2) 
#define DB2OLEDB_DDM_ACCMTHRM    	(DB2OLEDB_DDM_ERROR_START-3) 
#define DB2OLEDB_DDM_ACCRDBRM    	(DB2OLEDB_DDM_ERROR_START-4) 
#define DB2OLEDB_DDM_AGNPRMRM    	(DB2OLEDB_DDM_ERROR_START-5) 
#define DB2OLEDB_DDM_BASNAMRM    	(DB2OLEDB_DDM_ERROR_START-6) 
#define DB2OLEDB_DDM_BGNBNDRM    	(DB2OLEDB_DDM_ERROR_START-7) 
#define DB2OLEDB_DDM_CHGFATRM    	(DB2OLEDB_DDM_ERROR_START-8) 
#define DB2OLEDB_DDM_CLSDMGRM    	(DB2OLEDB_DDM_ERROR_START-9) 
#define DB2OLEDB_DDM_CMBACCAM    	(DB2OLEDB_DDM_ERROR_START-10)       /* -266 */
#define DB2OLEDB_DDM_CMBKEYAM    	(DB2OLEDB_DDM_ERROR_START-11) 
#define DB2OLEDB_DDM_CMBRNBAM    	(DB2OLEDB_DDM_ERROR_START-12) 
#define DB2OLEDB_DDM_CMDATHRM    	(DB2OLEDB_DDM_ERROR_START-13) 
#define DB2OLEDB_DDM_CMDCHKRM    	(DB2OLEDB_DDM_ERROR_START-14) 
#define DB2OLEDB_DDM_CMDCMPRM    	(DB2OLEDB_DDM_ERROR_START-15) 
#define DB2OLEDB_DDM_CMDNSPRM    	(DB2OLEDB_DDM_ERROR_START-16) 
#define DB2OLEDB_DDM_CMDVLTRM    	(DB2OLEDB_DDM_ERROR_START-17) 
#define DB2OLEDB_DDM_CMMRQSRM    	(DB2OLEDB_DDM_ERROR_START-18) 
#define DB2OLEDB_DDM_CSRNSARM    	(DB2OLEDB_DDM_ERROR_START-19) 
#define DB2OLEDB_DDM_DCLCNFRM    	(DB2OLEDB_DDM_ERROR_START-20)       /* -276 */
#define DB2OLEDB_DDM_DCLNAMRM    	(DB2OLEDB_DDM_ERROR_START-21) 
#define DB2OLEDB_DDM_DCLNFNRM    	(DB2OLEDB_DDM_ERROR_START-22) 
#define DB2OLEDB_DDM_DRCATHRM    	(DB2OLEDB_DDM_ERROR_START-23) 
#define DB2OLEDB_DDM_DRCDMGRM    	(DB2OLEDB_DDM_ERROR_START-24) 
#define DB2OLEDB_DDM_DRCENTRM    	(DB2OLEDB_DDM_ERROR_START-25) 
#define DB2OLEDB_DDM_DRCFULRM    	(DB2OLEDB_DDM_ERROR_START-26) 
#define DB2OLEDB_DDM_DRCIUSRM    	(DB2OLEDB_DDM_ERROR_START-27) 
#define DB2OLEDB_DDM_DRCNAMRM    	(DB2OLEDB_DDM_ERROR_START-28) 
#define DB2OLEDB_DDM_DRCNEMRM    	(DB2OLEDB_DDM_ERROR_START-29) 
#define DB2OLEDB_DDM_DRCNFNRM    	(DB2OLEDB_DDM_ERROR_START-30)       /* -286 */
#define DB2OLEDB_DDM_DRCSNARM    	(DB2OLEDB_DDM_ERROR_START-31) 
#define DB2OLEDB_DDM_DRCSUBRM    	(DB2OLEDB_DDM_ERROR_START-32) 
#define DB2OLEDB_DDM_DRCTNARM    	(DB2OLEDB_DDM_ERROR_START-33) 
#define DB2OLEDB_DDM_DSCINVRM    	(DB2OLEDB_DDM_ERROR_START-34) 
#define DB2OLEDB_DDM_DTAMAPRM    	(DB2OLEDB_DDM_ERROR_START-35) 
#define DB2OLEDB_DDM_DTAMCHRM    	(DB2OLEDB_DDM_ERROR_START-36) 
#define DB2OLEDB_DDM_DTANFNRM    	(DB2OLEDB_DDM_ERROR_START-37) 
#define DB2OLEDB_DDM_DTARECRM    	(DB2OLEDB_DDM_ERROR_START-38) 
#define DB2OLEDB_DDM_DUPDCLRM    	(DB2OLEDB_DDM_ERROR_START-39) 
#define DB2OLEDB_DDM_DUPDRCRM    	(DB2OLEDB_DDM_ERROR_START-40)       /* -296 */
#define DB2OLEDB_DDM_DUPFILRM    	(DB2OLEDB_DDM_ERROR_START-41) 
#define DB2OLEDB_DDM_DUPKDIRM    	(DB2OLEDB_DDM_ERROR_START-42) 
#define DB2OLEDB_DDM_DUPKSIRM    	(DB2OLEDB_DDM_ERROR_START-43) 
#define DB2OLEDB_DDM_DUPQUERM    	(DB2OLEDB_DDM_ERROR_START-44) 
#define DB2OLEDB_DDM_DUPRNBRM    	(DB2OLEDB_DDM_ERROR_START-45) 
#define DB2OLEDB_DDM_ENDFILRM    	(DB2OLEDB_DDM_ERROR_START-46) 
#define DB2OLEDB_DDM_ENDQRYRM    	(DB2OLEDB_DDM_ERROR_START-47) 
#define DB2OLEDB_DDM_ENDUOWRM    	(DB2OLEDB_DDM_ERROR_START-48) 
#define DB2OLEDB_DDM_EXSCNDRM    	(DB2OLEDB_DDM_ERROR_START-49) 
#define DB2OLEDB_DDM_FILATHRM    	(DB2OLEDB_DDM_ERROR_START-50)       /* -306 */
#define DB2OLEDB_DDM_FILDMGRM    	(DB2OLEDB_DDM_ERROR_START-51) 
#define DB2OLEDB_DDM_FILFULRM    	(DB2OLEDB_DDM_ERROR_START-52) 
#define DB2OLEDB_DDM_FILIUSRM    	(DB2OLEDB_DDM_ERROR_START-53) 
#define DB2OLEDB_DDM_FILNAMRM    	(DB2OLEDB_DDM_ERROR_START-54) 
#define DB2OLEDB_DDM_FILNFNRM    	(DB2OLEDB_DDM_ERROR_START-55) 
#define DB2OLEDB_DDM_FILNOPRM    	(DB2OLEDB_DDM_ERROR_START-56) 
#define DB2OLEDB_DDM_FILOLORM    	(DB2OLEDB_DDM_ERROR_START-57) 
#define DB2OLEDB_DDM_FILSNARM    	(DB2OLEDB_DDM_ERROR_START-58) 
#define DB2OLEDB_DDM_FILTNARM    	(DB2OLEDB_DDM_ERROR_START-59) 
#define DB2OLEDB_DDM_INTATHRM    	(DB2OLEDB_DDM_ERROR_START-60)       /* -316 */
#define DB2OLEDB_DDM_INTTKNRM    	(DB2OLEDB_DDM_ERROR_START-61) 
#define DB2OLEDB_DDM_INVRQSRM    	(DB2OLEDB_DDM_ERROR_START-62) 
#define DB2OLEDB_DDM_INVUSRRM    	(DB2OLEDB_DDM_ERROR_START-63) 
#define DB2OLEDB_DDM_KEYDEFRM    	(DB2OLEDB_DDM_ERROR_START-64) 
#define DB2OLEDB_DDM_KEYLENRM    	(DB2OLEDB_DDM_ERROR_START-65) 
#define DB2OLEDB_DDM_KEYMODRM    	(DB2OLEDB_DDM_ERROR_START-66) 
#define DB2OLEDB_DDM_KEYUDIRM    	(DB2OLEDB_DDM_ERROR_START-67) 
#define DB2OLEDB_DDM_KEYUSIRM    	(DB2OLEDB_DDM_ERROR_START-68) 
#define DB2OLEDB_DDM_KEYVALRM    	(DB2OLEDB_DDM_ERROR_START-69) 
#define DB2OLEDB_DDM_LODSTRRM    	(DB2OLEDB_DDM_ERROR_START-70)       /* -326 */
#define DB2OLEDB_DDM_MGMATHRM    	(DB2OLEDB_DDM_ERROR_START-71) 
#define DB2OLEDB_DDM_MGMCLSNM    	(DB2OLEDB_DDM_ERROR_START-72) 
#define DB2OLEDB_DDM_MGMCNFRM    	(DB2OLEDB_DDM_ERROR_START-73) 
#define DB2OLEDB_DDM_MGMNFNRM    	(DB2OLEDB_DDM_ERROR_START-74) 
#define DB2OLEDB_DDM_MGRDEPRM    	(DB2OLEDB_DDM_ERROR_START-75) 
#define DB2OLEDB_DDM_MGRLVLRM    	(DB2OLEDB_DDM_ERROR_START-76) 
#define DB2OLEDB_DDM_NEWDRNRM    	(DB2OLEDB_DDM_ERROR_START-77) 
#define DB2OLEDB_DDM_NEWNAMRM    	(DB2OLEDB_DDM_ERROR_START-78) 
#define DB2OLEDB_DDM_OBJNSPRM    	(DB2OLEDB_DDM_ERROR_START-79) 
#define DB2OLEDB_DDM_OPNCNFRM    	(DB2OLEDB_DDM_ERROR_START-80)       /* -336 */
#define DB2OLEDB_DDM_OPNEXCRM    	(DB2OLEDB_DDM_ERROR_START-81) 
#define DB2OLEDB_DDM_OPNMAXRM    	(DB2OLEDB_DDM_ERROR_START-82) 
#define DB2OLEDB_DDM_OPNQFLRM    	(DB2OLEDB_DDM_ERROR_START-83) 
#define DB2OLEDB_DDM_OPNQRYRM    	(DB2OLEDB_DDM_ERROR_START-84) 
#define DB2OLEDB_DDM_PKGBNARM    	(DB2OLEDB_DDM_ERROR_START-85) 
#define DB2OLEDB_DDM_PKGBPARM    	(DB2OLEDB_DDM_ERROR_START-86) 
#define DB2OLEDB_DDM_PRCCNVRM    	(DB2OLEDB_DDM_ERROR_START-87) 
#define DB2OLEDB_DDM_PRMNSPRM    	(DB2OLEDB_DDM_ERROR_START-88) 
#define DB2OLEDB_DDM_QRYNOPRM    	(DB2OLEDB_DDM_ERROR_START-89) 
#define DB2OLEDB_DDM_QRYPOPRM    	(DB2OLEDB_DDM_ERROR_START-90)       /* -346 */
#define DB2OLEDB_DDM_QUEATHRM    	(DB2OLEDB_DDM_ERROR_START-91) 
#define DB2OLEDB_DDM_QUEDMGRM    	(DB2OLEDB_DDM_ERROR_START-92) 
#define DB2OLEDB_DDM_QUEFULRM    	(DB2OLEDB_DDM_ERROR_START-93) 
#define DB2OLEDB_DDM_QUEIUSRM    	(DB2OLEDB_DDM_ERROR_START-94) 
#define DB2OLEDB_DDM_QUELENRM    	(DB2OLEDB_DDM_ERROR_START-95) 
#define DB2OLEDB_DDM_QUENAMRM    	(DB2OLEDB_DDM_ERROR_START-96) 
#define DB2OLEDB_DDM_QUENFNRM    	(DB2OLEDB_DDM_ERROR_START-97) 
#define DB2OLEDB_DDM_QUETNARM    	(DB2OLEDB_DDM_ERROR_START-98) 
#define DB2OLEDB_DDM_QUEVANRM    	(DB2OLEDB_DDM_ERROR_START-99) 
#define DB2OLEDB_DDM_RDBACCRM    	(DB2OLEDB_DDM_ERROR_START-100)      /* -356 */
#define DB2OLEDB_DDM_RDBAFLRM    	(DB2OLEDB_DDM_ERROR_START-101) 
#define DB2OLEDB_DDM_RDBATHRM    	(DB2OLEDB_DDM_ERROR_START-102) 
#define DB2OLEDB_DDM_RDBNACRM    	(DB2OLEDB_DDM_ERROR_START-103) 
#define DB2OLEDB_DDM_RDBNFNRM    	(DB2OLEDB_DDM_ERROR_START-104) 
#define DB2OLEDB_DDM_RDBUPDRM    	(DB2OLEDB_DDM_ERROR_START-105) 
#define DB2OLEDB_DDM_RECCNTRM    	(DB2OLEDB_DDM_ERROR_START-106) 
#define DB2OLEDB_DDM_RECDMGRM    	(DB2OLEDB_DDM_ERROR_START-107) 
#define DB2OLEDB_DDM_RECINARM    	(DB2OLEDB_DDM_ERROR_START-108) 
#define DB2OLEDB_DDM_RECIUSRM    	(DB2OLEDB_DDM_ERROR_START-109) 
#define DB2OLEDB_DDM_RECLENRM    	(DB2OLEDB_DDM_ERROR_START-110)      /* -366 */
#define DB2OLEDB_DDM_RECNAVRM    	(DB2OLEDB_DDM_ERROR_START-111) 
#define DB2OLEDB_DDM_RECNBRRM    	(DB2OLEDB_DDM_ERROR_START-112) 
#define DB2OLEDB_DDM_RECNFNRM    	(DB2OLEDB_DDM_ERROR_START-113) 
#define DB2OLEDB_DDM_RSCLMTRM    	(DB2OLEDB_DDM_ERROR_START-114) 
#define DB2OLEDB_DDM_SHDEXSRM    	(DB2OLEDB_DDM_ERROR_START-115) 
#define DB2OLEDB_DDM_SQLERRRM    	(DB2OLEDB_DDM_ERROR_START-116) 
#define DB2OLEDB_DDM_STGATHRM    	(DB2OLEDB_DDM_ERROR_START-117) 
#define DB2OLEDB_DDM_STGNFNRM    	(DB2OLEDB_DDM_ERROR_START-118) 
#define DB2OLEDB_DDM_STPCMPRM    	(DB2OLEDB_DDM_ERROR_START-119) 
#define DB2OLEDB_DDM_STRDMGRM    	(DB2OLEDB_DDM_ERROR_START-120)      /* -376 */
#define DB2OLEDB_DDM_STRIUSRM    	(DB2OLEDB_DDM_ERROR_START-121) 
#define DB2OLEDB_DDM_SUBSTRRM    	(DB2OLEDB_DDM_ERROR_START-122) 
#define DB2OLEDB_DDM_SYNTAXRM    	(DB2OLEDB_DDM_ERROR_START-123) 
#define DB2OLEDB_DDM_SYSCMDRM    	(DB2OLEDB_DDM_ERROR_START-124) 
#define DB2OLEDB_DDM_TRGNSPRM    	(DB2OLEDB_DDM_ERROR_START-125) 
#define DB2OLEDB_DDM_UPDCSRRM    	(DB2OLEDB_DDM_ERROR_START-126) 
#define DB2OLEDB_DDM_UPDINTRM    	(DB2OLEDB_DDM_ERROR_START-127) 
#define DB2OLEDB_DDM_USRATTRM    	(DB2OLEDB_DDM_ERROR_START-128) 
#define DB2OLEDB_DDM_VALNSPRM    	(DB2OLEDB_DDM_ERROR_START-129) 
#define DB2OLEDB_DDM_DFTRECRM       (DB2OLEDB_DDM_ERROR_START-130)      /* -386 */
#define DB2OLEDB_DDM_STGCNFRM       (DB2OLEDB_DDM_ERROR_START-131)

/*
    DB2OLEDB Communications Error Codes.
    Refer to Microsoft Host Integration Server SDK Documentation: APPC Programmer's Guide.
    Some error codes are related to TCP/IP communications.
*/ 
#define DB2OLEDB_COMM_ERROR_START                   -512
#define DB2OLEDB_COMM_PARAMETER_CHECK               (DB2OLEDB_COMM_ERROR_START)         /* APPC Errors: */
#define DB2OLEDB_COMM_BAD_TP_ID                     (DB2OLEDB_COMM_ERROR_START-1)
#define DB2OLEDB_COMM_BAD_CONV_ID                   (DB2OLEDB_COMM_ERROR_START-2)
#define DB2OLEDB_COMM_BAD_LU_ALIAS                  (DB2OLEDB_COMM_ERROR_START-3)
#define DB2OLEDB_COMM_INVALID_DATA_SEGMENT          (DB2OLEDB_COMM_ERROR_START-4)
#define DB2OLEDB_COMM_BAD_CONV_TYPE                 (DB2OLEDB_COMM_ERROR_START-5)
#define DB2OLEDB_COMM_BAD_SYNC_LEVEL                (DB2OLEDB_COMM_ERROR_START-6)
#define DB2OLEDB_COMM_BAD_SECURITY                  (DB2OLEDB_COMM_ERROR_START-7)
#define DB2OLEDB_COMM_BAD_RETURN_CONTROL            (DB2OLEDB_COMM_ERROR_START-8)       /* -520 */
#define DB2OLEDB_COMM_PIP_LEN_INCORRECT             (DB2OLEDB_COMM_ERROR_START-9)
#define DB2OLEDB_COMM_NO_USE_OF_SNASVCMG            (DB2OLEDB_COMM_ERROR_START-10)
#define DB2OLEDB_COMM_UNKNOWN_PARTNER_MODE          (DB2OLEDB_COMM_ERROR_START-11)
#define DB2OLEDB_COMM_CONFIRM_ON_SYNC_LEVEL_NONE    (DB2OLEDB_COMM_ERROR_START-12)
#define DB2OLEDB_COMM_DEALLOC_BAD_TYPE              (DB2OLEDB_COMM_ERROR_START-13)
#define DB2OLEDB_COMM_DEALLOC_LOG_LL_WRONG          (DB2OLEDB_COMM_ERROR_START-14)
#define DB2OLEDB_COMM_P_TO_R_INVALID_TYPE           (DB2OLEDB_COMM_ERROR_START-15)
#define DB2OLEDB_COMM_RCV_AND_WAIT_BAD_FILL         (DB2OLEDB_COMM_ERROR_START-16)
#define DB2OLEDB_COMM_RCV_IMMD_BAD_FILL             (DB2OLEDB_COMM_ERROR_START-17)
#define DB2OLEDB_COMM_RCV_AND_POST_BAD_FILL         (DB2OLEDB_COMM_ERROR_START-18)      /* -530 */
#define DB2OLEDB_COMM_INVALID_SEMAPHORE_HANDLE      (DB2OLEDB_COMM_ERROR_START-19)
#define DB2OLEDB_COMM_BAD_RETURN_STATUS_WITH_DATA   (DB2OLEDB_COMM_ERROR_START-20)
#define DB2OLEDB_COMM_BAD_LL                        (DB2OLEDB_COMM_ERROR_START-21)
#define DB2OLEDB_COMM_SEND_DATA_INVALID_TYPE        (DB2OLEDB_COMM_ERROR_START-22)
#define DB2OLEDB_COMM_INVALID_SESSION_ID            (DB2OLEDB_COMM_ERROR_START-23)
#define DB2OLEDB_COMM_SEND_DATA_CONFIRM_SYNC_NONE   (DB2OLEDB_COMM_ERROR_START-24)
#define DB2OLEDB_COMM_BAD_PARTNER_LU_ALIAS          (DB2OLEDB_COMM_ERROR_START-25) 
#define DB2OLEDB_COMM_SEND_ERROR_LOG_LL_WRONG       (DB2OLEDB_COMM_ERROR_START-26)
#define DB2OLEDB_COMM_SEND_ERROR_BAD_TYPE           (DB2OLEDB_COMM_ERROR_START-27) 
#define DB2OLEDB_COMM_BAD_ERROR_DIRECTION           (DB2OLEDB_COMM_ERROR_START-28)      /* -540 */
#define DB2OLEDB_COMM_TOO_MANY_TPS                  (DB2OLEDB_COMM_ERROR_START-29) 
#define DB2OLEDB_COMM_BAD_TYPE                      (DB2OLEDB_COMM_ERROR_START-30) 
#define DB2OLEDB_COMM_UNDEFINED_TP_NAME             (DB2OLEDB_COMM_ERROR_START-31) 

#define DB2OLEDB_COMM_STATE_CHECK                   (DB2OLEDB_COMM_ERROR_START-32)
#define DB2OLEDB_COMM_CONFIRM_BAD_STATE             (DB2OLEDB_COMM_ERROR_START-33)
#define DB2OLEDB_COMM_CONFIRM_NOT_LL_BDY            (DB2OLEDB_COMM_ERROR_START-34)
#define DB2OLEDB_COMM_CONFIRMED_BAD_STATE           (DB2OLEDB_COMM_ERROR_START-35)
#define DB2OLEDB_COMM_DEALLOC_FLUSH_BAD_STATE       (DB2OLEDB_COMM_ERROR_START-36)
#define DB2OLEDB_COMM_DEALLOC_CONFIRM_BAD_STATE     (DB2OLEDB_COMM_ERROR_START-37)
#define DB2OLEDB_COMM_DEALLOC_NOT_LL_BDY            (DB2OLEDB_COMM_ERROR_START-38)      /* -550 */
#define DB2OLEDB_COMM_FLUSH_NOT_SEND_STATE          (DB2OLEDB_COMM_ERROR_START-39)
#define DB2OLEDB_COMM_P_TO_R_NOT_LL_BDY             (DB2OLEDB_COMM_ERROR_START-40)
#define DB2OLEDB_COMM_P_TO_R_NOT_SEND_STATE         (DB2OLEDB_COMM_ERROR_START-41)
#define DB2OLEDB_COMM_RCV_AND_WAIT_BAD_STATE        (DB2OLEDB_COMM_ERROR_START-42)
#define DB2OLEDB_COMM_RCV_AND_WAIT_NOT_LL_BDY       (DB2OLEDB_COMM_ERROR_START-43)
#define DB2OLEDB_COMM_RCV_IMMD_BAD_STATE            (DB2OLEDB_COMM_ERROR_START-44)
#define DB2OLEDB_COMM_RCV_AND_POST_BAD_STATE        (DB2OLEDB_COMM_ERROR_START-45)
#define DB2OLEDB_COMM_RCV_AND_POST_NOT_LL_BDY       (DB2OLEDB_COMM_ERROR_START-46)
#define DB2OLEDB_COMM_R_T_S_BAD_STATE               (DB2OLEDB_COMM_ERROR_START-47)
#define DB2OLEDB_COMM_SEND_DATA_NOT_SEND_STATE      (DB2OLEDB_COMM_ERROR_START-48)      /* -560 */
#define DB2OLEDB_COMM_SEND_DATA_NOT_LL_BDY          (DB2OLEDB_COMM_ERROR_START-49)
#define DB2OLEDB_COMM_ATTACH_MANAGER_INACTIVE       (DB2OLEDB_COMM_ERROR_START-50)
#define DB2OLEDB_COMM_ALLOCATE_NOT_PENDING          (DB2OLEDB_COMM_ERROR_START-51)
#define DB2OLEDB_COMM_INVALID_PROCESS               (DB2OLEDB_COMM_ERROR_START-52)

#define DB2OLEDB_COMM_ALLOCATION_ERROR              (DB2OLEDB_COMM_ERROR_START-53)
#define DB2OLEDB_COMM_ALLOCATION_FAILURE_NO_RETRY   (DB2OLEDB_COMM_ERROR_START-54)
#define DB2OLEDB_COMM_ALLOCATION_FAILURE_RETRY      (DB2OLEDB_COMM_ERROR_START-55)
#define DB2OLEDB_COMM_SECURITY_NOT_VALID            (DB2OLEDB_COMM_ERROR_START-56)
#define DB2OLEDB_COMM_TRANS_PGM_NOT_AVAIL_RETRY     (DB2OLEDB_COMM_ERROR_START-57)
#define DB2OLEDB_COMM_TRANS_PGM_NOT_AVAIL_NO_RETRY  (DB2OLEDB_COMM_ERROR_START-58)      /* -570 */
#define DB2OLEDB_COMM_TP_NAME_NOT_RECOGNIZED        (DB2OLEDB_COMM_ERROR_START-59)
#define DB2OLEDB_COMM_PIP_NOT_ALLOWED               (DB2OLEDB_COMM_ERROR_START-60)
#define DB2OLEDB_COMM_PIP_NOT_SPECIFIED_CORRECTLY   (DB2OLEDB_COMM_ERROR_START-61)
#define DB2OLEDB_COMM_CONVERSATION_TYPE_MISMATCH    (DB2OLEDB_COMM_ERROR_START-62)
#define DB2OLEDB_COMM_SYNC_LEVEL_NOT_SUPPORTED      (DB2OLEDB_COMM_ERROR_START-63)

#define DB2OLEDB_COMM_DEALLOC_ABEND                 (DB2OLEDB_COMM_ERROR_START-64)
#define DB2OLEDB_COMM_DEALLOC_ABEND_PROG            (DB2OLEDB_COMM_ERROR_START-65)
#define DB2OLEDB_COMM_DEALLOC_ABEND_SVC             (DB2OLEDB_COMM_ERROR_START-66)
#define DB2OLEDB_COMM_DEALLOC_ABEND_TIMER           (DB2OLEDB_COMM_ERROR_START-67)
#define DB2OLEDB_COMM_DEALLOC_NORMAL                (DB2OLEDB_COMM_ERROR_START-68)      /* -580 */
#define DB2OLEDB_COMM_PROG_ERROR_NO_TRUNC           (DB2OLEDB_COMM_ERROR_START-69)
#define DB2OLEDB_COMM_PROG_ERROR_TRUNC              (DB2OLEDB_COMM_ERROR_START-70)
#define DB2OLEDB_COMM_PROG_ERROR_PURGING            (DB2OLEDB_COMM_ERROR_START-71)
#define DB2OLEDB_COMM_CONV_FAILURE_RETRY            (DB2OLEDB_COMM_ERROR_START-72)
#define DB2OLEDB_COMM_CONV_FAILURE_NO_RETRY         (DB2OLEDB_COMM_ERROR_START-73)
#define DB2OLEDB_COMM_SVC_ERROR_NO_TRUNC            (DB2OLEDB_COMM_ERROR_START-74)
#define DB2OLEDB_COMM_SVC_ERROR_TRUNC               (DB2OLEDB_COMM_ERROR_START-75)
#define DB2OLEDB_COMM_SVC_ERROR_PURGING             (DB2OLEDB_COMM_ERROR_START-76)
#define DB2OLEDB_COMM_UNSUCCESSFUL                  (DB2OLEDB_COMM_ERROR_START-77)
#define DB2OLEDB_COMM_CONVERSATION_TYPE_MIXED       (DB2OLEDB_COMM_ERROR_START-78)      /* -590 */
#define DB2OLEDB_COMM_CANCELLED                     (DB2OLEDB_COMM_ERROR_START-79)
#define DB2OLEDB_COMM_SECURITY_REQ_NOT_SUPPORTED    (DB2OLEDB_COMM_ERROR_START-80)
#define DB2OLEDB_COMM_TP_BUSY                       (DB2OLEDB_COMM_ERROR_START-81)      
#define DB2OLEDB_COMM_COMM_SUBSYSTEM_ABENDED        (DB2OLEDB_COMM_ERROR_START-82)      
#define DB2OLEDB_COMM_COMM_SUBSYSTEM_NOT_LOADED     (DB2OLEDB_COMM_ERROR_START-83)      
#define DB2OLEDB_COMM_CONV_BUSY                     (DB2OLEDB_COMM_ERROR_START-84)     
#define DB2OLEDB_COMM_THREAD_BLOCKING               (DB2OLEDB_COMM_ERROR_START-85)     
#define DB2OLEDB_COMM_INVALID_VERB_SEGMENT          (DB2OLEDB_COMM_ERROR_START-86)      
#define DB2OLEDB_COMM_UNEXPECTED_DOS_ERROR          (DB2OLEDB_COMM_ERROR_START-87)      
#define DB2OLEDB_COMM_STACK_TOO_SMALL               (DB2OLEDB_COMM_ERROR_START-88)      /* -600 */
#define DB2OLEDB_COMM_INVALID_VERB                  (DB2OLEDB_COMM_ERROR_START-89)
#define DB2OLEDB_COMM_HOST_NAMERESOLV_FAILED        (DB2OLEDB_COMM_ERROR_START-90)      /* TCP/IP Errors: */
#define DB2OLEDB_COMM_HOST_CONNECT_FAILED           (DB2OLEDB_COMM_ERROR_START-91)
#define DB2OLEDB_COMM_SOCKET_ALLOC_FAILED           (DB2OLEDB_COMM_ERROR_START-92)


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\dbdaoint.h ===
/************************************************************************ 
**	D B D A O I N T. H													*
**																		*
************************************************************************* 
** Copyright (C) 1995 by Microsoft Corporation		 					*
**		   All Rights Reserved					 						*
************************************************************************/ 
/*
 DBDAOINT.H
 OLE DAO Interface.  
This is a part of the Microsoft Data Access Objects SDK library.
See the dao*.hlp files for detailed information regarding the
Microsoft Data Access Objects SDK product.
 
*/
#ifndef _DBDAOINT_H_
#define _DBDAOINT_H_

#ifndef _INC_TCHAR
#include <tchar.h>
#endif

// Constants

typedef enum RecordsetTypeEnum {
    dbOpenTable = 1,
    dbOpenDynaset = 2,
    dbOpenSnapshot = 4,
    dbOpenForwardOnly = 8,
    dbOpenDynamic = 16
} RecordsetTypeEnum;

typedef enum EditModeEnum {
    dbEditNone = 0,
    dbEditInProgress = 1,
    dbEditAdd = 2,
    dbEditChanged = 4,
    dbEditDeleted = 8,
    dbEditNew = 16
} EditModeEnum;

typedef enum RecordsetOptionEnum {
    dbDenyWrite = 1,
    dbDenyRead = 2,
    dbReadOnly = 4,
    dbAppendOnly = 8,
    dbInconsistent = 16,
    dbConsistent = 32,
    dbSQLPassThrough = 64,
    dbFailOnError = 128,
    dbForwardOnly = 256,
    dbSeeChanges = 512,
    dbRunAsync = 1024,
    dbExecDirect = 2048
} RecordsetOptionEnum;

typedef enum LockTypeEnum {
    dbPessimistic = 2,
    dbOptimistic = 3,
    dbOptimisticValue = 1,
    dbOptimisticBatch = 5
} LockTypeEnum;

typedef enum UpdateCriteriaEnum {
    dbCriteriaKey = 1,
    dbCriteriaModValues = 2,
    dbCriteriaAllCols = 4,
    dbCriteriaTimestamp = 8,
    dbCriteriaDeleteInsert = 16,
    dbCriteriaUpdate = 32
} UpdateCriteriaEnum;

typedef enum FieldAttributeEnum {
    dbFixedField = 1,
    dbVariableField = 2,
    dbAutoIncrField = 16,
    dbUpdatableField = 32,
    dbSystemField = 8192,
    dbHyperlinkField = 32768,
    dbDescending = 1
} FieldAttributeEnum;

typedef enum DataTypeEnum {
    dbBoolean = 1,
    dbByte = 2,
    dbInteger = 3,
    dbLong = 4,
    dbCurrency = 5,
    dbSingle = 6,
    dbDouble = 7,
    dbDate = 8,
    dbBinary = 9,
    dbText = 10,
    dbLongBinary = 11,
    dbMemo = 12,
    dbGUID = 15,
    dbBigInt = 16,
    dbVarBinary = 17,
    dbChar = 18,
    dbNumeric = 19,
    dbDecimal = 20,
    dbFloat = 21,
    dbTime = 22,
    dbTimeStamp = 23
} DataTypeEnum;

typedef enum RelationAttributeEnum {
    dbRelationUnique = 1,
    dbRelationDontEnforce = 2,
    dbRelationInherited = 4,
    dbRelationUpdateCascade = 256,
    dbRelationDeleteCascade = 4096,
    dbRelationLeft = 16777216,
    dbRelationRight = 33554432
} RelationAttributeEnum;

typedef enum TableDefAttributeEnum {
    dbAttachExclusive = 65536,
    dbAttachSavePWD = 131072,
    dbSystemObject = -2147483646,
    dbAttachedTable = 1073741824,
    dbAttachedODBC = 536870912,
    dbHiddenObject = 1
} TableDefAttributeEnum;

typedef enum QueryDefTypeEnum {
    dbQSelect = 0,
    dbQProcedure = 224,
    dbQAction = 240,
    dbQCrosstab = 16,
    dbQDelete = 32,
    dbQUpdate = 48,
    dbQAppend = 64,
    dbQMakeTable = 80,
    dbQDDL = 96,
    dbQSQLPassThrough = 112,
    dbQSetOperation = 128,
    dbQSPTBulk = 144,
    dbQCompound = 160
} QueryDefTypeEnum;

typedef enum QueryDefStateEnum {
    dbQPrepare = 1,
    dbQUnprepare = 2
} QueryDefStateEnum;

typedef enum DatabaseTypeEnum {
    dbVersion10 = 1,
    dbEncrypt = 2,
    dbDecrypt = 4,
    dbVersion11 = 8,
    dbVersion20 = 16,
    dbVersion30 = 32
} DatabaseTypeEnum;

typedef enum CollatingOrderEnum {
    dbSortNeutral = 1024,
    dbSortArabic = 1025,
    dbSortCyrillic = 1049,
    dbSortCzech = 1029,
    dbSortDutch = 1043,
    dbSortGeneral = 1033,
    dbSortGreek = 1032,
    dbSortHebrew = 1037,
    dbSortHungarian = 1038,
    dbSortIcelandic = 1039,
    dbSortNorwdan = 1030,
    dbSortPDXIntl = 1033,
    dbSortPDXNor = 1030,
    dbSortPDXSwe = 1053,
    dbSortPolish = 1045,
    dbSortSpanish = 1034,
    dbSortSwedFin = 1053,
    dbSortTurkish = 1055,
    dbSortJapanese = 1041,
    dbSortChineseSimplified = 2052,
    dbSortChineseTraditional = 1028,
    dbSortKorean = 1042,
    dbSortThai = 1054,
    dbSortSlovenian = 1060,
    dbSortUndefined = -1
} CollatingOrderEnum;

typedef enum IdleEnum {
    dbFreeLocks = 1,
    dbRefreshCache = 8
} IdleEnum;

typedef enum PermissionEnum {
    dbSecNoAccess = 0,
    dbSecFullAccess = 1048575,
    dbSecDelete = 65536,
    dbSecReadSec = 131072,
    dbSecWriteSec = 262144,
    dbSecWriteOwner = 524288,
    dbSecDBCreate = 1,
    dbSecDBOpen = 2,
    dbSecDBExclusive = 4,
    dbSecDBAdmin = 8,
    dbSecCreate = 1,
    dbSecReadDef = 4,
    dbSecWriteDef = 65548,
    dbSecRetrieveData = 20,
    dbSecInsertData = 32,
    dbSecReplaceData = 64,
    dbSecDeleteData = 128
} PermissionEnum;

typedef enum SynchronizeTypeEnum {
    dbRepExportChanges = 1,
    dbRepImportChanges = 2,
    dbRepImpExpChanges = 4,
    dbRepSyncInternet = 16
} SynchronizeTypeEnum;

typedef enum ReplicaTypeEnum {
    dbRepMakeReadOnly = 2,
    dbRepMakePartial = 1
} ReplicaTypeEnum;

typedef enum WorkspaceTypeEnum {
    dbUseODBC = 1,
    dbUseJet = 2
} WorkspaceTypeEnum;

typedef enum CursorDriverEnum {
    dbUseDefaultCursor = -1,
    dbUseODBCCursor = 1,
    dbUseServerCursor = 2,
    dbUseClientBatchCursor = 3,
    dbUseNoCursor = 4
} CursorDriverEnum;

typedef enum DriverPromptEnum {
    dbDriverPrompt = 2,
    dbDriverNoPrompt = 1,
    dbDriverComplete = 0,
    dbDriverCompleteRequired = 3
} DriverPromptEnum;

typedef enum SetOptionEnum {
    dbPageTimeout = 6,
    dbLockRetry = 57,
    dbMaxBufferSize = 8,
    dbUserCommitSync = 58,
    dbImplicitCommitSync = 59,
    dbExclusiveAsyncDelay = 60,
    dbSharedAsyncDelay = 61,
    dbMaxLocksPerFile = 62,
    dbLockDelay = 63,
    dbRecycleLVs = 65,
    dbFlushTransactionTimeout = 66
} SetOptionEnum;

typedef enum ParameterDirectionEnum {
    dbParamInput = 1,
    dbParamOutput = 2,
    dbParamInputOutput = 3,
    dbParamReturnValue = 4
} ParameterDirectionEnum;

typedef enum UpdateTypeEnum {
    dbUpdateBatch = 4,
    dbUpdateRegular = 1,
    dbUpdateCurrentRecord = 2
} UpdateTypeEnum;

typedef enum RecordStatusEnum {
    dbRecordUnmodified = 0,
    dbRecordModified = 1,
    dbRecordNew = 2,
    dbRecordDeleted = 3,
    dbRecordDBDeleted = 4
} RecordStatusEnum;

typedef enum CommitTransOptionsEnum {
    dbForceOSFlush = 1
} CommitTransOptionsEnum;

typedef enum _DAOSuppHelp {
    LogMessages = 0,
    KeepLocal = 0,
    Replicable = 0,
    ReplicableBool = 0,
    V1xNullBehavior = 0
} _DAOSuppHelp;




	const TCHAR dbLangArabic[] = _T(";LANGID=0x0401;CP=1256;COUNTRY=0";);
	const TCHAR dbLangCzech[] = _T(";LANGID=0x0405;CP=1250;COUNTRY=0";);
	const TCHAR dbLangDutch[] = _T(";LANGID=0x0413;CP=1252;COUNTRY=0";);
	const TCHAR dbLangGeneral[] = _T(";LANGID=0x0409;CP=1252;COUNTRY=0";);
	const TCHAR dbLangGreek[] = _T(";LANGID=0x0408;CP=1253;COUNTRY=0";);
	const TCHAR dbLangHebrew[] = _T(";LANGID=0x040D;CP=1255;COUNTRY=0";);
	const TCHAR dbLangHungarian[] = _T(";LANGID=0x040E;CP=1250;COUNTRY=0";);
	const TCHAR dbLangIcelandic[] = _T(";LANGID=0x040F;CP=1252;COUNTRY=0";);
	const TCHAR dbLangNordic[] = _T(";LANGID=0x041D;CP=1252;COUNTRY=0";);
	const TCHAR dbLangNorwDan[] = _T(";LANGID=0x0414;CP=1252;COUNTRY=0";);
	const TCHAR dbLangPolish[] = _T(";LANGID=0x0415;CP=1250;COUNTRY=0";);
	const TCHAR dbLangCyrillic[] = _T(";LANGID=0x0419;CP=1251;COUNTRY=0";);
	const TCHAR dbLangSpanish[] = _T(";LANGID=0x040A;CP=1252;COUNTRY=0";);
	const TCHAR dbLangSwedFin[] = _T(";LANGID=0x040B;CP=1252;COUNTRY=0";);
	const TCHAR dbLangTurkish[] = _T(";LANGID=0x041F;CP=1254;COUNTRY=0";);
	const TCHAR dbLangJapanese[] = _T(";LANGID=0x0411;CP=932;COUNTRY=0";);
	const TCHAR dbLangChineseSimplified[] = _T(";LANGID=0x0804;CP=936;COUNTRY=0";);
	const TCHAR dbLangChineseTraditional[] = _T(";LANGID=0x0404;CP=950;COUNTRY=0";);
	const TCHAR dbLangKorean[] = _T(";LANGID=0x0412;CP=949;COUNTRY=0";);
	const TCHAR dbLangThai[] = _T(";LANGID=0x041E;CP=874;COUNTRY=0";);
	const TCHAR dbLangSlovenian[] = _T(";LANGID=0x0424;CP=1250;COUNTRY=0";);
// Forwards
#define DAODBEngine _DAODBEngine
interface _DAODBEngine;
interface DAOError;
interface DAOErrors;
interface DAOProperty;
interface DAOProperties;
interface DAOWorkspace;
interface DAOWorkspaces;
interface DAOConnection;
interface DAOConnections;
interface DAODatabase;
interface DAODatabases;
#define DAOTableDef _DAOTableDef
interface _DAOTableDef;
interface DAOTableDefs;
#define DAOQueryDef _DAOQueryDef
interface _DAOQueryDef;
interface DAOQueryDefs;
interface DAORecordset;
interface DAORecordsets;
#define DAOField _DAOField
interface _DAOField;
interface DAOFields;
#define DAOIndex _DAOIndex
interface _DAOIndex;
interface DAOIndexes;
interface DAOParameter;
interface DAOParameters;
#define DAOUser _DAOUser
interface _DAOUser;
interface DAOUsers;
#define DAOGroup _DAOGroup
interface _DAOGroup;
interface DAOGroups;
#define DAORelation _DAORelation
interface _DAORelation;
interface DAORelations;
interface DAOContainer;
interface DAOContainers;
interface DAODocument;
interface DAODocuments;


// Interface: _DAOCollection
#undef INTERFACE
#define INTERFACE _DAOCollection
DECLARE_INTERFACE_(_DAOCollection, IDispatch)
	{
	STDMETHOD(get_Count)						 (THIS_ short FAR* c) PURE;
	STDMETHOD(_NewEnum)							 (THIS_ IUnknown * FAR* ppunk) PURE;
	STDMETHOD(Refresh)							 (THIS) PURE;
	};

// Interface: _DAODynaCollection
#undef INTERFACE
#define INTERFACE _DAODynaCollection
DECLARE_INTERFACE_(_DAODynaCollection, _DAOCollection)
	{
	STDMETHOD(Append)							 (THIS_ IDispatch * Object) PURE;
	STDMETHOD(Delete)							 (THIS_ BSTR Name) PURE;
	};

// Interface: _DAO
#undef INTERFACE
#define INTERFACE _DAO
DECLARE_INTERFACE_(_DAO, IDispatch)
	{
	STDMETHOD(get_Properties)					 (THIS_ DAOProperties FAR* FAR* ppprops) PURE;
	};

// Interface: _DAODBEngine
#undef INTERFACE
#define INTERFACE _DAODBEngine
DECLARE_INTERFACE_(_DAODBEngine, _DAO)
	{
	STDMETHOD(get_Version)						 (THIS_ BSTR FAR* pbstr) PURE;
	STDMETHOD(get_IniPath)						 (THIS_ BSTR FAR* pbstr) PURE;
	STDMETHOD(put_IniPath)						 (THIS_ BSTR path) PURE;
	STDMETHOD(put_DefaultUser)					 (THIS_ BSTR user) PURE;
	STDMETHOD(put_DefaultPassword)				 (THIS_ BSTR pw) PURE;
	STDMETHOD(get_LoginTimeout)					 (THIS_ short FAR* ps) PURE;
	STDMETHOD(put_LoginTimeout)					 (THIS_ short Timeout) PURE;
	STDMETHOD(get_Workspaces)					 (THIS_ DAOWorkspaces FAR* FAR* ppworks) PURE;
	STDMETHOD(get_Errors)						 (THIS_ DAOErrors FAR* FAR* pperrs) PURE;
	STDMETHOD(Idle)								 (THIS_ VARIANT Action) PURE;
	STDMETHOD(CompactDatabase)					 (THIS_ BSTR SrcName, BSTR DstName, VARIANT DstLocale, VARIANT Options, VARIANT SrcLocale) PURE;
	STDMETHOD(RepairDatabase)					 (THIS_ BSTR Name) PURE;
	STDMETHOD(RegisterDatabase)					 (THIS_ BSTR Dsn, BSTR Driver, VARIANT_BOOL Silent, BSTR Attributes) PURE;
	STDMETHOD(_30_CreateWorkspace)				 (THIS_ BSTR Name, BSTR UserName, BSTR Password, DAOWorkspace FAR* FAR* ppwrk) PURE;
	STDMETHOD(OpenDatabase)						 (THIS_ BSTR Name, VARIANT Options, VARIANT ReadOnly, VARIANT Connect, DAODatabase FAR* FAR* ppdb) PURE;
	STDMETHOD(CreateDatabase)					 (THIS_ BSTR Name, BSTR Locale, VARIANT Option, DAODatabase FAR* FAR* ppdb) PURE;
	STDMETHOD(FreeLocks)						 (THIS) PURE;
	STDMETHOD(BeginTrans)						 (THIS) PURE;
	STDMETHOD(CommitTrans)						 (THIS_ long Option) PURE;
	STDMETHOD(Rollback)							 (THIS) PURE;
	STDMETHOD(SetDefaultWorkspace)				 (THIS_ BSTR Name, BSTR Password) PURE;
	STDMETHOD(SetDataAccessOption)				 (THIS_ short Option, VARIANT Value) PURE;
	STDMETHOD(ISAMStats)						 (THIS_ long StatNum, VARIANT Reset, long FAR* pl) PURE;
	STDMETHOD(get_SystemDB)						 (THIS_ BSTR FAR* pbstr) PURE;
	STDMETHOD(put_SystemDB)						 (THIS_ BSTR SystemDBPath) PURE;
	STDMETHOD(CreateWorkspace)					 (THIS_ BSTR Name, BSTR UserName, BSTR Password, VARIANT UseType, DAOWorkspace FAR* FAR* ppwrk) PURE;
	STDMETHOD(OpenConnection)					 (THIS_ BSTR Name, VARIANT Options, VARIANT ReadOnly, VARIANT Connect, DAOConnection FAR* FAR* ppconn) PURE;
	STDMETHOD(get_DefaultType)					 (THIS_ long FAR* Option) PURE;
	STDMETHOD(put_DefaultType)					 (THIS_ long Option) PURE;
	STDMETHOD(SetOption)						 (THIS_ long Option, VARIANT Value) PURE;
	};

// Interface: DAOError
#undef INTERFACE
#define INTERFACE DAOError
DECLARE_INTERFACE_(DAOError, IDispatch)
	{
	STDMETHOD(get_Number)						 (THIS_ long FAR* pl) PURE;
	STDMETHOD(get_Source)						 (THIS_ BSTR FAR* pbstr) PURE;
	STDMETHOD(get_Description)					 (THIS_ BSTR FAR* pbstr) PURE;
	STDMETHOD(get_HelpFile)						 (THIS_ BSTR FAR* pbstr) PURE;
	STDMETHOD(get_HelpContext)					 (THIS_ long FAR* pl) PURE;
	};

// Interface: DAOErrors
#undef INTERFACE
#define INTERFACE DAOErrors
DECLARE_INTERFACE_(DAOErrors, _DAOCollection)
	{
	STDMETHOD(get_Item)							 (THIS_ VARIANT index, DAOError FAR* FAR* pperr) PURE;
	};

// Interface: DAOWorkspace
#undef INTERFACE
#define INTERFACE DAOWorkspace
DECLARE_INTERFACE_(DAOWorkspace, _DAO)
	{
	STDMETHOD(get_Name)							 (THIS_ BSTR FAR* pbstr) PURE;
	STDMETHOD(put_Name)							 (THIS_ BSTR Name) PURE;
	STDMETHOD(get_UserName)						 (THIS_ BSTR FAR* pbstr) PURE;
	STDMETHOD(put__30_UserName)					 (THIS_ BSTR UserName) PURE;
	STDMETHOD(put__30_Password)					 (THIS_ BSTR Password) PURE;
	STDMETHOD(get_IsolateODBCTrans)				 (THIS_ short FAR* ps) PURE;
	STDMETHOD(put_IsolateODBCTrans)				 (THIS_ short s) PURE;
	STDMETHOD(get_Databases)					 (THIS_ DAODatabases FAR* FAR* ppdbs) PURE;
	STDMETHOD(get_Users)						 (THIS_ DAOUsers FAR* FAR* ppusrs) PURE;
	STDMETHOD(get_Groups)						 (THIS_ DAOGroups FAR* FAR* ppgrps) PURE;
	STDMETHOD(BeginTrans)						 (THIS) PURE;
	STDMETHOD(CommitTrans)						 (THIS_ long Options) PURE;
	STDMETHOD(Close)							 (THIS) PURE;
	STDMETHOD(Rollback)							 (THIS) PURE;
	STDMETHOD(OpenDatabase)						 (THIS_ BSTR Name, VARIANT Options, VARIANT ReadOnly, VARIANT Connect, DAODatabase FAR* FAR* ppdb) PURE;
	STDMETHOD(CreateDatabase)					 (THIS_ BSTR Name, BSTR Connect, VARIANT Option, DAODatabase FAR* FAR* ppdb) PURE;
	STDMETHOD(CreateUser)						 (THIS_ VARIANT Name, VARIANT PID, VARIANT Password, DAOUser FAR* FAR* ppusr) PURE;
	STDMETHOD(CreateGroup)						 (THIS_ VARIANT Name, VARIANT PID, DAOGroup FAR* FAR* ppgrp) PURE;
	STDMETHOD(OpenConnection)					 (THIS_ BSTR Name, VARIANT Options, VARIANT ReadOnly, VARIANT Connect, DAOConnection FAR* FAR* ppconn) PURE;
	STDMETHOD(get_LoginTimeout)					 (THIS_ long FAR* pTimeout) PURE;
	STDMETHOD(put_LoginTimeout)					 (THIS_ long Timeout) PURE;
	STDMETHOD(get_DefaultCursorDriver)			 (THIS_ long FAR* pCursorType) PURE;
	STDMETHOD(put_DefaultCursorDriver)			 (THIS_ long CursorType) PURE;
	STDMETHOD(get_hEnv)							 (THIS_ long FAR* phEnv) PURE;
	STDMETHOD(get_Type)							 (THIS_ long FAR* ptype) PURE;
	STDMETHOD(get_Connections)					 (THIS_ DAOConnections FAR* FAR* ppcns) PURE;
	};

// Interface: DAOWorkspaces
#undef INTERFACE
#define INTERFACE DAOWorkspaces
DECLARE_INTERFACE_(DAOWorkspaces, _DAODynaCollection)
	{
	STDMETHOD(get_Item)							 (THIS_ VARIANT index, DAOWorkspace FAR* FAR* ppwrk) PURE;
	};

// Interface: _DAOTableDef
#undef INTERFACE
#define INTERFACE _DAOTableDef
DECLARE_INTERFACE_(_DAOTableDef, _DAO)
	{
	STDMETHOD(get_Attributes)					 (THIS_ long FAR* pl) PURE;
	STDMETHOD(put_Attributes)					 (THIS_ long Attributes) PURE;
	STDMETHOD(get_Connect)						 (THIS_ BSTR FAR* pbstr) PURE;
	STDMETHOD(put_Connect)						 (THIS_ BSTR Connection) PURE;
	STDMETHOD(get_DateCreated)					 (THIS_ VARIANT FAR* pvar) PURE;
	STDMETHOD(get_LastUpdated)					 (THIS_ VARIANT FAR* pvar) PURE;
	STDMETHOD(get_Name)							 (THIS_ BSTR FAR* pbstr) PURE;
	STDMETHOD(put_Name)							 (THIS_ BSTR Name) PURE;
	STDMETHOD(get_SourceTableName)				 (THIS_ BSTR FAR* pbstr) PURE;
	STDMETHOD(put_SourceTableName)				 (THIS_ BSTR bstr) PURE;
	STDMETHOD(get_Updatable)					 (THIS_ VARIANT_BOOL FAR* pb) PURE;
	STDMETHOD(get_ValidationText)				 (THIS_ BSTR FAR* pbstr) PURE;
	STDMETHOD(put_ValidationText)				 (THIS_ BSTR bstr) PURE;
	STDMETHOD(get_ValidationRule)				 (THIS_ BSTR FAR* pbstr) PURE;
	STDMETHOD(put_ValidationRule)				 (THIS_ BSTR bstr) PURE;
	STDMETHOD(get_RecordCount)					 (THIS_ long FAR* pl) PURE;
	STDMETHOD(get_Fields)						 (THIS_ DAOFields FAR* FAR* ppflds) PURE;
	STDMETHOD(get_Indexes)						 (THIS_ DAOIndexes FAR* FAR* ppidxs) PURE;
	STDMETHOD(OpenRecordset)					 (THIS_ VARIANT Type, VARIANT Options, DAORecordset FAR* FAR* pprst) PURE;
	STDMETHOD(RefreshLink)						 (THIS) PURE;
	STDMETHOD(CreateField)						 (THIS_ VARIANT Name, VARIANT Type, VARIANT Size, DAOField FAR* FAR* ppfld) PURE;
	STDMETHOD(CreateIndex)						 (THIS_ VARIANT Name, DAOIndex FAR* FAR* ppidx) PURE;
	STDMETHOD(CreateProperty)					 (THIS_ VARIANT Name, VARIANT Type, VARIANT Value, VARIANT DDL, DAOProperty FAR* FAR* pprp) PURE;
	STDMETHOD(get_ConflictTable)				 (THIS_ BSTR FAR* pbstr) PURE;
	STDMETHOD(get_ReplicaFilter)				 (THIS_ VARIANT FAR* pFilter) PURE;
	STDMETHOD(put_ReplicaFilter)				 (THIS_ VARIANT Filter) PURE;
	};

// Interface: DAOTableDefs
#undef INTERFACE
#define INTERFACE DAOTableDefs
DECLARE_INTERFACE_(DAOTableDefs, _DAODynaCollection)
	{
	STDMETHOD(get_Item)							 (THIS_ VARIANT index, DAOTableDef FAR* FAR* pptdf) PURE;
	};

// Interface: DAODatabase
#undef INTERFACE
#define INTERFACE DAODatabase
DECLARE_INTERFACE_(DAODatabase, _DAO)
	{
	STDMETHOD(get_CollatingOrder)				 (THIS_ long FAR* pl) PURE;
	STDMETHOD(get_Connect)						 (THIS_ BSTR FAR* pbstr) PURE;
	STDMETHOD(get_Name)							 (THIS_ BSTR FAR* pbstr) PURE;
	STDMETHOD(get_QueryTimeout)					 (THIS_ short FAR* ps) PURE;
	STDMETHOD(put_QueryTimeout)					 (THIS_ short Timeout) PURE;
	STDMETHOD(get_Transactions)					 (THIS_ VARIANT_BOOL FAR* pb) PURE;
	STDMETHOD(get_Updatable)					 (THIS_ VARIANT_BOOL FAR* pb) PURE;
	STDMETHOD(get_Version)						 (THIS_ BSTR FAR* pbstr) PURE;
	STDMETHOD(get_RecordsAffected)				 (THIS_ long FAR* pl) PURE;
	STDMETHOD(get_TableDefs)					 (THIS_ DAOTableDefs FAR* FAR* pptdfs) PURE;
	STDMETHOD(get_QueryDefs)					 (THIS_ DAOQueryDefs FAR* FAR* ppqdfs) PURE;
	STDMETHOD(get_Relations)					 (THIS_ DAORelations FAR* FAR* pprls) PURE;
	STDMETHOD(get_Containers)					 (THIS_ DAOContainers FAR* FAR* ppctns) PURE;
	STDMETHOD(get_Recordsets)					 (THIS_ DAORecordsets FAR* FAR* pprsts) PURE;
	STDMETHOD(Close)							 (THIS) PURE;
	STDMETHOD(Execute)							 (THIS_ BSTR Query, VARIANT Options) PURE;
	STDMETHOD(_30_OpenRecordset)				 (THIS_ BSTR Name, VARIANT Type, VARIANT Options, DAORecordset FAR* FAR* pprst) PURE;
	STDMETHOD(CreateProperty)					 (THIS_ VARIANT Name, VARIANT Type, VARIANT Value, VARIANT DDL, DAOProperty FAR* FAR* pprp) PURE;
	STDMETHOD(CreateRelation)					 (THIS_ VARIANT Name, VARIANT Table, VARIANT ForeignTable, VARIANT Attributes, DAORelation FAR* FAR* pprel) PURE;
	STDMETHOD(CreateTableDef)					 (THIS_ VARIANT Name, VARIANT Attributes, VARIANT SourceTablename, VARIANT Connect, DAOTableDef FAR* FAR* pptdf) PURE;
	STDMETHOD(BeginTrans)						 (THIS) PURE;
	STDMETHOD(CommitTrans)						 (THIS_ long Options) PURE;
	STDMETHOD(Rollback)							 (THIS) PURE;
	STDMETHOD(CreateDynaset)					 (THIS_ BSTR Name, VARIANT Options, VARIANT Inconsistent, DAORecordset FAR* FAR* pprst) PURE;
	STDMETHOD(CreateQueryDef)					 (THIS_ VARIANT Name, VARIANT SQLText, DAOQueryDef FAR* FAR* ppqdf) PURE;
	STDMETHOD(CreateSnapshot)					 (THIS_ BSTR Source, VARIANT Options, DAORecordset FAR* FAR* pprst) PURE;
	STDMETHOD(DeleteQueryDef)					 (THIS_ BSTR Name) PURE;
	STDMETHOD(ExecuteSQL)						 (THIS_ BSTR SQL, long FAR* pl) PURE;
	STDMETHOD(ListFields)						 (THIS_ BSTR Name, DAORecordset FAR* FAR* pprst) PURE;
	STDMETHOD(ListTables)						 (THIS_ DAORecordset FAR* FAR* pprst) PURE;
	STDMETHOD(OpenQueryDef)						 (THIS_ BSTR Name, DAOQueryDef FAR* FAR* ppqdf) PURE;
	STDMETHOD(OpenTable)						 (THIS_ BSTR Name, VARIANT Options, DAORecordset FAR* FAR* pprst) PURE;
	STDMETHOD(get_ReplicaID)					 (THIS_ BSTR FAR* pbstr) PURE;
	STDMETHOD(get_DesignMasterID)				 (THIS_ BSTR FAR* pbstr) PURE;
	STDMETHOD(put_DesignMasterID)				 (THIS_ BSTR MasterID) PURE;
	STDMETHOD(Synchronize)						 (THIS_ BSTR DbPathName, VARIANT ExchangeType) PURE;
	STDMETHOD(MakeReplica)						 (THIS_ BSTR PathName, BSTR Description, VARIANT Options) PURE;
	STDMETHOD(put_Connect)						 (THIS_ BSTR ODBCConnnect) PURE;
	STDMETHOD(NewPassword)						 (THIS_ BSTR bstrOld, BSTR bstrNew) PURE;
	STDMETHOD(OpenRecordset)					 (THIS_ BSTR Name, VARIANT Type, VARIANT Options, VARIANT LockEdit, DAORecordset FAR* FAR* pprst) PURE;
	STDMETHOD(get_Connection)					 (THIS_ DAOConnection FAR* FAR* ppCn) PURE;
	STDMETHOD(PopulatePartial)					 (THIS_ BSTR DbPathName) PURE;
	};

// Interface: DAODatabases
#undef INTERFACE
#define INTERFACE DAODatabases
DECLARE_INTERFACE_(DAODatabases, _DAOCollection)
	{
	STDMETHOD(get_Item)							 (THIS_ VARIANT index, DAODatabase FAR* FAR* ppdb) PURE;
	};

// Interface: _DAOQueryDef
#undef INTERFACE
#define INTERFACE _DAOQueryDef
DECLARE_INTERFACE_(_DAOQueryDef, _DAO)
	{
	STDMETHOD(get_DateCreated)					 (THIS_ VARIANT FAR* pvar) PURE;
	STDMETHOD(get_LastUpdated)					 (THIS_ VARIANT FAR* pvar) PURE;
	STDMETHOD(get_Name)							 (THIS_ BSTR FAR* pbstr) PURE;
	STDMETHOD(put_Name)							 (THIS_ BSTR bstr) PURE;
	STDMETHOD(get_ODBCTimeout)					 (THIS_ short FAR* ps) PURE;
	STDMETHOD(put_ODBCTimeout)					 (THIS_ short timeout) PURE;
	STDMETHOD(get_Type)							 (THIS_ short FAR* pi) PURE;
	STDMETHOD(get_SQL)							 (THIS_ BSTR FAR* pbstr) PURE;
	STDMETHOD(put_SQL)							 (THIS_ BSTR bstr) PURE;
	STDMETHOD(get_Updatable)					 (THIS_ VARIANT_BOOL FAR* pb) PURE;
	STDMETHOD(get_Connect)						 (THIS_ BSTR FAR* pbstr) PURE;
	STDMETHOD(put_Connect)						 (THIS_ BSTR bstr) PURE;
	STDMETHOD(get_ReturnsRecords)				 (THIS_ VARIANT_BOOL FAR* pb) PURE;
	STDMETHOD(put_ReturnsRecords)				 (THIS_ VARIANT_BOOL f) PURE;
	STDMETHOD(get_RecordsAffected)				 (THIS_ long FAR* pl) PURE;
	STDMETHOD(get_Fields)						 (THIS_ DAOFields FAR* FAR* ppflds) PURE;
	STDMETHOD(get_Parameters)					 (THIS_ DAOParameters FAR* FAR* ppprms) PURE;
	STDMETHOD(Close)							 (THIS) PURE;
	STDMETHOD(_30_OpenRecordset)				 (THIS_ VARIANT Type, VARIANT Options, DAORecordset FAR* FAR* pprst) PURE;
	STDMETHOD(_30__OpenRecordset)				 (THIS_ VARIANT Type, VARIANT Options, DAORecordset FAR* FAR* pprst) PURE;
	STDMETHOD(_Copy)							 (THIS_ DAOQueryDef FAR* FAR* ppqdf) PURE;
	STDMETHOD(Execute)							 (THIS_ VARIANT Options) PURE;
	STDMETHOD(Compare)							 (THIS_ DAOQueryDef FAR* pQdef, short FAR* lps) PURE;
	STDMETHOD(CreateDynaset)					 (THIS_ VARIANT Options, VARIANT Inconsistent, DAORecordset FAR* FAR* pprst) PURE;
	STDMETHOD(CreateSnapshot)					 (THIS_ VARIANT Options, DAORecordset FAR* FAR* pprst) PURE;
	STDMETHOD(ListParameters)					 (THIS_ DAORecordset FAR* FAR* pprst) PURE;
	STDMETHOD(CreateProperty)					 (THIS_ VARIANT Name, VARIANT Type, VARIANT Value, VARIANT DDL, DAOProperty FAR* FAR* pprp) PURE;
	STDMETHOD(OpenRecordset)					 (THIS_ VARIANT Type, VARIANT Options, VARIANT LockEdit, DAORecordset FAR* FAR* pprst) PURE;
	STDMETHOD(_OpenRecordset)					 (THIS_ VARIANT Type, VARIANT Options, VARIANT LockEdit, DAORecordset FAR* FAR* pprst) PURE;
	STDMETHOD(Cancel)							 (THIS) PURE;
	STDMETHOD(get_hStmt)						 (THIS_ long FAR* phStmt) PURE;
	STDMETHOD(get_MaxRecords)					 (THIS_ long FAR* pMxRecs) PURE;
	STDMETHOD(put_MaxRecords)					 (THIS_ long MxRecs) PURE;
	STDMETHOD(get_StillExecuting)				 (THIS_ VARIANT_BOOL FAR* pStillExec) PURE;
	STDMETHOD(get_CacheSize)					 (THIS_ long FAR* lCacheSize) PURE;
	STDMETHOD(put_CacheSize)					 (THIS_ long lCacheSize) PURE;
	STDMETHOD(get_Prepare)						 (THIS_ VARIANT FAR* pb) PURE;
	STDMETHOD(put_Prepare)						 (THIS_ VARIANT f) PURE;
	};

// Interface: DAOQueryDefs
#undef INTERFACE
#define INTERFACE DAOQueryDefs
DECLARE_INTERFACE_(DAOQueryDefs, _DAODynaCollection)
	{
	STDMETHOD(get_Item)							 (THIS_ VARIANT index, DAOQueryDef FAR* FAR* ppqdef) PURE;
	};

// Interface: DAORecordset
#undef INTERFACE
#define INTERFACE DAORecordset
DECLARE_INTERFACE_(DAORecordset, _DAO)
	{
	STDMETHOD(get_BOF)							 (THIS_ VARIANT_BOOL FAR* pb) PURE;
	STDMETHOD(get_Bookmark)						 (THIS_ SAFEARRAY FAR* FAR* ppsach) PURE;
	STDMETHOD(put_Bookmark)						 (THIS_ SAFEARRAY FAR* FAR* psach) PURE;
	STDMETHOD(get_Bookmarkable)					 (THIS_ VARIANT_BOOL FAR* pb) PURE;
	STDMETHOD(get_DateCreated)					 (THIS_ VARIANT FAR* pvar) PURE;
	STDMETHOD(get_EOF)							 (THIS_ VARIANT_BOOL FAR* pb) PURE;
	STDMETHOD(get_Filter)						 (THIS_ BSTR FAR* pbstr) PURE;
	STDMETHOD(put_Filter)						 (THIS_ BSTR Filter) PURE;
	STDMETHOD(get_Index)						 (THIS_ BSTR FAR* pbstr) PURE;
	STDMETHOD(put_Index)						 (THIS_ BSTR bstr) PURE;
	STDMETHOD(get_LastModified)					 (THIS_ SAFEARRAY FAR* FAR* ppsa) PURE;
	STDMETHOD(get_LastUpdated)					 (THIS_ VARIANT FAR* pvar) PURE;
	STDMETHOD(get_LockEdits)					 (THIS_ VARIANT_BOOL FAR* pb) PURE;
	STDMETHOD(put_LockEdits)					 (THIS_ VARIANT_BOOL Lock) PURE;
	STDMETHOD(get_Name)							 (THIS_ BSTR FAR* pbstr) PURE;
	STDMETHOD(get_NoMatch)						 (THIS_ VARIANT_BOOL FAR* pb) PURE;
	STDMETHOD(get_Sort)							 (THIS_ BSTR FAR* pbstr) PURE;
	STDMETHOD(put_Sort)							 (THIS_ BSTR Sort) PURE;
	STDMETHOD(get_Transactions)					 (THIS_ VARIANT_BOOL FAR* pb) PURE;
	STDMETHOD(get_Type)							 (THIS_ short FAR* ps) PURE;
	STDMETHOD(get_RecordCount)					 (THIS_ long FAR* pl) PURE;
	STDMETHOD(get_Updatable)					 (THIS_ VARIANT_BOOL FAR* pb) PURE;
	STDMETHOD(get_Restartable)					 (THIS_ VARIANT_BOOL FAR* pb) PURE;
	STDMETHOD(get_ValidationText)				 (THIS_ BSTR FAR* pbstr) PURE;
	STDMETHOD(get_ValidationRule)				 (THIS_ BSTR FAR* pbstr) PURE;
	STDMETHOD(get_CacheStart)					 (THIS_ SAFEARRAY FAR* FAR* ppsa) PURE;
	STDMETHOD(put_CacheStart)					 (THIS_ SAFEARRAY FAR* FAR* psa) PURE;
	STDMETHOD(get_CacheSize)					 (THIS_ long FAR* pl) PURE;
	STDMETHOD(put_CacheSize)					 (THIS_ long CacheSize) PURE;
	STDMETHOD(get_PercentPosition)				 (THIS_ float FAR* pd) PURE;
	STDMETHOD(put_PercentPosition)				 (THIS_ float Position) PURE;
	STDMETHOD(get_AbsolutePosition)				 (THIS_ long FAR* pl) PURE;
	STDMETHOD(put_AbsolutePosition)				 (THIS_ long Position) PURE;
	STDMETHOD(get_EditMode)						 (THIS_ short FAR* pi) PURE;
	STDMETHOD(get_ODBCFetchCount)				 (THIS_ long FAR* pl) PURE;
	STDMETHOD(get_ODBCFetchDelay)				 (THIS_ long FAR* pl) PURE;
	STDMETHOD(get_Parent)						 (THIS_ DAODatabase FAR* FAR* pdb) PURE;
	STDMETHOD(get_Fields)						 (THIS_ DAOFields FAR* FAR* ppflds) PURE;
	STDMETHOD(get_Indexes)						 (THIS_ DAOIndexes FAR* FAR* ppidxs) PURE;
	STDMETHOD(_30_CancelUpdate)					 (THIS) PURE;
	STDMETHOD(AddNew)							 (THIS) PURE;
	STDMETHOD(Close)							 (THIS) PURE;
	STDMETHOD(OpenRecordset)					 (THIS_ VARIANT Type, VARIANT Options, DAORecordset FAR* FAR* pprst) PURE;
	STDMETHOD(Delete)							 (THIS) PURE;
	STDMETHOD(Edit)								 (THIS) PURE;
	STDMETHOD(FindFirst)						 (THIS_ BSTR Criteria) PURE;
	STDMETHOD(FindLast)							 (THIS_ BSTR Criteria) PURE;
	STDMETHOD(FindNext)							 (THIS_ BSTR Criteria) PURE;
	STDMETHOD(FindPrevious)						 (THIS_ BSTR Criteria) PURE;
	STDMETHOD(MoveFirst)						 (THIS) PURE;
	STDMETHOD(_30_MoveLast)						 (THIS) PURE;
	STDMETHOD(MoveNext)							 (THIS) PURE;
	STDMETHOD(MovePrevious)						 (THIS) PURE;
	STDMETHOD(Seek)								 (THIS_ BSTR Comparison, VARIANT Key1, VARIANT Key2, VARIANT Key3, VARIANT Key4, VARIANT Key5, VARIANT Key6, VARIANT Key7, VARIANT Key8, VARIANT Key9, VARIANT Key10, VARIANT Key11, VARIANT Key12, VARIANT Key13) PURE;
	STDMETHOD(_30_Update)						 (THIS) PURE;
	STDMETHOD(Clone)							 (THIS_ DAORecordset FAR* FAR* pprst) PURE;
	STDMETHOD(Requery)							 (THIS_ VARIANT NewQueryDef) PURE;
	STDMETHOD(Move)								 (THIS_ long Rows, VARIANT StartBookmark) PURE;
	STDMETHOD(FillCache)						 (THIS_ VARIANT Rows, VARIANT StartBookmark) PURE;
	STDMETHOD(CreateDynaset)					 (THIS_ VARIANT Options, VARIANT Inconsistent, DAORecordset FAR* FAR* pprst) PURE;
	STDMETHOD(CreateSnapshot)					 (THIS_ VARIANT Options, DAORecordset FAR* FAR* pprst) PURE;
	STDMETHOD(CopyQueryDef)						 (THIS_ DAOQueryDef FAR* FAR* ppqdf) PURE;
	STDMETHOD(ListFields)						 (THIS_ DAORecordset FAR* FAR* pprst) PURE;
	STDMETHOD(ListIndexes)						 (THIS_ DAORecordset FAR* FAR* pprst) PURE;
	STDMETHOD(GetRows)							 (THIS_ VARIANT NumRows, VARIANT FAR* pvar) PURE;
	STDMETHOD(get_Collect)						 (THIS_ VARIANT index, VARIANT FAR* pvar) PURE;
	STDMETHOD(put_Collect)						 (THIS_ VARIANT index, VARIANT value) PURE;
	STDMETHOD(Cancel)							 (THIS) PURE;
	STDMETHOD(NextRecordset)					 (THIS_ VARIANT_BOOL FAR* pb) PURE;
	STDMETHOD(get_hStmt)						 (THIS_ long FAR* phStmt) PURE;
	STDMETHOD(get_StillExecuting)				 (THIS_ VARIANT_BOOL FAR* pStillExec) PURE;
	STDMETHOD(get_BatchSize)					 (THIS_ long FAR* pl) PURE;
	STDMETHOD(put_BatchSize)					 (THIS_ long BatchSize) PURE;
	STDMETHOD(get_BatchCollisionCount)			 (THIS_ long FAR* pl) PURE;
	STDMETHOD(get_BatchCollisions)				 (THIS_ VARIANT FAR* pvar) PURE;
	STDMETHOD(get_Connection)					 (THIS_ DAOConnection FAR* FAR* ppCn) PURE;
	STDMETHOD(putref_Connection)				 (THIS_ DAOConnection FAR* pNewCn) PURE;
	STDMETHOD(get_RecordStatus)					 (THIS_ short FAR* pi) PURE;
	STDMETHOD(get_UpdateOptions)				 (THIS_ long FAR* pl) PURE;
	STDMETHOD(put_UpdateOptions)				 (THIS_ long l) PURE;
	STDMETHOD(CancelUpdate)						 (THIS_ long UpdateType) PURE;
	STDMETHOD(Update)							 (THIS_ long UpdateType, VARIANT_BOOL Force) PURE;
	STDMETHOD(MoveLast)							 (THIS_ long Options) PURE;
	};

// Interface: DAORecordsets
#undef INTERFACE
#define INTERFACE DAORecordsets
DECLARE_INTERFACE_(DAORecordsets, _DAOCollection)
	{
	STDMETHOD(get_Item)							 (THIS_ VARIANT index, DAORecordset FAR* FAR* pprst) PURE;
	};

// Interface: _DAOField
#undef INTERFACE
#define INTERFACE _DAOField
DECLARE_INTERFACE_(_DAOField, _DAO)
	{
	STDMETHOD(get_CollatingOrder)				 (THIS_ long FAR* pl) PURE;
	STDMETHOD(get_Type)							 (THIS_ short FAR* ps) PURE;
	STDMETHOD(put_Type)							 (THIS_ short Type) PURE;
	STDMETHOD(get_Name)							 (THIS_ BSTR FAR* pbstr) PURE;
	STDMETHOD(put_Name)							 (THIS_ BSTR Name) PURE;
	STDMETHOD(get_Size)							 (THIS_ long FAR* pl) PURE;
	STDMETHOD(put_Size)							 (THIS_ long Size) PURE;
	STDMETHOD(get_SourceField)					 (THIS_ BSTR FAR* pbstr) PURE;
	STDMETHOD(get_SourceTable)					 (THIS_ BSTR FAR* pbstr) PURE;
	STDMETHOD(get_Value)						 (THIS_ VARIANT FAR* pvar) PURE;
	STDMETHOD(put_Value)						 (THIS_ VARIANT Val) PURE;
	STDMETHOD(get_Attributes)					 (THIS_ long FAR* pl) PURE;
	STDMETHOD(put_Attributes)					 (THIS_ long Attr) PURE;
	STDMETHOD(get_OrdinalPosition)				 (THIS_ short FAR* ps) PURE;
	STDMETHOD(put_OrdinalPosition)				 (THIS_ short Pos) PURE;
	STDMETHOD(get_ValidationText)				 (THIS_ BSTR FAR* pbstr) PURE;
	STDMETHOD(put_ValidationText)				 (THIS_ BSTR bstr) PURE;
	STDMETHOD(get_ValidateOnSet)				 (THIS_ VARIANT_BOOL FAR* pb) PURE;
	STDMETHOD(put_ValidateOnSet)				 (THIS_ VARIANT_BOOL Validate) PURE;
	STDMETHOD(get_ValidationRule)				 (THIS_ BSTR FAR* pbstr) PURE;
	STDMETHOD(put_ValidationRule)				 (THIS_ BSTR bstr) PURE;
	STDMETHOD(get_DefaultValue)					 (THIS_ VARIANT FAR* pvar) PURE;
	STDMETHOD(put_DefaultValue)					 (THIS_ VARIANT var) PURE;
	STDMETHOD(get_Required)						 (THIS_ VARIANT_BOOL FAR* pb) PURE;
	STDMETHOD(put_Required)						 (THIS_ VARIANT_BOOL fReq) PURE;
	STDMETHOD(get_AllowZeroLength)				 (THIS_ VARIANT_BOOL FAR* pb) PURE;
	STDMETHOD(put_AllowZeroLength)				 (THIS_ VARIANT_BOOL fAllow) PURE;
	STDMETHOD(get_DataUpdatable)				 (THIS_ VARIANT_BOOL FAR* pb) PURE;
	STDMETHOD(get_ForeignName)					 (THIS_ BSTR FAR* pbstr) PURE;
	STDMETHOD(put_ForeignName)					 (THIS_ BSTR bstr) PURE;
	STDMETHOD(AppendChunk)						 (THIS_ VARIANT Val) PURE;
	STDMETHOD(GetChunk)							 (THIS_ long Offset, long Bytes, VARIANT FAR* pvar) PURE;
	STDMETHOD(_30_FieldSize)					 (THIS_ long FAR* pl) PURE;
	STDMETHOD(CreateProperty)					 (THIS_ VARIANT Name, VARIANT Type, VARIANT Value, VARIANT DDL, DAOProperty FAR* FAR* pprp) PURE;
	STDMETHOD(get_CollectionIndex)				 (THIS_ short FAR* i) PURE;
	STDMETHOD(get_OriginalValue)				 (THIS_ VARIANT FAR* pvar) PURE;
	STDMETHOD(get_VisibleValue)					 (THIS_ VARIANT FAR* pvar) PURE;
	STDMETHOD(get_FieldSize)					 (THIS_ long FAR* pl) PURE;
	};

// Interface: DAOFields
#undef INTERFACE
#define INTERFACE DAOFields
DECLARE_INTERFACE_(DAOFields, _DAODynaCollection)
	{
	STDMETHOD(get_Item)							 (THIS_ VARIANT index, DAOField FAR* FAR* ppfld) PURE;
	};

// Interface: _DAOIndex
#undef INTERFACE
#define INTERFACE _DAOIndex
DECLARE_INTERFACE_(_DAOIndex, _DAO)
	{
	STDMETHOD(get_Name)							 (THIS_ BSTR FAR* pbstr) PURE;
	STDMETHOD(put_Name)							 (THIS_ BSTR bstr) PURE;
	STDMETHOD(get_Foreign)						 (THIS_ VARIANT_BOOL FAR* pb) PURE;
	STDMETHOD(get_Unique)						 (THIS_ VARIANT_BOOL FAR* pb) PURE;
	STDMETHOD(put_Unique)						 (THIS_ VARIANT_BOOL fUnique) PURE;
	STDMETHOD(get_Clustered)					 (THIS_ VARIANT_BOOL FAR* pb) PURE;
	STDMETHOD(put_Clustered)					 (THIS_ VARIANT_BOOL fClustered) PURE;
	STDMETHOD(get_Required)						 (THIS_ VARIANT_BOOL FAR* pb) PURE;
	STDMETHOD(put_Required)						 (THIS_ VARIANT_BOOL fRequired) PURE;
	STDMETHOD(get_IgnoreNulls)					 (THIS_ VARIANT_BOOL FAR* pb) PURE;
	STDMETHOD(put_IgnoreNulls)					 (THIS_ VARIANT_BOOL fIgnoreNulls) PURE;
	STDMETHOD(get_Primary)						 (THIS_ VARIANT_BOOL FAR* pb) PURE;
	STDMETHOD(put_Primary)						 (THIS_ VARIANT_BOOL fPrimary) PURE;
	STDMETHOD(get_DistinctCount)				 (THIS_ long FAR* pl) PURE;
	STDMETHOD(get_Fields)						 (THIS_ VARIANT FAR* pv) PURE;
	STDMETHOD(put_Fields)						 (THIS_ VARIANT v) PURE;
	STDMETHOD(CreateField)						 (THIS_ VARIANT Name, VARIANT Type, VARIANT Size, DAOField FAR* FAR* ppfld) PURE;
	STDMETHOD(CreateProperty)					 (THIS_ VARIANT Name, VARIANT Type, VARIANT Value, VARIANT DDL, DAOProperty FAR* FAR* pprp) PURE;
	};

// Interface: DAOIndexes
#undef INTERFACE
#define INTERFACE DAOIndexes
DECLARE_INTERFACE_(DAOIndexes, _DAODynaCollection)
	{
	STDMETHOD(get_Item)							 (THIS_ VARIANT index, DAOIndex FAR* FAR* ppidx) PURE;
	};

// Interface: DAOIndexFields
#undef INTERFACE
#define INTERFACE DAOIndexFields
DECLARE_INTERFACE_(DAOIndexFields, _DAODynaCollection)
	{
	STDMETHOD(get_Item)							 (THIS_ VARIANT index, VARIANT FAR* pvar) PURE;
	};

// Interface: DAOParameter
#undef INTERFACE
#define INTERFACE DAOParameter
DECLARE_INTERFACE_(DAOParameter, _DAO)
	{
	STDMETHOD(get_Name)							 (THIS_ BSTR FAR* pbstr) PURE;
	STDMETHOD(get_Value)						 (THIS_ VARIANT FAR* pvar) PURE;
	STDMETHOD(put_Value)						 (THIS_ VARIANT val) PURE;
	STDMETHOD(get_Type)							 (THIS_ short FAR* ps) PURE;
	STDMETHOD(put_Type)							 (THIS_ short s) PURE;
	STDMETHOD(get_Direction)					 (THIS_ short FAR* pOption) PURE;
	STDMETHOD(put_Direction)					 (THIS_ short Option) PURE;
	};

// Interface: DAOParameters
#undef INTERFACE
#define INTERFACE DAOParameters
DECLARE_INTERFACE_(DAOParameters, _DAOCollection)
	{
	STDMETHOD(get_Item)							 (THIS_ VARIANT index, DAOParameter FAR* FAR* ppprm) PURE;
	};

// Interface: _DAOUser
#undef INTERFACE
#define INTERFACE _DAOUser
DECLARE_INTERFACE_(_DAOUser, _DAO)
	{
	STDMETHOD(get_Name)							 (THIS_ BSTR FAR* pbstr) PURE;
	STDMETHOD(put_Name)							 (THIS_ BSTR bstr) PURE;
	STDMETHOD(put_PID)							 (THIS_ BSTR bstr) PURE;
	STDMETHOD(put_Password)						 (THIS_ BSTR bstr) PURE;
	STDMETHOD(get_Groups)						 (THIS_ DAOGroups FAR* FAR* ppgrps) PURE;
	STDMETHOD(NewPassword)						 (THIS_ BSTR bstrOld, BSTR bstrNew) PURE;
	STDMETHOD(CreateGroup)						 (THIS_ VARIANT Name, VARIANT PID, DAOGroup FAR* FAR* ppgrp) PURE;
	};

// Interface: DAOUsers
#undef INTERFACE
#define INTERFACE DAOUsers
DECLARE_INTERFACE_(DAOUsers, _DAODynaCollection)
	{
	STDMETHOD(get_Item)							 (THIS_ VARIANT index, DAOUser FAR* FAR* ppusr) PURE;
	};

// Interface: _DAOGroup
#undef INTERFACE
#define INTERFACE _DAOGroup
DECLARE_INTERFACE_(_DAOGroup, _DAO)
	{
	STDMETHOD(get_Name)							 (THIS_ BSTR FAR* pbstr) PURE;
	STDMETHOD(put_Name)							 (THIS_ BSTR bstr) PURE;
	STDMETHOD(put_PID)							 (THIS_ BSTR bstr) PURE;
	STDMETHOD(get_Users)						 (THIS_ DAOUsers FAR* FAR* ppusrs) PURE;
	STDMETHOD(CreateUser)						 (THIS_ VARIANT Name, VARIANT PID, VARIANT Password, DAOUser FAR* FAR* ppusr) PURE;
	};

// Interface: DAOGroups
#undef INTERFACE
#define INTERFACE DAOGroups
DECLARE_INTERFACE_(DAOGroups, _DAODynaCollection)
	{
	STDMETHOD(get_Item)							 (THIS_ VARIANT index, DAOGroup FAR* FAR* ppgrp) PURE;
	};

// Interface: _DAORelation
#undef INTERFACE
#define INTERFACE _DAORelation
DECLARE_INTERFACE_(_DAORelation, _DAO)
	{
	STDMETHOD(get_Name)							 (THIS_ BSTR FAR* pbstr) PURE;
	STDMETHOD(put_Name)							 (THIS_ BSTR bstr) PURE;
	STDMETHOD(get_Table)						 (THIS_ BSTR FAR* pbstr) PURE;
	STDMETHOD(put_Table)						 (THIS_ BSTR bstr) PURE;
	STDMETHOD(get_ForeignTable)					 (THIS_ BSTR FAR* pbstr) PURE;
	STDMETHOD(put_ForeignTable)					 (THIS_ BSTR bstr) PURE;
	STDMETHOD(get_Attributes)					 (THIS_ long FAR* pl) PURE;
	STDMETHOD(put_Attributes)					 (THIS_ long attr) PURE;
	STDMETHOD(get_Fields)						 (THIS_ DAOFields FAR* FAR* ppflds) PURE;
	STDMETHOD(CreateField)						 (THIS_ VARIANT Name, VARIANT Type, VARIANT Size, DAOField FAR* FAR* ppfld) PURE;
	STDMETHOD(get_PartialReplica)				 (THIS_ VARIANT_BOOL FAR* pfPartialReplica) PURE;
	STDMETHOD(put_PartialReplica)				 (THIS_ VARIANT_BOOL fPartialReplica) PURE;
	};

// Interface: DAORelations
#undef INTERFACE
#define INTERFACE DAORelations
DECLARE_INTERFACE_(DAORelations, _DAODynaCollection)
	{
	STDMETHOD(get_Item)							 (THIS_ VARIANT index, DAORelation FAR* FAR* pprel) PURE;
	};

// Interface: DAOProperty
#undef INTERFACE
#define INTERFACE DAOProperty
DECLARE_INTERFACE_(DAOProperty, _DAO)
	{
	STDMETHOD(get_Value)						 (THIS_ VARIANT FAR* pval) PURE;
	STDMETHOD(put_Value)						 (THIS_ VARIANT val) PURE;
	STDMETHOD(get_Name)							 (THIS_ BSTR FAR* pbstr) PURE;
	STDMETHOD(put_Name)							 (THIS_ BSTR bstr) PURE;
	STDMETHOD(get_Type)							 (THIS_ short FAR* ptype) PURE;
	STDMETHOD(put_Type)							 (THIS_ short type) PURE;
	STDMETHOD(get_Inherited)					 (THIS_ VARIANT_BOOL FAR* pb) PURE;
	};

// Interface: DAOProperties
#undef INTERFACE
#define INTERFACE DAOProperties
DECLARE_INTERFACE_(DAOProperties, _DAODynaCollection)
	{
	STDMETHOD(get_Item)							 (THIS_ VARIANT index, DAOProperty FAR* FAR* ppprop) PURE;
	};

// Interface: DAOContainer
#undef INTERFACE
#define INTERFACE DAOContainer
DECLARE_INTERFACE_(DAOContainer, _DAO)
	{
	STDMETHOD(get_Name)							 (THIS_ BSTR FAR* pbstr) PURE;
	STDMETHOD(get_Owner)						 (THIS_ BSTR FAR* pbstr) PURE;
	STDMETHOD(put_Owner)						 (THIS_ BSTR bstr) PURE;
	STDMETHOD(get_UserName)						 (THIS_ BSTR FAR* pbstr) PURE;
	STDMETHOD(put_UserName)						 (THIS_ BSTR bstr) PURE;
	STDMETHOD(get_Permissions)					 (THIS_ long FAR* pl) PURE;
	STDMETHOD(put_Permissions)					 (THIS_ long permissions) PURE;
	STDMETHOD(get_Inherit)						 (THIS_ VARIANT_BOOL FAR* pb) PURE;
	STDMETHOD(put_Inherit)						 (THIS_ VARIANT_BOOL fInherit) PURE;
	STDMETHOD(get_Documents)					 (THIS_ DAODocuments FAR* FAR* ppdocs) PURE;
	STDMETHOD(get_AllPermissions)				 (THIS_ long FAR* pl) PURE;
	};

// Interface: DAOContainers
#undef INTERFACE
#define INTERFACE DAOContainers
DECLARE_INTERFACE_(DAOContainers, _DAOCollection)
	{
	STDMETHOD(get_Item)							 (THIS_ VARIANT index, DAOContainer FAR* FAR* ppctn) PURE;
	};

// Interface: DAODocument
#undef INTERFACE
#define INTERFACE DAODocument
DECLARE_INTERFACE_(DAODocument, _DAO)
	{
	STDMETHOD(get_Name)							 (THIS_ BSTR FAR* pbstr) PURE;
	STDMETHOD(get_Owner)						 (THIS_ BSTR FAR* pbstr) PURE;
	STDMETHOD(put_Owner)						 (THIS_ BSTR bstr) PURE;
	STDMETHOD(get_Container)					 (THIS_ BSTR FAR* pbstr) PURE;
	STDMETHOD(get_UserName)						 (THIS_ BSTR FAR* pbstr) PURE;
	STDMETHOD(put_UserName)						 (THIS_ BSTR bstr) PURE;
	STDMETHOD(get_Permissions)					 (THIS_ long FAR* pl) PURE;
	STDMETHOD(put_Permissions)					 (THIS_ long permissions) PURE;
	STDMETHOD(get_DateCreated)					 (THIS_ VARIANT FAR* pvar) PURE;
	STDMETHOD(get_LastUpdated)					 (THIS_ VARIANT FAR* pvar) PURE;
	STDMETHOD(get_AllPermissions)				 (THIS_ long FAR* pl) PURE;
	STDMETHOD(CreateProperty)					 (THIS_ VARIANT Name, VARIANT Type, VARIANT Value, VARIANT DDL, DAOProperty FAR* FAR* pprp) PURE;
	};

// Interface: DAODocuments
#undef INTERFACE
#define INTERFACE DAODocuments
DECLARE_INTERFACE_(DAODocuments, _DAOCollection)
	{
	STDMETHOD(get_Item)							 (THIS_ VARIANT index, DAODocument FAR* FAR* ppdoc) PURE;
	};

// Interface: DAOConnection
#undef INTERFACE
#define INTERFACE DAOConnection
DECLARE_INTERFACE_(DAOConnection, IDispatch)
	{
	STDMETHOD(get_Name)							 (THIS_ BSTR FAR* pbstr) PURE;
	STDMETHOD(get_Connect)						 (THIS_ BSTR FAR* pbstr) PURE;
	STDMETHOD(get_Database)						 (THIS_ DAODatabase FAR* FAR* ppDb) PURE;
	STDMETHOD(get_hDbc)							 (THIS_ long FAR* phDbc) PURE;
	STDMETHOD(get_QueryTimeout)					 (THIS_ short FAR* pSeconds) PURE;
	STDMETHOD(put_QueryTimeout)					 (THIS_ short Seconds) PURE;
	STDMETHOD(get_Transactions)					 (THIS_ VARIANT_BOOL FAR* pb) PURE;
	STDMETHOD(get_RecordsAffected)				 (THIS_ long FAR* pRecords) PURE;
	STDMETHOD(get_StillExecuting)				 (THIS_ VARIANT_BOOL FAR* pStillExec) PURE;
	STDMETHOD(get_Updatable)					 (THIS_ VARIANT_BOOL FAR* pStillExec) PURE;
	STDMETHOD(get_QueryDefs)					 (THIS_ DAOQueryDefs FAR* FAR* ppqdfs) PURE;
	STDMETHOD(get_Recordsets)					 (THIS_ DAORecordsets FAR* FAR* pprsts) PURE;
	STDMETHOD(Cancel)							 (THIS) PURE;
	STDMETHOD(Close)							 (THIS) PURE;
	STDMETHOD(CreateQueryDef)					 (THIS_ VARIANT Name, VARIANT SQLText, DAOQueryDef FAR* FAR* ppqdf) PURE;
	STDMETHOD(Execute)							 (THIS_ BSTR Query, VARIANT Options) PURE;
	STDMETHOD(OpenRecordset)					 (THIS_ BSTR Name, VARIANT Type, VARIANT Options, VARIANT LockEdit, DAORecordset FAR* FAR* pprst) PURE;
	};

// Interface: DAOConnections
#undef INTERFACE
#define INTERFACE DAOConnections
DECLARE_INTERFACE_(DAOConnections, _DAOCollection)
	{
	STDMETHOD(get_Item)							 (THIS_ VARIANT index, DAOConnection FAR* FAR* ppconn) PURE;
	};

#endif // _DBDAOINT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\dbghelp.h ===
/*++ BUILD Version: 0001     Increment this if a change has global effects

Copyright (c) 1990-1999  Microsoft Corporation

Module Name:

    dbghelp.h

Abstract:

    This module defines the prototypes and constants required for the image
    help routines.

    Contains debugging support routines that are redistributable.

Revision History:

--*/

#ifndef _DBGHELP_
#define _DBGHELP_

#if _MSC_VER > 1020
#pragma once
#endif


#ifdef _WIN64
#ifndef _IMAGEHLP64
#define _IMAGEHLP64
#endif
#endif


#ifdef __cplusplus
extern "C" {
#endif

#ifdef _IMAGEHLP_SOURCE_
#define IMAGEAPI __stdcall
#else
#define IMAGEAPI DECLSPEC_IMPORT __stdcall
#endif

#define IMAGE_SEPARATION (64*1024)

typedef struct _LOADED_IMAGE {
    PSTR                  ModuleName;
    HANDLE                hFile;
    PUCHAR                MappedAddress;
#ifdef _IMAGEHLP64
    PIMAGE_NT_HEADERS64   FileHeader;
#else
    PIMAGE_NT_HEADERS32   FileHeader;
#endif
    PIMAGE_SECTION_HEADER LastRvaSection;
    ULONG                 NumberOfSections;
    PIMAGE_SECTION_HEADER Sections;
    ULONG                 Characteristics;
    BOOLEAN               fSystemImage;
    BOOLEAN               fDOSImage;
    LIST_ENTRY            Links;
    ULONG                 SizeOfImage;
} LOADED_IMAGE, *PLOADED_IMAGE;



HANDLE
IMAGEAPI
FindDebugInfoFile (
    PSTR FileName,
    PSTR SymbolPath,
    PSTR DebugFilePath
    );

typedef BOOL
(CALLBACK *PFIND_DEBUG_FILE_CALLBACK)(
    HANDLE FileHandle,
    PSTR FileName,
    PVOID CallerData
    );

HANDLE
IMAGEAPI
FindDebugInfoFileEx (
    PSTR FileName,
    PSTR SymbolPath,
    PSTR DebugFilePath,
    PFIND_DEBUG_FILE_CALLBACK Callback,
    PVOID CallerData
    );

BOOL
IMAGEAPI
FindFileInSearchPath(
    HANDLE hprocess,
    LPSTR SearchPath,
    LPSTR FileName,
    DWORD one,
    DWORD two,
    DWORD three,
    LPSTR FilePath
    );
    
HANDLE
IMAGEAPI
FindExecutableImage(
    PSTR FileName,
    PSTR SymbolPath,
    PSTR ImageFilePath
    );

typedef BOOL
(CALLBACK *PFIND_EXE_FILE_CALLBACK)(
    HANDLE FileHandle,
    PSTR FileName,
    PVOID CallerData
    );

HANDLE
IMAGEAPI
FindExecutableImageEx(
    PSTR FileName,
    PSTR SymbolPath,
    PSTR ImageFilePath,
    PFIND_EXE_FILE_CALLBACK Callback,
    PVOID CallerData
    );

PIMAGE_NT_HEADERS
IMAGEAPI
ImageNtHeader (
    IN PVOID Base
    );

PVOID
IMAGEAPI
ImageDirectoryEntryToDataEx (
    IN PVOID Base,
    IN BOOLEAN MappedAsImage,
    IN USHORT DirectoryEntry,
    OUT PULONG Size,
    OUT PIMAGE_SECTION_HEADER *FoundHeader OPTIONAL
    );

PVOID
IMAGEAPI
ImageDirectoryEntryToData (
    IN PVOID Base,
    IN BOOLEAN MappedAsImage,
    IN USHORT DirectoryEntry,
    OUT PULONG Size
    );

PIMAGE_SECTION_HEADER
IMAGEAPI
ImageRvaToSection(
    IN PIMAGE_NT_HEADERS NtHeaders,
    IN PVOID Base,
    IN ULONG Rva
    );

PVOID
IMAGEAPI
ImageRvaToVa(
    IN PIMAGE_NT_HEADERS NtHeaders,
    IN PVOID Base,
    IN ULONG Rva,
    IN OUT PIMAGE_SECTION_HEADER *LastRvaSection
    );

// Symbol server export

typedef BOOL (*PSYMBOLSERVERPROC)(LPCSTR, LPCSTR, DWORD, DWORD, DWORD, LPSTR);
typedef BOOL (*PSYMBOLSERVEROPENPROC)(VOID);
typedef BOOL (*PSYMBOLSERVERCLOSEPROC)(VOID);

#ifndef _WIN64
// This api won't be ported to Win64 - Fix your code.

typedef struct _IMAGE_DEBUG_INFORMATION {
    LIST_ENTRY List;
    DWORD ReservedSize;
    PVOID ReservedMappedBase;
    USHORT ReservedMachine;
    USHORT ReservedCharacteristics;
    DWORD ReservedCheckSum;
    DWORD ImageBase;
    DWORD SizeOfImage;

    DWORD ReservedNumberOfSections;
    PIMAGE_SECTION_HEADER ReservedSections;

    DWORD ReservedExportedNamesSize;
    PSTR ReservedExportedNames;

    DWORD ReservedNumberOfFunctionTableEntries;
    PIMAGE_FUNCTION_ENTRY ReservedFunctionTableEntries;
    DWORD ReservedLowestFunctionStartingAddress;
    DWORD ReservedHighestFunctionEndingAddress;

    DWORD ReservedNumberOfFpoTableEntries;
    PFPO_DATA ReservedFpoTableEntries;

    DWORD SizeOfCoffSymbols;
    PIMAGE_COFF_SYMBOLS_HEADER CoffSymbols;

    DWORD ReservedSizeOfCodeViewSymbols;
    PVOID ReservedCodeViewSymbols;

    PSTR ImageFilePath;
    PSTR ImageFileName;
    PSTR ReservedDebugFilePath;

    DWORD ReservedTimeDateStamp;

    BOOL  ReservedRomImage;
    PIMAGE_DEBUG_DIRECTORY ReservedDebugDirectory;
    DWORD ReservedNumberOfDebugDirectories;

    DWORD ReservedOriginalFunctionTableBaseAddress;

    DWORD Reserved[ 2 ];

} IMAGE_DEBUG_INFORMATION, *PIMAGE_DEBUG_INFORMATION;


PIMAGE_DEBUG_INFORMATION
IMAGEAPI
MapDebugInformation(
    HANDLE FileHandle,
    PSTR FileName,
    PSTR SymbolPath,
    DWORD ImageBase
    );

BOOL
IMAGEAPI
UnmapDebugInformation(
    PIMAGE_DEBUG_INFORMATION DebugInfo
    );

#endif

BOOL
IMAGEAPI
SearchTreeForFile(
    PSTR RootPath,
    PSTR InputPathName,
    PSTR OutputPathBuffer
    );

BOOL
IMAGEAPI
MakeSureDirectoryPathExists(
    PCSTR DirPath
    );

//
// UnDecorateSymbolName Flags
//

#define UNDNAME_COMPLETE                 (0x0000)  // Enable full undecoration
#define UNDNAME_NO_LEADING_UNDERSCORES   (0x0001)  // Remove leading underscores from MS extended keywords
#define UNDNAME_NO_MS_KEYWORDS           (0x0002)  // Disable expansion of MS extended keywords
#define UNDNAME_NO_FUNCTION_RETURNS      (0x0004)  // Disable expansion of return type for primary declaration
#define UNDNAME_NO_ALLOCATION_MODEL      (0x0008)  // Disable expansion of the declaration model
#define UNDNAME_NO_ALLOCATION_LANGUAGE   (0x0010)  // Disable expansion of the declaration language specifier
#define UNDNAME_NO_MS_THISTYPE           (0x0020)  // NYI Disable expansion of MS keywords on the 'this' type for primary declaration
#define UNDNAME_NO_CV_THISTYPE           (0x0040)  // NYI Disable expansion of CV modifiers on the 'this' type for primary declaration
#define UNDNAME_NO_THISTYPE              (0x0060)  // Disable all modifiers on the 'this' type
#define UNDNAME_NO_ACCESS_SPECIFIERS     (0x0080)  // Disable expansion of access specifiers for members
#define UNDNAME_NO_THROW_SIGNATURES      (0x0100)  // Disable expansion of 'throw-signatures' for functions and pointers to functions
#define UNDNAME_NO_MEMBER_TYPE           (0x0200)  // Disable expansion of 'static' or 'virtual'ness of members
#define UNDNAME_NO_RETURN_UDT_MODEL      (0x0400)  // Disable expansion of MS model for UDT returns
#define UNDNAME_32_BIT_DECODE            (0x0800)  // Undecorate 32-bit decorated names
#define UNDNAME_NAME_ONLY                (0x1000)  // Crack only the name for primary declaration;
                                                                                                   //  return just [scope::]name.  Does expand template params
#define UNDNAME_NO_ARGUMENTS             (0x2000)  // Don't undecorate arguments to function
#define UNDNAME_NO_SPECIAL_SYMS          (0x4000)  // Don't undecorate special names (v-table, vcall, vector xxx, metatype, etc)

DWORD
IMAGEAPI
WINAPI
UnDecorateSymbolName(
    PCSTR   DecoratedName,         // Name to undecorate
    PSTR    UnDecoratedName,       // If NULL, it will be allocated
    DWORD    UndecoratedLength,     // The maximym length
    DWORD    Flags                  // See above.
    );

//
// StackWalking API
//

typedef enum {
    AddrMode1616,
    AddrMode1632,
    AddrModeReal,
    AddrModeFlat
} ADDRESS_MODE;

typedef struct _tagADDRESS64 {
    DWORD64       Offset;
    WORD          Segment;
    ADDRESS_MODE  Mode;
} ADDRESS64, *LPADDRESS64;

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define ADDRESS ADDRESS64
#define LPADDRESS LPADDRESS64
#else
typedef struct _tagADDRESS {
    DWORD         Offset;
    WORD          Segment;
    ADDRESS_MODE  Mode;
} ADDRESS, *LPADDRESS;

__inline
void
Address32To64(
    LPADDRESS a32,
    LPADDRESS64 a64
    )
{
    a64->Offset = (ULONG64)(LONG64)(LONG)a32->Offset;
    a64->Segment = a32->Segment;
    a64->Mode = a32->Mode;
}

__inline
void
Address64To32(
    LPADDRESS64 a64,
    LPADDRESS a32
    )
{
    a32->Offset = (ULONG)a64->Offset;
    a32->Segment = a64->Segment;
    a32->Mode = a64->Mode;
}
#endif

//
// This structure is included in the STACKFRAME structure,
// and is used to trace through usermode callbacks in a thread's
// kernel stack.  The values must be copied by the kernel debugger
// from the DBGKD_GET_VERSION and WAIT_STATE_CHANGE packets.
//

//
// New KDHELP structure for 64 bit system support.
// This structure is preferred in new code.
//
typedef struct _KDHELP64 {

    //
    // address of kernel thread object, as provided in the
    // WAIT_STATE_CHANGE packet.
    //
    DWORD64   Thread;

    //
    // offset in thread object to pointer to the current callback frame
    // in kernel stack.
    //
    DWORD   ThCallbackStack;

    //
    // offset in thread object to pointer to the current callback backing
    // store frame in kernel stack.
    //
    DWORD   ThCallbackBStore;

    //
    // offsets to values in frame:
    //
    // address of next callback frame
    DWORD   NextCallback;

    // address of saved frame pointer (if applicable)
    DWORD   FramePointer;


    //
    // Address of the kernel function that calls out to user mode
    //
    DWORD64   KiCallUserMode;

    //
    // Address of the user mode dispatcher function
    //
    DWORD64   KeUserCallbackDispatcher;

    //
    // Lowest kernel mode address
    //
    DWORD64   SystemRangeStart;

    DWORD64  Reserved[8];

} KDHELP64, *PKDHELP64;

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define KDHELP KDHELP64
#define PKDHELP PKDHELP64
#else
typedef struct _KDHELP {

    //
    // address of kernel thread object, as provided in the
    // WAIT_STATE_CHANGE packet.
    //
    DWORD   Thread;

    //
    // offset in thread object to pointer to the current callback frame
    // in kernel stack.
    //
    DWORD   ThCallbackStack;

    //
    // offsets to values in frame:
    //
    // address of next callback frame
    DWORD   NextCallback;

    // address of saved frame pointer (if applicable)
    DWORD   FramePointer;

    //
    // Address of the kernel function that calls out to user mode
    //
    DWORD   KiCallUserMode;

    //
    // Address of the user mode dispatcher function
    //
    DWORD   KeUserCallbackDispatcher;

    //
    // Lowest kernel mode address
    //
    DWORD   SystemRangeStart;

    //
    // offset in thread object to pointer to the current callback backing
    // store frame in kernel stack.
    //
    DWORD   ThCallbackBStore;

    DWORD  Reserved[8];

} KDHELP, *PKDHELP;

__inline
void
KdHelp32To64(
    PKDHELP p32,
    PKDHELP64 p64
    )
{
    p64->Thread = p32->Thread;
    p64->ThCallbackStack = p32->ThCallbackStack;
    p64->NextCallback = p32->NextCallback;
    p64->FramePointer = p32->FramePointer;
    p64->KiCallUserMode = p32->KiCallUserMode;
    p64->KeUserCallbackDispatcher = p32->KeUserCallbackDispatcher;
    p64->SystemRangeStart = p32->SystemRangeStart;
}
#endif

typedef struct _tagSTACKFRAME64 {
    ADDRESS64   AddrPC;               // program counter
    ADDRESS64   AddrReturn;           // return address
    ADDRESS64   AddrFrame;            // frame pointer
    ADDRESS64   AddrStack;            // stack pointer
    ADDRESS64   AddrBStore;           // backing store pointer
    PVOID       FuncTableEntry;       // pointer to pdata/fpo or NULL
    DWORD64     Params[4];            // possible arguments to the function
    BOOL        Far;                  // WOW far call
    BOOL        Virtual;              // is this a virtual frame?
    DWORD64     Reserved[3];
    KDHELP64    KdHelp;
} STACKFRAME64, *LPSTACKFRAME64;

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define STACKFRAME STACKFRAME64
#define LPSTACKFRAME LPSTACKFRAME64
#else
typedef struct _tagSTACKFRAME {
    ADDRESS     AddrPC;               // program counter
    ADDRESS     AddrReturn;           // return address
    ADDRESS     AddrFrame;            // frame pointer
    ADDRESS     AddrStack;            // stack pointer
    PVOID       FuncTableEntry;       // pointer to pdata/fpo or NULL
    DWORD       Params[4];            // possible arguments to the function
    BOOL        Far;                  // WOW far call
    BOOL        Virtual;              // is this a virtual frame?
    DWORD       Reserved[3];
    KDHELP      KdHelp;
    ADDRESS     AddrBStore;           // backing store pointer
} STACKFRAME, *LPSTACKFRAME;
#endif


typedef
BOOL
(__stdcall *PREAD_PROCESS_MEMORY_ROUTINE64)(
    HANDLE      hProcess,
    DWORD64     qwBaseAddress,
    PVOID       lpBuffer,
    DWORD       nSize,
    LPDWORD     lpNumberOfBytesRead
    );

typedef
PVOID
(__stdcall *PFUNCTION_TABLE_ACCESS_ROUTINE64)(
    HANDLE  hProcess,
    DWORD64 AddrBase
    );

typedef
DWORD64
(__stdcall *PGET_MODULE_BASE_ROUTINE64)(
    HANDLE  hProcess,
    DWORD64 Address
    );

typedef
DWORD64
(__stdcall *PTRANSLATE_ADDRESS_ROUTINE64)(
    HANDLE    hProcess,
    HANDLE    hThread,
    LPADDRESS64 lpaddr
    );

BOOL
IMAGEAPI
StackWalk64(
    DWORD                             MachineType,
    HANDLE                            hProcess,
    HANDLE                            hThread,
    LPSTACKFRAME64                    StackFrame,
    PVOID                             ContextRecord,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemoryRoutine,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  FunctionTableAccessRoutine,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBaseRoutine,
    PTRANSLATE_ADDRESS_ROUTINE64      TranslateAddress
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)

#define PREAD_PROCESS_MEMORY_ROUTINE PREAD_PROCESS_MEMORY_ROUTINE64
#define PFUNCTION_TABLE_ACCESS_ROUTINE PFUNCTION_TABLE_ACCESS_ROUTINE64
#define PGET_MODULE_BASE_ROUTINE PGET_MODULE_BASE_ROUTINE64
#define PTRANSLATE_ADDRESS_ROUTINE PTRANSLATE_ADDRESS_ROUTINE64

#define StackWalk StackWalk64

#else

typedef
BOOL
(__stdcall *PREAD_PROCESS_MEMORY_ROUTINE)(
    HANDLE  hProcess,
    DWORD   lpBaseAddress,
    PVOID   lpBuffer,
    DWORD   nSize,
    PDWORD  lpNumberOfBytesRead
    );

typedef
PVOID
(__stdcall *PFUNCTION_TABLE_ACCESS_ROUTINE)(
    HANDLE  hProcess,
    DWORD   AddrBase
    );

typedef
DWORD
(__stdcall *PGET_MODULE_BASE_ROUTINE)(
    HANDLE  hProcess,
    DWORD   Address
    );

typedef
DWORD
(__stdcall *PTRANSLATE_ADDRESS_ROUTINE)(
    HANDLE    hProcess,
    HANDLE    hThread,
    LPADDRESS lpaddr
    );

BOOL
IMAGEAPI
StackWalk(
    DWORD                             MachineType,
    HANDLE                            hProcess,
    HANDLE                            hThread,
    LPSTACKFRAME                      StackFrame,
    PVOID                             ContextRecord,
    PREAD_PROCESS_MEMORY_ROUTINE      ReadMemoryRoutine,
    PFUNCTION_TABLE_ACCESS_ROUTINE    FunctionTableAccessRoutine,
    PGET_MODULE_BASE_ROUTINE          GetModuleBaseRoutine,
    PTRANSLATE_ADDRESS_ROUTINE        TranslateAddress
    );

#endif


#define API_VERSION_NUMBER 9

typedef struct API_VERSION {
    USHORT  MajorVersion;
    USHORT  MinorVersion;
    USHORT  Revision;
    USHORT  Reserved;
} API_VERSION, *LPAPI_VERSION;

LPAPI_VERSION
IMAGEAPI
ImagehlpApiVersion(
    VOID
    );

LPAPI_VERSION
IMAGEAPI
ImagehlpApiVersionEx(
    LPAPI_VERSION AppVersion
    );

DWORD
IMAGEAPI
GetTimestampForLoadedLibrary(
    HMODULE Module
    );

//
// typedefs for function pointers
//
typedef BOOL
(CALLBACK *PSYM_ENUMMODULES_CALLBACK64)(
    PSTR ModuleName,
    DWORD64 BaseOfDll,
    PVOID UserContext
    );

typedef BOOL
(CALLBACK *PSYM_ENUMSYMBOLS_CALLBACK64)(
    PSTR SymbolName,
    DWORD64 SymbolAddress,
    ULONG SymbolSize,
    PVOID UserContext
    );

typedef BOOL
(CALLBACK *PSYM_ENUMSYMBOLS_CALLBACK64W)(
    PWSTR SymbolName,
    DWORD64 SymbolAddress,
    ULONG SymbolSize,
    PVOID UserContext
    );

typedef BOOL
(CALLBACK *PENUMLOADED_MODULES_CALLBACK64)(
    PSTR ModuleName,
    DWORD64 ModuleBase,
    ULONG ModuleSize,
    PVOID UserContext
    );

typedef BOOL
(CALLBACK *PSYMBOL_REGISTERED_CALLBACK64)(
    HANDLE  hProcess,
    ULONG   ActionCode,
    ULONG64 CallbackData,
    ULONG64 UserContext
    );

typedef
PVOID
(CALLBACK *PSYMBOL_FUNCENTRY_CALLBACK)(
    HANDLE  hProcess,
    DWORD   AddrBase,
    PVOID   UserContext
    );

typedef
PVOID
(CALLBACK *PSYMBOL_FUNCENTRY_CALLBACK64)(
    HANDLE  hProcess,
    ULONG64 AddrBase,
    ULONG64 UserContext
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)

#define PSYM_ENUMMODULES_CALLBACK PSYM_ENUMMODULES_CALLBACK64
#define PSYM_ENUMSYMBOLS_CALLBACK PSYM_ENUMSYMBOLS_CALLBACK64
#define PSYM_ENUMSYMBOLS_CALLBACKW PSYM_ENUMSYMBOLS_CALLBACK64W
#define PENUMLOADED_MODULES_CALLBACK PENUMLOADED_MODULES_CALLBACK64
#define PSYMBOL_REGISTERED_CALLBACK PSYMBOL_REGISTERED_CALLBACK64
#define PSYMBOL_FUNCENTRY_CALLBACK PSYMBOL_FUNCENTRY_CALLBACK64

#else

typedef BOOL
(CALLBACK *PSYM_ENUMMODULES_CALLBACK)(
    PSTR  ModuleName,
    ULONG BaseOfDll,
    PVOID UserContext
    );

typedef BOOL
(CALLBACK *PSYM_ENUMSYMBOLS_CALLBACK)(
    PSTR  SymbolName,
    ULONG SymbolAddress,
    ULONG SymbolSize,
    PVOID UserContext
    );

typedef BOOL
(CALLBACK *PSYM_ENUMSYMBOLS_CALLBACKW)(
    PWSTR  SymbolName,
    ULONG SymbolAddress,
    ULONG SymbolSize,
    PVOID UserContext
    );

typedef BOOL
(CALLBACK *PENUMLOADED_MODULES_CALLBACK)(
    PSTR  ModuleName,
    ULONG ModuleBase,
    ULONG ModuleSize,
    PVOID UserContext
    );

typedef BOOL
(CALLBACK *PSYMBOL_REGISTERED_CALLBACK)(
    HANDLE  hProcess,
    ULONG   ActionCode,
    PVOID   CallbackData,
    PVOID   UserContext
    );

#endif


//
// symbol flags
//

#define SYMF_OMAP_GENERATED   0x00000001
#define SYMF_OMAP_MODIFIED    0x00000002

//
// symbol type enumeration
//
typedef enum {
    SymNone,
    SymCoff,
    SymCv,
    SymPdb,
    SymExport,
    SymDeferred,
    SymSym                  // .sym file
} SYM_TYPE;

//
// symbol data structure
//

typedef struct _IMAGEHLP_SYMBOL64 {
    DWORD                       SizeOfStruct;           // set to sizeof(IMAGEHLP_SYMBOL64)
    DWORD64                     Address;                // virtual address including dll base address
    DWORD                       Size;                   // estimated size of symbol, can be zero
    DWORD                       Flags;                  // info about the symbols, see the SYMF defines
    DWORD                       MaxNameLength;          // maximum size of symbol name in 'Name'
    CHAR                        Name[1];                // symbol name (null terminated string)
} IMAGEHLP_SYMBOL64, *PIMAGEHLP_SYMBOL64;

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define IMAGEHLP_SYMBOL IMAGEHLP_SYMBOL64
#define PIMAGEHLP_SYMBOL PIMAGEHLP_SYMBOL64
#else
typedef struct _IMAGEHLP_SYMBOL {
    DWORD                       SizeOfStruct;           // set to sizeof(IMAGEHLP_SYMBOL)
    DWORD                       Address;                // virtual address including dll base address
    DWORD                       Size;                   // estimated size of symbol, can be zero
    DWORD                       Flags;                  // info about the symbols, see the SYMF defines
    DWORD                       MaxNameLength;          // maximum size of symbol name in 'Name'
    CHAR                        Name[1];                // symbol name (null terminated string)
} IMAGEHLP_SYMBOL, *PIMAGEHLP_SYMBOL;
#endif

//
// module data structure
//

typedef struct _IMAGEHLP_MODULE64 {
    DWORD                       SizeOfStruct;           // set to sizeof(IMAGEHLP_MODULE64)
    DWORD64                     BaseOfImage;            // base load address of module
    DWORD                       ImageSize;              // virtual size of the loaded module
    DWORD                       TimeDateStamp;          // date/time stamp from pe header
    DWORD                       CheckSum;               // checksum from the pe header
    DWORD                       NumSyms;                // number of symbols in the symbol table
    SYM_TYPE                    SymType;                // type of symbols loaded
    CHAR                        ModuleName[32];         // module name
    CHAR                        ImageName[256];         // image name
    CHAR                        LoadedImageName[256];   // symbol file name
} IMAGEHLP_MODULE64, *PIMAGEHLP_MODULE64;

typedef struct _IMAGEHLP_MODULE64W {
    DWORD                       SizeOfStruct;           // set to sizeof(IMAGEHLP_MODULE64)
    DWORD64                     BaseOfImage;            // base load address of module
    DWORD                       ImageSize;              // virtual size of the loaded module
    DWORD                       TimeDateStamp;          // date/time stamp from pe header
    DWORD                       CheckSum;               // checksum from the pe header
    DWORD                       NumSyms;                // number of symbols in the symbol table
    SYM_TYPE                    SymType;                // type of symbols loaded
    WCHAR                       ModuleName[32];         // module name
    WCHAR                       ImageName[256];         // image name
    WCHAR                       LoadedImageName[256];   // symbol file name
} IMAGEHLP_MODULEW64, *PIMAGEHLP_MODULEW64;

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define IMAGEHLP_MODULE IMAGEHLP_MODULE64
#define PIMAGEHLP_MODULE PIMAGEHLP_MODULE64
#define IMAGEHLP_MODULEW IMAGEHLP_MODULEW64
#define PIMAGEHLP_MODULEW PIMAGEHLP_MODULEW64
#else
typedef struct _IMAGEHLP_MODULE {
    DWORD                       SizeOfStruct;           // set to sizeof(IMAGEHLP_MODULE)
    DWORD                       BaseOfImage;            // base load address of module
    DWORD                       ImageSize;              // virtual size of the loaded module
    DWORD                       TimeDateStamp;          // date/time stamp from pe header
    DWORD                       CheckSum;               // checksum from the pe header
    DWORD                       NumSyms;                // number of symbols in the symbol table
    SYM_TYPE                    SymType;                // type of symbols loaded
    CHAR                        ModuleName[32];         // module name
    CHAR                        ImageName[256];         // image name
    CHAR                        LoadedImageName[256];   // symbol file name
} IMAGEHLP_MODULE, *PIMAGEHLP_MODULE;

typedef struct _IMAGEHLP_MODULEW {
    DWORD                       SizeOfStruct;           // set to sizeof(IMAGEHLP_MODULE)
    DWORD                       BaseOfImage;            // base load address of module
    DWORD                       ImageSize;              // virtual size of the loaded module
    DWORD                       TimeDateStamp;          // date/time stamp from pe header
    DWORD                       CheckSum;               // checksum from the pe header
    DWORD                       NumSyms;                // number of symbols in the symbol table
    SYM_TYPE                    SymType;                // type of symbols loaded
    WCHAR                       ModuleName[32];         // module name
    WCHAR                       ImageName[256];         // image name
    WCHAR                       LoadedImageName[256];   // symbol file name
} IMAGEHLP_MODULEW, *PIMAGEHLP_MODULEW;
#endif

//
// source file line data structure
//

typedef struct _IMAGEHLP_LINE64 {
    DWORD                       SizeOfStruct;           // set to sizeof(IMAGEHLP_LINE64)
    PVOID                       Key;                    // internal
    DWORD                       LineNumber;             // line number in file
    PCHAR                       FileName;               // full filename
    DWORD64                     Address;                // first instruction of line
} IMAGEHLP_LINE64, *PIMAGEHLP_LINE64;

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define IMAGEHLP_LINE IMAGEHLP_LINE64
#define PIMAGEHLP_LINE PIMAGEHLP_LINE64
#else
typedef struct _IMAGEHLP_LINE {
    DWORD                       SizeOfStruct;           // set to sizeof(IMAGEHLP_LINE)
    PVOID                       Key;                    // internal
    DWORD                       LineNumber;             // line number in file
    PCHAR                       FileName;               // full filename
    DWORD                       Address;                // first instruction of line
} IMAGEHLP_LINE, *PIMAGEHLP_LINE;
#endif

//
// data structures used for registered symbol callbacks
//

#define CBA_DEFERRED_SYMBOL_LOAD_START          0x00000001
#define CBA_DEFERRED_SYMBOL_LOAD_COMPLETE       0x00000002
#define CBA_DEFERRED_SYMBOL_LOAD_FAILURE        0x00000003
#define CBA_SYMBOLS_UNLOADED                    0x00000004
#define CBA_DUPLICATE_SYMBOL                    0x00000005
#define CBA_READ_MEMORY                         0x00000006
#define CBA_DEBUG_INFO                          0x10000000

typedef struct _IMAGEHLP_CBA_READ_MEMORY {
    DWORD64   addr;                                     // address to read from
    PVOID     buf;                                      // buffer to read to
    DWORD     bytes;                                    // amount of bytes to read
    DWORD    *bytesread;                                // pointer to store amount of bytes read
} IMAGEHLP_CBA_READ_MEMORY, *PIMAGEHLP_CBA_READ_MEMORY;

typedef struct _IMAGEHLP_DEFERRED_SYMBOL_LOAD64 {
    DWORD                       SizeOfStruct;           // set to sizeof(IMAGEHLP_DEFERRED_SYMBOL_LOAD64)
    DWORD64                     BaseOfImage;            // base load address of module
    DWORD                       CheckSum;               // checksum from the pe header
    DWORD                       TimeDateStamp;          // date/time stamp from pe header
    CHAR                        FileName[MAX_PATH];     // symbols file or image name
    BOOLEAN                     Reparse;                // load failure reparse
} IMAGEHLP_DEFERRED_SYMBOL_LOAD64, *PIMAGEHLP_DEFERRED_SYMBOL_LOAD64;

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define IMAGEHLP_DEFERRED_SYMBOL_LOAD IMAGEHLP_DEFERRED_SYMBOL_LOAD64
#define PIMAGEHLP_DEFERRED_SYMBOL_LOAD PIMAGEHLP_DEFERRED_SYMBOL_LOAD64
#else
typedef struct _IMAGEHLP_DEFERRED_SYMBOL_LOAD {
    DWORD                       SizeOfStruct;           // set to sizeof(IMAGEHLP_DEFERRED_SYMBOL_LOAD)
    DWORD                       BaseOfImage;            // base load address of module
    DWORD                       CheckSum;               // checksum from the pe header
    DWORD                       TimeDateStamp;          // date/time stamp from pe header
    CHAR                        FileName[MAX_PATH];     // symbols file or image name
    BOOLEAN                     Reparse;                // load failure reparse
} IMAGEHLP_DEFERRED_SYMBOL_LOAD, *PIMAGEHLP_DEFERRED_SYMBOL_LOAD;
#endif

typedef struct _IMAGEHLP_DUPLICATE_SYMBOL64 {
    DWORD                       SizeOfStruct;           // set to sizeof(IMAGEHLP_DUPLICATE_SYMBOL64)
    DWORD                       NumberOfDups;           // number of duplicates in the Symbol array
    PIMAGEHLP_SYMBOL64          Symbol;                 // array of duplicate symbols
    DWORD                       SelectedSymbol;         // symbol selected (-1 to start)
} IMAGEHLP_DUPLICATE_SYMBOL64, *PIMAGEHLP_DUPLICATE_SYMBOL64;

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define IMAGEHLP_DUPLICATE_SYMBOL IMAGEHLP_DUPLICATE_SYMBOL64
#define PIMAGEHLP_DUPLICATE_SYMBOL PIMAGEHLP_DUPLICATE_SYMBOL64
#else
typedef struct _IMAGEHLP_DUPLICATE_SYMBOL {
    DWORD                       SizeOfStruct;           // set to sizeof(IMAGEHLP_DUPLICATE_SYMBOL)
    DWORD                       NumberOfDups;           // number of duplicates in the Symbol array
    PIMAGEHLP_SYMBOL            Symbol;                 // array of duplicate symbols
    DWORD                       SelectedSymbol;         // symbol selected (-1 to start)
} IMAGEHLP_DUPLICATE_SYMBOL, *PIMAGEHLP_DUPLICATE_SYMBOL;
#endif


//
// options that are set/returned by SymSetOptions() & SymGetOptions()
// these are used as a mask
//
#define SYMOPT_CASE_INSENSITIVE  0x00000001
#define SYMOPT_UNDNAME           0x00000002
#define SYMOPT_DEFERRED_LOADS    0x00000004
#define SYMOPT_NO_CPP            0x00000008
#define SYMOPT_LOAD_LINES        0x00000010
#define SYMOPT_OMAP_FIND_NEAREST 0x00000020
#define SYMOPT_DEBUG             0x80000000


DWORD
IMAGEAPI
SymSetOptions(
    IN DWORD   SymOptions
    );

DWORD
IMAGEAPI
SymGetOptions(
    VOID
    );

BOOL
IMAGEAPI
SymCleanup(
    IN HANDLE hProcess
    );

BOOL
IMAGEAPI
SymEnumerateModules64(
    IN HANDLE                       hProcess,
    IN PSYM_ENUMMODULES_CALLBACK64  EnumModulesCallback,
    IN PVOID                        UserContext
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymEnumerateModules SymEnumerateModules64
#else
BOOL
IMAGEAPI
SymEnumerateModules(
    IN HANDLE                     hProcess,
    IN PSYM_ENUMMODULES_CALLBACK  EnumModulesCallback,
    IN PVOID                      UserContext
    );
#endif

BOOL
IMAGEAPI
SymEnumerateSymbols64(
    IN HANDLE                       hProcess,
    IN DWORD64                      BaseOfDll,
    IN PSYM_ENUMSYMBOLS_CALLBACK64  EnumSymbolsCallback,
    IN PVOID                        UserContext
    );

BOOL
IMAGEAPI
SymEnumerateSymbolsW64(
    IN HANDLE                       hProcess,
    IN DWORD64                      BaseOfDll,
    IN PSYM_ENUMSYMBOLS_CALLBACK64W EnumSymbolsCallback,
    IN PVOID                        UserContext
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymEnumerateSymbols SymEnumerateSymbols64
#define SymEnumerateSymbolsW SymEnumerateSymbolsW64
#else
BOOL
IMAGEAPI
SymEnumerateSymbols(
    IN HANDLE                     hProcess,
    IN DWORD                      BaseOfDll,
    IN PSYM_ENUMSYMBOLS_CALLBACK  EnumSymbolsCallback,
    IN PVOID                      UserContext
    );

BOOL
IMAGEAPI
SymEnumerateSymbolsW(
    IN HANDLE                       hProcess,
    IN DWORD                        BaseOfDll,
    IN PSYM_ENUMSYMBOLS_CALLBACKW   EnumSymbolsCallback,
    IN PVOID                        UserContext
    );
#endif

BOOL
IMAGEAPI
EnumerateLoadedModules64(
    IN HANDLE                           hProcess,
    IN PENUMLOADED_MODULES_CALLBACK64   EnumLoadedModulesCallback,
    IN PVOID                            UserContext
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define EnumerateLoadedModules EnumerateLoadedModules64
#else
BOOL
IMAGEAPI
EnumerateLoadedModules(
    IN HANDLE                         hProcess,
    IN PENUMLOADED_MODULES_CALLBACK   EnumLoadedModulesCallback,
    IN PVOID                          UserContext
    );
#endif

PVOID
IMAGEAPI
SymFunctionTableAccess64(
    HANDLE  hProcess,
    DWORD64 AddrBase
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymFunctionTableAccess SymFunctionTableAccess64
#else
PVOID
IMAGEAPI
SymFunctionTableAccess(
    HANDLE  hProcess,
    DWORD   AddrBase
    );
#endif

BOOL
IMAGEAPI
SymGetModuleInfo64(
    IN  HANDLE                  hProcess,
    IN  DWORD64                 qwAddr,
    OUT PIMAGEHLP_MODULE64      ModuleInfo
    );

BOOL
IMAGEAPI
SymGetModuleInfoW64(
    IN  HANDLE                  hProcess,
    IN  DWORD64                 qwAddr,
    OUT PIMAGEHLP_MODULEW64     ModuleInfo
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetModuleInfo   SymGetModuleInfo64
#define SymGetModuleInfoW  SymGetModuleInfoW64
#else
BOOL
IMAGEAPI
SymGetModuleInfo(
    IN  HANDLE              hProcess,
    IN  DWORD               dwAddr,
    OUT PIMAGEHLP_MODULE  ModuleInfo
    );

BOOL
IMAGEAPI
SymGetModuleInfoW(
    IN  HANDLE              hProcess,
    IN  DWORD               dwAddr,
    OUT PIMAGEHLP_MODULEW  ModuleInfo
    );
#endif

DWORD64
IMAGEAPI
SymGetModuleBase64(
    IN  HANDLE              hProcess,
    IN  DWORD64             qwAddr
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetModuleBase SymGetModuleBase64
#else
DWORD
IMAGEAPI
SymGetModuleBase(
    IN  HANDLE              hProcess,
    IN  DWORD               dwAddr
    );
#endif

BOOL
IMAGEAPI
SymGetSymFromAddr64(
    IN  HANDLE              hProcess,
    IN  DWORD64             qwAddr,
    OUT PDWORD64            pdwDisplacement,
    OUT PIMAGEHLP_SYMBOL64  Symbol
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetSymFromAddr SymGetSymFromAddr64
#else
BOOL
IMAGEAPI
SymGetSymFromAddr(
    IN  HANDLE            hProcess,
    IN  DWORD             dwAddr,
    OUT PDWORD            pdwDisplacement,
    OUT PIMAGEHLP_SYMBOL  Symbol
    );
#endif

BOOL
IMAGEAPI
SymGetSymFromName64(
    IN  HANDLE              hProcess,
    IN  PSTR                Name,
    OUT PIMAGEHLP_SYMBOL64  Symbol
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetSymFromName SymGetSymFromName64
#else
BOOL
IMAGEAPI
SymGetSymFromName(
    IN  HANDLE            hProcess,
    IN  PSTR              Name,
    OUT PIMAGEHLP_SYMBOL  Symbol
    );
#endif

BOOL
IMAGEAPI
SymGetSymNext64(
    IN     HANDLE              hProcess,
    IN OUT PIMAGEHLP_SYMBOL64  Symbol
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetSymNext SymGetSymNext64
#else
BOOL
IMAGEAPI
SymGetSymNext(
    IN     HANDLE            hProcess,
    IN OUT PIMAGEHLP_SYMBOL  Symbol
    );
#endif

BOOL
IMAGEAPI
SymGetSymPrev64(
    IN     HANDLE              hProcess,
    IN OUT PIMAGEHLP_SYMBOL64  Symbol
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetSymPrev SymGetSymPrev64
#else
BOOL
IMAGEAPI
SymGetSymPrev(
    IN     HANDLE            hProcess,
    IN OUT PIMAGEHLP_SYMBOL  Symbol
    );
#endif

BOOL
IMAGEAPI
SymGetLineFromAddr64(
    IN  HANDLE                  hProcess,
    IN  DWORD64                 qwAddr,
    OUT PDWORD                  pdwDisplacement,
    OUT PIMAGEHLP_LINE64        Line
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetLineFromAddr SymGetLineFromAddr64
#else
BOOL
IMAGEAPI
SymGetLineFromAddr(
    IN  HANDLE                hProcess,
    IN  DWORD                 dwAddr,
    OUT PDWORD                pdwDisplacement,
    OUT PIMAGEHLP_LINE        Line
    );
#endif

BOOL
IMAGEAPI
SymGetLineFromName64(
    IN     HANDLE               hProcess,
    IN     PSTR                 ModuleName,
    IN     PSTR                 FileName,
    IN     DWORD                dwLineNumber,
       OUT PLONG                plDisplacement,
    IN OUT PIMAGEHLP_LINE64     Line
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetLineFromName SymGetLineFromName64
#else
BOOL
IMAGEAPI
SymGetLineFromName(
    IN     HANDLE             hProcess,
    IN     PSTR               ModuleName,
    IN     PSTR               FileName,
    IN     DWORD              dwLineNumber,
       OUT PLONG              plDisplacement,
    IN OUT PIMAGEHLP_LINE     Line
    );
#endif

BOOL
IMAGEAPI
SymGetLineNext64(
    IN     HANDLE               hProcess,
    IN OUT PIMAGEHLP_LINE64     Line
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetLineNext SymGetLineNext64
#else
BOOL
IMAGEAPI
SymGetLineNext(
    IN     HANDLE             hProcess,
    IN OUT PIMAGEHLP_LINE     Line
    );
#endif

BOOL
IMAGEAPI
SymGetLinePrev64(
    IN     HANDLE               hProcess,
    IN OUT PIMAGEHLP_LINE64     Line
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetLinePrev SymGetLinePrev64
#else
BOOL
IMAGEAPI
SymGetLinePrev(
    IN     HANDLE             hProcess,
    IN OUT PIMAGEHLP_LINE     Line
    );
#endif

BOOL
IMAGEAPI
SymMatchFileName(
    IN  PSTR  FileName,
    IN  PSTR  Match,
    OUT PSTR *FileNameStop,
    OUT PSTR *MatchStop
    );

BOOL
IMAGEAPI
SymInitialize(
    IN HANDLE   hProcess,
    IN PSTR     UserSearchPath,
    IN BOOL     fInvadeProcess
    );

BOOL
IMAGEAPI
SymGetSearchPath(
    IN  HANDLE          hProcess,
    OUT PSTR            SearchPath,
    IN  DWORD           SearchPathLength
    );

BOOL
IMAGEAPI
SymSetSearchPath(
    IN HANDLE           hProcess,
    IN PSTR             SearchPath
    );

DWORD64
IMAGEAPI
SymLoadModule64(
    IN  HANDLE          hProcess,
    IN  HANDLE          hFile,
    IN  PSTR            ImageName,
    IN  PSTR            ModuleName,
    IN  DWORD64         BaseOfDll,
    IN  DWORD           SizeOfDll
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymLoadModule SymLoadModule64
#else
DWORD
IMAGEAPI
SymLoadModule(
    IN  HANDLE          hProcess,
    IN  HANDLE          hFile,
    IN  PSTR            ImageName,
    IN  PSTR            ModuleName,
    IN  DWORD           BaseOfDll,
    IN  DWORD           SizeOfDll
    );
#endif

BOOL
IMAGEAPI
SymUnloadModule64(
    IN  HANDLE          hProcess,
    IN  DWORD64         BaseOfDll
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymUnloadModule SymUnloadModule64
#else
BOOL
IMAGEAPI
SymUnloadModule(
    IN  HANDLE          hProcess,
    IN  DWORD           BaseOfDll
    );
#endif

BOOL
IMAGEAPI
SymUnDName64(
    IN  PIMAGEHLP_SYMBOL64 sym,               // Symbol to undecorate
    OUT PSTR               UnDecName,         // Buffer to store undecorated name in
    IN  DWORD              UnDecNameLength    // Size of the buffer
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymUnDName SymUnDName64
#else
BOOL
IMAGEAPI
SymUnDName(
    IN  PIMAGEHLP_SYMBOL sym,               // Symbol to undecorate
    OUT PSTR             UnDecName,         // Buffer to store undecorated name in
    IN  DWORD            UnDecNameLength    // Size of the buffer
    );
#endif

BOOL
IMAGEAPI
SymRegisterCallback64(
    IN HANDLE                        hProcess,
    IN PSYMBOL_REGISTERED_CALLBACK64 CallbackFunction,
    IN ULONG64                       UserContext
    );

BOOL
IMAGEAPI
SymRegisterFunctionEntryCallback64(
    IN HANDLE                       hProcess,
    IN PSYMBOL_FUNCENTRY_CALLBACK64 CallbackFunction,
    IN ULONG64                      UserContext
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymRegisterCallback SymRegisterCallback64
#define SymRegisterFunctionEntryCallback SymRegisterFunctionEntryCallback64
#else
BOOL
IMAGEAPI
SymRegisterCallback(
    IN HANDLE                      hProcess,
    IN PSYMBOL_REGISTERED_CALLBACK CallbackFunction,
    IN PVOID                       UserContext
    );

BOOL
IMAGEAPI
SymRegisterFunctionEntryCallback(
    IN HANDLE                     hProcess,
    IN PSYMBOL_FUNCENTRY_CALLBACK CallbackFunction,
    IN PVOID                      UserContext
    );
#endif

#ifdef __cplusplus
}
#endif

// Structure types
typedef enum IMAGEHLP_TYPES {
   IMAGEHLP_TYPEID_INDEX = 1,
   IMAGEHLP_TYPEID_NAME,
   IMAGEHLP_TYPEID_IMAGEHLP_SYMBOL,
   IMAGEHLP_TYPEID_IMAGEHLP_SYMBOL64,
   IMAGEHLP_TYPEID_MODULE_TYPE_INFO,
   IMAGEHLP_TYPEID_TYPE_ENUM_INFO, 
} IMAGEHLP_TYPES;

typedef struct _MODULE_TYPE_INFO { // AKA TYPTYP 
    USHORT      dataLength;        
    USHORT      leaf;
    BYTE        data[1];
} MODULE_TYPE_INFO, *PMODULE_TYPE_INFO;

typedef BOOL
(CALLBACK *PSYMBOL_TYPE_NAME_CALLBACK)(
    PSTR  MatchedName,
    ULONG typeIndex,
    PVOID CallerData
    );

typedef struct _TYPE_ENUM_INFO {
   PVOID   CallerData;
   PSYMBOL_TYPE_NAME_CALLBACK CallbackRoutine;
} TYPE_ENUM_INFO, *PTYPE_ENUM_INFO;



BOOL
IMAGEAPI
SymGetModuleInfoEx64(
    IN  HANDLE          hProcess,
    IN  DWORD64         Address,
    IN  IMAGEHLP_TYPES  TypeIn,
    IN  PBYTE           DataIn,
    IN  IMAGEHLP_TYPES  TypeOut,
    IN  OUT PULONG      SizeOut,
    IN  OUT PBYTE       DataOut
    );
#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetModuleInfoEx SymGetModuleInfoEx64
#else
BOOL
IMAGEAPI
SymGetModuleInfoEx(
    IN  HANDLE          hProcess,
    IN  DWORD           Address,
    IN  IMAGEHLP_TYPES  TypeIn,
    IN  PBYTE           DataIn,
    IN  IMAGEHLP_TYPES  TypeOut,
    IN  OUT PULONG      SizeOut,
    IN  OUT PBYTE       DataOut
    );
#endif

BOOL 
IMAGEAPI
SymGetSymbolInfo64(
    IN  HANDLE          hProcess,
    IN  DWORD64         Address,
    IN  IMAGEHLP_TYPES  TypeIn,
    IN  PBYTE           DataIn,
    IN  IMAGEHLP_TYPES  TypeOut,
    IN  OUT PULONG      SizeOut,
    IN  OUT PBYTE       DataOut
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetSymbolInfo SymGetSymbolInfo64
#else
BOOL 
IMAGEAPI
SymGetSymbolInfo(
    IN  HANDLE          hProcess,
    IN  DWORD           Address,
    IN  IMAGEHLP_TYPES  TypeIn,
    IN  PBYTE           DataIn,
    IN  IMAGEHLP_TYPES  TypeOut,
    IN  PULONG          SizeOut,
    IN  OUT PBYTE       DataOut
    );
#endif
   

#endif // _DGGHELP_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\dbt.h ===
/*****************************************************************************
 *
 *  (C) Copyright 1993 - 1999 Microsoft Corporation
 *
 *  Title:      DBT.H - Equates for WM_DEVICECHANGE and BroadcastSystemMessage
 *
 *  Version:    4.00
 *
 *  Date:       24-May-1993
 *
 *  Author:     rjc
 *
 *----------------------------------------------------------------------------
 *
 *  Change log:
 *
 *     DATE     REV                 DESCRIPTION
 *  ----------- --- ----------------------------------------------------------
 *
 *****************************************************************************/

#ifndef _DBT_H
#define _DBT_H

/*
 * BroadcastSpecialMessage constants.
 */
#define WM_DEVICECHANGE         0x0219

/* XLATOFF */
#ifdef  IS_32
#define DBTFAR
#else
#define DBTFAR  far
#endif
/* XLATON */

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

#ifndef GUID_DEFINED
    #define GUID_DEFINED
    typedef struct _GUID {
        ULONG   Data1;
        unsigned short Data2;
        unsigned short Data3;
        unsigned char Data4[8];
    } GUID;
#endif // !defined(GUID_DEFINED)

/*
 * Broadcast message and receipient flags.
 *
 * Note that there is a third "flag". If the wParam has:
 *
 * bit 15 on:   lparam is a pointer and bit 14 is meaningfull.
 * bit 15 off:  lparam is just a UNLONG data type.
 *
 * bit 14 on:   lparam is a pointer to an ASCIIZ string.
 * bit 14 off:  lparam is a pointer to a binary struture starting with
 *              a dword describing the length of the structure.
 */
#define BSF_QUERY               0x00000001
#define BSF_IGNORECURRENTTASK   0x00000002      /* Meaningless for VxDs */
#define BSF_FLUSHDISK           0x00000004      /* Shouldn't be used by VxDs */
#define BSF_NOHANG              0x00000008
#define BSF_POSTMESSAGE         0x00000010
#define BSF_FORCEIFHUNG         0x00000020
#define BSF_NOTIMEOUTIFNOTHUNG  0x00000040
#define BSF_MSGSRV32ISOK        0x80000000      /* Called synchronously from PM API */
#define BSF_MSGSRV32ISOK_BIT    31              /* Called synchronously from PM API */

#define BSM_ALLCOMPONENTS       0x00000000
#define BSM_VXDS                0x00000001
#define BSM_NETDRIVER           0x00000002
#define BSM_INSTALLABLEDRIVERS  0x00000004
#define BSM_APPLICATIONS        0x00000008

/*
 * Message = WM_DEVICECHANGE
 * wParam  = DBT_APPYBEGIN
 * lParam  = (not used)
 *
 *      'Appy-time is now available.  This message is itself sent
 *      at 'Appy-time.
 *
 * Message = WM_DEVICECHANGE
 * wParam  = DBT_APPYEND
 * lParam  = (not used)
 *
 *      'Appy-time is no longer available.  This message is *NOT* sent
 *      at 'Appy-time.  (It cannot be, because 'Appy-time is gone.)
 *
 * NOTE!  It is possible for DBT_APPYBEGIN and DBT_APPYEND to be sent
 * multiple times during a single Windows session.  Each appearance of
 * 'Appy-time is bracketed by these two messages, but 'Appy-time may
 * momentarily become unavailable during otherwise normal Windows
 * processing.  The current status of 'Appy-time availability can always
 * be obtained from a call to _SHELL_QueryAppyTimeAvailable.
 */
#define DBT_APPYBEGIN                   0x0000
#define DBT_APPYEND                     0x0001

/*
 * Message = WM_DEVICECHANGE
 * wParam  = DBT_DEVNODES_CHANGED
 * lParam  = 0
 *
 *      send when configmg finished a process tree batch. Some devnodes
 *      may have been added or removed. This is used by ring3 people which
 *      need to be refreshed whenever any devnode changed occur (like
 *      device manager). People specific to certain devices should use
 *      DBT_DEVICE* instead.
 */

#define DBT_DEVNODES_CHANGED            0x0007

/*
 * Message = WM_DEVICECHANGE
 * wParam  = DBT_QUERYCHANGECONFIG
 * lParam  = 0
 *
 *      sent to ask if a config change is allowed
 */

#define DBT_QUERYCHANGECONFIG           0x0017

/*
 * Message = WM_DEVICECHANGE
 * wParam  = DBT_CONFIGCHANGED
 * lParam  = 0
 *
 *      sent when a config has changed
 */

#define DBT_CONFIGCHANGED               0x0018

/*
 * Message = WM_DEVICECHANGE
 * wParam  = DBT_CONFIGCHANGECANCELED
 * lParam  = 0
 *
 *      someone cancelled the config change
 */

#define DBT_CONFIGCHANGECANCELED        0x0019

/*
 * Message = WM_DEVICECHANGE
 * wParam  = DBT_MONITORCHANGE
 * lParam  = new resolution to use (LOWORD=x, HIWORD=y)
 *           if 0, use the default res for current config
 *
 *      this message is sent when the display monitor has changed
 *      and the system should change the display mode to match it.
 */

#define DBT_MONITORCHANGE               0x001B

/*
 * Message = WM_DEVICECHANGE
 * wParam  = DBT_SHELLLOGGEDON
 * lParam  = 0
 *
 *      The shell has finished login on: VxD can now do Shell_EXEC.
 */

#define DBT_SHELLLOGGEDON               0x0020

/*
 * Message = WM_DEVICECHANGE
 * wParam  = DBT_CONFIGMGAPI
 * lParam  = CONFIGMG API Packet
 *
 *      CONFIGMG ring 3 call.
 */
#define DBT_CONFIGMGAPI32               0x0022

/*
 * Message = WM_DEVICECHANGE
 * wParam  = DBT_VXDINITCOMPLETE
 * lParam  = 0
 *
 *      CONFIGMG ring 3 call.
 */
#define DBT_VXDINITCOMPLETE             0x0023

/*
 * Message = WM_DEVICECHANGE
 * wParam  = DBT_VOLLOCK*
 * lParam  = pointer to VolLockBroadcast structure described below
 *
 *      Messages issued by IFSMGR for volume locking purposes on WM_DEVICECHANGE.
 *      All these messages pass a pointer to a struct which has no pointers.
 */

#define DBT_VOLLOCKQUERYLOCK    0x8041
#define DBT_VOLLOCKLOCKTAKEN    0x8042
#define DBT_VOLLOCKLOCKFAILED   0x8043
#define DBT_VOLLOCKQUERYUNLOCK  0x8044
#define DBT_VOLLOCKLOCKRELEASED 0x8045
#define DBT_VOLLOCKUNLOCKFAILED 0x8046

/*
 * Device broadcast header
 */

struct _DEV_BROADCAST_HDR {     /* */
    DWORD       dbch_size;
    DWORD       dbch_devicetype;
    DWORD       dbch_reserved;
};

typedef struct  _DEV_BROADCAST_HDR      DEV_BROADCAST_HDR;
typedef         DEV_BROADCAST_HDR       DBTFAR *PDEV_BROADCAST_HDR;

/*
 * Structure for volume lock broadcast
 */

typedef struct VolLockBroadcast VolLockBroadcast;
typedef VolLockBroadcast *pVolLockBroadcast;
struct VolLockBroadcast {
        struct  _DEV_BROADCAST_HDR vlb_dbh;
        DWORD   vlb_owner;              // thread on which lock request is being issued
        BYTE    vlb_perms;              // lock permission flags defined below
        BYTE    vlb_lockType;           // type of lock
        BYTE    vlb_drive;              // drive on which lock is issued
        BYTE    vlb_flags;              // miscellaneous flags
};

/*
 * Values for vlb_perms
 */
#define LOCKP_ALLOW_WRITES              0x01    // Bit 0 set - allow writes
#define LOCKP_FAIL_WRITES               0x00    // Bit 0 clear - fail writes
#define LOCKP_FAIL_MEM_MAPPING          0x02    // Bit 1 set - fail memory mappings
#define LOCKP_ALLOW_MEM_MAPPING         0x00    // Bit 1 clear - allow memory mappings
#define LOCKP_USER_MASK                 0x03    // Mask for user lock flags
#define LOCKP_LOCK_FOR_FORMAT           0x04    // Level 0 lock for format

/*
 * Values for vlb_flags
 */
#define LOCKF_LOGICAL_LOCK              0x00    // Bit 0 clear - logical lock
#define LOCKF_PHYSICAL_LOCK             0x01    // Bit 0 set - physical lock

/*
 * Message = WM_DEVICECHANGE
 * wParam  = DBT_NODISKSPACE
 * lParam  = drive number of drive that is out of disk space (1-based)
 *
 * Message issued by IFS manager when it detects that a drive is run out of
 * free space.
 */

#define DBT_NO_DISK_SPACE               0x0047

/*
 * Message = WM_DEVICECHANGE
 * wParam  = DBT_LOW_DISK_SPACE
 * lParam  = drive number of drive that is low on disk space (1-based)
 *
 * Message issued by VFAT when it detects that a drive it has mounted
 * has the remaning free space below a threshold specified by the
 * registry or by a disk space management application.
 * The broadcast is issued by VFAT ONLY when space is either allocated
 * or freed by VFAT.
 */

#define DBT_LOW_DISK_SPACE      0x0048

#define DBT_CONFIGMGPRIVATE             0x7FFF

/*
 * The following messages are for WM_DEVICECHANGE. The immediate list
 * is for the wParam. ALL THESE MESSAGES PASS A POINTER TO A STRUCT
 * STARTING WITH A DWORD SIZE AND HAVING NO POINTER IN THE STRUCT.
 *
 */
#define DBT_DEVICEARRIVAL               0x8000  // system detected a new device
#define DBT_DEVICEQUERYREMOVE           0x8001  // wants to remove, may fail
#define DBT_DEVICEQUERYREMOVEFAILED     0x8002  // removal aborted
#define DBT_DEVICEREMOVEPENDING         0x8003  // about to remove, still avail.
#define DBT_DEVICEREMOVECOMPLETE        0x8004  // device is gone
#define DBT_DEVICETYPESPECIFIC          0x8005  // type specific event
#if(WINVER >= 0x040A)
#define DBT_CUSTOMEVENT                 0x8006  // user-defined event
#endif /* WINVER >= 0x040A */

#define DBT_DEVTYP_OEM                  0x00000000  // oem-defined device type
#define DBT_DEVTYP_DEVNODE              0x00000001  // devnode number
#define DBT_DEVTYP_VOLUME               0x00000002  // logical volume
#define DBT_DEVTYP_PORT                 0x00000003  // serial, parallel
#define DBT_DEVTYP_NET                  0x00000004  // network resource

#if(WINVER >= 0x040A)
#define DBT_DEVTYP_DEVICEINTERFACE      0x00000005  // device interface class
#define DBT_DEVTYP_HANDLE               0x00000006  // file system handle
#endif /* WINVER >= 0x040A */

struct _DEV_BROADCAST_HEADER { /* */
    DWORD       dbcd_size;
    DWORD       dbcd_devicetype;
    DWORD       dbcd_reserved;
};

struct _DEV_BROADCAST_OEM {     /* */
    DWORD       dbco_size;
    DWORD       dbco_devicetype;
    DWORD       dbco_reserved;
    DWORD       dbco_identifier;
    DWORD       dbco_suppfunc;
};

typedef struct  _DEV_BROADCAST_OEM      DEV_BROADCAST_OEM;
typedef         DEV_BROADCAST_OEM       DBTFAR *PDEV_BROADCAST_OEM;

struct _DEV_BROADCAST_DEVNODE { /* */
    DWORD       dbcd_size;
    DWORD       dbcd_devicetype;
    DWORD       dbcd_reserved;
    DWORD       dbcd_devnode;
};

typedef struct  _DEV_BROADCAST_DEVNODE  DEV_BROADCAST_DEVNODE;
typedef         DEV_BROADCAST_DEVNODE   DBTFAR *PDEV_BROADCAST_DEVNODE;

struct _DEV_BROADCAST_VOLUME { /* */
    DWORD       dbcv_size;
    DWORD       dbcv_devicetype;
    DWORD       dbcv_reserved;
    DWORD       dbcv_unitmask;
    WORD        dbcv_flags;
};

typedef struct  _DEV_BROADCAST_VOLUME   DEV_BROADCAST_VOLUME;
typedef         DEV_BROADCAST_VOLUME    DBTFAR *PDEV_BROADCAST_VOLUME;

#define DBTF_MEDIA      0x0001          // media comings and goings
#define DBTF_NET        0x0002          // network volume

typedef struct _DEV_BROADCAST_PORT_A {
    DWORD       dbcp_size;
    DWORD       dbcp_devicetype;
    DWORD       dbcp_reserved;
    char        dbcp_name[1];
} DEV_BROADCAST_PORT_A, *PDEV_BROADCAST_PORT_A;

typedef struct _DEV_BROADCAST_PORT_W {
    DWORD       dbcp_size;
    DWORD       dbcp_devicetype;
    DWORD       dbcp_reserved;
    wchar_t     dbcp_name[1];
} DEV_BROADCAST_PORT_W, DBTFAR *PDEV_BROADCAST_PORT_W;

#ifdef UNICODE
typedef DEV_BROADCAST_PORT_W     DEV_BROADCAST_PORT;
typedef PDEV_BROADCAST_PORT_W    PDEV_BROADCAST_PORT;
#else
typedef DEV_BROADCAST_PORT_A     DEV_BROADCAST_PORT;
typedef PDEV_BROADCAST_PORT_A    PDEV_BROADCAST_PORT;
#endif

struct _DEV_BROADCAST_NET { /* */
    DWORD       dbcn_size;
    DWORD       dbcn_devicetype;
    DWORD       dbcn_reserved;
    DWORD       dbcn_resource;
    DWORD       dbcn_flags;
};

typedef struct  _DEV_BROADCAST_NET      DEV_BROADCAST_NET;
typedef         DEV_BROADCAST_NET       DBTFAR *PDEV_BROADCAST_NET;

#if(WINVER >= 0x040A)

typedef struct _DEV_BROADCAST_DEVICEINTERFACE_A {
    DWORD       dbcc_size;
    DWORD       dbcc_devicetype;
    DWORD       dbcc_reserved;
    GUID        dbcc_classguid;
    char        dbcc_name[1];
} DEV_BROADCAST_DEVICEINTERFACE_A, *PDEV_BROADCAST_DEVICEINTERFACE_A;

typedef struct _DEV_BROADCAST_DEVICEINTERFACE_W {
    DWORD       dbcc_size;
    DWORD       dbcc_devicetype;
    DWORD       dbcc_reserved;
    GUID        dbcc_classguid;
    wchar_t     dbcc_name[1];
} DEV_BROADCAST_DEVICEINTERFACE_W, *PDEV_BROADCAST_DEVICEINTERFACE_W;

#ifdef UNICODE
typedef DEV_BROADCAST_DEVICEINTERFACE_W   DEV_BROADCAST_DEVICEINTERFACE;
typedef PDEV_BROADCAST_DEVICEINTERFACE_W  PDEV_BROADCAST_DEVICEINTERFACE;
#else
typedef DEV_BROADCAST_DEVICEINTERFACE_A   DEV_BROADCAST_DEVICEINTERFACE;
typedef PDEV_BROADCAST_DEVICEINTERFACE_A  PDEV_BROADCAST_DEVICEINTERFACE;
#endif

typedef struct _DEV_BROADCAST_HANDLE {
    DWORD       dbch_size;
    DWORD       dbch_devicetype;
    DWORD       dbch_reserved;
    HANDLE      dbch_handle;     // file handle used in call to RegisterDeviceNotification
    DWORD       dbch_hdevnotify; // HDEVNOTIFY returned from RegisterDeviceNotification
    //
    // The following 3 fields are only valid if wParam is DBT_CUSTOMEVENT.
    //
    GUID        dbch_eventguid;
    LONG        dbch_nameoffset; // offset (bytes) of variable-length string buffer (-1 if none)
    BYTE        dbch_data[1];    // variable-sized buffer, potentially containing binary and/or text data
} DEV_BROADCAST_HANDLE, *PDEV_BROADCAST_HANDLE;

#endif /* WINVER >= 0x040A */

#define DBTF_RESOURCE   0x00000001      // network resource
#define DBTF_XPORT      0x00000002      // new transport coming or going
#define DBTF_SLOWNET    0x00000004      // new incoming transport is slow
                                        // (dbcn_resource undefined for now)

#define DBT_VPOWERDAPI  0x8100          // VPOWERD API for Win95

/*
 *  User-defined message types all use wParam = 0xFFFF with the
 *  lParam a pointer to the structure below.
 *
 *  dbud_dbh - DEV_BROADCAST_HEADER must be filled in as usual.
 *
 *  dbud_szName contains a case-sensitive ASCIIZ name which names the
 *  message.  The message name consists of the vendor name, a backslash,
 *  then arbitrary user-defined ASCIIZ text.  For example:
 *
 *      "WidgetWare\QueryScannerShutdown"
 *      "WidgetWare\Video Q39S\AdapterReady"
 *
 *  After the ASCIIZ name, arbitrary information may be provided.
 *  Make sure that dbud_dbh.dbch_size is big enough to encompass
 *  all the data.  And remember that nothing in the structure may
 *  contain pointers.
 */

#define DBT_USERDEFINED 0xFFFF

struct _DEV_BROADCAST_USERDEFINED { /* */
    struct _DEV_BROADCAST_HDR dbud_dbh;
    char        dbud_szName[1];     /* ASCIIZ name */
/*  BYTE        dbud_rgbUserDefined[];*/ /* User-defined contents */
};

#endif  // _DBT_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\dbsets.h ===
/***********************************************************************
**      D B S E T S . H                                                *
**                                                                     *
************************************************************************
** Copyright (C) 1996 by Microsoft Corporation                         *
**                 All Rights Reserved                                 *
************************************************************************/
/*

        DBSETS.H

        Database recordset class definitions for Microsoft Guide



*/



#ifndef _DBSETS_H_
#define _DBSETS_H_

#include "mstv.h"

#ifdef DBSETS_STATIC
#undef COMMMSTVEXPORT
#define COMMMSTVEXPORT
#endif

/*

The following classes provide an encapsulation of the dbDAO classes that
offers a simplified interface to the database tables.

CDatabaseConnection and CDatabaseRecordset are the root classes from
which individual Recordset classes are derived.

A Recordset class provides a means to open a recordset, fetch, update,
insert, and delete records, and close the recordset.  The records
produced are of the object type associated with the table.  The
Recordset object itself may be repeatedly opened and closed without
the need for deleting and re-instantiating a new object.

For example, the Episode table is accessed using the CEpisodeRecordset class.
It is opened with a where clause parameter that specifies the set of records.
Getting a record produces a CEpisode object, on a one-to-one basis.  The user
is responsible for deleting the object, and appropriate manipulation of the
object is done using the CEpisode methods.

Only the current record of an open recordset may be updated or deleted.

It is important to note that recordsets are opened by the Jet database engine
as either a Dynaset or Snapshot.  A Dynaset is essentially a list of pointers
to the records in the table.  Data is read from the database only when the
record is actually fetched.  A Snapshot reads all records in the set into a
RAM cache.  Large sets will cause caching to disk and subsequent poorer
performance.  Recordsets will be opened as Dynasets unless the optional lType
parameter specifies otherwise.

The record count is not defined on opening a recordset.  Calling
GetRecordCount requires "moving to the last record", which may be slow for
larger recordsets.  Recordsets generated with an ORDER BY clause appear to
correctly set the initial record count.


*/

COMMMSTVEXPORT void __stdcall SetJet ( CdbDBEngine* pEngine, CdbWorkspace* pWorkspace, CdbDatabase* pDatabase ); 
COMMMSTVEXPORT CdbDatabase * __stdcall GetDatabase(VOID);
COMMMSTVEXPORT BOOL __stdcall GetDatabaseConnected(VOID);


class COMMMSTVEXPORT CDatabaseConnection
{

//  This class provides the root encapsulation of the Jet engine and
//  the EPG database.


public:


	BOOL	StartEngine( const CString &csViewer, const CString &csPassword,
											 const CString &systemFile);
	BOOL    ConnectToDatabase( const CString &csViewer, const CString &csPassword,
							 const CString &systemFile, const CString &databaseFile, CString csWorkspaceName = "");

    BOOL    DisconnectFromDatabase( VOID);

    BOOL    CompactDatabase( VOID);

	CString  GetWorkspaceName( VOID);

	LPUNKNOWN GetWorkspaceUnknown( VOID);

protected:

	VOID    HandleDBException( CdbException* pException, LPCTSTR SourceOfException);

	BOOL 	RepairDB( const CString &databaseFile );

	BOOL	DataBaseInNeedOfRepair();
};





    enum // FindType is one of
    {   dbFindFirst = 1,
        dbFindLast,
        dbFindNext,
        dbFindPrevious
    };



class COMMMSTVEXPORT CDatabaseRecordset : public CDatabaseConnection
{

// This class provides the root encapsulation for recordset manipulation


// lType is one of: dbOpenSnapshot or default dbOpenDynaset
                
 
public:
                CDatabaseRecordset(VOID);
               ~CDatabaseRecordset(VOID);

		virtual BOOL    OpenRecordset( LPCTSTR WhereBy, LONG lType=-1);

        BOOL    OpenRecordsetQueryDef( LPCTSTR QueryName, LONG lType=-1);

        virtual VOID    CloseRecordset( VOID);

        CString GetQueryPrefix( VOID);

        LONG    GetRecordCount( VOID);

        VOID*   GetRecord( LONG RecordNumber);

        BOOL    GotoRecord( LONG RecordNumber);

        LONG    FindRecord( LONG FindType, LPCTSTR Criteria);

        BOOL    InsertRecord( VOID* cRecordsetObject);

        BOOL    UpdateRecord( VOID* cRecordsetObject);

        BOOL    DeleteRecord( VOID);

		void OpenIndexed(int iKeyID, int nOpenType,
										LPCTSTR lpszSQL, int nOptions);
		void SeekAddRS(CObject &coo);
		void UpdateRS(CObject &coo);
		void StartUpdateRS(CObject &coo);
		void EndUpdateRS();

		void Edit(void);
		void Update(void);
		void MoveFirst(void);
		void MovePrevious(void);
		void MoveNext(void);
		void MoveLast(void);
		BOOL GetEOF(void);

		COleVariant GetField(LPCTSTR pstrIndex);
		LONG GetLongField(LPCTSTR pstrIndex);
		COleVariant GetField(LONG lIndex);
		VOID SetField(LPCTSTR pstrIndex, COleVariant cov);
		ULONG GetFieldSize(LPCTSTR pstrIndex);

                // implemented by child recordset

virtual CString GetTableName( VOID) = 0;



protected:      // implemented by child recordset

virtual BOOLEAN Seek(LPCTSTR lpszComparison, CObject &coo);

virtual VOID*   GetRecordsetObject( VOID) = 0;

virtual BOOL    SetRecordsetObject( VOID* cRecordsetObject) = 0;



protected:          // accessed by child recordset

    CdbRecordset    m_cRecordset;


protected:

    time_t          m_ConnectTime;

    LONG            m_lRecordCount;
    LONG            m_lRecordNumber;
    BOOL            m_bRecordsetOpen;

};


#define AFX_RFX_LONG_PSEUDO_NULL (0x4a4d4120L)	// from afxdb.h


// Conversion macros - Variant

// These macros are used by the GetRecordsetObject routines to convert the
// Variant returned by dbdao to the local data type.
// Note there is no checking for nulls or incorrect data type,
// therefore use these macros at your own risk!

#define VAR2BOOL(v)           (v).bVal
#define VAR2BYTE(v)           (v).bVal
#define VAR2SHORT(v)          (v).iVal
#define VAR2LONG(v)           (v).lVal
#define VAR2FLOAT(v)          (v).fltVal
#define VAR2DOUBLE(v)         (v).dblVal
#define VAR2DATE(v)           (v)
#define VAR2CURRENCY(v)       (v)
#define VAR2CSTR(v)  (LPCTSTR)(v).bstrVal

// These macros are used in SetRecordsetObject routines to convert the local
// data type to COleVariant for dbdao

#define BOOL2OLEVAR(a)      COleVariant((BYTE)(a))
#define BYTE2OLEVAR(a)      COleVariant((a))
#define SHORT2OLEVAR(a)     COleVariant((a))
#define LONG2OLEVAR(a)      COleVariant((a))
#define FLOAT2OLEVAR(a)     COleVariant((a))
#define DOUBLE2OLEVAR(a)    COleVariant((a))
#define DATE2OLEVAR(a)      COleVariant((a))
#define CURRENCY2OLEVAR(a)  COleVariant((a))
#define CSTR2OLEVAR(a)      COleVariant((LPCTSTR)(a),VT_BSTRT)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\dbgprop.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.01.75 */
/* at Fri Sep 18 16:27:23 1998
 */
/* Compiler settings for dbgprop.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __dbgprop_h__
#define __dbgprop_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IDebugProperty_FWD_DEFINED__
#define __IDebugProperty_FWD_DEFINED__
typedef interface IDebugProperty IDebugProperty;
#endif 	/* __IDebugProperty_FWD_DEFINED__ */


#ifndef __IEnumDebugPropertyInfo_FWD_DEFINED__
#define __IEnumDebugPropertyInfo_FWD_DEFINED__
typedef interface IEnumDebugPropertyInfo IEnumDebugPropertyInfo;
#endif 	/* __IEnumDebugPropertyInfo_FWD_DEFINED__ */


#ifndef __IDebugExtendedProperty_FWD_DEFINED__
#define __IDebugExtendedProperty_FWD_DEFINED__
typedef interface IDebugExtendedProperty IDebugExtendedProperty;
#endif 	/* __IDebugExtendedProperty_FWD_DEFINED__ */


#ifndef __IEnumDebugExtendedPropertyInfo_FWD_DEFINED__
#define __IEnumDebugExtendedPropertyInfo_FWD_DEFINED__
typedef interface IEnumDebugExtendedPropertyInfo IEnumDebugExtendedPropertyInfo;
#endif 	/* __IEnumDebugExtendedPropertyInfo_FWD_DEFINED__ */


#ifndef __IPerPropertyBrowsing2_FWD_DEFINED__
#define __IPerPropertyBrowsing2_FWD_DEFINED__
typedef interface IPerPropertyBrowsing2 IPerPropertyBrowsing2;
#endif 	/* __IPerPropertyBrowsing2_FWD_DEFINED__ */


#ifndef __IDebugPropertyEnumType_All_FWD_DEFINED__
#define __IDebugPropertyEnumType_All_FWD_DEFINED__
typedef interface IDebugPropertyEnumType_All IDebugPropertyEnumType_All;
#endif 	/* __IDebugPropertyEnumType_All_FWD_DEFINED__ */


#ifndef __IDebugPropertyEnumType_Locals_FWD_DEFINED__
#define __IDebugPropertyEnumType_Locals_FWD_DEFINED__
typedef interface IDebugPropertyEnumType_Locals IDebugPropertyEnumType_Locals;
#endif 	/* __IDebugPropertyEnumType_Locals_FWD_DEFINED__ */


#ifndef __IDebugPropertyEnumType_Arguments_FWD_DEFINED__
#define __IDebugPropertyEnumType_Arguments_FWD_DEFINED__
typedef interface IDebugPropertyEnumType_Arguments IDebugPropertyEnumType_Arguments;
#endif 	/* __IDebugPropertyEnumType_Arguments_FWD_DEFINED__ */


#ifndef __IDebugPropertyEnumType_LocalsPlusArgs_FWD_DEFINED__
#define __IDebugPropertyEnumType_LocalsPlusArgs_FWD_DEFINED__
typedef interface IDebugPropertyEnumType_LocalsPlusArgs IDebugPropertyEnumType_LocalsPlusArgs;
#endif 	/* __IDebugPropertyEnumType_LocalsPlusArgs_FWD_DEFINED__ */


#ifndef __IDebugPropertyEnumType_Registers_FWD_DEFINED__
#define __IDebugPropertyEnumType_Registers_FWD_DEFINED__
typedef interface IDebugPropertyEnumType_Registers IDebugPropertyEnumType_Registers;
#endif 	/* __IDebugPropertyEnumType_Registers_FWD_DEFINED__ */


/* header files for imported files */
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/****************************************
 * Generated header for interface: __MIDL_itf_dbgprop_0000
 * at Fri Sep 18 16:27:23 1998
 * using MIDL 3.01.75
 ****************************************/
/* [local] */ 







// GUIDs for IDebugProperty::GetExtendedInfo
extern GUID guidDocument;
extern GUID guidCodeContext;

enum __MIDL___MIDL_itf_dbgprop_0000_0001
    {	DBGPROP_ATTRIB_NO_ATTRIB	= 0,
	DBGPROP_ATTRIB_VALUE_IS_INVALID	= 0x8,
	DBGPROP_ATTRIB_VALUE_IS_EXPANDABLE	= 0x10,
	DBGPROP_ATTRIB_VALUE_READONLY	= 0x800,
	DBGPROP_ATTRIB_ACCESS_PUBLIC	= 0x1000,
	DBGPROP_ATTRIB_ACCESS_PRIVATE	= 0x2000,
	DBGPROP_ATTRIB_ACCESS_PROTECTED	= 0x4000,
	DBGPROP_ATTRIB_ACCESS_FINAL	= 0x8000,
	DBGPROP_ATTRIB_STORAGE_GLOBAL	= 0x10000,
	DBGPROP_ATTRIB_STORAGE_STATIC	= 0x20000,
	DBGPROP_ATTRIB_STORAGE_FIELD	= 0x40000,
	DBGPROP_ATTRIB_STORAGE_VIRTUAL	= 0x80000,
	DBGPROP_ATTRIB_TYPE_IS_CONSTANT	= 0x100000,
	DBGPROP_ATTRIB_TYPE_IS_SYNCHRONIZED	= 0x200000,
	DBGPROP_ATTRIB_TYPE_IS_VOLATILE	= 0x400000,
	DBGPROP_ATTRIB_HAS_EXTENDED_ATTRIBS	= 0x800000
    };
typedef DWORD DBGPROP_ATTRIB_FLAGS;


enum __MIDL___MIDL_itf_dbgprop_0000_0002
    {	DBGPROP_INFO_NAME	= 0x1,
	DBGPROP_INFO_TYPE	= 0x2,
	DBGPROP_INFO_VALUE	= 0x4,
	DBGPROP_INFO_FULLNAME	= 0x20,
	DBGPROP_INFO_ATTRIBUTES	= 0x8,
	DBGPROP_INFO_DEBUGPROP	= 0x10,
	DBGPROP_INFO_AUTOEXPAND	= 0x8000000
    };
typedef DWORD DBGPROP_INFO_FLAGS;

#define	DBGPROP_INFO_STANDARD	( DBGPROP_INFO_NAME | DBGPROP_INFO_TYPE | DBGPROP_INFO_VALUE | DBGPROP_INFO_ATTRIBUTES )

#define	DBGPROP_INFO_ALL	( DBGPROP_INFO_NAME | DBGPROP_INFO_TYPE | DBGPROP_INFO_VALUE | DBGPROP_INFO_FULLNAME | DBGPROP_INFO_ATTRIBUTES | DBGPROP_INFO_DEBUGPROP )

typedef struct  tagDebugPropertyInfo
    {
    DBGPROP_INFO_FLAGS m_dwValidFields;
    BSTR m_bstrName;
    BSTR m_bstrType;
    BSTR m_bstrValue;
    BSTR m_bstrFullName;
    DBGPROP_ATTRIB_FLAGS m_dwAttrib;
    IDebugProperty __RPC_FAR *m_pDebugProp;
    }	DebugPropertyInfo;


enum __MIDL___MIDL_itf_dbgprop_0000_0003
    {	EX_DBGPROP_INFO_ID	= 0x100,
	EX_DBGPROP_INFO_NTYPE	= 0x200,
	EX_DBGPROP_INFO_NVALUE	= 0x400,
	EX_DBGPROP_INFO_LOCKBYTES	= 0x800,
	EX_DBGPROP_INFO_DEBUGEXTPROP	= 0x1000
    };
typedef DWORD EX_DBGPROP_INFO_FLAGS;

typedef struct  tagExtendedDebugPropertyInfo
    {
    DBGPROP_INFO_FLAGS m_dwValidFields;
    LPOLESTR m_bstrName;
    LPOLESTR m_bstrType;
    LPOLESTR m_bstrValue;
    LPOLESTR m_bstrFullName;
    DBGPROP_ATTRIB_FLAGS m_dwAttrib;
    IDebugProperty __RPC_FAR *m_pDebugProp;
    DWORD m_nDISPID;
    DWORD m_nType;
    VARIANT m_varValue;
    ILockBytes __RPC_FAR *m_plbValue;
    IDebugExtendedProperty __RPC_FAR *m_pDebugExtProp;
    }	ExtendedDebugPropertyInfo;



extern RPC_IF_HANDLE __MIDL_itf_dbgprop_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dbgprop_0000_v0_0_s_ifspec;

#ifndef __IDebugProperty_INTERFACE_DEFINED__
#define __IDebugProperty_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDebugProperty
 * at Fri Sep 18 16:27:23 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IDebugProperty;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("51973C50-CB0C-11d0-B5C9-00A0244A0E7A")
    IDebugProperty : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPropertyInfo( 
            /* [in] */ DBGPROP_INFO_FLAGS dwFieldSpec,
            /* [in] */ UINT nRadix,
            /* [out] */ DebugPropertyInfo __RPC_FAR *pPropertyInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetExtendedInfo( 
            /* [in] */ ULONG cInfos,
            /* [size_is][in] */ GUID __RPC_FAR *rgguidExtendedInfo,
            /* [size_is][out] */ VARIANT __RPC_FAR *rgvar) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetValueAsString( 
            /* [in] */ LPCOLESTR pszValue,
            /* [in] */ UINT nRadix) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumMembers( 
            /* [in] */ DBGPROP_INFO_FLAGS dwFieldSpec,
            /* [in] */ UINT nRadix,
            /* [in] */ REFIID refiid,
            /* [out] */ IEnumDebugPropertyInfo __RPC_FAR *__RPC_FAR *ppepi) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetParent( 
            /* [out] */ IDebugProperty __RPC_FAR *__RPC_FAR *ppDebugProp) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugPropertyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDebugProperty __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDebugProperty __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDebugProperty __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPropertyInfo )( 
            IDebugProperty __RPC_FAR * This,
            /* [in] */ DBGPROP_INFO_FLAGS dwFieldSpec,
            /* [in] */ UINT nRadix,
            /* [out] */ DebugPropertyInfo __RPC_FAR *pPropertyInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetExtendedInfo )( 
            IDebugProperty __RPC_FAR * This,
            /* [in] */ ULONG cInfos,
            /* [size_is][in] */ GUID __RPC_FAR *rgguidExtendedInfo,
            /* [size_is][out] */ VARIANT __RPC_FAR *rgvar);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetValueAsString )( 
            IDebugProperty __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszValue,
            /* [in] */ UINT nRadix);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumMembers )( 
            IDebugProperty __RPC_FAR * This,
            /* [in] */ DBGPROP_INFO_FLAGS dwFieldSpec,
            /* [in] */ UINT nRadix,
            /* [in] */ REFIID refiid,
            /* [out] */ IEnumDebugPropertyInfo __RPC_FAR *__RPC_FAR *ppepi);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetParent )( 
            IDebugProperty __RPC_FAR * This,
            /* [out] */ IDebugProperty __RPC_FAR *__RPC_FAR *ppDebugProp);
        
        END_INTERFACE
    } IDebugPropertyVtbl;

    interface IDebugProperty
    {
        CONST_VTBL struct IDebugPropertyVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugProperty_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugProperty_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugProperty_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugProperty_GetPropertyInfo(This,dwFieldSpec,nRadix,pPropertyInfo)	\
    (This)->lpVtbl -> GetPropertyInfo(This,dwFieldSpec,nRadix,pPropertyInfo)

#define IDebugProperty_GetExtendedInfo(This,cInfos,rgguidExtendedInfo,rgvar)	\
    (This)->lpVtbl -> GetExtendedInfo(This,cInfos,rgguidExtendedInfo,rgvar)

#define IDebugProperty_SetValueAsString(This,pszValue,nRadix)	\
    (This)->lpVtbl -> SetValueAsString(This,pszValue,nRadix)

#define IDebugProperty_EnumMembers(This,dwFieldSpec,nRadix,refiid,ppepi)	\
    (This)->lpVtbl -> EnumMembers(This,dwFieldSpec,nRadix,refiid,ppepi)

#define IDebugProperty_GetParent(This,ppDebugProp)	\
    (This)->lpVtbl -> GetParent(This,ppDebugProp)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDebugProperty_GetPropertyInfo_Proxy( 
    IDebugProperty __RPC_FAR * This,
    /* [in] */ DBGPROP_INFO_FLAGS dwFieldSpec,
    /* [in] */ UINT nRadix,
    /* [out] */ DebugPropertyInfo __RPC_FAR *pPropertyInfo);


void __RPC_STUB IDebugProperty_GetPropertyInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugProperty_GetExtendedInfo_Proxy( 
    IDebugProperty __RPC_FAR * This,
    /* [in] */ ULONG cInfos,
    /* [size_is][in] */ GUID __RPC_FAR *rgguidExtendedInfo,
    /* [size_is][out] */ VARIANT __RPC_FAR *rgvar);


void __RPC_STUB IDebugProperty_GetExtendedInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugProperty_SetValueAsString_Proxy( 
    IDebugProperty __RPC_FAR * This,
    /* [in] */ LPCOLESTR pszValue,
    /* [in] */ UINT nRadix);


void __RPC_STUB IDebugProperty_SetValueAsString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugProperty_EnumMembers_Proxy( 
    IDebugProperty __RPC_FAR * This,
    /* [in] */ DBGPROP_INFO_FLAGS dwFieldSpec,
    /* [in] */ UINT nRadix,
    /* [in] */ REFIID refiid,
    /* [out] */ IEnumDebugPropertyInfo __RPC_FAR *__RPC_FAR *ppepi);


void __RPC_STUB IDebugProperty_EnumMembers_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugProperty_GetParent_Proxy( 
    IDebugProperty __RPC_FAR * This,
    /* [out] */ IDebugProperty __RPC_FAR *__RPC_FAR *ppDebugProp);


void __RPC_STUB IDebugProperty_GetParent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDebugProperty_INTERFACE_DEFINED__ */


#ifndef __IEnumDebugPropertyInfo_INTERFACE_DEFINED__
#define __IEnumDebugPropertyInfo_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEnumDebugPropertyInfo
 * at Fri Sep 18 16:27:23 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IEnumDebugPropertyInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("51973C51-CB0C-11d0-B5C9-00A0244A0E7A")
    IEnumDebugPropertyInfo : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [out] */ DebugPropertyInfo __RPC_FAR *pi,
            /* [out] */ ULONG __RPC_FAR *pcEltsfetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumDebugPropertyInfo __RPC_FAR *__RPC_FAR *ppepi) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ ULONG __RPC_FAR *pcelt) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumDebugPropertyInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumDebugPropertyInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumDebugPropertyInfo __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumDebugPropertyInfo __RPC_FAR * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumDebugPropertyInfo __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [out] */ DebugPropertyInfo __RPC_FAR *pi,
            /* [out] */ ULONG __RPC_FAR *pcEltsfetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumDebugPropertyInfo __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumDebugPropertyInfo __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumDebugPropertyInfo __RPC_FAR * This,
            /* [out] */ IEnumDebugPropertyInfo __RPC_FAR *__RPC_FAR *ppepi);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCount )( 
            IEnumDebugPropertyInfo __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pcelt);
        
        END_INTERFACE
    } IEnumDebugPropertyInfoVtbl;

    interface IEnumDebugPropertyInfo
    {
        CONST_VTBL struct IEnumDebugPropertyInfoVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumDebugPropertyInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumDebugPropertyInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumDebugPropertyInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumDebugPropertyInfo_Next(This,celt,pi,pcEltsfetched)	\
    (This)->lpVtbl -> Next(This,celt,pi,pcEltsfetched)

#define IEnumDebugPropertyInfo_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumDebugPropertyInfo_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumDebugPropertyInfo_Clone(This,ppepi)	\
    (This)->lpVtbl -> Clone(This,ppepi)

#define IEnumDebugPropertyInfo_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT __stdcall IEnumDebugPropertyInfo_RemoteNext_Proxy( 
    IEnumDebugPropertyInfo __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ DebugPropertyInfo __RPC_FAR *pinfo,
    /* [out] */ ULONG __RPC_FAR *pcEltsfetched);


void __RPC_STUB IEnumDebugPropertyInfo_RemoteNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugPropertyInfo_Skip_Proxy( 
    IEnumDebugPropertyInfo __RPC_FAR * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumDebugPropertyInfo_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugPropertyInfo_Reset_Proxy( 
    IEnumDebugPropertyInfo __RPC_FAR * This);


void __RPC_STUB IEnumDebugPropertyInfo_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugPropertyInfo_Clone_Proxy( 
    IEnumDebugPropertyInfo __RPC_FAR * This,
    /* [out] */ IEnumDebugPropertyInfo __RPC_FAR *__RPC_FAR *ppepi);


void __RPC_STUB IEnumDebugPropertyInfo_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugPropertyInfo_GetCount_Proxy( 
    IEnumDebugPropertyInfo __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *pcelt);


void __RPC_STUB IEnumDebugPropertyInfo_GetCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumDebugPropertyInfo_INTERFACE_DEFINED__ */


#ifndef __IDebugExtendedProperty_INTERFACE_DEFINED__
#define __IDebugExtendedProperty_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDebugExtendedProperty
 * at Fri Sep 18 16:27:23 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IDebugExtendedProperty;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("51973C52-CB0C-11d0-B5C9-00A0244A0E7A")
    IDebugExtendedProperty : public IDebugProperty
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetExtendedPropertyInfo( 
            /* [in] */ EX_DBGPROP_INFO_FLAGS dwFieldSpec,
            /* [in] */ UINT nRadix,
            /* [out] */ ExtendedDebugPropertyInfo __RPC_FAR *pExtendedPropertyInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumExtendedMembers( 
            /* [in] */ EX_DBGPROP_INFO_FLAGS dwFieldSpec,
            /* [in] */ UINT nRadix,
            /* [out] */ IEnumDebugExtendedPropertyInfo __RPC_FAR *__RPC_FAR *ppeepi) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugExtendedPropertyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDebugExtendedProperty __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDebugExtendedProperty __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDebugExtendedProperty __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPropertyInfo )( 
            IDebugExtendedProperty __RPC_FAR * This,
            /* [in] */ DBGPROP_INFO_FLAGS dwFieldSpec,
            /* [in] */ UINT nRadix,
            /* [out] */ DebugPropertyInfo __RPC_FAR *pPropertyInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetExtendedInfo )( 
            IDebugExtendedProperty __RPC_FAR * This,
            /* [in] */ ULONG cInfos,
            /* [size_is][in] */ GUID __RPC_FAR *rgguidExtendedInfo,
            /* [size_is][out] */ VARIANT __RPC_FAR *rgvar);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetValueAsString )( 
            IDebugExtendedProperty __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszValue,
            /* [in] */ UINT nRadix);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumMembers )( 
            IDebugExtendedProperty __RPC_FAR * This,
            /* [in] */ DBGPROP_INFO_FLAGS dwFieldSpec,
            /* [in] */ UINT nRadix,
            /* [in] */ REFIID refiid,
            /* [out] */ IEnumDebugPropertyInfo __RPC_FAR *__RPC_FAR *ppepi);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetParent )( 
            IDebugExtendedProperty __RPC_FAR * This,
            /* [out] */ IDebugProperty __RPC_FAR *__RPC_FAR *ppDebugProp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetExtendedPropertyInfo )( 
            IDebugExtendedProperty __RPC_FAR * This,
            /* [in] */ EX_DBGPROP_INFO_FLAGS dwFieldSpec,
            /* [in] */ UINT nRadix,
            /* [out] */ ExtendedDebugPropertyInfo __RPC_FAR *pExtendedPropertyInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumExtendedMembers )( 
            IDebugExtendedProperty __RPC_FAR * This,
            /* [in] */ EX_DBGPROP_INFO_FLAGS dwFieldSpec,
            /* [in] */ UINT nRadix,
            /* [out] */ IEnumDebugExtendedPropertyInfo __RPC_FAR *__RPC_FAR *ppeepi);
        
        END_INTERFACE
    } IDebugExtendedPropertyVtbl;

    interface IDebugExtendedProperty
    {
        CONST_VTBL struct IDebugExtendedPropertyVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugExtendedProperty_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugExtendedProperty_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugExtendedProperty_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugExtendedProperty_GetPropertyInfo(This,dwFieldSpec,nRadix,pPropertyInfo)	\
    (This)->lpVtbl -> GetPropertyInfo(This,dwFieldSpec,nRadix,pPropertyInfo)

#define IDebugExtendedProperty_GetExtendedInfo(This,cInfos,rgguidExtendedInfo,rgvar)	\
    (This)->lpVtbl -> GetExtendedInfo(This,cInfos,rgguidExtendedInfo,rgvar)

#define IDebugExtendedProperty_SetValueAsString(This,pszValue,nRadix)	\
    (This)->lpVtbl -> SetValueAsString(This,pszValue,nRadix)

#define IDebugExtendedProperty_EnumMembers(This,dwFieldSpec,nRadix,refiid,ppepi)	\
    (This)->lpVtbl -> EnumMembers(This,dwFieldSpec,nRadix,refiid,ppepi)

#define IDebugExtendedProperty_GetParent(This,ppDebugProp)	\
    (This)->lpVtbl -> GetParent(This,ppDebugProp)


#define IDebugExtendedProperty_GetExtendedPropertyInfo(This,dwFieldSpec,nRadix,pExtendedPropertyInfo)	\
    (This)->lpVtbl -> GetExtendedPropertyInfo(This,dwFieldSpec,nRadix,pExtendedPropertyInfo)

#define IDebugExtendedProperty_EnumExtendedMembers(This,dwFieldSpec,nRadix,ppeepi)	\
    (This)->lpVtbl -> EnumExtendedMembers(This,dwFieldSpec,nRadix,ppeepi)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDebugExtendedProperty_GetExtendedPropertyInfo_Proxy( 
    IDebugExtendedProperty __RPC_FAR * This,
    /* [in] */ EX_DBGPROP_INFO_FLAGS dwFieldSpec,
    /* [in] */ UINT nRadix,
    /* [out] */ ExtendedDebugPropertyInfo __RPC_FAR *pExtendedPropertyInfo);


void __RPC_STUB IDebugExtendedProperty_GetExtendedPropertyInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugExtendedProperty_EnumExtendedMembers_Proxy( 
    IDebugExtendedProperty __RPC_FAR * This,
    /* [in] */ EX_DBGPROP_INFO_FLAGS dwFieldSpec,
    /* [in] */ UINT nRadix,
    /* [out] */ IEnumDebugExtendedPropertyInfo __RPC_FAR *__RPC_FAR *ppeepi);


void __RPC_STUB IDebugExtendedProperty_EnumExtendedMembers_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDebugExtendedProperty_INTERFACE_DEFINED__ */


#ifndef __IEnumDebugExtendedPropertyInfo_INTERFACE_DEFINED__
#define __IEnumDebugExtendedPropertyInfo_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEnumDebugExtendedPropertyInfo
 * at Fri Sep 18 16:27:23 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IEnumDebugExtendedPropertyInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("51973C53-CB0C-11d0-B5C9-00A0244A0E7A")
    IEnumDebugExtendedPropertyInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ ExtendedDebugPropertyInfo __RPC_FAR *rgExtendedPropertyInfo,
            /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumDebugExtendedPropertyInfo __RPC_FAR *__RPC_FAR *pedpe) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ ULONG __RPC_FAR *pcelt) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumDebugExtendedPropertyInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumDebugExtendedPropertyInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumDebugExtendedPropertyInfo __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumDebugExtendedPropertyInfo __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumDebugExtendedPropertyInfo __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ ExtendedDebugPropertyInfo __RPC_FAR *rgExtendedPropertyInfo,
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumDebugExtendedPropertyInfo __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumDebugExtendedPropertyInfo __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumDebugExtendedPropertyInfo __RPC_FAR * This,
            /* [out] */ IEnumDebugExtendedPropertyInfo __RPC_FAR *__RPC_FAR *pedpe);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCount )( 
            IEnumDebugExtendedPropertyInfo __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pcelt);
        
        END_INTERFACE
    } IEnumDebugExtendedPropertyInfoVtbl;

    interface IEnumDebugExtendedPropertyInfo
    {
        CONST_VTBL struct IEnumDebugExtendedPropertyInfoVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumDebugExtendedPropertyInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumDebugExtendedPropertyInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumDebugExtendedPropertyInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumDebugExtendedPropertyInfo_Next(This,celt,rgExtendedPropertyInfo,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgExtendedPropertyInfo,pceltFetched)

#define IEnumDebugExtendedPropertyInfo_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumDebugExtendedPropertyInfo_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumDebugExtendedPropertyInfo_Clone(This,pedpe)	\
    (This)->lpVtbl -> Clone(This,pedpe)

#define IEnumDebugExtendedPropertyInfo_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumDebugExtendedPropertyInfo_Next_Proxy( 
    IEnumDebugExtendedPropertyInfo __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ ExtendedDebugPropertyInfo __RPC_FAR *rgExtendedPropertyInfo,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumDebugExtendedPropertyInfo_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugExtendedPropertyInfo_Skip_Proxy( 
    IEnumDebugExtendedPropertyInfo __RPC_FAR * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumDebugExtendedPropertyInfo_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugExtendedPropertyInfo_Reset_Proxy( 
    IEnumDebugExtendedPropertyInfo __RPC_FAR * This);


void __RPC_STUB IEnumDebugExtendedPropertyInfo_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugExtendedPropertyInfo_Clone_Proxy( 
    IEnumDebugExtendedPropertyInfo __RPC_FAR * This,
    /* [out] */ IEnumDebugExtendedPropertyInfo __RPC_FAR *__RPC_FAR *pedpe);


void __RPC_STUB IEnumDebugExtendedPropertyInfo_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugExtendedPropertyInfo_GetCount_Proxy( 
    IEnumDebugExtendedPropertyInfo __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *pcelt);


void __RPC_STUB IEnumDebugExtendedPropertyInfo_GetCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumDebugExtendedPropertyInfo_INTERFACE_DEFINED__ */


#ifndef __IPerPropertyBrowsing2_INTERFACE_DEFINED__
#define __IPerPropertyBrowsing2_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IPerPropertyBrowsing2
 * at Fri Sep 18 16:27:23 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IPerPropertyBrowsing2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("51973C54-CB0C-11d0-B5C9-00A0244A0E7A")
    IPerPropertyBrowsing2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDisplayString( 
            /* [in] */ DISPID dispid,
            /* [out] */ BSTR __RPC_FAR *pBstr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MapPropertyToPage( 
            /* [in] */ DISPID dispid,
            /* [out] */ CLSID __RPC_FAR *pClsidPropPage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPredefinedStrings( 
            /* [in] */ DISPID dispid,
            /* [out] */ CALPOLESTR __RPC_FAR *pCaStrings,
            /* [out] */ CADWORD __RPC_FAR *pCaCookies) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPredefinedValue( 
            /* [in] */ DISPID dispid,
            /* [in] */ DWORD dwCookie) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPerPropertyBrowsing2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IPerPropertyBrowsing2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IPerPropertyBrowsing2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IPerPropertyBrowsing2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDisplayString )( 
            IPerPropertyBrowsing2 __RPC_FAR * This,
            /* [in] */ DISPID dispid,
            /* [out] */ BSTR __RPC_FAR *pBstr);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MapPropertyToPage )( 
            IPerPropertyBrowsing2 __RPC_FAR * This,
            /* [in] */ DISPID dispid,
            /* [out] */ CLSID __RPC_FAR *pClsidPropPage);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPredefinedStrings )( 
            IPerPropertyBrowsing2 __RPC_FAR * This,
            /* [in] */ DISPID dispid,
            /* [out] */ CALPOLESTR __RPC_FAR *pCaStrings,
            /* [out] */ CADWORD __RPC_FAR *pCaCookies);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPredefinedValue )( 
            IPerPropertyBrowsing2 __RPC_FAR * This,
            /* [in] */ DISPID dispid,
            /* [in] */ DWORD dwCookie);
        
        END_INTERFACE
    } IPerPropertyBrowsing2Vtbl;

    interface IPerPropertyBrowsing2
    {
        CONST_VTBL struct IPerPropertyBrowsing2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPerPropertyBrowsing2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPerPropertyBrowsing2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPerPropertyBrowsing2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPerPropertyBrowsing2_GetDisplayString(This,dispid,pBstr)	\
    (This)->lpVtbl -> GetDisplayString(This,dispid,pBstr)

#define IPerPropertyBrowsing2_MapPropertyToPage(This,dispid,pClsidPropPage)	\
    (This)->lpVtbl -> MapPropertyToPage(This,dispid,pClsidPropPage)

#define IPerPropertyBrowsing2_GetPredefinedStrings(This,dispid,pCaStrings,pCaCookies)	\
    (This)->lpVtbl -> GetPredefinedStrings(This,dispid,pCaStrings,pCaCookies)

#define IPerPropertyBrowsing2_SetPredefinedValue(This,dispid,dwCookie)	\
    (This)->lpVtbl -> SetPredefinedValue(This,dispid,dwCookie)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IPerPropertyBrowsing2_GetDisplayString_Proxy( 
    IPerPropertyBrowsing2 __RPC_FAR * This,
    /* [in] */ DISPID dispid,
    /* [out] */ BSTR __RPC_FAR *pBstr);


void __RPC_STUB IPerPropertyBrowsing2_GetDisplayString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPerPropertyBrowsing2_MapPropertyToPage_Proxy( 
    IPerPropertyBrowsing2 __RPC_FAR * This,
    /* [in] */ DISPID dispid,
    /* [out] */ CLSID __RPC_FAR *pClsidPropPage);


void __RPC_STUB IPerPropertyBrowsing2_MapPropertyToPage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPerPropertyBrowsing2_GetPredefinedStrings_Proxy( 
    IPerPropertyBrowsing2 __RPC_FAR * This,
    /* [in] */ DISPID dispid,
    /* [out] */ CALPOLESTR __RPC_FAR *pCaStrings,
    /* [out] */ CADWORD __RPC_FAR *pCaCookies);


void __RPC_STUB IPerPropertyBrowsing2_GetPredefinedStrings_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPerPropertyBrowsing2_SetPredefinedValue_Proxy( 
    IPerPropertyBrowsing2 __RPC_FAR * This,
    /* [in] */ DISPID dispid,
    /* [in] */ DWORD dwCookie);


void __RPC_STUB IPerPropertyBrowsing2_SetPredefinedValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPerPropertyBrowsing2_INTERFACE_DEFINED__ */


#ifndef __IDebugPropertyEnumType_All_INTERFACE_DEFINED__
#define __IDebugPropertyEnumType_All_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDebugPropertyEnumType_All
 * at Fri Sep 18 16:27:23 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IDebugPropertyEnumType_All;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("51973C55-CB0C-11d0-B5C9-00A0244A0E7A")
    IDebugPropertyEnumType_All : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetName( 
            /* [out] */ BSTR __RPC_FAR *__MIDL_0016) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugPropertyEnumType_AllVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDebugPropertyEnumType_All __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDebugPropertyEnumType_All __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDebugPropertyEnumType_All __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            IDebugPropertyEnumType_All __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *__MIDL_0016);
        
        END_INTERFACE
    } IDebugPropertyEnumType_AllVtbl;

    interface IDebugPropertyEnumType_All
    {
        CONST_VTBL struct IDebugPropertyEnumType_AllVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugPropertyEnumType_All_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugPropertyEnumType_All_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugPropertyEnumType_All_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugPropertyEnumType_All_GetName(This,__MIDL_0016)	\
    (This)->lpVtbl -> GetName(This,__MIDL_0016)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDebugPropertyEnumType_All_GetName_Proxy( 
    IDebugPropertyEnumType_All __RPC_FAR * This,
    /* [out] */ BSTR __RPC_FAR *__MIDL_0016);


void __RPC_STUB IDebugPropertyEnumType_All_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDebugPropertyEnumType_All_INTERFACE_DEFINED__ */


#ifndef __IDebugPropertyEnumType_Locals_INTERFACE_DEFINED__
#define __IDebugPropertyEnumType_Locals_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDebugPropertyEnumType_Locals
 * at Fri Sep 18 16:27:23 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IDebugPropertyEnumType_Locals;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("51973C56-CB0C-11d0-B5C9-00A0244A0E7A")
    IDebugPropertyEnumType_Locals : public IDebugPropertyEnumType_All
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IDebugPropertyEnumType_LocalsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDebugPropertyEnumType_Locals __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDebugPropertyEnumType_Locals __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDebugPropertyEnumType_Locals __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            IDebugPropertyEnumType_Locals __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *__MIDL_0016);
        
        END_INTERFACE
    } IDebugPropertyEnumType_LocalsVtbl;

    interface IDebugPropertyEnumType_Locals
    {
        CONST_VTBL struct IDebugPropertyEnumType_LocalsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugPropertyEnumType_Locals_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugPropertyEnumType_Locals_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugPropertyEnumType_Locals_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugPropertyEnumType_Locals_GetName(This,__MIDL_0016)	\
    (This)->lpVtbl -> GetName(This,__MIDL_0016)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDebugPropertyEnumType_Locals_INTERFACE_DEFINED__ */


#ifndef __IDebugPropertyEnumType_Arguments_INTERFACE_DEFINED__
#define __IDebugPropertyEnumType_Arguments_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDebugPropertyEnumType_Arguments
 * at Fri Sep 18 16:27:23 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IDebugPropertyEnumType_Arguments;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("51973C57-CB0C-11d0-B5C9-00A0244A0E7A")
    IDebugPropertyEnumType_Arguments : public IDebugPropertyEnumType_All
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IDebugPropertyEnumType_ArgumentsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDebugPropertyEnumType_Arguments __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDebugPropertyEnumType_Arguments __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDebugPropertyEnumType_Arguments __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            IDebugPropertyEnumType_Arguments __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *__MIDL_0016);
        
        END_INTERFACE
    } IDebugPropertyEnumType_ArgumentsVtbl;

    interface IDebugPropertyEnumType_Arguments
    {
        CONST_VTBL struct IDebugPropertyEnumType_ArgumentsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugPropertyEnumType_Arguments_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugPropertyEnumType_Arguments_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugPropertyEnumType_Arguments_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugPropertyEnumType_Arguments_GetName(This,__MIDL_0016)	\
    (This)->lpVtbl -> GetName(This,__MIDL_0016)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDebugPropertyEnumType_Arguments_INTERFACE_DEFINED__ */


#ifndef __IDebugPropertyEnumType_LocalsPlusArgs_INTERFACE_DEFINED__
#define __IDebugPropertyEnumType_LocalsPlusArgs_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDebugPropertyEnumType_LocalsPlusArgs
 * at Fri Sep 18 16:27:23 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IDebugPropertyEnumType_LocalsPlusArgs;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("51973C58-CB0C-11d0-B5C9-00A0244A0E7A")
    IDebugPropertyEnumType_LocalsPlusArgs : public IDebugPropertyEnumType_All
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IDebugPropertyEnumType_LocalsPlusArgsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDebugPropertyEnumType_LocalsPlusArgs __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDebugPropertyEnumType_LocalsPlusArgs __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDebugPropertyEnumType_LocalsPlusArgs __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            IDebugPropertyEnumType_LocalsPlusArgs __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *__MIDL_0016);
        
        END_INTERFACE
    } IDebugPropertyEnumType_LocalsPlusArgsVtbl;

    interface IDebugPropertyEnumType_LocalsPlusArgs
    {
        CONST_VTBL struct IDebugPropertyEnumType_LocalsPlusArgsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugPropertyEnumType_LocalsPlusArgs_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugPropertyEnumType_LocalsPlusArgs_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugPropertyEnumType_LocalsPlusArgs_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugPropertyEnumType_LocalsPlusArgs_GetName(This,__MIDL_0016)	\
    (This)->lpVtbl -> GetName(This,__MIDL_0016)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDebugPropertyEnumType_LocalsPlusArgs_INTERFACE_DEFINED__ */


#ifndef __IDebugPropertyEnumType_Registers_INTERFACE_DEFINED__
#define __IDebugPropertyEnumType_Registers_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDebugPropertyEnumType_Registers
 * at Fri Sep 18 16:27:23 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IDebugPropertyEnumType_Registers;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("51973C59-CB0C-11d0-B5C9-00A0244A0E7A")
    IDebugPropertyEnumType_Registers : public IDebugPropertyEnumType_All
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IDebugPropertyEnumType_RegistersVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDebugPropertyEnumType_Registers __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDebugPropertyEnumType_Registers __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDebugPropertyEnumType_Registers __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            IDebugPropertyEnumType_Registers __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *__MIDL_0016);
        
        END_INTERFACE
    } IDebugPropertyEnumType_RegistersVtbl;

    interface IDebugPropertyEnumType_Registers
    {
        CONST_VTBL struct IDebugPropertyEnumType_RegistersVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugPropertyEnumType_Registers_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugPropertyEnumType_Registers_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugPropertyEnumType_Registers_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugPropertyEnumType_Registers_GetName(This,__MIDL_0016)	\
    (This)->lpVtbl -> GetName(This,__MIDL_0016)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDebugPropertyEnumType_Registers_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long __RPC_FAR *, unsigned long            , VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long __RPC_FAR *, VARIANT __RPC_FAR * ); 

/* [local] */ HRESULT STDMETHODCALLTYPE IEnumDebugPropertyInfo_Next_Proxy( 
    IEnumDebugPropertyInfo __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [out] */ DebugPropertyInfo __RPC_FAR *pi,
    /* [out] */ ULONG __RPC_FAR *pcEltsfetched);


/* [call_as] */ HRESULT __stdcall IEnumDebugPropertyInfo_Next_Stub( 
    IEnumDebugPropertyInfo __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ DebugPropertyInfo __RPC_FAR *pinfo,
    /* [out] */ ULONG __RPC_FAR *pcEltsfetched);



/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\ddraw.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddraw.h
 *  Content:    DirectDraw include file
 *
 ***************************************************************************/

#ifndef __DDRAW_INCLUDED__
#define __DDRAW_INCLUDED__

//Disable the nameless union warning when building internally
#undef ENABLE_NAMELESS_UNION_PRAGMA
#ifdef DIRECTX_REDIST
#define ENABLE_NAMELESS_UNION_PRAGMA
#endif

#ifdef ENABLE_NAMELESS_UNION_PRAGMA
#pragma warning(disable:4201)
#endif

/*
 * If you wish an application built against the newest version of DirectDraw
 * to run against an older DirectDraw run time then define DIRECTDRAW_VERSION
 * to be the earlies version of DirectDraw you wish to run against. For,
 * example if you wish an application to run against a DX 3 runtime define
 * DIRECTDRAW_VERSION to be 0x0300.
 */
#ifndef   DIRECTDRAW_VERSION
#define   DIRECTDRAW_VERSION 0x0700
#endif /* DIRECTDRAW_VERSION */

#if defined( _WIN32 )  && !defined( _NO_COM )
#define COM_NO_WINDOWS_H
#include <objbase.h>
#else
#define IUnknown            void
#if !defined( NT_BUILD_ENVIRONMENT ) && !defined(WINNT)
        #define CO_E_NOTINITIALIZED 0x800401F0L
#endif
#endif

#define _FACDD  0x876
#define MAKE_DDHRESULT( code )  MAKE_HRESULT( 1, _FACDD, code )

#ifdef __cplusplus
extern "C" {
#endif

//
// For compilers that don't support nameless unions, do a
//
// #define NONAMELESSUNION
//
// before #include <ddraw.h>
//
#ifndef DUMMYUNIONNAMEN
#if defined(__cplusplus) || !defined(NONAMELESSUNION)
#define DUMMYUNIONNAMEN(n)
#else
#define DUMMYUNIONNAMEN(n)      u##n
#endif
#endif

#ifndef MAKEFOURCC
    #define MAKEFOURCC(ch0, ch1, ch2, ch3)                              \
                ((DWORD)(BYTE)(ch0) | ((DWORD)(BYTE)(ch1) << 8) |   \
                ((DWORD)(BYTE)(ch2) << 16) | ((DWORD)(BYTE)(ch3) << 24 ))
#endif //defined(MAKEFOURCC)

/*
 * FOURCC codes for DX compressed-texture pixel formats
 */
#define FOURCC_DXT1  (MAKEFOURCC('D','X','T','1'))
#define FOURCC_DXT2  (MAKEFOURCC('D','X','T','2'))
#define FOURCC_DXT3  (MAKEFOURCC('D','X','T','3'))
#define FOURCC_DXT4  (MAKEFOURCC('D','X','T','4'))
#define FOURCC_DXT5  (MAKEFOURCC('D','X','T','5'))

/*
 * GUIDS used by DirectDraw objects
 */
#if defined( _WIN32 ) && !defined( _NO_COM )

DEFINE_GUID( CLSID_DirectDraw,                  0xD7B70EE0,0x4340,0x11CF,0xB0,0x63,0x00,0x20,0xAF,0xC2,0xCD,0x35 );
DEFINE_GUID( CLSID_DirectDraw7,                 0x3c305196,0x50db,0x11d3,0x9c,0xfe,0x00,0xc0,0x4f,0xd9,0x30,0xc5 );
DEFINE_GUID( CLSID_DirectDrawClipper,           0x593817A0,0x7DB3,0x11CF,0xA2,0xDE,0x00,0xAA,0x00,0xb9,0x33,0x56 );
DEFINE_GUID( IID_IDirectDraw,                   0x6C14DB80,0xA733,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60 );
DEFINE_GUID( IID_IDirectDraw2,                  0xB3A6F3E0,0x2B43,0x11CF,0xA2,0xDE,0x00,0xAA,0x00,0xB9,0x33,0x56 );
DEFINE_GUID( IID_IDirectDraw4,                  0x9c59509a,0x39bd,0x11d1,0x8c,0x4a,0x00,0xc0,0x4f,0xd9,0x30,0xc5 );
DEFINE_GUID( IID_IDirectDraw7,                  0x15e65ec0,0x3b9c,0x11d2,0xb9,0x2f,0x00,0x60,0x97,0x97,0xea,0x5b );
DEFINE_GUID( IID_IDirectDrawSurface,            0x6C14DB81,0xA733,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60 );
DEFINE_GUID( IID_IDirectDrawSurface2,           0x57805885,0x6eec,0x11cf,0x94,0x41,0xa8,0x23,0x03,0xc1,0x0e,0x27 );
DEFINE_GUID( IID_IDirectDrawSurface3,           0xDA044E00,0x69B2,0x11D0,0xA1,0xD5,0x00,0xAA,0x00,0xB8,0xDF,0xBB );
DEFINE_GUID( IID_IDirectDrawSurface4,           0x0B2B8630,0xAD35,0x11D0,0x8E,0xA6,0x00,0x60,0x97,0x97,0xEA,0x5B );
DEFINE_GUID( IID_IDirectDrawSurface7,           0x06675a80,0x3b9b,0x11d2,0xb9,0x2f,0x00,0x60,0x97,0x97,0xea,0x5b );
DEFINE_GUID( IID_IDirectDrawPalette,            0x6C14DB84,0xA733,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60 );
DEFINE_GUID( IID_IDirectDrawClipper,            0x6C14DB85,0xA733,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60 );
DEFINE_GUID( IID_IDirectDrawColorControl,       0x4B9F0EE0,0x0D7E,0x11D0,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8 );
DEFINE_GUID( IID_IDirectDrawGammaControl,       0x69C11C3E,0xB46B,0x11D1,0xAD,0x7A,0x00,0xC0,0x4F,0xC2,0x9B,0x4E );

#endif

/*============================================================================
 *
 * DirectDraw Structures
 *
 * Various structures used to invoke DirectDraw.
 *
 *==========================================================================*/

struct IDirectDraw;
struct IDirectDrawSurface;
struct IDirectDrawPalette;
struct IDirectDrawClipper;

typedef struct IDirectDraw              FAR *LPDIRECTDRAW;
typedef struct IDirectDraw2             FAR *LPDIRECTDRAW2;
typedef struct IDirectDraw4             FAR *LPDIRECTDRAW4;
typedef struct IDirectDraw7             FAR *LPDIRECTDRAW7;
typedef struct IDirectDrawSurface       FAR *LPDIRECTDRAWSURFACE;
typedef struct IDirectDrawSurface2      FAR *LPDIRECTDRAWSURFACE2;
typedef struct IDirectDrawSurface3      FAR *LPDIRECTDRAWSURFACE3;
typedef struct IDirectDrawSurface4      FAR *LPDIRECTDRAWSURFACE4;
typedef struct IDirectDrawSurface7      FAR *LPDIRECTDRAWSURFACE7;
typedef struct IDirectDrawPalette               FAR *LPDIRECTDRAWPALETTE;
typedef struct IDirectDrawClipper               FAR *LPDIRECTDRAWCLIPPER;
typedef struct IDirectDrawColorControl          FAR *LPDIRECTDRAWCOLORCONTROL;
typedef struct IDirectDrawGammaControl          FAR *LPDIRECTDRAWGAMMACONTROL;

typedef struct _DDFXROP                 FAR *LPDDFXROP;
typedef struct _DDSURFACEDESC           FAR *LPDDSURFACEDESC;
typedef struct _DDSURFACEDESC2          FAR *LPDDSURFACEDESC2;
typedef struct _DDCOLORCONTROL          FAR *LPDDCOLORCONTROL;

/*
 * API's
 */
#if (defined (WIN32) || defined( _WIN32 ) ) && !defined( _NO_COM )
//#if defined( _WIN32 ) && !defined( _NO_ENUM )
    typedef BOOL (FAR PASCAL * LPDDENUMCALLBACKA)(GUID FAR *, LPSTR, LPSTR, LPVOID);
    typedef BOOL (FAR PASCAL * LPDDENUMCALLBACKW)(GUID FAR *, LPWSTR, LPWSTR, LPVOID);
    extern HRESULT WINAPI DirectDrawEnumerateW( LPDDENUMCALLBACKW lpCallback, LPVOID lpContext );
    extern HRESULT WINAPI DirectDrawEnumerateA( LPDDENUMCALLBACKA lpCallback, LPVOID lpContext );
    /*
     * Protect against old SDKs
     */
    #if !defined(HMONITOR_DECLARED) && (WINVER < 0x0500)
        #define HMONITOR_DECLARED
        DECLARE_HANDLE(HMONITOR);
    #endif
    typedef BOOL (FAR PASCAL * LPDDENUMCALLBACKEXA)(GUID FAR *, LPSTR, LPSTR, LPVOID, HMONITOR);
    typedef BOOL (FAR PASCAL * LPDDENUMCALLBACKEXW)(GUID FAR *, LPWSTR, LPWSTR, LPVOID, HMONITOR);
    extern HRESULT WINAPI DirectDrawEnumerateExW( LPDDENUMCALLBACKEXW lpCallback, LPVOID lpContext, DWORD dwFlags);
    extern HRESULT WINAPI DirectDrawEnumerateExA( LPDDENUMCALLBACKEXA lpCallback, LPVOID lpContext, DWORD dwFlags);
    typedef HRESULT (WINAPI * LPDIRECTDRAWENUMERATEEXA)( LPDDENUMCALLBACKEXA lpCallback, LPVOID lpContext, DWORD dwFlags);
    typedef HRESULT (WINAPI * LPDIRECTDRAWENUMERATEEXW)( LPDDENUMCALLBACKEXW lpCallback, LPVOID lpContext, DWORD dwFlags);

    #ifdef UNICODE
        typedef LPDDENUMCALLBACKW           LPDDENUMCALLBACK;
        #define DirectDrawEnumerate         DirectDrawEnumerateW
        typedef LPDDENUMCALLBACKEXW         LPDDENUMCALLBACKEX;
        typedef LPDIRECTDRAWENUMERATEEXW        LPDIRECTDRAWENUMERATEEX;
        #define DirectDrawEnumerateEx       DirectDrawEnumerateExW
    #else
        typedef LPDDENUMCALLBACKA           LPDDENUMCALLBACK;
        #define DirectDrawEnumerate         DirectDrawEnumerateA
        typedef LPDDENUMCALLBACKEXA         LPDDENUMCALLBACKEX;
        typedef LPDIRECTDRAWENUMERATEEXA        LPDIRECTDRAWENUMERATEEX;
        #define DirectDrawEnumerateEx       DirectDrawEnumerateExA
    #endif
    extern HRESULT WINAPI DirectDrawCreate( GUID FAR *lpGUID, LPDIRECTDRAW FAR *lplpDD, IUnknown FAR *pUnkOuter );
    extern HRESULT WINAPI DirectDrawCreateEx( GUID FAR * lpGuid, LPVOID  *lplpDD, REFIID  iid,IUnknown FAR *pUnkOuter );
    extern HRESULT WINAPI DirectDrawCreateClipper( DWORD dwFlags, LPDIRECTDRAWCLIPPER FAR *lplpDDClipper, IUnknown FAR *pUnkOuter );
#endif
/*
 * Flags for DirectDrawEnumerateEx
 * DirectDrawEnumerateEx supercedes DirectDrawEnumerate. You must use GetProcAddress to
 * obtain a function pointer (of type LPDIRECTDRAWENUMERATEEX) to DirectDrawEnumerateEx.
 * By default, only the primary display device is enumerated.
 * DirectDrawEnumerate is equivalent to DirectDrawEnumerate(,,DDENUM_NONDISPLAYDEVICES)
 */

/*
 * This flag causes enumeration of any GDI display devices which are part of
 * the Windows Desktop
 */
#define DDENUM_ATTACHEDSECONDARYDEVICES     0x00000001L

/*
 * This flag causes enumeration of any GDI display devices which are not
 * part of the Windows Desktop
 */
#define DDENUM_DETACHEDSECONDARYDEVICES     0x00000002L

/*
 * This flag causes enumeration of non-display devices
 */
#define DDENUM_NONDISPLAYDEVICES            0x00000004L


#define REGSTR_KEY_DDHW_DESCRIPTION     "Description"
#define REGSTR_KEY_DDHW_DRIVERNAME      "DriverName"
#define REGSTR_PATH_DDHW                "Hardware\\DirectDrawDrivers"

#define DDCREATE_HARDWAREONLY           0x00000001l
#define DDCREATE_EMULATIONONLY          0x00000002l

#if defined(WINNT) || !defined(WIN32)
typedef long HRESULT;
#endif

//#ifndef WINNT
typedef HRESULT (FAR PASCAL * LPDDENUMMODESCALLBACK)(LPDDSURFACEDESC, LPVOID);
typedef HRESULT (FAR PASCAL * LPDDENUMMODESCALLBACK2)(LPDDSURFACEDESC2, LPVOID);
typedef HRESULT (FAR PASCAL * LPDDENUMSURFACESCALLBACK)(LPDIRECTDRAWSURFACE, LPDDSURFACEDESC, LPVOID);
typedef HRESULT (FAR PASCAL * LPDDENUMSURFACESCALLBACK2)(LPDIRECTDRAWSURFACE4, LPDDSURFACEDESC2, LPVOID);
typedef HRESULT (FAR PASCAL * LPDDENUMSURFACESCALLBACK7)(LPDIRECTDRAWSURFACE7, LPDDSURFACEDESC2, LPVOID);
//#endif

/*
 * Generic pixel format with 8-bit RGB and alpha components
 */
typedef struct _DDARGB
{
    BYTE blue;
    BYTE green;
    BYTE red;
    BYTE alpha;
} DDARGB;

typedef DDARGB FAR *LPDDARGB;

/*
 * This version of the structure remains for backwards source compatibility.
 * The DDARGB structure is the one that should be used for all DirectDraw APIs.
 */
typedef struct _DDRGBA
{
    BYTE red;
    BYTE green;
    BYTE blue;
    BYTE alpha;
} DDRGBA;

typedef DDRGBA FAR *LPDDRGBA;


/*
 * DDCOLORKEY
 */
typedef struct _DDCOLORKEY
{
    DWORD       dwColorSpaceLowValue;   // low boundary of color space that is to
                                        // be treated as Color Key, inclusive
    DWORD       dwColorSpaceHighValue;  // high boundary of color space that is
                                        // to be treated as Color Key, inclusive
} DDCOLORKEY;

typedef DDCOLORKEY FAR* LPDDCOLORKEY;

/*
 * DDBLTFX
 * Used to pass override information to the DIRECTDRAWSURFACE callback Blt.
 */
typedef struct _DDBLTFX
{
    DWORD       dwSize;                         // size of structure
    DWORD       dwDDFX;                         // FX operations
    DWORD       dwROP;                          // Win32 raster operations
    DWORD       dwDDROP;                        // Raster operations new for DirectDraw
    DWORD       dwRotationAngle;                // Rotation angle for blt
    DWORD       dwZBufferOpCode;                // ZBuffer compares
    DWORD       dwZBufferLow;                   // Low limit of Z buffer
    DWORD       dwZBufferHigh;                  // High limit of Z buffer
    DWORD       dwZBufferBaseDest;              // Destination base value
    DWORD       dwZDestConstBitDepth;           // Bit depth used to specify Z constant for destination
    union
    {
        DWORD   dwZDestConst;                   // Constant to use as Z buffer for dest
        LPDIRECTDRAWSURFACE lpDDSZBufferDest;   // Surface to use as Z buffer for dest
    } DUMMYUNIONNAMEN(1);
    DWORD       dwZSrcConstBitDepth;            // Bit depth used to specify Z constant for source
    union
    {
        DWORD   dwZSrcConst;                    // Constant to use as Z buffer for src
        LPDIRECTDRAWSURFACE lpDDSZBufferSrc;    // Surface to use as Z buffer for src
    } DUMMYUNIONNAMEN(2);
    DWORD       dwAlphaEdgeBlendBitDepth;       // Bit depth used to specify constant for alpha edge blend
    DWORD       dwAlphaEdgeBlend;               // Alpha for edge blending
    DWORD       dwReserved;
    DWORD       dwAlphaDestConstBitDepth;       // Bit depth used to specify alpha constant for destination
    union
    {
        DWORD   dwAlphaDestConst;               // Constant to use as Alpha Channel
        LPDIRECTDRAWSURFACE lpDDSAlphaDest;     // Surface to use as Alpha Channel
    } DUMMYUNIONNAMEN(3);
    DWORD       dwAlphaSrcConstBitDepth;        // Bit depth used to specify alpha constant for source
    union
    {
        DWORD   dwAlphaSrcConst;                // Constant to use as Alpha Channel
        LPDIRECTDRAWSURFACE lpDDSAlphaSrc;      // Surface to use as Alpha Channel
    } DUMMYUNIONNAMEN(4);
    union
    {
        DWORD   dwFillColor;                    // color in RGB or Palettized
        DWORD   dwFillDepth;                    // depth value for z-buffer
        DWORD   dwFillPixel;                    // pixel value for RGBA or RGBZ
        LPDIRECTDRAWSURFACE lpDDSPattern;       // Surface to use as pattern
    } DUMMYUNIONNAMEN(5);
    DDCOLORKEY  ddckDestColorkey;               // DestColorkey override
    DDCOLORKEY  ddckSrcColorkey;                // SrcColorkey override
} DDBLTFX;

typedef DDBLTFX FAR* LPDDBLTFX;



/*
 * DDSCAPS
 */
typedef struct _DDSCAPS
{
    DWORD       dwCaps;         // capabilities of surface wanted
} DDSCAPS;

typedef DDSCAPS FAR* LPDDSCAPS;


/*
 * DDOSCAPS
 */
typedef struct _DDOSCAPS
{
    DWORD       dwCaps;         // capabilities of surface wanted
} DDOSCAPS;

typedef DDOSCAPS FAR* LPDDOSCAPS;

/*
 * This structure is used internally by DirectDraw.
 */
typedef struct _DDSCAPSEX
{
    DWORD       dwCaps2;
    DWORD       dwCaps3;
    union
    {
        DWORD       dwCaps4;
        DWORD       dwVolumeDepth;
    } DUMMYUNIONNAMEN(1);
} DDSCAPSEX, FAR * LPDDSCAPSEX;

/*
 * DDSCAPS2
 */
typedef struct _DDSCAPS2
{
    DWORD       dwCaps;         // capabilities of surface wanted
    DWORD       dwCaps2;
    DWORD       dwCaps3;
    union
    {
        DWORD       dwCaps4;
        DWORD       dwVolumeDepth;
    } DUMMYUNIONNAMEN(1);
} DDSCAPS2;

typedef DDSCAPS2 FAR* LPDDSCAPS2;

/*
 * DDCAPS
 */
#define DD_ROP_SPACE            (256/32)        // space required to store ROP array
/*
 * NOTE: Our choosen structure number scheme is to append a single digit to
 * the end of the structure giving the version that structure is associated
 * with.
 */

/*
 * This structure represents the DDCAPS structure released in DirectDraw 1.0.  It is used internally
 * by DirectDraw to interpret caps passed into ddraw by drivers written prior to the release of DirectDraw 2.0.
 * New applications should use the DDCAPS structure defined below.
 */
typedef struct _DDCAPS_DX1
{
    DWORD       dwSize;                 // size of the DDDRIVERCAPS structure
    DWORD       dwCaps;                 // driver specific capabilities
    DWORD       dwCaps2;                // more driver specific capabilites
    DWORD       dwCKeyCaps;             // color key capabilities of the surface
    DWORD       dwFXCaps;               // driver specific stretching and effects capabilites
    DWORD       dwFXAlphaCaps;          // alpha driver specific capabilities
    DWORD       dwPalCaps;              // palette capabilities
    DWORD       dwSVCaps;               // stereo vision capabilities
    DWORD       dwAlphaBltConstBitDepths;       // DDBD_2,4,8
    DWORD       dwAlphaBltPixelBitDepths;       // DDBD_1,2,4,8
    DWORD       dwAlphaBltSurfaceBitDepths;     // DDBD_1,2,4,8
    DWORD       dwAlphaOverlayConstBitDepths;   // DDBD_2,4,8
    DWORD       dwAlphaOverlayPixelBitDepths;   // DDBD_1,2,4,8
    DWORD       dwAlphaOverlaySurfaceBitDepths; // DDBD_1,2,4,8
    DWORD       dwZBufferBitDepths;             // DDBD_8,16,24,32
    DWORD       dwVidMemTotal;          // total amount of video memory
    DWORD       dwVidMemFree;           // amount of free video memory
    DWORD       dwMaxVisibleOverlays;   // maximum number of visible overlays
    DWORD       dwCurrVisibleOverlays;  // current number of visible overlays
    DWORD       dwNumFourCCCodes;       // number of four cc codes
    DWORD       dwAlignBoundarySrc;     // source rectangle alignment
    DWORD       dwAlignSizeSrc;         // source rectangle byte size
    DWORD       dwAlignBoundaryDest;    // dest rectangle alignment
    DWORD       dwAlignSizeDest;        // dest rectangle byte size
    DWORD       dwAlignStrideAlign;     // stride alignment
    DWORD       dwRops[DD_ROP_SPACE];   // ROPS supported
    DDSCAPS     ddsCaps;                // DDSCAPS structure has all the general capabilities
    DWORD       dwMinOverlayStretch;    // minimum overlay stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD       dwMaxOverlayStretch;    // maximum overlay stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD       dwMinLiveVideoStretch;  // OBSOLETE! This field remains for compatability reasons only
    DWORD       dwMaxLiveVideoStretch;  // OBSOLETE! This field remains for compatability reasons only
    DWORD       dwMinHwCodecStretch;    // OBSOLETE! This field remains for compatability reasons only
    DWORD       dwMaxHwCodecStretch;    // OBSOLETE! This field remains for compatability reasons only
    DWORD       dwReserved1;            // reserved
    DWORD       dwReserved2;            // reserved
    DWORD       dwReserved3;            // reserved
} DDCAPS_DX1;

typedef DDCAPS_DX1 FAR* LPDDCAPS_DX1;

/*
 * This structure is the DDCAPS structure as it was in version 2 and 3 of Direct X.
 * It is present for back compatability.
 */
typedef struct _DDCAPS_DX3
{
    DWORD       dwSize;                 // size of the DDDRIVERCAPS structure
    DWORD       dwCaps;                 // driver specific capabilities
    DWORD       dwCaps2;                // more driver specific capabilites
    DWORD       dwCKeyCaps;             // color key capabilities of the surface
    DWORD       dwFXCaps;               // driver specific stretching and effects capabilites
    DWORD       dwFXAlphaCaps;          // alpha driver specific capabilities
    DWORD       dwPalCaps;              // palette capabilities
    DWORD       dwSVCaps;               // stereo vision capabilities
    DWORD       dwAlphaBltConstBitDepths;       // DDBD_2,4,8
    DWORD       dwAlphaBltPixelBitDepths;       // DDBD_1,2,4,8
    DWORD       dwAlphaBltSurfaceBitDepths;     // DDBD_1,2,4,8
    DWORD       dwAlphaOverlayConstBitDepths;   // DDBD_2,4,8
    DWORD       dwAlphaOverlayPixelBitDepths;   // DDBD_1,2,4,8
    DWORD       dwAlphaOverlaySurfaceBitDepths; // DDBD_1,2,4,8
    DWORD       dwZBufferBitDepths;             // DDBD_8,16,24,32
    DWORD       dwVidMemTotal;          // total amount of video memory
    DWORD       dwVidMemFree;           // amount of free video memory
    DWORD       dwMaxVisibleOverlays;   // maximum number of visible overlays
    DWORD       dwCurrVisibleOverlays;  // current number of visible overlays
    DWORD       dwNumFourCCCodes;       // number of four cc codes
    DWORD       dwAlignBoundarySrc;     // source rectangle alignment
    DWORD       dwAlignSizeSrc;         // source rectangle byte size
    DWORD       dwAlignBoundaryDest;    // dest rectangle alignment
    DWORD       dwAlignSizeDest;        // dest rectangle byte size
    DWORD       dwAlignStrideAlign;     // stride alignment
    DWORD       dwRops[DD_ROP_SPACE];   // ROPS supported
    DDSCAPS     ddsCaps;                // DDSCAPS structure has all the general capabilities
    DWORD       dwMinOverlayStretch;    // minimum overlay stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD       dwMaxOverlayStretch;    // maximum overlay stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD       dwMinLiveVideoStretch;  // minimum live video stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD       dwMaxLiveVideoStretch;  // maximum live video stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD       dwMinHwCodecStretch;    // minimum hardware codec stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD       dwMaxHwCodecStretch;    // maximum hardware codec stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD       dwReserved1;            // reserved
    DWORD       dwReserved2;            // reserved
    DWORD       dwReserved3;            // reserved
    DWORD       dwSVBCaps;              // driver specific capabilities for System->Vmem blts
    DWORD       dwSVBCKeyCaps;          // driver color key capabilities for System->Vmem blts
    DWORD       dwSVBFXCaps;            // driver FX capabilities for System->Vmem blts
    DWORD       dwSVBRops[DD_ROP_SPACE];// ROPS supported for System->Vmem blts
    DWORD       dwVSBCaps;              // driver specific capabilities for Vmem->System blts
    DWORD       dwVSBCKeyCaps;          // driver color key capabilities for Vmem->System blts
    DWORD       dwVSBFXCaps;            // driver FX capabilities for Vmem->System blts
    DWORD       dwVSBRops[DD_ROP_SPACE];// ROPS supported for Vmem->System blts
    DWORD       dwSSBCaps;              // driver specific capabilities for System->System blts
    DWORD       dwSSBCKeyCaps;          // driver color key capabilities for System->System blts
    DWORD       dwSSBFXCaps;            // driver FX capabilities for System->System blts
    DWORD       dwSSBRops[DD_ROP_SPACE];// ROPS supported for System->System blts
    DWORD       dwReserved4;            // reserved
    DWORD       dwReserved5;            // reserved
    DWORD       dwReserved6;            // reserved
} DDCAPS_DX3;
typedef DDCAPS_DX3 FAR* LPDDCAPS_DX3;

/*
 * This structure is the DDCAPS structure as it was in version 5 of Direct X.
 * It is present for back compatability.
 */
typedef struct _DDCAPS_DX5
{
/*  0*/ DWORD   dwSize;                 // size of the DDDRIVERCAPS structure
/*  4*/ DWORD   dwCaps;                 // driver specific capabilities
/*  8*/ DWORD   dwCaps2;                // more driver specific capabilites
/*  c*/ DWORD   dwCKeyCaps;             // color key capabilities of the surface
/* 10*/ DWORD   dwFXCaps;               // driver specific stretching and effects capabilites
/* 14*/ DWORD   dwFXAlphaCaps;          // alpha driver specific capabilities
/* 18*/ DWORD   dwPalCaps;              // palette capabilities
/* 1c*/ DWORD   dwSVCaps;               // stereo vision capabilities
/* 20*/ DWORD   dwAlphaBltConstBitDepths;       // DDBD_2,4,8
/* 24*/ DWORD   dwAlphaBltPixelBitDepths;       // DDBD_1,2,4,8
/* 28*/ DWORD   dwAlphaBltSurfaceBitDepths;     // DDBD_1,2,4,8
/* 2c*/ DWORD   dwAlphaOverlayConstBitDepths;   // DDBD_2,4,8
/* 30*/ DWORD   dwAlphaOverlayPixelBitDepths;   // DDBD_1,2,4,8
/* 34*/ DWORD   dwAlphaOverlaySurfaceBitDepths; // DDBD_1,2,4,8
/* 38*/ DWORD   dwZBufferBitDepths;             // DDBD_8,16,24,32
/* 3c*/ DWORD   dwVidMemTotal;          // total amount of video memory
/* 40*/ DWORD   dwVidMemFree;           // amount of free video memory
/* 44*/ DWORD   dwMaxVisibleOverlays;   // maximum number of visible overlays
/* 48*/ DWORD   dwCurrVisibleOverlays;  // current number of visible overlays
/* 4c*/ DWORD   dwNumFourCCCodes;       // number of four cc codes
/* 50*/ DWORD   dwAlignBoundarySrc;     // source rectangle alignment
/* 54*/ DWORD   dwAlignSizeSrc;         // source rectangle byte size
/* 58*/ DWORD   dwAlignBoundaryDest;    // dest rectangle alignment
/* 5c*/ DWORD   dwAlignSizeDest;        // dest rectangle byte size
/* 60*/ DWORD   dwAlignStrideAlign;     // stride alignment
/* 64*/ DWORD   dwRops[DD_ROP_SPACE];   // ROPS supported
/* 84*/ DDSCAPS ddsCaps;                // DDSCAPS structure has all the general capabilities
/* 88*/ DWORD   dwMinOverlayStretch;    // minimum overlay stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
/* 8c*/ DWORD   dwMaxOverlayStretch;    // maximum overlay stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
/* 90*/ DWORD   dwMinLiveVideoStretch;  // minimum live video stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
/* 94*/ DWORD   dwMaxLiveVideoStretch;  // maximum live video stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
/* 98*/ DWORD   dwMinHwCodecStretch;    // minimum hardware codec stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
/* 9c*/ DWORD   dwMaxHwCodecStretch;    // maximum hardware codec stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
/* a0*/ DWORD   dwReserved1;            // reserved
/* a4*/ DWORD   dwReserved2;            // reserved
/* a8*/ DWORD   dwReserved3;            // reserved
/* ac*/ DWORD   dwSVBCaps;              // driver specific capabilities for System->Vmem blts
/* b0*/ DWORD   dwSVBCKeyCaps;          // driver color key capabilities for System->Vmem blts
/* b4*/ DWORD   dwSVBFXCaps;            // driver FX capabilities for System->Vmem blts
/* b8*/ DWORD   dwSVBRops[DD_ROP_SPACE];// ROPS supported for System->Vmem blts
/* d8*/ DWORD   dwVSBCaps;              // driver specific capabilities for Vmem->System blts
/* dc*/ DWORD   dwVSBCKeyCaps;          // driver color key capabilities for Vmem->System blts
/* e0*/ DWORD   dwVSBFXCaps;            // driver FX capabilities for Vmem->System blts
/* e4*/ DWORD   dwVSBRops[DD_ROP_SPACE];// ROPS supported for Vmem->System blts
/*104*/ DWORD   dwSSBCaps;              // driver specific capabilities for System->System blts
/*108*/ DWORD   dwSSBCKeyCaps;          // driver color key capabilities for System->System blts
/*10c*/ DWORD   dwSSBFXCaps;            // driver FX capabilities for System->System blts
/*110*/ DWORD   dwSSBRops[DD_ROP_SPACE];// ROPS supported for System->System blts
// Members added for DX5:
/*130*/ DWORD   dwMaxVideoPorts;        // maximum number of usable video ports
/*134*/ DWORD   dwCurrVideoPorts;       // current number of video ports used
/*138*/ DWORD   dwSVBCaps2;             // more driver specific capabilities for System->Vmem blts
/*13c*/ DWORD   dwNLVBCaps;               // driver specific capabilities for non-local->local vidmem blts
/*140*/ DWORD   dwNLVBCaps2;              // more driver specific capabilities non-local->local vidmem blts
/*144*/ DWORD   dwNLVBCKeyCaps;           // driver color key capabilities for non-local->local vidmem blts
/*148*/ DWORD   dwNLVBFXCaps;             // driver FX capabilities for non-local->local blts
/*14c*/ DWORD   dwNLVBRops[DD_ROP_SPACE]; // ROPS supported for non-local->local blts
} DDCAPS_DX5;
typedef DDCAPS_DX5 FAR* LPDDCAPS_DX5;

typedef struct _DDCAPS_DX6
{
/*  0*/ DWORD   dwSize;                 // size of the DDDRIVERCAPS structure
/*  4*/ DWORD   dwCaps;                 // driver specific capabilities
/*  8*/ DWORD   dwCaps2;                // more driver specific capabilites
/*  c*/ DWORD   dwCKeyCaps;             // color key capabilities of the surface
/* 10*/ DWORD   dwFXCaps;               // driver specific stretching and effects capabilites
/* 14*/ DWORD   dwFXAlphaCaps;          // alpha caps
/* 18*/ DWORD   dwPalCaps;              // palette capabilities
/* 1c*/ DWORD   dwSVCaps;               // stereo vision capabilities
/* 20*/ DWORD   dwAlphaBltConstBitDepths;       // DDBD_2,4,8
/* 24*/ DWORD   dwAlphaBltPixelBitDepths;       // DDBD_1,2,4,8
/* 28*/ DWORD   dwAlphaBltSurfaceBitDepths;     // DDBD_1,2,4,8
/* 2c*/ DWORD   dwAlphaOverlayConstBitDepths;   // DDBD_2,4,8
/* 30*/ DWORD   dwAlphaOverlayPixelBitDepths;   // DDBD_1,2,4,8
/* 34*/ DWORD   dwAlphaOverlaySurfaceBitDepths; // DDBD_1,2,4,8
/* 38*/ DWORD   dwZBufferBitDepths;             // DDBD_8,16,24,32
/* 3c*/ DWORD   dwVidMemTotal;          // total amount of video memory
/* 40*/ DWORD   dwVidMemFree;           // amount of free video memory
/* 44*/ DWORD   dwMaxVisibleOverlays;   // maximum number of visible overlays
/* 48*/ DWORD   dwCurrVisibleOverlays;  // current number of visible overlays
/* 4c*/ DWORD   dwNumFourCCCodes;       // number of four cc codes
/* 50*/ DWORD   dwAlignBoundarySrc;     // source rectangle alignment
/* 54*/ DWORD   dwAlignSizeSrc;         // source rectangle byte size
/* 58*/ DWORD   dwAlignBoundaryDest;    // dest rectangle alignment
/* 5c*/ DWORD   dwAlignSizeDest;        // dest rectangle byte size
/* 60*/ DWORD   dwAlignStrideAlign;     // stride alignment
/* 64*/ DWORD   dwRops[DD_ROP_SPACE];   // ROPS supported
/* 84*/ DDSCAPS ddsOldCaps;             // Was DDSCAPS  ddsCaps. ddsCaps is of type DDSCAPS2 for DX6
/* 88*/ DWORD   dwMinOverlayStretch;    // minimum overlay stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
/* 8c*/ DWORD   dwMaxOverlayStretch;    // maximum overlay stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
/* 90*/ DWORD   dwMinLiveVideoStretch;  // minimum live video stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
/* 94*/ DWORD   dwMaxLiveVideoStretch;  // maximum live video stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
/* 98*/ DWORD   dwMinHwCodecStretch;    // minimum hardware codec stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
/* 9c*/ DWORD   dwMaxHwCodecStretch;    // maximum hardware codec stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
/* a0*/ DWORD   dwReserved1;            // reserved
/* a4*/ DWORD   dwReserved2;            // reserved
/* a8*/ DWORD   dwReserved3;            // reserved
/* ac*/ DWORD   dwSVBCaps;              // driver specific capabilities for System->Vmem blts
/* b0*/ DWORD   dwSVBCKeyCaps;          // driver color key capabilities for System->Vmem blts
/* b4*/ DWORD   dwSVBFXCaps;            // driver FX capabilities for System->Vmem blts
/* b8*/ DWORD   dwSVBRops[DD_ROP_SPACE];// ROPS supported for System->Vmem blts
/* d8*/ DWORD   dwVSBCaps;              // driver specific capabilities for Vmem->System blts
/* dc*/ DWORD   dwVSBCKeyCaps;          // driver color key capabilities for Vmem->System blts
/* e0*/ DWORD   dwVSBFXCaps;            // driver FX capabilities for Vmem->System blts
/* e4*/ DWORD   dwVSBRops[DD_ROP_SPACE];// ROPS supported for Vmem->System blts
/*104*/ DWORD   dwSSBCaps;              // driver specific capabilities for System->System blts
/*108*/ DWORD   dwSSBCKeyCaps;          // driver color key capabilities for System->System blts
/*10c*/ DWORD   dwSSBFXCaps;            // driver FX capabilities for System->System blts
/*110*/ DWORD   dwSSBRops[DD_ROP_SPACE];// ROPS supported for System->System blts
/*130*/ DWORD   dwMaxVideoPorts;        // maximum number of usable video ports
/*134*/ DWORD   dwCurrVideoPorts;       // current number of video ports used
/*138*/ DWORD   dwSVBCaps2;             // more driver specific capabilities for System->Vmem blts
/*13c*/ DWORD   dwNLVBCaps;               // driver specific capabilities for non-local->local vidmem blts
/*140*/ DWORD   dwNLVBCaps2;              // more driver specific capabilities non-local->local vidmem blts
/*144*/ DWORD   dwNLVBCKeyCaps;           // driver color key capabilities for non-local->local vidmem blts
/*148*/ DWORD   dwNLVBFXCaps;             // driver FX capabilities for non-local->local blts
/*14c*/ DWORD   dwNLVBRops[DD_ROP_SPACE]; // ROPS supported for non-local->local blts
// Members added for DX6 release
/*16c*/ DDSCAPS2 ddsCaps;               // Surface Caps
} DDCAPS_DX6;
typedef DDCAPS_DX6 FAR* LPDDCAPS_DX6;

typedef struct _DDCAPS_DX7
{
/*  0*/ DWORD   dwSize;                 // size of the DDDRIVERCAPS structure
/*  4*/ DWORD   dwCaps;                 // driver specific capabilities
/*  8*/ DWORD   dwCaps2;                // more driver specific capabilites
/*  c*/ DWORD   dwCKeyCaps;             // color key capabilities of the surface
/* 10*/ DWORD   dwFXCaps;               // driver specific stretching and effects capabilites
/* 14*/ DWORD   dwFXAlphaCaps;          // alpha driver specific capabilities
/* 18*/ DWORD   dwPalCaps;              // palette capabilities
/* 1c*/ DWORD   dwSVCaps;               // stereo vision capabilities
/* 20*/ DWORD   dwAlphaBltConstBitDepths;       // DDBD_2,4,8
/* 24*/ DWORD   dwAlphaBltPixelBitDepths;       // DDBD_1,2,4,8
/* 28*/ DWORD   dwAlphaBltSurfaceBitDepths;     // DDBD_1,2,4,8
/* 2c*/ DWORD   dwAlphaOverlayConstBitDepths;   // DDBD_2,4,8
/* 30*/ DWORD   dwAlphaOverlayPixelBitDepths;   // DDBD_1,2,4,8
/* 34*/ DWORD   dwAlphaOverlaySurfaceBitDepths; // DDBD_1,2,4,8
/* 38*/ DWORD   dwZBufferBitDepths;             // DDBD_8,16,24,32
/* 3c*/ DWORD   dwVidMemTotal;          // total amount of video memory
/* 40*/ DWORD   dwVidMemFree;           // amount of free video memory
/* 44*/ DWORD   dwMaxVisibleOverlays;   // maximum number of visible overlays
/* 48*/ DWORD   dwCurrVisibleOverlays;  // current number of visible overlays
/* 4c*/ DWORD   dwNumFourCCCodes;       // number of four cc codes
/* 50*/ DWORD   dwAlignBoundarySrc;     // source rectangle alignment
/* 54*/ DWORD   dwAlignSizeSrc;         // source rectangle byte size
/* 58*/ DWORD   dwAlignBoundaryDest;    // dest rectangle alignment
/* 5c*/ DWORD   dwAlignSizeDest;        // dest rectangle byte size
/* 60*/ DWORD   dwAlignStrideAlign;     // stride alignment
/* 64*/ DWORD   dwRops[DD_ROP_SPACE];   // ROPS supported
/* 84*/ DDSCAPS ddsOldCaps;             // Was DDSCAPS  ddsCaps. ddsCaps is of type DDSCAPS2 for DX6
/* 88*/ DWORD   dwMinOverlayStretch;    // minimum overlay stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
/* 8c*/ DWORD   dwMaxOverlayStretch;    // maximum overlay stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
/* 90*/ DWORD   dwMinLiveVideoStretch;  // minimum live video stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
/* 94*/ DWORD   dwMaxLiveVideoStretch;  // maximum live video stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
/* 98*/ DWORD   dwMinHwCodecStretch;    // minimum hardware codec stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
/* 9c*/ DWORD   dwMaxHwCodecStretch;    // maximum hardware codec stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
/* a0*/ DWORD   dwReserved1;            // reserved
/* a4*/ DWORD   dwReserved2;            // reserved
/* a8*/ DWORD   dwReserved3;            // reserved
/* ac*/ DWORD   dwSVBCaps;              // driver specific capabilities for System->Vmem blts
/* b0*/ DWORD   dwSVBCKeyCaps;          // driver color key capabilities for System->Vmem blts
/* b4*/ DWORD   dwSVBFXCaps;            // driver FX capabilities for System->Vmem blts
/* b8*/ DWORD   dwSVBRops[DD_ROP_SPACE];// ROPS supported for System->Vmem blts
/* d8*/ DWORD   dwVSBCaps;              // driver specific capabilities for Vmem->System blts
/* dc*/ DWORD   dwVSBCKeyCaps;          // driver color key capabilities for Vmem->System blts
/* e0*/ DWORD   dwVSBFXCaps;            // driver FX capabilities for Vmem->System blts
/* e4*/ DWORD   dwVSBRops[DD_ROP_SPACE];// ROPS supported for Vmem->System blts
/*104*/ DWORD   dwSSBCaps;              // driver specific capabilities for System->System blts
/*108*/ DWORD   dwSSBCKeyCaps;          // driver color key capabilities for System->System blts
/*10c*/ DWORD   dwSSBFXCaps;            // driver FX capabilities for System->System blts
/*110*/ DWORD   dwSSBRops[DD_ROP_SPACE];// ROPS supported for System->System blts
/*130*/ DWORD   dwMaxVideoPorts;        // maximum number of usable video ports
/*134*/ DWORD   dwCurrVideoPorts;       // current number of video ports used
/*138*/ DWORD   dwSVBCaps2;             // more driver specific capabilities for System->Vmem blts
/*13c*/ DWORD   dwNLVBCaps;               // driver specific capabilities for non-local->local vidmem blts
/*140*/ DWORD   dwNLVBCaps2;              // more driver specific capabilities non-local->local vidmem blts
/*144*/ DWORD   dwNLVBCKeyCaps;           // driver color key capabilities for non-local->local vidmem blts
/*148*/ DWORD   dwNLVBFXCaps;             // driver FX capabilities for non-local->local blts
/*14c*/ DWORD   dwNLVBRops[DD_ROP_SPACE]; // ROPS supported for non-local->local blts
// Members added for DX6 release
/*16c*/ DDSCAPS2 ddsCaps;               // Surface Caps
} DDCAPS_DX7;
typedef DDCAPS_DX7 FAR* LPDDCAPS_DX7;


#if DIRECTDRAW_VERSION <= 0x300
    typedef DDCAPS_DX3 DDCAPS;
#elif DIRECTDRAW_VERSION <= 0x500
    typedef DDCAPS_DX5 DDCAPS;
#elif DIRECTDRAW_VERSION <= 0x600
    typedef DDCAPS_DX6 DDCAPS;
#else
    typedef DDCAPS_DX7 DDCAPS;
#endif

typedef DDCAPS FAR* LPDDCAPS;



/*
 * DDPIXELFORMAT
 */
typedef struct _DDPIXELFORMAT
{
    DWORD       dwSize;                 // size of structure
    DWORD       dwFlags;                // pixel format flags
    DWORD       dwFourCC;               // (FOURCC code)
    union
    {
        DWORD   dwRGBBitCount;          // how many bits per pixel
        DWORD   dwYUVBitCount;          // how many bits per pixel
        DWORD   dwZBufferBitDepth;      // how many total bits/pixel in z buffer (including any stencil bits)
        DWORD   dwAlphaBitDepth;        // how many bits for alpha channels
        DWORD   dwLuminanceBitCount;    // how many bits per pixel
        DWORD   dwBumpBitCount;         // how many bits per "buxel", total
        DWORD   dwPrivateFormatBitCount;// Bits per pixel of private driver formats. Only valid in texture
                                        // format list and if DDPF_D3DFORMAT is set
    } DUMMYUNIONNAMEN(1);
    union
    {
        DWORD   dwRBitMask;             // mask for red bit
        DWORD   dwYBitMask;             // mask for Y bits
        DWORD   dwStencilBitDepth;      // how many stencil bits (note: dwZBufferBitDepth-dwStencilBitDepth is total Z-only bits)
        DWORD   dwLuminanceBitMask;     // mask for luminance bits
        DWORD   dwBumpDuBitMask;        // mask for bump map U delta bits
        DWORD   dwOperations;           // DDPF_D3DFORMAT Operations
    } DUMMYUNIONNAMEN(2);
    union
    {
        DWORD   dwGBitMask;             // mask for green bits
        DWORD   dwUBitMask;             // mask for U bits
        DWORD   dwZBitMask;             // mask for Z bits
        DWORD   dwBumpDvBitMask;        // mask for bump map V delta bits
        struct
        {
            WORD    wFlipMSTypes;       // Multisample methods supported via flip for this D3DFORMAT
            WORD    wBltMSTypes;        // Multisample methods supported via blt for this D3DFORMAT
        } MultiSampleCaps;

    } DUMMYUNIONNAMEN(3);
    union
    {
        DWORD   dwBBitMask;             // mask for blue bits
        DWORD   dwVBitMask;             // mask for V bits
        DWORD   dwStencilBitMask;       // mask for stencil bits
        DWORD   dwBumpLuminanceBitMask; // mask for luminance in bump map
    } DUMMYUNIONNAMEN(4);
    union
    {
        DWORD   dwRGBAlphaBitMask;      // mask for alpha channel
        DWORD   dwYUVAlphaBitMask;      // mask for alpha channel
        DWORD   dwLuminanceAlphaBitMask;// mask for alpha channel
        DWORD   dwRGBZBitMask;          // mask for Z channel
        DWORD   dwYUVZBitMask;          // mask for Z channel
    } DUMMYUNIONNAMEN(5);
} DDPIXELFORMAT;

typedef DDPIXELFORMAT FAR* LPDDPIXELFORMAT;

/*
 * DDOVERLAYFX
 */
typedef struct _DDOVERLAYFX
{
    DWORD       dwSize;                         // size of structure
    DWORD       dwAlphaEdgeBlendBitDepth;       // Bit depth used to specify constant for alpha edge blend
    DWORD       dwAlphaEdgeBlend;               // Constant to use as alpha for edge blend
    DWORD       dwReserved;
    DWORD       dwAlphaDestConstBitDepth;       // Bit depth used to specify alpha constant for destination
    union
    {
        DWORD   dwAlphaDestConst;               // Constant to use as alpha channel for dest
        LPDIRECTDRAWSURFACE lpDDSAlphaDest;     // Surface to use as alpha channel for dest
    } DUMMYUNIONNAMEN(1);
    DWORD       dwAlphaSrcConstBitDepth;        // Bit depth used to specify alpha constant for source
    union
    {
        DWORD   dwAlphaSrcConst;                // Constant to use as alpha channel for src
        LPDIRECTDRAWSURFACE lpDDSAlphaSrc;      // Surface to use as alpha channel for src
    } DUMMYUNIONNAMEN(2);
    DDCOLORKEY  dckDestColorkey;                // DestColorkey override
    DDCOLORKEY  dckSrcColorkey;                 // DestColorkey override
    DWORD       dwDDFX;                         // Overlay FX
    DWORD       dwFlags;                        // flags
} DDOVERLAYFX;

typedef DDOVERLAYFX FAR *LPDDOVERLAYFX;


/*
 * DDBLTBATCH: BltBatch entry structure
 */
typedef struct _DDBLTBATCH
{
    LPRECT              lprDest;
    LPDIRECTDRAWSURFACE lpDDSSrc;
    LPRECT              lprSrc;
    DWORD               dwFlags;
    LPDDBLTFX           lpDDBltFx;
} DDBLTBATCH;

typedef DDBLTBATCH FAR * LPDDBLTBATCH;


/*
 * DDGAMMARAMP
 */
typedef struct _DDGAMMARAMP
{
    WORD                red[256];
    WORD                green[256];
    WORD                blue[256];
} DDGAMMARAMP;
typedef DDGAMMARAMP FAR * LPDDGAMMARAMP;

/*
 *  This is the structure within which DirectDraw returns data about the current graphics driver and chipset
 */

#define MAX_DDDEVICEID_STRING           512

typedef struct tagDDDEVICEIDENTIFIER
{
    /*
     * These elements are for presentation to the user only. They should not be used to identify particular
     * drivers, since this is unreliable and many different strings may be associated with the same
     * device, and the same driver from different vendors.
     */
    char    szDriver[MAX_DDDEVICEID_STRING];
    char    szDescription[MAX_DDDEVICEID_STRING];

    /*
     * This element is the version of the DirectDraw/3D driver. It is legal to do <, > comparisons
     * on the whole 64 bits. Caution should be exercised if you use this element to identify problematic
     * drivers. It is recommended that guidDeviceIdentifier is used for this purpose.
     *
     * This version has the form:
     *  wProduct = HIWORD(liDriverVersion.HighPart)
     *  wVersion = LOWORD(liDriverVersion.HighPart)
     *  wSubVersion = HIWORD(liDriverVersion.LowPart)
     *  wBuild = LOWORD(liDriverVersion.LowPart)
     */
#ifdef _WIN32
    LARGE_INTEGER liDriverVersion;      /* Defined for applications and other 32 bit components */
#else
    DWORD   dwDriverVersionLowPart;     /* Defined for 16 bit driver components */
    DWORD   dwDriverVersionHighPart;
#endif


    /*
     * These elements can be used to identify particular chipsets. Use with extreme caution.
     *   dwVendorId     Identifies the manufacturer. May be zero if unknown.
     *   dwDeviceId     Identifies the type of chipset. May be zero if unknown.
     *   dwSubSysId     Identifies the subsystem, typically this means the particular board. May be zero if unknown.
     *   dwRevision     Identifies the revision level of the chipset. May be zero if unknown.
     */
    DWORD   dwVendorId;
    DWORD   dwDeviceId;
    DWORD   dwSubSysId;
    DWORD   dwRevision;

    /*
     * This element can be used to check changes in driver/chipset. This GUID is a unique identifier for the
     * driver/chipset pair. Use this element if you wish to track changes to the driver/chipset in order to
     * reprofile the graphics subsystem.
     * This element can also be used to identify particular problematic drivers.
     */
    GUID    guidDeviceIdentifier;
} DDDEVICEIDENTIFIER, * LPDDDEVICEIDENTIFIER;

typedef struct tagDDDEVICEIDENTIFIER2
{
    /*
     * These elements are for presentation to the user only. They should not be used to identify particular
     * drivers, since this is unreliable and many different strings may be associated with the same
     * device, and the same driver from different vendors.
     */
    char    szDriver[MAX_DDDEVICEID_STRING];
    char    szDescription[MAX_DDDEVICEID_STRING];

    /*
     * This element is the version of the DirectDraw/3D driver. It is legal to do <, > comparisons
     * on the whole 64 bits. Caution should be exercised if you use this element to identify problematic
     * drivers. It is recommended that guidDeviceIdentifier is used for this purpose.
     *
     * This version has the form:
     *  wProduct = HIWORD(liDriverVersion.HighPart)
     *  wVersion = LOWORD(liDriverVersion.HighPart)
     *  wSubVersion = HIWORD(liDriverVersion.LowPart)
     *  wBuild = LOWORD(liDriverVersion.LowPart)
     */
#ifdef _WIN32
    LARGE_INTEGER liDriverVersion;      /* Defined for applications and other 32 bit components */
#else
    DWORD   dwDriverVersionLowPart;     /* Defined for 16 bit driver components */
    DWORD   dwDriverVersionHighPart;
#endif


    /*
     * These elements can be used to identify particular chipsets. Use with extreme caution.
     *   dwVendorId     Identifies the manufacturer. May be zero if unknown.
     *   dwDeviceId     Identifies the type of chipset. May be zero if unknown.
     *   dwSubSysId     Identifies the subsystem, typically this means the particular board. May be zero if unknown.
     *   dwRevision     Identifies the revision level of the chipset. May be zero if unknown.
     */
    DWORD   dwVendorId;
    DWORD   dwDeviceId;
    DWORD   dwSubSysId;
    DWORD   dwRevision;

    /*
     * This element can be used to check changes in driver/chipset. This GUID is a unique identifier for the
     * driver/chipset pair. Use this element if you wish to track changes to the driver/chipset in order to
     * reprofile the graphics subsystem.
     * This element can also be used to identify particular problematic drivers.
     */
    GUID    guidDeviceIdentifier;

    /*
     * This element is used to determine the Windows Hardware Quality Lab (WHQL)
     * certification level for this driver/device pair.
     */
    DWORD   dwWHQLLevel;

} DDDEVICEIDENTIFIER2, * LPDDDEVICEIDENTIFIER2;

/*
 * Flags for the IDirectDraw4::GetDeviceIdentifier method
 */

/*
 * This flag causes GetDeviceIdentifier to return information about the host (typically 2D) adapter in a system equipped
 * with a stacked secondary 3D adapter. Such an adapter appears to the application as if it were part of the
 * host adapter, but is typically physcially located on a separate card. The stacked secondary's information is
 * returned when GetDeviceIdentifier's dwFlags field is zero, since this most accurately reflects the qualities
 * of the DirectDraw object involved.
 */
#define DDGDI_GETHOSTIDENTIFIER         0x00000001L

/*
 * Macros for interpretting DDEVICEIDENTIFIER2.dwWHQLLevel
 */
#define GET_WHQL_YEAR( dwWHQLLevel ) \
    ( (dwWHQLLevel) / 0x10000 )
#define GET_WHQL_MONTH( dwWHQLLevel ) \
    ( ( (dwWHQLLevel) / 0x100 ) & 0x00ff )
#define GET_WHQL_DAY( dwWHQLLevel ) \
    ( (dwWHQLLevel) & 0xff )


/*
 * callbacks
 */
typedef DWORD   (FAR PASCAL *LPCLIPPERCALLBACK)(LPDIRECTDRAWCLIPPER lpDDClipper, HWND hWnd, DWORD code, LPVOID lpContext );
#ifdef STREAMING
typedef DWORD   (FAR PASCAL *LPSURFACESTREAMINGCALLBACK)(DWORD);
#endif


/*
 * INTERACES FOLLOW:
 *      IDirectDraw
 *      IDirectDrawClipper
 *      IDirectDrawPalette
 *      IDirectDrawSurface
 */

/*
 * IDirectDraw
 */
#if defined( _WIN32 ) && !defined( _NO_COM )
#undef INTERFACE
#define INTERFACE IDirectDraw
DECLARE_INTERFACE_( IDirectDraw, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDraw methods ***/
    STDMETHOD(Compact)(THIS) PURE;
    STDMETHOD(CreateClipper)(THIS_ DWORD, LPDIRECTDRAWCLIPPER FAR*, IUnknown FAR * ) PURE;
    STDMETHOD(CreatePalette)(THIS_ DWORD, LPPALETTEENTRY, LPDIRECTDRAWPALETTE FAR*, IUnknown FAR * ) PURE;
    STDMETHOD(CreateSurface)(THIS_  LPDDSURFACEDESC, LPDIRECTDRAWSURFACE FAR *, IUnknown FAR *) PURE;
    STDMETHOD(DuplicateSurface)( THIS_ LPDIRECTDRAWSURFACE, LPDIRECTDRAWSURFACE FAR * ) PURE;
    STDMETHOD(EnumDisplayModes)( THIS_ DWORD, LPDDSURFACEDESC, LPVOID, LPDDENUMMODESCALLBACK ) PURE;
    STDMETHOD(EnumSurfaces)(THIS_ DWORD, LPDDSURFACEDESC, LPVOID,LPDDENUMSURFACESCALLBACK ) PURE;
    STDMETHOD(FlipToGDISurface)(THIS) PURE;
    STDMETHOD(GetCaps)( THIS_ LPDDCAPS, LPDDCAPS) PURE;
    STDMETHOD(GetDisplayMode)( THIS_ LPDDSURFACEDESC) PURE;
    STDMETHOD(GetFourCCCodes)(THIS_  LPDWORD, LPDWORD ) PURE;
    STDMETHOD(GetGDISurface)(THIS_ LPDIRECTDRAWSURFACE FAR *) PURE;
    STDMETHOD(GetMonitorFrequency)(THIS_ LPDWORD) PURE;
    STDMETHOD(GetScanLine)(THIS_ LPDWORD) PURE;
    STDMETHOD(GetVerticalBlankStatus)(THIS_ LPBOOL ) PURE;
    STDMETHOD(Initialize)(THIS_ GUID FAR *) PURE;
    STDMETHOD(RestoreDisplayMode)(THIS) PURE;
    STDMETHOD(SetCooperativeLevel)(THIS_ HWND, DWORD) PURE;
    STDMETHOD(SetDisplayMode)(THIS_ DWORD, DWORD,DWORD) PURE;
    STDMETHOD(WaitForVerticalBlank)(THIS_ DWORD, HANDLE ) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectDraw_QueryInterface(p, a, b)         (p)->lpVtbl->QueryInterface(p, a, b)
#define IDirectDraw_AddRef(p)                       (p)->lpVtbl->AddRef(p)
#define IDirectDraw_Release(p)                      (p)->lpVtbl->Release(p)
#define IDirectDraw_Compact(p)                      (p)->lpVtbl->Compact(p)
#define IDirectDraw_CreateClipper(p, a, b, c)       (p)->lpVtbl->CreateClipper(p, a, b, c)
#define IDirectDraw_CreatePalette(p, a, b, c, d)    (p)->lpVtbl->CreatePalette(p, a, b, c, d)
#define IDirectDraw_CreateSurface(p, a, b, c)       (p)->lpVtbl->CreateSurface(p, a, b, c)
#define IDirectDraw_DuplicateSurface(p, a, b)       (p)->lpVtbl->DuplicateSurface(p, a, b)
#define IDirectDraw_EnumDisplayModes(p, a, b, c, d) (p)->lpVtbl->EnumDisplayModes(p, a, b, c, d)
#define IDirectDraw_EnumSurfaces(p, a, b, c, d)     (p)->lpVtbl->EnumSurfaces(p, a, b, c, d)
#define IDirectDraw_FlipToGDISurface(p)             (p)->lpVtbl->FlipToGDISurface(p)
#define IDirectDraw_GetCaps(p, a, b)                (p)->lpVtbl->GetCaps(p, a, b)
#define IDirectDraw_GetDisplayMode(p, a)            (p)->lpVtbl->GetDisplayMode(p, a)
#define IDirectDraw_GetFourCCCodes(p, a, b)         (p)->lpVtbl->GetFourCCCodes(p, a, b)
#define IDirectDraw_GetGDISurface(p, a)             (p)->lpVtbl->GetGDISurface(p, a)
#define IDirectDraw_GetMonitorFrequency(p, a)       (p)->lpVtbl->GetMonitorFrequency(p, a)
#define IDirectDraw_GetScanLine(p, a)               (p)->lpVtbl->GetScanLine(p, a)
#define IDirectDraw_GetVerticalBlankStatus(p, a)    (p)->lpVtbl->GetVerticalBlankStatus(p, a)
#define IDirectDraw_Initialize(p, a)                (p)->lpVtbl->Initialize(p, a)
#define IDirectDraw_RestoreDisplayMode(p)           (p)->lpVtbl->RestoreDisplayMode(p)
#define IDirectDraw_SetCooperativeLevel(p, a, b)    (p)->lpVtbl->SetCooperativeLevel(p, a, b)
#define IDirectDraw_SetDisplayMode(p, a, b, c)      (p)->lpVtbl->SetDisplayMode(p, a, b, c)
#define IDirectDraw_WaitForVerticalBlank(p, a, b)   (p)->lpVtbl->WaitForVerticalBlank(p, a, b)
#else
#define IDirectDraw_QueryInterface(p, a, b)         (p)->QueryInterface(a, b)
#define IDirectDraw_AddRef(p)                       (p)->AddRef()
#define IDirectDraw_Release(p)                      (p)->Release()
#define IDirectDraw_Compact(p)                      (p)->Compact()
#define IDirectDraw_CreateClipper(p, a, b, c)       (p)->CreateClipper(a, b, c)
#define IDirectDraw_CreatePalette(p, a, b, c, d)    (p)->CreatePalette(a, b, c, d)
#define IDirectDraw_CreateSurface(p, a, b, c)       (p)->CreateSurface(a, b, c)
#define IDirectDraw_DuplicateSurface(p, a, b)       (p)->DuplicateSurface(a, b)
#define IDirectDraw_EnumDisplayModes(p, a, b, c, d) (p)->EnumDisplayModes(a, b, c, d)
#define IDirectDraw_EnumSurfaces(p, a, b, c, d)     (p)->EnumSurfaces(a, b, c, d)
#define IDirectDraw_FlipToGDISurface(p)             (p)->FlipToGDISurface()
#define IDirectDraw_GetCaps(p, a, b)                (p)->GetCaps(a, b)
#define IDirectDraw_GetDisplayMode(p, a)            (p)->GetDisplayMode(a)
#define IDirectDraw_GetFourCCCodes(p, a, b)         (p)->GetFourCCCodes(a, b)
#define IDirectDraw_GetGDISurface(p, a)             (p)->GetGDISurface(a)
#define IDirectDraw_GetMonitorFrequency(p, a)       (p)->GetMonitorFrequency(a)
#define IDirectDraw_GetScanLine(p, a)               (p)->GetScanLine(a)
#define IDirectDraw_GetVerticalBlankStatus(p, a)    (p)->GetVerticalBlankStatus(a)
#define IDirectDraw_Initialize(p, a)                (p)->Initialize(a)
#define IDirectDraw_RestoreDisplayMode(p)           (p)->RestoreDisplayMode()
#define IDirectDraw_SetCooperativeLevel(p, a, b)    (p)->SetCooperativeLevel(a, b)
#define IDirectDraw_SetDisplayMode(p, a, b, c)      (p)->SetDisplayMode(a, b, c)
#define IDirectDraw_WaitForVerticalBlank(p, a, b)   (p)->WaitForVerticalBlank(a, b)
#endif

#endif

#if defined( _WIN32 ) && !defined( _NO_COM )
#undef INTERFACE
#define INTERFACE IDirectDraw2
DECLARE_INTERFACE_( IDirectDraw2, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDraw methods ***/
    STDMETHOD(Compact)(THIS) PURE;
    STDMETHOD(CreateClipper)(THIS_ DWORD, LPDIRECTDRAWCLIPPER FAR*, IUnknown FAR * ) PURE;
    STDMETHOD(CreatePalette)(THIS_ DWORD, LPPALETTEENTRY, LPDIRECTDRAWPALETTE FAR*, IUnknown FAR * ) PURE;
    STDMETHOD(CreateSurface)(THIS_  LPDDSURFACEDESC, LPDIRECTDRAWSURFACE FAR *, IUnknown FAR *) PURE;
    STDMETHOD(DuplicateSurface)( THIS_ LPDIRECTDRAWSURFACE, LPDIRECTDRAWSURFACE FAR * ) PURE;
    STDMETHOD(EnumDisplayModes)( THIS_ DWORD, LPDDSURFACEDESC, LPVOID, LPDDENUMMODESCALLBACK ) PURE;
    STDMETHOD(EnumSurfaces)(THIS_ DWORD, LPDDSURFACEDESC, LPVOID,LPDDENUMSURFACESCALLBACK ) PURE;
    STDMETHOD(FlipToGDISurface)(THIS) PURE;
    STDMETHOD(GetCaps)( THIS_ LPDDCAPS, LPDDCAPS) PURE;
    STDMETHOD(GetDisplayMode)( THIS_ LPDDSURFACEDESC) PURE;
    STDMETHOD(GetFourCCCodes)(THIS_  LPDWORD, LPDWORD ) PURE;
    STDMETHOD(GetGDISurface)(THIS_ LPDIRECTDRAWSURFACE FAR *) PURE;
    STDMETHOD(GetMonitorFrequency)(THIS_ LPDWORD) PURE;
    STDMETHOD(GetScanLine)(THIS_ LPDWORD) PURE;
    STDMETHOD(GetVerticalBlankStatus)(THIS_ LPBOOL ) PURE;
    STDMETHOD(Initialize)(THIS_ GUID FAR *) PURE;
    STDMETHOD(RestoreDisplayMode)(THIS) PURE;
    STDMETHOD(SetCooperativeLevel)(THIS_ HWND, DWORD) PURE;
    STDMETHOD(SetDisplayMode)(THIS_ DWORD, DWORD,DWORD, DWORD, DWORD) PURE;
    STDMETHOD(WaitForVerticalBlank)(THIS_ DWORD, HANDLE ) PURE;
    /*** Added in the v2 interface ***/
    STDMETHOD(GetAvailableVidMem)(THIS_ LPDDSCAPS, LPDWORD, LPDWORD) PURE;
};
#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectDraw2_QueryInterface(p, a, b)         (p)->lpVtbl->QueryInterface(p, a, b)
#define IDirectDraw2_AddRef(p)                       (p)->lpVtbl->AddRef(p)
#define IDirectDraw2_Release(p)                      (p)->lpVtbl->Release(p)
#define IDirectDraw2_Compact(p)                      (p)->lpVtbl->Compact(p)
#define IDirectDraw2_CreateClipper(p, a, b, c)       (p)->lpVtbl->CreateClipper(p, a, b, c)
#define IDirectDraw2_CreatePalette(p, a, b, c, d)    (p)->lpVtbl->CreatePalette(p, a, b, c, d)
#define IDirectDraw2_CreateSurface(p, a, b, c)       (p)->lpVtbl->CreateSurface(p, a, b, c)
#define IDirectDraw2_DuplicateSurface(p, a, b)       (p)->lpVtbl->DuplicateSurface(p, a, b)
#define IDirectDraw2_EnumDisplayModes(p, a, b, c, d) (p)->lpVtbl->EnumDisplayModes(p, a, b, c, d)
#define IDirectDraw2_EnumSurfaces(p, a, b, c, d)     (p)->lpVtbl->EnumSurfaces(p, a, b, c, d)
#define IDirectDraw2_FlipToGDISurface(p)             (p)->lpVtbl->FlipToGDISurface(p)
#define IDirectDraw2_GetCaps(p, a, b)                (p)->lpVtbl->GetCaps(p, a, b)
#define IDirectDraw2_GetDisplayMode(p, a)            (p)->lpVtbl->GetDisplayMode(p, a)
#define IDirectDraw2_GetFourCCCodes(p, a, b)         (p)->lpVtbl->GetFourCCCodes(p, a, b)
#define IDirectDraw2_GetGDISurface(p, a)             (p)->lpVtbl->GetGDISurface(p, a)
#define IDirectDraw2_GetMonitorFrequency(p, a)       (p)->lpVtbl->GetMonitorFrequency(p, a)
#define IDirectDraw2_GetScanLine(p, a)               (p)->lpVtbl->GetScanLine(p, a)
#define IDirectDraw2_GetVerticalBlankStatus(p, a)    (p)->lpVtbl->GetVerticalBlankStatus(p, a)
#define IDirectDraw2_Initialize(p, a)                (p)->lpVtbl->Initialize(p, a)
#define IDirectDraw2_RestoreDisplayMode(p)           (p)->lpVtbl->RestoreDisplayMode(p)
#define IDirectDraw2_SetCooperativeLevel(p, a, b)    (p)->lpVtbl->SetCooperativeLevel(p, a, b)
#define IDirectDraw2_SetDisplayMode(p, a, b, c, d, e) (p)->lpVtbl->SetDisplayMode(p, a, b, c, d, e)
#define IDirectDraw2_WaitForVerticalBlank(p, a, b)   (p)->lpVtbl->WaitForVerticalBlank(p, a, b)
#define IDirectDraw2_GetAvailableVidMem(p, a, b, c)  (p)->lpVtbl->GetAvailableVidMem(p, a, b, c)
#else
#define IDirectDraw2_QueryInterface(p, a, b)         (p)->QueryInterface(a, b)
#define IDirectDraw2_AddRef(p)                       (p)->AddRef()
#define IDirectDraw2_Release(p)                      (p)->Release()
#define IDirectDraw2_Compact(p)                      (p)->Compact()
#define IDirectDraw2_CreateClipper(p, a, b, c)       (p)->CreateClipper(a, b, c)
#define IDirectDraw2_CreatePalette(p, a, b, c, d)    (p)->CreatePalette(a, b, c, d)
#define IDirectDraw2_CreateSurface(p, a, b, c)       (p)->CreateSurface(a, b, c)
#define IDirectDraw2_DuplicateSurface(p, a, b)       (p)->DuplicateSurface(a, b)
#define IDirectDraw2_EnumDisplayModes(p, a, b, c, d) (p)->EnumDisplayModes(a, b, c, d)
#define IDirectDraw2_EnumSurfaces(p, a, b, c, d)     (p)->EnumSurfaces(a, b, c, d)
#define IDirectDraw2_FlipToGDISurface(p)             (p)->FlipToGDISurface()
#define IDirectDraw2_GetCaps(p, a, b)                (p)->GetCaps(a, b)
#define IDirectDraw2_GetDisplayMode(p, a)            (p)->GetDisplayMode(a)
#define IDirectDraw2_GetFourCCCodes(p, a, b)         (p)->GetFourCCCodes(a, b)
#define IDirectDraw2_GetGDISurface(p, a)             (p)->GetGDISurface(a)
#define IDirectDraw2_GetMonitorFrequency(p, a)       (p)->GetMonitorFrequency(a)
#define IDirectDraw2_GetScanLine(p, a)               (p)->GetScanLine(a)
#define IDirectDraw2_GetVerticalBlankStatus(p, a)    (p)->GetVerticalBlankStatus(a)
#define IDirectDraw2_Initialize(p, a)                (p)->Initialize(a)
#define IDirectDraw2_RestoreDisplayMode(p)           (p)->RestoreDisplayMode()
#define IDirectDraw2_SetCooperativeLevel(p, a, b)    (p)->SetCooperativeLevel(a, b)
#define IDirectDraw2_SetDisplayMode(p, a, b, c, d, e) (p)->SetDisplayMode(a, b, c, d, e)
#define IDirectDraw2_WaitForVerticalBlank(p, a, b)   (p)->WaitForVerticalBlank(a, b)
#define IDirectDraw2_GetAvailableVidMem(p, a, b, c)  (p)->GetAvailableVidMem(a, b, c)
#endif

#endif

#if defined( _WIN32 ) && !defined( _NO_COM )
#undef INTERFACE
#define INTERFACE IDirectDraw4
DECLARE_INTERFACE_( IDirectDraw4, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDraw methods ***/
    STDMETHOD(Compact)(THIS) PURE;
    STDMETHOD(CreateClipper)(THIS_ DWORD, LPDIRECTDRAWCLIPPER FAR*, IUnknown FAR * ) PURE;
    STDMETHOD(CreatePalette)(THIS_ DWORD, LPPALETTEENTRY, LPDIRECTDRAWPALETTE FAR*, IUnknown FAR * ) PURE;
    STDMETHOD(CreateSurface)(THIS_  LPDDSURFACEDESC2, LPDIRECTDRAWSURFACE4 FAR *, IUnknown FAR *) PURE;
    STDMETHOD(DuplicateSurface)( THIS_ LPDIRECTDRAWSURFACE4, LPDIRECTDRAWSURFACE4 FAR * ) PURE;
    STDMETHOD(EnumDisplayModes)( THIS_ DWORD, LPDDSURFACEDESC2, LPVOID, LPDDENUMMODESCALLBACK2 ) PURE;
    STDMETHOD(EnumSurfaces)(THIS_ DWORD, LPDDSURFACEDESC2, LPVOID,LPDDENUMSURFACESCALLBACK2 ) PURE;
    STDMETHOD(FlipToGDISurface)(THIS) PURE;
    STDMETHOD(GetCaps)( THIS_ LPDDCAPS, LPDDCAPS) PURE;
    STDMETHOD(GetDisplayMode)( THIS_ LPDDSURFACEDESC2) PURE;
    STDMETHOD(GetFourCCCodes)(THIS_  LPDWORD, LPDWORD ) PURE;
    STDMETHOD(GetGDISurface)(THIS_ LPDIRECTDRAWSURFACE4 FAR *) PURE;
    STDMETHOD(GetMonitorFrequency)(THIS_ LPDWORD) PURE;
    STDMETHOD(GetScanLine)(THIS_ LPDWORD) PURE;
    STDMETHOD(GetVerticalBlankStatus)(THIS_ LPBOOL ) PURE;
    STDMETHOD(Initialize)(THIS_ GUID FAR *) PURE;
    STDMETHOD(RestoreDisplayMode)(THIS) PURE;
    STDMETHOD(SetCooperativeLevel)(THIS_ HWND, DWORD) PURE;
    STDMETHOD(SetDisplayMode)(THIS_ DWORD, DWORD,DWORD, DWORD, DWORD) PURE;
    STDMETHOD(WaitForVerticalBlank)(THIS_ DWORD, HANDLE ) PURE;
    /*** Added in the v2 interface ***/
    STDMETHOD(GetAvailableVidMem)(THIS_ LPDDSCAPS2, LPDWORD, LPDWORD) PURE;
    /*** Added in the V4 Interface ***/
    STDMETHOD(GetSurfaceFromDC) (THIS_ HDC, LPDIRECTDRAWSURFACE4 *) PURE;
    STDMETHOD(RestoreAllSurfaces)(THIS) PURE;
    STDMETHOD(TestCooperativeLevel)(THIS) PURE;
    STDMETHOD(GetDeviceIdentifier)(THIS_ LPDDDEVICEIDENTIFIER, DWORD ) PURE;
};
#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectDraw4_QueryInterface(p, a, b)         (p)->lpVtbl->QueryInterface(p, a, b)
#define IDirectDraw4_AddRef(p)                       (p)->lpVtbl->AddRef(p)
#define IDirectDraw4_Release(p)                      (p)->lpVtbl->Release(p)
#define IDirectDraw4_Compact(p)                      (p)->lpVtbl->Compact(p)
#define IDirectDraw4_CreateClipper(p, a, b, c)       (p)->lpVtbl->CreateClipper(p, a, b, c)
#define IDirectDraw4_CreatePalette(p, a, b, c, d)    (p)->lpVtbl->CreatePalette(p, a, b, c, d)
#define IDirectDraw4_CreateSurface(p, a, b, c)       (p)->lpVtbl->CreateSurface(p, a, b, c)
#define IDirectDraw4_DuplicateSurface(p, a, b)       (p)->lpVtbl->DuplicateSurface(p, a, b)
#define IDirectDraw4_EnumDisplayModes(p, a, b, c, d) (p)->lpVtbl->EnumDisplayModes(p, a, b, c, d)
#define IDirectDraw4_EnumSurfaces(p, a, b, c, d)     (p)->lpVtbl->EnumSurfaces(p, a, b, c, d)
#define IDirectDraw4_FlipToGDISurface(p)             (p)->lpVtbl->FlipToGDISurface(p)
#define IDirectDraw4_GetCaps(p, a, b)                (p)->lpVtbl->GetCaps(p, a, b)
#define IDirectDraw4_GetDisplayMode(p, a)            (p)->lpVtbl->GetDisplayMode(p, a)
#define IDirectDraw4_GetFourCCCodes(p, a, b)         (p)->lpVtbl->GetFourCCCodes(p, a, b)
#define IDirectDraw4_GetGDISurface(p, a)             (p)->lpVtbl->GetGDISurface(p, a)
#define IDirectDraw4_GetMonitorFrequency(p, a)       (p)->lpVtbl->GetMonitorFrequency(p, a)
#define IDirectDraw4_GetScanLine(p, a)               (p)->lpVtbl->GetScanLine(p, a)
#define IDirectDraw4_GetVerticalBlankStatus(p, a)    (p)->lpVtbl->GetVerticalBlankStatus(p, a)
#define IDirectDraw4_Initialize(p, a)                (p)->lpVtbl->Initialize(p, a)
#define IDirectDraw4_RestoreDisplayMode(p)           (p)->lpVtbl->RestoreDisplayMode(p)
#define IDirectDraw4_SetCooperativeLevel(p, a, b)    (p)->lpVtbl->SetCooperativeLevel(p, a, b)
#define IDirectDraw4_SetDisplayMode(p, a, b, c, d, e) (p)->lpVtbl->SetDisplayMode(p, a, b, c, d, e)
#define IDirectDraw4_WaitForVerticalBlank(p, a, b)   (p)->lpVtbl->WaitForVerticalBlank(p, a, b)
#define IDirectDraw4_GetAvailableVidMem(p, a, b, c)  (p)->lpVtbl->GetAvailableVidMem(p, a, b, c)
#define IDirectDraw4_GetSurfaceFromDC(p, a, b)       (p)->lpVtbl->GetSurfaceFromDC(p, a, b)
#define IDirectDraw4_RestoreAllSurfaces(p)           (p)->lpVtbl->RestoreAllSurfaces(p)
#define IDirectDraw4_TestCooperativeLevel(p)         (p)->lpVtbl->TestCooperativeLevel(p)
#define IDirectDraw4_GetDeviceIdentifier(p,a,b)      (p)->lpVtbl->GetDeviceIdentifier(p,a,b)
#else
#define IDirectDraw4_QueryInterface(p, a, b)         (p)->QueryInterface(a, b)
#define IDirectDraw4_AddRef(p)                       (p)->AddRef()
#define IDirectDraw4_Release(p)                      (p)->Release()
#define IDirectDraw4_Compact(p)                      (p)->Compact()
#define IDirectDraw4_CreateClipper(p, a, b, c)       (p)->CreateClipper(a, b, c)
#define IDirectDraw4_CreatePalette(p, a, b, c, d)    (p)->CreatePalette(a, b, c, d)
#define IDirectDraw4_CreateSurface(p, a, b, c)       (p)->CreateSurface(a, b, c)
#define IDirectDraw4_DuplicateSurface(p, a, b)       (p)->DuplicateSurface(a, b)
#define IDirectDraw4_EnumDisplayModes(p, a, b, c, d) (p)->EnumDisplayModes(a, b, c, d)
#define IDirectDraw4_EnumSurfaces(p, a, b, c, d)     (p)->EnumSurfaces(a, b, c, d)
#define IDirectDraw4_FlipToGDISurface(p)             (p)->FlipToGDISurface()
#define IDirectDraw4_GetCaps(p, a, b)                (p)->GetCaps(a, b)
#define IDirectDraw4_GetDisplayMode(p, a)            (p)->GetDisplayMode(a)
#define IDirectDraw4_GetFourCCCodes(p, a, b)         (p)->GetFourCCCodes(a, b)
#define IDirectDraw4_GetGDISurface(p, a)             (p)->GetGDISurface(a)
#define IDirectDraw4_GetMonitorFrequency(p, a)       (p)->GetMonitorFrequency(a)
#define IDirectDraw4_GetScanLine(p, a)               (p)->GetScanLine(a)
#define IDirectDraw4_GetVerticalBlankStatus(p, a)    (p)->GetVerticalBlankStatus(a)
#define IDirectDraw4_Initialize(p, a)                (p)->Initialize(a)
#define IDirectDraw4_RestoreDisplayMode(p)           (p)->RestoreDisplayMode()
#define IDirectDraw4_SetCooperativeLevel(p, a, b)    (p)->SetCooperativeLevel(a, b)
#define IDirectDraw4_SetDisplayMode(p, a, b, c, d, e) (p)->SetDisplayMode(a, b, c, d, e)
#define IDirectDraw4_WaitForVerticalBlank(p, a, b)   (p)->WaitForVerticalBlank(a, b)
#define IDirectDraw4_GetAvailableVidMem(p, a, b, c)  (p)->GetAvailableVidMem(a, b, c)
#define IDirectDraw4_GetSurfaceFromDC(p, a, b)       (p)->GetSurfaceFromDC(a, b)
#define IDirectDraw4_RestoreAllSurfaces(p)           (p)->RestoreAllSurfaces()
#define IDirectDraw4_TestCooperativeLevel(p)         (p)->TestCooperativeLevel()
#define IDirectDraw4_GetDeviceIdentifier(p,a,b)      (p)->GetDeviceIdentifier(a,b)
#endif

#endif

#if defined( _WIN32 ) && !defined( _NO_COM )
#undef INTERFACE
#define INTERFACE IDirectDraw7
DECLARE_INTERFACE_( IDirectDraw7, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDraw methods ***/
    STDMETHOD(Compact)(THIS) PURE;
    STDMETHOD(CreateClipper)(THIS_ DWORD, LPDIRECTDRAWCLIPPER FAR*, IUnknown FAR * ) PURE;
    STDMETHOD(CreatePalette)(THIS_ DWORD, LPPALETTEENTRY, LPDIRECTDRAWPALETTE FAR*, IUnknown FAR * ) PURE;
    STDMETHOD(CreateSurface)(THIS_  LPDDSURFACEDESC2, LPDIRECTDRAWSURFACE7 FAR *, IUnknown FAR *) PURE;
    STDMETHOD(DuplicateSurface)( THIS_ LPDIRECTDRAWSURFACE7, LPDIRECTDRAWSURFACE7 FAR * ) PURE;
    STDMETHOD(EnumDisplayModes)( THIS_ DWORD, LPDDSURFACEDESC2, LPVOID, LPDDENUMMODESCALLBACK2 ) PURE;
    STDMETHOD(EnumSurfaces)(THIS_ DWORD, LPDDSURFACEDESC2, LPVOID,LPDDENUMSURFACESCALLBACK7 ) PURE;
    STDMETHOD(FlipToGDISurface)(THIS) PURE;
    STDMETHOD(GetCaps)( THIS_ LPDDCAPS, LPDDCAPS) PURE;
    STDMETHOD(GetDisplayMode)( THIS_ LPDDSURFACEDESC2) PURE;
    STDMETHOD(GetFourCCCodes)(THIS_  LPDWORD, LPDWORD ) PURE;
    STDMETHOD(GetGDISurface)(THIS_ LPDIRECTDRAWSURFACE7 FAR *) PURE;
    STDMETHOD(GetMonitorFrequency)(THIS_ LPDWORD) PURE;
    STDMETHOD(GetScanLine)(THIS_ LPDWORD) PURE;
    STDMETHOD(GetVerticalBlankStatus)(THIS_ LPBOOL ) PURE;
    STDMETHOD(Initialize)(THIS_ GUID FAR *) PURE;
    STDMETHOD(RestoreDisplayMode)(THIS) PURE;
    STDMETHOD(SetCooperativeLevel)(THIS_ HWND, DWORD) PURE;
    STDMETHOD(SetDisplayMode)(THIS_ DWORD, DWORD,DWORD, DWORD, DWORD) PURE;
    STDMETHOD(WaitForVerticalBlank)(THIS_ DWORD, HANDLE ) PURE;
    /*** Added in the v2 interface ***/
    STDMETHOD(GetAvailableVidMem)(THIS_ LPDDSCAPS2, LPDWORD, LPDWORD) PURE;
    /*** Added in the V4 Interface ***/
    STDMETHOD(GetSurfaceFromDC) (THIS_ HDC, LPDIRECTDRAWSURFACE7 *) PURE;
    STDMETHOD(RestoreAllSurfaces)(THIS) PURE;
    STDMETHOD(TestCooperativeLevel)(THIS) PURE;
    STDMETHOD(GetDeviceIdentifier)(THIS_ LPDDDEVICEIDENTIFIER2, DWORD ) PURE;
    STDMETHOD(StartModeTest)(THIS_ LPSIZE, DWORD, DWORD ) PURE;
    STDMETHOD(EvaluateMode)(THIS_ DWORD, DWORD * ) PURE;
};
#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectDraw7_QueryInterface(p, a, b)         (p)->lpVtbl->QueryInterface(p, a, b)
#define IDirectDraw7_AddRef(p)                       (p)->lpVtbl->AddRef(p)
#define IDirectDraw7_Release(p)                      (p)->lpVtbl->Release(p)
#define IDirectDraw7_Compact(p)                      (p)->lpVtbl->Compact(p)
#define IDirectDraw7_CreateClipper(p, a, b, c)       (p)->lpVtbl->CreateClipper(p, a, b, c)
#define IDirectDraw7_CreatePalette(p, a, b, c, d)    (p)->lpVtbl->CreatePalette(p, a, b, c, d)
#define IDirectDraw7_CreateSurface(p, a, b, c)       (p)->lpVtbl->CreateSurface(p, a, b, c)
#define IDirectDraw7_DuplicateSurface(p, a, b)       (p)->lpVtbl->DuplicateSurface(p, a, b)
#define IDirectDraw7_EnumDisplayModes(p, a, b, c, d) (p)->lpVtbl->EnumDisplayModes(p, a, b, c, d)
#define IDirectDraw7_EnumSurfaces(p, a, b, c, d)     (p)->lpVtbl->EnumSurfaces(p, a, b, c, d)
#define IDirectDraw7_FlipToGDISurface(p)             (p)->lpVtbl->FlipToGDISurface(p)
#define IDirectDraw7_GetCaps(p, a, b)                (p)->lpVtbl->GetCaps(p, a, b)
#define IDirectDraw7_GetDisplayMode(p, a)            (p)->lpVtbl->GetDisplayMode(p, a)
#define IDirectDraw7_GetFourCCCodes(p, a, b)         (p)->lpVtbl->GetFourCCCodes(p, a, b)
#define IDirectDraw7_GetGDISurface(p, a)             (p)->lpVtbl->GetGDISurface(p, a)
#define IDirectDraw7_GetMonitorFrequency(p, a)       (p)->lpVtbl->GetMonitorFrequency(p, a)
#define IDirectDraw7_GetScanLine(p, a)               (p)->lpVtbl->GetScanLine(p, a)
#define IDirectDraw7_GetVerticalBlankStatus(p, a)    (p)->lpVtbl->GetVerticalBlankStatus(p, a)
#define IDirectDraw7_Initialize(p, a)                (p)->lpVtbl->Initialize(p, a)
#define IDirectDraw7_RestoreDisplayMode(p)           (p)->lpVtbl->RestoreDisplayMode(p)
#define IDirectDraw7_SetCooperativeLevel(p, a, b)    (p)->lpVtbl->SetCooperativeLevel(p, a, b)
#define IDirectDraw7_SetDisplayMode(p, a, b, c, d, e) (p)->lpVtbl->SetDisplayMode(p, a, b, c, d, e)
#define IDirectDraw7_WaitForVerticalBlank(p, a, b)   (p)->lpVtbl->WaitForVerticalBlank(p, a, b)
#define IDirectDraw7_GetAvailableVidMem(p, a, b, c)  (p)->lpVtbl->GetAvailableVidMem(p, a, b, c)
#define IDirectDraw7_GetSurfaceFromDC(p, a, b)       (p)->lpVtbl->GetSurfaceFromDC(p, a, b)
#define IDirectDraw7_RestoreAllSurfaces(p)           (p)->lpVtbl->RestoreAllSurfaces(p)
#define IDirectDraw7_TestCooperativeLevel(p)         (p)->lpVtbl->TestCooperativeLevel(p)
#define IDirectDraw7_GetDeviceIdentifier(p,a,b)      (p)->lpVtbl->GetDeviceIdentifier(p,a,b)
#define IDirectDraw7_StartModeTest(p,a,b,c)        (p)->lpVtbl->StartModeTest(p,a,b,c)
#define IDirectDraw7_EvaluateMode(p,a,b)           (p)->lpVtbl->EvaluateMode(p,a,b)
#else
#define IDirectDraw7_QueryInterface(p, a, b)         (p)->QueryInterface(a, b)
#define IDirectDraw7_AddRef(p)                       (p)->AddRef()
#define IDirectDraw7_Release(p)                      (p)->Release()
#define IDirectDraw7_Compact(p)                      (p)->Compact()
#define IDirectDraw7_CreateClipper(p, a, b, c)       (p)->CreateClipper(a, b, c)
#define IDirectDraw7_CreatePalette(p, a, b, c, d)    (p)->CreatePalette(a, b, c, d)
#define IDirectDraw7_CreateSurface(p, a, b, c)       (p)->CreateSurface(a, b, c)
#define IDirectDraw7_DuplicateSurface(p, a, b)       (p)->DuplicateSurface(a, b)
#define IDirectDraw7_EnumDisplayModes(p, a, b, c, d) (p)->EnumDisplayModes(a, b, c, d)
#define IDirectDraw7_EnumSurfaces(p, a, b, c, d)     (p)->EnumSurfaces(a, b, c, d)
#define IDirectDraw7_FlipToGDISurface(p)             (p)->FlipToGDISurface()
#define IDirectDraw7_GetCaps(p, a, b)                (p)->GetCaps(a, b)
#define IDirectDraw7_GetDisplayMode(p, a)            (p)->GetDisplayMode(a)
#define IDirectDraw7_GetFourCCCodes(p, a, b)         (p)->GetFourCCCodes(a, b)
#define IDirectDraw7_GetGDISurface(p, a)             (p)->GetGDISurface(a)
#define IDirectDraw7_GetMonitorFrequency(p, a)       (p)->GetMonitorFrequency(a)
#define IDirectDraw7_GetScanLine(p, a)               (p)->GetScanLine(a)
#define IDirectDraw7_GetVerticalBlankStatus(p, a)    (p)->GetVerticalBlankStatus(a)
#define IDirectDraw7_Initialize(p, a)                (p)->Initialize(a)
#define IDirectDraw7_RestoreDisplayMode(p)           (p)->RestoreDisplayMode()
#define IDirectDraw7_SetCooperativeLevel(p, a, b)    (p)->SetCooperativeLevel(a, b)
#define IDirectDraw7_SetDisplayMode(p, a, b, c, d, e) (p)->SetDisplayMode(a, b, c, d, e)
#define IDirectDraw7_WaitForVerticalBlank(p, a, b)   (p)->WaitForVerticalBlank(a, b)
#define IDirectDraw7_GetAvailableVidMem(p, a, b, c)  (p)->GetAvailableVidMem(a, b, c)
#define IDirectDraw7_GetSurfaceFromDC(p, a, b)       (p)->GetSurfaceFromDC(a, b)
#define IDirectDraw7_RestoreAllSurfaces(p)           (p)->RestoreAllSurfaces()
#define IDirectDraw7_TestCooperativeLevel(p)         (p)->TestCooperativeLevel()
#define IDirectDraw7_GetDeviceIdentifier(p,a,b)      (p)->GetDeviceIdentifier(a,b)
#define IDirectDraw7_StartModeTest(p,a,b,c)        (p)->lpVtbl->StartModeTest(a,b,c)
#define IDirectDraw7_EvaluateMode(p,a,b)           (p)->lpVtbl->EvaluateMode(a,b)
#endif

#endif


/*
 * IDirectDrawPalette
 */
#if defined( _WIN32 ) && !defined( _NO_COM )
#undef INTERFACE
#define INTERFACE IDirectDrawPalette
DECLARE_INTERFACE_( IDirectDrawPalette, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDrawPalette methods ***/
    STDMETHOD(GetCaps)(THIS_ LPDWORD) PURE;
    STDMETHOD(GetEntries)(THIS_ DWORD,DWORD,DWORD,LPPALETTEENTRY) PURE;
    STDMETHOD(Initialize)(THIS_ LPDIRECTDRAW, DWORD, LPPALETTEENTRY) PURE;
    STDMETHOD(SetEntries)(THIS_ DWORD,DWORD,DWORD,LPPALETTEENTRY) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectDrawPalette_QueryInterface(p, a, b)      (p)->lpVtbl->QueryInterface(p, a, b)
#define IDirectDrawPalette_AddRef(p)                    (p)->lpVtbl->AddRef(p)
#define IDirectDrawPalette_Release(p)                   (p)->lpVtbl->Release(p)
#define IDirectDrawPalette_GetCaps(p, a)                (p)->lpVtbl->GetCaps(p, a)
#define IDirectDrawPalette_GetEntries(p, a, b, c, d)    (p)->lpVtbl->GetEntries(p, a, b, c, d)
#define IDirectDrawPalette_Initialize(p, a, b, c)       (p)->lpVtbl->Initialize(p, a, b, c)
#define IDirectDrawPalette_SetEntries(p, a, b, c, d)    (p)->lpVtbl->SetEntries(p, a, b, c, d)
#else
#define IDirectDrawPalette_QueryInterface(p, a, b)      (p)->QueryInterface(a, b)
#define IDirectDrawPalette_AddRef(p)                    (p)->AddRef()
#define IDirectDrawPalette_Release(p)                   (p)->Release()
#define IDirectDrawPalette_GetCaps(p, a)                (p)->GetCaps(a)
#define IDirectDrawPalette_GetEntries(p, a, b, c, d)    (p)->GetEntries(a, b, c, d)
#define IDirectDrawPalette_Initialize(p, a, b, c)       (p)->Initialize(a, b, c)
#define IDirectDrawPalette_SetEntries(p, a, b, c, d)    (p)->SetEntries(a, b, c, d)
#endif

#endif


/*
 * IDirectDrawClipper
 */
#if defined( _WIN32 ) && !defined( _NO_COM )
#undef INTERFACE
#define INTERFACE IDirectDrawClipper
DECLARE_INTERFACE_( IDirectDrawClipper, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDrawClipper methods ***/
    STDMETHOD(GetClipList)(THIS_ LPRECT, LPRGNDATA, LPDWORD) PURE;
    STDMETHOD(GetHWnd)(THIS_ HWND FAR *) PURE;
    STDMETHOD(Initialize)(THIS_ LPDIRECTDRAW, DWORD) PURE;
    STDMETHOD(IsClipListChanged)(THIS_ BOOL FAR *) PURE;
    STDMETHOD(SetClipList)(THIS_ LPRGNDATA,DWORD) PURE;
    STDMETHOD(SetHWnd)(THIS_ DWORD, HWND ) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectDrawClipper_QueryInterface(p, a, b)  (p)->lpVtbl->QueryInterface(p, a, b)
#define IDirectDrawClipper_AddRef(p)                (p)->lpVtbl->AddRef(p)
#define IDirectDrawClipper_Release(p)               (p)->lpVtbl->Release(p)
#define IDirectDrawClipper_GetClipList(p, a, b, c)  (p)->lpVtbl->GetClipList(p, a, b, c)
#define IDirectDrawClipper_GetHWnd(p, a)            (p)->lpVtbl->GetHWnd(p, a)
#define IDirectDrawClipper_Initialize(p, a, b)      (p)->lpVtbl->Initialize(p, a, b)
#define IDirectDrawClipper_IsClipListChanged(p, a)  (p)->lpVtbl->IsClipListChanged(p, a)
#define IDirectDrawClipper_SetClipList(p, a, b)     (p)->lpVtbl->SetClipList(p, a, b)
#define IDirectDrawClipper_SetHWnd(p, a, b)         (p)->lpVtbl->SetHWnd(p, a, b)
#else
#define IDirectDrawClipper_QueryInterface(p, a, b)  (p)->QueryInterface(a, b)
#define IDirectDrawClipper_AddRef(p)                (p)->AddRef()
#define IDirectDrawClipper_Release(p)               (p)->Release()
#define IDirectDrawClipper_GetClipList(p, a, b, c)  (p)->GetClipList(a, b, c)
#define IDirectDrawClipper_GetHWnd(p, a)            (p)->GetHWnd(a)
#define IDirectDrawClipper_Initialize(p, a, b)      (p)->Initialize(a, b)
#define IDirectDrawClipper_IsClipListChanged(p, a)  (p)->IsClipListChanged(a)
#define IDirectDrawClipper_SetClipList(p, a, b)     (p)->SetClipList(a, b)
#define IDirectDrawClipper_SetHWnd(p, a, b)         (p)->SetHWnd(a, b)
#endif

#endif

/*
 * IDirectDrawSurface and related interfaces
 */
#if defined( _WIN32 ) && !defined( _NO_COM )
#undef INTERFACE
#define INTERFACE IDirectDrawSurface
DECLARE_INTERFACE_( IDirectDrawSurface, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDrawSurface methods ***/
    STDMETHOD(AddAttachedSurface)(THIS_ LPDIRECTDRAWSURFACE) PURE;
    STDMETHOD(AddOverlayDirtyRect)(THIS_ LPRECT) PURE;
    STDMETHOD(Blt)(THIS_ LPRECT,LPDIRECTDRAWSURFACE, LPRECT,DWORD, LPDDBLTFX) PURE;
    STDMETHOD(BltBatch)(THIS_ LPDDBLTBATCH, DWORD, DWORD ) PURE;
    STDMETHOD(BltFast)(THIS_ DWORD,DWORD,LPDIRECTDRAWSURFACE, LPRECT,DWORD) PURE;
    STDMETHOD(DeleteAttachedSurface)(THIS_ DWORD,LPDIRECTDRAWSURFACE) PURE;
    STDMETHOD(EnumAttachedSurfaces)(THIS_ LPVOID,LPDDENUMSURFACESCALLBACK) PURE;
    STDMETHOD(EnumOverlayZOrders)(THIS_ DWORD,LPVOID,LPDDENUMSURFACESCALLBACK) PURE;
    STDMETHOD(Flip)(THIS_ LPDIRECTDRAWSURFACE, DWORD) PURE;
    STDMETHOD(GetAttachedSurface)(THIS_ LPDDSCAPS, LPDIRECTDRAWSURFACE FAR *) PURE;
    STDMETHOD(GetBltStatus)(THIS_ DWORD) PURE;
    STDMETHOD(GetCaps)(THIS_ LPDDSCAPS) PURE;
    STDMETHOD(GetClipper)(THIS_ LPDIRECTDRAWCLIPPER FAR*) PURE;
    STDMETHOD(GetColorKey)(THIS_ DWORD, LPDDCOLORKEY) PURE;
    STDMETHOD(GetDC)(THIS_ HDC FAR *) PURE;
    STDMETHOD(GetFlipStatus)(THIS_ DWORD) PURE;
    STDMETHOD(GetOverlayPosition)(THIS_ LPLONG, LPLONG ) PURE;
    STDMETHOD(GetPalette)(THIS_ LPDIRECTDRAWPALETTE FAR*) PURE;
    STDMETHOD(GetPixelFormat)(THIS_ LPDDPIXELFORMAT) PURE;
    STDMETHOD(GetSurfaceDesc)(THIS_ LPDDSURFACEDESC) PURE;
    STDMETHOD(Initialize)(THIS_ LPDIRECTDRAW, LPDDSURFACEDESC) PURE;
    STDMETHOD(IsLost)(THIS) PURE;
    STDMETHOD(Lock)(THIS_ LPRECT,LPDDSURFACEDESC,DWORD,HANDLE) PURE;
    STDMETHOD(ReleaseDC)(THIS_ HDC) PURE;
    STDMETHOD(Restore)(THIS) PURE;
    STDMETHOD(SetClipper)(THIS_ LPDIRECTDRAWCLIPPER) PURE;
    STDMETHOD(SetColorKey)(THIS_ DWORD, LPDDCOLORKEY) PURE;
    STDMETHOD(SetOverlayPosition)(THIS_ LONG, LONG ) PURE;
    STDMETHOD(SetPalette)(THIS_ LPDIRECTDRAWPALETTE) PURE;
    STDMETHOD(Unlock)(THIS_ LPVOID) PURE;
    STDMETHOD(UpdateOverlay)(THIS_ LPRECT, LPDIRECTDRAWSURFACE,LPRECT,DWORD, LPDDOVERLAYFX) PURE;
    STDMETHOD(UpdateOverlayDisplay)(THIS_ DWORD) PURE;
    STDMETHOD(UpdateOverlayZOrder)(THIS_ DWORD, LPDIRECTDRAWSURFACE) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectDrawSurface_QueryInterface(p,a,b)        (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectDrawSurface_AddRef(p)                    (p)->lpVtbl->AddRef(p)
#define IDirectDrawSurface_Release(p)                   (p)->lpVtbl->Release(p)
#define IDirectDrawSurface_AddAttachedSurface(p,a)      (p)->lpVtbl->AddAttachedSurface(p,a)
#define IDirectDrawSurface_AddOverlayDirtyRect(p,a)     (p)->lpVtbl->AddOverlayDirtyRect(p,a)
#define IDirectDrawSurface_Blt(p,a,b,c,d,e)             (p)->lpVtbl->Blt(p,a,b,c,d,e)
#define IDirectDrawSurface_BltBatch(p,a,b,c)            (p)->lpVtbl->BltBatch(p,a,b,c)
#define IDirectDrawSurface_BltFast(p,a,b,c,d,e)         (p)->lpVtbl->BltFast(p,a,b,c,d,e)
#define IDirectDrawSurface_DeleteAttachedSurface(p,a,b) (p)->lpVtbl->DeleteAttachedSurface(p,a,b)
#define IDirectDrawSurface_EnumAttachedSurfaces(p,a,b)  (p)->lpVtbl->EnumAttachedSurfaces(p,a,b)
#define IDirectDrawSurface_EnumOverlayZOrders(p,a,b,c)  (p)->lpVtbl->EnumOverlayZOrders(p,a,b,c)
#define IDirectDrawSurface_Flip(p,a,b)                  (p)->lpVtbl->Flip(p,a,b)
#define IDirectDrawSurface_GetAttachedSurface(p,a,b)    (p)->lpVtbl->GetAttachedSurface(p,a,b)
#define IDirectDrawSurface_GetBltStatus(p,a)            (p)->lpVtbl->GetBltStatus(p,a)
#define IDirectDrawSurface_GetCaps(p,b)                 (p)->lpVtbl->GetCaps(p,b)
#define IDirectDrawSurface_GetClipper(p,a)              (p)->lpVtbl->GetClipper(p,a)
#define IDirectDrawSurface_GetColorKey(p,a,b)           (p)->lpVtbl->GetColorKey(p,a,b)
#define IDirectDrawSurface_GetDC(p,a)                   (p)->lpVtbl->GetDC(p,a)
#define IDirectDrawSurface_GetFlipStatus(p,a)           (p)->lpVtbl->GetFlipStatus(p,a)
#define IDirectDrawSurface_GetOverlayPosition(p,a,b)    (p)->lpVtbl->GetOverlayPosition(p,a,b)
#define IDirectDrawSurface_GetPalette(p,a)              (p)->lpVtbl->GetPalette(p,a)
#define IDirectDrawSurface_GetPixelFormat(p,a)          (p)->lpVtbl->GetPixelFormat(p,a)
#define IDirectDrawSurface_GetSurfaceDesc(p,a)          (p)->lpVtbl->GetSurfaceDesc(p,a)
#define IDirectDrawSurface_Initialize(p,a,b)            (p)->lpVtbl->Initialize(p,a,b)
#define IDirectDrawSurface_IsLost(p)                    (p)->lpVtbl->IsLost(p)
#define IDirectDrawSurface_Lock(p,a,b,c,d)              (p)->lpVtbl->Lock(p,a,b,c,d)
#define IDirectDrawSurface_ReleaseDC(p,a)               (p)->lpVtbl->ReleaseDC(p,a)
#define IDirectDrawSurface_Restore(p)                   (p)->lpVtbl->Restore(p)
#define IDirectDrawSurface_SetClipper(p,a)              (p)->lpVtbl->SetClipper(p,a)
#define IDirectDrawSurface_SetColorKey(p,a,b)           (p)->lpVtbl->SetColorKey(p,a,b)
#define IDirectDrawSurface_SetOverlayPosition(p,a,b)    (p)->lpVtbl->SetOverlayPosition(p,a,b)
#define IDirectDrawSurface_SetPalette(p,a)              (p)->lpVtbl->SetPalette(p,a)
#define IDirectDrawSurface_Unlock(p,b)                  (p)->lpVtbl->Unlock(p,b)
#define IDirectDrawSurface_UpdateOverlay(p,a,b,c,d,e)   (p)->lpVtbl->UpdateOverlay(p,a,b,c,d,e)
#define IDirectDrawSurface_UpdateOverlayDisplay(p,a)    (p)->lpVtbl->UpdateOverlayDisplay(p,a)
#define IDirectDrawSurface_UpdateOverlayZOrder(p,a,b)   (p)->lpVtbl->UpdateOverlayZOrder(p,a,b)
#else
#define IDirectDrawSurface_QueryInterface(p,a,b)        (p)->QueryInterface(a,b)
#define IDirectDrawSurface_AddRef(p)                    (p)->AddRef()
#define IDirectDrawSurface_Release(p)                   (p)->Release()
#define IDirectDrawSurface_AddAttachedSurface(p,a)      (p)->AddAttachedSurface(a)
#define IDirectDrawSurface_AddOverlayDirtyRect(p,a)     (p)->AddOverlayDirtyRect(a)
#define IDirectDrawSurface_Blt(p,a,b,c,d,e)             (p)->Blt(a,b,c,d,e)
#define IDirectDrawSurface_BltBatch(p,a,b,c)            (p)->BltBatch(a,b,c)
#define IDirectDrawSurface_BltFast(p,a,b,c,d,e)         (p)->BltFast(a,b,c,d,e)
#define IDirectDrawSurface_DeleteAttachedSurface(p,a,b) (p)->DeleteAttachedSurface(a,b)
#define IDirectDrawSurface_EnumAttachedSurfaces(p,a,b)  (p)->EnumAttachedSurfaces(a,b)
#define IDirectDrawSurface_EnumOverlayZOrders(p,a,b,c)  (p)->EnumOverlayZOrders(a,b,c)
#define IDirectDrawSurface_Flip(p,a,b)                  (p)->Flip(a,b)
#define IDirectDrawSurface_GetAttachedSurface(p,a,b)    (p)->GetAttachedSurface(a,b)
#define IDirectDrawSurface_GetBltStatus(p,a)            (p)->GetBltStatus(a)
#define IDirectDrawSurface_GetCaps(p,b)                 (p)->GetCaps(b)
#define IDirectDrawSurface_GetClipper(p,a)              (p)->GetClipper(a)
#define IDirectDrawSurface_GetColorKey(p,a,b)           (p)->GetColorKey(a,b)
#define IDirectDrawSurface_GetDC(p,a)                   (p)->GetDC(a)
#define IDirectDrawSurface_GetFlipStatus(p,a)           (p)->GetFlipStatus(a)
#define IDirectDrawSurface_GetOverlayPosition(p,a,b)    (p)->GetOverlayPosition(a,b)
#define IDirectDrawSurface_GetPalette(p,a)              (p)->GetPalette(a)
#define IDirectDrawSurface_GetPixelFormat(p,a)          (p)->GetPixelFormat(a)
#define IDirectDrawSurface_GetSurfaceDesc(p,a)          (p)->GetSurfaceDesc(a)
#define IDirectDrawSurface_Initialize(p,a,b)            (p)->Initialize(a,b)
#define IDirectDrawSurface_IsLost(p)                    (p)->IsLost()
#define IDirectDrawSurface_Lock(p,a,b,c,d)              (p)->Lock(a,b,c,d)
#define IDirectDrawSurface_ReleaseDC(p,a)               (p)->ReleaseDC(a)
#define IDirectDrawSurface_Restore(p)                   (p)->Restore()
#define IDirectDrawSurface_SetClipper(p,a)              (p)->SetClipper(a)
#define IDirectDrawSurface_SetColorKey(p,a,b)           (p)->SetColorKey(a,b)
#define IDirectDrawSurface_SetOverlayPosition(p,a,b)    (p)->SetOverlayPosition(a,b)
#define IDirectDrawSurface_SetPalette(p,a)              (p)->SetPalette(a)
#define IDirectDrawSurface_Unlock(p,b)                  (p)->Unlock(b)
#define IDirectDrawSurface_UpdateOverlay(p,a,b,c,d,e)   (p)->UpdateOverlay(a,b,c,d,e)
#define IDirectDrawSurface_UpdateOverlayDisplay(p,a)    (p)->UpdateOverlayDisplay(a)
#define IDirectDrawSurface_UpdateOverlayZOrder(p,a,b)   (p)->UpdateOverlayZOrder(a,b)
#endif

/*
 * IDirectDrawSurface2 and related interfaces
 */
#undef INTERFACE
#define INTERFACE IDirectDrawSurface2
DECLARE_INTERFACE_( IDirectDrawSurface2, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDrawSurface methods ***/
    STDMETHOD(AddAttachedSurface)(THIS_ LPDIRECTDRAWSURFACE2) PURE;
    STDMETHOD(AddOverlayDirtyRect)(THIS_ LPRECT) PURE;
    STDMETHOD(Blt)(THIS_ LPRECT,LPDIRECTDRAWSURFACE2, LPRECT,DWORD, LPDDBLTFX) PURE;
    STDMETHOD(BltBatch)(THIS_ LPDDBLTBATCH, DWORD, DWORD ) PURE;
    STDMETHOD(BltFast)(THIS_ DWORD,DWORD,LPDIRECTDRAWSURFACE2, LPRECT,DWORD) PURE;
    STDMETHOD(DeleteAttachedSurface)(THIS_ DWORD,LPDIRECTDRAWSURFACE2) PURE;
    STDMETHOD(EnumAttachedSurfaces)(THIS_ LPVOID,LPDDENUMSURFACESCALLBACK) PURE;
    STDMETHOD(EnumOverlayZOrders)(THIS_ DWORD,LPVOID,LPDDENUMSURFACESCALLBACK) PURE;
    STDMETHOD(Flip)(THIS_ LPDIRECTDRAWSURFACE2, DWORD) PURE;
    STDMETHOD(GetAttachedSurface)(THIS_ LPDDSCAPS, LPDIRECTDRAWSURFACE2 FAR *) PURE;
    STDMETHOD(GetBltStatus)(THIS_ DWORD) PURE;
    STDMETHOD(GetCaps)(THIS_ LPDDSCAPS) PURE;
    STDMETHOD(GetClipper)(THIS_ LPDIRECTDRAWCLIPPER FAR*) PURE;
    STDMETHOD(GetColorKey)(THIS_ DWORD, LPDDCOLORKEY) PURE;
    STDMETHOD(GetDC)(THIS_ HDC FAR *) PURE;
    STDMETHOD(GetFlipStatus)(THIS_ DWORD) PURE;
    STDMETHOD(GetOverlayPosition)(THIS_ LPLONG, LPLONG ) PURE;
    STDMETHOD(GetPalette)(THIS_ LPDIRECTDRAWPALETTE FAR*) PURE;
    STDMETHOD(GetPixelFormat)(THIS_ LPDDPIXELFORMAT) PURE;
    STDMETHOD(GetSurfaceDesc)(THIS_ LPDDSURFACEDESC) PURE;
    STDMETHOD(Initialize)(THIS_ LPDIRECTDRAW, LPDDSURFACEDESC) PURE;
    STDMETHOD(IsLost)(THIS) PURE;
    STDMETHOD(Lock)(THIS_ LPRECT,LPDDSURFACEDESC,DWORD,HANDLE) PURE;
    STDMETHOD(ReleaseDC)(THIS_ HDC) PURE;
    STDMETHOD(Restore)(THIS) PURE;
    STDMETHOD(SetClipper)(THIS_ LPDIRECTDRAWCLIPPER) PURE;
    STDMETHOD(SetColorKey)(THIS_ DWORD, LPDDCOLORKEY) PURE;
    STDMETHOD(SetOverlayPosition)(THIS_ LONG, LONG ) PURE;
    STDMETHOD(SetPalette)(THIS_ LPDIRECTDRAWPALETTE) PURE;
    STDMETHOD(Unlock)(THIS_ LPVOID) PURE;
    STDMETHOD(UpdateOverlay)(THIS_ LPRECT, LPDIRECTDRAWSURFACE2,LPRECT,DWORD, LPDDOVERLAYFX) PURE;
    STDMETHOD(UpdateOverlayDisplay)(THIS_ DWORD) PURE;
    STDMETHOD(UpdateOverlayZOrder)(THIS_ DWORD, LPDIRECTDRAWSURFACE2) PURE;
    /*** Added in the v2 interface ***/
    STDMETHOD(GetDDInterface)(THIS_ LPVOID FAR *) PURE;
    STDMETHOD(PageLock)(THIS_ DWORD) PURE;
    STDMETHOD(PageUnlock)(THIS_ DWORD) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectDrawSurface2_QueryInterface(p,a,b)        (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectDrawSurface2_AddRef(p)                    (p)->lpVtbl->AddRef(p)
#define IDirectDrawSurface2_Release(p)                   (p)->lpVtbl->Release(p)
#define IDirectDrawSurface2_AddAttachedSurface(p,a)      (p)->lpVtbl->AddAttachedSurface(p,a)
#define IDirectDrawSurface2_AddOverlayDirtyRect(p,a)     (p)->lpVtbl->AddOverlayDirtyRect(p,a)
#define IDirectDrawSurface2_Blt(p,a,b,c,d,e)             (p)->lpVtbl->Blt(p,a,b,c,d,e)
#define IDirectDrawSurface2_BltBatch(p,a,b,c)            (p)->lpVtbl->BltBatch(p,a,b,c)
#define IDirectDrawSurface2_BltFast(p,a,b,c,d,e)         (p)->lpVtbl->BltFast(p,a,b,c,d,e)
#define IDirectDrawSurface2_DeleteAttachedSurface(p,a,b) (p)->lpVtbl->DeleteAttachedSurface(p,a,b)
#define IDirectDrawSurface2_EnumAttachedSurfaces(p,a,b)  (p)->lpVtbl->EnumAttachedSurfaces(p,a,b)
#define IDirectDrawSurface2_EnumOverlayZOrders(p,a,b,c)  (p)->lpVtbl->EnumOverlayZOrders(p,a,b,c)
#define IDirectDrawSurface2_Flip(p,a,b)                  (p)->lpVtbl->Flip(p,a,b)
#define IDirectDrawSurface2_GetAttachedSurface(p,a,b)    (p)->lpVtbl->GetAttachedSurface(p,a,b)
#define IDirectDrawSurface2_GetBltStatus(p,a)            (p)->lpVtbl->GetBltStatus(p,a)
#define IDirectDrawSurface2_GetCaps(p,b)                 (p)->lpVtbl->GetCaps(p,b)
#define IDirectDrawSurface2_GetClipper(p,a)              (p)->lpVtbl->GetClipper(p,a)
#define IDirectDrawSurface2_GetColorKey(p,a,b)           (p)->lpVtbl->GetColorKey(p,a,b)
#define IDirectDrawSurface2_GetDC(p,a)                   (p)->lpVtbl->GetDC(p,a)
#define IDirectDrawSurface2_GetFlipStatus(p,a)           (p)->lpVtbl->GetFlipStatus(p,a)
#define IDirectDrawSurface2_GetOverlayPosition(p,a,b)    (p)->lpVtbl->GetOverlayPosition(p,a,b)
#define IDirectDrawSurface2_GetPalette(p,a)              (p)->lpVtbl->GetPalette(p,a)
#define IDirectDrawSurface2_GetPixelFormat(p,a)          (p)->lpVtbl->GetPixelFormat(p,a)
#define IDirectDrawSurface2_GetSurfaceDesc(p,a)          (p)->lpVtbl->GetSurfaceDesc(p,a)
#define IDirectDrawSurface2_Initialize(p,a,b)            (p)->lpVtbl->Initialize(p,a,b)
#define IDirectDrawSurface2_IsLost(p)                    (p)->lpVtbl->IsLost(p)
#define IDirectDrawSurface2_Lock(p,a,b,c,d)              (p)->lpVtbl->Lock(p,a,b,c,d)
#define IDirectDrawSurface2_ReleaseDC(p,a)               (p)->lpVtbl->ReleaseDC(p,a)
#define IDirectDrawSurface2_Restore(p)                   (p)->lpVtbl->Restore(p)
#define IDirectDrawSurface2_SetClipper(p,a)              (p)->lpVtbl->SetClipper(p,a)
#define IDirectDrawSurface2_SetColorKey(p,a,b)           (p)->lpVtbl->SetColorKey(p,a,b)
#define IDirectDrawSurface2_SetOverlayPosition(p,a,b)    (p)->lpVtbl->SetOverlayPosition(p,a,b)
#define IDirectDrawSurface2_SetPalette(p,a)              (p)->lpVtbl->SetPalette(p,a)
#define IDirectDrawSurface2_Unlock(p,b)                  (p)->lpVtbl->Unlock(p,b)
#define IDirectDrawSurface2_UpdateOverlay(p,a,b,c,d,e)   (p)->lpVtbl->UpdateOverlay(p,a,b,c,d,e)
#define IDirectDrawSurface2_UpdateOverlayDisplay(p,a)    (p)->lpVtbl->UpdateOverlayDisplay(p,a)
#define IDirectDrawSurface2_UpdateOverlayZOrder(p,a,b)   (p)->lpVtbl->UpdateOverlayZOrder(p,a,b)
#define IDirectDrawSurface2_GetDDInterface(p,a)          (p)->lpVtbl->GetDDInterface(p,a)
#define IDirectDrawSurface2_PageLock(p,a)                (p)->lpVtbl->PageLock(p,a)
#define IDirectDrawSurface2_PageUnlock(p,a)              (p)->lpVtbl->PageUnlock(p,a)
#else
#define IDirectDrawSurface2_QueryInterface(p,a,b)        (p)->QueryInterface(a,b)
#define IDirectDrawSurface2_AddRef(p)                    (p)->AddRef()
#define IDirectDrawSurface2_Release(p)                   (p)->Release()
#define IDirectDrawSurface2_AddAttachedSurface(p,a)      (p)->AddAttachedSurface(a)
#define IDirectDrawSurface2_AddOverlayDirtyRect(p,a)     (p)->AddOverlayDirtyRect(a)
#define IDirectDrawSurface2_Blt(p,a,b,c,d,e)             (p)->Blt(a,b,c,d,e)
#define IDirectDrawSurface2_BltBatch(p,a,b,c)            (p)->BltBatch(a,b,c)
#define IDirectDrawSurface2_BltFast(p,a,b,c,d,e)         (p)->BltFast(a,b,c,d,e)
#define IDirectDrawSurface2_DeleteAttachedSurface(p,a,b) (p)->DeleteAttachedSurface(a,b)
#define IDirectDrawSurface2_EnumAttachedSurfaces(p,a,b)  (p)->EnumAttachedSurfaces(a,b)
#define IDirectDrawSurface2_EnumOverlayZOrders(p,a,b,c)  (p)->EnumOverlayZOrders(a,b,c)
#define IDirectDrawSurface2_Flip(p,a,b)                  (p)->Flip(a,b)
#define IDirectDrawSurface2_GetAttachedSurface(p,a,b)    (p)->GetAttachedSurface(a,b)
#define IDirectDrawSurface2_GetBltStatus(p,a)            (p)->GetBltStatus(a)
#define IDirectDrawSurface2_GetCaps(p,b)                 (p)->GetCaps(b)
#define IDirectDrawSurface2_GetClipper(p,a)              (p)->GetClipper(a)
#define IDirectDrawSurface2_GetColorKey(p,a,b)           (p)->GetColorKey(a,b)
#define IDirectDrawSurface2_GetDC(p,a)                   (p)->GetDC(a)
#define IDirectDrawSurface2_GetFlipStatus(p,a)           (p)->GetFlipStatus(a)
#define IDirectDrawSurface2_GetOverlayPosition(p,a,b)    (p)->GetOverlayPosition(a,b)
#define IDirectDrawSurface2_GetPalette(p,a)              (p)->GetPalette(a)
#define IDirectDrawSurface2_GetPixelFormat(p,a)          (p)->GetPixelFormat(a)
#define IDirectDrawSurface2_GetSurfaceDesc(p,a)          (p)->GetSurfaceDesc(a)
#define IDirectDrawSurface2_Initialize(p,a,b)            (p)->Initialize(a,b)
#define IDirectDrawSurface2_IsLost(p)                    (p)->IsLost()
#define IDirectDrawSurface2_Lock(p,a,b,c,d)              (p)->Lock(a,b,c,d)
#define IDirectDrawSurface2_ReleaseDC(p,a)               (p)->ReleaseDC(a)
#define IDirectDrawSurface2_Restore(p)                   (p)->Restore()
#define IDirectDrawSurface2_SetClipper(p,a)              (p)->SetClipper(a)
#define IDirectDrawSurface2_SetColorKey(p,a,b)           (p)->SetColorKey(a,b)
#define IDirectDrawSurface2_SetOverlayPosition(p,a,b)    (p)->SetOverlayPosition(a,b)
#define IDirectDrawSurface2_SetPalette(p,a)              (p)->SetPalette(a)
#define IDirectDrawSurface2_Unlock(p,b)                  (p)->Unlock(b)
#define IDirectDrawSurface2_UpdateOverlay(p,a,b,c,d,e)   (p)->UpdateOverlay(a,b,c,d,e)
#define IDirectDrawSurface2_UpdateOverlayDisplay(p,a)    (p)->UpdateOverlayDisplay(a)
#define IDirectDrawSurface2_UpdateOverlayZOrder(p,a,b)   (p)->UpdateOverlayZOrder(a,b)
#define IDirectDrawSurface2_GetDDInterface(p,a)          (p)->GetDDInterface(a)
#define IDirectDrawSurface2_PageLock(p,a)                (p)->PageLock(a)
#define IDirectDrawSurface2_PageUnlock(p,a)              (p)->PageUnlock(a)
#endif

/*
 * IDirectDrawSurface3 and related interfaces
 */
#undef INTERFACE
#define INTERFACE IDirectDrawSurface3
DECLARE_INTERFACE_( IDirectDrawSurface3, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDrawSurface methods ***/
    STDMETHOD(AddAttachedSurface)(THIS_ LPDIRECTDRAWSURFACE3) PURE;
    STDMETHOD(AddOverlayDirtyRect)(THIS_ LPRECT) PURE;
    STDMETHOD(Blt)(THIS_ LPRECT,LPDIRECTDRAWSURFACE3, LPRECT,DWORD, LPDDBLTFX) PURE;
    STDMETHOD(BltBatch)(THIS_ LPDDBLTBATCH, DWORD, DWORD ) PURE;
    STDMETHOD(BltFast)(THIS_ DWORD,DWORD,LPDIRECTDRAWSURFACE3, LPRECT,DWORD) PURE;
    STDMETHOD(DeleteAttachedSurface)(THIS_ DWORD,LPDIRECTDRAWSURFACE3) PURE;
    STDMETHOD(EnumAttachedSurfaces)(THIS_ LPVOID,LPDDENUMSURFACESCALLBACK) PURE;
    STDMETHOD(EnumOverlayZOrders)(THIS_ DWORD,LPVOID,LPDDENUMSURFACESCALLBACK) PURE;
    STDMETHOD(Flip)(THIS_ LPDIRECTDRAWSURFACE3, DWORD) PURE;
    STDMETHOD(GetAttachedSurface)(THIS_ LPDDSCAPS, LPDIRECTDRAWSURFACE3 FAR *) PURE;
    STDMETHOD(GetBltStatus)(THIS_ DWORD) PURE;
    STDMETHOD(GetCaps)(THIS_ LPDDSCAPS) PURE;
    STDMETHOD(GetClipper)(THIS_ LPDIRECTDRAWCLIPPER FAR*) PURE;
    STDMETHOD(GetColorKey)(THIS_ DWORD, LPDDCOLORKEY) PURE;
    STDMETHOD(GetDC)(THIS_ HDC FAR *) PURE;
    STDMETHOD(GetFlipStatus)(THIS_ DWORD) PURE;
    STDMETHOD(GetOverlayPosition)(THIS_ LPLONG, LPLONG ) PURE;
    STDMETHOD(GetPalette)(THIS_ LPDIRECTDRAWPALETTE FAR*) PURE;
    STDMETHOD(GetPixelFormat)(THIS_ LPDDPIXELFORMAT) PURE;
    STDMETHOD(GetSurfaceDesc)(THIS_ LPDDSURFACEDESC) PURE;
    STDMETHOD(Initialize)(THIS_ LPDIRECTDRAW, LPDDSURFACEDESC) PURE;
    STDMETHOD(IsLost)(THIS) PURE;
    STDMETHOD(Lock)(THIS_ LPRECT,LPDDSURFACEDESC,DWORD,HANDLE) PURE;
    STDMETHOD(ReleaseDC)(THIS_ HDC) PURE;
    STDMETHOD(Restore)(THIS) PURE;
    STDMETHOD(SetClipper)(THIS_ LPDIRECTDRAWCLIPPER) PURE;
    STDMETHOD(SetColorKey)(THIS_ DWORD, LPDDCOLORKEY) PURE;
    STDMETHOD(SetOverlayPosition)(THIS_ LONG, LONG ) PURE;
    STDMETHOD(SetPalette)(THIS_ LPDIRECTDRAWPALETTE) PURE;
    STDMETHOD(Unlock)(THIS_ LPVOID) PURE;
    STDMETHOD(UpdateOverlay)(THIS_ LPRECT, LPDIRECTDRAWSURFACE3,LPRECT,DWORD, LPDDOVERLAYFX) PURE;
    STDMETHOD(UpdateOverlayDisplay)(THIS_ DWORD) PURE;
    STDMETHOD(UpdateOverlayZOrder)(THIS_ DWORD, LPDIRECTDRAWSURFACE3) PURE;
    /*** Added in the v2 interface ***/
    STDMETHOD(GetDDInterface)(THIS_ LPVOID FAR *) PURE;
    STDMETHOD(PageLock)(THIS_ DWORD) PURE;
    STDMETHOD(PageUnlock)(THIS_ DWORD) PURE;
    /*** Added in the V3 interface ***/
    STDMETHOD(SetSurfaceDesc)(THIS_ LPDDSURFACEDESC, DWORD) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectDrawSurface3_QueryInterface(p,a,b)        (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectDrawSurface3_AddRef(p)                    (p)->lpVtbl->AddRef(p)
#define IDirectDrawSurface3_Release(p)                   (p)->lpVtbl->Release(p)
#define IDirectDrawSurface3_AddAttachedSurface(p,a)      (p)->lpVtbl->AddAttachedSurface(p,a)
#define IDirectDrawSurface3_AddOverlayDirtyRect(p,a)     (p)->lpVtbl->AddOverlayDirtyRect(p,a)
#define IDirectDrawSurface3_Blt(p,a,b,c,d,e)             (p)->lpVtbl->Blt(p,a,b,c,d,e)
#define IDirectDrawSurface3_BltBatch(p,a,b,c)            (p)->lpVtbl->BltBatch(p,a,b,c)
#define IDirectDrawSurface3_BltFast(p,a,b,c,d,e)         (p)->lpVtbl->BltFast(p,a,b,c,d,e)
#define IDirectDrawSurface3_DeleteAttachedSurface(p,a,b) (p)->lpVtbl->DeleteAttachedSurface(p,a,b)
#define IDirectDrawSurface3_EnumAttachedSurfaces(p,a,b)  (p)->lpVtbl->EnumAttachedSurfaces(p,a,b)
#define IDirectDrawSurface3_EnumOverlayZOrders(p,a,b,c)  (p)->lpVtbl->EnumOverlayZOrders(p,a,b,c)
#define IDirectDrawSurface3_Flip(p,a,b)                  (p)->lpVtbl->Flip(p,a,b)
#define IDirectDrawSurface3_GetAttachedSurface(p,a,b)    (p)->lpVtbl->GetAttachedSurface(p,a,b)
#define IDirectDrawSurface3_GetBltStatus(p,a)            (p)->lpVtbl->GetBltStatus(p,a)
#define IDirectDrawSurface3_GetCaps(p,b)                 (p)->lpVtbl->GetCaps(p,b)
#define IDirectDrawSurface3_GetClipper(p,a)              (p)->lpVtbl->GetClipper(p,a)
#define IDirectDrawSurface3_GetColorKey(p,a,b)           (p)->lpVtbl->GetColorKey(p,a,b)
#define IDirectDrawSurface3_GetDC(p,a)                   (p)->lpVtbl->GetDC(p,a)
#define IDirectDrawSurface3_GetFlipStatus(p,a)           (p)->lpVtbl->GetFlipStatus(p,a)
#define IDirectDrawSurface3_GetOverlayPosition(p,a,b)    (p)->lpVtbl->GetOverlayPosition(p,a,b)
#define IDirectDrawSurface3_GetPalette(p,a)              (p)->lpVtbl->GetPalette(p,a)
#define IDirectDrawSurface3_GetPixelFormat(p,a)          (p)->lpVtbl->GetPixelFormat(p,a)
#define IDirectDrawSurface3_GetSurfaceDesc(p,a)          (p)->lpVtbl->GetSurfaceDesc(p,a)
#define IDirectDrawSurface3_Initialize(p,a,b)            (p)->lpVtbl->Initialize(p,a,b)
#define IDirectDrawSurface3_IsLost(p)                    (p)->lpVtbl->IsLost(p)
#define IDirectDrawSurface3_Lock(p,a,b,c,d)              (p)->lpVtbl->Lock(p,a,b,c,d)
#define IDirectDrawSurface3_ReleaseDC(p,a)               (p)->lpVtbl->ReleaseDC(p,a)
#define IDirectDrawSurface3_Restore(p)                   (p)->lpVtbl->Restore(p)
#define IDirectDrawSurface3_SetClipper(p,a)              (p)->lpVtbl->SetClipper(p,a)
#define IDirectDrawSurface3_SetColorKey(p,a,b)           (p)->lpVtbl->SetColorKey(p,a,b)
#define IDirectDrawSurface3_SetOverlayPosition(p,a,b)    (p)->lpVtbl->SetOverlayPosition(p,a,b)
#define IDirectDrawSurface3_SetPalette(p,a)              (p)->lpVtbl->SetPalette(p,a)
#define IDirectDrawSurface3_Unlock(p,b)                  (p)->lpVtbl->Unlock(p,b)
#define IDirectDrawSurface3_UpdateOverlay(p,a,b,c,d,e)   (p)->lpVtbl->UpdateOverlay(p,a,b,c,d,e)
#define IDirectDrawSurface3_UpdateOverlayDisplay(p,a)    (p)->lpVtbl->UpdateOverlayDisplay(p,a)
#define IDirectDrawSurface3_UpdateOverlayZOrder(p,a,b)   (p)->lpVtbl->UpdateOverlayZOrder(p,a,b)
#define IDirectDrawSurface3_GetDDInterface(p,a)          (p)->lpVtbl->GetDDInterface(p,a)
#define IDirectDrawSurface3_PageLock(p,a)                (p)->lpVtbl->PageLock(p,a)
#define IDirectDrawSurface3_PageUnlock(p,a)              (p)->lpVtbl->PageUnlock(p,a)
#define IDirectDrawSurface3_SetSurfaceDesc(p,a,b)        (p)->lpVtbl->SetSurfaceDesc(p,a,b)
#else
#define IDirectDrawSurface3_QueryInterface(p,a,b)        (p)->QueryInterface(a,b)
#define IDirectDrawSurface3_AddRef(p)                    (p)->AddRef()
#define IDirectDrawSurface3_Release(p)                   (p)->Release()
#define IDirectDrawSurface3_AddAttachedSurface(p,a)      (p)->AddAttachedSurface(a)
#define IDirectDrawSurface3_AddOverlayDirtyRect(p,a)     (p)->AddOverlayDirtyRect(a)
#define IDirectDrawSurface3_Blt(p,a,b,c,d,e)             (p)->Blt(a,b,c,d,e)
#define IDirectDrawSurface3_BltBatch(p,a,b,c)            (p)->BltBatch(a,b,c)
#define IDirectDrawSurface3_BltFast(p,a,b,c,d,e)         (p)->BltFast(a,b,c,d,e)
#define IDirectDrawSurface3_DeleteAttachedSurface(p,a,b) (p)->DeleteAttachedSurface(a,b)
#define IDirectDrawSurface3_EnumAttachedSurfaces(p,a,b)  (p)->EnumAttachedSurfaces(a,b)
#define IDirectDrawSurface3_EnumOverlayZOrders(p,a,b,c)  (p)->EnumOverlayZOrders(a,b,c)
#define IDirectDrawSurface3_Flip(p,a,b)                  (p)->Flip(a,b)
#define IDirectDrawSurface3_GetAttachedSurface(p,a,b)    (p)->GetAttachedSurface(a,b)
#define IDirectDrawSurface3_GetBltStatus(p,a)            (p)->GetBltStatus(a)
#define IDirectDrawSurface3_GetCaps(p,b)                 (p)->GetCaps(b)
#define IDirectDrawSurface3_GetClipper(p,a)              (p)->GetClipper(a)
#define IDirectDrawSurface3_GetColorKey(p,a,b)           (p)->GetColorKey(a,b)
#define IDirectDrawSurface3_GetDC(p,a)                   (p)->GetDC(a)
#define IDirectDrawSurface3_GetFlipStatus(p,a)           (p)->GetFlipStatus(a)
#define IDirectDrawSurface3_GetOverlayPosition(p,a,b)    (p)->GetOverlayPosition(a,b)
#define IDirectDrawSurface3_GetPalette(p,a)              (p)->GetPalette(a)
#define IDirectDrawSurface3_GetPixelFormat(p,a)          (p)->GetPixelFormat(a)
#define IDirectDrawSurface3_GetSurfaceDesc(p,a)          (p)->GetSurfaceDesc(a)
#define IDirectDrawSurface3_Initialize(p,a,b)            (p)->Initialize(a,b)
#define IDirectDrawSurface3_IsLost(p)                    (p)->IsLost()
#define IDirectDrawSurface3_Lock(p,a,b,c,d)              (p)->Lock(a,b,c,d)
#define IDirectDrawSurface3_ReleaseDC(p,a)               (p)->ReleaseDC(a)
#define IDirectDrawSurface3_Restore(p)                   (p)->Restore()
#define IDirectDrawSurface3_SetClipper(p,a)              (p)->SetClipper(a)
#define IDirectDrawSurface3_SetColorKey(p,a,b)           (p)->SetColorKey(a,b)
#define IDirectDrawSurface3_SetOverlayPosition(p,a,b)    (p)->SetOverlayPosition(a,b)
#define IDirectDrawSurface3_SetPalette(p,a)              (p)->SetPalette(a)
#define IDirectDrawSurface3_Unlock(p,b)                  (p)->Unlock(b)
#define IDirectDrawSurface3_UpdateOverlay(p,a,b,c,d,e)   (p)->UpdateOverlay(a,b,c,d,e)
#define IDirectDrawSurface3_UpdateOverlayDisplay(p,a)    (p)->UpdateOverlayDisplay(a)
#define IDirectDrawSurface3_UpdateOverlayZOrder(p,a,b)   (p)->UpdateOverlayZOrder(a,b)
#define IDirectDrawSurface3_GetDDInterface(p,a)          (p)->GetDDInterface(a)
#define IDirectDrawSurface3_PageLock(p,a)                (p)->PageLock(a)
#define IDirectDrawSurface3_PageUnlock(p,a)              (p)->PageUnlock(a)
#define IDirectDrawSurface3_SetSurfaceDesc(p,a,b)        (p)->SetSurfaceDesc(a,b)
#endif

/*
 * IDirectDrawSurface4 and related interfaces
 */
#undef INTERFACE
#define INTERFACE IDirectDrawSurface4
DECLARE_INTERFACE_( IDirectDrawSurface4, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDrawSurface methods ***/
    STDMETHOD(AddAttachedSurface)(THIS_ LPDIRECTDRAWSURFACE4) PURE;
    STDMETHOD(AddOverlayDirtyRect)(THIS_ LPRECT) PURE;
    STDMETHOD(Blt)(THIS_ LPRECT,LPDIRECTDRAWSURFACE4, LPRECT,DWORD, LPDDBLTFX) PURE;
    STDMETHOD(BltBatch)(THIS_ LPDDBLTBATCH, DWORD, DWORD ) PURE;
    STDMETHOD(BltFast)(THIS_ DWORD,DWORD,LPDIRECTDRAWSURFACE4, LPRECT,DWORD) PURE;
    STDMETHOD(DeleteAttachedSurface)(THIS_ DWORD,LPDIRECTDRAWSURFACE4) PURE;
    STDMETHOD(EnumAttachedSurfaces)(THIS_ LPVOID,LPDDENUMSURFACESCALLBACK2) PURE;
    STDMETHOD(EnumOverlayZOrders)(THIS_ DWORD,LPVOID,LPDDENUMSURFACESCALLBACK2) PURE;
    STDMETHOD(Flip)(THIS_ LPDIRECTDRAWSURFACE4, DWORD) PURE;
    STDMETHOD(GetAttachedSurface)(THIS_ LPDDSCAPS2, LPDIRECTDRAWSURFACE4 FAR *) PURE;
    STDMETHOD(GetBltStatus)(THIS_ DWORD) PURE;
    STDMETHOD(GetCaps)(THIS_ LPDDSCAPS2) PURE;
    STDMETHOD(GetClipper)(THIS_ LPDIRECTDRAWCLIPPER FAR*) PURE;
    STDMETHOD(GetColorKey)(THIS_ DWORD, LPDDCOLORKEY) PURE;
    STDMETHOD(GetDC)(THIS_ HDC FAR *) PURE;
    STDMETHOD(GetFlipStatus)(THIS_ DWORD) PURE;
    STDMETHOD(GetOverlayPosition)(THIS_ LPLONG, LPLONG ) PURE;
    STDMETHOD(GetPalette)(THIS_ LPDIRECTDRAWPALETTE FAR*) PURE;
    STDMETHOD(GetPixelFormat)(THIS_ LPDDPIXELFORMAT) PURE;
    STDMETHOD(GetSurfaceDesc)(THIS_ LPDDSURFACEDESC2) PURE;
    STDMETHOD(Initialize)(THIS_ LPDIRECTDRAW, LPDDSURFACEDESC2) PURE;
    STDMETHOD(IsLost)(THIS) PURE;
    STDMETHOD(Lock)(THIS_ LPRECT,LPDDSURFACEDESC2,DWORD,HANDLE) PURE;
    STDMETHOD(ReleaseDC)(THIS_ HDC) PURE;
    STDMETHOD(Restore)(THIS) PURE;
    STDMETHOD(SetClipper)(THIS_ LPDIRECTDRAWCLIPPER) PURE;
    STDMETHOD(SetColorKey)(THIS_ DWORD, LPDDCOLORKEY) PURE;
    STDMETHOD(SetOverlayPosition)(THIS_ LONG, LONG ) PURE;
    STDMETHOD(SetPalette)(THIS_ LPDIRECTDRAWPALETTE) PURE;
    STDMETHOD(Unlock)(THIS_ LPRECT) PURE;
    STDMETHOD(UpdateOverlay)(THIS_ LPRECT, LPDIRECTDRAWSURFACE4,LPRECT,DWORD, LPDDOVERLAYFX) PURE;
    STDMETHOD(UpdateOverlayDisplay)(THIS_ DWORD) PURE;
    STDMETHOD(UpdateOverlayZOrder)(THIS_ DWORD, LPDIRECTDRAWSURFACE4) PURE;
    /*** Added in the v2 interface ***/
    STDMETHOD(GetDDInterface)(THIS_ LPVOID FAR *) PURE;
    STDMETHOD(PageLock)(THIS_ DWORD) PURE;
    STDMETHOD(PageUnlock)(THIS_ DWORD) PURE;
    /*** Added in the v3 interface ***/
    STDMETHOD(SetSurfaceDesc)(THIS_ LPDDSURFACEDESC2, DWORD) PURE;
    /*** Added in the v4 interface ***/
    STDMETHOD(SetPrivateData)(THIS_ REFGUID, LPVOID, DWORD, DWORD) PURE;
    STDMETHOD(GetPrivateData)(THIS_ REFGUID, LPVOID, LPDWORD) PURE;
    STDMETHOD(FreePrivateData)(THIS_ REFGUID) PURE;
    STDMETHOD(GetUniquenessValue)(THIS_ LPDWORD) PURE;
    STDMETHOD(ChangeUniquenessValue)(THIS) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectDrawSurface4_QueryInterface(p,a,b)        (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectDrawSurface4_AddRef(p)                    (p)->lpVtbl->AddRef(p)
#define IDirectDrawSurface4_Release(p)                   (p)->lpVtbl->Release(p)
#define IDirectDrawSurface4_AddAttachedSurface(p,a)      (p)->lpVtbl->AddAttachedSurface(p,a)
#define IDirectDrawSurface4_AddOverlayDirtyRect(p,a)     (p)->lpVtbl->AddOverlayDirtyRect(p,a)
#define IDirectDrawSurface4_Blt(p,a,b,c,d,e)             (p)->lpVtbl->Blt(p,a,b,c,d,e)
#define IDirectDrawSurface4_BltBatch(p,a,b,c)            (p)->lpVtbl->BltBatch(p,a,b,c)
#define IDirectDrawSurface4_BltFast(p,a,b,c,d,e)         (p)->lpVtbl->BltFast(p,a,b,c,d,e)
#define IDirectDrawSurface4_DeleteAttachedSurface(p,a,b) (p)->lpVtbl->DeleteAttachedSurface(p,a,b)
#define IDirectDrawSurface4_EnumAttachedSurfaces(p,a,b)  (p)->lpVtbl->EnumAttachedSurfaces(p,a,b)
#define IDirectDrawSurface4_EnumOverlayZOrders(p,a,b,c)  (p)->lpVtbl->EnumOverlayZOrders(p,a,b,c)
#define IDirectDrawSurface4_Flip(p,a,b)                  (p)->lpVtbl->Flip(p,a,b)
#define IDirectDrawSurface4_GetAttachedSurface(p,a,b)    (p)->lpVtbl->GetAttachedSurface(p,a,b)
#define IDirectDrawSurface4_GetBltStatus(p,a)            (p)->lpVtbl->GetBltStatus(p,a)
#define IDirectDrawSurface4_GetCaps(p,b)                 (p)->lpVtbl->GetCaps(p,b)
#define IDirectDrawSurface4_GetClipper(p,a)              (p)->lpVtbl->GetClipper(p,a)
#define IDirectDrawSurface4_GetColorKey(p,a,b)           (p)->lpVtbl->GetColorKey(p,a,b)
#define IDirectDrawSurface4_GetDC(p,a)                   (p)->lpVtbl->GetDC(p,a)
#define IDirectDrawSurface4_GetFlipStatus(p,a)           (p)->lpVtbl->GetFlipStatus(p,a)
#define IDirectDrawSurface4_GetOverlayPosition(p,a,b)    (p)->lpVtbl->GetOverlayPosition(p,a,b)
#define IDirectDrawSurface4_GetPalette(p,a)              (p)->lpVtbl->GetPalette(p,a)
#define IDirectDrawSurface4_GetPixelFormat(p,a)          (p)->lpVtbl->GetPixelFormat(p,a)
#define IDirectDrawSurface4_GetSurfaceDesc(p,a)          (p)->lpVtbl->GetSurfaceDesc(p,a)
#define IDirectDrawSurface4_Initialize(p,a,b)            (p)->lpVtbl->Initialize(p,a,b)
#define IDirectDrawSurface4_IsLost(p)                    (p)->lpVtbl->IsLost(p)
#define IDirectDrawSurface4_Lock(p,a,b,c,d)              (p)->lpVtbl->Lock(p,a,b,c,d)
#define IDirectDrawSurface4_ReleaseDC(p,a)               (p)->lpVtbl->ReleaseDC(p,a)
#define IDirectDrawSurface4_Restore(p)                   (p)->lpVtbl->Restore(p)
#define IDirectDrawSurface4_SetClipper(p,a)              (p)->lpVtbl->SetClipper(p,a)
#define IDirectDrawSurface4_SetColorKey(p,a,b)           (p)->lpVtbl->SetColorKey(p,a,b)
#define IDirectDrawSurface4_SetOverlayPosition(p,a,b)    (p)->lpVtbl->SetOverlayPosition(p,a,b)
#define IDirectDrawSurface4_SetPalette(p,a)              (p)->lpVtbl->SetPalette(p,a)
#define IDirectDrawSurface4_Unlock(p,b)                  (p)->lpVtbl->Unlock(p,b)
#define IDirectDrawSurface4_UpdateOverlay(p,a,b,c,d,e)   (p)->lpVtbl->UpdateOverlay(p,a,b,c,d,e)
#define IDirectDrawSurface4_UpdateOverlayDisplay(p,a)    (p)->lpVtbl->UpdateOverlayDisplay(p,a)
#define IDirectDrawSurface4_UpdateOverlayZOrder(p,a,b)   (p)->lpVtbl->UpdateOverlayZOrder(p,a,b)
#define IDirectDrawSurface4_GetDDInterface(p,a)          (p)->lpVtbl->GetDDInterface(p,a)
#define IDirectDrawSurface4_PageLock(p,a)                (p)->lpVtbl->PageLock(p,a)
#define IDirectDrawSurface4_PageUnlock(p,a)              (p)->lpVtbl->PageUnlock(p,a)
#define IDirectDrawSurface4_SetSurfaceDesc(p,a,b)        (p)->lpVtbl->SetSurfaceDesc(p,a,b)
#define IDirectDrawSurface4_SetPrivateData(p,a,b,c,d)    (p)->lpVtbl->SetPrivateData(p,a,b,c,d)
#define IDirectDrawSurface4_GetPrivateData(p,a,b,c)      (p)->lpVtbl->GetPrivateData(p,a,b,c)
#define IDirectDrawSurface4_FreePrivateData(p,a)         (p)->lpVtbl->FreePrivateData(p,a)
#define IDirectDrawSurface4_GetUniquenessValue(p, a)     (p)->lpVtbl->GetUniquenessValue(p, a)
#define IDirectDrawSurface4_ChangeUniquenessValue(p)     (p)->lpVtbl->ChangeUniquenessValue(p)
#else
#define IDirectDrawSurface4_QueryInterface(p,a,b)        (p)->QueryInterface(a,b)
#define IDirectDrawSurface4_AddRef(p)                    (p)->AddRef()
#define IDirectDrawSurface4_Release(p)                   (p)->Release()
#define IDirectDrawSurface4_AddAttachedSurface(p,a)      (p)->AddAttachedSurface(a)
#define IDirectDrawSurface4_AddOverlayDirtyRect(p,a)     (p)->AddOverlayDirtyRect(a)
#define IDirectDrawSurface4_Blt(p,a,b,c,d,e)             (p)->Blt(a,b,c,d,e)
#define IDirectDrawSurface4_BltBatch(p,a,b,c)            (p)->BltBatch(a,b,c)
#define IDirectDrawSurface4_BltFast(p,a,b,c,d,e)         (p)->BltFast(a,b,c,d,e)
#define IDirectDrawSurface4_DeleteAttachedSurface(p,a,b) (p)->DeleteAttachedSurface(a,b)
#define IDirectDrawSurface4_EnumAttachedSurfaces(p,a,b)  (p)->EnumAttachedSurfaces(a,b)
#define IDirectDrawSurface4_EnumOverlayZOrders(p,a,b,c)  (p)->EnumOverlayZOrders(a,b,c)
#define IDirectDrawSurface4_Flip(p,a,b)                  (p)->Flip(a,b)
#define IDirectDrawSurface4_GetAttachedSurface(p,a,b)    (p)->GetAttachedSurface(a,b)
#define IDirectDrawSurface4_GetBltStatus(p,a)            (p)->GetBltStatus(a)
#define IDirectDrawSurface4_GetCaps(p,b)                 (p)->GetCaps(b)
#define IDirectDrawSurface4_GetClipper(p,a)              (p)->GetClipper(a)
#define IDirectDrawSurface4_GetColorKey(p,a,b)           (p)->GetColorKey(a,b)
#define IDirectDrawSurface4_GetDC(p,a)                   (p)->GetDC(a)
#define IDirectDrawSurface4_GetFlipStatus(p,a)           (p)->GetFlipStatus(a)
#define IDirectDrawSurface4_GetOverlayPosition(p,a,b)    (p)->GetOverlayPosition(a,b)
#define IDirectDrawSurface4_GetPalette(p,a)              (p)->GetPalette(a)
#define IDirectDrawSurface4_GetPixelFormat(p,a)          (p)->GetPixelFormat(a)
#define IDirectDrawSurface4_GetSurfaceDesc(p,a)          (p)->GetSurfaceDesc(a)
#define IDirectDrawSurface4_Initialize(p,a,b)            (p)->Initialize(a,b)
#define IDirectDrawSurface4_IsLost(p)                    (p)->IsLost()
#define IDirectDrawSurface4_Lock(p,a,b,c,d)              (p)->Lock(a,b,c,d)
#define IDirectDrawSurface4_ReleaseDC(p,a)               (p)->ReleaseDC(a)
#define IDirectDrawSurface4_Restore(p)                   (p)->Restore()
#define IDirectDrawSurface4_SetClipper(p,a)              (p)->SetClipper(a)
#define IDirectDrawSurface4_SetColorKey(p,a,b)           (p)->SetColorKey(a,b)
#define IDirectDrawSurface4_SetOverlayPosition(p,a,b)    (p)->SetOverlayPosition(a,b)
#define IDirectDrawSurface4_SetPalette(p,a)              (p)->SetPalette(a)
#define IDirectDrawSurface4_Unlock(p,b)                  (p)->Unlock(b)
#define IDirectDrawSurface4_UpdateOverlay(p,a,b,c,d,e)   (p)->UpdateOverlay(a,b,c,d,e)
#define IDirectDrawSurface4_UpdateOverlayDisplay(p,a)    (p)->UpdateOverlayDisplay(a)
#define IDirectDrawSurface4_UpdateOverlayZOrder(p,a,b)   (p)->UpdateOverlayZOrder(a,b)
#define IDirectDrawSurface4_GetDDInterface(p,a)          (p)->GetDDInterface(a)
#define IDirectDrawSurface4_PageLock(p,a)                (p)->PageLock(a)
#define IDirectDrawSurface4_PageUnlock(p,a)              (p)->PageUnlock(a)
#define IDirectDrawSurface4_SetSurfaceDesc(p,a,b)        (p)->SetSurfaceDesc(a,b)
#define IDirectDrawSurface4_SetPrivateData(p,a,b,c,d)    (p)->SetPrivateData(a,b,c,d)
#define IDirectDrawSurface4_GetPrivateData(p,a,b,c)      (p)->GetPrivateData(a,b,c)
#define IDirectDrawSurface4_FreePrivateData(p,a)         (p)->FreePrivateData(a)
#define IDirectDrawSurface4_GetUniquenessValue(p, a)     (p)->GetUniquenessValue(a)
#define IDirectDrawSurface4_ChangeUniquenessValue(p)     (p)->ChangeUniquenessValue()
#endif

/*
 * IDirectDrawSurface7 and related interfaces
 */
#undef INTERFACE
#define INTERFACE IDirectDrawSurface7
DECLARE_INTERFACE_( IDirectDrawSurface7, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDrawSurface methods ***/
    STDMETHOD(AddAttachedSurface)(THIS_ LPDIRECTDRAWSURFACE7) PURE;
    STDMETHOD(AddOverlayDirtyRect)(THIS_ LPRECT) PURE;
    STDMETHOD(Blt)(THIS_ LPRECT,LPDIRECTDRAWSURFACE7, LPRECT,DWORD, LPDDBLTFX) PURE;
    STDMETHOD(BltBatch)(THIS_ LPDDBLTBATCH, DWORD, DWORD ) PURE;
    STDMETHOD(BltFast)(THIS_ DWORD,DWORD,LPDIRECTDRAWSURFACE7, LPRECT,DWORD) PURE;
    STDMETHOD(DeleteAttachedSurface)(THIS_ DWORD,LPDIRECTDRAWSURFACE7) PURE;
    STDMETHOD(EnumAttachedSurfaces)(THIS_ LPVOID,LPDDENUMSURFACESCALLBACK7) PURE;
    STDMETHOD(EnumOverlayZOrders)(THIS_ DWORD,LPVOID,LPDDENUMSURFACESCALLBACK7) PURE;
    STDMETHOD(Flip)(THIS_ LPDIRECTDRAWSURFACE7, DWORD) PURE;
    STDMETHOD(GetAttachedSurface)(THIS_ LPDDSCAPS2, LPDIRECTDRAWSURFACE7 FAR *) PURE;
    STDMETHOD(GetBltStatus)(THIS_ DWORD) PURE;
    STDMETHOD(GetCaps)(THIS_ LPDDSCAPS2) PURE;
    STDMETHOD(GetClipper)(THIS_ LPDIRECTDRAWCLIPPER FAR*) PURE;
    STDMETHOD(GetColorKey)(THIS_ DWORD, LPDDCOLORKEY) PURE;
    STDMETHOD(GetDC)(THIS_ HDC FAR *) PURE;
    STDMETHOD(GetFlipStatus)(THIS_ DWORD) PURE;
    STDMETHOD(GetOverlayPosition)(THIS_ LPLONG, LPLONG ) PURE;
    STDMETHOD(GetPalette)(THIS_ LPDIRECTDRAWPALETTE FAR*) PURE;
    STDMETHOD(GetPixelFormat)(THIS_ LPDDPIXELFORMAT) PURE;
    STDMETHOD(GetSurfaceDesc)(THIS_ LPDDSURFACEDESC2) PURE;
    STDMETHOD(Initialize)(THIS_ LPDIRECTDRAW, LPDDSURFACEDESC2) PURE;
    STDMETHOD(IsLost)(THIS) PURE;
    STDMETHOD(Lock)(THIS_ LPRECT,LPDDSURFACEDESC2,DWORD,HANDLE) PURE;
    STDMETHOD(ReleaseDC)(THIS_ HDC) PURE;
    STDMETHOD(Restore)(THIS) PURE;
    STDMETHOD(SetClipper)(THIS_ LPDIRECTDRAWCLIPPER) PURE;
    STDMETHOD(SetColorKey)(THIS_ DWORD, LPDDCOLORKEY) PURE;
    STDMETHOD(SetOverlayPosition)(THIS_ LONG, LONG ) PURE;
    STDMETHOD(SetPalette)(THIS_ LPDIRECTDRAWPALETTE) PURE;
    STDMETHOD(Unlock)(THIS_ LPRECT) PURE;
    STDMETHOD(UpdateOverlay)(THIS_ LPRECT, LPDIRECTDRAWSURFACE7,LPRECT,DWORD, LPDDOVERLAYFX) PURE;
    STDMETHOD(UpdateOverlayDisplay)(THIS_ DWORD) PURE;
    STDMETHOD(UpdateOverlayZOrder)(THIS_ DWORD, LPDIRECTDRAWSURFACE7) PURE;
    /*** Added in the v2 interface ***/
    STDMETHOD(GetDDInterface)(THIS_ LPVOID FAR *) PURE;
    STDMETHOD(PageLock)(THIS_ DWORD) PURE;
    STDMETHOD(PageUnlock)(THIS_ DWORD) PURE;
    /*** Added in the v3 interface ***/
    STDMETHOD(SetSurfaceDesc)(THIS_ LPDDSURFACEDESC2, DWORD) PURE;
    /*** Added in the v4 interface ***/
    STDMETHOD(SetPrivateData)(THIS_ REFGUID, LPVOID, DWORD, DWORD) PURE;
    STDMETHOD(GetPrivateData)(THIS_ REFGUID, LPVOID, LPDWORD) PURE;
    STDMETHOD(FreePrivateData)(THIS_ REFGUID) PURE;
    STDMETHOD(GetUniquenessValue)(THIS_ LPDWORD) PURE;
    STDMETHOD(ChangeUniquenessValue)(THIS) PURE;
    /*** Moved Texture7 methods here ***/
    STDMETHOD(SetPriority)(THIS_ DWORD) PURE;
    STDMETHOD(GetPriority)(THIS_ LPDWORD) PURE;
    STDMETHOD(SetLOD)(THIS_ DWORD) PURE;
    STDMETHOD(GetLOD)(THIS_ LPDWORD) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectDrawSurface7_QueryInterface(p,a,b)        (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectDrawSurface7_AddRef(p)                    (p)->lpVtbl->AddRef(p)
#define IDirectDrawSurface7_Release(p)                   (p)->lpVtbl->Release(p)
#define IDirectDrawSurface7_AddAttachedSurface(p,a)      (p)->lpVtbl->AddAttachedSurface(p,a)
#define IDirectDrawSurface7_AddOverlayDirtyRect(p,a)     (p)->lpVtbl->AddOverlayDirtyRect(p,a)
#define IDirectDrawSurface7_Blt(p,a,b,c,d,e)             (p)->lpVtbl->Blt(p,a,b,c,d,e)
#define IDirectDrawSurface7_BltBatch(p,a,b,c)            (p)->lpVtbl->BltBatch(p,a,b,c)
#define IDirectDrawSurface7_BltFast(p,a,b,c,d,e)         (p)->lpVtbl->BltFast(p,a,b,c,d,e)
#define IDirectDrawSurface7_DeleteAttachedSurface(p,a,b) (p)->lpVtbl->DeleteAttachedSurface(p,a,b)
#define IDirectDrawSurface7_EnumAttachedSurfaces(p,a,b)  (p)->lpVtbl->EnumAttachedSurfaces(p,a,b)
#define IDirectDrawSurface7_EnumOverlayZOrders(p,a,b,c)  (p)->lpVtbl->EnumOverlayZOrders(p,a,b,c)
#define IDirectDrawSurface7_Flip(p,a,b)                  (p)->lpVtbl->Flip(p,a,b)
#define IDirectDrawSurface7_GetAttachedSurface(p,a,b)    (p)->lpVtbl->GetAttachedSurface(p,a,b)
#define IDirectDrawSurface7_GetBltStatus(p,a)            (p)->lpVtbl->GetBltStatus(p,a)
#define IDirectDrawSurface7_GetCaps(p,b)                 (p)->lpVtbl->GetCaps(p,b)
#define IDirectDrawSurface7_GetClipper(p,a)              (p)->lpVtbl->GetClipper(p,a)
#define IDirectDrawSurface7_GetColorKey(p,a,b)           (p)->lpVtbl->GetColorKey(p,a,b)
#define IDirectDrawSurface7_GetDC(p,a)                   (p)->lpVtbl->GetDC(p,a)
#define IDirectDrawSurface7_GetFlipStatus(p,a)           (p)->lpVtbl->GetFlipStatus(p,a)
#define IDirectDrawSurface7_GetOverlayPosition(p,a,b)    (p)->lpVtbl->GetOverlayPosition(p,a,b)
#define IDirectDrawSurface7_GetPalette(p,a)              (p)->lpVtbl->GetPalette(p,a)
#define IDirectDrawSurface7_GetPixelFormat(p,a)          (p)->lpVtbl->GetPixelFormat(p,a)
#define IDirectDrawSurface7_GetSurfaceDesc(p,a)          (p)->lpVtbl->GetSurfaceDesc(p,a)
#define IDirectDrawSurface7_Initialize(p,a,b)            (p)->lpVtbl->Initialize(p,a,b)
#define IDirectDrawSurface7_IsLost(p)                    (p)->lpVtbl->IsLost(p)
#define IDirectDrawSurface7_Lock(p,a,b,c,d)              (p)->lpVtbl->Lock(p,a,b,c,d)
#define IDirectDrawSurface7_ReleaseDC(p,a)               (p)->lpVtbl->ReleaseDC(p,a)
#define IDirectDrawSurface7_Restore(p)                   (p)->lpVtbl->Restore(p)
#define IDirectDrawSurface7_SetClipper(p,a)              (p)->lpVtbl->SetClipper(p,a)
#define IDirectDrawSurface7_SetColorKey(p,a,b)           (p)->lpVtbl->SetColorKey(p,a,b)
#define IDirectDrawSurface7_SetOverlayPosition(p,a,b)    (p)->lpVtbl->SetOverlayPosition(p,a,b)
#define IDirectDrawSurface7_SetPalette(p,a)              (p)->lpVtbl->SetPalette(p,a)
#define IDirectDrawSurface7_Unlock(p,b)                  (p)->lpVtbl->Unlock(p,b)
#define IDirectDrawSurface7_UpdateOverlay(p,a,b,c,d,e)   (p)->lpVtbl->UpdateOverlay(p,a,b,c,d,e)
#define IDirectDrawSurface7_UpdateOverlayDisplay(p,a)    (p)->lpVtbl->UpdateOverlayDisplay(p,a)
#define IDirectDrawSurface7_UpdateOverlayZOrder(p,a,b)   (p)->lpVtbl->UpdateOverlayZOrder(p,a,b)
#define IDirectDrawSurface7_GetDDInterface(p,a)          (p)->lpVtbl->GetDDInterface(p,a)
#define IDirectDrawSurface7_PageLock(p,a)                (p)->lpVtbl->PageLock(p,a)
#define IDirectDrawSurface7_PageUnlock(p,a)              (p)->lpVtbl->PageUnlock(p,a)
#define IDirectDrawSurface7_SetSurfaceDesc(p,a,b)        (p)->lpVtbl->SetSurfaceDesc(p,a,b)
#define IDirectDrawSurface7_SetPrivateData(p,a,b,c,d)    (p)->lpVtbl->SetPrivateData(p,a,b,c,d)
#define IDirectDrawSurface7_GetPrivateData(p,a,b,c)      (p)->lpVtbl->GetPrivateData(p,a,b,c)
#define IDirectDrawSurface7_FreePrivateData(p,a)         (p)->lpVtbl->FreePrivateData(p,a)
#define IDirectDrawSurface7_GetUniquenessValue(p, a)     (p)->lpVtbl->GetUniquenessValue(p, a)
#define IDirectDrawSurface7_ChangeUniquenessValue(p)     (p)->lpVtbl->ChangeUniquenessValue(p)
#define IDirectDrawSurface7_SetPriority(p,a)             (p)->lpVtbl->SetPriority(p,a)
#define IDirectDrawSurface7_GetPriority(p,a)             (p)->lpVtbl->GetPriority(p,a)
#define IDirectDrawSurface7_SetLOD(p,a)                  (p)->lpVtbl->SetLOD(p,a)
#define IDirectDrawSurface7_GetLOD(p,a)                  (p)->lpVtbl->GetLOD(p,a)
#else
#define IDirectDrawSurface7_QueryInterface(p,a,b)        (p)->QueryInterface(a,b)
#define IDirectDrawSurface7_AddRef(p)                    (p)->AddRef()
#define IDirectDrawSurface7_Release(p)                   (p)->Release()
#define IDirectDrawSurface7_AddAttachedSurface(p,a)      (p)->AddAttachedSurface(a)
#define IDirectDrawSurface7_AddOverlayDirtyRect(p,a)     (p)->AddOverlayDirtyRect(a)
#define IDirectDrawSurface7_Blt(p,a,b,c,d,e)             (p)->Blt(a,b,c,d,e)
#define IDirectDrawSurface7_BltBatch(p,a,b,c)            (p)->BltBatch(a,b,c)
#define IDirectDrawSurface7_BltFast(p,a,b,c,d,e)         (p)->BltFast(a,b,c,d,e)
#define IDirectDrawSurface7_DeleteAttachedSurface(p,a,b) (p)->DeleteAttachedSurface(a,b)
#define IDirectDrawSurface7_EnumAttachedSurfaces(p,a,b)  (p)->EnumAttachedSurfaces(a,b)
#define IDirectDrawSurface7_EnumOverlayZOrders(p,a,b,c)  (p)->EnumOverlayZOrders(a,b,c)
#define IDirectDrawSurface7_Flip(p,a,b)                  (p)->Flip(a,b)
#define IDirectDrawSurface7_GetAttachedSurface(p,a,b)    (p)->GetAttachedSurface(a,b)
#define IDirectDrawSurface7_GetBltStatus(p,a)            (p)->GetBltStatus(a)
#define IDirectDrawSurface7_GetCaps(p,b)                 (p)->GetCaps(b)
#define IDirectDrawSurface7_GetClipper(p,a)              (p)->GetClipper(a)
#define IDirectDrawSurface7_GetColorKey(p,a,b)           (p)->GetColorKey(a,b)
#define IDirectDrawSurface7_GetDC(p,a)                   (p)->GetDC(a)
#define IDirectDrawSurface7_GetFlipStatus(p,a)           (p)->GetFlipStatus(a)
#define IDirectDrawSurface7_GetOverlayPosition(p,a,b)    (p)->GetOverlayPosition(a,b)
#define IDirectDrawSurface7_GetPalette(p,a)              (p)->GetPalette(a)
#define IDirectDrawSurface7_GetPixelFormat(p,a)          (p)->GetPixelFormat(a)
#define IDirectDrawSurface7_GetSurfaceDesc(p,a)          (p)->GetSurfaceDesc(a)
#define IDirectDrawSurface7_Initialize(p,a,b)            (p)->Initialize(a,b)
#define IDirectDrawSurface7_IsLost(p)                    (p)->IsLost()
#define IDirectDrawSurface7_Lock(p,a,b,c,d)              (p)->Lock(a,b,c,d)
#define IDirectDrawSurface7_ReleaseDC(p,a)               (p)->ReleaseDC(a)
#define IDirectDrawSurface7_Restore(p)                   (p)->Restore()
#define IDirectDrawSurface7_SetClipper(p,a)              (p)->SetClipper(a)
#define IDirectDrawSurface7_SetColorKey(p,a,b)           (p)->SetColorKey(a,b)
#define IDirectDrawSurface7_SetOverlayPosition(p,a,b)    (p)->SetOverlayPosition(a,b)
#define IDirectDrawSurface7_SetPalette(p,a)              (p)->SetPalette(a)
#define IDirectDrawSurface7_Unlock(p,b)                  (p)->Unlock(b)
#define IDirectDrawSurface7_UpdateOverlay(p,a,b,c,d,e)   (p)->UpdateOverlay(a,b,c,d,e)
#define IDirectDrawSurface7_UpdateOverlayDisplay(p,a)    (p)->UpdateOverlayDisplay(a)
#define IDirectDrawSurface7_UpdateOverlayZOrder(p,a,b)   (p)->UpdateOverlayZOrder(a,b)
#define IDirectDrawSurface7_GetDDInterface(p,a)          (p)->GetDDInterface(a)
#define IDirectDrawSurface7_PageLock(p,a)                (p)->PageLock(a)
#define IDirectDrawSurface7_PageUnlock(p,a)              (p)->PageUnlock(a)
#define IDirectDrawSurface7_SetSurfaceDesc(p,a,b)        (p)->SetSurfaceDesc(a,b)
#define IDirectDrawSurface7_SetPrivateData(p,a,b,c,d)    (p)->SetPrivateData(a,b,c,d)
#define IDirectDrawSurface7_GetPrivateData(p,a,b,c)      (p)->GetPrivateData(a,b,c)
#define IDirectDrawSurface7_FreePrivateData(p,a)         (p)->FreePrivateData(a)
#define IDirectDrawSurface7_GetUniquenessValue(p, a)     (p)->GetUniquenessValue(a)
#define IDirectDrawSurface7_ChangeUniquenessValue(p)     (p)->ChangeUniquenessValue()
#define IDirectDrawSurface7_SetPriority(p,a)             (p)->SetPriority(a)
#define IDirectDrawSurface7_GetPriority(p,a)             (p)->GetPriority(a)
#define IDirectDrawSurface7_SetLOD(p,a)                  (p)->SetLOD(a)
#define IDirectDrawSurface7_GetLOD(p,a)                  (p)->GetLOD(a)
#endif


/*
 * IDirectDrawColorControl
 */
#if defined( _WIN32 ) && !defined( _NO_COM )
#undef INTERFACE
#define INTERFACE IDirectDrawColorControl
DECLARE_INTERFACE_( IDirectDrawColorControl, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDrawColorControl methods ***/
    STDMETHOD(GetColorControls)(THIS_ LPDDCOLORCONTROL) PURE;
    STDMETHOD(SetColorControls)(THIS_ LPDDCOLORCONTROL) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectDrawColorControl_QueryInterface(p, a, b)  (p)->lpVtbl->QueryInterface(p, a, b)
#define IDirectDrawColorControl_AddRef(p)                (p)->lpVtbl->AddRef(p)
#define IDirectDrawColorControl_Release(p)               (p)->lpVtbl->Release(p)
#define IDirectDrawColorControl_GetColorControls(p, a)   (p)->lpVtbl->GetColorControls(p, a)
#define IDirectDrawColorControl_SetColorControls(p, a)   (p)->lpVtbl->SetColorControls(p, a)
#else
#define IDirectDrawColorControl_QueryInterface(p, a, b)  (p)->QueryInterface(a, b)
#define IDirectDrawColorControl_AddRef(p)                (p)->AddRef()
#define IDirectDrawColorControl_Release(p)               (p)->Release()
#define IDirectDrawColorControl_GetColorControls(p, a)   (p)->GetColorControls(a)
#define IDirectDrawColorControl_SetColorControls(p, a)   (p)->SetColorControls(a)
#endif

#endif


/*
 * IDirectDrawGammaControl
 */
#if defined( _WIN32 ) && !defined( _NO_COM )
#undef INTERFACE
#define INTERFACE IDirectDrawGammaControl
DECLARE_INTERFACE_( IDirectDrawGammaControl, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDrawGammaControl methods ***/
    STDMETHOD(GetGammaRamp)(THIS_ DWORD, LPDDGAMMARAMP) PURE;
    STDMETHOD(SetGammaRamp)(THIS_ DWORD, LPDDGAMMARAMP) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectDrawGammaControl_QueryInterface(p, a, b)  (p)->lpVtbl->QueryInterface(p, a, b)
#define IDirectDrawGammaControl_AddRef(p)                (p)->lpVtbl->AddRef(p)
#define IDirectDrawGammaControl_Release(p)               (p)->lpVtbl->Release(p)
#define IDirectDrawGammaControl_GetGammaRamp(p, a, b)    (p)->lpVtbl->GetGammaRamp(p, a, b)
#define IDirectDrawGammaControl_SetGammaRamp(p, a, b)    (p)->lpVtbl->SetGammaRamp(p, a, b)
#else
#define IDirectDrawGammaControl_QueryInterface(p, a, b)  (p)->QueryInterface(a, b)
#define IDirectDrawGammaControl_AddRef(p)                (p)->AddRef()
#define IDirectDrawGammaControl_Release(p)               (p)->Release()
#define IDirectDrawGammaControl_GetGammaRamp(p, a, b)    (p)->GetGammaRamp(a, b)
#define IDirectDrawGammaControl_SetGammaRamp(p, a, b)    (p)->SetGammaRamp(a, b)
#endif

#endif



#endif


/*
 * DDSURFACEDESC
 */
typedef struct _DDSURFACEDESC
{
    DWORD               dwSize;                 // size of the DDSURFACEDESC structure
    DWORD               dwFlags;                // determines what fields are valid
    DWORD               dwHeight;               // height of surface to be created
    DWORD               dwWidth;                // width of input surface
    union
    {
        LONG            lPitch;                 // distance to start of next line (return value only)
        DWORD           dwLinearSize;           // Formless late-allocated optimized surface size
    } DUMMYUNIONNAMEN(1);
    DWORD               dwBackBufferCount;      // number of back buffers requested
    union
    {
        DWORD           dwMipMapCount;          // number of mip-map levels requested
        DWORD           dwZBufferBitDepth;      // depth of Z buffer requested
        DWORD           dwRefreshRate;          // refresh rate (used when display mode is described)
    } DUMMYUNIONNAMEN(2);
    DWORD               dwAlphaBitDepth;        // depth of alpha buffer requested
    DWORD               dwReserved;             // reserved
    LPVOID              lpSurface;              // pointer to the associated surface memory
    DDCOLORKEY          ddckCKDestOverlay;      // color key for destination overlay use
    DDCOLORKEY          ddckCKDestBlt;          // color key for destination blt use
    DDCOLORKEY          ddckCKSrcOverlay;       // color key for source overlay use
    DDCOLORKEY          ddckCKSrcBlt;           // color key for source blt use
    DDPIXELFORMAT       ddpfPixelFormat;        // pixel format description of the surface
    DDSCAPS             ddsCaps;                // direct draw surface capabilities
} DDSURFACEDESC;

/*
 * DDSURFACEDESC2
 */
typedef struct _DDSURFACEDESC2
{
    DWORD               dwSize;                 // size of the DDSURFACEDESC structure
    DWORD               dwFlags;                // determines what fields are valid
    DWORD               dwHeight;               // height of surface to be created
    DWORD               dwWidth;                // width of input surface
    union
    {
        LONG            lPitch;                 // distance to start of next line (return value only)
        DWORD           dwLinearSize;           // Formless late-allocated optimized surface size
    } DUMMYUNIONNAMEN(1);
    union
    {
        DWORD           dwBackBufferCount;      // number of back buffers requested
        DWORD           dwDepth;                // the depth if this is a volume texture 
    } DUMMYUNIONNAMEN(5);
    union
    {
        DWORD           dwMipMapCount;          // number of mip-map levels requestde
                                                // dwZBufferBitDepth removed, use ddpfPixelFormat one instead
        DWORD           dwRefreshRate;          // refresh rate (used when display mode is described)
        DWORD           dwSrcVBHandle;          // The source used in VB::Optimize
    } DUMMYUNIONNAMEN(2);
    DWORD               dwAlphaBitDepth;        // depth of alpha buffer requested
    DWORD               dwReserved;             // reserved
    LPVOID              lpSurface;              // pointer to the associated surface memory
    union
    {
        DDCOLORKEY      ddckCKDestOverlay;      // color key for destination overlay use
        DWORD           dwEmptyFaceColor;       // Physical color for empty cubemap faces
    } DUMMYUNIONNAMEN(3);
    DDCOLORKEY          ddckCKDestBlt;          // color key for destination blt use
    DDCOLORKEY          ddckCKSrcOverlay;       // color key for source overlay use
    DDCOLORKEY          ddckCKSrcBlt;           // color key for source blt use
    union
    {
        DDPIXELFORMAT   ddpfPixelFormat;        // pixel format description of the surface
        DWORD           dwFVF;                  // vertex format description of vertex buffers
    } DUMMYUNIONNAMEN(4);
    DDSCAPS2            ddsCaps;                // direct draw surface capabilities
    DWORD               dwTextureStage;         // stage in multitexture cascade
} DDSURFACEDESC2;

/*
 * ddsCaps field is valid.
 */
#define DDSD_CAPS               0x00000001l     // default

/*
 * dwHeight field is valid.
 */
#define DDSD_HEIGHT             0x00000002l

/*
 * dwWidth field is valid.
 */
#define DDSD_WIDTH              0x00000004l

/*
 * lPitch is valid.
 */
#define DDSD_PITCH              0x00000008l

/*
 * dwBackBufferCount is valid.
 */
#define DDSD_BACKBUFFERCOUNT    0x00000020l

/*
 * dwZBufferBitDepth is valid.  (shouldnt be used in DDSURFACEDESC2)
 */
#define DDSD_ZBUFFERBITDEPTH    0x00000040l

/*
 * dwAlphaBitDepth is valid.
 */
#define DDSD_ALPHABITDEPTH      0x00000080l


/*
 * lpSurface is valid.
 */
#define DDSD_LPSURFACE          0x00000800l

/*
 * ddpfPixelFormat is valid.
 */
#define DDSD_PIXELFORMAT        0x00001000l

/*
 * ddckCKDestOverlay is valid.
 */
#define DDSD_CKDESTOVERLAY      0x00002000l

/*
 * ddckCKDestBlt is valid.
 */
#define DDSD_CKDESTBLT          0x00004000l

/*
 * ddckCKSrcOverlay is valid.
 */
#define DDSD_CKSRCOVERLAY       0x00008000l

/*
 * ddckCKSrcBlt is valid.
 */
#define DDSD_CKSRCBLT           0x00010000l

/*
 * dwMipMapCount is valid.
 */
#define DDSD_MIPMAPCOUNT        0x00020000l

 /*
  * dwRefreshRate is valid
  */
#define DDSD_REFRESHRATE        0x00040000l

/*
 * dwLinearSize is valid
 */
#define DDSD_LINEARSIZE         0x00080000l

/*
 * dwTextureStage is valid
 */
#define DDSD_TEXTURESTAGE       0x00100000l
/*
 * dwFVF is valid
 */
#define DDSD_FVF                0x00200000l
/*
 * dwSrcVBHandle is valid
 */
#define DDSD_SRCVBHANDLE        0x00400000l

/*
 * dwDepth is valid
 */
#define DDSD_DEPTH              0x00800000l

/*
 * All input fields are valid.
 */
#define DDSD_ALL                0x00fff9eel

/*
 * DDOPTSURFACEDESC
 */
typedef struct _DDOPTSURFACEDESC
{
    DWORD       dwSize;             // size of the DDOPTSURFACEDESC structure
    DWORD       dwFlags;            // determines what fields are valid
    DDSCAPS2    ddSCaps;            // Common caps like: Memory type
    DDOSCAPS    ddOSCaps;           // Common caps like: Memory type
    GUID        guid;               // Compression technique GUID
    DWORD       dwCompressionRatio; // Compression ratio
} DDOPTSURFACEDESC;

/*
 * guid field is valid.
 */
#define DDOSD_GUID                  0x00000001l

/*
 * dwCompressionRatio field is valid.
 */
#define DDOSD_COMPRESSION_RATIO     0x00000002l

/*
 * ddSCaps field is valid.
 */
#define DDOSD_SCAPS                 0x00000004l

/*
 * ddOSCaps field is valid.
 */
#define DDOSD_OSCAPS                0x00000008l

/*
 * All input fields are valid.
 */
#define DDOSD_ALL                   0x0000000fl

/*
 * The surface's optimized pixelformat is compressed
 */
#define DDOSDCAPS_OPTCOMPRESSED                 0x00000001l

/*
 * The surface's optimized pixelformat is reordered
 */
#define DDOSDCAPS_OPTREORDERED                  0x00000002l

/*
 * The opt surface is a monolithic mipmap
 */
#define DDOSDCAPS_MONOLITHICMIPMAP              0x00000004l

/*
 * The valid Surf caps:
 * #define DDSCAPS_SYSTEMMEMORY                 0x00000800l
 * #define DDSCAPS_VIDEOMEMORY          0x00004000l
 * #define DDSCAPS_LOCALVIDMEM          0x10000000l
 * #define DDSCAPS_NONLOCALVIDMEM       0x20000000l
 */
#define DDOSDCAPS_VALIDSCAPS            0x30004800l

/*
 * The valid OptSurf caps
 */
#define DDOSDCAPS_VALIDOSCAPS           0x00000007l


/*
 * DDCOLORCONTROL
 */
typedef struct _DDCOLORCONTROL
{
    DWORD               dwSize;
    DWORD               dwFlags;
    LONG                lBrightness;
    LONG                lContrast;
    LONG                lHue;
    LONG                lSaturation;
    LONG                lSharpness;
    LONG                lGamma;
    LONG                lColorEnable;
    DWORD               dwReserved1;
} DDCOLORCONTROL;


/*
 * lBrightness field is valid.
 */
#define DDCOLOR_BRIGHTNESS              0x00000001l

/*
 * lContrast field is valid.
 */
#define DDCOLOR_CONTRAST                0x00000002l

/*
 * lHue field is valid.
 */
#define DDCOLOR_HUE                     0x00000004l

/*
 * lSaturation field is valid.
 */
#define DDCOLOR_SATURATION              0x00000008l

/*
 * lSharpness field is valid.
 */
#define DDCOLOR_SHARPNESS               0x00000010l

/*
 * lGamma field is valid.
 */
#define DDCOLOR_GAMMA                   0x00000020l

/*
 * lColorEnable field is valid.
 */
#define DDCOLOR_COLORENABLE             0x00000040l



/*============================================================================
 *
 * Direct Draw Capability Flags
 *
 * These flags are used to describe the capabilities of a given Surface.
 * All flags are bit flags.
 *
 *==========================================================================*/

/****************************************************************************
 *
 * DIRECTDRAWSURFACE CAPABILITY FLAGS
 *
 ****************************************************************************/

/*
 * This bit is reserved. It should not be specified.
 */
#define DDSCAPS_RESERVED1                       0x00000001l

/*
 * Indicates that this surface contains alpha-only information.
 * (To determine if a surface is RGBA/YUVA, the pixel format must be
 * interrogated.)
 */
#define DDSCAPS_ALPHA                           0x00000002l

/*
 * Indicates that this surface is a backbuffer.  It is generally
 * set by CreateSurface when the DDSCAPS_FLIP capability bit is set.
 * It indicates that this surface is THE back buffer of a surface
 * flipping structure.  DirectDraw supports N surfaces in a
 * surface flipping structure.  Only the surface that immediately
 * precedeces the DDSCAPS_FRONTBUFFER has this capability bit set.
 * The other surfaces are identified as back buffers by the presence
 * of the DDSCAPS_FLIP capability, their attachment order, and the
 * absence of the DDSCAPS_FRONTBUFFER and DDSCAPS_BACKBUFFER
 * capabilities.  The bit is sent to CreateSurface when a standalone
 * back buffer is being created.  This surface could be attached to
 * a front buffer and/or back buffers to form a flipping surface
 * structure after the CreateSurface call.  See AddAttachments for
 * a detailed description of the behaviors in this case.
 */
#define DDSCAPS_BACKBUFFER                      0x00000004l

/*
 * Indicates a complex surface structure is being described.  A
 * complex surface structure results in the creation of more than
 * one surface.  The additional surfaces are attached to the root
 * surface.  The complex structure can only be destroyed by
 * destroying the root.
 */
#define DDSCAPS_COMPLEX                         0x00000008l

/*
 * Indicates that this surface is a part of a surface flipping structure.
 * When it is passed to CreateSurface the DDSCAPS_FRONTBUFFER and
 * DDSCAP_BACKBUFFER bits are not set.  They are set by CreateSurface
 * on the resulting creations.  The dwBackBufferCount field in the
 * DDSURFACEDESC structure must be set to at least 1 in order for
 * the CreateSurface call to succeed.  The DDSCAPS_COMPLEX capability
 * must always be set with creating multiple surfaces through CreateSurface.
 */
#define DDSCAPS_FLIP                            0x00000010l

/*
 * Indicates that this surface is THE front buffer of a surface flipping
 * structure.  It is generally set by CreateSurface when the DDSCAPS_FLIP
 * capability bit is set.
 * If this capability is sent to CreateSurface then a standalonw front buffer
 * is created.  This surface will not have the DDSCAPS_FLIP capability.
 * It can be attached to other back buffers to form a flipping structure.
 * See AddAttachments for a detailed description of the behaviors in this
 * case.
 */
#define DDSCAPS_FRONTBUFFER                     0x00000020l

/*
 * Indicates that this surface is any offscreen surface that is not an overlay,
 * texture, zbuffer, front buffer, back buffer, or alpha surface.  It is used
 * to identify plain vanilla surfaces.
 */
#define DDSCAPS_OFFSCREENPLAIN                  0x00000040l

/*
 * Indicates that this surface is an overlay.  It may or may not be directly visible
 * depending on whether or not it is currently being overlayed onto the primary
 * surface.  DDSCAPS_VISIBLE can be used to determine whether or not it is being
 * overlayed at the moment.
 */
#define DDSCAPS_OVERLAY                         0x00000080l

/*
 * Indicates that unique DirectDrawPalette objects can be created and
 * attached to this surface.
 */
#define DDSCAPS_PALETTE                         0x00000100l

/*
 * Indicates that this surface is the primary surface.  The primary
 * surface represents what the user is seeing at the moment.
 */
#define DDSCAPS_PRIMARYSURFACE                  0x00000200l


/*
 * This flag used to be DDSCAPS_PRIMARYSURFACELEFT, which is now
 * obsolete.
 */
#define DDSCAPS_RESERVED3               0x00000400l
#define DDSCAPS_PRIMARYSURFACELEFT              0x00000000l

/*
 * Indicates that this surface memory was allocated in system memory
 */
#define DDSCAPS_SYSTEMMEMORY                    0x00000800l

/*
 * Indicates that this surface can be used as a 3D texture.  It does not
 * indicate whether or not the surface is being used for that purpose.
 */
#define DDSCAPS_TEXTURE                         0x00001000l

/*
 * Indicates that a surface may be a destination for 3D rendering.  This
 * bit must be set in order to query for a Direct3D Device Interface
 * from this surface.
 */
#define DDSCAPS_3DDEVICE                        0x00002000l

/*
 * Indicates that this surface exists in video memory.
 */
#define DDSCAPS_VIDEOMEMORY                     0x00004000l

/*
 * Indicates that changes made to this surface are immediately visible.
 * It is always set for the primary surface and is set for overlays while
 * they are being overlayed and texture maps while they are being textured.
 */
#define DDSCAPS_VISIBLE                         0x00008000l

/*
 * Indicates that only writes are permitted to the surface.  Read accesses
 * from the surface may or may not generate a protection fault, but the
 * results of a read from this surface will not be meaningful.  READ ONLY.
 */
#define DDSCAPS_WRITEONLY                       0x00010000l

/*
 * Indicates that this surface is a z buffer. A z buffer does not contain
 * displayable information.  Instead it contains bit depth information that is
 * used to determine which pixels are visible and which are obscured.
 */
#define DDSCAPS_ZBUFFER                         0x00020000l

/*
 * Indicates surface will have a DC associated long term
 */
#define DDSCAPS_OWNDC                           0x00040000l

/*
 * Indicates surface should be able to receive live video
 */
#define DDSCAPS_LIVEVIDEO                       0x00080000l

/*
 * Indicates surface should be able to have a stream decompressed
 * to it by the hardware.
 */
#define DDSCAPS_HWCODEC                         0x00100000l

/*
 * Surface is a ModeX surface.
 *
 */
#define DDSCAPS_MODEX                           0x00200000l

/*
 * Indicates surface is one level of a mip-map. This surface will
 * be attached to other DDSCAPS_MIPMAP surfaces to form the mip-map.
 * This can be done explicitly, by creating a number of surfaces and
 * attaching them with AddAttachedSurface or by implicitly by CreateSurface.
 * If this bit is set then DDSCAPS_TEXTURE must also be set.
 */
#define DDSCAPS_MIPMAP                          0x00400000l

/*
 * This bit is reserved. It should not be specified.
 */
#define DDSCAPS_RESERVED2                       0x00800000l


/*
 * Indicates that memory for the surface is not allocated until the surface
 * is loaded (via the Direct3D texture Load() function).
 */
#define DDSCAPS_ALLOCONLOAD                     0x04000000l

/*
 * Indicates that the surface will recieve data from a video port.
 */
#define DDSCAPS_VIDEOPORT                       0x08000000l

/*
 * Indicates that a video memory surface is resident in true, local video
 * memory rather than non-local video memory. If this flag is specified then
 * so must DDSCAPS_VIDEOMEMORY. This flag is mutually exclusive with
 * DDSCAPS_NONLOCALVIDMEM.
 */
#define DDSCAPS_LOCALVIDMEM                     0x10000000l

/*
 * Indicates that a video memory surface is resident in non-local video
 * memory rather than true, local video memory. If this flag is specified
 * then so must DDSCAPS_VIDEOMEMORY. This flag is mutually exclusive with
 * DDSCAPS_LOCALVIDMEM.
 */
#define DDSCAPS_NONLOCALVIDMEM                  0x20000000l

/*
 * Indicates that this surface is a standard VGA mode surface, and not a
 * ModeX surface. (This flag will never be set in combination with the
 * DDSCAPS_MODEX flag).
 */
#define DDSCAPS_STANDARDVGAMODE                 0x40000000l

/*
 * Indicates that this surface will be an optimized surface. This flag is
 * currently only valid in conjunction with the DDSCAPS_TEXTURE flag. The surface
 * will be created without any underlying video memory until loaded.
 */
#define DDSCAPS_OPTIMIZED                       0x80000000l



/*
 * This bit is reserved
 */
#define DDSCAPS2_RESERVED4                      0x00000002L
#define DDSCAPS2_HARDWAREDEINTERLACE            0x00000000L

/*
 * Indicates to the driver that this surface will be locked very frequently
 * (for procedural textures, dynamic lightmaps, etc). Surfaces with this cap
 * set must also have DDSCAPS_TEXTURE. This cap cannot be used with
 * DDSCAPS2_HINTSTATIC and DDSCAPS2_OPAQUE.
 */
#define DDSCAPS2_HINTDYNAMIC                    0x00000004L

/*
 * Indicates to the driver that this surface can be re-ordered/retiled on
 * load. This operation will not change the size of the texture. It is
 * relatively fast and symmetrical, since the application may lock these
 * bits (although it will take a performance hit when doing so). Surfaces
 * with this cap set must also have DDSCAPS_TEXTURE. This cap cannot be
 * used with DDSCAPS2_HINTDYNAMIC and DDSCAPS2_OPAQUE.
 */
#define DDSCAPS2_HINTSTATIC                     0x00000008L

/*
 * Indicates that the client would like this texture surface to be managed by the
 * DirectDraw/Direct3D runtime. Surfaces with this cap set must also have
 * DDSCAPS_TEXTURE set.
 */
#define DDSCAPS2_TEXTUREMANAGE                  0x00000010L

/*
 * These bits are reserved for internal use */
#define DDSCAPS2_RESERVED1                      0x00000020L
#define DDSCAPS2_RESERVED2                      0x00000040L

/*
 * Indicates to the driver that this surface will never be locked again.
 * The driver is free to optimize this surface via retiling and actual compression.
 * All calls to Lock() or Blts from this surface will fail. Surfaces with this
 * cap set must also have DDSCAPS_TEXTURE. This cap cannot be used with
 * DDSCAPS2_HINTDYNAMIC and DDSCAPS2_HINTSTATIC.
 */
#define DDSCAPS2_OPAQUE                         0x00000080L

/*
 * Applications should set this bit at CreateSurface time to indicate that they
 * intend to use antialiasing. Only valid if DDSCAPS_3DDEVICE is also set.
 */
#define DDSCAPS2_HINTANTIALIASING               0x00000100L


/*
 * This flag is used at CreateSurface time to indicate that this set of
 * surfaces is a cubic environment map
 */
#define DDSCAPS2_CUBEMAP                        0x00000200L

/*
 * These flags preform two functions:
 * - At CreateSurface time, they define which of the six cube faces are
 *   required by the application.
 * - After creation, each face in the cubemap will have exactly one of these
 *   bits set.
 */
#define DDSCAPS2_CUBEMAP_POSITIVEX              0x00000400L
#define DDSCAPS2_CUBEMAP_NEGATIVEX              0x00000800L
#define DDSCAPS2_CUBEMAP_POSITIVEY              0x00001000L
#define DDSCAPS2_CUBEMAP_NEGATIVEY              0x00002000L
#define DDSCAPS2_CUBEMAP_POSITIVEZ              0x00004000L
#define DDSCAPS2_CUBEMAP_NEGATIVEZ              0x00008000L

/*
 * This macro may be used to specify all faces of a cube map at CreateSurface time
 */
#define DDSCAPS2_CUBEMAP_ALLFACES ( DDSCAPS2_CUBEMAP_POSITIVEX |\
                                    DDSCAPS2_CUBEMAP_NEGATIVEX |\
                                    DDSCAPS2_CUBEMAP_POSITIVEY |\
                                    DDSCAPS2_CUBEMAP_NEGATIVEY |\
                                    DDSCAPS2_CUBEMAP_POSITIVEZ |\
                                    DDSCAPS2_CUBEMAP_NEGATIVEZ )


/*
 * This flag is an additional flag which is present on mipmap sublevels from DX7 onwards
 * It enables easier use of GetAttachedSurface rather than EnumAttachedSurfaces for surface
 * constructs such as Cube Maps, wherein there are more than one mipmap surface attached
 * to the root surface.
 * This caps bit is ignored by CreateSurface
 */
#define DDSCAPS2_MIPMAPSUBLEVEL                 0x00010000L

/* This flag indicates that the texture should be managed by D3D only */
#define DDSCAPS2_D3DTEXTUREMANAGE               0x00020000L

/* This flag indicates that the managed surface can be safely lost */
#define DDSCAPS2_DONOTPERSIST                   0x00040000L

/* indicates that this surface is part of a stereo flipping chain */
#define DDSCAPS2_STEREOSURFACELEFT              0x00080000L


/*
 * Indicates that the surface is a volume.
 * Can be combined with DDSCAPS_MIPMAP to indicate a multi-level volume
 */
#define DDSCAPS2_VOLUME                         0x00200000L

/*
 * Indicates that the surface may be locked multiple times by the application.
 * This cap cannot be used with DDSCAPS2_OPAQUE.
 */
#define DDSCAPS2_NOTUSERLOCKABLE                0x00400000L

/*
 * Indicates that the vertex buffer data can be used to render points and
 * point sprites.
 */
#define DDSCAPS2_POINTS                         0x00800000L

/*
 * Indicates that the vertex buffer data can be used to render rt pactches.
 */
#define DDSCAPS2_RTPATCHES                      0x01000000L

/*
 * Indicates that the vertex buffer data can be used to render n patches.
 */
#define DDSCAPS2_NPATCHES                       0x02000000L

/*
 * This bit is reserved for internal use 
 */
#define DDSCAPS2_RESERVED3                      0x04000000L


/*
 * Indicates that the contents of the backbuffer do not have to be preserved
 * the contents of the backbuffer after they are presented.
 */
#define DDSCAPS2_DISCARDBACKBUFFER              0x10000000L

/*
 * This is a mask that indicates the set of bits that may be set
 * at createsurface time to indicate number of samples per pixel
 * when multisampling
 */
#define DDSCAPS3_MULTISAMPLE_MASK               0x0000001FL


 /****************************************************************************
 *
 * DIRECTDRAW DRIVER CAPABILITY FLAGS
 *
 ****************************************************************************/

/*
 * Display hardware has 3D acceleration.
 */
#define DDCAPS_3D                       0x00000001l

/*
 * Indicates that DirectDraw will support only dest rectangles that are aligned
 * on DIRECTDRAWCAPS.dwAlignBoundaryDest boundaries of the surface, respectively.
 * READ ONLY.
 */
#define DDCAPS_ALIGNBOUNDARYDEST        0x00000002l

/*
 * Indicates that DirectDraw will support only source rectangles  whose sizes in
 * BYTEs are DIRECTDRAWCAPS.dwAlignSizeDest multiples, respectively.  READ ONLY.
 */
#define DDCAPS_ALIGNSIZEDEST            0x00000004l
/*
 * Indicates that DirectDraw will support only source rectangles that are aligned
 * on DIRECTDRAWCAPS.dwAlignBoundarySrc boundaries of the surface, respectively.
 * READ ONLY.
 */
#define DDCAPS_ALIGNBOUNDARYSRC         0x00000008l

/*
 * Indicates that DirectDraw will support only source rectangles  whose sizes in
 * BYTEs are DIRECTDRAWCAPS.dwAlignSizeSrc multiples, respectively.  READ ONLY.
 */
#define DDCAPS_ALIGNSIZESRC             0x00000010l

/*
 * Indicates that DirectDraw will create video memory surfaces that have a stride
 * alignment equal to DIRECTDRAWCAPS.dwAlignStride.  READ ONLY.
 */
#define DDCAPS_ALIGNSTRIDE              0x00000020l

/*
 * Display hardware is capable of blt operations.
 */
#define DDCAPS_BLT                      0x00000040l

/*
 * Display hardware is capable of asynchronous blt operations.
 */
#define DDCAPS_BLTQUEUE                 0x00000080l

/*
 * Display hardware is capable of color space conversions during the blt operation.
 */
#define DDCAPS_BLTFOURCC                0x00000100l

/*
 * Display hardware is capable of stretching during blt operations.
 */
#define DDCAPS_BLTSTRETCH               0x00000200l

/*
 * Display hardware is shared with GDI.
 */
#define DDCAPS_GDI                      0x00000400l

/*
 * Display hardware can overlay.
 */
#define DDCAPS_OVERLAY                  0x00000800l

/*
 * Set if display hardware supports overlays but can not clip them.
 */
#define DDCAPS_OVERLAYCANTCLIP          0x00001000l

/*
 * Indicates that overlay hardware is capable of color space conversions during
 * the overlay operation.
 */
#define DDCAPS_OVERLAYFOURCC            0x00002000l

/*
 * Indicates that stretching can be done by the overlay hardware.
 */
#define DDCAPS_OVERLAYSTRETCH           0x00004000l

/*
 * Indicates that unique DirectDrawPalettes can be created for DirectDrawSurfaces
 * other than the primary surface.
 */
#define DDCAPS_PALETTE                  0x00008000l

/*
 * Indicates that palette changes can be syncd with the veritcal refresh.
 */
#define DDCAPS_PALETTEVSYNC             0x00010000l

/*
 * Display hardware can return the current scan line.
 */
#define DDCAPS_READSCANLINE             0x00020000l


/*
 * This flag used to bo DDCAPS_STEREOVIEW, which is now obsolete
 */
#define DDCAPS_RESERVED1                0x00040000l

/*
 * Display hardware is capable of generating a vertical blank interrupt.
 */
#define DDCAPS_VBI                      0x00080000l

/*
 * Supports the use of z buffers with blt operations.
 */
#define DDCAPS_ZBLTS                    0x00100000l

/*
 * Supports Z Ordering of overlays.
 */
#define DDCAPS_ZOVERLAYS                0x00200000l

/*
 * Supports color key
 */
#define DDCAPS_COLORKEY                 0x00400000l

/*
 * Supports alpha surfaces
 */
#define DDCAPS_ALPHA                    0x00800000l

/*
 * colorkey is hardware assisted(DDCAPS_COLORKEY will also be set)
 */
#define DDCAPS_COLORKEYHWASSIST         0x01000000l

/*
 * no hardware support at all
 */
#define DDCAPS_NOHARDWARE               0x02000000l

/*
 * Display hardware is capable of color fill with bltter
 */
#define DDCAPS_BLTCOLORFILL             0x04000000l

/*
 * Display hardware is bank switched, and potentially very slow at
 * random access to VRAM.
 */
#define DDCAPS_BANKSWITCHED             0x08000000l

/*
 * Display hardware is capable of depth filling Z-buffers with bltter
 */
#define DDCAPS_BLTDEPTHFILL             0x10000000l

/*
 * Display hardware is capable of clipping while bltting.
 */
#define DDCAPS_CANCLIP                  0x20000000l

/*
 * Display hardware is capable of clipping while stretch bltting.
 */
#define DDCAPS_CANCLIPSTRETCHED         0x40000000l

/*
 * Display hardware is capable of bltting to or from system memory
 */
#define DDCAPS_CANBLTSYSMEM             0x80000000l


 /****************************************************************************
 *
 * MORE DIRECTDRAW DRIVER CAPABILITY FLAGS (dwCaps2)
 *
 ****************************************************************************/

/*
 * Display hardware is certified
 */
#define DDCAPS2_CERTIFIED              0x00000001l

/*
 * Driver cannot interleave 2D operations (lock and blt) to surfaces with
 * Direct3D rendering operations between calls to BeginScene() and EndScene()
 */
#define DDCAPS2_NO2DDURING3DSCENE       0x00000002l

/*
 * Display hardware contains a video port
 */
#define DDCAPS2_VIDEOPORT               0x00000004l

/*
 * The overlay can be automatically flipped according to the video port
 * VSYNCs, providing automatic doubled buffered display of video port
 * data using an overlay
 */
#define DDCAPS2_AUTOFLIPOVERLAY         0x00000008l

/*
 * Overlay can display each field of interlaced data individually while
 * it is interleaved in memory without causing jittery artifacts.
 */
#define DDCAPS2_CANBOBINTERLEAVED       0x00000010l

/*
 * Overlay can display each field of interlaced data individually while
 * it is not interleaved in memory without causing jittery artifacts.
 */
#define DDCAPS2_CANBOBNONINTERLEAVED    0x00000020l

/*
 * The overlay surface contains color controls (brightness, sharpness, etc.)
 */
#define DDCAPS2_COLORCONTROLOVERLAY     0x00000040l

/*
 * The primary surface contains color controls (gamma, etc.)
 */
#define DDCAPS2_COLORCONTROLPRIMARY     0x00000080l

/*
 * RGBZ -> RGB supported for 16:16 RGB:Z
 */
#define DDCAPS2_CANDROPZ16BIT           0x00000100l

/*
 * Driver supports non-local video memory.
 */
#define DDCAPS2_NONLOCALVIDMEM          0x00000200l

/*
 * Dirver supports non-local video memory but has different capabilities for
 * non-local video memory surfaces. If this bit is set then so must
 * DDCAPS2_NONLOCALVIDMEM.
 */
#define DDCAPS2_NONLOCALVIDMEMCAPS      0x00000400l

/*
 * Driver neither requires nor prefers surfaces to be pagelocked when performing
 * blts involving system memory surfaces
 */
#define DDCAPS2_NOPAGELOCKREQUIRED      0x00000800l

/*
 * Driver can create surfaces which are wider than the primary surface
 */
#define DDCAPS2_WIDESURFACES            0x00001000l

/*
 * Driver supports bob without using a video port by handling the
 * DDFLIP_ODD and DDFLIP_EVEN flags specified in Flip.
 */
#define DDCAPS2_CANFLIPODDEVEN          0x00002000l

/*
 * Driver supports bob using hardware
 */
#define DDCAPS2_CANBOBHARDWARE          0x00004000l

/*
 * Driver supports bltting any FOURCC surface to another surface of the same FOURCC
 */
#define DDCAPS2_COPYFOURCC              0x00008000l


/*
 * Driver supports loadable gamma ramps for the primary surface
 */
#define DDCAPS2_PRIMARYGAMMA            0x00020000l

/*
 * Driver can render in windowed mode.
 */
#define DDCAPS2_CANRENDERWINDOWED       0x00080000l

/*
 * A calibrator is available to adjust the gamma ramp according to the
 * physical display properties so that the result will be identical on
 * all calibrated systems.
 */
#define DDCAPS2_CANCALIBRATEGAMMA       0x00100000l

/*
 * Indicates that the driver will respond to DDFLIP_INTERVALn flags
 */
#define DDCAPS2_FLIPINTERVAL            0x00200000l

/*
 * Indicates that the driver will respond to DDFLIP_NOVSYNC
 */
#define DDCAPS2_FLIPNOVSYNC             0x00400000l

/*
 * Driver supports management of video memory, if this flag is ON,
 * driver manages the texture if requested with DDSCAPS2_TEXTUREMANAGE on
 * DirectX manages the texture if this flag is OFF and surface has DDSCAPS2_TEXTUREMANAGE on
 */
#define DDCAPS2_CANMANAGETEXTURE        0x00800000l

/*
 * The Direct3D texture manager uses this cap to decide whether to put managed
 * surfaces in non-local video memory. If the cap is set, the texture manager will
 * put managed surfaces in non-local vidmem. Drivers that cannot texture from
 * local vidmem SHOULD NOT set this cap.
 */
#define DDCAPS2_TEXMANINNONLOCALVIDMEM  0x01000000l

/*
 * Indicates that the driver supports DX7 type of stereo in at least one mode (which may
 * not necessarily be the current mode). Applications should use IDirectDraw7 (or higher)
 * ::EnumDisplayModes and check the DDSURFACEDESC.ddsCaps.dwCaps2 field for the presence of
 * DDSCAPS2_STEREOSURFACELEFT to check if a particular mode supports stereo. The application
 * can also use IDirectDraw7(or higher)::GetDisplayMode to check the current mode.
 */
#define DDCAPS2_STEREO                  0x02000000L

/*
 * This caps bit is intended for internal DirectDraw use.
 * -It is only valid if DDCAPS2_NONLOCALVIDMEMCAPS is set.
 * -If this bit is set, then DDCAPS_CANBLTSYSMEM MUST be set by the driver (and
 *  all the assoicated system memory blt caps must be correct).
 * -It implies that the system->video blt caps in DDCAPS also apply to system to
 *  nonlocal blts. I.e. the dwSVBCaps, dwSVBCKeyCaps, dwSVBFXCaps and dwSVBRops
 *  members of DDCAPS (DDCORECAPS) are filled in correctly.
 * -Any blt from system to nonlocal memory that matches these caps bits will
 *  be passed to the driver.
 *
 * NOTE: This is intended to enable the driver itself to do efficient reordering
 * of textures. This is NOT meant to imply that hardware can write into AGP memory.
 * This operation is not currently supported.
 */
#define DDCAPS2_SYSTONONLOCAL_AS_SYSTOLOCAL   0x04000000L

/*
 * Indicates that the driver can support PUREHAL.
 */
#define DDCAPS2_PUREHAL                       0x08000000L


/****************************************************************************
 *
 * DIRECTDRAW FX ALPHA CAPABILITY FLAGS
 *
 ****************************************************************************/

/*
 * Supports alpha blending around the edge of a source color keyed surface.
 * For Blt.
 */
#define DDFXALPHACAPS_BLTALPHAEDGEBLEND         0x00000001l

/*
 * Supports alpha information in the pixel format.  The bit depth of alpha
 * information in the pixel format can be 1,2,4, or 8.  The alpha value becomes
 * more opaque as the alpha value increases.  (0 is transparent.)
 * For Blt.
 */
#define DDFXALPHACAPS_BLTALPHAPIXELS            0x00000002l

/*
 * Supports alpha information in the pixel format.  The bit depth of alpha
 * information in the pixel format can be 1,2,4, or 8.  The alpha value
 * becomes more transparent as the alpha value increases.  (0 is opaque.)
 * This flag can only be set if DDCAPS_ALPHA is set.
 * For Blt.
 */
#define DDFXALPHACAPS_BLTALPHAPIXELSNEG         0x00000004l

/*
 * Supports alpha only surfaces.  The bit depth of an alpha only surface can be
 * 1,2,4, or 8.  The alpha value becomes more opaque as the alpha value increases.
 * (0 is transparent.)
 * For Blt.
 */
#define DDFXALPHACAPS_BLTALPHASURFACES          0x00000008l

/*
 * The depth of the alpha channel data can range can be 1,2,4, or 8.
 * The NEG suffix indicates that this alpha channel becomes more transparent
 * as the alpha value increases. (0 is opaque.)  This flag can only be set if
 * DDCAPS_ALPHA is set.
 * For Blt.
 */
#define DDFXALPHACAPS_BLTALPHASURFACESNEG       0x00000010l

/*
 * Supports alpha blending around the edge of a source color keyed surface.
 * For Overlays.
 */
#define DDFXALPHACAPS_OVERLAYALPHAEDGEBLEND     0x00000020l

/*
 * Supports alpha information in the pixel format.  The bit depth of alpha
 * information in the pixel format can be 1,2,4, or 8.  The alpha value becomes
 * more opaque as the alpha value increases.  (0 is transparent.)
 * For Overlays.
 */
#define DDFXALPHACAPS_OVERLAYALPHAPIXELS        0x00000040l

/*
 * Supports alpha information in the pixel format.  The bit depth of alpha
 * information in the pixel format can be 1,2,4, or 8.  The alpha value
 * becomes more transparent as the alpha value increases.  (0 is opaque.)
 * This flag can only be set if DDCAPS_ALPHA is set.
 * For Overlays.
 */
#define DDFXALPHACAPS_OVERLAYALPHAPIXELSNEG     0x00000080l

/*
 * Supports alpha only surfaces.  The bit depth of an alpha only surface can be
 * 1,2,4, or 8.  The alpha value becomes more opaque as the alpha value increases.
 * (0 is transparent.)
 * For Overlays.
 */
#define DDFXALPHACAPS_OVERLAYALPHASURFACES      0x00000100l

/*
 * The depth of the alpha channel data can range can be 1,2,4, or 8.
 * The NEG suffix indicates that this alpha channel becomes more transparent
 * as the alpha value increases. (0 is opaque.)  This flag can only be set if
 * DDCAPS_ALPHA is set.
 * For Overlays.
 */
#define DDFXALPHACAPS_OVERLAYALPHASURFACESNEG   0x00000200l

#if DIRECTDRAW_VERSION < 0x0600
#endif  //DIRECTDRAW_VERSION


/****************************************************************************
 *
 * DIRECTDRAW FX CAPABILITY FLAGS
 *
 ****************************************************************************/

/*
 * Uses arithmetic operations to stretch and shrink surfaces during blt
 * rather than pixel doubling techniques.  Along the Y axis.
 */
#define DDFXCAPS_BLTARITHSTRETCHY       0x00000020l

/*
 * Uses arithmetic operations to stretch during blt
 * rather than pixel doubling techniques.  Along the Y axis. Only
 * works for x1, x2, etc.
 */
#define DDFXCAPS_BLTARITHSTRETCHYN      0x00000010l

/*
 * Supports mirroring left to right in blt.
 */
#define DDFXCAPS_BLTMIRRORLEFTRIGHT     0x00000040l

/*
 * Supports mirroring top to bottom in blt.
 */
#define DDFXCAPS_BLTMIRRORUPDOWN        0x00000080l

/*
 * Supports arbitrary rotation for blts.
 */
#define DDFXCAPS_BLTROTATION            0x00000100l

/*
 * Supports 90 degree rotations for blts.
 */
#define DDFXCAPS_BLTROTATION90          0x00000200l

/*
 * DirectDraw supports arbitrary shrinking of a surface along the
 * x axis (horizontal direction) for blts.
 */
#define DDFXCAPS_BLTSHRINKX             0x00000400l

/*
 * DirectDraw supports integer shrinking (1x,2x,) of a surface
 * along the x axis (horizontal direction) for blts.
 */
#define DDFXCAPS_BLTSHRINKXN            0x00000800l

/*
 * DirectDraw supports arbitrary shrinking of a surface along the
 * y axis (horizontal direction) for blts.
 */
#define DDFXCAPS_BLTSHRINKY             0x00001000l

/*
 * DirectDraw supports integer shrinking (1x,2x,) of a surface
 * along the y axis (vertical direction) for blts.
 */
#define DDFXCAPS_BLTSHRINKYN            0x00002000l

/*
 * DirectDraw supports arbitrary stretching of a surface along the
 * x axis (horizontal direction) for blts.
 */
#define DDFXCAPS_BLTSTRETCHX            0x00004000l

/*
 * DirectDraw supports integer stretching (1x,2x,) of a surface
 * along the x axis (horizontal direction) for blts.
 */
#define DDFXCAPS_BLTSTRETCHXN           0x00008000l

/*
 * DirectDraw supports arbitrary stretching of a surface along the
 * y axis (horizontal direction) for blts.
 */
#define DDFXCAPS_BLTSTRETCHY            0x00010000l

/*
 * DirectDraw supports integer stretching (1x,2x,) of a surface
 * along the y axis (vertical direction) for blts.
 */
#define DDFXCAPS_BLTSTRETCHYN           0x00020000l

/*
 * Uses arithmetic operations to stretch and shrink surfaces during
 * overlay rather than pixel doubling techniques.  Along the Y axis
 * for overlays.
 */
#define DDFXCAPS_OVERLAYARITHSTRETCHY   0x00040000l

/*
 * Uses arithmetic operations to stretch surfaces during
 * overlay rather than pixel doubling techniques.  Along the Y axis
 * for overlays. Only works for x1, x2, etc.
 */
#define DDFXCAPS_OVERLAYARITHSTRETCHYN  0x00000008l

/*
 * DirectDraw supports arbitrary shrinking of a surface along the
 * x axis (horizontal direction) for overlays.
 */
#define DDFXCAPS_OVERLAYSHRINKX         0x00080000l

/*
 * DirectDraw supports integer shrinking (1x,2x,) of a surface
 * along the x axis (horizontal direction) for overlays.
 */
#define DDFXCAPS_OVERLAYSHRINKXN        0x00100000l

/*
 * DirectDraw supports arbitrary shrinking of a surface along the
 * y axis (horizontal direction) for overlays.
 */
#define DDFXCAPS_OVERLAYSHRINKY         0x00200000l

/*
 * DirectDraw supports integer shrinking (1x,2x,) of a surface
 * along the y axis (vertical direction) for overlays.
 */
#define DDFXCAPS_OVERLAYSHRINKYN        0x00400000l

/*
 * DirectDraw supports arbitrary stretching of a surface along the
 * x axis (horizontal direction) for overlays.
 */
#define DDFXCAPS_OVERLAYSTRETCHX        0x00800000l

/*
 * DirectDraw supports integer stretching (1x,2x,) of a surface
 * along the x axis (horizontal direction) for overlays.
 */
#define DDFXCAPS_OVERLAYSTRETCHXN       0x01000000l

/*
 * DirectDraw supports arbitrary stretching of a surface along the
 * y axis (horizontal direction) for overlays.
 */
#define DDFXCAPS_OVERLAYSTRETCHY        0x02000000l

/*
 * DirectDraw supports integer stretching (1x,2x,) of a surface
 * along the y axis (vertical direction) for overlays.
 */
#define DDFXCAPS_OVERLAYSTRETCHYN       0x04000000l

/*
 * DirectDraw supports mirroring of overlays across the vertical axis
 */
#define DDFXCAPS_OVERLAYMIRRORLEFTRIGHT 0x08000000l

/*
 * DirectDraw supports mirroring of overlays across the horizontal axis
 */
#define DDFXCAPS_OVERLAYMIRRORUPDOWN    0x10000000l

/*
 * DirectDraw supports deinterlacing of overlay surfaces
 */
#define DDFXCAPS_OVERLAYDEINTERLACE		0x20000000l

/*
 * Driver can do alpha blending for blits.
 */
#define DDFXCAPS_BLTALPHA               0x00000001l


/*
 * Driver can do surface-reconstruction filtering for warped blits.
 */
#define DDFXCAPS_BLTFILTER              DDFXCAPS_BLTARITHSTRETCHY

/*
 * Driver can do alpha blending for overlays.
 */
#define DDFXCAPS_OVERLAYALPHA           0x00000004l


/*
 * Driver can do surface-reconstruction filtering for warped overlays.
 */
#define DDFXCAPS_OVERLAYFILTER          DDFXCAPS_OVERLAYARITHSTRETCHY

/****************************************************************************
 *
 * DIRECTDRAW STEREO VIEW CAPABILITIES
 *
 ****************************************************************************/

/*
 * This flag used to be DDSVCAPS_ENIGMA, which is now obsolete
 */

#define DDSVCAPS_RESERVED1              0x00000001l

/*
 * This flag used to be DDSVCAPS_FLICKER, which is now obsolete
 */
#define DDSVCAPS_RESERVED2              0x00000002l

/*
 * This flag used to be DDSVCAPS_REDBLUE, which is now obsolete
 */
#define DDSVCAPS_RESERVED3              0x00000004l

/*
 * This flag used to be DDSVCAPS_SPLIT, which is now obsolete
 */
#define DDSVCAPS_RESERVED4              0x00000008l

/*
 * The stereo view is accomplished with switching technology
 */

#define DDSVCAPS_STEREOSEQUENTIAL       0x00000010L




/****************************************************************************
 *
 * DIRECTDRAWPALETTE CAPABILITIES
 *
 ****************************************************************************/

/*
 * Index is 4 bits.  There are sixteen color entries in the palette table.
 */
#define DDPCAPS_4BIT                    0x00000001l

/*
 * Index is onto a 8 bit color index.  This field is only valid with the
 * DDPCAPS_1BIT, DDPCAPS_2BIT or DDPCAPS_4BIT capability and the target
 * surface is in 8bpp. Each color entry is one byte long and is an index
 * into destination surface's 8bpp palette.
 */
#define DDPCAPS_8BITENTRIES             0x00000002l

/*
 * Index is 8 bits.  There are 256 color entries in the palette table.
 */
#define DDPCAPS_8BIT                    0x00000004l

/*
 * Indicates that this DIRECTDRAWPALETTE should use the palette color array
 * passed into the lpDDColorArray parameter to initialize the DIRECTDRAWPALETTE
 * object.
 * This flag is obsolete. DirectDraw always initializes the color array from
 * the lpDDColorArray parameter. The definition remains for source-level
 * compatibility.
 */
#define DDPCAPS_INITIALIZE              0x00000000l

/*
 * This palette is the one attached to the primary surface.  Changing this
 * table has immediate effect on the display unless DDPSETPAL_VSYNC is specified
 * and supported.
 */
#define DDPCAPS_PRIMARYSURFACE          0x00000010l

/*
 * This palette is the one attached to the primary surface left.  Changing
 * this table has immediate effect on the display for the left eye unless
 * DDPSETPAL_VSYNC is specified and supported.
 */
#define DDPCAPS_PRIMARYSURFACELEFT      0x00000020l

/*
 * This palette can have all 256 entries defined
 */
#define DDPCAPS_ALLOW256                0x00000040l

/*
 * This palette can have modifications to it synced with the monitors
 * refresh rate.
 */
#define DDPCAPS_VSYNC                   0x00000080l

/*
 * Index is 1 bit.  There are two color entries in the palette table.
 */
#define DDPCAPS_1BIT                    0x00000100l

/*
 * Index is 2 bit.  There are four color entries in the palette table.
 */
#define DDPCAPS_2BIT                    0x00000200l

/*
 * The peFlags member of PALETTEENTRY denotes an 8 bit alpha value
 */
#define DDPCAPS_ALPHA                   0x00000400l


/****************************************************************************
 *
 * DIRECTDRAWPALETTE SETENTRY CONSTANTS
 *
 ****************************************************************************/


/****************************************************************************
 *
 * DIRECTDRAWPALETTE GETENTRY CONSTANTS
 *
 ****************************************************************************/

/* 0 is the only legal value */

/****************************************************************************
 *
 * DIRECTDRAWSURFACE SETPRIVATEDATA CONSTANTS
 *
 ****************************************************************************/

/*
 * The passed pointer is an IUnknown ptr. The cbData argument to SetPrivateData
 * must be set to sizeof(IUnknown*). DirectDraw will call AddRef through this
 * pointer and Release when the private data is destroyed. This includes when
 * the surface or palette is destroyed before such priovate data is destroyed.
 */
#define DDSPD_IUNKNOWNPOINTER           0x00000001L

/*
 * Private data is only valid for the current state of the object,
 * as determined by the uniqueness value.
 */
#define DDSPD_VOLATILE                  0x00000002L


/****************************************************************************
 *
 * DIRECTDRAWSURFACE SETPALETTE CONSTANTS
 *
 ****************************************************************************/


/****************************************************************************
 *
 * DIRECTDRAW BITDEPTH CONSTANTS
 *
 * NOTE:  These are only used to indicate supported bit depths.   These
 * are flags only, they are not to be used as an actual bit depth.   The
 * absolute numbers 1, 2, 4, 8, 16, 24 and 32 are used to indicate actual
 * bit depths in a surface or for changing the display mode.
 *
 ****************************************************************************/

/*
 * 1 bit per pixel.
 */
#define DDBD_1                  0x00004000l

/*
 * 2 bits per pixel.
 */
#define DDBD_2                  0x00002000l

/*
 * 4 bits per pixel.
 */
#define DDBD_4                  0x00001000l

/*
 * 8 bits per pixel.
 */
#define DDBD_8                  0x00000800l

/*
 * 16 bits per pixel.
 */
#define DDBD_16                 0x00000400l

/*
 * 24 bits per pixel.
 */
#define DDBD_24                 0X00000200l

/*
 * 32 bits per pixel.
 */
#define DDBD_32                 0x00000100l

/****************************************************************************
 *
 * DIRECTDRAWSURFACE SET/GET COLOR KEY FLAGS
 *
 ****************************************************************************/

/*
 * Set if the structure contains a color space.  Not set if the structure
 * contains a single color key.
 */
#define DDCKEY_COLORSPACE       0x00000001l

/*
 * Set if the structure specifies a color key or color space which is to be
 * used as a destination color key for blt operations.
 */
#define DDCKEY_DESTBLT          0x00000002l

/*
 * Set if the structure specifies a color key or color space which is to be
 * used as a destination color key for overlay operations.
 */
#define DDCKEY_DESTOVERLAY      0x00000004l

/*
 * Set if the structure specifies a color key or color space which is to be
 * used as a source color key for blt operations.
 */
#define DDCKEY_SRCBLT           0x00000008l

/*
 * Set if the structure specifies a color key or color space which is to be
 * used as a source color key for overlay operations.
 */
#define DDCKEY_SRCOVERLAY       0x00000010l


/****************************************************************************
 *
 * DIRECTDRAW COLOR KEY CAPABILITY FLAGS
 *
 ****************************************************************************/

/*
 * Supports transparent blting using a color key to identify the replaceable
 * bits of the destination surface for RGB colors.
 */
#define DDCKEYCAPS_DESTBLT                      0x00000001l

/*
 * Supports transparent blting using a color space to identify the replaceable
 * bits of the destination surface for RGB colors.
 */
#define DDCKEYCAPS_DESTBLTCLRSPACE              0x00000002l

/*
 * Supports transparent blting using a color space to identify the replaceable
 * bits of the destination surface for YUV colors.
 */
#define DDCKEYCAPS_DESTBLTCLRSPACEYUV           0x00000004l

/*
 * Supports transparent blting using a color key to identify the replaceable
 * bits of the destination surface for YUV colors.
 */
#define DDCKEYCAPS_DESTBLTYUV                   0x00000008l

/*
 * Supports overlaying using colorkeying of the replaceable bits of the surface
 * being overlayed for RGB colors.
 */
#define DDCKEYCAPS_DESTOVERLAY                  0x00000010l

/*
 * Supports a color space as the color key for the destination for RGB colors.
 */
#define DDCKEYCAPS_DESTOVERLAYCLRSPACE          0x00000020l

/*
 * Supports a color space as the color key for the destination for YUV colors.
 */
#define DDCKEYCAPS_DESTOVERLAYCLRSPACEYUV       0x00000040l

/*
 * Supports only one active destination color key value for visible overlay
 * surfaces.
 */
#define DDCKEYCAPS_DESTOVERLAYONEACTIVE         0x00000080l

/*
 * Supports overlaying using colorkeying of the replaceable bits of the
 * surface being overlayed for YUV colors.
 */
#define DDCKEYCAPS_DESTOVERLAYYUV               0x00000100l

/*
 * Supports transparent blting using the color key for the source with
 * this surface for RGB colors.
 */
#define DDCKEYCAPS_SRCBLT                       0x00000200l

/*
 * Supports transparent blting using a color space for the source with
 * this surface for RGB colors.
 */
#define DDCKEYCAPS_SRCBLTCLRSPACE               0x00000400l

/*
 * Supports transparent blting using a color space for the source with
 * this surface for YUV colors.
 */
#define DDCKEYCAPS_SRCBLTCLRSPACEYUV            0x00000800l

/*
 * Supports transparent blting using the color key for the source with
 * this surface for YUV colors.
 */
#define DDCKEYCAPS_SRCBLTYUV                    0x00001000l

/*
 * Supports overlays using the color key for the source with this
 * overlay surface for RGB colors.
 */
#define DDCKEYCAPS_SRCOVERLAY                   0x00002000l

/*
 * Supports overlays using a color space as the source color key for
 * the overlay surface for RGB colors.
 */
#define DDCKEYCAPS_SRCOVERLAYCLRSPACE           0x00004000l

/*
 * Supports overlays using a color space as the source color key for
 * the overlay surface for YUV colors.
 */
#define DDCKEYCAPS_SRCOVERLAYCLRSPACEYUV        0x00008000l

/*
 * Supports only one active source color key value for visible
 * overlay surfaces.
 */
#define DDCKEYCAPS_SRCOVERLAYONEACTIVE          0x00010000l

/*
 * Supports overlays using the color key for the source with this
 * overlay surface for YUV colors.
 */
#define DDCKEYCAPS_SRCOVERLAYYUV                0x00020000l

/*
 * there are no bandwidth trade-offs for using colorkey with an overlay
 */
#define DDCKEYCAPS_NOCOSTOVERLAY                0x00040000l


/****************************************************************************
 *
 * DIRECTDRAW PIXELFORMAT FLAGS
 *
 ****************************************************************************/

/*
 * The surface has alpha channel information in the pixel format.
 */
#define DDPF_ALPHAPIXELS                        0x00000001l

/*
 * The pixel format contains alpha only information
 */
#define DDPF_ALPHA                              0x00000002l

/*
 * The FourCC code is valid.
 */
#define DDPF_FOURCC                             0x00000004l

/*
 * The surface is 4-bit color indexed.
 */
#define DDPF_PALETTEINDEXED4                    0x00000008l

/*
 * The surface is indexed into a palette which stores indices
 * into the destination surface's 8-bit palette.
 */
#define DDPF_PALETTEINDEXEDTO8                  0x00000010l

/*
 * The surface is 8-bit color indexed.
 */
#define DDPF_PALETTEINDEXED8                    0x00000020l

/*
 * The RGB data in the pixel format structure is valid.
 */
#define DDPF_RGB                                0x00000040l

/*
 * The surface will accept pixel data in the format specified
 * and compress it during the write.
 */
#define DDPF_COMPRESSED                         0x00000080l

/*
 * The surface will accept RGB data and translate it during
 * the write to YUV data.  The format of the data to be written
 * will be contained in the pixel format structure.  The DDPF_RGB
 * flag will be set.
 */
#define DDPF_RGBTOYUV                           0x00000100l

/*
 * pixel format is YUV - YUV data in pixel format struct is valid
 */
#define DDPF_YUV                                0x00000200l

/*
 * pixel format is a z buffer only surface
 */
#define DDPF_ZBUFFER                            0x00000400l

/*
 * The surface is 1-bit color indexed.
 */
#define DDPF_PALETTEINDEXED1                    0x00000800l

/*
 * The surface is 2-bit color indexed.
 */
#define DDPF_PALETTEINDEXED2                    0x00001000l

/*
 * The surface contains Z information in the pixels
 */
#define DDPF_ZPIXELS                            0x00002000l

/*
 * The surface contains stencil information along with Z
 */
#define DDPF_STENCILBUFFER                      0x00004000l

/*
 * Premultiplied alpha format -- the color components have been
 * premultiplied by the alpha component.
 */
#define DDPF_ALPHAPREMULT                       0x00008000l


/*
 * Luminance data in the pixel format is valid.
 * Use this flag for luminance-only or luminance+alpha surfaces,
 * the bit depth is then ddpf.dwLuminanceBitCount.
 */
#define DDPF_LUMINANCE                          0x00020000l

/*
 * Luminance data in the pixel format is valid.
 * Use this flag when hanging luminance off bumpmap surfaces,
 * the bit mask for the luminance portion of the pixel is then
 * ddpf.dwBumpLuminanceBitMask
 */
#define DDPF_BUMPLUMINANCE                      0x00040000l

/*
 * Bump map dUdV data in the pixel format is valid.
 */
#define DDPF_BUMPDUDV                           0x00080000l


/*===========================================================================
 *
 *
 * DIRECTDRAW CALLBACK FLAGS
 *
 *
 *==========================================================================*/

/****************************************************************************
 *
 * DIRECTDRAW ENUMSURFACES FLAGS
 *
 ****************************************************************************/

/*
 * Enumerate all of the surfaces that meet the search criterion.
 */
#define DDENUMSURFACES_ALL                      0x00000001l

/*
 * A search hit is a surface that matches the surface description.
 */
#define DDENUMSURFACES_MATCH                    0x00000002l

/*
 * A search hit is a surface that does not match the surface description.
 */
#define DDENUMSURFACES_NOMATCH                  0x00000004l

/*
 * Enumerate the first surface that can be created which meets the search criterion.
 */
#define DDENUMSURFACES_CANBECREATED             0x00000008l

/*
 * Enumerate the surfaces that already exist that meet the search criterion.
 */
#define DDENUMSURFACES_DOESEXIST                0x00000010l


/****************************************************************************
 *
 * DIRECTDRAW SETDISPLAYMODE FLAGS
 *
 ****************************************************************************/

/*
 * The desired mode is a standard VGA mode
 */
#define DDSDM_STANDARDVGAMODE                   0x00000001l


/****************************************************************************
 *
 * DIRECTDRAW ENUMDISPLAYMODES FLAGS
 *
 ****************************************************************************/

/*
 * Enumerate Modes with different refresh rates.  EnumDisplayModes guarantees
 * that a particular mode will be enumerated only once.  This flag specifies whether
 * the refresh rate is taken into account when determining if a mode is unique.
 */
#define DDEDM_REFRESHRATES                      0x00000001l

/*
 * Enumerate VGA modes. Specify this flag if you wish to enumerate supported VGA
 * modes such as mode 0x13 in addition to the usual ModeX modes (which are always
 * enumerated if the application has previously called SetCooperativeLevel with the
 * DDSCL_ALLOWMODEX flag set).
 */
#define DDEDM_STANDARDVGAMODES                  0x00000002L


/****************************************************************************
 *
 * DIRECTDRAW SETCOOPERATIVELEVEL FLAGS
 *
 ****************************************************************************/

/*
 * Exclusive mode owner will be responsible for the entire primary surface.
 * GDI can be ignored. used with DD
 */
#define DDSCL_FULLSCREEN                        0x00000001l

/*
 * allow CTRL_ALT_DEL to work while in fullscreen exclusive mode
 */
#define DDSCL_ALLOWREBOOT                       0x00000002l

/*
 * prevents DDRAW from modifying the application window.
 * prevents DDRAW from minimize/restore the application window on activation.
 */
#define DDSCL_NOWINDOWCHANGES                   0x00000004l

/*
 * app wants to work as a regular Windows application
 */
#define DDSCL_NORMAL                            0x00000008l

/*
 * app wants exclusive access
 */
#define DDSCL_EXCLUSIVE                         0x00000010l


/*
 * app can deal with non-windows display modes
 */
#define DDSCL_ALLOWMODEX                        0x00000040l

/*
 * this window will receive the focus messages
 */
#define DDSCL_SETFOCUSWINDOW                    0x00000080l

/*
 * this window is associated with the DDRAW object and will
 * cover the screen in fullscreen mode
 */
#define DDSCL_SETDEVICEWINDOW                   0x00000100l

/*
 * app wants DDRAW to create a window to be associated with the
 * DDRAW object
 */
#define DDSCL_CREATEDEVICEWINDOW                0x00000200l

/*
 * App explicitly asks DDRAW/D3D to be multithread safe. This makes D3D
 * take the global crtisec more frequently.
 */
#define DDSCL_MULTITHREADED                     0x00000400l

/*
 * App specifies that it would like to keep the FPU set up for optimal Direct3D
 * performance (single precision and exceptions disabled) so Direct3D
 * does not need to explicitly set the FPU each time. This is assumed by
 * default in DirectX 7. See also DDSCL_FPUPRESERVE
 */
#define DDSCL_FPUSETUP                          0x00000800l

/*
 * App specifies that it needs either double precision FPU or FPU exceptions
 * enabled. This makes Direct3D explicitly set the FPU state eah time it is
 * called. Setting the flag will reduce Direct3D performance. The flag is
 * assumed by default in DirectX 6 and earlier. See also DDSCL_FPUSETUP
 */
#define DDSCL_FPUPRESERVE                          0x00001000l


/****************************************************************************
 *
 * DIRECTDRAW BLT FLAGS
 *
 ****************************************************************************/

/*
 * Use the alpha information in the pixel format or the alpha channel surface
 * attached to the destination surface as the alpha channel for this blt.
 */
#define DDBLT_ALPHADEST                         0x00000001l

/*
 * Use the dwConstAlphaDest field in the DDBLTFX structure as the alpha channel
 * for the destination surface for this blt.
 */
#define DDBLT_ALPHADESTCONSTOVERRIDE            0x00000002l

/*
 * The NEG suffix indicates that the destination surface becomes more
 * transparent as the alpha value increases. (0 is opaque)
 */
#define DDBLT_ALPHADESTNEG                      0x00000004l

/*
 * Use the lpDDSAlphaDest field in the DDBLTFX structure as the alpha
 * channel for the destination for this blt.
 */
#define DDBLT_ALPHADESTSURFACEOVERRIDE          0x00000008l

/*
 * Use the dwAlphaEdgeBlend field in the DDBLTFX structure as the alpha channel
 * for the edges of the image that border the color key colors.
 */
#define DDBLT_ALPHAEDGEBLEND                    0x00000010l

/*
 * Use the alpha information in the pixel format or the alpha channel surface
 * attached to the source surface as the alpha channel for this blt.
 */
#define DDBLT_ALPHASRC                          0x00000020l

/*
 * Use the dwConstAlphaSrc field in the DDBLTFX structure as the alpha channel
 * for the source for this blt.
 */
#define DDBLT_ALPHASRCCONSTOVERRIDE             0x00000040l

/*
 * The NEG suffix indicates that the source surface becomes more transparent
 * as the alpha value increases. (0 is opaque)
 */
#define DDBLT_ALPHASRCNEG                       0x00000080l

/*
 * Use the lpDDSAlphaSrc field in the DDBLTFX structure as the alpha channel
 * for the source for this blt.
 */
#define DDBLT_ALPHASRCSURFACEOVERRIDE           0x00000100l

/*
 * Do this blt asynchronously through the FIFO in the order received.  If
 * there is no room in the hardware FIFO fail the call.
 */
#define DDBLT_ASYNC                             0x00000200l

/*
 * Uses the dwFillColor field in the DDBLTFX structure as the RGB color
 * to fill the destination rectangle on the destination surface with.
 */
#define DDBLT_COLORFILL                         0x00000400l

/*
 * Uses the dwDDFX field in the DDBLTFX structure to specify the effects
 * to use for the blt.
 */
#define DDBLT_DDFX                              0x00000800l

/*
 * Uses the dwDDROPS field in the DDBLTFX structure to specify the ROPS
 * that are not part of the Win32 API.
 */
#define DDBLT_DDROPS                            0x00001000l

/*
 * Use the color key associated with the destination surface.
 */
#define DDBLT_KEYDEST                           0x00002000l

/*
 * Use the dckDestColorkey field in the DDBLTFX structure as the color key
 * for the destination surface.
 */
#define DDBLT_KEYDESTOVERRIDE                   0x00004000l

/*
 * Use the color key associated with the source surface.
 */
#define DDBLT_KEYSRC                            0x00008000l

/*
 * Use the dckSrcColorkey field in the DDBLTFX structure as the color key
 * for the source surface.
 */
#define DDBLT_KEYSRCOVERRIDE                    0x00010000l

/*
 * Use the dwROP field in the DDBLTFX structure for the raster operation
 * for this blt.  These ROPs are the same as the ones defined in the Win32 API.
 */
#define DDBLT_ROP                               0x00020000l

/*
 * Use the dwRotationAngle field in the DDBLTFX structure as the angle
 * (specified in 1/100th of a degree) to rotate the surface.
 */
#define DDBLT_ROTATIONANGLE                     0x00040000l

/*
 * Z-buffered blt using the z-buffers attached to the source and destination
 * surfaces and the dwZBufferOpCode field in the DDBLTFX structure as the
 * z-buffer opcode.
 */
#define DDBLT_ZBUFFER                           0x00080000l

/*
 * Z-buffered blt using the dwConstDest Zfield and the dwZBufferOpCode field
 * in the DDBLTFX structure as the z-buffer and z-buffer opcode respectively
 * for the destination.
 */
#define DDBLT_ZBUFFERDESTCONSTOVERRIDE          0x00100000l

/*
 * Z-buffered blt using the lpDDSDestZBuffer field and the dwZBufferOpCode
 * field in the DDBLTFX structure as the z-buffer and z-buffer opcode
 * respectively for the destination.
 */
#define DDBLT_ZBUFFERDESTOVERRIDE               0x00200000l

/*
 * Z-buffered blt using the dwConstSrcZ field and the dwZBufferOpCode field
 * in the DDBLTFX structure as the z-buffer and z-buffer opcode respectively
 * for the source.
 */
#define DDBLT_ZBUFFERSRCCONSTOVERRIDE           0x00400000l

/*
 * Z-buffered blt using the lpDDSSrcZBuffer field and the dwZBufferOpCode
 * field in the DDBLTFX structure as the z-buffer and z-buffer opcode
 * respectively for the source.
 */
#define DDBLT_ZBUFFERSRCOVERRIDE                0x00800000l

/*
 * wait until the device is ready to handle the blt
 * this will cause blt to not return DDERR_WASSTILLDRAWING
 */
#define DDBLT_WAIT                              0x01000000l

/*
 * Uses the dwFillDepth field in the DDBLTFX structure as the depth value
 * to fill the destination rectangle on the destination Z-buffer surface
 * with.
 */
#define DDBLT_DEPTHFILL                         0x02000000l


/*
 * wait until the device is ready to handle the blt
 * this will cause blt to not return DDERR_WASSTILLDRAWING
 */
#define DDBLT_DONOTWAIT                         0x08000000l

/*
 * These flags indicate a presentation blt (i.e. a blt
 * that moves surface contents from an offscreen back buffer to the primary
 * surface). The driver is not allowed to "queue"  more than three such blts.
 * The "end" of the presentation blt is indicated, since the
 * blt may be clipped, in which case the runtime will call the driver with 
 * several blts. All blts (even if not clipped) are tagged with DDBLT_PRESENTATION
 * and the last (even if not clipped) additionally with DDBLT_LAST_PRESENTATION.
 * Thus the true rule is that the driver must not schedule a DDBLT_PRESENTATION
 * blt if there are 3 or more DDBLT_PRESENTLAST blts in the hardware pipe.
 * If there are such blts in the pipe, the driver should return DDERR_WASSTILLDRAWING
 * until the oldest queued DDBLT_LAST_PRESENTATION blts has been retired (i.e. the
 * pixels have been actually written to the primary surface). Once the oldest blt
 * has been retired, the driver is free to schedule the current blt.
 * The goal is to provide a mechanism whereby the device's hardware queue never
 * gets more than 3 frames ahead of the frames being generated by the application.
 * When excessive queueing occurs, applications become unusable because the application
 * visibly lags user input, and such problems make windowed interactive applications impossible.
 * Some drivers may not have sufficient knowledge of their hardware's FIFO to know
 * when a certain blt has been retired. Such drivers should code cautiously, and 
 * simply not allow any frames to be queued at all. DDBLT_LAST_PRESENTATION should cause
 * such drivers to return DDERR_WASSTILLDRAWING until the accelerator is completely
 * finished- exactly as if the application had called Lock on the source surface
 * before calling Blt. 
 * In other words, the driver is allowed and encouraged to 
 * generate as much latency as it can, but never more than 3 frames worth.
 * Implementation detail: Drivers should count blts against the SOURCE surface, not
 * against the primary surface. This enables multiple parallel windowed application
 * to function more optimally.
 * This flag is passed only to DX8 or higher drivers.
 *
 * APPLICATIONS DO NOT SET THESE FLAGS. THEY ARE SET BY THE DIRECTDRAW RUNTIME.
 * 
 */
#define DDBLT_PRESENTATION                      0x10000000l
#define DDBLT_LAST_PRESENTATION                 0x20000000l



/****************************************************************************
 *
 * BLTFAST FLAGS
 *
 ****************************************************************************/

#define DDBLTFAST_NOCOLORKEY                    0x00000000
#define DDBLTFAST_SRCCOLORKEY                   0x00000001
#define DDBLTFAST_DESTCOLORKEY                  0x00000002
#define DDBLTFAST_WAIT                          0x00000010
#define DDBLTFAST_DONOTWAIT                     0x00000020

/****************************************************************************
 *
 * FLIP FLAGS
 *
 ****************************************************************************/

#define DDFLIP_WAIT                          0x00000001L

/*
 * Indicates that the target surface contains the even field of video data.
 * This flag is only valid with an overlay surface.
 */
#define DDFLIP_EVEN                          0x00000002L

/*
 * Indicates that the target surface contains the odd field of video data.
 * This flag is only valid with an overlay surface.
 */
#define DDFLIP_ODD                           0x00000004L

/*
 * Causes DirectDraw to perform the physical flip immediately and return
 * to the application. Typically, what was the front buffer but is now the back
 * buffer will still be visible (depending on timing) until the next vertical
 * retrace. Subsequent operations involving the two flipped surfaces will
 * not check to see if the physical flip has finished (i.e. will not return
 * DDERR_WASSTILLDRAWING for that reason (but may for other reasons)).
 * This allows an application to perform Flips at a higher frequency than the
 * monitor refresh rate, but may introduce visible artifacts.
 * Only effective if DDCAPS2_FLIPNOVSYNC is set. If that bit is not set,
 * DDFLIP_NOVSYNC has no effect.
 */
#define DDFLIP_NOVSYNC                       0x00000008L


/*
 * Flip Interval Flags. These flags indicate how many vertical retraces to wait between
 * each flip. The default is one. DirectDraw will return DDERR_WASSTILLDRAWING for each
 * surface involved in the flip until the specified number of vertical retraces has
 * ocurred. Only effective if DDCAPS2_FLIPINTERVAL is set. If that bit is not set,
 * DDFLIP_INTERVALn has no effect.
 */

/*
 * DirectDraw will flip on every other vertical sync
 */
#define DDFLIP_INTERVAL2                     0x02000000L


/*
 * DirectDraw will flip on every third vertical sync
 */
#define DDFLIP_INTERVAL3                     0x03000000L


/*
 * DirectDraw will flip on every fourth vertical sync
 */
#define DDFLIP_INTERVAL4                     0x04000000L

/*
 * DirectDraw will flip and display a main stereo surface
 */
#define DDFLIP_STEREO                        0x00000010L

/*
 * On IDirectDrawSurface7 and higher interfaces, the default is DDFLIP_WAIT. If you wish
 * to override the default and use time when the accelerator is busy (as denoted by
 * the DDERR_WASSTILLDRAWING return code) then use DDFLIP_DONOTWAIT.
 */
#define DDFLIP_DONOTWAIT                     0x00000020L


/****************************************************************************
 *
 * DIRECTDRAW SURFACE OVERLAY FLAGS
 *
 ****************************************************************************/

/*
 * Use the alpha information in the pixel format or the alpha channel surface
 * attached to the destination surface as the alpha channel for the
 * destination overlay.
 */
#define DDOVER_ALPHADEST                        0x00000001l

/*
 * Use the dwConstAlphaDest field in the DDOVERLAYFX structure as the
 * destination alpha channel for this overlay.
 */
#define DDOVER_ALPHADESTCONSTOVERRIDE           0x00000002l

/*
 * The NEG suffix indicates that the destination surface becomes more
 * transparent as the alpha value increases.
 */
#define DDOVER_ALPHADESTNEG                     0x00000004l

/*
 * Use the lpDDSAlphaDest field in the DDOVERLAYFX structure as the alpha
 * channel destination for this overlay.
 */
#define DDOVER_ALPHADESTSURFACEOVERRIDE         0x00000008l

/*
 * Use the dwAlphaEdgeBlend field in the DDOVERLAYFX structure as the alpha
 * channel for the edges of the image that border the color key colors.
 */
#define DDOVER_ALPHAEDGEBLEND                   0x00000010l

/*
 * Use the alpha information in the pixel format or the alpha channel surface
 * attached to the source surface as the source alpha channel for this overlay.
 */
#define DDOVER_ALPHASRC                         0x00000020l

/*
 * Use the dwConstAlphaSrc field in the DDOVERLAYFX structure as the source
 * alpha channel for this overlay.
 */
#define DDOVER_ALPHASRCCONSTOVERRIDE            0x00000040l

/*
 * The NEG suffix indicates that the source surface becomes more transparent
 * as the alpha value increases.
 */
#define DDOVER_ALPHASRCNEG                      0x00000080l

/*
 * Use the lpDDSAlphaSrc field in the DDOVERLAYFX structure as the alpha channel
 * source for this overlay.
 */
#define DDOVER_ALPHASRCSURFACEOVERRIDE          0x00000100l

/*
 * Turn this overlay off.
 */
#define DDOVER_HIDE                             0x00000200l

/*
 * Use the color key associated with the destination surface.
 */
#define DDOVER_KEYDEST                          0x00000400l

/*
 * Use the dckDestColorkey field in the DDOVERLAYFX structure as the color key
 * for the destination surface
 */
#define DDOVER_KEYDESTOVERRIDE                  0x00000800l

/*
 * Use the color key associated with the source surface.
 */
#define DDOVER_KEYSRC                           0x00001000l

/*
 * Use the dckSrcColorkey field in the DDOVERLAYFX structure as the color key
 * for the source surface.
 */
#define DDOVER_KEYSRCOVERRIDE                   0x00002000l

/*
 * Turn this overlay on.
 */
#define DDOVER_SHOW                             0x00004000l

/*
 * Add a dirty rect to an emulated overlayed surface.
 */
#define DDOVER_ADDDIRTYRECT                     0x00008000l

/*
 * Redraw all dirty rects on an emulated overlayed surface.
 */
#define DDOVER_REFRESHDIRTYRECTS                0x00010000l

/*
 * Redraw the entire surface on an emulated overlayed surface.
 */
#define DDOVER_REFRESHALL                      0x00020000l


/*
 * Use the overlay FX flags to define special overlay FX
 */
#define DDOVER_DDFX                             0x00080000l

/*
 * Autoflip the overlay when ever the video port autoflips
 */
#define DDOVER_AUTOFLIP                         0x00100000l

/*
 * Display each field of video port data individually without
 * causing any jittery artifacts
 */
#define DDOVER_BOB                              0x00200000l

/*
 * Indicates that bob/weave decisions should not be overridden by other
 * interfaces.
 */
#define DDOVER_OVERRIDEBOBWEAVE                 0x00400000l

/*
 * Indicates that the surface memory is composed of interleaved fields.
 */
#define DDOVER_INTERLEAVED                      0x00800000l

/*
 * Indicates that bob will be performed using hardware rather than
 * software or emulated.
 */
#define DDOVER_BOBHARDWARE                      0x01000000l

/*
 * Indicates that overlay FX structure contains valid ARGB scaling factors.
 */
#define DDOVER_ARGBSCALEFACTORS                 0x02000000l

/*
 * Indicates that ARGB scaling factors can be degraded to fit driver capabilities.
 */
#define DDOVER_DEGRADEARGBSCALING               0x04000000l


/****************************************************************************
 *
 * DIRECTDRAWSURFACE LOCK FLAGS
 *
 ****************************************************************************/

/*
 * The default.  Set to indicate that Lock should return a valid memory pointer
 * to the top of the specified rectangle.  If no rectangle is specified then a
 * pointer to the top of the surface is returned.
 */
#define DDLOCK_SURFACEMEMORYPTR                 0x00000000L     // default

/*
 * Set to indicate that Lock should wait until it can obtain a valid memory
 * pointer before returning.  If this bit is set, Lock will never return
 * DDERR_WASSTILLDRAWING.
 */
#define DDLOCK_WAIT                             0x00000001L

/*
 * Set if an event handle is being passed to Lock.  Lock will trigger the event
 * when it can return the surface memory pointer requested.
 */
#define DDLOCK_EVENT                            0x00000002L

/*
 * Indicates that the surface being locked will only be read from.
 */
#define DDLOCK_READONLY                         0x00000010L

/*
 * Indicates that the surface being locked will only be written to
 */
#define DDLOCK_WRITEONLY                        0x00000020L


/*
 * Indicates that a system wide lock should not be taken when this surface
 * is locked. This has several advantages (cursor responsiveness, ability
 * to call more Windows functions, easier debugging) when locking video
 * memory surfaces. However, an application specifying this flag must
 * comply with a number of conditions documented in the help file.
 * Furthermore, this flag cannot be specified when locking the primary.
 */
#define DDLOCK_NOSYSLOCK                        0x00000800L

/*
 * Used only with Direct3D Vertex Buffer Locks. Indicates that no vertices
 * that were referred to in Draw*PrimtiveVB calls since the start of the
 * frame (or the last lock without this flag) will be modified during the
 * lock. This can be useful when one is only appending data to the vertex
 * buffer
 */
#define DDLOCK_NOOVERWRITE                      0x00001000L

/*
 * Indicates that no assumptions will be made about the contents of the
 * surface or vertex buffer during this lock.
 * This enables two things:
 * -    Direct3D or the driver may provide an alternative memory
 *      area as the vertex buffer. This is useful when one plans to clear the
 *      contents of the vertex buffer and fill in new data.
 * -    Drivers sometimes store surface data in a re-ordered format.
 *      When the application locks the surface, the driver is forced to un-re-order
 *      the surface data before allowing the application to see the surface contents.
 *      This flag is a hint to the driver that it can skip the un-re-ordering process
 *      since the application plans to overwrite every single pixel in the surface
 *      or locked rectangle (and so erase any un-re-ordered pixels anyway).
 *      Applications should always set this flag when they intend to overwrite the entire
 *      surface or locked rectangle.
 */
#define DDLOCK_DISCARDCONTENTS                  0x00002000L
 /*
  * DDLOCK_OKTOSWAP is an older, less informative name for DDLOCK_DISCARDCONTENTS
  */
#define DDLOCK_OKTOSWAP                         0x00002000L

/*
 * On IDirectDrawSurface7 and higher interfaces, the default is DDLOCK_WAIT. If you wish
 * to override the default and use time when the accelerator is busy (as denoted by
 * the DDERR_WASSTILLDRAWING return code) then use DDLOCK_DONOTWAIT.
 */
#define DDLOCK_DONOTWAIT                        0x00004000L



/****************************************************************************
 *
 * DIRECTDRAWSURFACE PAGELOCK FLAGS
 *
 ****************************************************************************/

/*
 * No flags defined at present
 */


/****************************************************************************
 *
 * DIRECTDRAWSURFACE PAGEUNLOCK FLAGS
 *
 ****************************************************************************/

/*
 * No flags defined at present
 */


/****************************************************************************
 *
 * DIRECTDRAWSURFACE BLT FX FLAGS
 *
 ****************************************************************************/

/*
 * If stretching, use arithmetic stretching along the Y axis for this blt.
 */
#define DDBLTFX_ARITHSTRETCHY                   0x00000001l

/*
 * Do this blt mirroring the surface left to right.  Spin the
 * surface around its y-axis.
 */
#define DDBLTFX_MIRRORLEFTRIGHT                 0x00000002l

/*
 * Do this blt mirroring the surface up and down.  Spin the surface
 * around its x-axis.
 */
#define DDBLTFX_MIRRORUPDOWN                    0x00000004l

/*
 * Schedule this blt to avoid tearing.
 */
#define DDBLTFX_NOTEARING                       0x00000008l

/*
 * Do this blt rotating the surface one hundred and eighty degrees.
 */
#define DDBLTFX_ROTATE180                       0x00000010l

/*
 * Do this blt rotating the surface two hundred and seventy degrees.
 */
#define DDBLTFX_ROTATE270                       0x00000020l

/*
 * Do this blt rotating the surface ninety degrees.
 */
#define DDBLTFX_ROTATE90                        0x00000040l

/*
 * Do this z blt using dwZBufferLow and dwZBufferHigh as  range values
 * specified to limit the bits copied from the source surface.
 */
#define DDBLTFX_ZBUFFERRANGE                    0x00000080l

/*
 * Do this z blt adding the dwZBufferBaseDest to each of the sources z values
 * before comparing it with the desting z values.
 */
#define DDBLTFX_ZBUFFERBASEDEST                 0x00000100l

/****************************************************************************
 *
 * DIRECTDRAWSURFACE OVERLAY FX FLAGS
 *
 ****************************************************************************/

/*
 * If stretching, use arithmetic stretching along the Y axis for this overlay.
 */
#define DDOVERFX_ARITHSTRETCHY                  0x00000001l

/*
 * Mirror the overlay across the vertical axis
 */
#define DDOVERFX_MIRRORLEFTRIGHT                0x00000002l

/*
 * Mirror the overlay across the horizontal axis
 */
#define DDOVERFX_MIRRORUPDOWN                   0x00000004l

/*
 * Deinterlace the overlay, if possible
 */
#define DDOVERFX_DEINTERLACE                    0x00000008l


/****************************************************************************
 *
 * DIRECTDRAW WAITFORVERTICALBLANK FLAGS
 *
 ****************************************************************************/

/*
 * return when the vertical blank interval begins
 */
#define DDWAITVB_BLOCKBEGIN                     0x00000001l

/*
 * set up an event to trigger when the vertical blank begins
 */
#define DDWAITVB_BLOCKBEGINEVENT                0x00000002l

/*
 * return when the vertical blank interval ends and display begins
 */
#define DDWAITVB_BLOCKEND                       0x00000004l

/****************************************************************************
 *
 * DIRECTDRAW GETFLIPSTATUS FLAGS
 *
 ****************************************************************************/

/*
 * is it OK to flip now?
 */
#define DDGFS_CANFLIP                   0x00000001l

/*
 * is the last flip finished?
 */
#define DDGFS_ISFLIPDONE                0x00000002l

/****************************************************************************
 *
 * DIRECTDRAW GETBLTSTATUS FLAGS
 *
 ****************************************************************************/

/*
 * is it OK to blt now?
 */
#define DDGBS_CANBLT                    0x00000001l

/*
 * is the blt to the surface finished?
 */
#define DDGBS_ISBLTDONE                 0x00000002l


/****************************************************************************
 *
 * DIRECTDRAW ENUMOVERLAYZORDER FLAGS
 *
 ****************************************************************************/

/*
 * Enumerate overlays back to front.
 */
#define DDENUMOVERLAYZ_BACKTOFRONT      0x00000000l

/*
 * Enumerate overlays front to back
 */
#define DDENUMOVERLAYZ_FRONTTOBACK      0x00000001l

/****************************************************************************
 *
 * DIRECTDRAW UPDATEOVERLAYZORDER FLAGS
 *
 ****************************************************************************/

/*
 * Send overlay to front
 */
#define DDOVERZ_SENDTOFRONT             0x00000000l

/*
 * Send overlay to back
 */
#define DDOVERZ_SENDTOBACK              0x00000001l

/*
 * Move Overlay forward
 */
#define DDOVERZ_MOVEFORWARD             0x00000002l

/*
 * Move Overlay backward
 */
#define DDOVERZ_MOVEBACKWARD            0x00000003l

/*
 * Move Overlay in front of relative surface
 */
#define DDOVERZ_INSERTINFRONTOF         0x00000004l

/*
 * Move Overlay in back of relative surface
 */
#define DDOVERZ_INSERTINBACKOF          0x00000005l


/****************************************************************************
 *
 * DIRECTDRAW SETGAMMARAMP FLAGS
 *
 ****************************************************************************/

/*
 * Request calibrator to adjust the gamma ramp according to the physical
 * properties of the display so that the result should appear identical
 * on all systems.
 */
#define DDSGR_CALIBRATE                        0x00000001L


/****************************************************************************
 *
 * DIRECTDRAW STARTMODETEST FLAGS
 *
 ****************************************************************************/

/*
 * Indicates that the mode being tested has passed
 */
#define DDSMT_ISTESTREQUIRED                   0x00000001L


/****************************************************************************
 *
 * DIRECTDRAW EVALUATEMODE FLAGS
 *
 ****************************************************************************/

/*
 * Indicates that the mode being tested has passed
 */
#define DDEM_MODEPASSED                        0x00000001L

/*
 * Indicates that the mode being tested has failed
 */
#define DDEM_MODEFAILED                        0x00000002L


/*===========================================================================
 *
 *
 * DIRECTDRAW RETURN CODES
 *
 * The return values from DirectDraw Commands and Surface that return an HRESULT
 * are codes from DirectDraw concerning the results of the action
 * requested by DirectDraw.
 *
 *==========================================================================*/

/*
 * Status is OK
 *
 * Issued by: DirectDraw Commands and all callbacks
 */
#define DD_OK                                   0
#define DD_FALSE                                S_FALSE

/****************************************************************************
 *
 * DIRECTDRAW ENUMCALLBACK RETURN VALUES
 *
 * EnumCallback returns are used to control the flow of the DIRECTDRAW and
 * DIRECTDRAWSURFACE object enumerations.   They can only be returned by
 * enumeration callback routines.
 *
 ****************************************************************************/

/*
 * stop the enumeration
 */
#define DDENUMRET_CANCEL                        0

/*
 * continue the enumeration
 */
#define DDENUMRET_OK                            1

/****************************************************************************
 *
 * DIRECTDRAW ERRORS
 *
 * Errors are represented by negative values and cannot be combined.
 *
 ****************************************************************************/

/*
 * This object is already initialized
 */
#define DDERR_ALREADYINITIALIZED                MAKE_DDHRESULT( 5 )

/*
 * This surface can not be attached to the requested surface.
 */
#define DDERR_CANNOTATTACHSURFACE               MAKE_DDHRESULT( 10 )

/*
 * This surface can not be detached from the requested surface.
 */
#define DDERR_CANNOTDETACHSURFACE               MAKE_DDHRESULT( 20 )

/*
 * Support is currently not available.
 */
#define DDERR_CURRENTLYNOTAVAIL                 MAKE_DDHRESULT( 40 )

/*
 * An exception was encountered while performing the requested operation
 */
#define DDERR_EXCEPTION                         MAKE_DDHRESULT( 55 )

/*
 * Generic failure.
 */
#define DDERR_GENERIC                           E_FAIL

/*
 * Height of rectangle provided is not a multiple of reqd alignment
 */
#define DDERR_HEIGHTALIGN                       MAKE_DDHRESULT( 90 )

/*
 * Unable to match primary surface creation request with existing
 * primary surface.
 */
#define DDERR_INCOMPATIBLEPRIMARY               MAKE_DDHRESULT( 95 )

/*
 * One or more of the caps bits passed to the callback are incorrect.
 */
#define DDERR_INVALIDCAPS                       MAKE_DDHRESULT( 100 )

/*
 * DirectDraw does not support provided Cliplist.
 */
#define DDERR_INVALIDCLIPLIST                   MAKE_DDHRESULT( 110 )

/*
 * DirectDraw does not support the requested mode
 */
#define DDERR_INVALIDMODE                       MAKE_DDHRESULT( 120 )

/*
 * DirectDraw received a pointer that was an invalid DIRECTDRAW object.
 */
#define DDERR_INVALIDOBJECT                     MAKE_DDHRESULT( 130 )

/*
 * One or more of the parameters passed to the callback function are
 * incorrect.
 */
#define DDERR_INVALIDPARAMS                     E_INVALIDARG

/*
 * pixel format was invalid as specified
 */
#define DDERR_INVALIDPIXELFORMAT                MAKE_DDHRESULT( 145 )

/*
 * Rectangle provided was invalid.
 */
#define DDERR_INVALIDRECT                       MAKE_DDHRESULT( 150 )

/*
 * Operation could not be carried out because one or more surfaces are locked
 */
#define DDERR_LOCKEDSURFACES                    MAKE_DDHRESULT( 160 )

/*
 * There is no 3D present.
 */
#define DDERR_NO3D                              MAKE_DDHRESULT( 170 )

/*
 * Operation could not be carried out because there is no alpha accleration
 * hardware present or available.
 */
#define DDERR_NOALPHAHW                         MAKE_DDHRESULT( 180 )

/*
 * Operation could not be carried out because there is no stereo
 * hardware present or available.
 */
#define DDERR_NOSTEREOHARDWARE          MAKE_DDHRESULT( 181 )

/*
 * Operation could not be carried out because there is no hardware
 * present which supports stereo surfaces
 */
#define DDERR_NOSURFACELEFT                             MAKE_DDHRESULT( 182 )



/*
 * no clip list available
 */
#define DDERR_NOCLIPLIST                        MAKE_DDHRESULT( 205 )

/*
 * Operation could not be carried out because there is no color conversion
 * hardware present or available.
 */
#define DDERR_NOCOLORCONVHW                     MAKE_DDHRESULT( 210 )

/*
 * Create function called without DirectDraw object method SetCooperativeLevel
 * being called.
 */
#define DDERR_NOCOOPERATIVELEVELSET             MAKE_DDHRESULT( 212 )

/*
 * Surface doesn't currently have a color key
 */
#define DDERR_NOCOLORKEY                        MAKE_DDHRESULT( 215 )

/*
 * Operation could not be carried out because there is no hardware support
 * of the dest color key.
 */
#define DDERR_NOCOLORKEYHW                      MAKE_DDHRESULT( 220 )

/*
 * No DirectDraw support possible with current display driver
 */
#define DDERR_NODIRECTDRAWSUPPORT               MAKE_DDHRESULT( 222 )

/*
 * Operation requires the application to have exclusive mode but the
 * application does not have exclusive mode.
 */
#define DDERR_NOEXCLUSIVEMODE                   MAKE_DDHRESULT( 225 )

/*
 * Flipping visible surfaces is not supported.
 */
#define DDERR_NOFLIPHW                          MAKE_DDHRESULT( 230 )

/*
 * There is no GDI present.
 */
#define DDERR_NOGDI                             MAKE_DDHRESULT( 240 )

/*
 * Operation could not be carried out because there is no hardware present
 * or available.
 */
#define DDERR_NOMIRRORHW                        MAKE_DDHRESULT( 250 )

/*
 * Requested item was not found
 */
#define DDERR_NOTFOUND                          MAKE_DDHRESULT( 255 )

/*
 * Operation could not be carried out because there is no overlay hardware
 * present or available.
 */
#define DDERR_NOOVERLAYHW                       MAKE_DDHRESULT( 260 )

/*
 * Operation could not be carried out because the source and destination
 * rectangles are on the same surface and overlap each other.
 */
#define DDERR_OVERLAPPINGRECTS                  MAKE_DDHRESULT( 270 )

/*
 * Operation could not be carried out because there is no appropriate raster
 * op hardware present or available.
 */
#define DDERR_NORASTEROPHW                      MAKE_DDHRESULT( 280 )

/*
 * Operation could not be carried out because there is no rotation hardware
 * present or available.
 */
#define DDERR_NOROTATIONHW                      MAKE_DDHRESULT( 290 )

/*
 * Operation could not be carried out because there is no hardware support
 * for stretching
 */
#define DDERR_NOSTRETCHHW                       MAKE_DDHRESULT( 310 )

/*
 * DirectDrawSurface is not in 4 bit color palette and the requested operation
 * requires 4 bit color palette.
 */
#define DDERR_NOT4BITCOLOR                      MAKE_DDHRESULT( 316 )

/*
 * DirectDrawSurface is not in 4 bit color index palette and the requested
 * operation requires 4 bit color index palette.
 */
#define DDERR_NOT4BITCOLORINDEX                 MAKE_DDHRESULT( 317 )

/*
 * DirectDraw Surface is not in 8 bit color mode and the requested operation
 * requires 8 bit color.
 */
#define DDERR_NOT8BITCOLOR                      MAKE_DDHRESULT( 320 )

/*
 * Operation could not be carried out because there is no texture mapping
 * hardware present or available.
 */
#define DDERR_NOTEXTUREHW                       MAKE_DDHRESULT( 330 )

/*
 * Operation could not be carried out because there is no hardware support
 * for vertical blank synchronized operations.
 */
#define DDERR_NOVSYNCHW                         MAKE_DDHRESULT( 335 )

/*
 * Operation could not be carried out because there is no hardware support
 * for zbuffer blting.
 */
#define DDERR_NOZBUFFERHW                       MAKE_DDHRESULT( 340 )

/*
 * Overlay surfaces could not be z layered based on their BltOrder because
 * the hardware does not support z layering of overlays.
 */
#define DDERR_NOZOVERLAYHW                      MAKE_DDHRESULT( 350 )

/*
 * The hardware needed for the requested operation has already been
 * allocated.
 */
#define DDERR_OUTOFCAPS                         MAKE_DDHRESULT( 360 )

/*
 * DirectDraw does not have enough memory to perform the operation.
 */
#define DDERR_OUTOFMEMORY                       E_OUTOFMEMORY

/*
 * DirectDraw does not have enough memory to perform the operation.
 */
#define DDERR_OUTOFVIDEOMEMORY                  MAKE_DDHRESULT( 380 )

/*
 * hardware does not support clipped overlays
 */
#define DDERR_OVERLAYCANTCLIP                   MAKE_DDHRESULT( 382 )

/*
 * Can only have ony color key active at one time for overlays
 */
#define DDERR_OVERLAYCOLORKEYONLYONEACTIVE      MAKE_DDHRESULT( 384 )

/*
 * Access to this palette is being refused because the palette is already
 * locked by another thread.
 */
#define DDERR_PALETTEBUSY                       MAKE_DDHRESULT( 387 )

/*
 * No src color key specified for this operation.
 */
#define DDERR_COLORKEYNOTSET                    MAKE_DDHRESULT( 400 )

/*
 * This surface is already attached to the surface it is being attached to.
 */
#define DDERR_SURFACEALREADYATTACHED            MAKE_DDHRESULT( 410 )

/*
 * This surface is already a dependency of the surface it is being made a
 * dependency of.
 */
#define DDERR_SURFACEALREADYDEPENDENT           MAKE_DDHRESULT( 420 )

/*
 * Access to this surface is being refused because the surface is already
 * locked by another thread.
 */
#define DDERR_SURFACEBUSY                       MAKE_DDHRESULT( 430 )

/*
 * Access to this surface is being refused because no driver exists
 * which can supply a pointer to the surface.
 * This is most likely to happen when attempting to lock the primary
 * surface when no DCI provider is present.
 * Will also happen on attempts to lock an optimized surface.
 */
#define DDERR_CANTLOCKSURFACE                   MAKE_DDHRESULT( 435 )

/*
 * Access to Surface refused because Surface is obscured.
 */
#define DDERR_SURFACEISOBSCURED                 MAKE_DDHRESULT( 440 )

/*
 * Access to this surface is being refused because the surface is gone.
 * The DIRECTDRAWSURFACE object representing this surface should
 * have Restore called on it.
 */
#define DDERR_SURFACELOST                       MAKE_DDHRESULT( 450 )

/*
 * The requested surface is not attached.
 */
#define DDERR_SURFACENOTATTACHED                MAKE_DDHRESULT( 460 )

/*
 * Height requested by DirectDraw is too large.
 */
#define DDERR_TOOBIGHEIGHT                      MAKE_DDHRESULT( 470 )

/*
 * Size requested by DirectDraw is too large --  The individual height and
 * width are OK.
 */
#define DDERR_TOOBIGSIZE                        MAKE_DDHRESULT( 480 )

/*
 * Width requested by DirectDraw is too large.
 */
#define DDERR_TOOBIGWIDTH                       MAKE_DDHRESULT( 490 )

/*
 * Action not supported.
 */
#define DDERR_UNSUPPORTED                       E_NOTIMPL

/*
 * Pixel format requested is unsupported by DirectDraw
 */
#define DDERR_UNSUPPORTEDFORMAT                 MAKE_DDHRESULT( 510 )

/*
 * Bitmask in the pixel format requested is unsupported by DirectDraw
 */
#define DDERR_UNSUPPORTEDMASK                   MAKE_DDHRESULT( 520 )

/*
 * The specified stream contains invalid data
 */
#define DDERR_INVALIDSTREAM                     MAKE_DDHRESULT( 521 )

/*
 * vertical blank is in progress
 */
#define DDERR_VERTICALBLANKINPROGRESS           MAKE_DDHRESULT( 537 )

/*
 * Informs DirectDraw that the previous Blt which is transfering information
 * to or from this Surface is incomplete.
 */
#define DDERR_WASSTILLDRAWING                   MAKE_DDHRESULT( 540 )


/*
 * The specified surface type requires specification of the COMPLEX flag
 */
#define DDERR_DDSCAPSCOMPLEXREQUIRED            MAKE_DDHRESULT( 542 )


/*
 * Rectangle provided was not horizontally aligned on reqd. boundary
 */
#define DDERR_XALIGN                            MAKE_DDHRESULT( 560 )

/*
 * The GUID passed to DirectDrawCreate is not a valid DirectDraw driver
 * identifier.
 */
#define DDERR_INVALIDDIRECTDRAWGUID             MAKE_DDHRESULT( 561 )

/*
 * A DirectDraw object representing this driver has already been created
 * for this process.
 */
#define DDERR_DIRECTDRAWALREADYCREATED          MAKE_DDHRESULT( 562 )

/*
 * A hardware only DirectDraw object creation was attempted but the driver
 * did not support any hardware.
 */
#define DDERR_NODIRECTDRAWHW                    MAKE_DDHRESULT( 563 )

/*
 * this process already has created a primary surface
 */
#define DDERR_PRIMARYSURFACEALREADYEXISTS       MAKE_DDHRESULT( 564 )

/*
 * software emulation not available.
 */
#define DDERR_NOEMULATION                       MAKE_DDHRESULT( 565 )

/*
 * region passed to Clipper::GetClipList is too small.
 */
#define DDERR_REGIONTOOSMALL                    MAKE_DDHRESULT( 566 )

/*
 * an attempt was made to set a clip list for a clipper objec that
 * is already monitoring an hwnd.
 */
#define DDERR_CLIPPERISUSINGHWND                MAKE_DDHRESULT( 567 )

/*
 * No clipper object attached to surface object
 */
#define DDERR_NOCLIPPERATTACHED                 MAKE_DDHRESULT( 568 )

/*
 * Clipper notification requires an HWND or
 * no HWND has previously been set as the CooperativeLevel HWND.
 */
#define DDERR_NOHWND                            MAKE_DDHRESULT( 569 )

/*
 * HWND used by DirectDraw CooperativeLevel has been subclassed,
 * this prevents DirectDraw from restoring state.
 */
#define DDERR_HWNDSUBCLASSED                    MAKE_DDHRESULT( 570 )

/*
 * The CooperativeLevel HWND has already been set.
 * It can not be reset while the process has surfaces or palettes created.
 */
#define DDERR_HWNDALREADYSET                    MAKE_DDHRESULT( 571 )

/*
 * No palette object attached to this surface.
 */
#define DDERR_NOPALETTEATTACHED                 MAKE_DDHRESULT( 572 )

/*
 * No hardware support for 16 or 256 color palettes.
 */
#define DDERR_NOPALETTEHW                       MAKE_DDHRESULT( 573 )

/*
 * If a clipper object is attached to the source surface passed into a
 * BltFast call.
 */
#define DDERR_BLTFASTCANTCLIP                   MAKE_DDHRESULT( 574 )

/*
 * No blter.
 */
#define DDERR_NOBLTHW                           MAKE_DDHRESULT( 575 )

/*
 * No DirectDraw ROP hardware.
 */
#define DDERR_NODDROPSHW                        MAKE_DDHRESULT( 576 )

/*
 * returned when GetOverlayPosition is called on a hidden overlay
 */
#define DDERR_OVERLAYNOTVISIBLE                 MAKE_DDHRESULT( 577 )

/*
 * returned when GetOverlayPosition is called on a overlay that UpdateOverlay
 * has never been called on to establish a destionation.
 */
#define DDERR_NOOVERLAYDEST                     MAKE_DDHRESULT( 578 )

/*
 * returned when the position of the overlay on the destionation is no longer
 * legal for that destionation.
 */
#define DDERR_INVALIDPOSITION                   MAKE_DDHRESULT( 579 )

/*
 * returned when an overlay member is called for a non-overlay surface
 */
#define DDERR_NOTAOVERLAYSURFACE                MAKE_DDHRESULT( 580 )

/*
 * An attempt was made to set the cooperative level when it was already
 * set to exclusive.
 */
#define DDERR_EXCLUSIVEMODEALREADYSET           MAKE_DDHRESULT( 581 )

/*
 * An attempt has been made to flip a surface that is not flippable.
 */
#define DDERR_NOTFLIPPABLE                      MAKE_DDHRESULT( 582 )

/*
 * Can't duplicate primary & 3D surfaces, or surfaces that are implicitly
 * created.
 */
#define DDERR_CANTDUPLICATE                     MAKE_DDHRESULT( 583 )

/*
 * Surface was not locked.  An attempt to unlock a surface that was not
 * locked at all, or by this process, has been attempted.
 */
#define DDERR_NOTLOCKED                         MAKE_DDHRESULT( 584 )

/*
 * Windows can not create any more DCs, or a DC was requested for a paltte-indexed
 * surface when the surface had no palette AND the display mode was not palette-indexed
 * (in this case DirectDraw cannot select a proper palette into the DC)
 */
#define DDERR_CANTCREATEDC                      MAKE_DDHRESULT( 585 )

/*
 * No DC was ever created for this surface.
 */
#define DDERR_NODC                              MAKE_DDHRESULT( 586 )

/*
 * This surface can not be restored because it was created in a different
 * mode.
 */
#define DDERR_WRONGMODE                         MAKE_DDHRESULT( 587 )

/*
 * This surface can not be restored because it is an implicitly created
 * surface.
 */
#define DDERR_IMPLICITLYCREATED                 MAKE_DDHRESULT( 588 )

/*
 * The surface being used is not a palette-based surface
 */
#define DDERR_NOTPALETTIZED                     MAKE_DDHRESULT( 589 )


/*
 * The display is currently in an unsupported mode
 */
#define DDERR_UNSUPPORTEDMODE                   MAKE_DDHRESULT( 590 )

/*
 * Operation could not be carried out because there is no mip-map
 * texture mapping hardware present or available.
 */
#define DDERR_NOMIPMAPHW                        MAKE_DDHRESULT( 591 )

/*
 * The requested action could not be performed because the surface was of
 * the wrong type.
 */
#define DDERR_INVALIDSURFACETYPE                MAKE_DDHRESULT( 592 )


/*
 * Device does not support optimized surfaces, therefore no video memory optimized surfaces
 */
#define DDERR_NOOPTIMIZEHW                      MAKE_DDHRESULT( 600 )

/*
 * Surface is an optimized surface, but has not yet been allocated any memory
 */
#define DDERR_NOTLOADED                         MAKE_DDHRESULT( 601 )

/*
 * Attempt was made to create or set a device window without first setting
 * the focus window
 */
#define DDERR_NOFOCUSWINDOW                     MAKE_DDHRESULT( 602 )

/*
 * Attempt was made to set a palette on a mipmap sublevel
 */
#define DDERR_NOTONMIPMAPSUBLEVEL               MAKE_DDHRESULT( 603 )

/*
 * A DC has already been returned for this surface. Only one DC can be
 * retrieved per surface.
 */
#define DDERR_DCALREADYCREATED                  MAKE_DDHRESULT( 620 )

/*
 * An attempt was made to allocate non-local video memory from a device
 * that does not support non-local video memory.
 */
#define DDERR_NONONLOCALVIDMEM                  MAKE_DDHRESULT( 630 )

/*
 * The attempt to page lock a surface failed.
 */
#define DDERR_CANTPAGELOCK                      MAKE_DDHRESULT( 640 )


/*
 * The attempt to page unlock a surface failed.
 */
#define DDERR_CANTPAGEUNLOCK                    MAKE_DDHRESULT( 660 )

/*
 * An attempt was made to page unlock a surface with no outstanding page locks.
 */
#define DDERR_NOTPAGELOCKED                     MAKE_DDHRESULT( 680 )

/*
 * There is more data available than the specified buffer size could hold
 */
#define DDERR_MOREDATA                          MAKE_DDHRESULT( 690 )

/*
 * The data has expired and is therefore no longer valid.
 */
#define DDERR_EXPIRED                           MAKE_DDHRESULT( 691 )

/*
 * The mode test has finished executing.
 */
#define DDERR_TESTFINISHED                      MAKE_DDHRESULT( 692 )

/*
 * The mode test has switched to a new mode.
 */
#define DDERR_NEWMODE                           MAKE_DDHRESULT( 693 )

/*
 * D3D has not yet been initialized.
 */
#define DDERR_D3DNOTINITIALIZED                 MAKE_DDHRESULT( 694 )

/*
 * The video port is not active
 */
#define DDERR_VIDEONOTACTIVE                    MAKE_DDHRESULT( 695 )

/*
 * The monitor does not have EDID data.
 */
#define DDERR_NOMONITORINFORMATION              MAKE_DDHRESULT( 696 )

/*
 * The driver does not enumerate display mode refresh rates.
 */
#define DDERR_NODRIVERSUPPORT                   MAKE_DDHRESULT( 697 )

/*
 * Surfaces created by one direct draw device cannot be used directly by
 * another direct draw device.
 */
#define DDERR_DEVICEDOESNTOWNSURFACE            MAKE_DDHRESULT( 699 )



/*
 * An attempt was made to invoke an interface member of a DirectDraw object
 * created by CoCreateInstance() before it was initialized.
 */
#define DDERR_NOTINITIALIZED                    CO_E_NOTINITIALIZED


/* Alpha bit depth constants */


#ifdef __cplusplus
};
#endif

#ifdef ENABLE_NAMELESS_UNION_PRAGMA
#pragma warning(default:4201)
#endif

#endif //__DDRAW_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\ddrawex.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1995-1997               **
//*********************************************************************
//
//	DDRAWEX.H 
//
//	Header file for DirectDrawEx functionality

#ifndef __DDRAWEXH__
#define __DDRAWEXH__

#ifdef __cplusplus
extern "C" {
#endif

#include <ddraw.h>

// {4FD2A832-86C8-11d0-8FCA-00C04FD9189D}
DEFINE_GUID(CLSID_DirectDrawFactory, 
0x4fd2a832, 0x86c8, 0x11d0, 0x8f, 0xca, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0x9d);

DEFINE_GUID(IID_IDirectDrawFactory, 
0x4fd2a833, 0x86c8, 0x11d0, 0x8f, 0xca, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0x9d);

#ifndef DIRECTDRAW_VERSION

//Functionality supported by DDrawex but not DX3
#define DDSD_LPSURFACE		0x00000800l

DEFINE_GUID( IID_IDirectDrawSurface3,
0xDA044E00,0x69B2,0x11D0,0xA1,0xD5,0x00,0xAA,0x00,0xB8,0xDF,0xBB );

typedef struct IDirectDrawSurface3		FAR *LPDIRECTDRAWSURFACE3;

#undef INTERFACE
#define INTERFACE IDirectDrawSurface3
DECLARE_INTERFACE_( IDirectDrawSurface3, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDrawSurface methods ***/
    STDMETHOD(AddAttachedSurface)(THIS_ LPDIRECTDRAWSURFACE3) PURE;
    STDMETHOD(AddOverlayDirtyRect)(THIS_ LPRECT) PURE;
    STDMETHOD(Blt)(THIS_ LPRECT,LPDIRECTDRAWSURFACE3, LPRECT,DWORD, LPDDBLTFX) PURE;
    STDMETHOD(BltBatch)(THIS_ LPDDBLTBATCH, DWORD, DWORD ) PURE;
    STDMETHOD(BltFast)(THIS_ DWORD,DWORD,LPDIRECTDRAWSURFACE3, LPRECT,DWORD) PURE;
    STDMETHOD(DeleteAttachedSurface)(THIS_ DWORD,LPDIRECTDRAWSURFACE3) PURE;
    STDMETHOD(EnumAttachedSurfaces)(THIS_ LPVOID,LPDDENUMSURFACESCALLBACK) PURE;
    STDMETHOD(EnumOverlayZOrders)(THIS_ DWORD,LPVOID,LPDDENUMSURFACESCALLBACK) PURE;
    STDMETHOD(Flip)(THIS_ LPDIRECTDRAWSURFACE3, DWORD) PURE;
    STDMETHOD(GetAttachedSurface)(THIS_ LPDDSCAPS, LPDIRECTDRAWSURFACE3 FAR *) PURE;
    STDMETHOD(GetBltStatus)(THIS_ DWORD) PURE;
    STDMETHOD(GetCaps)(THIS_ LPDDSCAPS) PURE;
    STDMETHOD(GetClipper)(THIS_ LPDIRECTDRAWCLIPPER FAR*) PURE;
    STDMETHOD(GetColorKey)(THIS_ DWORD, LPDDCOLORKEY) PURE;
    STDMETHOD(GetDC)(THIS_ HDC FAR *) PURE;
    STDMETHOD(GetFlipStatus)(THIS_ DWORD) PURE;
    STDMETHOD(GetOverlayPosition)(THIS_ LPLONG, LPLONG ) PURE;
    STDMETHOD(GetPalette)(THIS_ LPDIRECTDRAWPALETTE FAR*) PURE;
    STDMETHOD(GetPixelFormat)(THIS_ LPDDPIXELFORMAT) PURE;
    STDMETHOD(GetSurfaceDesc)(THIS_ LPDDSURFACEDESC) PURE;
    STDMETHOD(Initialize)(THIS_ LPDIRECTDRAW, LPDDSURFACEDESC) PURE;
    STDMETHOD(IsLost)(THIS) PURE;
    STDMETHOD(Lock)(THIS_ LPRECT,LPDDSURFACEDESC,DWORD,HANDLE) PURE;
    STDMETHOD(ReleaseDC)(THIS_ HDC) PURE;
    STDMETHOD(Restore)(THIS) PURE;
    STDMETHOD(SetClipper)(THIS_ LPDIRECTDRAWCLIPPER) PURE;
    STDMETHOD(SetColorKey)(THIS_ DWORD, LPDDCOLORKEY) PURE;
    STDMETHOD(SetOverlayPosition)(THIS_ LONG, LONG ) PURE;
    STDMETHOD(SetPalette)(THIS_ LPDIRECTDRAWPALETTE) PURE;
    STDMETHOD(Unlock)(THIS_ LPVOID) PURE;
    STDMETHOD(UpdateOverlay)(THIS_ LPRECT, LPDIRECTDRAWSURFACE3,LPRECT,DWORD, LPDDOVERLAYFX) PURE;
    STDMETHOD(UpdateOverlayDisplay)(THIS_ DWORD) PURE;
    STDMETHOD(UpdateOverlayZOrder)(THIS_ DWORD, LPDIRECTDRAWSURFACE3) PURE;
    /*** Added in the v2 interface ***/
    STDMETHOD(GetDDInterface)(THIS_ LPVOID FAR *) PURE;
    STDMETHOD(PageLock)(THIS_ DWORD) PURE;
    STDMETHOD(PageUnlock)(THIS_ DWORD) PURE;
    /*** Added in the v3 interface ***/
    STDMETHOD(SetSurfaceDesc)(THIS_ LPDDSURFACEDESC, DWORD ) PURE;
};
#endif




#define	DDSCAPS_DATAEXCHANGE	(DDSCAPS_SYSTEMMEMORY|DDSCAPS_VIDEOMEMORY)

#undef	INTERFACE
#define INTERFACE IDirectDrawFactory

DECLARE_INTERFACE_(IDirectDrawFactory, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDrawFactory methods ***/
    STDMETHOD(CreateDirectDraw) (THIS_ GUID * pGUID, HWND hWnd, DWORD dwCoopLevelFlags, DWORD dwReserved, IUnknown *pUnkOuter, IDirectDraw **ppDirectDraw) PURE;
    STDMETHOD(DirectDrawEnumerate) (THIS_ LPDDENUMCALLBACK lpCallback, LPVOID lpContext) PURE;
};


 
// {618F8AD4-8B7A-11d0-8FCC-00C04FD9189D}
DEFINE_GUID(IID_IDirectDraw3, 
0x618f8ad4, 0x8b7a, 0x11d0, 0x8f, 0xcc, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0x9d);

typedef struct IDirectDraw3		FAR *LPDIRECTDRAW3;

#undef	INTERFACE
#define INTERFACE IDirectDraw3

DECLARE_INTERFACE_(IDirectDraw3, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDraw methods ***/
    STDMETHOD(Compact)(THIS) PURE;
    STDMETHOD(CreateClipper)(THIS_ DWORD, LPDIRECTDRAWCLIPPER FAR*, IUnknown FAR * ) PURE;
    STDMETHOD(CreatePalette)(THIS_ DWORD, LPPALETTEENTRY, LPDIRECTDRAWPALETTE FAR*, IUnknown FAR * ) PURE;
    STDMETHOD(CreateSurface)(THIS_  LPDDSURFACEDESC, LPDIRECTDRAWSURFACE FAR *, IUnknown FAR *) PURE;
    STDMETHOD(DuplicateSurface)( THIS_ LPDIRECTDRAWSURFACE, LPDIRECTDRAWSURFACE FAR * ) PURE;
    STDMETHOD(EnumDisplayModes)( THIS_ DWORD, LPDDSURFACEDESC, LPVOID, LPDDENUMMODESCALLBACK ) PURE;
    STDMETHOD(EnumSurfaces)(THIS_ DWORD, LPDDSURFACEDESC, LPVOID,LPDDENUMSURFACESCALLBACK ) PURE;
    STDMETHOD(FlipToGDISurface)(THIS) PURE;
    STDMETHOD(GetCaps)( THIS_ LPDDCAPS, LPDDCAPS) PURE;
    STDMETHOD(GetDisplayMode)( THIS_ LPDDSURFACEDESC) PURE;
    STDMETHOD(GetFourCCCodes)(THIS_  LPDWORD, LPDWORD ) PURE;
    STDMETHOD(GetGDISurface)(THIS_ LPDIRECTDRAWSURFACE FAR *) PURE;
    STDMETHOD(GetMonitorFrequency)(THIS_ LPDWORD) PURE;
    STDMETHOD(GetScanLine)(THIS_ LPDWORD) PURE;
    STDMETHOD(GetVerticalBlankStatus)(THIS_ LPBOOL ) PURE;
    STDMETHOD(Initialize)(THIS_ GUID FAR *) PURE;
    STDMETHOD(RestoreDisplayMode)(THIS) PURE;
    STDMETHOD(SetCooperativeLevel)(THIS_ HWND, DWORD) PURE;
    STDMETHOD(SetDisplayMode)(THIS_ DWORD, DWORD,DWORD, DWORD, DWORD) PURE;
    STDMETHOD(WaitForVerticalBlank)(THIS_ DWORD, HANDLE ) PURE;
    /*** Added in the v2 interface ***/
    STDMETHOD(GetAvailableVidMem)(THIS_ LPDDSCAPS, LPDWORD, LPDWORD) PURE;
    /*** IDirectDraw3 methods ***/
    STDMETHOD(GetSurfaceFromDC) (THIS_ HDC, IDirectDrawSurface **) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectDraw3_QueryInterface(p, a, b)         (p)->lpVtbl->QueryInterface(p, a, b)
#define IDirectDraw3_AddRef(p)                       (p)->lpVtbl->AddRef(p)
#define IDirectDraw3_Release(p)                      (p)->lpVtbl->Release(p)
#define IDirectDraw3_Compact(p)                      (p)->lpVtbl->Compact(p)
#define IDirectDraw3_CreateClipper(p, a, b, c)       (p)->lpVtbl->CreateClipper(p, a, b, c)
#define IDirectDraw3_CreatePalette(p, a, b, c, d)    (p)->lpVtbl->CreatePalette(p, a, b, c, d)
#define IDirectDraw3_CreateSurface(p, a, b, c)       (p)->lpVtbl->CreateSurface(p, a, b, c)
#define IDirectDraw3_DuplicateSurface(p, a, b)       (p)->lpVtbl->DuplicateSurface(p, a, b)
#define IDirectDraw3_EnumDisplayModes(p, a, b, c, d) (p)->lpVtbl->EnumDisplayModes(p, a, b, c, d)
#define IDirectDraw3_EnumSurfaces(p, a, b, c, d)     (p)->lpVtbl->EnumSurfaces(p, a, b, c, d)
#define IDirectDraw3_FlipToGDISurface(p)             (p)->lpVtbl->FlipToGDISurface(p)
#define IDirectDraw3_GetCaps(p, a, b)                (p)->lpVtbl->GetCaps(p, a, b)
#define IDirectDraw3_GetDisplayMode(p, a)            (p)->lpVtbl->GetDisplayMode(p, a)
#define IDirectDraw3_GetFourCCCodes(p, a, b)         (p)->lpVtbl->GetFourCCCodes(p, a, b)
#define IDirectDraw3_GetGDISurface(p, a)             (p)->lpVtbl->GetGDISurface(p, a)
#define IDirectDraw3_GetMonitorFrequency(p, a)       (p)->lpVtbl->GetMonitorFrequency(p, a)
#define IDirectDraw3_GetScanLine(p, a)               (p)->lpVtbl->GetScanLine(p, a)
#define IDirectDraw3_GetVerticalBlankStatus(p, a)    (p)->lpVtbl->GetVerticalBlankStatus(p, a)
#define IDirectDraw3_Initialize(p, a)                (p)->lpVtbl->Initialize(p, a)
#define IDirectDraw3_RestoreDisplayMode(p)           (p)->lpVtbl->RestoreDisplayMode(p)
#define IDirectDraw3_SetCooperativeLevel(p, a, b)    (p)->lpVtbl->SetCooperativeLevel(p, a, b)
#define IDirectDraw3_SetDisplayMode(p, a, b, c, d, e) (p)->lpVtbl->SetDisplayMode(p, a, b, c, d, e)
#define IDirectDraw3_WaitForVerticalBlank(p, a, b)   (p)->lpVtbl->WaitForVerticalBlank(p, a, b)
#define IDirectDraw3_GetAvailableVidMem(p, a, b, c)  (p)->lpVtbl->GetAvailableVidMem(p, a, b, c)
#define IDirectDraw3_GetSurfaceFromDC(p, a, b)       (p)->lpVtbl->GetSurfaceFromDC(p, a, b)
#endif

 

/*===========================================================================
 *
 *
 * DIRECTDRAWEX RETURN CODES
 *
 * The return values from DirectDrawEx Commands and Surface that return an
 * HRESULT are codes from DirectDrawEx concerning the results of the action
 * requested by DirectDrawEx.
 *
 *==========================================================================*/

/*
 * An attempt was made to load ddraw.dll
 */
#define DDERR_LOADFAILED                        MAKE_DDHRESULT( 901 )

/*
 * Unable to determine module/os version number
 */
#define DDERR_BADVERSIONINFO                    MAKE_DDHRESULT( 902 )

/*
 * Unable to determine address of ddraw.dll exported symbol (DirectDrawCreate or
 * DirectDrawEnumerate).
 */
#define DDERR_BADPROCADDRESS                    MAKE_DDHRESULT( 903 )

/*
 * Legacy usage: do not use QI() to create D3D device objects from surface objects.  
 * Use IDirect3D2::CreateDevice()
 */
#define DDERR_LEGACYUSAGE                       MAKE_DDHRESULT( 904 )

#ifdef __cplusplus
}
#endif


#endif // __DDRAWEXH__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\delayhlp.cpp ===
#define STRICT
#include <windows.h>
#pragma hdrstop
#include "delayImp.h"

extern "C"
PUnloadInfo __puiHead = 0;

struct ULI : public UnloadInfo {
    ULI(PCImgDelayDescr pidd_) {
        pidd = pidd_;
        Link();
        }

    ~ULI() {
        Unlink();
        }

    void *
    operator new(unsigned int cb) {
        return ::LocalAlloc(LPTR, cb);
        }

    void
    operator delete(void * pv) {
        ::LocalFree(pv);
        }

    void
    Unlink() {
        PUnloadInfo *   ppui = &__puiHead;

        while (*ppui && *ppui != this) {
            ppui = &((*ppui)->puiNext);
            }
        if (*ppui == this) {
            *ppui = puiNext;
            }
        }

    void
    Link() {
        puiNext = __puiHead;
        __puiHead = this;
        }
    };

static inline
PIMAGE_NT_HEADERS WINAPI
PinhFromImageBase(HMODULE);

static inline
DWORD WINAPI
TimeStampOfImage(PIMAGE_NT_HEADERS);

static inline
void WINAPI
OverlayIAT(PImgThunkData pitdDst, PCImgThunkData pitdSrc);

static inline
bool WINAPI
FLoadedAtPreferredAddress(PIMAGE_NT_HEADERS, HMODULE);

extern "C"
FARPROC WINAPI
__delayLoadHelper(
    PCImgDelayDescr pidd,
    FARPROC *       ppfnIATEntry
    ) {

    // Set up some data we use for the hook procs but also useful for
    // our own use
    //
    DelayLoadInfo   dli = {
        sizeof DelayLoadInfo,
        pidd,
        ppfnIATEntry,
        pidd->szName,
            { 0 },
        0,
        0,
        0
        };

    HMODULE hmod = *(pidd->phmod);

    // Calculate the index for the name in the import name table.
    // N.B. it is ordered the same as the IAT entries so the calculation
    // comes from the IAT side.
    //
    unsigned        iINT;
    iINT = IndexFromPImgThunkData(PCImgThunkData(ppfnIATEntry), pidd->pIAT);

    PCImgThunkData  pitd = &((pidd->pINT)[iINT]);

    if (dli.dlp.fImportByName = ((pitd->u1.Ordinal & IMAGE_ORDINAL_FLAG) == 0)) {
        dli.dlp.szProcName = LPCSTR(pitd->u1.AddressOfData->Name);
        }
    else {
        dli.dlp.dwOrdinal = IMAGE_ORDINAL(pitd->u1.Ordinal);
        }

    // Call the initial hook.  If it exists and returns a function pointer,
    // abort the rest of the processing and just return it for the call.
    //
    FARPROC pfnRet = NULL;

    if (__pfnDliNotifyHook) {
        if (pfnRet = ((*__pfnDliNotifyHook)(dliStartProcessing, &dli))) {
            goto HookBypass;
            }
        }

    if (hmod == 0) {
        if (__pfnDliNotifyHook) {
            hmod = HMODULE(((*__pfnDliNotifyHook)(dliNotePreLoadLibrary, &dli)));
            }
        if (hmod == 0) {
            hmod = ::LoadLibrary(dli.szDll);
            }
        if (hmod == 0) {
            dli.dwLastError = ::GetLastError();
            if (__pfnDliFailureHook) {
                // when the hook is called on LoadLibrary failure, it will
                // return 0 for failure and an hmod for the lib if it fixed
                // the problem.
                //
                hmod = HMODULE((*__pfnDliFailureHook)(dliFailLoadLib, &dli));
                }

            if (hmod == 0) {
                PDelayLoadInfo  pdli = &dli;

                RaiseException(
                    VcppException(ERROR_SEVERITY_ERROR, ERROR_MOD_NOT_FOUND),
                    0,
                    1,
                    PDWORD(&pdli)
                    );
                
                // If we get to here, we blindly assume that the handler of the exception
                // has magically fixed everything up and left the function pointer in 
                // dli.pfnCur.
                //
                return dli.pfnCur;
                }
            }

        // Store the library handle.  If it is already there, we infer
        // that another thread got there first, and we need to do a
        // FreeLibrary() to reduce the refcount
        //
        HMODULE hmodT = HMODULE(::InterlockedExchange(LPLONG(pidd->phmod), LONG(hmod)));
        if (hmodT != hmod) {
            // add lib to unload list if we have unload data
            if (pidd->pUnloadIAT) {
                ULI *   puli = new ULI(pidd);
                (void *)puli;
                }
            }
        else {
            ::FreeLibrary(hmod);
            }
        
        }

    // Go for the procedure now.
    dli.hmodCur = hmod;
    if (__pfnDliNotifyHook) {
        pfnRet = (*__pfnDliNotifyHook)(dliNotePreGetProcAddress, &dli);
        }
    if (pfnRet == 0) {
        if (pidd->pBoundIAT && pidd->dwTimeStamp) {
            // bound imports exist...check the timestamp from the target image
            PIMAGE_NT_HEADERS   pinh(PinhFromImageBase(hmod));

            if (pinh->Signature == IMAGE_NT_SIGNATURE &&
                TimeStampOfImage(pinh) == pidd->dwTimeStamp &&
                FLoadedAtPreferredAddress(pinh, hmod)) {

                OverlayIAT(pidd->pIAT, pidd->pBoundIAT);
                pfnRet = FARPROC(pidd->pIAT[iINT].u1.Function);
                goto HookBypass;
                }
            }

        pfnRet = ::GetProcAddress(hmod, dli.dlp.szProcName);
        }

    if (pfnRet == 0) {
        dli.dwLastError = ::GetLastError();
        if (__pfnDliFailureHook) {
            // when the hook is called on GetProcAddress failure, it will
            // return 0 on failure and a valid proc address on success
            //
            pfnRet = (*__pfnDliFailureHook)(dliFailGetProc, &dli);
            }
        if (pfnRet == 0) {
            PDelayLoadInfo  pdli = &dli;

            RaiseException(
                VcppException(ERROR_SEVERITY_ERROR, ERROR_PROC_NOT_FOUND),
                0,
                1,
                PDWORD(&pdli)
                );

            // If we get to here, we blindly assume that the handler of the exception
            // has magically fixed everything up and left the function pointer in 
            // dli.pfnCur.
            //
            pfnRet = dli.pfnCur;
            }
        }


    *ppfnIATEntry = pfnRet;

HookBypass:
    if (__pfnDliNotifyHook) {
        dli.dwLastError = 0;
        dli.hmodCur = hmod;
        dli.pfnCur = pfnRet;
        (*__pfnDliNotifyHook)(dliNoteEndProcessing, &dli);
        }
    return pfnRet;
    }


#pragma intrinsic(strlen,memcmp,memcpy)

extern "C"
BOOL WINAPI
__FUnloadDelayLoadedDLL(LPCSTR szDll) {
    
    BOOL        fRet = FALSE;
    PUnloadInfo pui = __puiHead;
    
    for (pui = __puiHead; pui; pui = pui->puiNext) {
        if (memcmp(szDll, pui->pidd->szName, strlen(pui->pidd->szName)) == 0) {
            break;
            }
        }

    if (pui && pui->pidd->pUnloadIAT) {
        PCImgDelayDescr pidd = pui->pidd;
        HMODULE         hmod = *pidd->phmod;

        OverlayIAT(pidd->pIAT, pidd->pUnloadIAT);
        ::FreeLibrary(hmod);
        *pidd->phmod = NULL;
        
        delete reinterpret_cast<ULI*> (pui);

        fRet = TRUE;
        }

    return fRet;
    }

static inline
PIMAGE_NT_HEADERS WINAPI
PinhFromImageBase(HMODULE hmod) {
    return PIMAGE_NT_HEADERS(PCHAR(hmod) + PIMAGE_DOS_HEADER(hmod)->e_lfanew);
    }

static inline
void WINAPI
OverlayIAT(PImgThunkData pitdDst, PCImgThunkData pitdSrc) {
    memcpy(pitdDst, pitdSrc, CountOfImports(pitdDst) * sizeof IMAGE_THUNK_DATA);
    }

static inline
DWORD WINAPI
TimeStampOfImage(PIMAGE_NT_HEADERS pinh) {
    return pinh->FileHeader.TimeDateStamp;
    }

static inline
bool WINAPI
FLoadedAtPreferredAddress(PIMAGE_NT_HEADERS pinh, HMODULE hmod) {
    return DWORD(hmod) == pinh->OptionalHeader.ImageBase;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\ddkernel.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	ddkernel.h
 *  Content:	APIs for accessing kernel mode support.
 *
 ***************************************************************************/

#ifndef __DDKM_INCLUDED__
#define __DDKM_INCLUDED__
#if defined( _WIN32 )  && !defined( _NO_COM )
#define COM_NO_WINDOWS_H
#include <objbase.h>
#else
#define IUnknown	    void
#undef  CO_E_NOTINITIALIZED
#define CO_E_NOTINITIALIZED 0x800401F0L
#endif

#ifdef __cplusplus
extern "C" {
#endif

/*
 * GUIDS used by to get kernel interfaces
 */
#if defined( _WIN32 ) && !defined( _NO_COM )
DEFINE_GUID( IID_IDirectDrawKernel,             0x8D56C120,0x6A08,0x11D0,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8 );
DEFINE_GUID( IID_IDirectDrawSurfaceKernel,      0x60755DA0,0x6A40,0x11D0,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8 );

#endif

/*============================================================================
 *
 * DirectDraw Structures
 *
 * Various structures used to invoke the kernel API functions.
 *
 *==========================================================================*/

typedef struct IDirectDrawKernel		FAR *LPDIRECTDRAWKERNEL;
typedef struct IDirectDrawSurfaceKernel		FAR *LPDIRECTDRAWSURFACEKERNEL;
typedef struct _DDKERNELCAPS			FAR *LPDDKERNELCAPS;


/*
 * INTERACES FOLLOW:
 *	IDirectDrawKernel
 *	IVideoPort
 */

/*
 * IDirectDrawKernel
 */
#if defined( _WIN32 ) && !defined( _NO_COM )
#undef INTERFACE
#define INTERFACE IDirectDrawKernel
DECLARE_INTERFACE_( IDirectDrawKernel, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDraw methods ***/
    STDMETHOD(GetCaps)(THIS_ LPDDKERNELCAPS) PURE;
    STDMETHOD(GetKernelHandle)(THIS_ LPDWORD) PURE;
    STDMETHOD(ReleaseKernelHandle)(THIS) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectDrawKernel_GetCaps(p, a)             (p)->lpVtbl->GetCaps(p, a)
#define IDirectDrawKernel_GetKernelHandle(p, a)     (p)->lpVtbl->GetKernelHandle(p, a)
#define IDirectDrawKernel_ReleaseKernelHandle(p)    (p)->lpVtbl->ReleaseKernelHandle(p)
#endif

#endif

/*
 * IDirectDrawSurfaceKernel
 */
#if defined( _WIN32 ) && !defined( _NO_COM )
#undef INTERFACE
#define INTERFACE IDirectDrawSurfaceKernel
DECLARE_INTERFACE_( IDirectDrawSurfaceKernel, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDraw methods ***/
    STDMETHOD(GetKernelHandle)(THIS_ LPDWORD) PURE;
    STDMETHOD(ReleaseKernelHandle)(THIS) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectDrawSurfaceKernel_GetKernelHandle(p, a)     (p)->lpVtbl->GetKernelHandle(p, a)
#define IDirectDrawSurfaceKernel_ReleaseKernelHandle(p)    (p)->lpVtbl->ReleaseKernelHandle(p)
#endif

#endif


/*
 * DDKERNELCAPS
 */
typedef struct _DDKERNELCAPS
{
    DWORD dwSize;			// size of the DDKERNELCAPS structure
    DWORD dwCaps;			// indicates which fields contain data
    DWORD dwIRQCaps;			// max width of the video port field
} DDKERNELCAPS, FAR *LPDDKERNELCAPS;



/****************************************************************************
 *
 * DDKERNELCAPS CAPS
 *
 ****************************************************************************/

/*
 * Indicates that the device supports field skipping.
 */
#define DDKERNELCAPS_SKIPFIELDS			0x00000001l

/*
 * Indicates that the device can support software autoflipping.
 */
#define DDKERNELCAPS_AUTOFLIP			0x00000002l

/*
 * Indicates that the device can switch between bob and weave.
 */
#define DDKERNELCAPS_SETSTATE			0x00000004l

/*
 * Indicates that a client can gain direct access to the frame buffer.
 */
#define DDKERNELCAPS_LOCK			0x00000008l

/*
 * Indicates that a client can manually flip the video port.
 */
#define DDKERNELCAPS_FLIPVIDEOPORT		0x00000010l

/*
 * Indicates that a client can manually flip the overlay.
 */
#define DDKERNELCAPS_FLIPOVERLAY		0x00000020l

/*
 * Indicates that the device supports a fast, asynchronous transfer
 * mechanism to system memory.
 */
#define DDKERNELCAPS_TRANSFER_SYSMEM		0x00000040l

/*
 * Indicates that the device supports a fast, asynchronous transfer
 * mechanism via AGP.
 */
#define DDKERNELCAPS_TRANSFER_AGP		0x00000080l

/*
 * Indicates that the device can report the polarity (even/odd) of
 * the curent video field.
 */
#define DDKERNELCAPS_FIELDPOLARITY		0x00000100l

/****************************************************************************
 *
 * DDKERNELCAPS IRQ CAPS
 *
 ****************************************************************************/

/*
 * The device can generate display VSYNC IRQs
 */
#define DDIRQ_DISPLAY_VSYNC			0x00000001l

/*
 * Reserved
 */
#define DDIRQ_RESERVED1				0x00000002l

/*
 * The device can generate video ports VSYNC IRQs using video port 0
 */
#define DDIRQ_VPORT0_VSYNC			0x00000004l

/*
 * The device can generate video ports line IRQs using video port 0
 */
#define DDIRQ_VPORT0_LINE			0x00000008l

/*
 * The device can generate video ports VSYNC IRQs using video port 1
 */
#define DDIRQ_VPORT1_VSYNC			0x00000010l

/*
 * The device can generate video ports line IRQs using video port 1
 */
#define DDIRQ_VPORT1_LINE			0x00000020l

/*
 * The device can generate video ports VSYNC IRQs using video port 2
 */
#define DDIRQ_VPORT2_VSYNC			0x00000040l

/*
 * The device can generate video ports line IRQs using video port 2
 */
#define DDIRQ_VPORT2_LINE			0x00000080l

/*
 * The device can generate video ports VSYNC IRQs using video port 3
 */
#define DDIRQ_VPORT3_VSYNC			0x00000100l

/*
 * The device can generate video ports line IRQs using video port 3
 */
#define DDIRQ_VPORT3_LINE			0x00000200l

/*
 * The device can generate video ports VSYNC IRQs using video port 4
 */
#define DDIRQ_VPORT4_VSYNC			0x00000400l

/*
 * The device can generate video ports line IRQs using video port 4
 */
#define DDIRQ_VPORT4_LINE			0x00000800l

/*
 * The device can generate video ports VSYNC IRQs using video port 5
 */
#define DDIRQ_VPORT5_VSYNC			0x00001000l

/*
 * The device can generate video ports line IRQs using video port 5
 */
#define DDIRQ_VPORT5_LINE			0x00002000l

/*
 * The device can generate video ports VSYNC IRQs using video port 6
 */
#define DDIRQ_VPORT6_VSYNC			0x00004000l

/*
 * The device can generate video ports line IRQs using video port 6
 */
#define DDIRQ_VPORT6_LINE			0x00008000l

/*
 * The device can generate video ports VSYNC IRQs using video port 7
 */
#define DDIRQ_VPORT7_VSYNC			0x00010000l

/*
 * The device can generate video ports line IRQs using video port 7
 */
#define DDIRQ_VPORT7_LINE			0x00020000l

/*
 * The device can generate video ports VSYNC IRQs using video port 8
 */
#define DDIRQ_VPORT8_VSYNC			0x00040000l

/*
 * The device can generate video ports line IRQs using video port 8
 */
#define DDIRQ_VPORT8_LINE			0x00080000l

/*
 * The device can generate video ports VSYNC IRQs using video port 9
 */
#define DDIRQ_VPORT9_VSYNC			0x00010000l

/*
 * The device can generate video ports line IRQs using video port 9
 */
#define DDIRQ_VPORT9_LINE			0x00020000l



#ifdef __cplusplus
};
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\dde.h ===
/*****************************************************************************\
*                                                                             *
* dde.h -       Dynamic Data Exchange structures and definitions              *
*                                                                             *
* Copyright (c) 1993-1999, Microsoft Corp.	All rights reserved	      *
*                                                                             *
\*****************************************************************************/
#ifndef _DDEHEADER_INCLUDED_
#define _DDEHEADER_INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _WINDEF_
#include <windef.h>
#endif

#ifdef __cplusplus
extern "C" {
#endif

// begin_r_dde

/* DDE window messages */

#define WM_DDE_FIRST	    0x03E0
#define WM_DDE_INITIATE     (WM_DDE_FIRST)
#define WM_DDE_TERMINATE    (WM_DDE_FIRST+1)
#define WM_DDE_ADVISE	    (WM_DDE_FIRST+2)
#define WM_DDE_UNADVISE     (WM_DDE_FIRST+3)
#define WM_DDE_ACK	        (WM_DDE_FIRST+4)
#define WM_DDE_DATA	        (WM_DDE_FIRST+5)
#define WM_DDE_REQUEST	    (WM_DDE_FIRST+6)
#define WM_DDE_POKE	        (WM_DDE_FIRST+7)
#define WM_DDE_EXECUTE	    (WM_DDE_FIRST+8)
#define WM_DDE_LAST	        (WM_DDE_FIRST+8)

// end_r_dde

/*----------------------------------------------------------------------------
|       DDEACK structure
|
|	Structure of wStatus (LOWORD(lParam)) in WM_DDE_ACK message
|       sent in response to a WM_DDE_DATA, WM_DDE_REQUEST, WM_DDE_POKE,
|       WM_DDE_ADVISE, or WM_DDE_UNADVISE message.
|
----------------------------------------------------------------------------*/

typedef struct {
#ifndef _MAC
        unsigned short bAppReturnCode:8,
                 reserved:6,
                 fBusy:1,
		 fAck:1;
#else
        unsigned short usFlags;
#endif
} DDEACK;


/*----------------------------------------------------------------------------
|       DDEADVISE structure
|
|	WM_DDE_ADVISE parameter structure for hOptions (LOWORD(lParam))
|
----------------------------------------------------------------------------*/

typedef struct {
#ifndef _MAC
        unsigned short reserved:14,
                 fDeferUpd:1,
		 fAckReq:1;
#else
        unsigned short usFlags;
#endif
	short     cfFormat;
} DDEADVISE;


/*----------------------------------------------------------------------------
|       DDEDATA structure
|
|       WM_DDE_DATA parameter structure for hData (LOWORD(lParam)).
|       The actual size of this structure depends on the size of
|       the Value array.
|
----------------------------------------------------------------------------*/

typedef struct {
#ifndef _MAC
	unsigned short unused:12,
                 fResponse:1,
                 fRelease:1,
                 reserved:1,
                 fAckReq:1;
#else
	unsigned short usFlags;
#endif
	short	 cfFormat;
	BYTE	 Value[1];
} DDEDATA;


/*----------------------------------------------------------------------------
|	DDEPOKE structure
|
|	WM_DDE_POKE parameter structure for hData (LOWORD(lParam)).
|       The actual size of this structure depends on the size of
|       the Value array.
|
----------------------------------------------------------------------------*/

typedef struct {
#ifndef _MAC
	unsigned short unused:13,  /* Earlier versions of DDE.H incorrectly */
                             /* 12 unused bits.                       */
		 fRelease:1,
		 fReserved:2;
#else
	unsigned short usFlags;
#endif
	short    cfFormat;
	BYTE	 Value[1];  /* This member was named rgb[1] in previous */
                            /* versions of DDE.H                        */

} DDEPOKE;

/*----------------------------------------------------------------------------
The following typedef's were used in previous versions of the Windows SDK.
They are still valid.  The above typedef's define exactly the same structures
as those below.  The above typedef names are recommended, however, as they
are more meaningful.

Note that the DDEPOKE structure typedef'ed in earlier versions of DDE.H did
not correctly define the bit positions.
----------------------------------------------------------------------------*/

typedef struct {
#ifndef _MAC
        unsigned short unused:13,
                 fRelease:1,
                 fDeferUpd:1,
		 fAckReq:1;
#else
	unsigned short usFlags;
#endif
	short	 cfFormat;
} DDELN;

typedef struct {
#ifndef _MAC
	unsigned short unused:12,
                 fAck:1,
                 fRelease:1,
                 fReserved:1,
                 fAckReq:1;
#else
	unsigned short usFlags;
#endif
	short	 cfFormat;
	BYTE	 rgb[1];
} DDEUP;


/*
 * DDE SECURITY
 */

BOOL
WINAPI
DdeSetQualityOfService(
    HWND hwndClient,
    CONST SECURITY_QUALITY_OF_SERVICE *pqosNew,
    PSECURITY_QUALITY_OF_SERVICE pqosPrev);

BOOL
WINAPI
ImpersonateDdeClientWindow(
    HWND hWndClient,
    HWND hWndServer);

/*
 * DDE message packing APIs
 */
LPARAM APIENTRY PackDDElParam(UINT msg, UINT_PTR uiLo, UINT_PTR uiHi);
BOOL   APIENTRY UnpackDDElParam(UINT msg, LPARAM lParam, PUINT_PTR puiLo, PUINT_PTR puiHi);
BOOL   APIENTRY FreeDDElParam(UINT msg, LPARAM lParam);
LPARAM APIENTRY ReuseDDElParam(LPARAM lParam, UINT msgIn, UINT msgOut, UINT_PTR uiLo, UINT_PTR uiHi);

#ifdef __cplusplus
}
#endif

#endif // _DDEHEADER_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\delayimp.h ===
//
// DelayImp.h
//
//  define structures and prototypes necessary for delay loading of imports
//
#pragma once
#if !defined(_delayimp_h)
#define _delayimp_h

#if defined(__cplusplus)
#define ExternC extern "C"
#else
#define ExternC
#endif

typedef IMAGE_THUNK_DATA *          PImgThunkData;
typedef const IMAGE_THUNK_DATA *    PCImgThunkData;

typedef struct ImgDelayDescr {
    DWORD           grAttrs;        // attributes
    LPCSTR          szName;         // pointer to dll name
    HMODULE *       phmod;          // address of module handle
    PImgThunkData   pIAT;           // address of the IAT
    PCImgThunkData  pINT;           // address of the INT
    PCImgThunkData  pBoundIAT;      // address of the optional bound IAT
    PCImgThunkData  pUnloadIAT;     // address of optional copy of original IAT
    DWORD           dwTimeStamp;    // 0 if not bound,
                                    // O.W. date/time stamp of DLL bound to (Old BIND)
    } ImgDelayDescr, * PImgDelayDescr;

typedef const ImgDelayDescr *   PCImgDelayDescr;

//
// Delay load import hook notifications
//
enum {
    dliStartProcessing,             // used to bypass or note helper only
    dliNotePreLoadLibrary,          // called just before LoadLibrary, can
                                    //  override w/ new HMODULE return val
    dliNotePreGetProcAddress,       // called just before GetProcAddress, can
                                    //  override w/ new FARPROC return value
    dliFailLoadLib,                 // failed to load library, fix it by
                                    //  returning a valid HMODULE
    dliFailGetProc,                 // failed to get proc address, fix it by
                                    //  returning a valid FARPROC
    dliNoteEndProcessing,           // called after all processing is done, no
                                    //  no bypass possible at this point except
                                    //  by longjmp()/throw()/RaiseException.
    };

typedef struct DelayLoadProc {
    BOOL                fImportByName;
    union {
        LPCSTR          szProcName;
        DWORD           dwOrdinal;
        };
    } DelayLoadProc;

typedef struct DelayLoadInfo {
    DWORD               cb;         // size of structure
    PCImgDelayDescr     pidd;       // raw form of data (everything is there)
    FARPROC *           ppfn;       // points to address of function to load
    LPCSTR              szDll;      // name of dll
    DelayLoadProc       dlp;        // name or ordinal of procedure
    HMODULE             hmodCur;    // the hInstance of the library we have loaded
    FARPROC             pfnCur;     // the actual function that will be called
    DWORD               dwLastError;// error received (if an error notification)
    } DelayLoadInfo, * PDelayLoadInfo;

typedef FARPROC (WINAPI *PfnDliHook)(
    unsigned        dliNotify,
    PDelayLoadInfo  pdli
    );

// utility function for calculating the index of the current import
// for all the tables (INT, BIAT, UIAT, and IAT).
__inline unsigned
IndexFromPImgThunkData(PCImgThunkData pitdCur, PCImgThunkData pitdBase) {
    return pitdCur - pitdBase;
    }

//
// Unload support
//

// routine definition; takes a pointer to a name to unload, or NULL to
// unload all the delay load dlls in the list.
//
ExternC
BOOL WINAPI
__FUnloadDelayLoadedDLL(LPCSTR szDll);

// structure definitions for the list of unload records
typedef struct UnloadInfo * PUnloadInfo;
typedef struct UnloadInfo {
    PUnloadInfo     puiNext;
    PCImgDelayDescr pidd;
    } UnloadInfo;

// the default delay load helper places the unloadinfo records in the list
// headed by the following pointer.
ExternC
extern
PUnloadInfo __puiHead;

//
// Exception information
//
#define FACILITY_VISUALCPP  ((LONG)0x6d)
#define VcppException(sev,err)  ((sev) | (FACILITY_VISUALCPP<<16) | err)

// utility function for calculating the count of imports given the base
// of the IAT.  NB: this only works on a valid IAT!
__inline unsigned
CountOfImports(PCImgThunkData pitdBase) {
    unsigned        cRet = 0;
    PCImgThunkData  pitd = pitdBase;
    while (pitd->u1.Function) {
        pitd++;
        cRet++;
        }
    return cRet;
    }

//
// Hook pointers
//

// The "notify hook" gets called for every call to the
// delay load helper.  This allows a user to hook every call and
// skip the delay load helper entirely.
//
// dliNotify == {
//  dliStartProcessing |
//  dliPreLoadLibrary  |
//  dliPreGetProc |
//  dliNoteEndProcessing}
//  on this call.
//
ExternC
extern
PfnDliHook   __pfnDliNotifyHook;

// This is the failure hook, dliNotify = {dliFailLoadLib|dliFailGetProc}
ExternC
extern
PfnDliHook   __pfnDliFailureHook;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\ddeml.h ===
/*++ BUILD Version: 0001 // Increment this if a change has global effects --*/

/*****************************************************************************\
*                                                                             *
*  ddeml.h -    DDEML API header file                                         *
*                                                                             *
*               Version 3.10                                                  *
*                                                                             *
*               Copyright (c) 1993-1999, Microsoft Corp.  All rights reserved.*
*                                                                             *
\*****************************************************************************/
#ifndef _INC_DDEMLH
#define _INC_DDEMLH

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

/******** public types ********/

DECLARE_HANDLE(HCONVLIST);
DECLARE_HANDLE(HCONV);
DECLARE_HANDLE(HSZ);
DECLARE_HANDLE(HDDEDATA);
#define EXPENTRY        CALLBACK

/* the following structure is for use with XTYP_WILDCONNECT processing. */

typedef struct tagHSZPAIR {
    HSZ hszSvc;
    HSZ hszTopic;
} HSZPAIR;
typedef HSZPAIR FAR *PHSZPAIR;

/* The following structure is used by DdeConnect() and DdeConnectList() and
   by XTYP_CONNECT and XTYP_WILDCONNECT callbacks. */

typedef struct tagCONVCONTEXT {
    UINT        cb;             /* set to sizeof(CONVCONTEXT) */
    UINT        wFlags;         /* none currently defined. */
    UINT        wCountryID;     /* country code for topic/item strings used. */
    int         iCodePage;      /* codepage used for topic/item strings. */
    DWORD       dwLangID;       /* language ID for topic/item strings. */
    DWORD       dwSecurity;     /* Private security code. */
    SECURITY_QUALITY_OF_SERVICE qos;  /* client side's quality of service */
} CONVCONTEXT;
typedef CONVCONTEXT FAR *PCONVCONTEXT;


/* The following structure is used by DdeQueryConvInfo(): */

typedef struct tagCONVINFO {
    DWORD   cb;            /* sizeof(CONVINFO)  */
    DWORD_PTR hUser;       /* user specified field  */
    HCONV   hConvPartner;  /* hConv on other end or 0 if non-ddemgr partner  */
    HSZ     hszSvcPartner; /* app name of partner if obtainable  */
    HSZ     hszServiceReq; /* AppName requested for connection  */
    HSZ     hszTopic;      /* Topic name for conversation  */
    HSZ     hszItem;       /* transaction item name or NULL if quiescent  */
    UINT    wFmt;          /* transaction format or NULL if quiescent  */
    UINT    wType;         /* XTYP_ for current transaction  */
    UINT    wStatus;       /* ST_ constant for current conversation  */
    UINT    wConvst;       /* XST_ constant for current transaction  */
    UINT    wLastError;    /* last transaction error.  */
    HCONVLIST hConvList;   /* parent hConvList if this conversation is in a list */
    CONVCONTEXT ConvCtxt;  /* conversation context */
    HWND    hwnd;          /* window handle for this conversation */
    HWND    hwndPartner;   /* partner window handle for this conversation */
} CONVINFO;
typedef CONVINFO FAR *PCONVINFO;

/***** conversation states (usState) *****/

#define     XST_NULL              0  /* quiescent states */
#define     XST_INCOMPLETE        1
#define     XST_CONNECTED         2
#define     XST_INIT1             3  /* mid-initiation states */
#define     XST_INIT2             4
#define     XST_REQSENT           5  /* active conversation states */
#define     XST_DATARCVD          6
#define     XST_POKESENT          7
#define     XST_POKEACKRCVD       8
#define     XST_EXECSENT          9
#define     XST_EXECACKRCVD      10
#define     XST_ADVSENT          11
#define     XST_UNADVSENT        12
#define     XST_ADVACKRCVD       13
#define     XST_UNADVACKRCVD     14
#define     XST_ADVDATASENT      15
#define     XST_ADVDATAACKRCVD   16

/* used in LOWORD(dwData1) of XTYP_ADVREQ callbacks... */
#define     CADV_LATEACK         0xFFFF

/***** conversation status bits (fsStatus) *****/

#define     ST_CONNECTED            0x0001
#define     ST_ADVISE               0x0002
#define     ST_ISLOCAL              0x0004
#define     ST_BLOCKED              0x0008
#define     ST_CLIENT               0x0010
#define     ST_TERMINATED           0x0020
#define     ST_INLIST               0x0040
#define     ST_BLOCKNEXT            0x0080
#define     ST_ISSELF               0x0100

/* DDE constants for wStatus field */

#define DDE_FACK                0x8000
#define DDE_FBUSY               0x4000
#define DDE_FDEFERUPD           0x4000
#define DDE_FACKREQ             0x8000
#define DDE_FRELEASE            0x2000
#define DDE_FREQUESTED          0x1000
#define DDE_FAPPSTATUS          0x00ff
#define DDE_FNOTPROCESSED       0x0000

#define DDE_FACKRESERVED        (~(DDE_FACK | DDE_FBUSY | DDE_FAPPSTATUS))
#define DDE_FADVRESERVED        (~(DDE_FACKREQ | DDE_FDEFERUPD))
#define DDE_FDATRESERVED        (~(DDE_FACKREQ | DDE_FRELEASE | DDE_FREQUESTED))
#define DDE_FPOKRESERVED        (~(DDE_FRELEASE))

/***** message filter hook types *****/

#define     MSGF_DDEMGR             0x8001

/***** codepage constants ****/

#define CP_WINANSI      1004    /* default codepage for windows & old DDE convs. */
#define CP_WINUNICODE   1200
#ifdef UNICODE
#define CP_WINNEUTRAL   CP_WINUNICODE
#else  // !UNICODE
#define CP_WINNEUTRAL   CP_WINANSI
#endif // !UNICODE

/***** transaction types *****/

#define     XTYPF_NOBLOCK            0x0002  /* CBR_BLOCK will not work */
#define     XTYPF_NODATA             0x0004  /* DDE_FDEFERUPD */
#define     XTYPF_ACKREQ             0x0008  /* DDE_FACKREQ */

#define     XCLASS_MASK              0xFC00
#define     XCLASS_BOOL              0x1000
#define     XCLASS_DATA              0x2000
#define     XCLASS_FLAGS             0x4000
#define     XCLASS_NOTIFICATION      0x8000

#define     XTYP_ERROR              (0x0000 | XCLASS_NOTIFICATION | XTYPF_NOBLOCK )
#define     XTYP_ADVDATA            (0x0010 | XCLASS_FLAGS         )
#define     XTYP_ADVREQ             (0x0020 | XCLASS_DATA | XTYPF_NOBLOCK )
#define     XTYP_ADVSTART           (0x0030 | XCLASS_BOOL          )
#define     XTYP_ADVSTOP            (0x0040 | XCLASS_NOTIFICATION)
#define     XTYP_EXECUTE            (0x0050 | XCLASS_FLAGS         )
#define     XTYP_CONNECT            (0x0060 | XCLASS_BOOL | XTYPF_NOBLOCK)
#define     XTYP_CONNECT_CONFIRM    (0x0070 | XCLASS_NOTIFICATION | XTYPF_NOBLOCK)
#define     XTYP_XACT_COMPLETE      (0x0080 | XCLASS_NOTIFICATION  )
#define     XTYP_POKE               (0x0090 | XCLASS_FLAGS         )
#define     XTYP_REGISTER           (0x00A0 | XCLASS_NOTIFICATION | XTYPF_NOBLOCK)
#define     XTYP_REQUEST            (0x00B0 | XCLASS_DATA          )
#define     XTYP_DISCONNECT         (0x00C0 | XCLASS_NOTIFICATION | XTYPF_NOBLOCK)
#define     XTYP_UNREGISTER         (0x00D0 | XCLASS_NOTIFICATION | XTYPF_NOBLOCK)
#define     XTYP_WILDCONNECT        (0x00E0 | XCLASS_DATA | XTYPF_NOBLOCK)

#define     XTYP_MASK                0x00F0
#define     XTYP_SHIFT               4  /* shift to turn XTYP_ into an index */

/***** Timeout constants *****/

#define     TIMEOUT_ASYNC           0xFFFFFFFF

/***** Transaction ID constants *****/

#define     QID_SYNC                0xFFFFFFFF

/****** public strings used in DDE ******/

#ifdef UNICODE
#define SZDDESYS_TOPIC         L"System"
#define SZDDESYS_ITEM_TOPICS   L"Topics"
#define SZDDESYS_ITEM_SYSITEMS L"SysItems"
#define SZDDESYS_ITEM_RTNMSG   L"ReturnMessage"
#define SZDDESYS_ITEM_STATUS   L"Status"
#define SZDDESYS_ITEM_FORMATS  L"Formats"
#define SZDDESYS_ITEM_HELP     L"Help"
#define SZDDE_ITEM_ITEMLIST    L"TopicItemList"
#else
#define SZDDESYS_TOPIC         "System"
#define SZDDESYS_ITEM_TOPICS   "Topics"
#define SZDDESYS_ITEM_SYSITEMS "SysItems"
#define SZDDESYS_ITEM_RTNMSG   "ReturnMessage"
#define SZDDESYS_ITEM_STATUS   "Status"
#define SZDDESYS_ITEM_FORMATS  "Formats"
#define SZDDESYS_ITEM_HELP     "Help"
#define SZDDE_ITEM_ITEMLIST    "TopicItemList"
#endif


/****** API entry points ******/

typedef HDDEDATA CALLBACK FNCALLBACK(UINT wType, UINT wFmt, HCONV hConv,
        HSZ hsz1, HSZ hsz2, HDDEDATA hData, ULONG_PTR dwData1, ULONG_PTR dwData2);
typedef HDDEDATA (CALLBACK *PFNCALLBACK)(UINT wType, UINT wFmt, HCONV hConv,
        HSZ hsz1, HSZ hsz2, HDDEDATA hData, ULONG_PTR dwData1, ULONG_PTR dwData2);

#define     CBR_BLOCK           ((HDDEDATA)0xffffffffL)

/* DLL registration functions */

UINT WINAPI DdeInitializeA( IN OUT LPDWORD pidInst, IN PFNCALLBACK pfnCallback,
        IN DWORD afCmd, IN DWORD ulRes);
UINT WINAPI DdeInitializeW( IN OUT LPDWORD pidInst, IN PFNCALLBACK pfnCallback,
        IN DWORD afCmd, IN DWORD ulRes);
#ifdef UNICODE
#define DdeInitialize  DdeInitializeW
#else
#define DdeInitialize  DdeInitializeA
#endif // !UNICODE

/*
 * Callback filter flags for use with standard apps.
 */

#define     CBF_FAIL_SELFCONNECTIONS     0x00001000
#define     CBF_FAIL_CONNECTIONS         0x00002000
#define     CBF_FAIL_ADVISES             0x00004000
#define     CBF_FAIL_EXECUTES            0x00008000
#define     CBF_FAIL_POKES               0x00010000
#define     CBF_FAIL_REQUESTS            0x00020000
#define     CBF_FAIL_ALLSVRXACTIONS      0x0003f000

#define     CBF_SKIP_CONNECT_CONFIRMS    0x00040000
#define     CBF_SKIP_REGISTRATIONS       0x00080000
#define     CBF_SKIP_UNREGISTRATIONS     0x00100000
#define     CBF_SKIP_DISCONNECTS         0x00200000
#define     CBF_SKIP_ALLNOTIFICATIONS    0x003c0000

/*
 * Application command flags
 */
#define     APPCMD_CLIENTONLY            0x00000010L
#define     APPCMD_FILTERINITS           0x00000020L
#define     APPCMD_MASK                  0x00000FF0L

/*
 * Application classification flags
 */
#define     APPCLASS_STANDARD            0x00000000L
#define     APPCLASS_MASK                0x0000000FL

BOOL WINAPI DdeUninitialize( IN DWORD idInst);

/*
 * conversation enumeration functions
 */

HCONVLIST WINAPI DdeConnectList( IN DWORD idInst, IN HSZ hszService, IN HSZ hszTopic,
        IN HCONVLIST hConvList, IN PCONVCONTEXT pCC);
HCONV WINAPI DdeQueryNextServer( IN HCONVLIST hConvList, IN HCONV hConvPrev);
BOOL WINAPI DdeDisconnectList( IN HCONVLIST hConvList);

/*
 * conversation control functions
 */

HCONV WINAPI DdeConnect( IN DWORD idInst, IN HSZ hszService, IN HSZ hszTopic,
        IN PCONVCONTEXT pCC);
BOOL WINAPI DdeDisconnect( IN OUT HCONV hConv);
HCONV WINAPI DdeReconnect( IN HCONV hConv);
UINT WINAPI DdeQueryConvInfo( IN HCONV hConv, IN DWORD idTransaction, IN OUT PCONVINFO pConvInfo);
BOOL WINAPI DdeSetUserHandle( IN HCONV hConv, IN DWORD id, IN DWORD_PTR hUser);
BOOL WINAPI DdeAbandonTransaction( IN DWORD idInst, IN HCONV hConv, IN DWORD idTransaction);


/*
 * app server interface functions
 */

BOOL WINAPI DdePostAdvise( IN DWORD idInst, IN HSZ hszTopic, IN HSZ hszItem);
BOOL WINAPI DdeEnableCallback( IN DWORD idInst, IN HCONV hConv, IN UINT wCmd);
BOOL WINAPI DdeImpersonateClient( IN HCONV hConv);

#define EC_ENABLEALL            0
#define EC_ENABLEONE            ST_BLOCKNEXT
#define EC_DISABLE              ST_BLOCKED
#define EC_QUERYWAITING         2

HDDEDATA WINAPI DdeNameService( IN DWORD idInst, IN HSZ hsz1, IN HSZ hsz2, IN UINT afCmd);

#define DNS_REGISTER        0x0001
#define DNS_UNREGISTER      0x0002
#define DNS_FILTERON        0x0004
#define DNS_FILTEROFF       0x0008

/*
 * app client interface functions
 */

HDDEDATA WINAPI DdeClientTransaction( IN LPBYTE pData, IN DWORD cbData,
        IN HCONV hConv, IN HSZ hszItem, IN UINT wFmt, IN UINT wType,
        IN DWORD dwTimeout, OUT LPDWORD pdwResult);

/*
 *data transfer functions
 */

HDDEDATA WINAPI DdeCreateDataHandle( IN DWORD idInst, IN LPBYTE pSrc, IN DWORD cb,
        IN DWORD cbOff, IN HSZ hszItem, IN UINT wFmt, IN UINT afCmd);
HDDEDATA WINAPI DdeAddData( IN HDDEDATA hData, IN LPBYTE pSrc, IN DWORD cb, IN DWORD cbOff);
DWORD WINAPI DdeGetData( IN HDDEDATA hData, OUT LPBYTE pDst, IN DWORD cbMax, IN DWORD cbOff);
LPBYTE WINAPI DdeAccessData( IN HDDEDATA hData, OUT LPDWORD pcbDataSize);
BOOL WINAPI DdeUnaccessData( IN HDDEDATA hData);
BOOL WINAPI DdeFreeDataHandle( IN OUT HDDEDATA hData);

#define     HDATA_APPOWNED          0x0001


UINT WINAPI DdeGetLastError( IN DWORD idInst);

#define     DMLERR_NO_ERROR                    0       /* must be 0 */

#define     DMLERR_FIRST                       0x4000

#define     DMLERR_ADVACKTIMEOUT               0x4000
#define     DMLERR_BUSY                        0x4001
#define     DMLERR_DATAACKTIMEOUT              0x4002
#define     DMLERR_DLL_NOT_INITIALIZED         0x4003
#define     DMLERR_DLL_USAGE                   0x4004
#define     DMLERR_EXECACKTIMEOUT              0x4005
#define     DMLERR_INVALIDPARAMETER            0x4006
#define     DMLERR_LOW_MEMORY                  0x4007
#define     DMLERR_MEMORY_ERROR                0x4008
#define     DMLERR_NOTPROCESSED                0x4009
#define     DMLERR_NO_CONV_ESTABLISHED         0x400a
#define     DMLERR_POKEACKTIMEOUT              0x400b
#define     DMLERR_POSTMSG_FAILED              0x400c
#define     DMLERR_REENTRANCY                  0x400d
#define     DMLERR_SERVER_DIED                 0x400e
#define     DMLERR_SYS_ERROR                   0x400f
#define     DMLERR_UNADVACKTIMEOUT             0x4010
#define     DMLERR_UNFOUND_QUEUE_ID            0x4011

#define     DMLERR_LAST                        0x4011

HSZ  WINAPI DdeCreateStringHandleA( IN DWORD idInst, IN LPCSTR psz, IN int iCodePage);
HSZ  WINAPI DdeCreateStringHandleW( IN DWORD idInst, IN LPCWSTR psz, IN int iCodePage);
#ifdef UNICODE
#define DdeCreateStringHandle  DdeCreateStringHandleW
#else
#define DdeCreateStringHandle  DdeCreateStringHandleA
#endif // !UNICODE
DWORD WINAPI DdeQueryStringA( IN DWORD idInst, IN HSZ hsz, IN OUT LPSTR psz, IN DWORD cchMax, IN int iCodePage);
DWORD WINAPI DdeQueryStringW( IN DWORD idInst, IN HSZ hsz, IN OUT LPWSTR psz, IN DWORD cchMax, IN int iCodePage);
#ifdef UNICODE
#define DdeQueryString  DdeQueryStringW
#else
#define DdeQueryString  DdeQueryStringA
#endif // !UNICODE
BOOL WINAPI DdeFreeStringHandle( IN DWORD idInst, IN OUT HSZ hsz);
BOOL WINAPI DdeKeepStringHandle( IN DWORD idInst, IN OUT HSZ hsz);
int WINAPI DdeCmpStringHandles( IN HSZ hsz1, IN HSZ hsz2);


#ifndef NODDEMLSPY
/*
 * DDEML public debugging header file info
 */

typedef struct tagDDEML_MSG_HOOK_DATA {    // new for NT
    UINT_PTR uiLo;  // unpacked lo and hi parts of lParam
    UINT_PTR uiHi;
    DWORD cbData;   // amount of data in message, if any. May be > than 32 bytes.
    DWORD Data[8];  // data peeking by DDESPY is limited to 32 bytes.
} DDEML_MSG_HOOK_DATA, *PDDEML_MSG_HOOK_DATA;


typedef struct tagMONMSGSTRUCT {
    UINT    cb;
    HWND    hwndTo;
    DWORD   dwTime;
    HANDLE  hTask;
    UINT    wMsg;
    WPARAM  wParam;
    LPARAM  lParam;
    DDEML_MSG_HOOK_DATA dmhd;       // new for NT
} MONMSGSTRUCT, *PMONMSGSTRUCT;

typedef struct tagMONCBSTRUCT {
    UINT   cb;
    DWORD  dwTime;
    HANDLE hTask;
    DWORD  dwRet;
    UINT   wType;
    UINT   wFmt;
    HCONV  hConv;
    HSZ    hsz1;
    HSZ    hsz2;
    HDDEDATA hData;
    ULONG_PTR dwData1;
    ULONG_PTR dwData2;
    CONVCONTEXT cc;                 // new for NT for XTYP_CONNECT callbacks
    DWORD  cbData;                  // new for NT for data peeking
    DWORD  Data[8];                 // new for NT for data peeking
} MONCBSTRUCT, *PMONCBSTRUCT;

typedef struct tagMONHSZSTRUCTA {
    UINT   cb;
    BOOL   fsAction;    /* MH_ value */
    DWORD  dwTime;
    HSZ    hsz;
    HANDLE hTask;
    CHAR    str[1];
} MONHSZSTRUCTA, *PMONHSZSTRUCTA;
typedef struct tagMONHSZSTRUCTW {
    UINT   cb;
    BOOL   fsAction;    /* MH_ value */
    DWORD  dwTime;
    HSZ    hsz;
    HANDLE hTask;
    WCHAR   str[1];
} MONHSZSTRUCTW, *PMONHSZSTRUCTW;
#ifdef UNICODE
typedef MONHSZSTRUCTW MONHSZSTRUCT;
typedef PMONHSZSTRUCTW PMONHSZSTRUCT;
#else
typedef MONHSZSTRUCTA MONHSZSTRUCT;
typedef PMONHSZSTRUCTA PMONHSZSTRUCT;
#endif // UNICODE

#define MH_CREATE   1
#define MH_KEEP     2
#define MH_DELETE   3
#define MH_CLEANUP  4

typedef struct tagMONERRSTRUCT {
    UINT    cb;
    UINT    wLastError;
    DWORD   dwTime;
    HANDLE  hTask;
} MONERRSTRUCT, *PMONERRSTRUCT;

typedef struct tagMONLINKSTRUCT {
    UINT    cb;
    DWORD   dwTime;
    HANDLE  hTask;
    BOOL    fEstablished;
    BOOL    fNoData;
    HSZ     hszSvc;
    HSZ     hszTopic;
    HSZ     hszItem;
    UINT    wFmt;
    BOOL    fServer;
    HCONV   hConvServer;
    HCONV   hConvClient;
} MONLINKSTRUCT, *PMONLINKSTRUCT;

typedef struct tagMONCONVSTRUCT {
    UINT    cb;
    BOOL    fConnect;
    DWORD   dwTime;
    HANDLE  hTask;
    HSZ     hszSvc;
    HSZ     hszTopic;
    HCONV   hConvClient;        // Globally unique value != apps local hConv
    HCONV   hConvServer;        // Globally unique value != apps local hConv
} MONCONVSTRUCT, *PMONCONVSTRUCT;

#define     MAX_MONITORS            4
#define     APPCLASS_MONITOR        0x00000001L
#define     XTYP_MONITOR            (0x00F0 | XCLASS_NOTIFICATION | XTYPF_NOBLOCK)

/*
 * Callback filter flags for use with MONITOR apps - 0 implies no monitor
 * callbacks.
 */
#define     MF_HSZ_INFO                  0x01000000
#define     MF_SENDMSGS                  0x02000000
#define     MF_POSTMSGS                  0x04000000
#define     MF_CALLBACKS                 0x08000000
#define     MF_ERRORS                    0x10000000
#define     MF_LINKS                     0x20000000
#define     MF_CONV                      0x40000000

#define     MF_MASK                      0xFF000000
#endif /* NODDEMLSPY */

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#endif /* _INC_DDEMLH */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\devguid.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright 1992 - 1998 Microsoft Corporation

Module Name:

    devguid.h

Abstract:

    Defines GUIDs for device classes used in Plug & Play.

Author:

    Lonny McMichael (lonnym) 30-Aug--1995

Revision History:

--*/


DEFINE_GUID( GUID_DEVCLASS_1394,           0x6bdd1fc1L, 0x810f, 0x11d0, 0xbe, 0xc7, 0x08, 0x00, 0x2b, 0xe2, 0x09, 0x2f );
DEFINE_GUID( GUID_DEVCLASS_ADAPTER,        0x4d36e964L, 0xe325, 0x11ce, 0xbf, 0xc1, 0x08, 0x00, 0x2b, 0xe1, 0x03, 0x18 );
DEFINE_GUID( GUID_DEVCLASS_CDROM,          0x4d36e965L, 0xe325, 0x11ce, 0xbf, 0xc1, 0x08, 0x00, 0x2b, 0xe1, 0x03, 0x18 );
DEFINE_GUID( GUID_DEVCLASS_COMPUTER,       0x4d36e966L, 0xe325, 0x11ce, 0xbf, 0xc1, 0x08, 0x00, 0x2b, 0xe1, 0x03, 0x18 );
DEFINE_GUID( GUID_DEVCLASS_DECODER,        0x6bdd1fc2L, 0x810f, 0x11d0, 0xbe, 0xc7, 0x08, 0x00, 0x2b, 0xe2, 0x09, 0x2f );
DEFINE_GUID( GUID_DEVCLASS_DISKDRIVE,      0x4d36e967L, 0xe325, 0x11ce, 0xbf, 0xc1, 0x08, 0x00, 0x2b, 0xe1, 0x03, 0x18 );
DEFINE_GUID( GUID_DEVCLASS_DISPLAY,        0x4d36e968L, 0xe325, 0x11ce, 0xbf, 0xc1, 0x08, 0x00, 0x2b, 0xe1, 0x03, 0x18 );
DEFINE_GUID( GUID_DEVCLASS_FDC,            0x4d36e969L, 0xe325, 0x11ce, 0xbf, 0xc1, 0x08, 0x00, 0x2b, 0xe1, 0x03, 0x18 );
DEFINE_GUID( GUID_DEVCLASS_GPS,            0x6bdd1fc3L, 0x810f, 0x11d0, 0xbe, 0xc7, 0x08, 0x00, 0x2b, 0xe2, 0x09, 0x2f );
DEFINE_GUID( GUID_DEVCLASS_HDC,            0x4d36e96aL, 0xe325, 0x11ce, 0xbf, 0xc1, 0x08, 0x00, 0x2b, 0xe1, 0x03, 0x18 );
DEFINE_GUID( GUID_DEVCLASS_IMAGE,          0x6bdd1fc4L, 0x810f, 0x11d0, 0xbe, 0xc7, 0x08, 0x00, 0x2b, 0xe2, 0x09, 0x2f );
DEFINE_GUID( GUID_DEVCLASS_INFRARED,       0x6bdd1fc5L, 0x810f, 0x11d0, 0xbe, 0xc7, 0x08, 0x00, 0x2b, 0xe2, 0x09, 0x2f );
DEFINE_GUID( GUID_DEVCLASS_KEYBOARD,       0x4d36e96bL, 0xe325, 0x11ce, 0xbf, 0xc1, 0x08, 0x00, 0x2b, 0xe1, 0x03, 0x18 );
DEFINE_GUID( GUID_DEVCLASS_LEGACYDRIVER,   0x8ecc055dL, 0x047f, 0x11d1, 0xa5, 0x37, 0x00, 0x00, 0xf8, 0x75, 0x3e, 0xd1 );
DEFINE_GUID( GUID_DEVCLASS_MEDIA,          0x4d36e96cL, 0xe325, 0x11ce, 0xbf, 0xc1, 0x08, 0x00, 0x2b, 0xe1, 0x03, 0x18 );
DEFINE_GUID( GUID_DEVCLASS_MODEM,          0x4d36e96dL, 0xe325, 0x11ce, 0xbf, 0xc1, 0x08, 0x00, 0x2b, 0xe1, 0x03, 0x18 );
DEFINE_GUID( GUID_DEVCLASS_MONITOR,        0x4d36e96eL, 0xe325, 0x11ce, 0xbf, 0xc1, 0x08, 0x00, 0x2b, 0xe1, 0x03, 0x18 );
DEFINE_GUID( GUID_DEVCLASS_MOUSE,          0x4d36e96fL, 0xe325, 0x11ce, 0xbf, 0xc1, 0x08, 0x00, 0x2b, 0xe1, 0x03, 0x18 );
DEFINE_GUID( GUID_DEVCLASS_MTD,            0x4d36e970L, 0xe325, 0x11ce, 0xbf, 0xc1, 0x08, 0x00, 0x2b, 0xe1, 0x03, 0x18 );
DEFINE_GUID( GUID_DEVCLASS_MULTIFUNCTION,  0x4d36e971L, 0xe325, 0x11ce, 0xbf, 0xc1, 0x08, 0x00, 0x2b, 0xe1, 0x03, 0x18 );
DEFINE_GUID( GUID_DEVCLASS_NET,            0x4d36e972L, 0xe325, 0x11ce, 0xbf, 0xc1, 0x08, 0x00, 0x2b, 0xe1, 0x03, 0x18 );
DEFINE_GUID( GUID_DEVCLASS_NETCLIENT,      0x4d36e973L, 0xe325, 0x11ce, 0xbf, 0xc1, 0x08, 0x00, 0x2b, 0xe1, 0x03, 0x18 );
DEFINE_GUID( GUID_DEVCLASS_NETSERVICE,     0x4d36e974L, 0xe325, 0x11ce, 0xbf, 0xc1, 0x08, 0x00, 0x2b, 0xe1, 0x03, 0x18 );
DEFINE_GUID( GUID_DEVCLASS_NETTRANS,       0x4d36e975L, 0xe325, 0x11ce, 0xbf, 0xc1, 0x08, 0x00, 0x2b, 0xe1, 0x03, 0x18 );
DEFINE_GUID( GUID_DEVCLASS_NODRIVER,       0x4d36e976L, 0xe325, 0x11ce, 0xbf, 0xc1, 0x08, 0x00, 0x2b, 0xe1, 0x03, 0x18 );
DEFINE_GUID( GUID_DEVCLASS_PARALLEL,       0x811fc6a5L, 0xf728, 0x11d0, 0xa5, 0x37, 0x00, 0x00, 0xf8, 0x75, 0x3e, 0xd1 );
DEFINE_GUID( GUID_DEVCLASS_PCMCIA,         0x4d36e977L, 0xe325, 0x11ce, 0xbf, 0xc1, 0x08, 0x00, 0x2b, 0xe1, 0x03, 0x18 );
DEFINE_GUID( GUID_DEVCLASS_PORTS,          0x4d36e978L, 0xe325, 0x11ce, 0xbf, 0xc1, 0x08, 0x00, 0x2b, 0xe1, 0x03, 0x18 );
DEFINE_GUID( GUID_DEVCLASS_PRINTER,        0x4d36e979L, 0xe325, 0x11ce, 0xbf, 0xc1, 0x08, 0x00, 0x2b, 0xe1, 0x03, 0x18 );
DEFINE_GUID( GUID_DEVCLASS_PRINTERUPGRADE, 0x4d36e97aL, 0xe325, 0x11ce, 0xbf, 0xc1, 0x08, 0x00, 0x2b, 0xe1, 0x03, 0x18 );
DEFINE_GUID( GUID_DEVCLASS_SCSIADAPTER,    0x4d36e97bL, 0xe325, 0x11ce, 0xbf, 0xc1, 0x08, 0x00, 0x2b, 0xe1, 0x03, 0x18 );
DEFINE_GUID( GUID_DEVCLASS_SOUND,          0x4d36e97cL, 0xe325, 0x11ce, 0xbf, 0xc1, 0x08, 0x00, 0x2b, 0xe1, 0x03, 0x18 );
DEFINE_GUID( GUID_DEVCLASS_STILLIMAGE,     0x6bdd1fc6L, 0x810f, 0x11d0, 0xbe, 0xc7, 0x08, 0x00, 0x2b, 0xe2, 0x09, 0x2f );
DEFINE_GUID( GUID_DEVCLASS_SYSTEM,         0x4d36e97dL, 0xe325, 0x11ce, 0xbf, 0xc1, 0x08, 0x00, 0x2b, 0xe1, 0x03, 0x18 );
DEFINE_GUID( GUID_DEVCLASS_TAPEDRIVE,      0x6d807884L, 0x7d21, 0x11cf, 0x80, 0x1c, 0x08, 0x00, 0x2b, 0xe1, 0x03, 0x18 );
DEFINE_GUID( GUID_DEVCLASS_UNKNOWN,        0x4d36e97eL, 0xe325, 0x11ce, 0xbf, 0xc1, 0x08, 0x00, 0x2b, 0xe1, 0x03, 0x18 );
DEFINE_GUID( GUID_DEVCLASS_VOLUME,         0x71a27cddL, 0x812a, 0x11d0, 0xbe, 0xc7, 0x08, 0x00, 0x2b, 0xe2, 0x09, 0x2f );
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\devioctl.h ===
/*++ BUILD Version: 0004    // Increment this if a change has global effects

Copyright (c) 1992-1999  Microsoft Corporation

Module Name:

    devioctl.h

Abstract:

    This module contains

Author:

    Andre Vachon (andreva) 21-Feb-1992


Revision History:


--*/

// begin_winioctl

#ifndef _DEVIOCTL_
#define _DEVIOCTL_

// begin_ntddk begin_wdm begin_nthal begin_ntifs
//
// Define the various device type values.  Note that values used by Microsoft
// Corporation are in the range 0-32767, and 32768-65535 are reserved for use
// by customers.
//

#define DEVICE_TYPE ULONG

#define FILE_DEVICE_BEEP                0x00000001
#define FILE_DEVICE_CD_ROM              0x00000002
#define FILE_DEVICE_CD_ROM_FILE_SYSTEM  0x00000003
#define FILE_DEVICE_CONTROLLER          0x00000004
#define FILE_DEVICE_DATALINK            0x00000005
#define FILE_DEVICE_DFS                 0x00000006
#define FILE_DEVICE_DISK                0x00000007
#define FILE_DEVICE_DISK_FILE_SYSTEM    0x00000008
#define FILE_DEVICE_FILE_SYSTEM         0x00000009
#define FILE_DEVICE_INPORT_PORT         0x0000000a
#define FILE_DEVICE_KEYBOARD            0x0000000b
#define FILE_DEVICE_MAILSLOT            0x0000000c
#define FILE_DEVICE_MIDI_IN             0x0000000d
#define FILE_DEVICE_MIDI_OUT            0x0000000e
#define FILE_DEVICE_MOUSE               0x0000000f
#define FILE_DEVICE_MULTI_UNC_PROVIDER  0x00000010
#define FILE_DEVICE_NAMED_PIPE          0x00000011
#define FILE_DEVICE_NETWORK             0x00000012
#define FILE_DEVICE_NETWORK_BROWSER     0x00000013
#define FILE_DEVICE_NETWORK_FILE_SYSTEM 0x00000014
#define FILE_DEVICE_NULL                0x00000015
#define FILE_DEVICE_PARALLEL_PORT       0x00000016
#define FILE_DEVICE_PHYSICAL_NETCARD    0x00000017
#define FILE_DEVICE_PRINTER             0x00000018
#define FILE_DEVICE_SCANNER             0x00000019
#define FILE_DEVICE_SERIAL_MOUSE_PORT   0x0000001a
#define FILE_DEVICE_SERIAL_PORT         0x0000001b
#define FILE_DEVICE_SCREEN              0x0000001c
#define FILE_DEVICE_SOUND               0x0000001d
#define FILE_DEVICE_STREAMS             0x0000001e
#define FILE_DEVICE_TAPE                0x0000001f
#define FILE_DEVICE_TAPE_FILE_SYSTEM    0x00000020
#define FILE_DEVICE_TRANSPORT           0x00000021
#define FILE_DEVICE_UNKNOWN             0x00000022
#define FILE_DEVICE_VIDEO               0x00000023
#define FILE_DEVICE_VIRTUAL_DISK        0x00000024
#define FILE_DEVICE_WAVE_IN             0x00000025
#define FILE_DEVICE_WAVE_OUT            0x00000026
#define FILE_DEVICE_8042_PORT           0x00000027
#define FILE_DEVICE_NETWORK_REDIRECTOR  0x00000028
#define FILE_DEVICE_BATTERY             0x00000029
#define FILE_DEVICE_BUS_EXTENDER        0x0000002a
#define FILE_DEVICE_MODEM               0x0000002b
#define FILE_DEVICE_VDM                 0x0000002c
#define FILE_DEVICE_MASS_STORAGE        0x0000002d
#define FILE_DEVICE_SMB                 0x0000002e
#define FILE_DEVICE_KS                  0x0000002f
#define FILE_DEVICE_CHANGER             0x00000030
#define FILE_DEVICE_SMARTCARD           0x00000031
#define FILE_DEVICE_ACPI                0x00000032
#define FILE_DEVICE_DVD                 0x00000033
#define FILE_DEVICE_FULLSCREEN_VIDEO    0x00000034
#define FILE_DEVICE_DFS_FILE_SYSTEM     0x00000035
#define FILE_DEVICE_DFS_VOLUME          0x00000036
#define FILE_DEVICE_SERENUM             0x00000037
#define FILE_DEVICE_TERMSRV             0x00000038
#define FILE_DEVICE_KSEC                0x00000039

//
// Macro definition for defining IOCTL and FSCTL function control codes.  Note
// that function codes 0-2047 are reserved for Microsoft Corporation, and
// 2048-4095 are reserved for customers.
//

#define CTL_CODE( DeviceType, Function, Method, Access ) (                 \
    ((DeviceType) << 16) | ((Access) << 14) | ((Function) << 2) | (Method) \
)

//
// Macro to extract device type out of the device io control code
//
#define DEVICE_TYPE_FROM_CTL_CODE(ctrlCode)     (((ULONG)(ctrlCode & 0xffff0000)) >> 16)

//
// Define the method codes for how buffers are passed for I/O and FS controls
//

#define METHOD_BUFFERED                 0
#define METHOD_IN_DIRECT                1
#define METHOD_OUT_DIRECT               2
#define METHOD_NEITHER                  3

//
// Define the access check value for any access
//
//
// The FILE_READ_ACCESS and FILE_WRITE_ACCESS constants are also defined in
// ntioapi.h as FILE_READ_DATA and FILE_WRITE_DATA. The values for these
// constants *MUST* always be in sync.
//
//
// FILE_SPECIAL_ACCESS is checked by the NT I/O system the same as FILE_ANY_ACCESS.
// The file systems, however, may add additional access checks for I/O and FS controls
// that use this value.
//


#define FILE_ANY_ACCESS                 0
#define FILE_SPECIAL_ACCESS    (FILE_ANY_ACCESS)
#define FILE_READ_ACCESS          ( 0x0001 )    // file & pipe
#define FILE_WRITE_ACCESS         ( 0x0002 )    // file & pipe

// end_ntddk end_wdm end_nthal end_ntifs

#endif // _DEVIOCTL_

// end_winioctl
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\devtype.h ===
// devtype.h : definitions for vidsvr.odl
// Copyright (c) Microsoft Corporation 1995-1997.
//
#ifdef __cplusplus
# define odlhelp(x)
# define odlhelp2(x, y)
#else
# define odlhelp(x) [ helpstring(x)]
# define odlhelp2(x, y) [ x, y ]
#endif
// these device type elements are built into the ODL and are used to construct
// the DeviceType property

#ifdef __MKTYPLIB__

#include <dssenum.h>

        // these are the string resource id numbers in the vidsvr
        // for the progid strings
        typedef enum BpcVidsvrProgIds {
            BPC_IDS_VIDSVR_PROGID = 2100,
            BPC_IDS_COABPCDETAILS_PROGID = 2101,
        } BpcVidsvrProgIds;


        typedef enum statustype {
//          STATUS_POWER        = 0x01,
            STATUS_PLAY         = 0x02,
//          STATUS_THISPLAY     = 0x04,
            STATUS_PAUSED       = 0x08,
//          STATUS_AUDIO        = 0x10,
//          STATUS_VIDEO        = 0x20,
//          STATUS_RECORDING    = 0x40,
            STATUS_ACTIVE       = 0x80, // set when we're input or output
        } STATUSTYPE;

#if 0
// reserved for future use
        typedef enum ircommands {
            IR_PLAY = 1,
            IR_STOP = 2,
            IR_PAUSE = 3,
            IR_UNPAUSE = 4,
            IR_RECORD = 5,
            IR_REWIND = 6,
            IR_FASTFORWARD = 7,
            IR_SETCHANNEL = 8,
            IR_TOGGLEPOWER = 9,
            IR_POWERON = 10,
            IR_POWEROFF = 11
        } IRCOMMANDS;

    // these values must match those in quartzsrc\ui\controls\litevid\dispids.h
    typedef odlhelp2 (
        uuid(05589fa4-c356-11ce-bf01-00aa0055595a),
        helpstring("Event Notification Flags")
    ) enum
    {
        odlhelp("No Event Notification") eventNone              = 0x00,
        odlhelp("State Changes (default)") eventStateChange     = 0x01,
        odlhelp("Position Changes") eventPositionChange         = 0x02,
        odlhelp("Timer events") eventTimer                      = 0x04,
        odlhelp("Keyboard Events") eventKeyboard                = 0x08,
        odlhelp("Mouse Clicks") eventMouseClick                 = 0x10,
        odlhelp("Mouse Moves") eventMouseMove                   = 0x20
    } EventNotificationFlags;
#endif

    typedef odlhelp2 (
        uuid(05589faa-c356-11ce-bf01-00aa0055595a),
        helpstring("Movie Window Settings")
   ) enum
    {
        odlhelp("Default Size") movieDefaultSize,
        odlhelp("Half Size") movieHalfSize,
        odlhelp("Double Size") movieDoubleSize,
        odlhelp("Maximum Size") movieMaximizeSize,
        odlhelp("Full Screen") movieFullScreen,
        odlhelp("User Defined (enforce Aspect Ratio)") moviePermitResizeWithAspect,
        odlhelp("User Defined (ignore Aspect Ratio)") moviePermitResizeNoRestrict
    } MovieWindowSetting;


    typedef odlhelp2(
        uuid(05589fab-c356-11ce-bf01-00aa0055595a),
        helpstring("State of Movie Clip")
    ) enum
    {
        // These values MUST be the same as the State_ constants in quartz\sdk\include\strmif.h
        odlhelp("Movie is stopped") stateStopped,
        odlhelp("Movie is paused") statePaused,
        odlhelp("Movie is running") stateRunning
    } State;


    typedef odlhelp2(
        uuid(05589fac-c356-11ce-bf01-00aa0055595a),
        helpstring("Display Mode")
    ) enum
    {
        odlhelp("Time") modeTime,
        odlhelp("Frames") modeFrames
    } DisplayMode;
#endif
// mktyplib won't allow an enum to define disp ids
// vid ids
#define dispidPower      1008
#define dispidStartTime  1002
#define dispidStopTime   1003
#define dispidVideoOn    1004
#define dispidClosedCaption     1005
#define dispidDebug             1006
#define dispidEventNotification 1007
#define dispidDeviceCount       1001
#define dispidDisplayMode       1025
#define dispidInput     1020
#define dispidOutput    1021
#define dispidColorKey  1012
#define dispidFileName  1013
#define dispidPriority  1014
#define dispidUserName  1015
#define dispidLogin     1016
#define dispidVolume    1017
#define dispidBalance   1018
#define dispidImageSourceHeight  1019
#define dispidImageSourceWidth   1010
#define dispidMovieWindowSetting 1011
#define dispidCurrentState       1022
#define dispidCurrentPosition    1023
#define dispidDuration           1024
#define dispidPrerollTime        1009
#define dispidRate               1026
#define dispidLocaleID           1027
#define dispidRun                1028
#define dispidPause              1029
#define dispidStop               1030
#define dispidClose              1031
#define dispidOpen               1032
#define dispidDevices            1033
#define dispidControlling        1034
#define dispidTune               1035
#define dispidTSDevCount         1036
#define dispidLogout             1037
#define dispidAutoScan           1038

        // Vid events
#define eventidGotControl     1001
#define eventidLostControl    1002
#define eventidDeviceMessage  1003
#define eventidStateChange    1004
#define eventidPositionChange 1005
#define eventidErrorMessage   1006
        //DeviceBase methods&props
#define dispidName         1001
#define dispidIsInput      1002
#define dispidIsOutput     1003
#define dispidHasChannel   1004
#define dispidHasFilename  1005
#define dispidDeviceType   1006
#define dispidStatus       1007
#define dispidProdName     1008
#define dispidDevFileName  1009
#define dispidChannel      1010
#define dispidSendMessage  1011
#define dispidCommand      1012
#define dispidChannelAvailable  1013
#define dispidCommandAvailable  1014
#define dispidDevImageSourceWidth   1015
#define dispidDevImageSourceHeight  1016
#define dispidDevCurrentPosition    1017
#define dispidDevDuration           1018
#define dispidDevPrerollTime        1019
#define dispidDevRate               1020
#define dispidDevCountryCode        1021
#define dispidDevVideoFrequency     1022
#define dispidDevAudioFrequency     1023
#define dispidDevDefaultVideoType   1024
#define dispidDevDefaultAudioType   1025
#define dispidDevVideoSubchannel    1026
#define dispidDevAudioSubchannel    1027
#define dispidDevTuningSpace        1028
#define dispidStatusString      1030
#define dispidDevVolume         1031
#define dispidDevBalance        1032
#define dispidActivate          1033
#define dispidDeActivate        1034
#define dispidDevPower          1035
#define dispidDevRun            1036
#define dispidDevStop           1037
#define dispidDevPause          1038
#define dispidDevRefresh        1039
#define dispidHasCA             1040
#define dispidDevVideoOn        1041
#define dispidDevCurrentState   1042
#define dispidDevOverScan       1043
//
#define dispidItem              1500
#define dispidCount             1501
#define dispidHWnd              1502
#define dispidLCID              1503
#define dispidNotify            1504
#define dispidDevControlling    1505
#define dispidDevColorKey       1506
#define dispidDevPriority       1507
#define dispidDevInput          1508
#define dispidDevOutput         1509
#define dispidDevTune           1510
#define dispidDevTSDevCount     1511
#define dispidDevOpen           1512
#define dispidDevLogin          1513
#define dispidDevLogout         1514
#define dispidDevAutoScan       1515
// NOTE:  !!!! these must match the odl for the caserver(caserver.odl)
// don't change these without considering the impact on existing code
// normally you should not delete, rename, or reuse any of these.  you should
// add new ones and stop using the old ones while leaving them in place marked
// as obsolete.

// These symbols are #defined because mktyplib doesn't understand
// enum.  if we convert completely to midl then we could  change all
// of these to enums which would be more type safe for authors
// of provider specific dll's


// IBPCDetails interface
#define OABPCDETID_Channel        (1401)
#define OABPCDETID_StartTime      (1402)
#define OABPCDETID_Duration       (1403)
#define OABPCDETID_ItemID         (1404)
#define OABPCDETID_StorageId      (1405)
#define OABPCDETID_Title          (1406)
#define OABPCDETID_Rating         (1407)
#define OABPCDETID_Year           (1408)
#define OABPCDETID_Description    (1409)
#define OABPCDETID_ViewCost       (1410)
#define OABPCDETID_TapeCost       (1411)
#define OABPCDETID_Action         (1412)
#define OABPCDETID_Status         (1413)
#define OABPCDETID_Reason         (1414)
#define OABPCDETID_ReasonDesc     (1415)
#define OABPCDETID_ProviderBuffer (1416)
#define OABPCDETID_Expiry         (1417)
#define OABPCDETID_Location       (1418)
#define OABPCDETID_UserId         (1419)

// CAServer Interface
#define CASERVERID_ResetProviderSystem (1301)
#define CASERVERID_BuyItem             (1302)
#define CASERVERID_CancelItem          (1303)
#define CASERVERID_ItemDetails         (1304)
#define CASERVERID_ProviderEPGMask     (1305)
#define CASERVERID_DisplayConfigDialog (1306)
#define CASERVERID_UserName            (1307)
#define CASERVERID_UserArea            (1308)
#define CASERVERID_ProviderRating      (1309)
#define CASERVERID_ProviderStatus      (1310)
#define CASERVERID_ShowBox             (1311)
#define CASERVERID_HistoryItems        (1312)
#define CASERVERID_EmailMessages       (1313)
#define CASERVERID_ErrorMessages       (1314)
#define CASERVERID_HandleCardChaining  (1315)

// CAEvent Interface
// message event
#define CAEVENTID_CardMissing         (1201)
#define CAEVENTID_CardReady           (1202)
#define CAEVENTID_CardInvalid         (1203)
#define CAEVENTID_WrongCard           (1204)
#define CAEVENTID_BlackedOut          (1205)
#define CAEVENTID_RatingExceeded      (1206)
#define CAEVENTID_CostExceeded        (1207)
#define CAEVENTID_NotReady            (1208)
#define CAEVENTID_PasswordCleared     (1209)
#define CAEVENTID_SignalLost          (1210)
#define CAEVENTID_IntegrityFault      (1211)
#define CAEVENTID_OSDRequest          (1212)
// notifications
#define CAEVENTID_NewEmail            (1213)
#define CAEVENTID_NewCard             (1214)
#define CAEVENTID_ColdStart           (1215)
#define CAEVENTID_Ready               (1216)
#define CAEVENTID_CannotPurchase      (1217)
#define CAEVENTID_NoSubscriber        (1218)
#define CAEVENTID_CAFault             (1219)
#define CAEVENTID_CAFail              (1220)
#define CAEVENTID_CASuccess           (1221)
#define CAEVENTID_Retry               (1222)
#define CAEVENTID_Fail                (1223)
#define CAEVENTID_TuningChanged       (1224)
#define CAEVENTID_MessagesUpdated     (1233)
#define CAEVENTID_HistoryUpdated      (1234)
// special
#define CAEVENTID_TapingControlChanged (1225)
#define CAEVENTID_EPGGuideChanged     (1226)
#define CAEVENTID_HandlePurchaseOffer (1227)
#define CAEVENTID_RevokeEvent         (1228)
#define CAEVENTID_BillingCallStart    (1229)
#define CAEVENTID_BillingCallEnd      (1230)
#define CAEVENTID_CopyCard            (1231)
#define CAEVENTID_EPGFilterChanged    (1232)
#define CAEVENTID_CallbackFailed      (1235)

#define MSGID_Attributes              (1800)
#define MSGID_Message                 (1801)

#define EMSGID_MsgId                              (2000)
#define EMSGID_UserId                             (2001)
#define EMSGID_Received                           (2002)
#define EMSGID_Expires                            (2003)
#define EMSGID_Title                              (2004)
#define EMSGID_Message                            (2005)
#define EMSGID_Read                               (2006)

#define SUSPEND_DeviceRelease                     (2100)
//#define VCTL_VBITune                              (2101)
//#define VCTL_VBIStatus                            (2102)



//all the collection interfaces

#define COLLECTID_Item     (0)
#define COLLECTID_Count    (1)
#define COLLECTID_Remove   (2)
#define COLLECTID_MarkRead (3)

// this is a standard system defined dispatch id
// however, due to the turmoil involved in midl vs. mktyplib
// and vc 4.1's poor support for OLE i can't include
// oaidl.h where this is defined and get a clean compile
// therefore i'm redefining it here.  this should be removed
// someday(hopefully vc4.2, maybe vc 5.0)
#ifndef DISPID_NEWENUM
#define DISPID_NEWENUM   (-4)
#endif

// end of file - devtype.h

=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\ddstream.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0338 */
/* Compiler settings for ddstream.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __ddstream_h__
#define __ddstream_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IDirectDrawMediaStream_FWD_DEFINED__
#define __IDirectDrawMediaStream_FWD_DEFINED__
typedef interface IDirectDrawMediaStream IDirectDrawMediaStream;
#endif 	/* __IDirectDrawMediaStream_FWD_DEFINED__ */


#ifndef __IDirectDrawStreamSample_FWD_DEFINED__
#define __IDirectDrawStreamSample_FWD_DEFINED__
typedef interface IDirectDrawStreamSample IDirectDrawStreamSample;
#endif 	/* __IDirectDrawStreamSample_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "mmstream.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_ddstream_0000 */
/* [local] */ 

//
//	The following declarations within the 'if 0' block are dummy typedefs used to make
//	the ddstream.idl file build.  The actual definitions are contained in DDRAW.H
//
#if 0
typedef void *LPDDSURFACEDESC;

typedef struct tDDSURFACEDESC DDSURFACEDESC;

#endif
#include <ddraw.h>

enum __MIDL___MIDL_itf_ddstream_0000_0001
    {	DDSFF_PROGRESSIVERENDER	= 0x1
    } ;







extern RPC_IF_HANDLE __MIDL_itf_ddstream_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_ddstream_0000_v0_0_s_ifspec;

#ifndef __IDirectDrawMediaStream_INTERFACE_DEFINED__
#define __IDirectDrawMediaStream_INTERFACE_DEFINED__

/* interface IDirectDrawMediaStream */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IDirectDrawMediaStream;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F4104FCE-9A70-11d0-8FDE-00C04FD9189D")
    IDirectDrawMediaStream : public IMediaStream
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetFormat( 
            /* [out] */ DDSURFACEDESC *pDDSDCurrent,
            /* [out] */ IDirectDrawPalette **ppDirectDrawPalette,
            /* [out] */ DDSURFACEDESC *pDDSDDesired,
            /* [out] */ DWORD *pdwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFormat( 
            /* [in] */ const DDSURFACEDESC *pDDSurfaceDesc,
            /* [in] */ IDirectDrawPalette *pDirectDrawPalette) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDirectDraw( 
            /* [out] */ IDirectDraw **ppDirectDraw) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDirectDraw( 
            /* [in] */ IDirectDraw *pDirectDraw) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateSample( 
            /* [in] */ IDirectDrawSurface *pSurface,
            /* [in] */ const RECT *pRect,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDirectDrawStreamSample **ppSample) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTimePerFrame( 
            /* [out] */ STREAM_TIME *pFrameTime) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDirectDrawMediaStreamVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDirectDrawMediaStream * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDirectDrawMediaStream * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDirectDrawMediaStream * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetMultiMediaStream )( 
            IDirectDrawMediaStream * This,
            /* [out] */ IMultiMediaStream **ppMultiMediaStream);
        
        HRESULT ( STDMETHODCALLTYPE *GetInformation )( 
            IDirectDrawMediaStream * This,
            /* [out] */ MSPID *pPurposeId,
            /* [out] */ STREAM_TYPE *pType);
        
        HRESULT ( STDMETHODCALLTYPE *SetSameFormat )( 
            IDirectDrawMediaStream * This,
            /* [in] */ IMediaStream *pStreamThatHasDesiredFormat,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *AllocateSample )( 
            IDirectDrawMediaStream * This,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IStreamSample **ppSample);
        
        HRESULT ( STDMETHODCALLTYPE *CreateSharedSample )( 
            IDirectDrawMediaStream * This,
            /* [in] */ IStreamSample *pExistingSample,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IStreamSample **ppNewSample);
        
        HRESULT ( STDMETHODCALLTYPE *SendEndOfStream )( 
            IDirectDrawMediaStream * This,
            DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetFormat )( 
            IDirectDrawMediaStream * This,
            /* [out] */ DDSURFACEDESC *pDDSDCurrent,
            /* [out] */ IDirectDrawPalette **ppDirectDrawPalette,
            /* [out] */ DDSURFACEDESC *pDDSDDesired,
            /* [out] */ DWORD *pdwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *SetFormat )( 
            IDirectDrawMediaStream * This,
            /* [in] */ const DDSURFACEDESC *pDDSurfaceDesc,
            /* [in] */ IDirectDrawPalette *pDirectDrawPalette);
        
        HRESULT ( STDMETHODCALLTYPE *GetDirectDraw )( 
            IDirectDrawMediaStream * This,
            /* [out] */ IDirectDraw **ppDirectDraw);
        
        HRESULT ( STDMETHODCALLTYPE *SetDirectDraw )( 
            IDirectDrawMediaStream * This,
            /* [in] */ IDirectDraw *pDirectDraw);
        
        HRESULT ( STDMETHODCALLTYPE *CreateSample )( 
            IDirectDrawMediaStream * This,
            /* [in] */ IDirectDrawSurface *pSurface,
            /* [in] */ const RECT *pRect,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDirectDrawStreamSample **ppSample);
        
        HRESULT ( STDMETHODCALLTYPE *GetTimePerFrame )( 
            IDirectDrawMediaStream * This,
            /* [out] */ STREAM_TIME *pFrameTime);
        
        END_INTERFACE
    } IDirectDrawMediaStreamVtbl;

    interface IDirectDrawMediaStream
    {
        CONST_VTBL struct IDirectDrawMediaStreamVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDirectDrawMediaStream_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDirectDrawMediaStream_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDirectDrawMediaStream_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDirectDrawMediaStream_GetMultiMediaStream(This,ppMultiMediaStream)	\
    (This)->lpVtbl -> GetMultiMediaStream(This,ppMultiMediaStream)

#define IDirectDrawMediaStream_GetInformation(This,pPurposeId,pType)	\
    (This)->lpVtbl -> GetInformation(This,pPurposeId,pType)

#define IDirectDrawMediaStream_SetSameFormat(This,pStreamThatHasDesiredFormat,dwFlags)	\
    (This)->lpVtbl -> SetSameFormat(This,pStreamThatHasDesiredFormat,dwFlags)

#define IDirectDrawMediaStream_AllocateSample(This,dwFlags,ppSample)	\
    (This)->lpVtbl -> AllocateSample(This,dwFlags,ppSample)

#define IDirectDrawMediaStream_CreateSharedSample(This,pExistingSample,dwFlags,ppNewSample)	\
    (This)->lpVtbl -> CreateSharedSample(This,pExistingSample,dwFlags,ppNewSample)

#define IDirectDrawMediaStream_SendEndOfStream(This,dwFlags)	\
    (This)->lpVtbl -> SendEndOfStream(This,dwFlags)


#define IDirectDrawMediaStream_GetFormat(This,pDDSDCurrent,ppDirectDrawPalette,pDDSDDesired,pdwFlags)	\
    (This)->lpVtbl -> GetFormat(This,pDDSDCurrent,ppDirectDrawPalette,pDDSDDesired,pdwFlags)

#define IDirectDrawMediaStream_SetFormat(This,pDDSurfaceDesc,pDirectDrawPalette)	\
    (This)->lpVtbl -> SetFormat(This,pDDSurfaceDesc,pDirectDrawPalette)

#define IDirectDrawMediaStream_GetDirectDraw(This,ppDirectDraw)	\
    (This)->lpVtbl -> GetDirectDraw(This,ppDirectDraw)

#define IDirectDrawMediaStream_SetDirectDraw(This,pDirectDraw)	\
    (This)->lpVtbl -> SetDirectDraw(This,pDirectDraw)

#define IDirectDrawMediaStream_CreateSample(This,pSurface,pRect,dwFlags,ppSample)	\
    (This)->lpVtbl -> CreateSample(This,pSurface,pRect,dwFlags,ppSample)

#define IDirectDrawMediaStream_GetTimePerFrame(This,pFrameTime)	\
    (This)->lpVtbl -> GetTimePerFrame(This,pFrameTime)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDirectDrawMediaStream_GetFormat_Proxy( 
    IDirectDrawMediaStream * This,
    /* [out] */ DDSURFACEDESC *pDDSDCurrent,
    /* [out] */ IDirectDrawPalette **ppDirectDrawPalette,
    /* [out] */ DDSURFACEDESC *pDDSDDesired,
    /* [out] */ DWORD *pdwFlags);


void __RPC_STUB IDirectDrawMediaStream_GetFormat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirectDrawMediaStream_SetFormat_Proxy( 
    IDirectDrawMediaStream * This,
    /* [in] */ const DDSURFACEDESC *pDDSurfaceDesc,
    /* [in] */ IDirectDrawPalette *pDirectDrawPalette);


void __RPC_STUB IDirectDrawMediaStream_SetFormat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirectDrawMediaStream_GetDirectDraw_Proxy( 
    IDirectDrawMediaStream * This,
    /* [out] */ IDirectDraw **ppDirectDraw);


void __RPC_STUB IDirectDrawMediaStream_GetDirectDraw_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirectDrawMediaStream_SetDirectDraw_Proxy( 
    IDirectDrawMediaStream * This,
    /* [in] */ IDirectDraw *pDirectDraw);


void __RPC_STUB IDirectDrawMediaStream_SetDirectDraw_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirectDrawMediaStream_CreateSample_Proxy( 
    IDirectDrawMediaStream * This,
    /* [in] */ IDirectDrawSurface *pSurface,
    /* [in] */ const RECT *pRect,
    /* [in] */ DWORD dwFlags,
    /* [out] */ IDirectDrawStreamSample **ppSample);


void __RPC_STUB IDirectDrawMediaStream_CreateSample_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirectDrawMediaStream_GetTimePerFrame_Proxy( 
    IDirectDrawMediaStream * This,
    /* [out] */ STREAM_TIME *pFrameTime);


void __RPC_STUB IDirectDrawMediaStream_GetTimePerFrame_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDirectDrawMediaStream_INTERFACE_DEFINED__ */


#ifndef __IDirectDrawStreamSample_INTERFACE_DEFINED__
#define __IDirectDrawStreamSample_INTERFACE_DEFINED__

/* interface IDirectDrawStreamSample */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IDirectDrawStreamSample;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F4104FCF-9A70-11d0-8FDE-00C04FD9189D")
    IDirectDrawStreamSample : public IStreamSample
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSurface( 
            /* [out] */ IDirectDrawSurface **ppDirectDrawSurface,
            /* [out] */ RECT *pRect) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRect( 
            /* [in] */ const RECT *pRect) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDirectDrawStreamSampleVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDirectDrawStreamSample * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDirectDrawStreamSample * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDirectDrawStreamSample * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetMediaStream )( 
            IDirectDrawStreamSample * This,
            /* [in] */ IMediaStream **ppMediaStream);
        
        HRESULT ( STDMETHODCALLTYPE *GetSampleTimes )( 
            IDirectDrawStreamSample * This,
            /* [out] */ STREAM_TIME *pStartTime,
            /* [out] */ STREAM_TIME *pEndTime,
            /* [out] */ STREAM_TIME *pCurrentTime);
        
        HRESULT ( STDMETHODCALLTYPE *SetSampleTimes )( 
            IDirectDrawStreamSample * This,
            /* [in] */ const STREAM_TIME *pStartTime,
            /* [in] */ const STREAM_TIME *pEndTime);
        
        HRESULT ( STDMETHODCALLTYPE *Update )( 
            IDirectDrawStreamSample * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ HANDLE hEvent,
            /* [in] */ PAPCFUNC pfnAPC,
            /* [in] */ DWORD_PTR dwAPCData);
        
        HRESULT ( STDMETHODCALLTYPE *CompletionStatus )( 
            IDirectDrawStreamSample * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwMilliseconds);
        
        HRESULT ( STDMETHODCALLTYPE *GetSurface )( 
            IDirectDrawStreamSample * This,
            /* [out] */ IDirectDrawSurface **ppDirectDrawSurface,
            /* [out] */ RECT *pRect);
        
        HRESULT ( STDMETHODCALLTYPE *SetRect )( 
            IDirectDrawStreamSample * This,
            /* [in] */ const RECT *pRect);
        
        END_INTERFACE
    } IDirectDrawStreamSampleVtbl;

    interface IDirectDrawStreamSample
    {
        CONST_VTBL struct IDirectDrawStreamSampleVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDirectDrawStreamSample_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDirectDrawStreamSample_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDirectDrawStreamSample_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDirectDrawStreamSample_GetMediaStream(This,ppMediaStream)	\
    (This)->lpVtbl -> GetMediaStream(This,ppMediaStream)

#define IDirectDrawStreamSample_GetSampleTimes(This,pStartTime,pEndTime,pCurrentTime)	\
    (This)->lpVtbl -> GetSampleTimes(This,pStartTime,pEndTime,pCurrentTime)

#define IDirectDrawStreamSample_SetSampleTimes(This,pStartTime,pEndTime)	\
    (This)->lpVtbl -> SetSampleTimes(This,pStartTime,pEndTime)

#define IDirectDrawStreamSample_Update(This,dwFlags,hEvent,pfnAPC,dwAPCData)	\
    (This)->lpVtbl -> Update(This,dwFlags,hEvent,pfnAPC,dwAPCData)

#define IDirectDrawStreamSample_CompletionStatus(This,dwFlags,dwMilliseconds)	\
    (This)->lpVtbl -> CompletionStatus(This,dwFlags,dwMilliseconds)


#define IDirectDrawStreamSample_GetSurface(This,ppDirectDrawSurface,pRect)	\
    (This)->lpVtbl -> GetSurface(This,ppDirectDrawSurface,pRect)

#define IDirectDrawStreamSample_SetRect(This,pRect)	\
    (This)->lpVtbl -> SetRect(This,pRect)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDirectDrawStreamSample_GetSurface_Proxy( 
    IDirectDrawStreamSample * This,
    /* [out] */ IDirectDrawSurface **ppDirectDrawSurface,
    /* [out] */ RECT *pRect);


void __RPC_STUB IDirectDrawStreamSample_GetSurface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirectDrawStreamSample_SetRect_Proxy( 
    IDirectDrawStreamSample * This,
    /* [in] */ const RECT *pRect);


void __RPC_STUB IDirectDrawStreamSample_SetRect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDirectDrawStreamSample_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\des.h ===
//-----------------------------------------------------------------------------
//
// File:   des.h
//
// Microsoft Digital Rights Management
// Copyright (C) 1998-1999 Microsoft Corporation, All Rights Reserved
//
// Description:
//
//-----------------------------------------------------------------------------

#ifndef __DES_H__
#define __DES_H__

#ifndef RSA32API
#define RSA32API __stdcall
#endif

#ifdef __cplusplus
extern "C" {
#endif

typedef struct _destable {
    unsigned long   keytab[16][2];
} DESTable;

#define DES_TABLESIZE   (sizeof(DESTable))
#define DES_BLOCKLEN    (8)
#define DES_KEYSIZE     (8)

typedef struct _desxtable {
    unsigned char inWhitening[8];
    unsigned char outWhitening[8];
    DESTable desTable;
} DESXTable;

#define DESX_TABLESIZE  (sizeof(DESXTable))
#define DESX_BLOCKLEN   (8)
#define DESX_KEYSIZE    (24)

/* In deskey.c:

     Fill in the DESTable struct with the decrypt and encrypt
     key expansions.

     Assumes that the second parameter points to DES_BLOCKLEN
     bytes of key.

*/

void RSA32API deskey(DESTable *,unsigned char *);

/* In desport.c:

     Encrypt or decrypt with the key in DESTable

*/

void RSA32API des(BYTE *pbOut, BYTE *pbIn, void *key, int op);

//
// set the parity on the DES key to be odd
// NOTE : must be called before deskey
// key must be cbKey number of bytes
//
void RSA32API desparityonkey(BYTE *pbKey, DWORD cbKey);

//
// reduce the DES key to a 40 bit key
// NOTE : must be called before deskey
// key must be 8 bytes
//
void RSA32API desreducekey(BYTE *key);

// Expand 40 bit DES key to 64 and check weakness
// same as desreducekey except expands instead of weakening keys
void RSA32API deskeyexpand(BYTE *pbKey, BYTE *pbExpanded_key);


void
RSA32API
desexpand128to192(
    BYTE *pbKey,        // input 128bit or 192bit buffer
    BYTE *pbExpandedKey // output buffer (must be 192bit wide if pbKey == pbExpandedKey
    );

// DES-X routines

// initialize desX key struct.  key size is 24 bytes
void RSA32API desxkey(DESXTable *k, BYTE *key);

void RSA32API desx(BYTE *pbOut, BYTE *pbIn, void *keyin, int op);


extern int Asmversion;  /* 1 if we're linked with an asm version, 0 if C */

#ifdef __cplusplus
}
#endif

#endif // __DES_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\dhtmliid.h ===
// GUIDs for DHTMLEd.OCX
// Copyright 1998-1999 Microsoft Corporation.  All rights reserved.

#ifndef _dhtmliid_h_
#define _dhtmliid_h_

#ifdef __cplusplus
extern "C"{
#endif 

EXTERN_C const IID   LIBID_DHTMLEDLib;

EXTERN_C const CLSID CLSID_DHTMLEdit;
EXTERN_C const CLSID CLSID_DHTMLSafe;
EXTERN_C const CLSID CLSID_DEInsertTableParam;
EXTERN_C const CLSID CLSID_DEGetBlockFmtNamesParam;

EXTERN_C const IID   DIID__DHTMLSafeEvents;
EXTERN_C const IID   DIID__DHTMLEditEvents;

EXTERN_C const IID   IID_IDHTMLEdit;
EXTERN_C const IID   IID_IDHTMLSafe;
EXTERN_C const IID   IID_IDEInsertTableParam;
EXTERN_C const IID   IID_IDEGetBlockFmtNamesParam;


DEFINE_GUID(LIBID_DHTMLEDLib,              0x683364A1, 0xB37D, 0x11D1, 0xAD, 0xC5, 0x00, 0x60, 0x08, 0xA5, 0x84, 0x8C);

DEFINE_GUID(CLSID_DHTMLEdit,               0x2D360200, 0xFFF5, 0x11d1, 0x8D, 0x03, 0x00, 0xA0, 0xC9, 0x59, 0xBC, 0x0A);
DEFINE_GUID(CLSID_DHTMLSafe,               0x2D360201, 0xFFF5, 0x11d1, 0x8D, 0x03, 0x00, 0xA0, 0xC9, 0x59, 0xBC, 0x0A);
DEFINE_GUID(CLSID_DEInsertTableParam,      0x47B0DFC7, 0xB7A3, 0x11D1, 0xAD, 0xC5, 0x00, 0x60, 0x08, 0xA5, 0x84, 0x8C);
DEFINE_GUID(CLSID_DEGetBlockFmtNamesParam, 0x8D91090E, 0xB955, 0x11D1, 0xAD, 0xC5, 0x00, 0x60, 0x08, 0xA5, 0x84, 0x8C);

DEFINE_GUID(DIID__DHTMLSafeEvents,         0xD1FC78E8, 0xB380, 0x11d1, 0xAD, 0xC5, 0x00, 0x60, 0x08, 0xA5, 0x84, 0x8C);
DEFINE_GUID(DIID__DHTMLEditEvents,         0x588D5040, 0xCF28, 0x11d1, 0x8C, 0xD3, 0x00, 0xA0, 0xC9, 0x59, 0xBC, 0x0A);

DEFINE_GUID(IID_IDHTMLEdit,                0xCE04B591, 0x2B1F, 0x11d2, 0x8D, 0x1E, 0x00, 0xA0, 0xC9, 0x59, 0xBC, 0x0A);
DEFINE_GUID(IID_IDHTMLSafe,                0xCE04B590, 0x2B1F, 0x11d2, 0x8D, 0x1E, 0x00, 0xA0, 0xC9, 0x59, 0xBC, 0x0A0);
DEFINE_GUID(IID_IDEInsertTableParam,       0x47B0DFC6, 0xB7A3, 0x11D1, 0xAD, 0xC5, 0x00, 0x60, 0x08, 0xA5, 0x84, 0x8C);
DEFINE_GUID(IID_IDEGetBlockFmtNamesParam,  0x8D91090D, 0xB955, 0x11D1, 0xAD, 0xC5, 0x00, 0x60, 0x08, 0xA5, 0x84, 0x8C);

#ifdef __cplusplus
}
#endif

#endif	// _dhtmliid_h_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\digitalv.h ===
/****************************************************************************/
/*                                                                          */
/*        DIGITALV.H - Include file for the MCI Digital Video Command Set   */
/*                                                                          */
/*                              Version 1.0                                 */
/*                                                                          */
/*        Copyright (c) 1995-1999, Microsoft Corp.  All rights reserved.    */
/*                                                                          */
/*  Date            Modification                                            */
/*  ------------    ------------                                            */
/*  Aug 19, 1992    -Version 1.0 Release                                    */
/*                                                                          */
/****************************************************************************/

#ifndef _INC_DIGITALV
#define _INC_DIGITALV  100

#ifdef _WIN32
#include <pshpack1.h>
#else
#ifndef RC_INVOKED
#pragma pack(1)
#endif
#endif

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

#define MCI_TEST                            0x00000020L

/* Message values */

#define MCI_CAPTURE                         0x0870
#define MCI_MONITOR                         0x0871
#define MCI_RESERVE                         0x0872
#define MCI_SETAUDIO                        0x0873
#define MCI_SIGNAL                          0x0875
#define MCI_SETVIDEO                        0x0876
#define MCI_QUALITY                         0x0877
#define MCI_LIST                            0x0878
#define MCI_UNDO                            0x0879
#define MCI_CONFIGURE                       0x087a
#define MCI_RESTORE                         0x087b

/* Return and string constant values */

#define MCI_ON   1
#define MCI_OFF  0

#define MCI_DGV_FILE_MODE_SAVING            0x0001
#define MCI_DGV_FILE_MODE_LOADING           0x0002
#define MCI_DGV_FILE_MODE_EDITING           0x0003
#define MCI_DGV_FILE_MODE_IDLE              0x0004

/* These identifiers are used only by device drivers */

#define MCI_ON_S                            0x00008000L
#define MCI_OFF_S                           0x00008001L
#define MCI_DGV_FILE_S                      0x00008002L
#define MCI_DGV_INPUT_S                     0x00008003L

#define MCI_DGV_FILE_MODE_SAVING_S          0x00008004L
#define MCI_DGV_FILE_MODE_LOADING_S         0x00008005L
#define MCI_DGV_FILE_MODE_EDITING_S         0x00008006L
#define MCI_DGV_FILE_MODE_IDLE_S            0x00008007L

#define MCI_DGV_SETVIDEO_SRC_NTSC_S         0x00008010L
#define MCI_DGV_SETVIDEO_SRC_RGB_S          0x00008011L
#define MCI_DGV_SETVIDEO_SRC_SVIDEO_S       0x00008012L
#define MCI_DGV_SETVIDEO_SRC_PAL_S          0x00008013L
#define MCI_DGV_SETVIDEO_SRC_SECAM_S        0x00008014L
#define MCI_DGV_SETVIDEO_SRC_GENERIC_S      0x00008015L

#define MCI_DGV_SETAUDIO_SRC_LEFT_S         0x00008020L
#define MCI_DGV_SETAUDIO_SRC_RIGHT_S        0x00008021L
#define MCI_DGV_SETAUDIO_SRC_AVERAGE_S      0x00008022L
#define MCI_DGV_SETAUDIO_SRC_STEREO_S       0x00008023L

/* Window message for signal notification */

#define MM_MCISIGNAL                        0x3CB

/* error values */

#define MCIERR_DGV_DEVICE_LIMIT             (MCIERR_CUSTOM_DRIVER_BASE+0)
#define MCIERR_DGV_IOERR                    (MCIERR_CUSTOM_DRIVER_BASE+1)
#define MCIERR_DGV_WORKSPACE_EMPTY          (MCIERR_CUSTOM_DRIVER_BASE+2)
#define MCIERR_DGV_DISK_FULL                (MCIERR_CUSTOM_DRIVER_BASE+3)
#define MCIERR_DGV_DEVICE_MEMORY_FULL       (MCIERR_CUSTOM_DRIVER_BASE+4)
#define MCIERR_DGV_BAD_CLIPBOARD_RANGE      (MCIERR_CUSTOM_DRIVER_BASE+5)

/* defines for monitor methods */

#define MCI_DGV_METHOD_PRE                  0x0000a000L
#define MCI_DGV_METHOD_POST                 0x0000a001L
#define MCI_DGV_METHOD_DIRECT               0x0000a002L

/* defines for known file formats */

#define MCI_DGV_FF_AVSS                     0x00004000L
#define MCI_DGV_FF_AVI                      0x00004001L
#define MCI_DGV_FF_DIB                      0x00004002L
#define MCI_DGV_FF_RDIB                     0x00004003L
#define MCI_DGV_FF_JPEG                     0x00004004L
#define MCI_DGV_FF_RJPEG                    0x00004005L
#define MCI_DGV_FF_JFIF                     0x00004006L
#define MCI_DGV_FF_MPEG                     0x00004007L

/* values for dwItem field of MCI_CAPABILITY_PARMS structure */

#define MCI_DGV_GETDEVCAPS_CAN_LOCK         0x00004000L
#define MCI_DGV_GETDEVCAPS_CAN_STRETCH      0x00004001L
#define MCI_DGV_GETDEVCAPS_CAN_FREEZE       0x00004002L
#define MCI_DGV_GETDEVCAPS_MAX_WINDOWS      0x00004003L
#define MCI_DGV_GETDEVCAPS_CAN_REVERSE      0x00004004L
#define MCI_DGV_GETDEVCAPS_HAS_STILL        0x00004005L
#define MCI_DGV_GETDEVCAPS_PALETTES         0x00004006L
#define MCI_DGV_GETDEVCAPS_CAN_STR_IN       0x00004008L
#define MCI_DGV_GETDEVCAPS_CAN_TEST         0x00004009L
#define MCI_DGV_GETDEVCAPS_MAXIMUM_RATE     0x0000400aL
#define MCI_DGV_GETDEVCAPS_MINIMUM_RATE     0x0000400bL

/* flags for dwFlags parameter of MCI_CAPTURE command message */

#define MCI_DGV_CAPTURE_AS                  0x00010000L
#define MCI_DGV_CAPTURE_AT                  0x00020000L

/* flags for dwFlags parameter of MCI_COPY command message */

#define MCI_DGV_COPY_AT                     0x00010000L
#define MCI_DGV_COPY_AUDIO_STREAM           0x00020000L
#define MCI_DGV_COPY_VIDEO_STREAM           0x00040000L

/* flags for dwFlags parameter of MCI_CUE command message */

#define MCI_DGV_CUE_INPUT                   0x00010000L
#define MCI_DGV_CUE_OUTPUT                  0x00020000L
#define MCI_DGV_CUE_NOSHOW                  0x00040000L

/* flags for dwFlags parameter of MCI_CUT command message */

#define MCI_DGV_CUT_AT                      0x00010000L
#define MCI_DGV_CUT_AUDIO_STREAM            0x00020000L
#define MCI_DGV_CUT_VIDEO_STREAM            0x00040000L

/* flags for dwFlags parameter of MCI_DELETE command message */

#define MCI_DGV_DELETE_AT                   0x00010000L
#define MCI_DGV_DELETE_AUDIO_STREAM         0x00020000L
#define MCI_DGV_DELETE_VIDEO_STREAM         0x00040000L

/* flags for dwFlags parameter of MCI_FREEZE command message */

#define MCI_DGV_FREEZE_AT                   0x00010000L
#define MCI_DGV_FREEZE_OUTSIDE              0x00020000L

/* flags for dwFlags parameter of MCI_INFO command message */

#define MCI_DGV_INFO_TEXT                   0x00010000L
#define MCI_DGV_INFO_ITEM                   0X00020000L

/* values for dwItem field of MCI_DGV_INFO_PARMS structure */

#define MCI_INFO_VERSION                    0x00000400L

#define MCI_DGV_INFO_USAGE                  0x00004000L
#define MCI_DGV_INFO_AUDIO_QUALITY          0x00004001L
#define MCI_DGV_INFO_STILL_QUALITY          0x00004002L
#define MCI_DGV_INFO_VIDEO_QUALITY          0x00004003L
#define MCI_DGV_INFO_AUDIO_ALG              0x00004004L
#define MCI_DGV_INFO_STILL_ALG              0x00004005L
#define MCI_DGV_INFO_VIDEO_ALG              0x00004006L

/* flags for dwFlags parameter of MCI_LIST command message */

#define MCI_DGV_LIST_ITEM                   0x00010000L
#define MCI_DGV_LIST_COUNT                  0x00020000L
#define MCI_DGV_LIST_NUMBER                 0x00040000L
#define MCI_DGV_LIST_ALG                    0x00080000L

/* values for dwItem field of MCI_DGV_LIST_PARMS structure */

#define MCI_DGV_LIST_AUDIO_ALG              0x00004000L
#define MCI_DGV_LIST_AUDIO_QUALITY          0x00004001L
#define MCI_DGV_LIST_AUDIO_STREAM           0x00004002L
#define MCI_DGV_LIST_STILL_ALG              0x00004003L
#define MCI_DGV_LIST_STILL_QUALITY          0x00004004L
#define MCI_DGV_LIST_VIDEO_ALG              0x00004005L
#define MCI_DGV_LIST_VIDEO_QUALITY          0x00004006L
#define MCI_DGV_LIST_VIDEO_STREAM           0x00004007L
#define MCI_DGV_LIST_VIDEO_SOURCE           0x00004008L


/* flags for dwFlags parameter of MCI_MONITOR command message */

#define MCI_DGV_MONITOR_METHOD              0x00010000L
#define MCI_DGV_MONITOR_SOURCE              0x00020000L

/* values for dwSource parameter of the MCI_DGV_MONITOR_PARMS struture */

#define MCI_DGV_MONITOR_INPUT               0x00004000L
#define MCI_DGV_MONITOR_FILE                0x00004001L

/* flags for dwFlags parameter of MCI_OPEN command message */

#define MCI_DGV_OPEN_WS                     0x00010000L
#define MCI_DGV_OPEN_PARENT                 0x00020000L
#define MCI_DGV_OPEN_NOSTATIC               0x00040000L
#define MCI_DGV_OPEN_16BIT                  0x00080000L
#define MCI_DGV_OPEN_32BIT                  0x00100000L

/* flags for dwFlags parameter of MCI_PASTE command message */

#define MCI_DGV_PASTE_AT                    0x00010000L
#define MCI_DGV_PASTE_AUDIO_STREAM          0x00020000L
#define MCI_DGV_PASTE_VIDEO_STREAM          0x00040000L
#define MCI_DGV_PASTE_INSERT                0x00080000L
#define MCI_DGV_PASTE_OVERWRITE             0x00100000L

/* flags for dwFlags parameter of MCI_PLAY command message */

#define MCI_DGV_PLAY_REPEAT                 0x00010000L
#define MCI_DGV_PLAY_REVERSE                0x00020000L

/* flags for dwFlags parameter of MCI_PUT command message */

#define MCI_DGV_RECT                        0x00010000L
#define MCI_DGV_PUT_SOURCE                  0x00020000L
#define MCI_DGV_PUT_DESTINATION             0x00040000L
#define MCI_DGV_PUT_FRAME                   0x00080000L
#define MCI_DGV_PUT_VIDEO                   0x00100000L
#define MCI_DGV_PUT_WINDOW                  0x00200000L
#define MCI_DGV_PUT_CLIENT                  0x00400000L

/* flags for dwFlags parameter of MCI_QUALITY command message */

#define MCI_QUALITY_ITEM                    0x00010000L
#define MCI_QUALITY_NAME                    0x00020000L
#define MCI_QUALITY_ALG                     0x00040000L
#define MCI_QUALITY_DIALOG                  0x00080000L
#define MCI_QUALITY_HANDLE                  0x00100000L

/* values for dwItem field of MCI_QUALITY_PARMS structure */

#define MCI_QUALITY_ITEM_AUDIO              0x00004000L
#define MCI_QUALITY_ITEM_STILL              0x00004001L
#define MCI_QUALITY_ITEM_VIDEO              0x00004002L

/* flags for dwFlags parameter of MCI_REALIZE command message */

#define MCI_DGV_REALIZE_NORM                0x00010000L
#define MCI_DGV_REALIZE_BKGD                0x00020000L

/* flags for dwFlags parameter of MCI_RECORD command message */

#define MCI_DGV_RECORD_HOLD                 0x00020000L
#define MCI_DGV_RECORD_AUDIO_STREAM         0x00040000L
#define MCI_DGV_RECORD_VIDEO_STREAM         0x00080000L

/* flags for dwFlags parameters of MCI_RESERVE command message */

#define MCI_DGV_RESERVE_IN                  0x00010000L
#define MCI_DGV_RESERVE_SIZE                0x00020000L

/* flags for dwFlags parameter of MCI_RESTORE command message */

#define MCI_DGV_RESTORE_FROM                0x00010000L
#define MCI_DGV_RESTORE_AT                  0x00020000L

/* flags for dwFlags parameters of MCI_SAVE command message */

#define MCI_DGV_SAVE_ABORT                  0x00020000L
#define MCI_DGV_SAVE_KEEPRESERVE            0x00040000L

/* flags for dwFlags parameters of MCI_SET command message */

#define MCI_DGV_SET_SEEK_EXACTLY            0x00010000L
#define MCI_DGV_SET_SPEED                   0x00020000L
#define MCI_DGV_SET_STILL                   0x00040000L
#define MCI_DGV_SET_FILEFORMAT              0x00080000L

/* flags for the dwFlags parameter of MCI_SETAUDIO command message */

#define MCI_DGV_SETAUDIO_OVER               0x00010000L
#define MCI_DGV_SETAUDIO_CLOCKTIME          0x00020000L
#define MCI_DGV_SETAUDIO_ALG                0x00040000L
#define MCI_DGV_SETAUDIO_QUALITY            0x00080000L
#define MCI_DGV_SETAUDIO_RECORD             0x00100000L
#define MCI_DGV_SETAUDIO_LEFT               0x00200000L
#define MCI_DGV_SETAUDIO_RIGHT              0x00400000L
#define MCI_DGV_SETAUDIO_ITEM               0x00800000L
#define MCI_DGV_SETAUDIO_VALUE              0x01000000L
#define MCI_DGV_SETAUDIO_INPUT              0x02000000L
#define MCI_DGV_SETAUDIO_OUTPUT             0x04000000L

/* values for the dwItem parameter of MCI_DGV_SETAUDIO_PARMS */

#define MCI_DGV_SETAUDIO_TREBLE             0x00004000L
#define MCI_DGV_SETAUDIO_BASS               0x00004001L
#define MCI_DGV_SETAUDIO_VOLUME             0x00004002L
#define MCI_DGV_SETAUDIO_STREAM             0x00004003L
#define MCI_DGV_SETAUDIO_SOURCE             0x00004004L
#define MCI_DGV_SETAUDIO_SAMPLESPERSEC      0x00004005L
#define MCI_DGV_SETAUDIO_AVGBYTESPERSEC     0x00004006L
#define MCI_DGV_SETAUDIO_BLOCKALIGN         0x00004007L
#define MCI_DGV_SETAUDIO_BITSPERSAMPLE      0x00004008L

/* values for the dwValue parameter of MCI_DGV_SETAUDIO_PARMS
   used with MCI_DGV_SETAUDIO_SOURCE */

#define MCI_DGV_SETAUDIO_SOURCE_STEREO      0x00000000L
#define MCI_DGV_SETAUDIO_SOURCE_LEFT        0x00000001L
#define MCI_DGV_SETAUDIO_SOURCE_RIGHT       0x00000002L
#define MCI_DGV_SETAUDIO_SOURCE_AVERAGE     0x00004000L

/* flags for the dwFlags parameter of MCI_SETVIDEO command */

#define MCI_DGV_SETVIDEO_QUALITY            0x00010000L
#define MCI_DGV_SETVIDEO_ALG                0x00020000L
#define MCI_DGV_SETVIDEO_CLOCKTIME          0x00040000L
#define MCI_DGV_SETVIDEO_SRC_NUMBER         0x00080000L
#define MCI_DGV_SETVIDEO_ITEM               0x00100000L
#define MCI_DGV_SETVIDEO_OVER               0x00200000L
#define MCI_DGV_SETVIDEO_RECORD             0x00400000L
#define MCI_DGV_SETVIDEO_STILL              0x00800000L
#define MCI_DGV_SETVIDEO_VALUE              0x01000000L
#define MCI_DGV_SETVIDEO_INPUT              0x02000000L
#define MCI_DGV_SETVIDEO_OUTPUT             0x04000000L

/* values for the dwTo field of MCI_SETVIDEO_PARMS
   used with MCI_DGV_SETVIDEO_SOURCE */

#define MCI_DGV_SETVIDEO_SRC_NTSC           0x00004000L
#define MCI_DGV_SETVIDEO_SRC_RGB            0x00004001L
#define MCI_DGV_SETVIDEO_SRC_SVIDEO         0x00004002L
#define MCI_DGV_SETVIDEO_SRC_PAL            0x00004003L
#define MCI_DGV_SETVIDEO_SRC_SECAM          0x00004004L
#define MCI_DGV_SETVIDEO_SRC_GENERIC        0x00004005L

/* values for the dwItem field of MCI_SETVIDEO_PARMS */

#define MCI_DGV_SETVIDEO_BRIGHTNESS         0x00004000L
#define MCI_DGV_SETVIDEO_COLOR              0x00004001L
#define MCI_DGV_SETVIDEO_CONTRAST           0x00004002L
#define MCI_DGV_SETVIDEO_TINT               0x00004003L
#define MCI_DGV_SETVIDEO_SHARPNESS          0x00004004L
#define MCI_DGV_SETVIDEO_GAMMA              0x00004005L
#define MCI_DGV_SETVIDEO_STREAM             0x00004006L
#define MCI_DGV_SETVIDEO_PALHANDLE          0x00004007L
#define MCI_DGV_SETVIDEO_FRAME_RATE         0x00004008L
#define MCI_DGV_SETVIDEO_SOURCE             0x00004009L
#define MCI_DGV_SETVIDEO_KEY_INDEX          0x0000400aL
#define MCI_DGV_SETVIDEO_KEY_COLOR          0x0000400bL
#define MCI_DGV_SETVIDEO_BITSPERPEL         0x0000400cL

/* flags for the dwFlags parameter of MCI_SIGNAL */

#define MCI_DGV_SIGNAL_AT                   0x00010000L
#define MCI_DGV_SIGNAL_EVERY                0x00020000L
#define MCI_DGV_SIGNAL_USERVAL              0x00040000L
#define MCI_DGV_SIGNAL_CANCEL               0x00080000L
#define MCI_DGV_SIGNAL_POSITION             0x00100000L

/* The following is the function digitalvideo drivers must use
 * to signal when a frame marked by the SIGNAL command has been rendered:
 *
 *  SEND_DGVSIGNAL(dwFlags, dwCallback, hDriver, wDeviceID, dwUser, dwPos )
 *
 * The following is a description of the parameters:
 *
 *  dwFlags    - the dwFlags parameter passed when the signal was set
 *  dwCallback - the dwCallback value from the MCI_DGV_SIGNAL_PARMS struct
 *               used to set the signal
 *  hDriver    - the handle assigned to the driver by MMSYSTEM when the
 *               device was opened
 *  wDeviceID  - the device ID
 *  dwUser     - the dwUserParm value from the MCI_DGV_SIGNAL_PARMS struct
 *               used to set the signal
 *  dwPos      - the position at which the signal was sent, in the current
 *               time format.
 *
 * The window indicated by the handle in the dwCallback field is notified
 * by means of a Windows message with the following form:
 *
 * msg    = MM_MCISIGNAL
 * wParam = wDeviceID of the sending driver
 * lParam = the uservalue specified or the position the signal was sent
 *          at; the latter if the MCI_DGV_SIGNAL_POSITION flag was set
 *          in the dwFlags parameter when the signal was created.
 */

#define SEND_DGVSIGNAL(dwFlags, dwCallback, hDriver, wDeviceID, dwUser, dwPos ) \
  DriverCallback( (dwCallback), DCB_WINDOW, (HANDLE)(wDeviceID), MM_MCISIGNAL,\
  hDriver, ((dwFlags) & MCI_DGV_SIGNAL_POSITION) ? (dwPos):(dwUser),\
  ((dwFlags) & MCI_DGV_SIGNAL_POSITION) ? (dwUser):(dwPos))

/* flags for the dwFlags parameter of MCI_STATUS command */

#define MCI_DGV_STATUS_NOMINAL              0x00020000L
#define MCI_DGV_STATUS_REFERENCE            0x00040000L
#define MCI_DGV_STATUS_LEFT                 0x00080000L
#define MCI_DGV_STATUS_RIGHT                0x00100000L
#define MCI_DGV_STATUS_DISKSPACE            0x00200000L
#define MCI_DGV_STATUS_INPUT                0x00400000L
#define MCI_DGV_STATUS_OUTPUT               0x00800000L
#define MCI_DGV_STATUS_RECORD               0x01000000L

/* values for dwItem field of MCI_STATUS_PARMS structure */

#define MCI_DGV_STATUS_AUDIO_INPUT          0x00004000L
#define MCI_DGV_STATUS_HWND                 0x00004001L
#define MCI_DGV_STATUS_SPEED                0x00004003L
#define MCI_DGV_STATUS_HPAL                 0x00004004L
#define MCI_DGV_STATUS_BRIGHTNESS           0x00004005L
#define MCI_DGV_STATUS_COLOR                0x00004006L
#define MCI_DGV_STATUS_CONTRAST             0x00004007L
#define MCI_DGV_STATUS_FILEFORMAT           0x00004008L
#define MCI_DGV_STATUS_AUDIO_SOURCE         0x00004009L
#define MCI_DGV_STATUS_GAMMA                0x0000400aL
#define MCI_DGV_STATUS_MONITOR              0x0000400bL
#define MCI_DGV_STATUS_MONITOR_METHOD       0x0000400cL
#define MCI_DGV_STATUS_FRAME_RATE           0x0000400eL
#define MCI_DGV_STATUS_BASS                 0x0000400fL
#define MCI_DGV_STATUS_SIZE                 0x00004010L
#define MCI_DGV_STATUS_SEEK_EXACTLY         0x00004011L
#define MCI_DGV_STATUS_SHARPNESS            0x00004012L
#define MCI_DGV_STATUS_SMPTE                0x00004013L
#define MCI_DGV_STATUS_AUDIO                0x00004014L
#define MCI_DGV_STATUS_TINT                 0x00004015L
#define MCI_DGV_STATUS_TREBLE               0x00004016L
#define MCI_DGV_STATUS_UNSAVED              0x00004017L
#define MCI_DGV_STATUS_VIDEO                0x00004018L
#define MCI_DGV_STATUS_VOLUME               0x00004019L
#define MCI_DGV_STATUS_AUDIO_RECORD         0x0000401aL
#define MCI_DGV_STATUS_VIDEO_SOURCE         0x0000401bL
#define MCI_DGV_STATUS_VIDEO_RECORD         0x0000401cL
#define MCI_DGV_STATUS_STILL_FILEFORMAT     0x0000401dL
#define MCI_DGV_STATUS_VIDEO_SRC_NUM        0x0000401eL
#define MCI_DGV_STATUS_FILE_MODE            0x0000401fL
#define MCI_DGV_STATUS_FILE_COMPLETION      0x00004020L
#define MCI_DGV_STATUS_WINDOW_VISIBLE       0x00004021L
#define MCI_DGV_STATUS_WINDOW_MINIMIZED     0x00004022L
#define MCI_DGV_STATUS_WINDOW_MAXIMIZED     0x00004023L
#define MCI_DGV_STATUS_KEY_INDEX            0x00004024L
#define MCI_DGV_STATUS_KEY_COLOR            0x00004025L
#define MCI_DGV_STATUS_PAUSE_MODE           0x00004026L
#define MCI_DGV_STATUS_SAMPLESPERSEC        0x00004027L
#define MCI_DGV_STATUS_AVGBYTESPERSEC       0x00004028L
#define MCI_DGV_STATUS_BLOCKALIGN           0x00004029L
#define MCI_DGV_STATUS_BITSPERSAMPLE        0x0000402aL
#define MCI_DGV_STATUS_BITSPERPEL           0x0000402bL
#define MCI_DGV_STATUS_FORWARD              0x0000402cL
#define MCI_DGV_STATUS_AUDIO_STREAM         0x0000402dL
#define MCI_DGV_STATUS_VIDEO_STREAM         0x0000402eL

/* flags for dwFlags parameter of MCI_STEP command message */

#define MCI_DGV_STEP_REVERSE                0x00010000L
#define MCI_DGV_STEP_FRAMES                 0x00020000L

/* flags for dwFlags parameter of MCI_STOP command message */

#define MCI_DGV_STOP_HOLD                   0x00010000L

/* flags for dwFlags parameter of MCI_UPDATE command message */

#define MCI_DGV_UPDATE_HDC                  0x00020000L
#define MCI_DGV_UPDATE_PAINT                0x00040000L

/* flags for dwFlags parameter of MCI_WHERE command message */

#define MCI_DGV_WHERE_SOURCE                0x00020000L
#define MCI_DGV_WHERE_DESTINATION           0x00040000L
#define MCI_DGV_WHERE_FRAME                 0x00080000L
#define MCI_DGV_WHERE_VIDEO                 0x00100000L
#define MCI_DGV_WHERE_WINDOW                0x00200000L
#define MCI_DGV_WHERE_MAX                   0x00400000L

/* flags for dwFlags parameter of MCI_WINDOW command message */

#define MCI_DGV_WINDOW_HWND                 0x00010000L
#define MCI_DGV_WINDOW_STATE                0x00040000L
#define MCI_DGV_WINDOW_TEXT                 0x00080000L

/* flags for hWnd parameter of MCI_DGV_WINDOW_PARMS parameter block */

#define MCI_DGV_WINDOW_DEFAULT              0x00000000L

/* parameter block for MCI_WHERE, MCI_PUT, MCI_FREEZE, MCI_UNFREEZE cmds */

typedef struct {
    DWORD_PTR   dwCallback;
#ifdef MCI_USE_OFFEXT
    POINT   ptOffset;
    POINT   ptExtent;
#else	
    RECT    rc;
#endif
} MCI_DGV_RECT_PARMS;
typedef MCI_DGV_RECT_PARMS FAR * LPMCI_DGV_RECT_PARMS;

/* parameter block for MCI_CAPTURE command message */

typedef struct {
    DWORD_PTR   dwCallback;
    LPSTR   lpstrFileName;
#ifdef MCI_USE_OFFEXT
    POINT   ptOffset;
    POINT   ptExtent;
#else	
    RECT    rc;
#endif
} MCI_DGV_CAPTURE_PARMSA;
typedef struct {
    DWORD_PTR   dwCallback;
    LPWSTR  lpstrFileName;
#ifdef MCI_USE_OFFEXT
    POINT   ptOffset;
    POINT   ptExtent;
#else	
    RECT    rc;
#endif
} MCI_DGV_CAPTURE_PARMSW;
#ifdef UNICODE
typedef MCI_DGV_CAPTURE_PARMSW MCI_DGV_CAPTURE_PARMS;
#else
typedef MCI_DGV_CAPTURE_PARMSA MCI_DGV_CAPTURE_PARMS;
#endif // UNICODE
typedef MCI_DGV_CAPTURE_PARMSA FAR * LPMCI_DGV_CAPTURE_PARMSA;
typedef MCI_DGV_CAPTURE_PARMSW FAR * LPMCI_DGV_CAPTURE_PARMSW;
#ifdef UNICODE
typedef LPMCI_DGV_CAPTURE_PARMSW LPMCI_DGV_CAPTURE_PARMS;
#else
typedef LPMCI_DGV_CAPTURE_PARMSA LPMCI_DGV_CAPTURE_PARMS;
#endif // UNICODE

/* parameter block for MCI_CLOSE command message */

typedef MCI_GENERIC_PARMS MCI_CLOSE_PARMS;
typedef MCI_CLOSE_PARMS FAR * LPMCI_CLOSE_PARMS;

/* parameter block for MCI_COPY command message */

typedef struct {
    DWORD_PTR   dwCallback;
    DWORD   dwFrom;
    DWORD   dwTo;
#ifdef MCI_USE_OFFEXT
    POINT   ptOffset;
    POINT   ptExtent;
#else	
    RECT    rc;
#endif
    DWORD   dwAudioStream;
    DWORD   dwVideoStream;
} MCI_DGV_COPY_PARMS;
typedef MCI_DGV_COPY_PARMS FAR * LPMCI_DGV_COPY_PARMS;

/* parameter block for MCI_CUE command message */

typedef struct {
    DWORD_PTR   dwCallback;
    DWORD   dwTo;
} MCI_DGV_CUE_PARMS;
typedef MCI_DGV_CUE_PARMS FAR * LPMCI_DGV_CUE_PARMS;

/* parameter block for MCI_CUT command message */

typedef struct {
    DWORD_PTR   dwCallback;
    DWORD   dwFrom;
    DWORD   dwTo;
#ifdef MCI_USE_OFFEXT
    POINT   ptOffset;
    POINT   ptExtent;
#else	
    RECT    rc;
#endif
    DWORD   dwAudioStream;
    DWORD   dwVideoStream;
} MCI_DGV_CUT_PARMS;
typedef MCI_DGV_CUT_PARMS FAR * LPMCI_DGV_CUT_PARMS;

/* parameter block for MCI_DELETE command message */

typedef struct {
    DWORD_PTR   dwCallback;
    DWORD   dwFrom;
    DWORD   dwTo;
#ifdef MCI_USE_OFFEXT
    POINT   ptOffset;
    POINT   ptExtent;
#else	
    RECT    rc;
#endif
    DWORD   dwAudioStream;
    DWORD   dwVideoStream;
} MCI_DGV_DELETE_PARMS;
typedef MCI_DGV_DELETE_PARMS FAR * LPMCI_DGV_DELETE_PARMS;

/* parameter block for MCI_FREEZE command message */

typedef MCI_DGV_RECT_PARMS MCI_DGV_FREEZE_PARMS;
typedef MCI_DGV_FREEZE_PARMS FAR * LPMCI_DGV_FREEZE_PARMS;

/* parameter block for MCI_INFO command message */

typedef struct  {
    DWORD_PTR   dwCallback;
    LPSTR   lpstrReturn;
    DWORD   dwRetSize;
    DWORD   dwItem;
} MCI_DGV_INFO_PARMSA;
typedef struct  {
    DWORD_PTR   dwCallback;
    LPWSTR  lpstrReturn;
    DWORD   dwRetSize;
    DWORD   dwItem;
} MCI_DGV_INFO_PARMSW;
#ifdef UNICODE
typedef MCI_DGV_INFO_PARMSW MCI_DGV_INFO_PARMS;
#else
typedef MCI_DGV_INFO_PARMSA MCI_DGV_INFO_PARMS;
#endif // UNICODE
//? already typedef'd?  //typedef MCI_INFO_PARMS FAR * LPMCI_INFO_PARMS;
typedef MCI_DGV_INFO_PARMSA FAR * LPMCI_DGV_INFO_PARMSA;
typedef MCI_DGV_INFO_PARMSW FAR * LPMCI_DGV_INFO_PARMSW;
#ifdef UNICODE
typedef LPMCI_DGV_INFO_PARMSW LPMCI_DGV_INFO_PARMS;
#else
typedef LPMCI_DGV_INFO_PARMSA LPMCI_DGV_INFO_PARMS;
#endif // UNICODE

/* parameter block for MCI_LIST command message */

typedef struct {
    DWORD_PTR   dwCallback;
    LPSTR   lpstrReturn;
    DWORD   dwLength;
    DWORD   dwNumber;
    DWORD   dwItem;
    LPSTR   lpstrAlgorithm;
} MCI_DGV_LIST_PARMSA;
typedef struct {
    DWORD_PTR   dwCallback;
    LPWSTR  lpstrReturn;
    DWORD   dwLength;
    DWORD   dwNumber;
    DWORD   dwItem;
    LPWSTR  lpstrAlgorithm;
} MCI_DGV_LIST_PARMSW;
#ifdef UNICODE
typedef MCI_DGV_LIST_PARMSW MCI_DGV_LIST_PARMS;
#else
typedef MCI_DGV_LIST_PARMSA MCI_DGV_LIST_PARMS;
#endif // UNICODE
typedef MCI_DGV_LIST_PARMSA FAR * LPMCI_DGV_LIST_PARMSA;
typedef MCI_DGV_LIST_PARMSW FAR * LPMCI_DGV_LIST_PARMSW;
#ifdef UNICODE
typedef LPMCI_DGV_LIST_PARMSW LPMCI_DGV_LIST_PARMS;
#else
typedef LPMCI_DGV_LIST_PARMSA LPMCI_DGV_LIST_PARMS;
#endif // UNICODE

/* parameter block for MCI_LOAD command message */

typedef MCI_LOAD_PARMS MCI_DGV_LOAD_PARMS;
typedef MCI_DGV_LOAD_PARMS FAR * LPMCI_DGV_LOAD_PARMS;

/* parameter block for MCI_MONITOR command message */

typedef struct {
    DWORD_PTR   dwCallback;
    DWORD   dwSource;
    DWORD   dwMethod;
} MCI_DGV_MONITOR_PARMS;
typedef MCI_DGV_MONITOR_PARMS FAR * LPMCI_DGV_MONITOR_PARMS;

/* parameter block for MCI_OPEN command message */

typedef struct {
    DWORD_PTR   dwCallback;
    UINT    wDeviceID;
#ifndef _WIN32
    WORD    wReserved0;
#endif
    LPSTR   lpstrDeviceType;
    LPSTR   lpstrElementName;
    LPSTR   lpstrAlias;
    DWORD   dwStyle;
    HWND    hWndParent;
#ifndef _WIN32
    WORD    wReserved1;
#endif
} MCI_DGV_OPEN_PARMSA;
typedef struct {
    DWORD_PTR   dwCallback;
    UINT    wDeviceID;
#ifndef _WIN32
    WORD    wReserved0;
#endif
    LPWSTR  lpstrDeviceType;
    LPWSTR  lpstrElementName;
    LPWSTR  lpstrAlias;
    DWORD   dwStyle;
    HWND    hWndParent;
#ifndef _WIN32
    WORD    wReserved1;
#endif
} MCI_DGV_OPEN_PARMSW;
#ifdef UNICODE
typedef MCI_DGV_OPEN_PARMSW MCI_DGV_OPEN_PARMS;
#else
typedef MCI_DGV_OPEN_PARMSA MCI_DGV_OPEN_PARMS;
#endif // UNICODE
typedef MCI_DGV_OPEN_PARMSA FAR * LPMCI_DGV_OPEN_PARMSA;
typedef MCI_DGV_OPEN_PARMSW FAR * LPMCI_DGV_OPEN_PARMSW;
#ifdef UNICODE
typedef LPMCI_DGV_OPEN_PARMSW LPMCI_DGV_OPEN_PARMS;
#else
typedef LPMCI_DGV_OPEN_PARMSA LPMCI_DGV_OPEN_PARMS;
#endif // UNICODE

/* parameter block for MCI_PAUSE command message */

typedef MCI_GENERIC_PARMS MCI_DGV_PAUSE_PARMS;
typedef MCI_DGV_PAUSE_PARMS FAR * LPMCI_DGV_PAUSE_PARMS;

/* parameter block for MCI_PASTE command message */

typedef struct {
    DWORD_PTR   dwCallback;
    DWORD   dwTo;
#ifdef MCI_USE_OFFEXT
    POINT   ptOffset;
    POINT   ptExtent;
#else	
    RECT    rc;
#endif
    DWORD   dwAudioStream;
    DWORD   dwVideoStream;
} MCI_DGV_PASTE_PARMS;
typedef MCI_DGV_PASTE_PARMS FAR * LPMCI_DGV_PASTE_PARMS;

/* parameter block for MCI_PLAY command message */

typedef MCI_PLAY_PARMS MCI_DGV_PLAY_PARMS;
typedef MCI_DGV_PLAY_PARMS FAR * LPMCI_DGV_PLAY_PARMS;

/* parameter block for MCI_PUT command message */

typedef MCI_DGV_RECT_PARMS MCI_DGV_PUT_PARMS;
typedef MCI_DGV_PUT_PARMS FAR * LPMCI_DGV_PUT_PARMS;

/* parameter block for MCI_QUALITY command message */

typedef struct {
    DWORD_PTR   dwCallback;
    DWORD       dwItem;
    LPSTR       lpstrName;
    DWORD       lpstrAlgorithm;
    DWORD       dwHandle;
} MCI_DGV_QUALITY_PARMSA;
typedef struct {
    DWORD_PTR   dwCallback;
    DWORD       dwItem;
    LPWSTR      lpstrName;
    DWORD       lpstrAlgorithm;
    DWORD       dwHandle;
} MCI_DGV_QUALITY_PARMSW;
#ifdef UNICODE
typedef MCI_DGV_QUALITY_PARMSW MCI_DGV_QUALITY_PARMS;
#else
typedef MCI_DGV_QUALITY_PARMSA MCI_DGV_QUALITY_PARMS;
#endif // UNICODE
typedef MCI_DGV_QUALITY_PARMSA FAR * LPMCI_DGV_QUALITY_PARMSA;
typedef MCI_DGV_QUALITY_PARMSW FAR * LPMCI_DGV_QUALITY_PARMSW;
#ifdef UNICODE
typedef LPMCI_DGV_QUALITY_PARMSW LPMCI_DGV_QUALITY_PARMS;
#else
typedef LPMCI_DGV_QUALITY_PARMSA LPMCI_DGV_QUALITY_PARMS;
#endif // UNICODE

/* parameter block for MCI_REALIZE command message */

typedef MCI_GENERIC_PARMS MCI_REALIZE_PARMS;
typedef MCI_REALIZE_PARMS FAR * LPMCI_REALIZE_PARMS;

/* parameter block for MCI_RECORD command message */

typedef struct {
    DWORD_PTR   dwCallback;
    DWORD   dwFrom;
    DWORD   dwTo;
#ifdef MCI_USE_OFFEXT
    POINT   ptOffset;
    POINT   ptExtent;
#else	
    RECT    rc;
#endif
    DWORD   dwAudioStream;
    DWORD   dwVideoStream;
} MCI_DGV_RECORD_PARMS;
typedef MCI_DGV_RECORD_PARMS FAR * LPMCI_DGV_RECORD_PARMS;

/* parameter block for MCI_RESERVE command message */

typedef struct {
    DWORD_PTR   dwCallback;
    LPSTR   lpstrPath;
    DWORD   dwSize;
} MCI_DGV_RESERVE_PARMSA;
typedef struct {
    DWORD_PTR   dwCallback;
    LPWSTR  lpstrPath;
    DWORD   dwSize;
} MCI_DGV_RESERVE_PARMSW;
#ifdef UNICODE
typedef MCI_DGV_RESERVE_PARMSW MCI_DGV_RESERVE_PARMS;
#else
typedef MCI_DGV_RESERVE_PARMSA MCI_DGV_RESERVE_PARMS;
#endif // UNICODE
typedef MCI_DGV_RESERVE_PARMSA FAR * LPMCI_DGV_RESERVE_PARMSA;
typedef MCI_DGV_RESERVE_PARMSW FAR * LPMCI_DGV_RESERVE_PARMSW;
#ifdef UNICODE
typedef LPMCI_DGV_RESERVE_PARMSW LPMCI_DGV_RESERVE_PARMS;
#else
typedef LPMCI_DGV_RESERVE_PARMSA LPMCI_DGV_RESERVE_PARMS;
#endif // UNICODE

/* parameter block for MCI_RESTORE command message */

typedef struct {
    DWORD_PTR   dwCallback;
    LPSTR   lpstrFileName;
#ifdef MCI_USE_OFFEXT
    POINT   ptOffset;
    POINT   ptExtent;
#else	
    RECT    rc;
#endif
} MCI_DGV_RESTORE_PARMSA;
typedef struct {
    DWORD_PTR   dwCallback;
    LPWSTR  lpstrFileName;
#ifdef MCI_USE_OFFEXT
    POINT   ptOffset;
    POINT   ptExtent;
#else	
    RECT    rc;
#endif
} MCI_DGV_RESTORE_PARMSW;
#ifdef UNICODE
typedef MCI_DGV_RESTORE_PARMSW MCI_DGV_RESTORE_PARMS;
#else
typedef MCI_DGV_RESTORE_PARMSA MCI_DGV_RESTORE_PARMS;
#endif // UNICODE
typedef MCI_DGV_RESTORE_PARMSA FAR * LPMCI_DGV_RESTORE_PARMSA;
typedef MCI_DGV_RESTORE_PARMSW FAR * LPMCI_DGV_RESTORE_PARMSW;
#ifdef UNICODE
typedef LPMCI_DGV_RESTORE_PARMSW LPMCI_DGV_RESTORE_PARMS;
#else
typedef LPMCI_DGV_RESTORE_PARMSA LPMCI_DGV_RESTORE_PARMS;
#endif // UNICODE

/* parameter block for MCI_RESUME command message */

typedef MCI_GENERIC_PARMS MCI_DGV_RESUME_PARMS;
typedef MCI_DGV_RESUME_PARMS FAR * LPMCI_DGV_RESUME_PARMS;

/* parameter block for MCI_SAVE command message */

typedef struct {
    DWORD_PTR   dwCallback;
    LPSTR   lpstrFileName;
    RECT    rc;
} MCI_DGV_SAVE_PARMSA;
typedef struct {
    DWORD_PTR   dwCallback;
    LPWSTR  lpstrFileName;
    RECT    rc;
} MCI_DGV_SAVE_PARMSW;
#ifdef UNICODE
typedef MCI_DGV_SAVE_PARMSW MCI_DGV_SAVE_PARMS;
#else
typedef MCI_DGV_SAVE_PARMSA MCI_DGV_SAVE_PARMS;
#endif // UNICODE
typedef MCI_DGV_SAVE_PARMSA FAR * LPMCI_DGV_SAVE_PARMSA;
typedef MCI_DGV_SAVE_PARMSW FAR * LPMCI_DGV_SAVE_PARMSW;
#ifdef UNICODE
typedef LPMCI_DGV_SAVE_PARMSW LPMCI_DGV_SAVE_PARMS;
#else
typedef LPMCI_DGV_SAVE_PARMSA LPMCI_DGV_SAVE_PARMS;
#endif // UNICODE

/* parameter block for MCI_SET command message */

typedef struct {
    DWORD_PTR   dwCallback;
    DWORD   dwTimeFormat;
    DWORD   dwAudio;
    DWORD   dwFileFormat;
    DWORD   dwSpeed;
} MCI_DGV_SET_PARMS;
typedef MCI_DGV_SET_PARMS FAR * LPMCI_DGV_SET_PARMS;

/* parameter block for MCI_SETAUDIO command message */

typedef struct {
    DWORD_PTR   dwCallback;
    DWORD   dwItem;
    DWORD   dwValue;
    DWORD   dwOver;
    LPSTR   lpstrAlgorithm;
    LPSTR   lpstrQuality;
} MCI_DGV_SETAUDIO_PARMSA;
typedef struct {
    DWORD_PTR   dwCallback;
    DWORD   dwItem;
    DWORD   dwValue;
    DWORD   dwOver;
    LPWSTR  lpstrAlgorithm;
    LPWSTR  lpstrQuality;
} MCI_DGV_SETAUDIO_PARMSW;
#ifdef UNICODE
typedef MCI_DGV_SETAUDIO_PARMSW MCI_DGV_SETAUDIO_PARMS;
#else
typedef MCI_DGV_SETAUDIO_PARMSA MCI_DGV_SETAUDIO_PARMS;
#endif // UNICODE
typedef MCI_DGV_SETAUDIO_PARMSA FAR * LPMCI_DGV_SETAUDIO_PARMSA;
typedef MCI_DGV_SETAUDIO_PARMSW FAR * LPMCI_DGV_SETAUDIO_PARMSW;
#ifdef UNICODE
typedef LPMCI_DGV_SETAUDIO_PARMSW LPMCI_DGV_SETAUDIO_PARMS;
#else
typedef LPMCI_DGV_SETAUDIO_PARMSA LPMCI_DGV_SETAUDIO_PARMS;
#endif // UNICODE

/* parameter block for MCI_SIGNAL command message */

typedef struct {
    DWORD_PTR   dwCallback;
    DWORD   dwPosition;
    DWORD   dwPeriod;
    DWORD   dwUserParm;
} MCI_DGV_SIGNAL_PARMS;
typedef MCI_DGV_SIGNAL_PARMS FAR * LPMCI_DGV_SIGNAL_PARMS;

/* parameter block for MCI_SETVIDEO command message */

typedef struct {
    DWORD_PTR   dwCallback;
    DWORD   dwItem;
    DWORD   dwValue;
    DWORD   dwOver;
    LPSTR   lpstrAlgorithm;
    LPSTR   lpstrQuality;
    DWORD   dwSourceNumber;
} MCI_DGV_SETVIDEO_PARMSA;
typedef struct {
    DWORD_PTR   dwCallback;
    DWORD   dwItem;
    DWORD   dwValue;
    DWORD   dwOver;
    LPWSTR  lpstrAlgorithm;
    LPWSTR  lpstrQuality;
    DWORD   dwSourceNumber;
} MCI_DGV_SETVIDEO_PARMSW;
#ifdef UNICODE
typedef MCI_DGV_SETVIDEO_PARMSW MCI_DGV_SETVIDEO_PARMS;
#else
typedef MCI_DGV_SETVIDEO_PARMSA MCI_DGV_SETVIDEO_PARMS;
#endif // UNICODE
typedef MCI_DGV_SETVIDEO_PARMSA FAR * LPMCI_DGV_SETVIDEO_PARMSA;
typedef MCI_DGV_SETVIDEO_PARMSW FAR * LPMCI_DGV_SETVIDEO_PARMSW;
#ifdef UNICODE
typedef LPMCI_DGV_SETVIDEO_PARMSW LPMCI_DGV_SETVIDEO_PARMS;
#else
typedef LPMCI_DGV_SETVIDEO_PARMSA LPMCI_DGV_SETVIDEO_PARMS;
#endif // UNICODE

/* parameter block for MCI_STATUS command message */

typedef struct {
    DWORD_PTR dwCallback;
    DWORD_PTR dwReturn;
    DWORD   dwItem;
    DWORD   dwTrack;
    LPSTR   lpstrDrive;
    DWORD   dwReference;
} MCI_DGV_STATUS_PARMSA;
typedef struct {
    DWORD_PTR dwCallback;
    DWORD_PTR dwReturn;
    DWORD   dwItem;
    DWORD   dwTrack;
    LPWSTR  lpstrDrive;
    DWORD   dwReference;
} MCI_DGV_STATUS_PARMSW;
#ifdef UNICODE
typedef MCI_DGV_STATUS_PARMSW MCI_DGV_STATUS_PARMS;
#else
typedef MCI_DGV_STATUS_PARMSA MCI_DGV_STATUS_PARMS;
#endif // UNICODE
typedef MCI_DGV_STATUS_PARMSA FAR * LPMCI_DGV_STATUS_PARMSA;
typedef MCI_DGV_STATUS_PARMSW FAR * LPMCI_DGV_STATUS_PARMSW;
#ifdef UNICODE
typedef LPMCI_DGV_STATUS_PARMSW LPMCI_DGV_STATUS_PARMS;
#else
typedef LPMCI_DGV_STATUS_PARMSA LPMCI_DGV_STATUS_PARMS;
#endif // UNICODE

/* parameter block for MCI_STEP command message */

typedef struct {
    DWORD_PTR   dwCallback;
    DWORD   dwFrames;
} MCI_DGV_STEP_PARMS;
typedef MCI_DGV_STEP_PARMS FAR *LPMCI_DGV_STEP_PARMS;

/* parameter block for MCI_STOP command message */

typedef MCI_GENERIC_PARMS MCI_DGV_STOP_PARMS;
typedef MCI_DGV_STOP_PARMS FAR * LPMCI_DGV_STOP_PARMS;

/* parameter block for MCI_UNFREEZE command message */

typedef MCI_DGV_RECT_PARMS MCI_DGV_UNFREEZE_PARMS;
typedef MCI_DGV_UNFREEZE_PARMS FAR * LPMCI_DGV_UNFREEZE_PARMS;

/* parameter block for MCI_UPDATE command message */

typedef struct {
    DWORD_PTR   dwCallback;
#ifdef MCI_USE_OFFEXT
    POINT   ptOffset;
    POINT   ptExtent;
#else	
    RECT    rc;
#endif
    HDC     hDC;

#ifndef _WIN32
    WORD    wReserved0;
#endif
} MCI_DGV_UPDATE_PARMS;
typedef MCI_DGV_UPDATE_PARMS FAR * LPMCI_DGV_UPDATE_PARMS;

/* parameter block for MCI_WHERE command message */

typedef MCI_DGV_RECT_PARMS MCI_DGV_WHERE_PARMS;
typedef MCI_DGV_WHERE_PARMS FAR * LPMCI_DGV_WHERE_PARMS;

/* parameter block for MCI_WINDOW command message */

typedef struct {
    DWORD_PTR   dwCallback;
    HWND    hWnd;
#ifndef _WIN32
    WORD    wReserved1;
#endif
    UINT    nCmdShow;
#ifndef _WIN32
    WORD    wReserved2;
#endif
    LPSTR   lpstrText;
} MCI_DGV_WINDOW_PARMSA;
typedef struct {
    DWORD_PTR   dwCallback;
    HWND    hWnd;
#ifndef _WIN32
    WORD    wReserved1;
#endif
    UINT    nCmdShow;
#ifndef _WIN32
    WORD    wReserved2;
#endif
    LPWSTR  lpstrText;
} MCI_DGV_WINDOW_PARMSW;
#ifdef UNICODE
typedef MCI_DGV_WINDOW_PARMSW MCI_DGV_WINDOW_PARMS;
#else
typedef MCI_DGV_WINDOW_PARMSA MCI_DGV_WINDOW_PARMS;
#endif // UNICODE
typedef MCI_DGV_WINDOW_PARMSA FAR * LPMCI_DGV_WINDOW_PARMSA;
typedef MCI_DGV_WINDOW_PARMSW FAR * LPMCI_DGV_WINDOW_PARMSW;
#ifdef UNICODE
typedef LPMCI_DGV_WINDOW_PARMSW LPMCI_DGV_WINDOW_PARMS;
#else
typedef LPMCI_DGV_WINDOW_PARMSA LPMCI_DGV_WINDOW_PARMS;
#endif // UNICODE

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif	/* __cplusplus */

#ifdef _WIN32
#include <poppack.h>
#else
#ifndef RC_INVOKED
#pragma pack()
#endif
#endif

#endif  /* !_INC_DIGITALV */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\dinput.h ===
/****************************************************************************
 *
 *  Copyright (C) 1996-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dinput.h
 *  Content:    DirectInput include file
 *
 ****************************************************************************/

#ifndef __DINPUT_INCLUDED__
#define __DINPUT_INCLUDED__

#ifndef DIJ_RINGZERO

#ifdef _WIN32
#define COM_NO_WINDOWS_H
#include <objbase.h>
#endif

#endif /* DIJ_RINGZERO */

#ifdef __cplusplus
extern "C" {
#endif





/*
 *  To build applications for older versions of DirectInput
 *
 *  #define DIRECTINPUT_VERSION [ 0x0300 | 0x0500 | 0x0700 ]
 *
 *  before #include <dinput.h>.  By default, #include <dinput.h>
 *  will produce a DirectX 8-compatible header file.
 *
 */

#define DIRECTINPUT_HEADER_VERSION  0x0800
#ifndef DIRECTINPUT_VERSION
#define DIRECTINPUT_VERSION         DIRECTINPUT_HEADER_VERSION
#endif

#ifndef DIJ_RINGZERO

/****************************************************************************
 *
 *      Class IDs
 *
 ****************************************************************************/

DEFINE_GUID(CLSID_DirectInput,       0x25E609E0,0xB259,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(CLSID_DirectInputDevice, 0x25E609E1,0xB259,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);

DEFINE_GUID(CLSID_DirectInput8,      0x25E609E4,0xB259,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(CLSID_DirectInputDevice8,0x25E609E5,0xB259,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);

/****************************************************************************
 *
 *      Interfaces
 *
 ****************************************************************************/

DEFINE_GUID(IID_IDirectInputA,     0x89521360,0xAA8A,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(IID_IDirectInputW,     0x89521361,0xAA8A,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(IID_IDirectInput2A,    0x5944E662,0xAA8A,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(IID_IDirectInput2W,    0x5944E663,0xAA8A,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(IID_IDirectInput7A,    0x9A4CB684,0x236D,0x11D3,0x8E,0x9D,0x00,0xC0,0x4F,0x68,0x44,0xAE);
DEFINE_GUID(IID_IDirectInput7W,    0x9A4CB685,0x236D,0x11D3,0x8E,0x9D,0x00,0xC0,0x4F,0x68,0x44,0xAE);
DEFINE_GUID(IID_IDirectInput8A,    0xBF798030,0x483A,0x4DA2,0xAA,0x99,0x5D,0x64,0xED,0x36,0x97,0x00);
DEFINE_GUID(IID_IDirectInput8W,    0xBF798031,0x483A,0x4DA2,0xAA,0x99,0x5D,0x64,0xED,0x36,0x97,0x00);
DEFINE_GUID(IID_IDirectInputDeviceA, 0x5944E680,0xC92E,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(IID_IDirectInputDeviceW, 0x5944E681,0xC92E,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(IID_IDirectInputDevice2A,0x5944E682,0xC92E,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(IID_IDirectInputDevice2W,0x5944E683,0xC92E,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(IID_IDirectInputDevice7A,0x57D7C6BC,0x2356,0x11D3,0x8E,0x9D,0x00,0xC0,0x4F,0x68,0x44,0xAE);
DEFINE_GUID(IID_IDirectInputDevice7W,0x57D7C6BD,0x2356,0x11D3,0x8E,0x9D,0x00,0xC0,0x4F,0x68,0x44,0xAE);
DEFINE_GUID(IID_IDirectInputDevice8A,0x54D41080,0xDC15,0x4833,0xA4,0x1B,0x74,0x8F,0x73,0xA3,0x81,0x79);
DEFINE_GUID(IID_IDirectInputDevice8W,0x54D41081,0xDC15,0x4833,0xA4,0x1B,0x74,0x8F,0x73,0xA3,0x81,0x79);
DEFINE_GUID(IID_IDirectInputEffect,  0xE7E1F7C0,0x88D2,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);

/****************************************************************************
 *
 *      Predefined object types
 *
 ****************************************************************************/

DEFINE_GUID(GUID_XAxis,   0xA36D02E0,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_YAxis,   0xA36D02E1,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_ZAxis,   0xA36D02E2,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_RxAxis,  0xA36D02F4,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_RyAxis,  0xA36D02F5,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_RzAxis,  0xA36D02E3,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_Slider,  0xA36D02E4,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);

DEFINE_GUID(GUID_Button,  0xA36D02F0,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_Key,     0x55728220,0xD33C,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);

DEFINE_GUID(GUID_POV,     0xA36D02F2,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);

DEFINE_GUID(GUID_Unknown, 0xA36D02F3,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);

/****************************************************************************
 *
 *      Predefined product GUIDs
 *
 ****************************************************************************/

DEFINE_GUID(GUID_SysMouse,   0x6F1D2B60,0xD5A0,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_SysKeyboard,0x6F1D2B61,0xD5A0,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_Joystick   ,0x6F1D2B70,0xD5A0,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_SysMouseEm, 0x6F1D2B80,0xD5A0,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_SysMouseEm2,0x6F1D2B81,0xD5A0,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_SysKeyboardEm, 0x6F1D2B82,0xD5A0,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_SysKeyboardEm2,0x6F1D2B83,0xD5A0,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);

/****************************************************************************
 *
 *      Predefined force feedback effects
 *
 ****************************************************************************/

DEFINE_GUID(GUID_ConstantForce, 0x13541C20,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
DEFINE_GUID(GUID_RampForce,     0x13541C21,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
DEFINE_GUID(GUID_Square,        0x13541C22,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
DEFINE_GUID(GUID_Sine,          0x13541C23,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
DEFINE_GUID(GUID_Triangle,      0x13541C24,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
DEFINE_GUID(GUID_SawtoothUp,    0x13541C25,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
DEFINE_GUID(GUID_SawtoothDown,  0x13541C26,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
DEFINE_GUID(GUID_Spring,        0x13541C27,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
DEFINE_GUID(GUID_Damper,        0x13541C28,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
DEFINE_GUID(GUID_Inertia,       0x13541C29,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
DEFINE_GUID(GUID_Friction,      0x13541C2A,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
DEFINE_GUID(GUID_CustomForce,   0x13541C2B,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);

#endif /* DIJ_RINGZERO */

/****************************************************************************
 *
 *      Interfaces and Structures...
 *
 ****************************************************************************/

#if(DIRECTINPUT_VERSION >= 0x0500)

/****************************************************************************
 *
 *      IDirectInputEffect
 *
 ****************************************************************************/

#define DIEFT_ALL                   0x00000000

#define DIEFT_CONSTANTFORCE         0x00000001
#define DIEFT_RAMPFORCE             0x00000002
#define DIEFT_PERIODIC              0x00000003
#define DIEFT_CONDITION             0x00000004
#define DIEFT_CUSTOMFORCE           0x00000005
#define DIEFT_HARDWARE              0x000000FF
#define DIEFT_FFATTACK              0x00000200
#define DIEFT_FFFADE                0x00000400
#define DIEFT_SATURATION            0x00000800
#define DIEFT_POSNEGCOEFFICIENTS    0x00001000
#define DIEFT_POSNEGSATURATION      0x00002000
#define DIEFT_DEADBAND              0x00004000
#define DIEFT_STARTDELAY            0x00008000
#define DIEFT_GETTYPE(n)            LOBYTE(n)

#define DI_DEGREES                  100
#define DI_FFNOMINALMAX             10000
#define DI_SECONDS                  1000000

typedef struct DICONSTANTFORCE {
    LONG  lMagnitude;
} DICONSTANTFORCE, *LPDICONSTANTFORCE;
typedef const DICONSTANTFORCE *LPCDICONSTANTFORCE;

typedef struct DIRAMPFORCE {
    LONG  lStart;
    LONG  lEnd;
} DIRAMPFORCE, *LPDIRAMPFORCE;
typedef const DIRAMPFORCE *LPCDIRAMPFORCE;

typedef struct DIPERIODIC {
    DWORD dwMagnitude;
    LONG  lOffset;
    DWORD dwPhase;
    DWORD dwPeriod;
} DIPERIODIC, *LPDIPERIODIC;
typedef const DIPERIODIC *LPCDIPERIODIC;

typedef struct DICONDITION {
    LONG  lOffset;
    LONG  lPositiveCoefficient;
    LONG  lNegativeCoefficient;
    DWORD dwPositiveSaturation;
    DWORD dwNegativeSaturation;
    LONG  lDeadBand;
} DICONDITION, *LPDICONDITION;
typedef const DICONDITION *LPCDICONDITION;

typedef struct DICUSTOMFORCE {
    DWORD cChannels;
    DWORD dwSamplePeriod;
    DWORD cSamples;
    LPLONG rglForceData;
} DICUSTOMFORCE, *LPDICUSTOMFORCE;
typedef const DICUSTOMFORCE *LPCDICUSTOMFORCE;


typedef struct DIENVELOPE {
    DWORD dwSize;                   /* sizeof(DIENVELOPE)   */
    DWORD dwAttackLevel;
    DWORD dwAttackTime;             /* Microseconds         */
    DWORD dwFadeLevel;
    DWORD dwFadeTime;               /* Microseconds         */
} DIENVELOPE, *LPDIENVELOPE;
typedef const DIENVELOPE *LPCDIENVELOPE;


/* This structure is defined for DirectX 5.0 compatibility */
typedef struct DIEFFECT_DX5 {
    DWORD dwSize;                   /* sizeof(DIEFFECT_DX5) */
    DWORD dwFlags;                  /* DIEFF_*              */
    DWORD dwDuration;               /* Microseconds         */
    DWORD dwSamplePeriod;           /* Microseconds         */
    DWORD dwGain;
    DWORD dwTriggerButton;          /* or DIEB_NOTRIGGER    */
    DWORD dwTriggerRepeatInterval;  /* Microseconds         */
    DWORD cAxes;                    /* Number of axes       */
    LPDWORD rgdwAxes;               /* Array of axes        */
    LPLONG rglDirection;            /* Array of directions  */
    LPDIENVELOPE lpEnvelope;        /* Optional             */
    DWORD cbTypeSpecificParams;     /* Size of params       */
    LPVOID lpvTypeSpecificParams;   /* Pointer to params    */
} DIEFFECT_DX5, *LPDIEFFECT_DX5;
typedef const DIEFFECT_DX5 *LPCDIEFFECT_DX5;

typedef struct DIEFFECT {
    DWORD dwSize;                   /* sizeof(DIEFFECT)     */
    DWORD dwFlags;                  /* DIEFF_*              */
    DWORD dwDuration;               /* Microseconds         */
    DWORD dwSamplePeriod;           /* Microseconds         */
    DWORD dwGain;
    DWORD dwTriggerButton;          /* or DIEB_NOTRIGGER    */
    DWORD dwTriggerRepeatInterval;  /* Microseconds         */
    DWORD cAxes;                    /* Number of axes       */
    LPDWORD rgdwAxes;               /* Array of axes        */
    LPLONG rglDirection;            /* Array of directions  */
    LPDIENVELOPE lpEnvelope;        /* Optional             */
    DWORD cbTypeSpecificParams;     /* Size of params       */
    LPVOID lpvTypeSpecificParams;   /* Pointer to params    */
#if(DIRECTINPUT_VERSION >= 0x0600)
    DWORD  dwStartDelay;            /* Microseconds         */
#endif /* DIRECTINPUT_VERSION >= 0x0600 */
} DIEFFECT, *LPDIEFFECT;
typedef DIEFFECT DIEFFECT_DX6;
typedef LPDIEFFECT LPDIEFFECT_DX6;
typedef const DIEFFECT *LPCDIEFFECT;


#if(DIRECTINPUT_VERSION >= 0x0700)
#ifndef DIJ_RINGZERO
typedef struct DIFILEEFFECT{
    DWORD       dwSize;
    GUID        GuidEffect;
    LPCDIEFFECT lpDiEffect;
    CHAR        szFriendlyName[MAX_PATH];
}DIFILEEFFECT, *LPDIFILEEFFECT;
typedef const DIFILEEFFECT *LPCDIFILEEFFECT;
typedef BOOL (FAR PASCAL * LPDIENUMEFFECTSINFILECALLBACK)(LPCDIFILEEFFECT , LPVOID);
#endif /* DIJ_RINGZERO */
#endif /* DIRECTINPUT_VERSION >= 0x0700 */

#define DIEFF_OBJECTIDS             0x00000001
#define DIEFF_OBJECTOFFSETS         0x00000002
#define DIEFF_CARTESIAN             0x00000010
#define DIEFF_POLAR                 0x00000020
#define DIEFF_SPHERICAL             0x00000040

#define DIEP_DURATION               0x00000001
#define DIEP_SAMPLEPERIOD           0x00000002
#define DIEP_GAIN                   0x00000004
#define DIEP_TRIGGERBUTTON          0x00000008
#define DIEP_TRIGGERREPEATINTERVAL  0x00000010
#define DIEP_AXES                   0x00000020
#define DIEP_DIRECTION              0x00000040
#define DIEP_ENVELOPE               0x00000080
#define DIEP_TYPESPECIFICPARAMS     0x00000100
#if(DIRECTINPUT_VERSION >= 0x0600)
#define DIEP_STARTDELAY             0x00000200
#define DIEP_ALLPARAMS_DX5          0x000001FF
#define DIEP_ALLPARAMS              0x000003FF
#else /* DIRECTINPUT_VERSION < 0x0600 */
#define DIEP_ALLPARAMS              0x000001FF
#endif /* DIRECTINPUT_VERSION < 0x0600 */
#define DIEP_START                  0x20000000
#define DIEP_NORESTART              0x40000000
#define DIEP_NODOWNLOAD             0x80000000
#define DIEB_NOTRIGGER              0xFFFFFFFF

#define DIES_SOLO                   0x00000001
#define DIES_NODOWNLOAD             0x80000000

#define DIEGES_PLAYING              0x00000001
#define DIEGES_EMULATED             0x00000002

typedef struct DIEFFESCAPE {
    DWORD   dwSize;
    DWORD   dwCommand;
    LPVOID  lpvInBuffer;
    DWORD   cbInBuffer;
    LPVOID  lpvOutBuffer;
    DWORD   cbOutBuffer;
} DIEFFESCAPE, *LPDIEFFESCAPE;

#ifndef DIJ_RINGZERO

#undef INTERFACE
#define INTERFACE IDirectInputEffect

DECLARE_INTERFACE_(IDirectInputEffect, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirectInputEffect methods ***/
    STDMETHOD(Initialize)(THIS_ HINSTANCE,DWORD,REFGUID) PURE;
    STDMETHOD(GetEffectGuid)(THIS_ LPGUID) PURE;
    STDMETHOD(GetParameters)(THIS_ LPDIEFFECT,DWORD) PURE;
    STDMETHOD(SetParameters)(THIS_ LPCDIEFFECT,DWORD) PURE;
    STDMETHOD(Start)(THIS_ DWORD,DWORD) PURE;
    STDMETHOD(Stop)(THIS) PURE;
    STDMETHOD(GetEffectStatus)(THIS_ LPDWORD) PURE;
    STDMETHOD(Download)(THIS) PURE;
    STDMETHOD(Unload)(THIS) PURE;
    STDMETHOD(Escape)(THIS_ LPDIEFFESCAPE) PURE;
};

typedef struct IDirectInputEffect *LPDIRECTINPUTEFFECT;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectInputEffect_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectInputEffect_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirectInputEffect_Release(p) (p)->lpVtbl->Release(p)
#define IDirectInputEffect_Initialize(p,a,b,c) (p)->lpVtbl->Initialize(p,a,b,c)
#define IDirectInputEffect_GetEffectGuid(p,a) (p)->lpVtbl->GetEffectGuid(p,a)
#define IDirectInputEffect_GetParameters(p,a,b) (p)->lpVtbl->GetParameters(p,a,b)
#define IDirectInputEffect_SetParameters(p,a,b) (p)->lpVtbl->SetParameters(p,a,b)
#define IDirectInputEffect_Start(p,a,b) (p)->lpVtbl->Start(p,a,b)
#define IDirectInputEffect_Stop(p) (p)->lpVtbl->Stop(p)
#define IDirectInputEffect_GetEffectStatus(p,a) (p)->lpVtbl->GetEffectStatus(p,a)
#define IDirectInputEffect_Download(p) (p)->lpVtbl->Download(p)
#define IDirectInputEffect_Unload(p) (p)->lpVtbl->Unload(p)
#define IDirectInputEffect_Escape(p,a) (p)->lpVtbl->Escape(p,a)
#else
#define IDirectInputEffect_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirectInputEffect_AddRef(p) (p)->AddRef()
#define IDirectInputEffect_Release(p) (p)->Release()
#define IDirectInputEffect_Initialize(p,a,b,c) (p)->Initialize(a,b,c)
#define IDirectInputEffect_GetEffectGuid(p,a) (p)->GetEffectGuid(a)
#define IDirectInputEffect_GetParameters(p,a,b) (p)->GetParameters(a,b)
#define IDirectInputEffect_SetParameters(p,a,b) (p)->SetParameters(a,b)
#define IDirectInputEffect_Start(p,a,b) (p)->Start(a,b)
#define IDirectInputEffect_Stop(p) (p)->Stop()
#define IDirectInputEffect_GetEffectStatus(p,a) (p)->GetEffectStatus(a)
#define IDirectInputEffect_Download(p) (p)->Download()
#define IDirectInputEffect_Unload(p) (p)->Unload()
#define IDirectInputEffect_Escape(p,a) (p)->Escape(a)
#endif

#endif /* DIJ_RINGZERO */

#endif /* DIRECTINPUT_VERSION >= 0x0500 */

/****************************************************************************
 *
 *      IDirectInputDevice
 *
 ****************************************************************************/

#if DIRECTINPUT_VERSION <= 0x700
#define DIDEVTYPE_DEVICE        1
#define DIDEVTYPE_MOUSE         2
#define DIDEVTYPE_KEYBOARD      3
#define DIDEVTYPE_JOYSTICK      4

#else
#define DI8DEVCLASS_ALL             0
#define DI8DEVCLASS_DEVICE          1
#define DI8DEVCLASS_POINTER         2
#define DI8DEVCLASS_KEYBOARD        3
#define DI8DEVCLASS_GAMECTRL        4

#define DI8DEVTYPE_DEVICE           0x11
#define DI8DEVTYPE_MOUSE            0x12
#define DI8DEVTYPE_KEYBOARD         0x13
#define DI8DEVTYPE_JOYSTICK         0x14
#define DI8DEVTYPE_GAMEPAD          0x15
#define DI8DEVTYPE_DRIVING          0x16
#define DI8DEVTYPE_FLIGHT           0x17
#define DI8DEVTYPE_1STPERSON        0x18
#define DI8DEVTYPE_DEVICECTRL       0x19
#define DI8DEVTYPE_SCREENPOINTER    0x1A
#define DI8DEVTYPE_REMOTE           0x1B
#define DI8DEVTYPE_SUPPLEMENTAL     0x1C
#endif /* DIRECTINPUT_VERSION <= 0x700 */

#define DIDEVTYPE_HID           0x00010000

#if DIRECTINPUT_VERSION <= 0x700
#define DIDEVTYPEMOUSE_UNKNOWN          1
#define DIDEVTYPEMOUSE_TRADITIONAL      2
#define DIDEVTYPEMOUSE_FINGERSTICK      3
#define DIDEVTYPEMOUSE_TOUCHPAD         4
#define DIDEVTYPEMOUSE_TRACKBALL        5

#define DIDEVTYPEKEYBOARD_UNKNOWN       0
#define DIDEVTYPEKEYBOARD_PCXT          1
#define DIDEVTYPEKEYBOARD_OLIVETTI      2
#define DIDEVTYPEKEYBOARD_PCAT          3
#define DIDEVTYPEKEYBOARD_PCENH         4
#define DIDEVTYPEKEYBOARD_NOKIA1050     5
#define DIDEVTYPEKEYBOARD_NOKIA9140     6
#define DIDEVTYPEKEYBOARD_NEC98         7
#define DIDEVTYPEKEYBOARD_NEC98LAPTOP   8
#define DIDEVTYPEKEYBOARD_NEC98106      9
#define DIDEVTYPEKEYBOARD_JAPAN106     10
#define DIDEVTYPEKEYBOARD_JAPANAX      11
#define DIDEVTYPEKEYBOARD_J3100        12

#define DIDEVTYPEJOYSTICK_UNKNOWN       1
#define DIDEVTYPEJOYSTICK_TRADITIONAL   2
#define DIDEVTYPEJOYSTICK_FLIGHTSTICK   3
#define DIDEVTYPEJOYSTICK_GAMEPAD       4
#define DIDEVTYPEJOYSTICK_RUDDER        5
#define DIDEVTYPEJOYSTICK_WHEEL         6
#define DIDEVTYPEJOYSTICK_HEADTRACKER   7

#else
#define DI8DEVTYPEMOUSE_UNKNOWN                     1
#define DI8DEVTYPEMOUSE_TRADITIONAL                 2
#define DI8DEVTYPEMOUSE_FINGERSTICK                 3
#define DI8DEVTYPEMOUSE_TOUCHPAD                    4
#define DI8DEVTYPEMOUSE_TRACKBALL                   5
#define DI8DEVTYPEMOUSE_ABSOLUTE                    6

#define DI8DEVTYPEKEYBOARD_UNKNOWN                  0
#define DI8DEVTYPEKEYBOARD_PCXT                     1
#define DI8DEVTYPEKEYBOARD_OLIVETTI                 2
#define DI8DEVTYPEKEYBOARD_PCAT                     3
#define DI8DEVTYPEKEYBOARD_PCENH                    4
#define DI8DEVTYPEKEYBOARD_NOKIA1050                5
#define DI8DEVTYPEKEYBOARD_NOKIA9140                6
#define DI8DEVTYPEKEYBOARD_NEC98                    7
#define DI8DEVTYPEKEYBOARD_NEC98LAPTOP              8
#define DI8DEVTYPEKEYBOARD_NEC98106                 9
#define DI8DEVTYPEKEYBOARD_JAPAN106                10
#define DI8DEVTYPEKEYBOARD_JAPANAX                 11
#define DI8DEVTYPEKEYBOARD_J3100                   12

#define DI8DEVTYPE_LIMITEDGAMESUBTYPE               1

#define DI8DEVTYPEJOYSTICK_LIMITED                  DI8DEVTYPE_LIMITEDGAMESUBTYPE
#define DI8DEVTYPEJOYSTICK_STANDARD                 2

#define DI8DEVTYPEGAMEPAD_LIMITED                   DI8DEVTYPE_LIMITEDGAMESUBTYPE
#define DI8DEVTYPEGAMEPAD_STANDARD                  2
#define DI8DEVTYPEGAMEPAD_TILT                      3

#define DI8DEVTYPEDRIVING_LIMITED                   DI8DEVTYPE_LIMITEDGAMESUBTYPE
#define DI8DEVTYPEDRIVING_COMBINEDPEDALS            2
#define DI8DEVTYPEDRIVING_DUALPEDALS                3
#define DI8DEVTYPEDRIVING_THREEPEDALS               4
#define DI8DEVTYPEDRIVING_HANDHELD                  5

#define DI8DEVTYPEFLIGHT_LIMITED                    DI8DEVTYPE_LIMITEDGAMESUBTYPE
#define DI8DEVTYPEFLIGHT_STICK                      2
#define DI8DEVTYPEFLIGHT_YOKE                       3
#define DI8DEVTYPEFLIGHT_RC                         4

#define DI8DEVTYPE1STPERSON_LIMITED                 DI8DEVTYPE_LIMITEDGAMESUBTYPE
#define DI8DEVTYPE1STPERSON_UNKNOWN                 2
#define DI8DEVTYPE1STPERSON_SIXDOF                  3
#define DI8DEVTYPE1STPERSON_SHOOTER                 4

#define DI8DEVTYPESCREENPTR_UNKNOWN                 2
#define DI8DEVTYPESCREENPTR_LIGHTGUN                3
#define DI8DEVTYPESCREENPTR_LIGHTPEN                4
#define DI8DEVTYPESCREENPTR_TOUCH                   5

#define DI8DEVTYPEREMOTE_UNKNOWN                    2

#define DI8DEVTYPEDEVICECTRL_UNKNOWN                2
#define DI8DEVTYPEDEVICECTRL_COMMSSELECTION         3
#define DI8DEVTYPEDEVICECTRL_COMMSSELECTION_HARDWIRED 4

#define DI8DEVTYPESUPPLEMENTAL_UNKNOWN              2
#define DI8DEVTYPESUPPLEMENTAL_2NDHANDCONTROLLER    3
#define DI8DEVTYPESUPPLEMENTAL_HEADTRACKER          4
#define DI8DEVTYPESUPPLEMENTAL_HANDTRACKER          5
#define DI8DEVTYPESUPPLEMENTAL_SHIFTSTICKGATE       6
#define DI8DEVTYPESUPPLEMENTAL_SHIFTER              7
#define DI8DEVTYPESUPPLEMENTAL_THROTTLE             8
#define DI8DEVTYPESUPPLEMENTAL_SPLITTHROTTLE        9
#define DI8DEVTYPESUPPLEMENTAL_COMBINEDPEDALS      10
#define DI8DEVTYPESUPPLEMENTAL_DUALPEDALS          11
#define DI8DEVTYPESUPPLEMENTAL_THREEPEDALS         12
#define DI8DEVTYPESUPPLEMENTAL_RUDDERPEDALS        13
#endif /* DIRECTINPUT_VERSION <= 0x700 */

#define GET_DIDEVICE_TYPE(dwDevType)    LOBYTE(dwDevType)
#define GET_DIDEVICE_SUBTYPE(dwDevType) HIBYTE(dwDevType)

#if(DIRECTINPUT_VERSION >= 0x0500)
/* This structure is defined for DirectX 3.0 compatibility */
typedef struct DIDEVCAPS_DX3 {
    DWORD   dwSize;
    DWORD   dwFlags;
    DWORD   dwDevType;
    DWORD   dwAxes;
    DWORD   dwButtons;
    DWORD   dwPOVs;
} DIDEVCAPS_DX3, *LPDIDEVCAPS_DX3;
#endif /* DIRECTINPUT_VERSION >= 0x0500 */

typedef struct DIDEVCAPS {
    DWORD   dwSize;
    DWORD   dwFlags;
    DWORD   dwDevType;
    DWORD   dwAxes;
    DWORD   dwButtons;
    DWORD   dwPOVs;
#if(DIRECTINPUT_VERSION >= 0x0500)
    DWORD   dwFFSamplePeriod;
    DWORD   dwFFMinTimeResolution;
    DWORD   dwFirmwareRevision;
    DWORD   dwHardwareRevision;
    DWORD   dwFFDriverVersion;
#endif /* DIRECTINPUT_VERSION >= 0x0500 */
} DIDEVCAPS, *LPDIDEVCAPS;

#define DIDC_ATTACHED           0x00000001
#define DIDC_POLLEDDEVICE       0x00000002
#define DIDC_EMULATED           0x00000004
#define DIDC_POLLEDDATAFORMAT   0x00000008
#if(DIRECTINPUT_VERSION >= 0x0500)
#define DIDC_FORCEFEEDBACK      0x00000100
#define DIDC_FFATTACK           0x00000200
#define DIDC_FFFADE             0x00000400
#define DIDC_SATURATION         0x00000800
#define DIDC_POSNEGCOEFFICIENTS 0x00001000
#define DIDC_POSNEGSATURATION   0x00002000
#define DIDC_DEADBAND           0x00004000
#endif /* DIRECTINPUT_VERSION >= 0x0500 */
#define DIDC_STARTDELAY         0x00008000
#if(DIRECTINPUT_VERSION >= 0x050a)
#define DIDC_ALIAS              0x00010000
#define DIDC_PHANTOM            0x00020000
#endif /* DIRECTINPUT_VERSION >= 0x050a */
#if(DIRECTINPUT_VERSION >= 0x0800)
#define DIDC_HIDDEN             0x00040000
#endif /* DIRECTINPUT_VERSION >= 0x0800 */

#define DIDFT_ALL           0x00000000

#define DIDFT_RELAXIS       0x00000001
#define DIDFT_ABSAXIS       0x00000002
#define DIDFT_AXIS          0x00000003

#define DIDFT_PSHBUTTON     0x00000004
#define DIDFT_TGLBUTTON     0x00000008
#define DIDFT_BUTTON        0x0000000C

#define DIDFT_POV           0x00000010
#define DIDFT_COLLECTION    0x00000040
#define DIDFT_NODATA        0x00000080

#define DIDFT_ANYINSTANCE   0x00FFFF00
#define DIDFT_INSTANCEMASK  DIDFT_ANYINSTANCE
#define DIDFT_MAKEINSTANCE(n) ((WORD)(n) << 8)
#define DIDFT_GETTYPE(n)     LOBYTE(n)
#define DIDFT_GETINSTANCE(n) LOWORD((n) >> 8)
#define DIDFT_FFACTUATOR        0x01000000
#define DIDFT_FFEFFECTTRIGGER   0x02000000
#if(DIRECTINPUT_VERSION >= 0x050a)
#define DIDFT_OUTPUT            0x10000000
#define DIDFT_VENDORDEFINED     0x04000000
#define DIDFT_ALIAS             0x08000000
#endif /* DIRECTINPUT_VERSION >= 0x050a */

#define DIDFT_ENUMCOLLECTION(n) ((WORD)(n) << 8)
#define DIDFT_NOCOLLECTION      0x00FFFF00

#ifndef DIJ_RINGZERO

typedef struct _DIOBJECTDATAFORMAT {
    const GUID *pguid;
    DWORD   dwOfs;
    DWORD   dwType;
    DWORD   dwFlags;
} DIOBJECTDATAFORMAT, *LPDIOBJECTDATAFORMAT;
typedef const DIOBJECTDATAFORMAT *LPCDIOBJECTDATAFORMAT;

typedef struct _DIDATAFORMAT {
    DWORD   dwSize;
    DWORD   dwObjSize;
    DWORD   dwFlags;
    DWORD   dwDataSize;
    DWORD   dwNumObjs;
    LPDIOBJECTDATAFORMAT rgodf;
} DIDATAFORMAT, *LPDIDATAFORMAT;
typedef const DIDATAFORMAT *LPCDIDATAFORMAT;

#define DIDF_ABSAXIS            0x00000001
#define DIDF_RELAXIS            0x00000002

#ifdef __cplusplus
extern "C" {
#endif
extern const DIDATAFORMAT c_dfDIMouse;

#if(DIRECTINPUT_VERSION >= 0x0700)
extern const DIDATAFORMAT c_dfDIMouse2;
#endif /* DIRECTINPUT_VERSION >= 0x0700 */

extern const DIDATAFORMAT c_dfDIKeyboard;

#if(DIRECTINPUT_VERSION >= 0x0500)
extern const DIDATAFORMAT c_dfDIJoystick;
extern const DIDATAFORMAT c_dfDIJoystick2;
#endif /* DIRECTINPUT_VERSION >= 0x0500 */

#ifdef __cplusplus
};
#endif


#if DIRECTINPUT_VERSION > 0x0700

typedef struct _DIACTIONA {
                UINT_PTR    uAppData;
                DWORD       dwSemantic;
    OPTIONAL    DWORD       dwFlags;
    OPTIONAL    union {
                    LPCSTR      lptszActionName;
                    UINT        uResIdString;
                };
    OPTIONAL    GUID        guidInstance;
    OPTIONAL    DWORD       dwObjID;
    OPTIONAL    DWORD       dwHow;
} DIACTIONA, *LPDIACTIONA ;
typedef struct _DIACTIONW {
                UINT_PTR    uAppData;
                DWORD       dwSemantic;
    OPTIONAL    DWORD       dwFlags;
    OPTIONAL    union {
                    LPCWSTR     lptszActionName;
                    UINT        uResIdString;
                };
    OPTIONAL    GUID        guidInstance;
    OPTIONAL    DWORD       dwObjID;
    OPTIONAL    DWORD       dwHow;
} DIACTIONW, *LPDIACTIONW ;
#ifdef UNICODE
typedef DIACTIONW DIACTION;
typedef LPDIACTIONW LPDIACTION;
#else
typedef DIACTIONA DIACTION;
typedef LPDIACTIONA LPDIACTION;
#endif // UNICODE

typedef const DIACTIONA *LPCDIACTIONA;
typedef const DIACTIONW *LPCDIACTIONW;
#ifdef UNICODE
typedef DIACTIONW DIACTION;
typedef LPCDIACTIONW LPCDIACTION;
#else
typedef DIACTIONA DIACTION;
typedef LPCDIACTIONA LPCDIACTION;
#endif // UNICODE
typedef const DIACTION *LPCDIACTION;


#define DIA_FORCEFEEDBACK       0x00000001
#define DIA_APPMAPPED           0x00000002
#define DIA_APPNOMAP            0x00000004
#define DIA_NORANGE             0x00000008
#define DIA_APPFIXED            0x00000010

#define DIAH_UNMAPPED           0x00000000
#define DIAH_USERCONFIG         0x00000001
#define DIAH_APPREQUESTED       0x00000002
#define DIAH_HWAPP              0x00000004
#define DIAH_HWDEFAULT          0x00000008
#define DIAH_DEFAULT            0x00000020
#define DIAH_ERROR              0x80000000

typedef struct _DIACTIONFORMATA {
                DWORD       dwSize;
                DWORD       dwActionSize;
                DWORD       dwDataSize;
                DWORD       dwNumActions;
                LPDIACTIONA rgoAction;
                GUID        guidActionMap;
                DWORD       dwGenre;
                DWORD       dwBufferSize;
    OPTIONAL    LONG        lAxisMin;
    OPTIONAL    LONG        lAxisMax;
    OPTIONAL    HINSTANCE   hInstString;
                FILETIME    ftTimeStamp;
                DWORD       dwCRC;
                CHAR        tszActionMap[MAX_PATH];
} DIACTIONFORMATA, *LPDIACTIONFORMATA;
typedef struct _DIACTIONFORMATW {
                DWORD       dwSize;
                DWORD       dwActionSize;
                DWORD       dwDataSize;
                DWORD       dwNumActions;
                LPDIACTIONW rgoAction;
                GUID        guidActionMap;
                DWORD       dwGenre;
                DWORD       dwBufferSize;
    OPTIONAL    LONG        lAxisMin;
    OPTIONAL    LONG        lAxisMax;
    OPTIONAL    HINSTANCE   hInstString;
                FILETIME    ftTimeStamp;
                DWORD       dwCRC;
                WCHAR       tszActionMap[MAX_PATH];
} DIACTIONFORMATW, *LPDIACTIONFORMATW;
#ifdef UNICODE
typedef DIACTIONFORMATW DIACTIONFORMAT;
typedef LPDIACTIONFORMATW LPDIACTIONFORMAT;
#else
typedef DIACTIONFORMATA DIACTIONFORMAT;
typedef LPDIACTIONFORMATA LPDIACTIONFORMAT;
#endif // UNICODE
typedef const DIACTIONFORMATA *LPCDIACTIONFORMATA;
typedef const DIACTIONFORMATW *LPCDIACTIONFORMATW;
#ifdef UNICODE
typedef DIACTIONFORMATW DIACTIONFORMAT;
typedef LPCDIACTIONFORMATW LPCDIACTIONFORMAT;
#else
typedef DIACTIONFORMATA DIACTIONFORMAT;
typedef LPCDIACTIONFORMATA LPCDIACTIONFORMAT;
#endif // UNICODE
typedef const DIACTIONFORMAT *LPCDIACTIONFORMAT;

#define DIAFTS_NEWDEVICELOW     0xFFFFFFFF
#define DIAFTS_NEWDEVICEHIGH    0xFFFFFFFF
#define DIAFTS_UNUSEDDEVICELOW  0x00000000
#define DIAFTS_UNUSEDDEVICEHIGH 0x00000000

#define DIDBAM_DEFAULT          0x00000000
#define DIDBAM_PRESERVE         0x00000001
#define DIDBAM_INITIALIZE       0x00000002
#define DIDBAM_HWDEFAULTS       0x00000004

#define DIDSAM_DEFAULT          0x00000000
#define DIDSAM_NOUSER           0x00000001
#define DIDSAM_FORCESAVE        0x00000002

#define DICD_DEFAULT            0x00000000
#define DICD_EDIT               0x00000001

/*
 * The following definition is normally defined in d3dtypes.h
 */
#ifndef D3DCOLOR_DEFINED
typedef DWORD D3DCOLOR;
#define D3DCOLOR_DEFINED
#endif

typedef struct _DICOLORSET{
    DWORD dwSize;
    D3DCOLOR cTextFore;
    D3DCOLOR cTextHighlight;
    D3DCOLOR cCalloutLine;
    D3DCOLOR cCalloutHighlight;
    D3DCOLOR cBorder;
    D3DCOLOR cControlFill;
    D3DCOLOR cHighlightFill;
    D3DCOLOR cAreaFill;
} DICOLORSET, *LPDICOLORSET;
typedef const DICOLORSET *LPCDICOLORSET;


typedef struct _DICONFIGUREDEVICESPARAMSA{
     DWORD             dwSize;
     DWORD             dwcUsers;
     LPSTR             lptszUserNames;
     DWORD             dwcFormats;
     LPDIACTIONFORMATA lprgFormats;
     HWND              hwnd;
     DICOLORSET        dics;
     IUnknown FAR *    lpUnkDDSTarget;
} DICONFIGUREDEVICESPARAMSA, *LPDICONFIGUREDEVICESPARAMSA;
typedef struct _DICONFIGUREDEVICESPARAMSW{
     DWORD             dwSize;
     DWORD             dwcUsers;
     LPWSTR            lptszUserNames;
     DWORD             dwcFormats;
     LPDIACTIONFORMATW lprgFormats;
     HWND              hwnd;
     DICOLORSET        dics;
     IUnknown FAR *    lpUnkDDSTarget;
} DICONFIGUREDEVICESPARAMSW, *LPDICONFIGUREDEVICESPARAMSW;
#ifdef UNICODE
typedef DICONFIGUREDEVICESPARAMSW DICONFIGUREDEVICESPARAMS;
typedef LPDICONFIGUREDEVICESPARAMSW LPDICONFIGUREDEVICESPARAMS;
#else
typedef DICONFIGUREDEVICESPARAMSA DICONFIGUREDEVICESPARAMS;
typedef LPDICONFIGUREDEVICESPARAMSA LPDICONFIGUREDEVICESPARAMS;
#endif // UNICODE
typedef const DICONFIGUREDEVICESPARAMSA *LPCDICONFIGUREDEVICESPARAMSA;
typedef const DICONFIGUREDEVICESPARAMSW *LPCDICONFIGUREDEVICESPARAMSW;
#ifdef UNICODE
typedef DICONFIGUREDEVICESPARAMSW DICONFIGUREDEVICESPARAMS;
typedef LPCDICONFIGUREDEVICESPARAMSW LPCDICONFIGUREDEVICESPARAMS;
#else
typedef DICONFIGUREDEVICESPARAMSA DICONFIGUREDEVICESPARAMS;
typedef LPCDICONFIGUREDEVICESPARAMSA LPCDICONFIGUREDEVICESPARAMS;
#endif // UNICODE
typedef const DICONFIGUREDEVICESPARAMS *LPCDICONFIGUREDEVICESPARAMS;


#define DIDIFT_CONFIGURATION    0x00000001
#define DIDIFT_OVERLAY          0x00000002

#define DIDAL_CENTERED      0x00000000
#define DIDAL_LEFTALIGNED   0x00000001
#define DIDAL_RIGHTALIGNED  0x00000002
#define DIDAL_MIDDLE        0x00000000
#define DIDAL_TOPALIGNED    0x00000004
#define DIDAL_BOTTOMALIGNED 0x00000008

typedef struct _DIDEVICEIMAGEINFOA {
    CHAR        tszImagePath[MAX_PATH];
    DWORD       dwFlags; 
    // These are valid if DIDIFT_OVERLAY is present in dwFlags.
    DWORD       dwViewID;      
    RECT        rcOverlay;             
    DWORD       dwObjID;
    DWORD       dwcValidPts;
    POINT       rgptCalloutLine[5];  
    RECT        rcCalloutRect;  
    DWORD       dwTextAlign;     
} DIDEVICEIMAGEINFOA, *LPDIDEVICEIMAGEINFOA;
typedef struct _DIDEVICEIMAGEINFOW {
    WCHAR       tszImagePath[MAX_PATH];
    DWORD       dwFlags; 
    // These are valid if DIDIFT_OVERLAY is present in dwFlags.
    DWORD       dwViewID;      
    RECT        rcOverlay;             
    DWORD       dwObjID;
    DWORD       dwcValidPts;
    POINT       rgptCalloutLine[5];  
    RECT        rcCalloutRect;  
    DWORD       dwTextAlign;     
} DIDEVICEIMAGEINFOW, *LPDIDEVICEIMAGEINFOW;
#ifdef UNICODE
typedef DIDEVICEIMAGEINFOW DIDEVICEIMAGEINFO;
typedef LPDIDEVICEIMAGEINFOW LPDIDEVICEIMAGEINFO;
#else
typedef DIDEVICEIMAGEINFOA DIDEVICEIMAGEINFO;
typedef LPDIDEVICEIMAGEINFOA LPDIDEVICEIMAGEINFO;
#endif // UNICODE
typedef const DIDEVICEIMAGEINFOA *LPCDIDEVICEIMAGEINFOA;
typedef const DIDEVICEIMAGEINFOW *LPCDIDEVICEIMAGEINFOW;
#ifdef UNICODE
typedef DIDEVICEIMAGEINFOW DIDEVICEIMAGEINFO;
typedef LPCDIDEVICEIMAGEINFOW LPCDIDEVICEIMAGEINFO;
#else
typedef DIDEVICEIMAGEINFOA DIDEVICEIMAGEINFO;
typedef LPCDIDEVICEIMAGEINFOA LPCDIDEVICEIMAGEINFO;
#endif // UNICODE
typedef const DIDEVICEIMAGEINFO *LPCDIDEVICEIMAGEINFO;

typedef struct _DIDEVICEIMAGEINFOHEADERA {
    DWORD       dwSize;
    DWORD       dwSizeImageInfo;
    DWORD       dwcViews;
    DWORD       dwcButtons;
    DWORD       dwcAxes;
    DWORD       dwcPOVs;
    DWORD       dwBufferSize;
    DWORD       dwBufferUsed;
    LPDIDEVICEIMAGEINFOA lprgImageInfoArray;
} DIDEVICEIMAGEINFOHEADERA, *LPDIDEVICEIMAGEINFOHEADERA;
typedef struct _DIDEVICEIMAGEINFOHEADERW {
    DWORD       dwSize;
    DWORD       dwSizeImageInfo;
    DWORD       dwcViews;
    DWORD       dwcButtons;
    DWORD       dwcAxes;
    DWORD       dwcPOVs;
    DWORD       dwBufferSize;
    DWORD       dwBufferUsed;
    LPDIDEVICEIMAGEINFOW lprgImageInfoArray;
} DIDEVICEIMAGEINFOHEADERW, *LPDIDEVICEIMAGEINFOHEADERW;
#ifdef UNICODE
typedef DIDEVICEIMAGEINFOHEADERW DIDEVICEIMAGEINFOHEADER;
typedef LPDIDEVICEIMAGEINFOHEADERW LPDIDEVICEIMAGEINFOHEADER;
#else
typedef DIDEVICEIMAGEINFOHEADERA DIDEVICEIMAGEINFOHEADER;
typedef LPDIDEVICEIMAGEINFOHEADERA LPDIDEVICEIMAGEINFOHEADER;
#endif // UNICODE
typedef const DIDEVICEIMAGEINFOHEADERA *LPCDIDEVICEIMAGEINFOHEADERA;
typedef const DIDEVICEIMAGEINFOHEADERW *LPCDIDEVICEIMAGEINFOHEADERW;
#ifdef UNICODE
typedef DIDEVICEIMAGEINFOHEADERW DIDEVICEIMAGEINFOHEADER;
typedef LPCDIDEVICEIMAGEINFOHEADERW LPCDIDEVICEIMAGEINFOHEADER;
#else
typedef DIDEVICEIMAGEINFOHEADERA DIDEVICEIMAGEINFOHEADER;
typedef LPCDIDEVICEIMAGEINFOHEADERA LPCDIDEVICEIMAGEINFOHEADER;
#endif // UNICODE
typedef const DIDEVICEIMAGEINFOHEADER *LPCDIDEVICEIMAGEINFOHEADER;

#endif /* DIRECTINPUT_VERSION > 0x0700 */

#if(DIRECTINPUT_VERSION >= 0x0500)
/* These structures are defined for DirectX 3.0 compatibility */

typedef struct DIDEVICEOBJECTINSTANCE_DX3A {
    DWORD   dwSize;
    GUID    guidType;
    DWORD   dwOfs;
    DWORD   dwType;
    DWORD   dwFlags;
    CHAR    tszName[MAX_PATH];
} DIDEVICEOBJECTINSTANCE_DX3A, *LPDIDEVICEOBJECTINSTANCE_DX3A;
typedef struct DIDEVICEOBJECTINSTANCE_DX3W {
    DWORD   dwSize;
    GUID    guidType;
    DWORD   dwOfs;
    DWORD   dwType;
    DWORD   dwFlags;
    WCHAR   tszName[MAX_PATH];
} DIDEVICEOBJECTINSTANCE_DX3W, *LPDIDEVICEOBJECTINSTANCE_DX3W;
#ifdef UNICODE
typedef DIDEVICEOBJECTINSTANCE_DX3W DIDEVICEOBJECTINSTANCE_DX3;
typedef LPDIDEVICEOBJECTINSTANCE_DX3W LPDIDEVICEOBJECTINSTANCE_DX3;
#else
typedef DIDEVICEOBJECTINSTANCE_DX3A DIDEVICEOBJECTINSTANCE_DX3;
typedef LPDIDEVICEOBJECTINSTANCE_DX3A LPDIDEVICEOBJECTINSTANCE_DX3;
#endif // UNICODE
typedef const DIDEVICEOBJECTINSTANCE_DX3A *LPCDIDEVICEOBJECTINSTANCE_DX3A;
typedef const DIDEVICEOBJECTINSTANCE_DX3W *LPCDIDEVICEOBJECTINSTANCE_DX3W;
typedef const DIDEVICEOBJECTINSTANCE_DX3  *LPCDIDEVICEOBJECTINSTANCE_DX3;
#endif /* DIRECTINPUT_VERSION >= 0x0500 */

typedef struct DIDEVICEOBJECTINSTANCEA {
    DWORD   dwSize;
    GUID    guidType;
    DWORD   dwOfs;
    DWORD   dwType;
    DWORD   dwFlags;
    CHAR    tszName[MAX_PATH];
#if(DIRECTINPUT_VERSION >= 0x0500)
    DWORD   dwFFMaxForce;
    DWORD   dwFFForceResolution;
    WORD    wCollectionNumber;
    WORD    wDesignatorIndex;
    WORD    wUsagePage;
    WORD    wUsage;
    DWORD   dwDimension;
    WORD    wExponent;
    WORD    wReportId;
#endif /* DIRECTINPUT_VERSION >= 0x0500 */
} DIDEVICEOBJECTINSTANCEA, *LPDIDEVICEOBJECTINSTANCEA;
typedef struct DIDEVICEOBJECTINSTANCEW {
    DWORD   dwSize;
    GUID    guidType;
    DWORD   dwOfs;
    DWORD   dwType;
    DWORD   dwFlags;
    WCHAR   tszName[MAX_PATH];
#if(DIRECTINPUT_VERSION >= 0x0500)
    DWORD   dwFFMaxForce;
    DWORD   dwFFForceResolution;
    WORD    wCollectionNumber;
    WORD    wDesignatorIndex;
    WORD    wUsagePage;
    WORD    wUsage;
    DWORD   dwDimension;
    WORD    wExponent;
    WORD    wReportId;
#endif /* DIRECTINPUT_VERSION >= 0x0500 */
} DIDEVICEOBJECTINSTANCEW, *LPDIDEVICEOBJECTINSTANCEW;
#ifdef UNICODE
typedef DIDEVICEOBJECTINSTANCEW DIDEVICEOBJECTINSTANCE;
typedef LPDIDEVICEOBJECTINSTANCEW LPDIDEVICEOBJECTINSTANCE;
#else
typedef DIDEVICEOBJECTINSTANCEA DIDEVICEOBJECTINSTANCE;
typedef LPDIDEVICEOBJECTINSTANCEA LPDIDEVICEOBJECTINSTANCE;
#endif // UNICODE
typedef const DIDEVICEOBJECTINSTANCEA *LPCDIDEVICEOBJECTINSTANCEA;
typedef const DIDEVICEOBJECTINSTANCEW *LPCDIDEVICEOBJECTINSTANCEW;
typedef const DIDEVICEOBJECTINSTANCE  *LPCDIDEVICEOBJECTINSTANCE;

typedef BOOL (FAR PASCAL * LPDIENUMDEVICEOBJECTSCALLBACKA)(LPCDIDEVICEOBJECTINSTANCEA, LPVOID);
typedef BOOL (FAR PASCAL * LPDIENUMDEVICEOBJECTSCALLBACKW)(LPCDIDEVICEOBJECTINSTANCEW, LPVOID);
#ifdef UNICODE
#define LPDIENUMDEVICEOBJECTSCALLBACK  LPDIENUMDEVICEOBJECTSCALLBACKW
#else
#define LPDIENUMDEVICEOBJECTSCALLBACK  LPDIENUMDEVICEOBJECTSCALLBACKA
#endif // !UNICODE

#if(DIRECTINPUT_VERSION >= 0x0500)
#define DIDOI_FFACTUATOR        0x00000001
#define DIDOI_FFEFFECTTRIGGER   0x00000002
#define DIDOI_POLLED            0x00008000
#define DIDOI_ASPECTPOSITION    0x00000100
#define DIDOI_ASPECTVELOCITY    0x00000200
#define DIDOI_ASPECTACCEL       0x00000300
#define DIDOI_ASPECTFORCE       0x00000400
#define DIDOI_ASPECTMASK        0x00000F00
#endif /* DIRECTINPUT_VERSION >= 0x0500 */
#if(DIRECTINPUT_VERSION >= 0x050a)
#define DIDOI_GUIDISUSAGE       0x00010000
#endif /* DIRECTINPUT_VERSION >= 0x050a */

typedef struct DIPROPHEADER {
    DWORD   dwSize;
    DWORD   dwHeaderSize;
    DWORD   dwObj;
    DWORD   dwHow;
} DIPROPHEADER, *LPDIPROPHEADER;
typedef const DIPROPHEADER *LPCDIPROPHEADER;

#define DIPH_DEVICE             0
#define DIPH_BYOFFSET           1
#define DIPH_BYID               2
#if(DIRECTINPUT_VERSION >= 0x050a)
#define DIPH_BYUSAGE            3

#define DIMAKEUSAGEDWORD(UsagePage, Usage) \
                                (DWORD)MAKELONG(Usage, UsagePage)
#endif /* DIRECTINPUT_VERSION >= 0x050a */

typedef struct DIPROPDWORD {
    DIPROPHEADER diph;
    DWORD   dwData;
} DIPROPDWORD, *LPDIPROPDWORD;
typedef const DIPROPDWORD *LPCDIPROPDWORD;

#if(DIRECTINPUT_VERSION >= 0x0800)
typedef struct DIPROPPOINTER {
    DIPROPHEADER diph;
    UINT_PTR uData;
} DIPROPPOINTER, *LPDIPROPPOINTER;
typedef const DIPROPPOINTER *LPCDIPROPPOINTER;
#endif /* DIRECTINPUT_VERSION >= 0x0800 */

typedef struct DIPROPRANGE {
    DIPROPHEADER diph;
    LONG    lMin;
    LONG    lMax;
} DIPROPRANGE, *LPDIPROPRANGE;
typedef const DIPROPRANGE *LPCDIPROPRANGE;

#define DIPROPRANGE_NOMIN       ((LONG)0x80000000)
#define DIPROPRANGE_NOMAX       ((LONG)0x7FFFFFFF)

#if(DIRECTINPUT_VERSION >= 0x050a)
typedef struct DIPROPCAL {
    DIPROPHEADER diph;
    LONG    lMin;
    LONG    lCenter;
    LONG    lMax;
} DIPROPCAL, *LPDIPROPCAL;
typedef const DIPROPCAL *LPCDIPROPCAL;

typedef struct DIPROPGUIDANDPATH {
    DIPROPHEADER diph;
    GUID    guidClass;
    WCHAR   wszPath[MAX_PATH];
} DIPROPGUIDANDPATH, *LPDIPROPGUIDANDPATH;
typedef const DIPROPGUIDANDPATH *LPCDIPROPGUIDANDPATH;

typedef struct DIPROPSTRING {
    DIPROPHEADER diph;
    WCHAR   wsz[MAX_PATH];
} DIPROPSTRING, *LPDIPROPSTRING;
typedef const DIPROPSTRING *LPCDIPROPSTRING;

#endif /* DIRECTINPUT_VERSION >= 0x050a */

#if(DIRECTINPUT_VERSION >= 0x0800)
#define MAXCPOINTSNUM          8

typedef struct _CPOINT
{
    LONG  lP;     // raw value
    DWORD dwLog;  // logical_value / max_logical_value * 10000
} CPOINT, *PCPOINT;

typedef struct DIPROPCPOINTS {
    DIPROPHEADER diph;
    DWORD  dwCPointsNum;
    CPOINT cp[MAXCPOINTSNUM];
} DIPROPCPOINTS, *LPDIPROPCPOINTS;
typedef const DIPROPCPOINTS *LPCDIPROPCPOINTS;
#endif /* DIRECTINPUT_VERSION >= 0x0800 */


#ifdef __cplusplus
#define MAKEDIPROP(prop)    (*(const GUID *)(prop))
#else
#define MAKEDIPROP(prop)    ((REFGUID)(prop))
#endif

#define DIPROP_BUFFERSIZE       MAKEDIPROP(1)

#define DIPROP_AXISMODE         MAKEDIPROP(2)

#define DIPROPAXISMODE_ABS      0
#define DIPROPAXISMODE_REL      1

#define DIPROP_GRANULARITY      MAKEDIPROP(3)

#define DIPROP_RANGE            MAKEDIPROP(4)

#define DIPROP_DEADZONE         MAKEDIPROP(5)

#define DIPROP_SATURATION       MAKEDIPROP(6)

#define DIPROP_FFGAIN           MAKEDIPROP(7)

#define DIPROP_FFLOAD           MAKEDIPROP(8)

#define DIPROP_AUTOCENTER       MAKEDIPROP(9)

#define DIPROPAUTOCENTER_OFF    0
#define DIPROPAUTOCENTER_ON     1

#define DIPROP_CALIBRATIONMODE  MAKEDIPROP(10)

#define DIPROPCALIBRATIONMODE_COOKED    0
#define DIPROPCALIBRATIONMODE_RAW       1

#if(DIRECTINPUT_VERSION >= 0x050a)
#define DIPROP_CALIBRATION      MAKEDIPROP(11)

#define DIPROP_GUIDANDPATH      MAKEDIPROP(12)

#define DIPROP_INSTANCENAME     MAKEDIPROP(13)

#define DIPROP_PRODUCTNAME      MAKEDIPROP(14)
#endif /* DIRECTINPUT_VERSION >= 0x050a */

#if(DIRECTINPUT_VERSION >= 0x05b2)
#define DIPROP_JOYSTICKID       MAKEDIPROP(15)

#define DIPROP_GETPORTDISPLAYNAME       MAKEDIPROP(16)

#endif /* DIRECTINPUT_VERSION >= 0x05b2 */

#if(DIRECTINPUT_VERSION >= 0x0700)
#define DIPROP_PHYSICALRANGE            MAKEDIPROP(18)

#define DIPROP_LOGICALRANGE             MAKEDIPROP(19)
#endif /* DIRECTINPUT_VERSION >= 0x0700 */

#if(DIRECTINPUT_VERSION >= 0x0800)
#define DIPROP_KEYNAME                     MAKEDIPROP(20)

#define DIPROP_CPOINTS                 MAKEDIPROP(21)

#define DIPROP_APPDATA       MAKEDIPROP(22)

#define DIPROP_SCANCODE      MAKEDIPROP(23)

#define DIPROP_VIDPID           MAKEDIPROP(24)

#define DIPROP_USERNAME         MAKEDIPROP(25)

#define DIPROP_TYPENAME         MAKEDIPROP(26)
#endif /* DIRECTINPUT_VERSION >= 0x0800 */


typedef struct DIDEVICEOBJECTDATA_DX3 {
    DWORD       dwOfs;
    DWORD       dwData;
    DWORD       dwTimeStamp;
    DWORD       dwSequence;
} DIDEVICEOBJECTDATA_DX3, *LPDIDEVICEOBJECTDATA_DX3;
typedef const DIDEVICEOBJECTDATA_DX3 *LPCDIDEVICEOBJECTDATA_DX;

typedef struct DIDEVICEOBJECTDATA {
    DWORD       dwOfs;
    DWORD       dwData;
    DWORD       dwTimeStamp;
    DWORD       dwSequence;
#if(DIRECTINPUT_VERSION >= 0x0800)
    UINT_PTR    uAppData;
#endif /* DIRECTINPUT_VERSION >= 0x0800 */
} DIDEVICEOBJECTDATA, *LPDIDEVICEOBJECTDATA;
typedef const DIDEVICEOBJECTDATA *LPCDIDEVICEOBJECTDATA;

#define DIGDD_PEEK          0x00000001

#define DISEQUENCE_COMPARE(dwSequence1, cmp, dwSequence2) \
                        ((int)((dwSequence1) - (dwSequence2)) cmp 0)
#define DISCL_EXCLUSIVE     0x00000001
#define DISCL_NONEXCLUSIVE  0x00000002
#define DISCL_FOREGROUND    0x00000004
#define DISCL_BACKGROUND    0x00000008
#define DISCL_NOWINKEY      0x00000010

#if(DIRECTINPUT_VERSION >= 0x0500)
/* These structures are defined for DirectX 3.0 compatibility */

typedef struct DIDEVICEINSTANCE_DX3A {
    DWORD   dwSize;
    GUID    guidInstance;
    GUID    guidProduct;
    DWORD   dwDevType;
    CHAR    tszInstanceName[MAX_PATH];
    CHAR    tszProductName[MAX_PATH];
} DIDEVICEINSTANCE_DX3A, *LPDIDEVICEINSTANCE_DX3A;
typedef struct DIDEVICEINSTANCE_DX3W {
    DWORD   dwSize;
    GUID    guidInstance;
    GUID    guidProduct;
    DWORD   dwDevType;
    WCHAR   tszInstanceName[MAX_PATH];
    WCHAR   tszProductName[MAX_PATH];
} DIDEVICEINSTANCE_DX3W, *LPDIDEVICEINSTANCE_DX3W;
#ifdef UNICODE
typedef DIDEVICEINSTANCE_DX3W DIDEVICEINSTANCE_DX3;
typedef LPDIDEVICEINSTANCE_DX3W LPDIDEVICEINSTANCE_DX3;
#else
typedef DIDEVICEINSTANCE_DX3A DIDEVICEINSTANCE_DX3;
typedef LPDIDEVICEINSTANCE_DX3A LPDIDEVICEINSTANCE_DX3;
#endif // UNICODE
typedef const DIDEVICEINSTANCE_DX3A *LPCDIDEVICEINSTANCE_DX3A;
typedef const DIDEVICEINSTANCE_DX3W *LPCDIDEVICEINSTANCE_DX3W;
typedef const DIDEVICEINSTANCE_DX3  *LPCDIDEVICEINSTANCE_DX3;
#endif /* DIRECTINPUT_VERSION >= 0x0500 */

typedef struct DIDEVICEINSTANCEA {
    DWORD   dwSize;
    GUID    guidInstance;
    GUID    guidProduct;
    DWORD   dwDevType;
    CHAR    tszInstanceName[MAX_PATH];
    CHAR    tszProductName[MAX_PATH];
#if(DIRECTINPUT_VERSION >= 0x0500)
    GUID    guidFFDriver;
    WORD    wUsagePage;
    WORD    wUsage;
#endif /* DIRECTINPUT_VERSION >= 0x0500 */
} DIDEVICEINSTANCEA, *LPDIDEVICEINSTANCEA;
typedef struct DIDEVICEINSTANCEW {
    DWORD   dwSize;
    GUID    guidInstance;
    GUID    guidProduct;
    DWORD   dwDevType;
    WCHAR   tszInstanceName[MAX_PATH];
    WCHAR   tszProductName[MAX_PATH];
#if(DIRECTINPUT_VERSION >= 0x0500)
    GUID    guidFFDriver;
    WORD    wUsagePage;
    WORD    wUsage;
#endif /* DIRECTINPUT_VERSION >= 0x0500 */
} DIDEVICEINSTANCEW, *LPDIDEVICEINSTANCEW;
#ifdef UNICODE
typedef DIDEVICEINSTANCEW DIDEVICEINSTANCE;
typedef LPDIDEVICEINSTANCEW LPDIDEVICEINSTANCE;
#else
typedef DIDEVICEINSTANCEA DIDEVICEINSTANCE;
typedef LPDIDEVICEINSTANCEA LPDIDEVICEINSTANCE;
#endif // UNICODE

typedef const DIDEVICEINSTANCEA *LPCDIDEVICEINSTANCEA;
typedef const DIDEVICEINSTANCEW *LPCDIDEVICEINSTANCEW;
#ifdef UNICODE
typedef DIDEVICEINSTANCEW DIDEVICEINSTANCE;
typedef LPCDIDEVICEINSTANCEW LPCDIDEVICEINSTANCE;
#else
typedef DIDEVICEINSTANCEA DIDEVICEINSTANCE;
typedef LPCDIDEVICEINSTANCEA LPCDIDEVICEINSTANCE;
#endif // UNICODE
typedef const DIDEVICEINSTANCE  *LPCDIDEVICEINSTANCE;

#undef INTERFACE
#define INTERFACE IDirectInputDeviceW

DECLARE_INTERFACE_(IDirectInputDeviceW, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirectInputDeviceW methods ***/
    STDMETHOD(GetCapabilities)(THIS_ LPDIDEVCAPS) PURE;
    STDMETHOD(EnumObjects)(THIS_ LPDIENUMDEVICEOBJECTSCALLBACKW,LPVOID,DWORD) PURE;
    STDMETHOD(GetProperty)(THIS_ REFGUID,LPDIPROPHEADER) PURE;
    STDMETHOD(SetProperty)(THIS_ REFGUID,LPCDIPROPHEADER) PURE;
    STDMETHOD(Acquire)(THIS) PURE;
    STDMETHOD(Unacquire)(THIS) PURE;
    STDMETHOD(GetDeviceState)(THIS_ DWORD,LPVOID) PURE;
    STDMETHOD(GetDeviceData)(THIS_ DWORD,LPDIDEVICEOBJECTDATA,LPDWORD,DWORD) PURE;
    STDMETHOD(SetDataFormat)(THIS_ LPCDIDATAFORMAT) PURE;
    STDMETHOD(SetEventNotification)(THIS_ HANDLE) PURE;
    STDMETHOD(SetCooperativeLevel)(THIS_ HWND,DWORD) PURE;
    STDMETHOD(GetObjectInfo)(THIS_ LPDIDEVICEOBJECTINSTANCEW,DWORD,DWORD) PURE;
    STDMETHOD(GetDeviceInfo)(THIS_ LPDIDEVICEINSTANCEW) PURE;
    STDMETHOD(RunControlPanel)(THIS_ HWND,DWORD) PURE;
    STDMETHOD(Initialize)(THIS_ HINSTANCE,DWORD,REFGUID) PURE;
};

typedef struct IDirectInputDeviceW *LPDIRECTINPUTDEVICEW;

#undef INTERFACE
#define INTERFACE IDirectInputDeviceA

DECLARE_INTERFACE_(IDirectInputDeviceA, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirectInputDeviceA methods ***/
    STDMETHOD(GetCapabilities)(THIS_ LPDIDEVCAPS) PURE;
    STDMETHOD(EnumObjects)(THIS_ LPDIENUMDEVICEOBJECTSCALLBACKA,LPVOID,DWORD) PURE;
    STDMETHOD(GetProperty)(THIS_ REFGUID,LPDIPROPHEADER) PURE;
    STDMETHOD(SetProperty)(THIS_ REFGUID,LPCDIPROPHEADER) PURE;
    STDMETHOD(Acquire)(THIS) PURE;
    STDMETHOD(Unacquire)(THIS) PURE;
    STDMETHOD(GetDeviceState)(THIS_ DWORD,LPVOID) PURE;
    STDMETHOD(GetDeviceData)(THIS_ DWORD,LPDIDEVICEOBJECTDATA,LPDWORD,DWORD) PURE;
    STDMETHOD(SetDataFormat)(THIS_ LPCDIDATAFORMAT) PURE;
    STDMETHOD(SetEventNotification)(THIS_ HANDLE) PURE;
    STDMETHOD(SetCooperativeLevel)(THIS_ HWND,DWORD) PURE;
    STDMETHOD(GetObjectInfo)(THIS_ LPDIDEVICEOBJECTINSTANCEA,DWORD,DWORD) PURE;
    STDMETHOD(GetDeviceInfo)(THIS_ LPDIDEVICEINSTANCEA) PURE;
    STDMETHOD(RunControlPanel)(THIS_ HWND,DWORD) PURE;
    STDMETHOD(Initialize)(THIS_ HINSTANCE,DWORD,REFGUID) PURE;
};

typedef struct IDirectInputDeviceA *LPDIRECTINPUTDEVICEA;

#ifdef UNICODE
#define IID_IDirectInputDevice IID_IDirectInputDeviceW
#define IDirectInputDevice IDirectInputDeviceW
#define IDirectInputDeviceVtbl IDirectInputDeviceWVtbl
#else
#define IID_IDirectInputDevice IID_IDirectInputDeviceA
#define IDirectInputDevice IDirectInputDeviceA
#define IDirectInputDeviceVtbl IDirectInputDeviceAVtbl
#endif
typedef struct IDirectInputDevice *LPDIRECTINPUTDEVICE;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectInputDevice_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectInputDevice_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirectInputDevice_Release(p) (p)->lpVtbl->Release(p)
#define IDirectInputDevice_GetCapabilities(p,a) (p)->lpVtbl->GetCapabilities(p,a)
#define IDirectInputDevice_EnumObjects(p,a,b,c) (p)->lpVtbl->EnumObjects(p,a,b,c)
#define IDirectInputDevice_GetProperty(p,a,b) (p)->lpVtbl->GetProperty(p,a,b)
#define IDirectInputDevice_SetProperty(p,a,b) (p)->lpVtbl->SetProperty(p,a,b)
#define IDirectInputDevice_Acquire(p) (p)->lpVtbl->Acquire(p)
#define IDirectInputDevice_Unacquire(p) (p)->lpVtbl->Unacquire(p)
#define IDirectInputDevice_GetDeviceState(p,a,b) (p)->lpVtbl->GetDeviceState(p,a,b)
#define IDirectInputDevice_GetDeviceData(p,a,b,c,d) (p)->lpVtbl->GetDeviceData(p,a,b,c,d)
#define IDirectInputDevice_SetDataFormat(p,a) (p)->lpVtbl->SetDataFormat(p,a)
#define IDirectInputDevice_SetEventNotification(p,a) (p)->lpVtbl->SetEventNotification(p,a)
#define IDirectInputDevice_SetCooperativeLevel(p,a,b) (p)->lpVtbl->SetCooperativeLevel(p,a,b)
#define IDirectInputDevice_GetObjectInfo(p,a,b,c) (p)->lpVtbl->GetObjectInfo(p,a,b,c)
#define IDirectInputDevice_GetDeviceInfo(p,a) (p)->lpVtbl->GetDeviceInfo(p,a)
#define IDirectInputDevice_RunControlPanel(p,a,b) (p)->lpVtbl->RunControlPanel(p,a,b)
#define IDirectInputDevice_Initialize(p,a,b,c) (p)->lpVtbl->Initialize(p,a,b,c)
#else
#define IDirectInputDevice_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirectInputDevice_AddRef(p) (p)->AddRef()
#define IDirectInputDevice_Release(p) (p)->Release()
#define IDirectInputDevice_GetCapabilities(p,a) (p)->GetCapabilities(a)
#define IDirectInputDevice_EnumObjects(p,a,b,c) (p)->EnumObjects(a,b,c)
#define IDirectInputDevice_GetProperty(p,a,b) (p)->GetProperty(a,b)
#define IDirectInputDevice_SetProperty(p,a,b) (p)->SetProperty(a,b)
#define IDirectInputDevice_Acquire(p) (p)->Acquire()
#define IDirectInputDevice_Unacquire(p) (p)->Unacquire()
#define IDirectInputDevice_GetDeviceState(p,a,b) (p)->GetDeviceState(a,b)
#define IDirectInputDevice_GetDeviceData(p,a,b,c,d) (p)->GetDeviceData(a,b,c,d)
#define IDirectInputDevice_SetDataFormat(p,a) (p)->SetDataFormat(a)
#define IDirectInputDevice_SetEventNotification(p,a) (p)->SetEventNotification(a)
#define IDirectInputDevice_SetCooperativeLevel(p,a,b) (p)->SetCooperativeLevel(a,b)
#define IDirectInputDevice_GetObjectInfo(p,a,b,c) (p)->GetObjectInfo(a,b,c)
#define IDirectInputDevice_GetDeviceInfo(p,a) (p)->GetDeviceInfo(a)
#define IDirectInputDevice_RunControlPanel(p,a,b) (p)->RunControlPanel(a,b)
#define IDirectInputDevice_Initialize(p,a,b,c) (p)->Initialize(a,b,c)
#endif

#endif /* DIJ_RINGZERO */


#if(DIRECTINPUT_VERSION >= 0x0500)

#define DISFFC_RESET            0x00000001
#define DISFFC_STOPALL          0x00000002
#define DISFFC_PAUSE            0x00000004
#define DISFFC_CONTINUE         0x00000008
#define DISFFC_SETACTUATORSON   0x00000010
#define DISFFC_SETACTUATORSOFF  0x00000020

#define DIGFFS_EMPTY            0x00000001
#define DIGFFS_STOPPED          0x00000002
#define DIGFFS_PAUSED           0x00000004
#define DIGFFS_ACTUATORSON      0x00000010
#define DIGFFS_ACTUATORSOFF     0x00000020
#define DIGFFS_POWERON          0x00000040
#define DIGFFS_POWEROFF         0x00000080
#define DIGFFS_SAFETYSWITCHON   0x00000100
#define DIGFFS_SAFETYSWITCHOFF  0x00000200
#define DIGFFS_USERFFSWITCHON   0x00000400
#define DIGFFS_USERFFSWITCHOFF  0x00000800
#define DIGFFS_DEVICELOST       0x80000000

#ifndef DIJ_RINGZERO

typedef struct DIEFFECTINFOA {
    DWORD   dwSize;
    GUID    guid;
    DWORD   dwEffType;
    DWORD   dwStaticParams;
    DWORD   dwDynamicParams;
    CHAR    tszName[MAX_PATH];
} DIEFFECTINFOA, *LPDIEFFECTINFOA;
typedef struct DIEFFECTINFOW {
    DWORD   dwSize;
    GUID    guid;
    DWORD   dwEffType;
    DWORD   dwStaticParams;
    DWORD   dwDynamicParams;
    WCHAR   tszName[MAX_PATH];
} DIEFFECTINFOW, *LPDIEFFECTINFOW;
#ifdef UNICODE
typedef DIEFFECTINFOW DIEFFECTINFO;
typedef LPDIEFFECTINFOW LPDIEFFECTINFO;
#else
typedef DIEFFECTINFOA DIEFFECTINFO;
typedef LPDIEFFECTINFOA LPDIEFFECTINFO;
#endif // UNICODE
typedef const DIEFFECTINFOA *LPCDIEFFECTINFOA;
typedef const DIEFFECTINFOW *LPCDIEFFECTINFOW;
typedef const DIEFFECTINFO  *LPCDIEFFECTINFO;

#define DISDD_CONTINUE          0x00000001

typedef BOOL (FAR PASCAL * LPDIENUMEFFECTSCALLBACKA)(LPCDIEFFECTINFOA, LPVOID);
typedef BOOL (FAR PASCAL * LPDIENUMEFFECTSCALLBACKW)(LPCDIEFFECTINFOW, LPVOID);
#ifdef UNICODE
#define LPDIENUMEFFECTSCALLBACK  LPDIENUMEFFECTSCALLBACKW
#else
#define LPDIENUMEFFECTSCALLBACK  LPDIENUMEFFECTSCALLBACKA
#endif // !UNICODE
typedef BOOL (FAR PASCAL * LPDIENUMCREATEDEFFECTOBJECTSCALLBACK)(LPDIRECTINPUTEFFECT, LPVOID);

#undef INTERFACE
#define INTERFACE IDirectInputDevice2W

DECLARE_INTERFACE_(IDirectInputDevice2W, IDirectInputDeviceW)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirectInputDeviceW methods ***/
    STDMETHOD(GetCapabilities)(THIS_ LPDIDEVCAPS) PURE;
    STDMETHOD(EnumObjects)(THIS_ LPDIENUMDEVICEOBJECTSCALLBACKW,LPVOID,DWORD) PURE;
    STDMETHOD(GetProperty)(THIS_ REFGUID,LPDIPROPHEADER) PURE;
    STDMETHOD(SetProperty)(THIS_ REFGUID,LPCDIPROPHEADER) PURE;
    STDMETHOD(Acquire)(THIS) PURE;
    STDMETHOD(Unacquire)(THIS) PURE;
    STDMETHOD(GetDeviceState)(THIS_ DWORD,LPVOID) PURE;
    STDMETHOD(GetDeviceData)(THIS_ DWORD,LPDIDEVICEOBJECTDATA,LPDWORD,DWORD) PURE;
    STDMETHOD(SetDataFormat)(THIS_ LPCDIDATAFORMAT) PURE;
    STDMETHOD(SetEventNotification)(THIS_ HANDLE) PURE;
    STDMETHOD(SetCooperativeLevel)(THIS_ HWND,DWORD) PURE;
    STDMETHOD(GetObjectInfo)(THIS_ LPDIDEVICEOBJECTINSTANCEW,DWORD,DWORD) PURE;
    STDMETHOD(GetDeviceInfo)(THIS_ LPDIDEVICEINSTANCEW) PURE;
    STDMETHOD(RunControlPanel)(THIS_ HWND,DWORD) PURE;
    STDMETHOD(Initialize)(THIS_ HINSTANCE,DWORD,REFGUID) PURE;

    /*** IDirectInputDevice2W methods ***/
    STDMETHOD(CreateEffect)(THIS_ REFGUID,LPCDIEFFECT,LPDIRECTINPUTEFFECT *,LPUNKNOWN) PURE;
    STDMETHOD(EnumEffects)(THIS_ LPDIENUMEFFECTSCALLBACKW,LPVOID,DWORD) PURE;
    STDMETHOD(GetEffectInfo)(THIS_ LPDIEFFECTINFOW,REFGUID) PURE;
    STDMETHOD(GetForceFeedbackState)(THIS_ LPDWORD) PURE;
    STDMETHOD(SendForceFeedbackCommand)(THIS_ DWORD) PURE;
    STDMETHOD(EnumCreatedEffectObjects)(THIS_ LPDIENUMCREATEDEFFECTOBJECTSCALLBACK,LPVOID,DWORD) PURE;
    STDMETHOD(Escape)(THIS_ LPDIEFFESCAPE) PURE;
    STDMETHOD(Poll)(THIS) PURE;
    STDMETHOD(SendDeviceData)(THIS_ DWORD,LPCDIDEVICEOBJECTDATA,LPDWORD,DWORD) PURE;
};

typedef struct IDirectInputDevice2W *LPDIRECTINPUTDEVICE2W;

#undef INTERFACE
#define INTERFACE IDirectInputDevice2A

DECLARE_INTERFACE_(IDirectInputDevice2A, IDirectInputDeviceA)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirectInputDeviceA methods ***/
    STDMETHOD(GetCapabilities)(THIS_ LPDIDEVCAPS) PURE;
    STDMETHOD(EnumObjects)(THIS_ LPDIENUMDEVICEOBJECTSCALLBACKA,LPVOID,DWORD) PURE;
    STDMETHOD(GetProperty)(THIS_ REFGUID,LPDIPROPHEADER) PURE;
    STDMETHOD(SetProperty)(THIS_ REFGUID,LPCDIPROPHEADER) PURE;
    STDMETHOD(Acquire)(THIS) PURE;
    STDMETHOD(Unacquire)(THIS) PURE;
    STDMETHOD(GetDeviceState)(THIS_ DWORD,LPVOID) PURE;
    STDMETHOD(GetDeviceData)(THIS_ DWORD,LPDIDEVICEOBJECTDATA,LPDWORD,DWORD) PURE;
    STDMETHOD(SetDataFormat)(THIS_ LPCDIDATAFORMAT) PURE;
    STDMETHOD(SetEventNotification)(THIS_ HANDLE) PURE;
    STDMETHOD(SetCooperativeLevel)(THIS_ HWND,DWORD) PURE;
    STDMETHOD(GetObjectInfo)(THIS_ LPDIDEVICEOBJECTINSTANCEA,DWORD,DWORD) PURE;
    STDMETHOD(GetDeviceInfo)(THIS_ LPDIDEVICEINSTANCEA) PURE;
    STDMETHOD(RunControlPanel)(THIS_ HWND,DWORD) PURE;
    STDMETHOD(Initialize)(THIS_ HINSTANCE,DWORD,REFGUID) PURE;

    /*** IDirectInputDevice2A methods ***/
    STDMETHOD(CreateEffect)(THIS_ REFGUID,LPCDIEFFECT,LPDIRECTINPUTEFFECT *,LPUNKNOWN) PURE;
    STDMETHOD(EnumEffects)(THIS_ LPDIENUMEFFECTSCALLBACKA,LPVOID,DWORD) PURE;
    STDMETHOD(GetEffectInfo)(THIS_ LPDIEFFECTINFOA,REFGUID) PURE;
    STDMETHOD(GetForceFeedbackState)(THIS_ LPDWORD) PURE;
    STDMETHOD(SendForceFeedbackCommand)(THIS_ DWORD) PURE;
    STDMETHOD(EnumCreatedEffectObjects)(THIS_ LPDIENUMCREATEDEFFECTOBJECTSCALLBACK,LPVOID,DWORD) PURE;
    STDMETHOD(Escape)(THIS_ LPDIEFFESCAPE) PURE;
    STDMETHOD(Poll)(THIS) PURE;
    STDMETHOD(SendDeviceData)(THIS_ DWORD,LPCDIDEVICEOBJECTDATA,LPDWORD,DWORD) PURE;
};

typedef struct IDirectInputDevice2A *LPDIRECTINPUTDEVICE2A;

#ifdef UNICODE
#define IID_IDirectInputDevice2 IID_IDirectInputDevice2W
#define IDirectInputDevice2 IDirectInputDevice2W
#define IDirectInputDevice2Vtbl IDirectInputDevice2WVtbl
#else
#define IID_IDirectInputDevice2 IID_IDirectInputDevice2A
#define IDirectInputDevice2 IDirectInputDevice2A
#define IDirectInputDevice2Vtbl IDirectInputDevice2AVtbl
#endif
typedef struct IDirectInputDevice2 *LPDIRECTINPUTDEVICE2;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectInputDevice2_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectInputDevice2_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirectInputDevice2_Release(p) (p)->lpVtbl->Release(p)
#define IDirectInputDevice2_GetCapabilities(p,a) (p)->lpVtbl->GetCapabilities(p,a)
#define IDirectInputDevice2_EnumObjects(p,a,b,c) (p)->lpVtbl->EnumObjects(p,a,b,c)
#define IDirectInputDevice2_GetProperty(p,a,b) (p)->lpVtbl->GetProperty(p,a,b)
#define IDirectInputDevice2_SetProperty(p,a,b) (p)->lpVtbl->SetProperty(p,a,b)
#define IDirectInputDevice2_Acquire(p) (p)->lpVtbl->Acquire(p)
#define IDirectInputDevice2_Unacquire(p) (p)->lpVtbl->Unacquire(p)
#define IDirectInputDevice2_GetDeviceState(p,a,b) (p)->lpVtbl->GetDeviceState(p,a,b)
#define IDirectInputDevice2_GetDeviceData(p,a,b,c,d) (p)->lpVtbl->GetDeviceData(p,a,b,c,d)
#define IDirectInputDevice2_SetDataFormat(p,a) (p)->lpVtbl->SetDataFormat(p,a)
#define IDirectInputDevice2_SetEventNotification(p,a) (p)->lpVtbl->SetEventNotification(p,a)
#define IDirectInputDevice2_SetCooperativeLevel(p,a,b) (p)->lpVtbl->SetCooperativeLevel(p,a,b)
#define IDirectInputDevice2_GetObjectInfo(p,a,b,c) (p)->lpVtbl->GetObjectInfo(p,a,b,c)
#define IDirectInputDevice2_GetDeviceInfo(p,a) (p)->lpVtbl->GetDeviceInfo(p,a)
#define IDirectInputDevice2_RunControlPanel(p,a,b) (p)->lpVtbl->RunControlPanel(p,a,b)
#define IDirectInputDevice2_Initialize(p,a,b,c) (p)->lpVtbl->Initialize(p,a,b,c)
#define IDirectInputDevice2_CreateEffect(p,a,b,c,d) (p)->lpVtbl->CreateEffect(p,a,b,c,d)
#define IDirectInputDevice2_EnumEffects(p,a,b,c) (p)->lpVtbl->EnumEffects(p,a,b,c)
#define IDirectInputDevice2_GetEffectInfo(p,a,b) (p)->lpVtbl->GetEffectInfo(p,a,b)
#define IDirectInputDevice2_GetForceFeedbackState(p,a) (p)->lpVtbl->GetForceFeedbackState(p,a)
#define IDirectInputDevice2_SendForceFeedbackCommand(p,a) (p)->lpVtbl->SendForceFeedbackCommand(p,a)
#define IDirectInputDevice2_EnumCreatedEffectObjects(p,a,b,c) (p)->lpVtbl->EnumCreatedEffectObjects(p,a,b,c)
#define IDirectInputDevice2_Escape(p,a) (p)->lpVtbl->Escape(p,a)
#define IDirectInputDevice2_Poll(p) (p)->lpVtbl->Poll(p)
#define IDirectInputDevice2_SendDeviceData(p,a,b,c,d) (p)->lpVtbl->SendDeviceData(p,a,b,c,d)
#else
#define IDirectInputDevice2_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirectInputDevice2_AddRef(p) (p)->AddRef()
#define IDirectInputDevice2_Release(p) (p)->Release()
#define IDirectInputDevice2_GetCapabilities(p,a) (p)->GetCapabilities(a)
#define IDirectInputDevice2_EnumObjects(p,a,b,c) (p)->EnumObjects(a,b,c)
#define IDirectInputDevice2_GetProperty(p,a,b) (p)->GetProperty(a,b)
#define IDirectInputDevice2_SetProperty(p,a,b) (p)->SetProperty(a,b)
#define IDirectInputDevice2_Acquire(p) (p)->Acquire()
#define IDirectInputDevice2_Unacquire(p) (p)->Unacquire()
#define IDirectInputDevice2_GetDeviceState(p,a,b) (p)->GetDeviceState(a,b)
#define IDirectInputDevice2_GetDeviceData(p,a,b,c,d) (p)->GetDeviceData(a,b,c,d)
#define IDirectInputDevice2_SetDataFormat(p,a) (p)->SetDataFormat(a)
#define IDirectInputDevice2_SetEventNotification(p,a) (p)->SetEventNotification(a)
#define IDirectInputDevice2_SetCooperativeLevel(p,a,b) (p)->SetCooperativeLevel(a,b)
#define IDirectInputDevice2_GetObjectInfo(p,a,b,c) (p)->GetObjectInfo(a,b,c)
#define IDirectInputDevice2_GetDeviceInfo(p,a) (p)->GetDeviceInfo(a)
#define IDirectInputDevice2_RunControlPanel(p,a,b) (p)->RunControlPanel(a,b)
#define IDirectInputDevice2_Initialize(p,a,b,c) (p)->Initialize(a,b,c)
#define IDirectInputDevice2_CreateEffect(p,a,b,c,d) (p)->CreateEffect(a,b,c,d)
#define IDirectInputDevice2_EnumEffects(p,a,b,c) (p)->EnumEffects(a,b,c)
#define IDirectInputDevice2_GetEffectInfo(p,a,b) (p)->GetEffectInfo(a,b)
#define IDirectInputDevice2_GetForceFeedbackState(p,a) (p)->GetForceFeedbackState(a)
#define IDirectInputDevice2_SendForceFeedbackCommand(p,a) (p)->SendForceFeedbackCommand(a)
#define IDirectInputDevice2_EnumCreatedEffectObjects(p,a,b,c) (p)->EnumCreatedEffectObjects(a,b,c)
#define IDirectInputDevice2_Escape(p,a) (p)->Escape(a)
#define IDirectInputDevice2_Poll(p) (p)->Poll()
#define IDirectInputDevice2_SendDeviceData(p,a,b,c,d) (p)->SendDeviceData(a,b,c,d)
#endif

#endif /* DIJ_RINGZERO */

#endif /* DIRECTINPUT_VERSION >= 0x0500 */

#if(DIRECTINPUT_VERSION >= 0x0700)
#define DIFEF_DEFAULT               0x00000000
#define DIFEF_INCLUDENONSTANDARD    0x00000001
#define DIFEF_MODIFYIFNEEDED            0x00000010

#ifndef DIJ_RINGZERO

#undef INTERFACE
#define INTERFACE IDirectInputDevice7W

DECLARE_INTERFACE_(IDirectInputDevice7W, IDirectInputDevice2W)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirectInputDevice2W methods ***/
    STDMETHOD(GetCapabilities)(THIS_ LPDIDEVCAPS) PURE;
    STDMETHOD(EnumObjects)(THIS_ LPDIENUMDEVICEOBJECTSCALLBACKW,LPVOID,DWORD) PURE;
    STDMETHOD(GetProperty)(THIS_ REFGUID,LPDIPROPHEADER) PURE;
    STDMETHOD(SetProperty)(THIS_ REFGUID,LPCDIPROPHEADER) PURE;
    STDMETHOD(Acquire)(THIS) PURE;
    STDMETHOD(Unacquire)(THIS) PURE;
    STDMETHOD(GetDeviceState)(THIS_ DWORD,LPVOID) PURE;
    STDMETHOD(GetDeviceData)(THIS_ DWORD,LPDIDEVICEOBJECTDATA,LPDWORD,DWORD) PURE;
    STDMETHOD(SetDataFormat)(THIS_ LPCDIDATAFORMAT) PURE;
    STDMETHOD(SetEventNotification)(THIS_ HANDLE) PURE;
    STDMETHOD(SetCooperativeLevel)(THIS_ HWND,DWORD) PURE;
    STDMETHOD(GetObjectInfo)(THIS_ LPDIDEVICEOBJECTINSTANCEW,DWORD,DWORD) PURE;
    STDMETHOD(GetDeviceInfo)(THIS_ LPDIDEVICEINSTANCEW) PURE;
    STDMETHOD(RunControlPanel)(THIS_ HWND,DWORD) PURE;
    STDMETHOD(Initialize)(THIS_ HINSTANCE,DWORD,REFGUID) PURE;
    STDMETHOD(CreateEffect)(THIS_ REFGUID,LPCDIEFFECT,LPDIRECTINPUTEFFECT *,LPUNKNOWN) PURE;
    STDMETHOD(EnumEffects)(THIS_ LPDIENUMEFFECTSCALLBACKW,LPVOID,DWORD) PURE;
    STDMETHOD(GetEffectInfo)(THIS_ LPDIEFFECTINFOW,REFGUID) PURE;
    STDMETHOD(GetForceFeedbackState)(THIS_ LPDWORD) PURE;
    STDMETHOD(SendForceFeedbackCommand)(THIS_ DWORD) PURE;
    STDMETHOD(EnumCreatedEffectObjects)(THIS_ LPDIENUMCREATEDEFFECTOBJECTSCALLBACK,LPVOID,DWORD) PURE;
    STDMETHOD(Escape)(THIS_ LPDIEFFESCAPE) PURE;
    STDMETHOD(Poll)(THIS) PURE;
    STDMETHOD(SendDeviceData)(THIS_ DWORD,LPCDIDEVICEOBJECTDATA,LPDWORD,DWORD) PURE;

    /*** IDirectInputDevice7W methods ***/
    STDMETHOD(EnumEffectsInFile)(THIS_ LPCWSTR,LPDIENUMEFFECTSINFILECALLBACK,LPVOID,DWORD) PURE;
    STDMETHOD(WriteEffectToFile)(THIS_ LPCWSTR,DWORD,LPDIFILEEFFECT,DWORD) PURE;
};

typedef struct IDirectInputDevice7W *LPDIRECTINPUTDEVICE7W;

#undef INTERFACE
#define INTERFACE IDirectInputDevice7A

DECLARE_INTERFACE_(IDirectInputDevice7A, IDirectInputDevice2A)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirectInputDevice2A methods ***/
    STDMETHOD(GetCapabilities)(THIS_ LPDIDEVCAPS) PURE;
    STDMETHOD(EnumObjects)(THIS_ LPDIENUMDEVICEOBJECTSCALLBACKA,LPVOID,DWORD) PURE;
    STDMETHOD(GetProperty)(THIS_ REFGUID,LPDIPROPHEADER) PURE;
    STDMETHOD(SetProperty)(THIS_ REFGUID,LPCDIPROPHEADER) PURE;
    STDMETHOD(Acquire)(THIS) PURE;
    STDMETHOD(Unacquire)(THIS) PURE;
    STDMETHOD(GetDeviceState)(THIS_ DWORD,LPVOID) PURE;
    STDMETHOD(GetDeviceData)(THIS_ DWORD,LPDIDEVICEOBJECTDATA,LPDWORD,DWORD) PURE;
    STDMETHOD(SetDataFormat)(THIS_ LPCDIDATAFORMAT) PURE;
    STDMETHOD(SetEventNotification)(THIS_ HANDLE) PURE;
    STDMETHOD(SetCooperativeLevel)(THIS_ HWND,DWORD) PURE;
    STDMETHOD(GetObjectInfo)(THIS_ LPDIDEVICEOBJECTINSTANCEA,DWORD,DWORD) PURE;
    STDMETHOD(GetDeviceInfo)(THIS_ LPDIDEVICEINSTANCEA) PURE;
    STDMETHOD(RunControlPanel)(THIS_ HWND,DWORD) PURE;
    STDMETHOD(Initialize)(THIS_ HINSTANCE,DWORD,REFGUID) PURE;
    STDMETHOD(CreateEffect)(THIS_ REFGUID,LPCDIEFFECT,LPDIRECTINPUTEFFECT *,LPUNKNOWN) PURE;
    STDMETHOD(EnumEffects)(THIS_ LPDIENUMEFFECTSCALLBACKA,LPVOID,DWORD) PURE;
    STDMETHOD(GetEffectInfo)(THIS_ LPDIEFFECTINFOA,REFGUID) PURE;
    STDMETHOD(GetForceFeedbackState)(THIS_ LPDWORD) PURE;
    STDMETHOD(SendForceFeedbackCommand)(THIS_ DWORD) PURE;
    STDMETHOD(EnumCreatedEffectObjects)(THIS_ LPDIENUMCREATEDEFFECTOBJECTSCALLBACK,LPVOID,DWORD) PURE;
    STDMETHOD(Escape)(THIS_ LPDIEFFESCAPE) PURE;
    STDMETHOD(Poll)(THIS) PURE;
    STDMETHOD(SendDeviceData)(THIS_ DWORD,LPCDIDEVICEOBJECTDATA,LPDWORD,DWORD) PURE;

    /*** IDirectInputDevice7A methods ***/
    STDMETHOD(EnumEffectsInFile)(THIS_ LPCSTR,LPDIENUMEFFECTSINFILECALLBACK,LPVOID,DWORD) PURE;
    STDMETHOD(WriteEffectToFile)(THIS_ LPCSTR,DWORD,LPDIFILEEFFECT,DWORD) PURE;
};

typedef struct IDirectInputDevice7A *LPDIRECTINPUTDEVICE7A;

#ifdef UNICODE
#define IID_IDirectInputDevice7 IID_IDirectInputDevice7W
#define IDirectInputDevice7 IDirectInputDevice7W
#define IDirectInputDevice7Vtbl IDirectInputDevice7WVtbl
#else
#define IID_IDirectInputDevice7 IID_IDirectInputDevice7A
#define IDirectInputDevice7 IDirectInputDevice7A
#define IDirectInputDevice7Vtbl IDirectInputDevice7AVtbl
#endif
typedef struct IDirectInputDevice7 *LPDIRECTINPUTDEVICE7;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectInputDevice7_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectInputDevice7_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirectInputDevice7_Release(p) (p)->lpVtbl->Release(p)
#define IDirectInputDevice7_GetCapabilities(p,a) (p)->lpVtbl->GetCapabilities(p,a)
#define IDirectInputDevice7_EnumObjects(p,a,b,c) (p)->lpVtbl->EnumObjects(p,a,b,c)
#define IDirectInputDevice7_GetProperty(p,a,b) (p)->lpVtbl->GetProperty(p,a,b)
#define IDirectInputDevice7_SetProperty(p,a,b) (p)->lpVtbl->SetProperty(p,a,b)
#define IDirectInputDevice7_Acquire(p) (p)->lpVtbl->Acquire(p)
#define IDirectInputDevice7_Unacquire(p) (p)->lpVtbl->Unacquire(p)
#define IDirectInputDevice7_GetDeviceState(p,a,b) (p)->lpVtbl->GetDeviceState(p,a,b)
#define IDirectInputDevice7_GetDeviceData(p,a,b,c,d) (p)->lpVtbl->GetDeviceData(p,a,b,c,d)
#define IDirectInputDevice7_SetDataFormat(p,a) (p)->lpVtbl->SetDataFormat(p,a)
#define IDirectInputDevice7_SetEventNotification(p,a) (p)->lpVtbl->SetEventNotification(p,a)
#define IDirectInputDevice7_SetCooperativeLevel(p,a,b) (p)->lpVtbl->SetCooperativeLevel(p,a,b)
#define IDirectInputDevice7_GetObjectInfo(p,a,b,c) (p)->lpVtbl->GetObjectInfo(p,a,b,c)
#define IDirectInputDevice7_GetDeviceInfo(p,a) (p)->lpVtbl->GetDeviceInfo(p,a)
#define IDirectInputDevice7_RunControlPanel(p,a,b) (p)->lpVtbl->RunControlPanel(p,a,b)
#define IDirectInputDevice7_Initialize(p,a,b,c) (p)->lpVtbl->Initialize(p,a,b,c)
#define IDirectInputDevice7_CreateEffect(p,a,b,c,d) (p)->lpVtbl->CreateEffect(p,a,b,c,d)
#define IDirectInputDevice7_EnumEffects(p,a,b,c) (p)->lpVtbl->EnumEffects(p,a,b,c)
#define IDirectInputDevice7_GetEffectInfo(p,a,b) (p)->lpVtbl->GetEffectInfo(p,a,b)
#define IDirectInputDevice7_GetForceFeedbackState(p,a) (p)->lpVtbl->GetForceFeedbackState(p,a)
#define IDirectInputDevice7_SendForceFeedbackCommand(p,a) (p)->lpVtbl->SendForceFeedbackCommand(p,a)
#define IDirectInputDevice7_EnumCreatedEffectObjects(p,a,b,c) (p)->lpVtbl->EnumCreatedEffectObjects(p,a,b,c)
#define IDirectInputDevice7_Escape(p,a) (p)->lpVtbl->Escape(p,a)
#define IDirectInputDevice7_Poll(p) (p)->lpVtbl->Poll(p)
#define IDirectInputDevice7_SendDeviceData(p,a,b,c,d) (p)->lpVtbl->SendDeviceData(p,a,b,c,d)
#define IDirectInputDevice7_EnumEffectsInFile(p,a,b,c,d) (p)->lpVtbl->EnumEffectsInFile(p,a,b,c,d)
#define IDirectInputDevice7_WriteEffectToFile(p,a,b,c,d) (p)->lpVtbl->WriteEffectToFile(p,a,b,c,d)
#else
#define IDirectInputDevice7_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirectInputDevice7_AddRef(p) (p)->AddRef()
#define IDirectInputDevice7_Release(p) (p)->Release()
#define IDirectInputDevice7_GetCapabilities(p,a) (p)->GetCapabilities(a)
#define IDirectInputDevice7_EnumObjects(p,a,b,c) (p)->EnumObjects(a,b,c)
#define IDirectInputDevice7_GetProperty(p,a,b) (p)->GetProperty(a,b)
#define IDirectInputDevice7_SetProperty(p,a,b) (p)->SetProperty(a,b)
#define IDirectInputDevice7_Acquire(p) (p)->Acquire()
#define IDirectInputDevice7_Unacquire(p) (p)->Unacquire()
#define IDirectInputDevice7_GetDeviceState(p,a,b) (p)->GetDeviceState(a,b)
#define IDirectInputDevice7_GetDeviceData(p,a,b,c,d) (p)->GetDeviceData(a,b,c,d)
#define IDirectInputDevice7_SetDataFormat(p,a) (p)->SetDataFormat(a)
#define IDirectInputDevice7_SetEventNotification(p,a) (p)->SetEventNotification(a)
#define IDirectInputDevice7_SetCooperativeLevel(p,a,b) (p)->SetCooperativeLevel(a,b)
#define IDirectInputDevice7_GetObjectInfo(p,a,b,c) (p)->GetObjectInfo(a,b,c)
#define IDirectInputDevice7_GetDeviceInfo(p,a) (p)->GetDeviceInfo(a)
#define IDirectInputDevice7_RunControlPanel(p,a,b) (p)->RunControlPanel(a,b)
#define IDirectInputDevice7_Initialize(p,a,b,c) (p)->Initialize(a,b,c)
#define IDirectInputDevice7_CreateEffect(p,a,b,c,d) (p)->CreateEffect(a,b,c,d)
#define IDirectInputDevice7_EnumEffects(p,a,b,c) (p)->EnumEffects(a,b,c)
#define IDirectInputDevice7_GetEffectInfo(p,a,b) (p)->GetEffectInfo(a,b)
#define IDirectInputDevice7_GetForceFeedbackState(p,a) (p)->GetForceFeedbackState(a)
#define IDirectInputDevice7_SendForceFeedbackCommand(p,a) (p)->SendForceFeedbackCommand(a)
#define IDirectInputDevice7_EnumCreatedEffectObjects(p,a,b,c) (p)->EnumCreatedEffectObjects(a,b,c)
#define IDirectInputDevice7_Escape(p,a) (p)->Escape(a)
#define IDirectInputDevice7_Poll(p) (p)->Poll()
#define IDirectInputDevice7_SendDeviceData(p,a,b,c,d) (p)->SendDeviceData(a,b,c,d)
#define IDirectInputDevice7_EnumEffectsInFile(p,a,b,c,d) (p)->EnumEffectsInFile(a,b,c,d)
#define IDirectInputDevice7_WriteEffectToFile(p,a,b,c,d) (p)->WriteEffectToFile(a,b,c,d)
#endif

#endif /* DIJ_RINGZERO */

#endif /* DIRECTINPUT_VERSION >= 0x0700 */

#if(DIRECTINPUT_VERSION >= 0x0800)

#ifndef DIJ_RINGZERO

#undef INTERFACE
#define INTERFACE IDirectInputDevice8W

DECLARE_INTERFACE_(IDirectInputDevice8W, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirectInputDevice8W methods ***/
    STDMETHOD(GetCapabilities)(THIS_ LPDIDEVCAPS) PURE;
    STDMETHOD(EnumObjects)(THIS_ LPDIENUMDEVICEOBJECTSCALLBACKW,LPVOID,DWORD) PURE;
    STDMETHOD(GetProperty)(THIS_ REFGUID,LPDIPROPHEADER) PURE;
    STDMETHOD(SetProperty)(THIS_ REFGUID,LPCDIPROPHEADER) PURE;
    STDMETHOD(Acquire)(THIS) PURE;
    STDMETHOD(Unacquire)(THIS) PURE;
    STDMETHOD(GetDeviceState)(THIS_ DWORD,LPVOID) PURE;
    STDMETHOD(GetDeviceData)(THIS_ DWORD,LPDIDEVICEOBJECTDATA,LPDWORD,DWORD) PURE;
    STDMETHOD(SetDataFormat)(THIS_ LPCDIDATAFORMAT) PURE;
    STDMETHOD(SetEventNotification)(THIS_ HANDLE) PURE;
    STDMETHOD(SetCooperativeLevel)(THIS_ HWND,DWORD) PURE;
    STDMETHOD(GetObjectInfo)(THIS_ LPDIDEVICEOBJECTINSTANCEW,DWORD,DWORD) PURE;
    STDMETHOD(GetDeviceInfo)(THIS_ LPDIDEVICEINSTANCEW) PURE;
    STDMETHOD(RunControlPanel)(THIS_ HWND,DWORD) PURE;
    STDMETHOD(Initialize)(THIS_ HINSTANCE,DWORD,REFGUID) PURE;
    STDMETHOD(CreateEffect)(THIS_ REFGUID,LPCDIEFFECT,LPDIRECTINPUTEFFECT *,LPUNKNOWN) PURE;
    STDMETHOD(EnumEffects)(THIS_ LPDIENUMEFFECTSCALLBACKW,LPVOID,DWORD) PURE;
    STDMETHOD(GetEffectInfo)(THIS_ LPDIEFFECTINFOW,REFGUID) PURE;
    STDMETHOD(GetForceFeedbackState)(THIS_ LPDWORD) PURE;
    STDMETHOD(SendForceFeedbackCommand)(THIS_ DWORD) PURE;
    STDMETHOD(EnumCreatedEffectObjects)(THIS_ LPDIENUMCREATEDEFFECTOBJECTSCALLBACK,LPVOID,DWORD) PURE;
    STDMETHOD(Escape)(THIS_ LPDIEFFESCAPE) PURE;
    STDMETHOD(Poll)(THIS) PURE;
    STDMETHOD(SendDeviceData)(THIS_ DWORD,LPCDIDEVICEOBJECTDATA,LPDWORD,DWORD) PURE;
    STDMETHOD(EnumEffectsInFile)(THIS_ LPCWSTR,LPDIENUMEFFECTSINFILECALLBACK,LPVOID,DWORD) PURE;
    STDMETHOD(WriteEffectToFile)(THIS_ LPCWSTR,DWORD,LPDIFILEEFFECT,DWORD) PURE;
    STDMETHOD(BuildActionMap)(THIS_ LPDIACTIONFORMATW,LPCWSTR,DWORD) PURE;
    STDMETHOD(SetActionMap)(THIS_ LPDIACTIONFORMATW,LPCWSTR,DWORD) PURE;
    STDMETHOD(GetImageInfo)(THIS_ LPDIDEVICEIMAGEINFOHEADERW) PURE;
};

typedef struct IDirectInputDevice8W *LPDIRECTINPUTDEVICE8W;

#undef INTERFACE
#define INTERFACE IDirectInputDevice8A

DECLARE_INTERFACE_(IDirectInputDevice8A, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirectInputDevice8A methods ***/
    STDMETHOD(GetCapabilities)(THIS_ LPDIDEVCAPS) PURE;
    STDMETHOD(EnumObjects)(THIS_ LPDIENUMDEVICEOBJECTSCALLBACKA,LPVOID,DWORD) PURE;
    STDMETHOD(GetProperty)(THIS_ REFGUID,LPDIPROPHEADER) PURE;
    STDMETHOD(SetProperty)(THIS_ REFGUID,LPCDIPROPHEADER) PURE;
    STDMETHOD(Acquire)(THIS) PURE;
    STDMETHOD(Unacquire)(THIS) PURE;
    STDMETHOD(GetDeviceState)(THIS_ DWORD,LPVOID) PURE;
    STDMETHOD(GetDeviceData)(THIS_ DWORD,LPDIDEVICEOBJECTDATA,LPDWORD,DWORD) PURE;
    STDMETHOD(SetDataFormat)(THIS_ LPCDIDATAFORMAT) PURE;
    STDMETHOD(SetEventNotification)(THIS_ HANDLE) PURE;
    STDMETHOD(SetCooperativeLevel)(THIS_ HWND,DWORD) PURE;
    STDMETHOD(GetObjectInfo)(THIS_ LPDIDEVICEOBJECTINSTANCEA,DWORD,DWORD) PURE;
    STDMETHOD(GetDeviceInfo)(THIS_ LPDIDEVICEINSTANCEA) PURE;
    STDMETHOD(RunControlPanel)(THIS_ HWND,DWORD) PURE;
    STDMETHOD(Initialize)(THIS_ HINSTANCE,DWORD,REFGUID) PURE;
    STDMETHOD(CreateEffect)(THIS_ REFGUID,LPCDIEFFECT,LPDIRECTINPUTEFFECT *,LPUNKNOWN) PURE;
    STDMETHOD(EnumEffects)(THIS_ LPDIENUMEFFECTSCALLBACKA,LPVOID,DWORD) PURE;
    STDMETHOD(GetEffectInfo)(THIS_ LPDIEFFECTINFOA,REFGUID) PURE;
    STDMETHOD(GetForceFeedbackState)(THIS_ LPDWORD) PURE;
    STDMETHOD(SendForceFeedbackCommand)(THIS_ DWORD) PURE;
    STDMETHOD(EnumCreatedEffectObjects)(THIS_ LPDIENUMCREATEDEFFECTOBJECTSCALLBACK,LPVOID,DWORD) PURE;
    STDMETHOD(Escape)(THIS_ LPDIEFFESCAPE) PURE;
    STDMETHOD(Poll)(THIS) PURE;
    STDMETHOD(SendDeviceData)(THIS_ DWORD,LPCDIDEVICEOBJECTDATA,LPDWORD,DWORD) PURE;
    STDMETHOD(EnumEffectsInFile)(THIS_ LPCSTR,LPDIENUMEFFECTSINFILECALLBACK,LPVOID,DWORD) PURE;
    STDMETHOD(WriteEffectToFile)(THIS_ LPCSTR,DWORD,LPDIFILEEFFECT,DWORD) PURE;
    STDMETHOD(BuildActionMap)(THIS_ LPDIACTIONFORMATA,LPCSTR,DWORD) PURE;
    STDMETHOD(SetActionMap)(THIS_ LPDIACTIONFORMATA,LPCSTR,DWORD) PURE;
    STDMETHOD(GetImageInfo)(THIS_ LPDIDEVICEIMAGEINFOHEADERA) PURE;
};

typedef struct IDirectInputDevice8A *LPDIRECTINPUTDEVICE8A;

#ifdef UNICODE
#define IID_IDirectInputDevice8 IID_IDirectInputDevice8W
#define IDirectInputDevice8 IDirectInputDevice8W
#define IDirectInputDevice8Vtbl IDirectInputDevice8WVtbl
#else
#define IID_IDirectInputDevice8 IID_IDirectInputDevice8A
#define IDirectInputDevice8 IDirectInputDevice8A
#define IDirectInputDevice8Vtbl IDirectInputDevice8AVtbl
#endif
typedef struct IDirectInputDevice8 *LPDIRECTINPUTDEVICE8;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectInputDevice8_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectInputDevice8_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirectInputDevice8_Release(p) (p)->lpVtbl->Release(p)
#define IDirectInputDevice8_GetCapabilities(p,a) (p)->lpVtbl->GetCapabilities(p,a)
#define IDirectInputDevice8_EnumObjects(p,a,b,c) (p)->lpVtbl->EnumObjects(p,a,b,c)
#define IDirectInputDevice8_GetProperty(p,a,b) (p)->lpVtbl->GetProperty(p,a,b)
#define IDirectInputDevice8_SetProperty(p,a,b) (p)->lpVtbl->SetProperty(p,a,b)
#define IDirectInputDevice8_Acquire(p) (p)->lpVtbl->Acquire(p)
#define IDirectInputDevice8_Unacquire(p) (p)->lpVtbl->Unacquire(p)
#define IDirectInputDevice8_GetDeviceState(p,a,b) (p)->lpVtbl->GetDeviceState(p,a,b)
#define IDirectInputDevice8_GetDeviceData(p,a,b,c,d) (p)->lpVtbl->GetDeviceData(p,a,b,c,d)
#define IDirectInputDevice8_SetDataFormat(p,a) (p)->lpVtbl->SetDataFormat(p,a)
#define IDirectInputDevice8_SetEventNotification(p,a) (p)->lpVtbl->SetEventNotification(p,a)
#define IDirectInputDevice8_SetCooperativeLevel(p,a,b) (p)->lpVtbl->SetCooperativeLevel(p,a,b)
#define IDirectInputDevice8_GetObjectInfo(p,a,b,c) (p)->lpVtbl->GetObjectInfo(p,a,b,c)
#define IDirectInputDevice8_GetDeviceInfo(p,a) (p)->lpVtbl->GetDeviceInfo(p,a)
#define IDirectInputDevice8_RunControlPanel(p,a,b) (p)->lpVtbl->RunControlPanel(p,a,b)
#define IDirectInputDevice8_Initialize(p,a,b,c) (p)->lpVtbl->Initialize(p,a,b,c)
#define IDirectInputDevice8_CreateEffect(p,a,b,c,d) (p)->lpVtbl->CreateEffect(p,a,b,c,d)
#define IDirectInputDevice8_EnumEffects(p,a,b,c) (p)->lpVtbl->EnumEffects(p,a,b,c)
#define IDirectInputDevice8_GetEffectInfo(p,a,b) (p)->lpVtbl->GetEffectInfo(p,a,b)
#define IDirectInputDevice8_GetForceFeedbackState(p,a) (p)->lpVtbl->GetForceFeedbackState(p,a)
#define IDirectInputDevice8_SendForceFeedbackCommand(p,a) (p)->lpVtbl->SendForceFeedbackCommand(p,a)
#define IDirectInputDevice8_EnumCreatedEffectObjects(p,a,b,c) (p)->lpVtbl->EnumCreatedEffectObjects(p,a,b,c)
#define IDirectInputDevice8_Escape(p,a) (p)->lpVtbl->Escape(p,a)
#define IDirectInputDevice8_Poll(p) (p)->lpVtbl->Poll(p)
#define IDirectInputDevice8_SendDeviceData(p,a,b,c,d) (p)->lpVtbl->SendDeviceData(p,a,b,c,d)
#define IDirectInputDevice8_EnumEffectsInFile(p,a,b,c,d) (p)->lpVtbl->EnumEffectsInFile(p,a,b,c,d)
#define IDirectInputDevice8_WriteEffectToFile(p,a,b,c,d) (p)->lpVtbl->WriteEffectToFile(p,a,b,c,d)
#define IDirectInputDevice8_BuildActionMap(p,a,b,c) (p)->lpVtbl->BuildActionMap(p,a,b,c)
#define IDirectInputDevice8_SetActionMap(p,a,b,c) (p)->lpVtbl->SetActionMap(p,a,b,c)
#define IDirectInputDevice8_GetImageInfo(p,a) (p)->lpVtbl->GetImageInfo(p,a)
#else
#define IDirectInputDevice8_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirectInputDevice8_AddRef(p) (p)->AddRef()
#define IDirectInputDevice8_Release(p) (p)->Release()
#define IDirectInputDevice8_GetCapabilities(p,a) (p)->GetCapabilities(a)
#define IDirectInputDevice8_EnumObjects(p,a,b,c) (p)->EnumObjects(a,b,c)
#define IDirectInputDevice8_GetProperty(p,a,b) (p)->GetProperty(a,b)
#define IDirectInputDevice8_SetProperty(p,a,b) (p)->SetProperty(a,b)
#define IDirectInputDevice8_Acquire(p) (p)->Acquire()
#define IDirectInputDevice8_Unacquire(p) (p)->Unacquire()
#define IDirectInputDevice8_GetDeviceState(p,a,b) (p)->GetDeviceState(a,b)
#define IDirectInputDevice8_GetDeviceData(p,a,b,c,d) (p)->GetDeviceData(a,b,c,d)
#define IDirectInputDevice8_SetDataFormat(p,a) (p)->SetDataFormat(a)
#define IDirectInputDevice8_SetEventNotification(p,a) (p)->SetEventNotification(a)
#define IDirectInputDevice8_SetCooperativeLevel(p,a,b) (p)->SetCooperativeLevel(a,b)
#define IDirectInputDevice8_GetObjectInfo(p,a,b,c) (p)->GetObjectInfo(a,b,c)
#define IDirectInputDevice8_GetDeviceInfo(p,a) (p)->GetDeviceInfo(a)
#define IDirectInputDevice8_RunControlPanel(p,a,b) (p)->RunControlPanel(a,b)
#define IDirectInputDevice8_Initialize(p,a,b,c) (p)->Initialize(a,b,c)
#define IDirectInputDevice8_CreateEffect(p,a,b,c,d) (p)->CreateEffect(a,b,c,d)
#define IDirectInputDevice8_EnumEffects(p,a,b,c) (p)->EnumEffects(a,b,c)
#define IDirectInputDevice8_GetEffectInfo(p,a,b) (p)->GetEffectInfo(a,b)
#define IDirectInputDevice8_GetForceFeedbackState(p,a) (p)->GetForceFeedbackState(a)
#define IDirectInputDevice8_SendForceFeedbackCommand(p,a) (p)->SendForceFeedbackCommand(a)
#define IDirectInputDevice8_EnumCreatedEffectObjects(p,a,b,c) (p)->EnumCreatedEffectObjects(a,b,c)
#define IDirectInputDevice8_Escape(p,a) (p)->Escape(a)
#define IDirectInputDevice8_Poll(p) (p)->Poll()
#define IDirectInputDevice8_SendDeviceData(p,a,b,c,d) (p)->SendDeviceData(a,b,c,d)
#define IDirectInputDevice8_EnumEffectsInFile(p,a,b,c,d) (p)->EnumEffectsInFile(a,b,c,d)
#define IDirectInputDevice8_WriteEffectToFile(p,a,b,c,d) (p)->WriteEffectToFile(a,b,c,d)
#define IDirectInputDevice8_BuildActionMap(p,a,b,c) (p)->BuildActionMap(a,b,c)
#define IDirectInputDevice8_SetActionMap(p,a,b,c) (p)->SetActionMap(a,b,c)
#define IDirectInputDevice8_GetImageInfo(p,a) (p)->GetImageInfo(a)
#endif

#endif /* DIJ_RINGZERO */

#endif /* DIRECTINPUT_VERSION >= 0x0800 */

/****************************************************************************
 *
 *      Mouse
 *
 ****************************************************************************/

#ifndef DIJ_RINGZERO

typedef struct _DIMOUSESTATE {
    LONG    lX;
    LONG    lY;
    LONG    lZ;
    BYTE    rgbButtons[4];
} DIMOUSESTATE, *LPDIMOUSESTATE;

#if DIRECTINPUT_VERSION >= 0x0700
typedef struct _DIMOUSESTATE2 {
    LONG    lX;
    LONG    lY;
    LONG    lZ;
    BYTE    rgbButtons[8];
} DIMOUSESTATE2, *LPDIMOUSESTATE2;
#endif


#define DIMOFS_X        FIELD_OFFSET(DIMOUSESTATE, lX)
#define DIMOFS_Y        FIELD_OFFSET(DIMOUSESTATE, lY)
#define DIMOFS_Z        FIELD_OFFSET(DIMOUSESTATE, lZ)
#define DIMOFS_BUTTON0 (FIELD_OFFSET(DIMOUSESTATE, rgbButtons) + 0)
#define DIMOFS_BUTTON1 (FIELD_OFFSET(DIMOUSESTATE, rgbButtons) + 1)
#define DIMOFS_BUTTON2 (FIELD_OFFSET(DIMOUSESTATE, rgbButtons) + 2)
#define DIMOFS_BUTTON3 (FIELD_OFFSET(DIMOUSESTATE, rgbButtons) + 3)
#if (DIRECTINPUT_VERSION >= 0x0700)
#define DIMOFS_BUTTON4 (FIELD_OFFSET(DIMOUSESTATE2, rgbButtons) + 4)
#define DIMOFS_BUTTON5 (FIELD_OFFSET(DIMOUSESTATE2, rgbButtons) + 5)
#define DIMOFS_BUTTON6 (FIELD_OFFSET(DIMOUSESTATE2, rgbButtons) + 6)
#define DIMOFS_BUTTON7 (FIELD_OFFSET(DIMOUSESTATE2, rgbButtons) + 7)
#endif
#endif /* DIJ_RINGZERO */

/****************************************************************************
 *
 *      Keyboard
 *
 ****************************************************************************/

#ifndef DIJ_RINGZERO

/****************************************************************************
 *
 *      DirectInput keyboard scan codes
 *
 ****************************************************************************/
#define DIK_ESCAPE          0x01
#define DIK_1               0x02
#define DIK_2               0x03
#define DIK_3               0x04
#define DIK_4               0x05
#define DIK_5               0x06
#define DIK_6               0x07
#define DIK_7               0x08
#define DIK_8               0x09
#define DIK_9               0x0A
#define DIK_0               0x0B
#define DIK_MINUS           0x0C    /* - on main keyboard */
#define DIK_EQUALS          0x0D
#define DIK_BACK            0x0E    /* backspace */
#define DIK_TAB             0x0F
#define DIK_Q               0x10
#define DIK_W               0x11
#define DIK_E               0x12
#define DIK_R               0x13
#define DIK_T               0x14
#define DIK_Y               0x15
#define DIK_U               0x16
#define DIK_I               0x17
#define DIK_O               0x18
#define DIK_P               0x19
#define DIK_LBRACKET        0x1A
#define DIK_RBRACKET        0x1B
#define DIK_RETURN          0x1C    /* Enter on main keyboard */
#define DIK_LCONTROL        0x1D
#define DIK_A               0x1E
#define DIK_S               0x1F
#define DIK_D               0x20
#define DIK_F               0x21
#define DIK_G               0x22
#define DIK_H               0x23
#define DIK_J               0x24
#define DIK_K               0x25
#define DIK_L               0x26
#define DIK_SEMICOLON       0x27
#define DIK_APOSTROPHE      0x28
#define DIK_GRAVE           0x29    /* accent grave */
#define DIK_LSHIFT          0x2A
#define DIK_BACKSLASH       0x2B
#define DIK_Z               0x2C
#define DIK_X               0x2D
#define DIK_C               0x2E
#define DIK_V               0x2F
#define DIK_B               0x30
#define DIK_N               0x31
#define DIK_M               0x32
#define DIK_COMMA           0x33
#define DIK_PERIOD          0x34    /* . on main keyboard */
#define DIK_SLASH           0x35    /* / on main keyboard */
#define DIK_RSHIFT          0x36
#define DIK_MULTIPLY        0x37    /* * on numeric keypad */
#define DIK_LMENU           0x38    /* left Alt */
#define DIK_SPACE           0x39
#define DIK_CAPITAL         0x3A
#define DIK_F1              0x3B
#define DIK_F2              0x3C
#define DIK_F3              0x3D
#define DIK_F4              0x3E
#define DIK_F5              0x3F
#define DIK_F6              0x40
#define DIK_F7              0x41
#define DIK_F8              0x42
#define DIK_F9              0x43
#define DIK_F10             0x44
#define DIK_NUMLOCK         0x45
#define DIK_SCROLL          0x46    /* Scroll Lock */
#define DIK_NUMPAD7         0x47
#define DIK_NUMPAD8         0x48
#define DIK_NUMPAD9         0x49
#define DIK_SUBTRACT        0x4A    /* - on numeric keypad */
#define DIK_NUMPAD4         0x4B
#define DIK_NUMPAD5         0x4C
#define DIK_NUMPAD6         0x4D
#define DIK_ADD             0x4E    /* + on numeric keypad */
#define DIK_NUMPAD1         0x4F
#define DIK_NUMPAD2         0x50
#define DIK_NUMPAD3         0x51
#define DIK_NUMPAD0         0x52
#define DIK_DECIMAL         0x53    /* . on numeric keypad */
#define DIK_OEM_102         0x56    /* < > | on UK/Germany keyboards */
#define DIK_F11             0x57
#define DIK_F12             0x58
#define DIK_F13             0x64    /*                     (NEC PC98) */
#define DIK_F14             0x65    /*                     (NEC PC98) */
#define DIK_F15             0x66    /*                     (NEC PC98) */
#define DIK_KANA            0x70    /* (Japanese keyboard)            */
#define DIK_ABNT_C1         0x73    /* / ? on Portugese (Brazilian) keyboards */
#define DIK_CONVERT         0x79    /* (Japanese keyboard)            */
#define DIK_NOCONVERT       0x7B    /* (Japanese keyboard)            */
#define DIK_YEN             0x7D    /* (Japanese keyboard)            */
#define DIK_ABNT_C2         0x7E    /* Numpad . on Portugese (Brazilian) keyboards */
#define DIK_NUMPADEQUALS    0x8D    /* = on numeric keypad (NEC PC98) */
#define DIK_PREVTRACK       0x90    /* Previous Track (DIK_CIRCUMFLEX on Japanese keyboard) */
#define DIK_AT              0x91    /*                     (NEC PC98) */
#define DIK_COLON           0x92    /*                     (NEC PC98) */
#define DIK_UNDERLINE       0x93    /*                     (NEC PC98) */
#define DIK_KANJI           0x94    /* (Japanese keyboard)            */
#define DIK_STOP            0x95    /*                     (NEC PC98) */
#define DIK_AX              0x96    /*                     (Japan AX) */
#define DIK_UNLABELED       0x97    /*                        (J3100) */
#define DIK_NEXTTRACK       0x99    /* Next Track */
#define DIK_NUMPADENTER     0x9C    /* Enter on numeric keypad */
#define DIK_RCONTROL        0x9D
#define DIK_MUTE            0xA0    /* Mute */
#define DIK_CALCULATOR      0xA1    /* Calculator */
#define DIK_PLAYPAUSE       0xA2    /* Play / Pause */
#define DIK_MEDIASTOP       0xA4    /* Media Stop */
#define DIK_VOLUMEDOWN      0xAE    /* Volume - */
#define DIK_VOLUMEUP        0xB0    /* Volume + */
#define DIK_WEBHOME         0xB2    /* Web home */
#define DIK_NUMPADCOMMA     0xB3    /* , on numeric keypad (NEC PC98) */
#define DIK_DIVIDE          0xB5    /* / on numeric keypad */
#define DIK_SYSRQ           0xB7
#define DIK_RMENU           0xB8    /* right Alt */
#define DIK_PAUSE           0xC5    /* Pause */
#define DIK_HOME            0xC7    /* Home on arrow keypad */
#define DIK_UP              0xC8    /* UpArrow on arrow keypad */
#define DIK_PRIOR           0xC9    /* PgUp on arrow keypad */
#define DIK_LEFT            0xCB    /* LeftArrow on arrow keypad */
#define DIK_RIGHT           0xCD    /* RightArrow on arrow keypad */
#define DIK_END             0xCF    /* End on arrow keypad */
#define DIK_DOWN            0xD0    /* DownArrow on arrow keypad */
#define DIK_NEXT            0xD1    /* PgDn on arrow keypad */
#define DIK_INSERT          0xD2    /* Insert on arrow keypad */
#define DIK_DELETE          0xD3    /* Delete on arrow keypad */
#define DIK_LWIN            0xDB    /* Left Windows key */
#define DIK_RWIN            0xDC    /* Right Windows key */
#define DIK_APPS            0xDD    /* AppMenu key */
#define DIK_POWER           0xDE    /* System Power */
#define DIK_SLEEP           0xDF    /* System Sleep */
#define DIK_WAKE            0xE3    /* System Wake */
#define DIK_WEBSEARCH       0xE5    /* Web Search */
#define DIK_WEBFAVORITES    0xE6    /* Web Favorites */
#define DIK_WEBREFRESH      0xE7    /* Web Refresh */
#define DIK_WEBSTOP         0xE8    /* Web Stop */
#define DIK_WEBFORWARD      0xE9    /* Web Forward */
#define DIK_WEBBACK         0xEA    /* Web Back */
#define DIK_MYCOMPUTER      0xEB    /* My Computer */
#define DIK_MAIL            0xEC    /* Mail */
#define DIK_MEDIASELECT     0xED    /* Media Select */

/*
 *  Alternate names for keys, to facilitate transition from DOS.
 */
#define DIK_BACKSPACE       DIK_BACK            /* backspace */
#define DIK_NUMPADSTAR      DIK_MULTIPLY        /* * on numeric keypad */
#define DIK_LALT            DIK_LMENU           /* left Alt */
#define DIK_CAPSLOCK        DIK_CAPITAL         /* CapsLock */
#define DIK_NUMPADMINUS     DIK_SUBTRACT        /* - on numeric keypad */
#define DIK_NUMPADPLUS      DIK_ADD             /* + on numeric keypad */
#define DIK_NUMPADPERIOD    DIK_DECIMAL         /* . on numeric keypad */
#define DIK_NUMPADSLASH     DIK_DIVIDE          /* / on numeric keypad */
#define DIK_RALT            DIK_RMENU           /* right Alt */
#define DIK_UPARROW         DIK_UP              /* UpArrow on arrow keypad */
#define DIK_PGUP            DIK_PRIOR           /* PgUp on arrow keypad */
#define DIK_LEFTARROW       DIK_LEFT            /* LeftArrow on arrow keypad */
#define DIK_RIGHTARROW      DIK_RIGHT           /* RightArrow on arrow keypad */
#define DIK_DOWNARROW       DIK_DOWN            /* DownArrow on arrow keypad */
#define DIK_PGDN            DIK_NEXT            /* PgDn on arrow keypad */

/*
 *  Alternate names for keys originally not used on US keyboards.
 */
#define DIK_CIRCUMFLEX      DIK_PREVTRACK       /* Japanese keyboard */

#endif /* DIJ_RINGZERO */

/****************************************************************************
 *
 *      Joystick
 *
 ****************************************************************************/

#ifndef DIJ_RINGZERO

typedef struct DIJOYSTATE {
    LONG    lX;                     /* x-axis position              */
    LONG    lY;                     /* y-axis position              */
    LONG    lZ;                     /* z-axis position              */
    LONG    lRx;                    /* x-axis rotation              */
    LONG    lRy;                    /* y-axis rotation              */
    LONG    lRz;                    /* z-axis rotation              */
    LONG    rglSlider[2];           /* extra axes positions         */
    DWORD   rgdwPOV[4];             /* POV directions               */
    BYTE    rgbButtons[32];         /* 32 buttons                   */
} DIJOYSTATE, *LPDIJOYSTATE;

typedef struct DIJOYSTATE2 {
    LONG    lX;                     /* x-axis position              */
    LONG    lY;                     /* y-axis position              */
    LONG    lZ;                     /* z-axis position              */
    LONG    lRx;                    /* x-axis rotation              */
    LONG    lRy;                    /* y-axis rotation              */
    LONG    lRz;                    /* z-axis rotation              */
    LONG    rglSlider[2];           /* extra axes positions         */
    DWORD   rgdwPOV[4];             /* POV directions               */
    BYTE    rgbButtons[128];        /* 128 buttons                  */
    LONG    lVX;                    /* x-axis velocity              */
    LONG    lVY;                    /* y-axis velocity              */
    LONG    lVZ;                    /* z-axis velocity              */
    LONG    lVRx;                   /* x-axis angular velocity      */
    LONG    lVRy;                   /* y-axis angular velocity      */
    LONG    lVRz;                   /* z-axis angular velocity      */
    LONG    rglVSlider[2];          /* extra axes velocities        */
    LONG    lAX;                    /* x-axis acceleration          */
    LONG    lAY;                    /* y-axis acceleration          */
    LONG    lAZ;                    /* z-axis acceleration          */
    LONG    lARx;                   /* x-axis angular acceleration  */
    LONG    lARy;                   /* y-axis angular acceleration  */
    LONG    lARz;                   /* z-axis angular acceleration  */
    LONG    rglASlider[2];          /* extra axes accelerations     */
    LONG    lFX;                    /* x-axis force                 */
    LONG    lFY;                    /* y-axis force                 */
    LONG    lFZ;                    /* z-axis force                 */
    LONG    lFRx;                   /* x-axis torque                */
    LONG    lFRy;                   /* y-axis torque                */
    LONG    lFRz;                   /* z-axis torque                */
    LONG    rglFSlider[2];          /* extra axes forces            */
} DIJOYSTATE2, *LPDIJOYSTATE2;

#define DIJOFS_X            FIELD_OFFSET(DIJOYSTATE, lX)
#define DIJOFS_Y            FIELD_OFFSET(DIJOYSTATE, lY)
#define DIJOFS_Z            FIELD_OFFSET(DIJOYSTATE, lZ)
#define DIJOFS_RX           FIELD_OFFSET(DIJOYSTATE, lRx)
#define DIJOFS_RY           FIELD_OFFSET(DIJOYSTATE, lRy)
#define DIJOFS_RZ           FIELD_OFFSET(DIJOYSTATE, lRz)
#define DIJOFS_SLIDER(n)   (FIELD_OFFSET(DIJOYSTATE, rglSlider) + \
                                                        (n) * sizeof(LONG))
#define DIJOFS_POV(n)      (FIELD_OFFSET(DIJOYSTATE, rgdwPOV) + \
                                                        (n) * sizeof(DWORD))
#define DIJOFS_BUTTON(n)   (FIELD_OFFSET(DIJOYSTATE, rgbButtons) + (n))
#define DIJOFS_BUTTON0      DIJOFS_BUTTON(0)
#define DIJOFS_BUTTON1      DIJOFS_BUTTON(1)
#define DIJOFS_BUTTON2      DIJOFS_BUTTON(2)
#define DIJOFS_BUTTON3      DIJOFS_BUTTON(3)
#define DIJOFS_BUTTON4      DIJOFS_BUTTON(4)
#define DIJOFS_BUTTON5      DIJOFS_BUTTON(5)
#define DIJOFS_BUTTON6      DIJOFS_BUTTON(6)
#define DIJOFS_BUTTON7      DIJOFS_BUTTON(7)
#define DIJOFS_BUTTON8      DIJOFS_BUTTON(8)
#define DIJOFS_BUTTON9      DIJOFS_BUTTON(9)
#define DIJOFS_BUTTON10     DIJOFS_BUTTON(10)
#define DIJOFS_BUTTON11     DIJOFS_BUTTON(11)
#define DIJOFS_BUTTON12     DIJOFS_BUTTON(12)
#define DIJOFS_BUTTON13     DIJOFS_BUTTON(13)
#define DIJOFS_BUTTON14     DIJOFS_BUTTON(14)
#define DIJOFS_BUTTON15     DIJOFS_BUTTON(15)
#define DIJOFS_BUTTON16     DIJOFS_BUTTON(16)
#define DIJOFS_BUTTON17     DIJOFS_BUTTON(17)
#define DIJOFS_BUTTON18     DIJOFS_BUTTON(18)
#define DIJOFS_BUTTON19     DIJOFS_BUTTON(19)
#define DIJOFS_BUTTON20     DIJOFS_BUTTON(20)
#define DIJOFS_BUTTON21     DIJOFS_BUTTON(21)
#define DIJOFS_BUTTON22     DIJOFS_BUTTON(22)
#define DIJOFS_BUTTON23     DIJOFS_BUTTON(23)
#define DIJOFS_BUTTON24     DIJOFS_BUTTON(24)
#define DIJOFS_BUTTON25     DIJOFS_BUTTON(25)
#define DIJOFS_BUTTON26     DIJOFS_BUTTON(26)
#define DIJOFS_BUTTON27     DIJOFS_BUTTON(27)
#define DIJOFS_BUTTON28     DIJOFS_BUTTON(28)
#define DIJOFS_BUTTON29     DIJOFS_BUTTON(29)
#define DIJOFS_BUTTON30     DIJOFS_BUTTON(30)
#define DIJOFS_BUTTON31     DIJOFS_BUTTON(31)


#endif /* DIJ_RINGZERO */

/****************************************************************************
 *
 *  IDirectInput
 *
 ****************************************************************************/

#ifndef DIJ_RINGZERO

#define DIENUM_STOP             0
#define DIENUM_CONTINUE         1

typedef BOOL (FAR PASCAL * LPDIENUMDEVICESCALLBACKA)(LPCDIDEVICEINSTANCEA, LPVOID);
typedef BOOL (FAR PASCAL * LPDIENUMDEVICESCALLBACKW)(LPCDIDEVICEINSTANCEW, LPVOID);
#ifdef UNICODE
#define LPDIENUMDEVICESCALLBACK  LPDIENUMDEVICESCALLBACKW
#else
#define LPDIENUMDEVICESCALLBACK  LPDIENUMDEVICESCALLBACKA
#endif // !UNICODE
typedef BOOL (FAR PASCAL * LPDICONFIGUREDEVICESCALLBACK)(IUnknown FAR *, LPVOID);

#define DIEDFL_ALLDEVICES       0x00000000
#define DIEDFL_ATTACHEDONLY     0x00000001
#if(DIRECTINPUT_VERSION >= 0x0500)
#define DIEDFL_FORCEFEEDBACK    0x00000100
#endif /* DIRECTINPUT_VERSION >= 0x0500 */
#if(DIRECTINPUT_VERSION >= 0x050a)
#define DIEDFL_INCLUDEALIASES   0x00010000
#define DIEDFL_INCLUDEPHANTOMS  0x00020000
#endif /* DIRECTINPUT_VERSION >= 0x050a */
#if(DIRECTINPUT_VERSION >= 0x0800)
#define DIEDFL_INCLUDEHIDDEN    0x00040000
#endif /* DIRECTINPUT_VERSION >= 0x0800 */


#if(DIRECTINPUT_VERSION >= 0x0800)
typedef BOOL (FAR PASCAL * LPDIENUMDEVICESBYSEMANTICSCBA)(LPCDIDEVICEINSTANCEA, LPDIRECTINPUTDEVICE8A, DWORD, DWORD, LPVOID);
typedef BOOL (FAR PASCAL * LPDIENUMDEVICESBYSEMANTICSCBW)(LPCDIDEVICEINSTANCEW, LPDIRECTINPUTDEVICE8W, DWORD, DWORD, LPVOID);
#ifdef UNICODE
#define LPDIENUMDEVICESBYSEMANTICSCB  LPDIENUMDEVICESBYSEMANTICSCBW
#else
#define LPDIENUMDEVICESBYSEMANTICSCB  LPDIENUMDEVICESBYSEMANTICSCBA
#endif // !UNICODE
#endif /* DIRECTINPUT_VERSION >= 0x0800 */

#if(DIRECTINPUT_VERSION >= 0x0800)
#define DIEDBS_MAPPEDPRI1         0x00000001
#define DIEDBS_MAPPEDPRI2         0x00000002
#define DIEDBS_RECENTDEVICE       0x00000010
#define DIEDBS_NEWDEVICE          0x00000020
#endif /* DIRECTINPUT_VERSION >= 0x0800 */

#if(DIRECTINPUT_VERSION >= 0x0800)
#define DIEDBSFL_ATTACHEDONLY       0x00000000
#define DIEDBSFL_THISUSER           0x00000010
#define DIEDBSFL_FORCEFEEDBACK      DIEDFL_FORCEFEEDBACK
#define DIEDBSFL_AVAILABLEDEVICES   0x00001000
#define DIEDBSFL_MULTIMICEKEYBOARDS 0x00002000
#define DIEDBSFL_NONGAMINGDEVICES   0x00004000
#define DIEDBSFL_VALID              0x00007110
#endif /* DIRECTINPUT_VERSION >= 0x0800 */

#undef INTERFACE
#define INTERFACE IDirectInputW

DECLARE_INTERFACE_(IDirectInputW, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirectInputW methods ***/
    STDMETHOD(CreateDevice)(THIS_ REFGUID,LPDIRECTINPUTDEVICEW *,LPUNKNOWN) PURE;
    STDMETHOD(EnumDevices)(THIS_ DWORD,LPDIENUMDEVICESCALLBACKW,LPVOID,DWORD) PURE;
    STDMETHOD(GetDeviceStatus)(THIS_ REFGUID) PURE;
    STDMETHOD(RunControlPanel)(THIS_ HWND,DWORD) PURE;
    STDMETHOD(Initialize)(THIS_ HINSTANCE,DWORD) PURE;
};

typedef struct IDirectInputW *LPDIRECTINPUTW;

#undef INTERFACE
#define INTERFACE IDirectInputA

DECLARE_INTERFACE_(IDirectInputA, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirectInputA methods ***/
    STDMETHOD(CreateDevice)(THIS_ REFGUID,LPDIRECTINPUTDEVICEA *,LPUNKNOWN) PURE;
    STDMETHOD(EnumDevices)(THIS_ DWORD,LPDIENUMDEVICESCALLBACKA,LPVOID,DWORD) PURE;
    STDMETHOD(GetDeviceStatus)(THIS_ REFGUID) PURE;
    STDMETHOD(RunControlPanel)(THIS_ HWND,DWORD) PURE;
    STDMETHOD(Initialize)(THIS_ HINSTANCE,DWORD) PURE;
};

typedef struct IDirectInputA *LPDIRECTINPUTA;

#ifdef UNICODE
#define IID_IDirectInput IID_IDirectInputW
#define IDirectInput IDirectInputW
#define IDirectInputVtbl IDirectInputWVtbl
#else
#define IID_IDirectInput IID_IDirectInputA
#define IDirectInput IDirectInputA
#define IDirectInputVtbl IDirectInputAVtbl
#endif
typedef struct IDirectInput *LPDIRECTINPUT;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectInput_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectInput_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirectInput_Release(p) (p)->lpVtbl->Release(p)
#define IDirectInput_CreateDevice(p,a,b,c) (p)->lpVtbl->CreateDevice(p,a,b,c)
#define IDirectInput_EnumDevices(p,a,b,c,d) (p)->lpVtbl->EnumDevices(p,a,b,c,d)
#define IDirectInput_GetDeviceStatus(p,a) (p)->lpVtbl->GetDeviceStatus(p,a)
#define IDirectInput_RunControlPanel(p,a,b) (p)->lpVtbl->RunControlPanel(p,a,b)
#define IDirectInput_Initialize(p,a,b) (p)->lpVtbl->Initialize(p,a,b)
#else
#define IDirectInput_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirectInput_AddRef(p) (p)->AddRef()
#define IDirectInput_Release(p) (p)->Release()
#define IDirectInput_CreateDevice(p,a,b,c) (p)->CreateDevice(a,b,c)
#define IDirectInput_EnumDevices(p,a,b,c,d) (p)->EnumDevices(a,b,c,d)
#define IDirectInput_GetDeviceStatus(p,a) (p)->GetDeviceStatus(a)
#define IDirectInput_RunControlPanel(p,a,b) (p)->RunControlPanel(a,b)
#define IDirectInput_Initialize(p,a,b) (p)->Initialize(a,b)
#endif

#undef INTERFACE
#define INTERFACE IDirectInput2W

DECLARE_INTERFACE_(IDirectInput2W, IDirectInputW)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirectInputW methods ***/
    STDMETHOD(CreateDevice)(THIS_ REFGUID,LPDIRECTINPUTDEVICEW *,LPUNKNOWN) PURE;
    STDMETHOD(EnumDevices)(THIS_ DWORD,LPDIENUMDEVICESCALLBACKW,LPVOID,DWORD) PURE;
    STDMETHOD(GetDeviceStatus)(THIS_ REFGUID) PURE;
    STDMETHOD(RunControlPanel)(THIS_ HWND,DWORD) PURE;
    STDMETHOD(Initialize)(THIS_ HINSTANCE,DWORD) PURE;

    /*** IDirectInput2W methods ***/
    STDMETHOD(FindDevice)(THIS_ REFGUID,LPCWSTR,LPGUID) PURE;
};

typedef struct IDirectInput2W *LPDIRECTINPUT2W;

#undef INTERFACE
#define INTERFACE IDirectInput2A

DECLARE_INTERFACE_(IDirectInput2A, IDirectInputA)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirectInputA methods ***/
    STDMETHOD(CreateDevice)(THIS_ REFGUID,LPDIRECTINPUTDEVICEA *,LPUNKNOWN) PURE;
    STDMETHOD(EnumDevices)(THIS_ DWORD,LPDIENUMDEVICESCALLBACKA,LPVOID,DWORD) PURE;
    STDMETHOD(GetDeviceStatus)(THIS_ REFGUID) PURE;
    STDMETHOD(RunControlPanel)(THIS_ HWND,DWORD) PURE;
    STDMETHOD(Initialize)(THIS_ HINSTANCE,DWORD) PURE;

    /*** IDirectInput2A methods ***/
    STDMETHOD(FindDevice)(THIS_ REFGUID,LPCSTR,LPGUID) PURE;
};

typedef struct IDirectInput2A *LPDIRECTINPUT2A;

#ifdef UNICODE
#define IID_IDirectInput2 IID_IDirectInput2W
#define IDirectInput2 IDirectInput2W
#define IDirectInput2Vtbl IDirectInput2WVtbl
#else
#define IID_IDirectInput2 IID_IDirectInput2A
#define IDirectInput2 IDirectInput2A
#define IDirectInput2Vtbl IDirectInput2AVtbl
#endif
typedef struct IDirectInput2 *LPDIRECTINPUT2;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectInput2_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectInput2_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirectInput2_Release(p) (p)->lpVtbl->Release(p)
#define IDirectInput2_CreateDevice(p,a,b,c) (p)->lpVtbl->CreateDevice(p,a,b,c)
#define IDirectInput2_EnumDevices(p,a,b,c,d) (p)->lpVtbl->EnumDevices(p,a,b,c,d)
#define IDirectInput2_GetDeviceStatus(p,a) (p)->lpVtbl->GetDeviceStatus(p,a)
#define IDirectInput2_RunControlPanel(p,a,b) (p)->lpVtbl->RunControlPanel(p,a,b)
#define IDirectInput2_Initialize(p,a,b) (p)->lpVtbl->Initialize(p,a,b)
#define IDirectInput2_FindDevice(p,a,b,c) (p)->lpVtbl->FindDevice(p,a,b,c)
#else
#define IDirectInput2_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirectInput2_AddRef(p) (p)->AddRef()
#define IDirectInput2_Release(p) (p)->Release()
#define IDirectInput2_CreateDevice(p,a,b,c) (p)->CreateDevice(a,b,c)
#define IDirectInput2_EnumDevices(p,a,b,c,d) (p)->EnumDevices(a,b,c,d)
#define IDirectInput2_GetDeviceStatus(p,a) (p)->GetDeviceStatus(a)
#define IDirectInput2_RunControlPanel(p,a,b) (p)->RunControlPanel(a,b)
#define IDirectInput2_Initialize(p,a,b) (p)->Initialize(a,b)
#define IDirectInput2_FindDevice(p,a,b,c) (p)->FindDevice(a,b,c)
#endif


#undef INTERFACE
#define INTERFACE IDirectInput7W

DECLARE_INTERFACE_(IDirectInput7W, IDirectInput2W)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirectInput2W methods ***/
    STDMETHOD(CreateDevice)(THIS_ REFGUID,LPDIRECTINPUTDEVICEW *,LPUNKNOWN) PURE;
    STDMETHOD(EnumDevices)(THIS_ DWORD,LPDIENUMDEVICESCALLBACKW,LPVOID,DWORD) PURE;
    STDMETHOD(GetDeviceStatus)(THIS_ REFGUID) PURE;
    STDMETHOD(RunControlPanel)(THIS_ HWND,DWORD) PURE;
    STDMETHOD(Initialize)(THIS_ HINSTANCE,DWORD) PURE;
    STDMETHOD(FindDevice)(THIS_ REFGUID,LPCWSTR,LPGUID) PURE;

    /*** IDirectInput7W methods ***/
    STDMETHOD(CreateDeviceEx)(THIS_ REFGUID,REFIID,LPVOID *,LPUNKNOWN) PURE;
};

typedef struct IDirectInput7W *LPDIRECTINPUT7W;

#undef INTERFACE
#define INTERFACE IDirectInput7A

DECLARE_INTERFACE_(IDirectInput7A, IDirectInput2A)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirectInput2A methods ***/
    STDMETHOD(CreateDevice)(THIS_ REFGUID,LPDIRECTINPUTDEVICEA *,LPUNKNOWN) PURE;
    STDMETHOD(EnumDevices)(THIS_ DWORD,LPDIENUMDEVICESCALLBACKA,LPVOID,DWORD) PURE;
    STDMETHOD(GetDeviceStatus)(THIS_ REFGUID) PURE;
    STDMETHOD(RunControlPanel)(THIS_ HWND,DWORD) PURE;
    STDMETHOD(Initialize)(THIS_ HINSTANCE,DWORD) PURE;
    STDMETHOD(FindDevice)(THIS_ REFGUID,LPCSTR,LPGUID) PURE;

    /*** IDirectInput7A methods ***/
    STDMETHOD(CreateDeviceEx)(THIS_ REFGUID,REFIID,LPVOID *,LPUNKNOWN) PURE;
};

typedef struct IDirectInput7A *LPDIRECTINPUT7A;

#ifdef UNICODE
#define IID_IDirectInput7 IID_IDirectInput7W
#define IDirectInput7 IDirectInput7W
#define IDirectInput7Vtbl IDirectInput7WVtbl
#else
#define IID_IDirectInput7 IID_IDirectInput7A
#define IDirectInput7 IDirectInput7A
#define IDirectInput7Vtbl IDirectInput7AVtbl
#endif
typedef struct IDirectInput7 *LPDIRECTINPUT7;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectInput7_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectInput7_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirectInput7_Release(p) (p)->lpVtbl->Release(p)
#define IDirectInput7_CreateDevice(p,a,b,c) (p)->lpVtbl->CreateDevice(p,a,b,c)
#define IDirectInput7_EnumDevices(p,a,b,c,d) (p)->lpVtbl->EnumDevices(p,a,b,c,d)
#define IDirectInput7_GetDeviceStatus(p,a) (p)->lpVtbl->GetDeviceStatus(p,a)
#define IDirectInput7_RunControlPanel(p,a,b) (p)->lpVtbl->RunControlPanel(p,a,b)
#define IDirectInput7_Initialize(p,a,b) (p)->lpVtbl->Initialize(p,a,b)
#define IDirectInput7_FindDevice(p,a,b,c) (p)->lpVtbl->FindDevice(p,a,b,c)
#define IDirectInput7_CreateDeviceEx(p,a,b,c,d) (p)->lpVtbl->CreateDeviceEx(p,a,b,c,d)
#else
#define IDirectInput7_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirectInput7_AddRef(p) (p)->AddRef()
#define IDirectInput7_Release(p) (p)->Release()
#define IDirectInput7_CreateDevice(p,a,b,c) (p)->CreateDevice(a,b,c)
#define IDirectInput7_EnumDevices(p,a,b,c,d) (p)->EnumDevices(a,b,c,d)
#define IDirectInput7_GetDeviceStatus(p,a) (p)->GetDeviceStatus(a)
#define IDirectInput7_RunControlPanel(p,a,b) (p)->RunControlPanel(a,b)
#define IDirectInput7_Initialize(p,a,b) (p)->Initialize(a,b)
#define IDirectInput7_FindDevice(p,a,b,c) (p)->FindDevice(a,b,c)
#define IDirectInput7_CreateDeviceEx(p,a,b,c,d) (p)->CreateDeviceEx(a,b,c,d)
#endif

#if(DIRECTINPUT_VERSION >= 0x0800)
#undef INTERFACE
#define INTERFACE IDirectInput8W

DECLARE_INTERFACE_(IDirectInput8W, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirectInput8W methods ***/
    STDMETHOD(CreateDevice)(THIS_ REFGUID,LPDIRECTINPUTDEVICE8W *,LPUNKNOWN) PURE;
    STDMETHOD(EnumDevices)(THIS_ DWORD,LPDIENUMDEVICESCALLBACKW,LPVOID,DWORD) PURE;
    STDMETHOD(GetDeviceStatus)(THIS_ REFGUID) PURE;
    STDMETHOD(RunControlPanel)(THIS_ HWND,DWORD) PURE;
    STDMETHOD(Initialize)(THIS_ HINSTANCE,DWORD) PURE;
    STDMETHOD(FindDevice)(THIS_ REFGUID,LPCWSTR,LPGUID) PURE;
    STDMETHOD(EnumDevicesBySemantics)(THIS_ LPCWSTR,LPDIACTIONFORMATW,LPDIENUMDEVICESBYSEMANTICSCBW,LPVOID,DWORD) PURE;
    STDMETHOD(ConfigureDevices)(THIS_ LPDICONFIGUREDEVICESCALLBACK,LPDICONFIGUREDEVICESPARAMSW,DWORD,LPVOID) PURE;
};

typedef struct IDirectInput8W *LPDIRECTINPUT8W;

#undef INTERFACE
#define INTERFACE IDirectInput8A

DECLARE_INTERFACE_(IDirectInput8A, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirectInput8A methods ***/
    STDMETHOD(CreateDevice)(THIS_ REFGUID,LPDIRECTINPUTDEVICE8A *,LPUNKNOWN) PURE;
    STDMETHOD(EnumDevices)(THIS_ DWORD,LPDIENUMDEVICESCALLBACKA,LPVOID,DWORD) PURE;
    STDMETHOD(GetDeviceStatus)(THIS_ REFGUID) PURE;
    STDMETHOD(RunControlPanel)(THIS_ HWND,DWORD) PURE;
    STDMETHOD(Initialize)(THIS_ HINSTANCE,DWORD) PURE;
    STDMETHOD(FindDevice)(THIS_ REFGUID,LPCSTR,LPGUID) PURE;
    STDMETHOD(EnumDevicesBySemantics)(THIS_ LPCSTR,LPDIACTIONFORMATA,LPDIENUMDEVICESBYSEMANTICSCBA,LPVOID,DWORD) PURE;
    STDMETHOD(ConfigureDevices)(THIS_ LPDICONFIGUREDEVICESCALLBACK,LPDICONFIGUREDEVICESPARAMSA,DWORD,LPVOID) PURE;
};

typedef struct IDirectInput8A *LPDIRECTINPUT8A;

#ifdef UNICODE
#define IID_IDirectInput8 IID_IDirectInput8W
#define IDirectInput8 IDirectInput8W
#define IDirectInput8Vtbl IDirectInput8WVtbl
#else
#define IID_IDirectInput8 IID_IDirectInput8A
#define IDirectInput8 IDirectInput8A
#define IDirectInput8Vtbl IDirectInput8AVtbl
#endif
typedef struct IDirectInput8 *LPDIRECTINPUT8;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectInput8_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectInput8_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirectInput8_Release(p) (p)->lpVtbl->Release(p)
#define IDirectInput8_CreateDevice(p,a,b,c) (p)->lpVtbl->CreateDevice(p,a,b,c)
#define IDirectInput8_EnumDevices(p,a,b,c,d) (p)->lpVtbl->EnumDevices(p,a,b,c,d)
#define IDirectInput8_GetDeviceStatus(p,a) (p)->lpVtbl->GetDeviceStatus(p,a)
#define IDirectInput8_RunControlPanel(p,a,b) (p)->lpVtbl->RunControlPanel(p,a,b)
#define IDirectInput8_Initialize(p,a,b) (p)->lpVtbl->Initialize(p,a,b)
#define IDirectInput8_FindDevice(p,a,b,c) (p)->lpVtbl->FindDevice(p,a,b,c)
#define IDirectInput8_EnumDevicesBySemantics(p,a,b,c,d,e) (p)->lpVtbl->EnumDevicesBySemantics(p,a,b,c,d,e)
#define IDirectInput8_ConfigureDevices(p,a,b,c,d) (p)->lpVtbl->ConfigureDevices(p,a,b,c,d)
#else
#define IDirectInput8_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirectInput8_AddRef(p) (p)->AddRef()
#define IDirectInput8_Release(p) (p)->Release()
#define IDirectInput8_CreateDevice(p,a,b,c) (p)->CreateDevice(a,b,c)
#define IDirectInput8_EnumDevices(p,a,b,c,d) (p)->EnumDevices(a,b,c,d)
#define IDirectInput8_GetDeviceStatus(p,a) (p)->GetDeviceStatus(a)
#define IDirectInput8_RunControlPanel(p,a,b) (p)->RunControlPanel(a,b)
#define IDirectInput8_Initialize(p,a,b) (p)->Initialize(a,b)
#define IDirectInput8_FindDevice(p,a,b,c) (p)->FindDevice(a,b,c)
#define IDirectInput8_EnumDevicesBySemantics(p,a,b,c,d,e) (p)->EnumDevicesBySemantics(a,b,c,d,e)
#define IDirectInput8_ConfigureDevices(p,a,b,c,d) (p)->ConfigureDevices(a,b,c,d)
#endif
#endif /* DIRECTINPUT_VERSION >= 0x0800 */

#if DIRECTINPUT_VERSION > 0x0700

extern HRESULT WINAPI DirectInput8Create(HINSTANCE hinst, DWORD dwVersion, REFIID riidltf, LPVOID *ppvOut, LPUNKNOWN punkOuter);

#else
extern HRESULT WINAPI DirectInputCreateA(HINSTANCE hinst, DWORD dwVersion, LPDIRECTINPUTA *ppDI, LPUNKNOWN punkOuter);
extern HRESULT WINAPI DirectInputCreateW(HINSTANCE hinst, DWORD dwVersion, LPDIRECTINPUTW *ppDI, LPUNKNOWN punkOuter);
#ifdef UNICODE
#define DirectInputCreate  DirectInputCreateW
#else
#define DirectInputCreate  DirectInputCreateA
#endif // !UNICODE

extern HRESULT WINAPI DirectInputCreateEx(HINSTANCE hinst, DWORD dwVersion, REFIID riidltf, LPVOID *ppvOut, LPUNKNOWN punkOuter);

#endif /* DIRECTINPUT_VERSION > 0x700 */

#endif /* DIJ_RINGZERO */


/****************************************************************************
 *
 *  Return Codes
 *
 ****************************************************************************/

/*
 *  The operation completed successfully.
 */
#define DI_OK                           S_OK

/*
 *  The device exists but is not currently attached.
 */
#define DI_NOTATTACHED                  S_FALSE

/*
 *  The device buffer overflowed.  Some input was lost.
 */
#define DI_BUFFEROVERFLOW               S_FALSE

/*
 *  The change in device properties had no effect.
 */
#define DI_PROPNOEFFECT                 S_FALSE

/*
 *  The operation had no effect.
 */
#define DI_NOEFFECT                     S_FALSE

/*
 *  The device is a polled device.  As a result, device buffering
 *  will not collect any data and event notifications will not be
 *  signalled until GetDeviceState is called.
 */
#define DI_POLLEDDEVICE                 ((HRESULT)0x00000002L)

/*
 *  The parameters of the effect were successfully updated by
 *  IDirectInputEffect::SetParameters, but the effect was not
 *  downloaded because the device is not exclusively acquired
 *  or because the DIEP_NODOWNLOAD flag was passed.
 */
#define DI_DOWNLOADSKIPPED              ((HRESULT)0x00000003L)

/*
 *  The parameters of the effect were successfully updated by
 *  IDirectInputEffect::SetParameters, but in order to change
 *  the parameters, the effect needed to be restarted.
 */
#define DI_EFFECTRESTARTED              ((HRESULT)0x00000004L)

/*
 *  The parameters of the effect were successfully updated by
 *  IDirectInputEffect::SetParameters, but some of them were
 *  beyond the capabilities of the device and were truncated.
 */
#define DI_TRUNCATED                    ((HRESULT)0x00000008L)

/*
 *  The settings have been successfully applied but could not be 
 *  persisted. 
 */
#define DI_SETTINGSNOTSAVED				((HRESULT)0x0000000BL)

/*
 *  Equal to DI_EFFECTRESTARTED | DI_TRUNCATED.
 */
#define DI_TRUNCATEDANDRESTARTED        ((HRESULT)0x0000000CL)

/*
 *  A SUCCESS code indicating that settings cannot be modified.
 */
#define DI_WRITEPROTECT                 ((HRESULT)0x00000013L)

/*
 *  The application requires a newer version of DirectInput.
 */
#define DIERR_OLDDIRECTINPUTVERSION     \
    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_OLD_WIN_VERSION)

/*
 *  The application was written for an unsupported prerelease version
 *  of DirectInput.
 */
#define DIERR_BETADIRECTINPUTVERSION    \
    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_RMODE_APP)

/*
 *  The object could not be created due to an incompatible driver version
 *  or mismatched or incomplete driver components.
 */
#define DIERR_BADDRIVERVER              \
    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_BAD_DRIVER_LEVEL)

/*
 * The device or device instance or effect is not registered with DirectInput.
 */
#define DIERR_DEVICENOTREG              REGDB_E_CLASSNOTREG

/*
 * The requested object does not exist.
 */
#define DIERR_NOTFOUND                  \
    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_FILE_NOT_FOUND)

/*
 * The requested object does not exist.
 */
#define DIERR_OBJECTNOTFOUND            \
    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_FILE_NOT_FOUND)

/*
 * An invalid parameter was passed to the returning function,
 * or the object was not in a state that admitted the function
 * to be called.
 */
#define DIERR_INVALIDPARAM              E_INVALIDARG

/*
 * The specified interface is not supported by the object
 */
#define DIERR_NOINTERFACE               E_NOINTERFACE

/*
 * An undetermined error occured inside the DInput subsystem
 */
#define DIERR_GENERIC                   E_FAIL

/*
 * The DInput subsystem couldn't allocate sufficient memory to complete the
 * caller's request.
 */
#define DIERR_OUTOFMEMORY               E_OUTOFMEMORY

/*
 * The function called is not supported at this time
 */
#define DIERR_UNSUPPORTED               E_NOTIMPL

/*
 * This object has not been initialized
 */
#define DIERR_NOTINITIALIZED            \
    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_NOT_READY)

/*
 * This object is already initialized
 */
#define DIERR_ALREADYINITIALIZED        \
    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_ALREADY_INITIALIZED)

/*
 * This object does not support aggregation
 */
#define DIERR_NOAGGREGATION             CLASS_E_NOAGGREGATION

/*
 * Another app has a higher priority level, preventing this call from
 * succeeding.
 */
#define DIERR_OTHERAPPHASPRIO           E_ACCESSDENIED

/*
 * Access to the device has been lost.  It must be re-acquired.
 */
#define DIERR_INPUTLOST                 \
    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_READ_FAULT)

/*
 * The operation cannot be performed while the device is acquired.
 */
#define DIERR_ACQUIRED                  \
    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_BUSY)

/*
 * The operation cannot be performed unless the device is acquired.
 */
#define DIERR_NOTACQUIRED               \
    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_INVALID_ACCESS)

/*
 * The specified property cannot be changed.
 */
#define DIERR_READONLY                  E_ACCESSDENIED

/*
 * The device already has an event notification associated with it.
 */
#define DIERR_HANDLEEXISTS              E_ACCESSDENIED

/*
 * Data is not yet available.
 */
#ifndef E_PENDING
#define E_PENDING                       0x8000000AL
#endif

/*
 * Unable to IDirectInputJoyConfig_Acquire because the user
 * does not have sufficient privileges to change the joystick
 * configuration.
 */
#define DIERR_INSUFFICIENTPRIVS         0x80040200L

/*
 * The device is full.
 */
#define DIERR_DEVICEFULL                0x80040201L

/*
 * Not all the requested information fit into the buffer.
 */
#define DIERR_MOREDATA                  0x80040202L

/*
 * The effect is not downloaded.
 */
#define DIERR_NOTDOWNLOADED             0x80040203L

/*
 *  The device cannot be reinitialized because there are still effects
 *  attached to it.
 */
#define DIERR_HASEFFECTS                0x80040204L

/*
 *  The operation cannot be performed unless the device is acquired
 *  in DISCL_EXCLUSIVE mode.
 */
#define DIERR_NOTEXCLUSIVEACQUIRED      0x80040205L

/*
 *  The effect could not be downloaded because essential information
 *  is missing.  For example, no axes have been associated with the
 *  effect, or no type-specific information has been created.
 */
#define DIERR_INCOMPLETEEFFECT          0x80040206L

/*
 *  Attempted to read buffered device data from a device that is
 *  not buffered.
 */
#define DIERR_NOTBUFFERED               0x80040207L

/*
 *  An attempt was made to modify parameters of an effect while it is
 *  playing.  Not all hardware devices support altering the parameters
 *  of an effect while it is playing.
 */
#define DIERR_EFFECTPLAYING             0x80040208L

/*
 *  The operation could not be completed because the device is not
 *  plugged in.
 */
#define DIERR_UNPLUGGED                 0x80040209L

/*
 *  SendDeviceData failed because more information was requested
 *  to be sent than can be sent to the device.  Some devices have
 *  restrictions on how much data can be sent to them.  (For example,
 *  there might be a limit on the number of buttons that can be
 *  pressed at once.)
 */
#define DIERR_REPORTFULL                0x8004020AL


/*
 *  A mapper file function failed because reading or writing the user or IHV 
 *  settings file failed.
 */
#define DIERR_MAPFILEFAIL               0x8004020BL


/*--- DINPUT Mapper Definitions: New for Dx8         ---*/


/*--- Keyboard
      Physical Keyboard Device       ---*/

#define DIKEYBOARD_ESCAPE                       0x81000401
#define DIKEYBOARD_1                            0x81000402
#define DIKEYBOARD_2                            0x81000403
#define DIKEYBOARD_3                            0x81000404
#define DIKEYBOARD_4                            0x81000405
#define DIKEYBOARD_5                            0x81000406
#define DIKEYBOARD_6                            0x81000407
#define DIKEYBOARD_7                            0x81000408
#define DIKEYBOARD_8                            0x81000409
#define DIKEYBOARD_9                            0x8100040A
#define DIKEYBOARD_0                            0x8100040B
#define DIKEYBOARD_MINUS                        0x8100040C    /* - on main keyboard */
#define DIKEYBOARD_EQUALS                       0x8100040D
#define DIKEYBOARD_BACK                         0x8100040E    /* backspace */
#define DIKEYBOARD_TAB                          0x8100040F
#define DIKEYBOARD_Q                            0x81000410
#define DIKEYBOARD_W                            0x81000411
#define DIKEYBOARD_E                            0x81000412
#define DIKEYBOARD_R                            0x81000413
#define DIKEYBOARD_T                            0x81000414
#define DIKEYBOARD_Y                            0x81000415
#define DIKEYBOARD_U                            0x81000416
#define DIKEYBOARD_I                            0x81000417
#define DIKEYBOARD_O                            0x81000418
#define DIKEYBOARD_P                            0x81000419
#define DIKEYBOARD_LBRACKET                     0x8100041A
#define DIKEYBOARD_RBRACKET                     0x8100041B
#define DIKEYBOARD_RETURN                       0x8100041C    /* Enter on main keyboard */
#define DIKEYBOARD_LCONTROL                     0x8100041D
#define DIKEYBOARD_A                            0x8100041E
#define DIKEYBOARD_S                            0x8100041F
#define DIKEYBOARD_D                            0x81000420
#define DIKEYBOARD_F                            0x81000421
#define DIKEYBOARD_G                            0x81000422
#define DIKEYBOARD_H                            0x81000423
#define DIKEYBOARD_J                            0x81000424
#define DIKEYBOARD_K                            0x81000425
#define DIKEYBOARD_L                            0x81000426
#define DIKEYBOARD_SEMICOLON                    0x81000427
#define DIKEYBOARD_APOSTROPHE                   0x81000428
#define DIKEYBOARD_GRAVE                        0x81000429    /* accent grave */
#define DIKEYBOARD_LSHIFT                       0x8100042A
#define DIKEYBOARD_BACKSLASH                    0x8100042B
#define DIKEYBOARD_Z                            0x8100042C
#define DIKEYBOARD_X                            0x8100042D
#define DIKEYBOARD_C                            0x8100042E
#define DIKEYBOARD_V                            0x8100042F
#define DIKEYBOARD_B                            0x81000430
#define DIKEYBOARD_N                            0x81000431
#define DIKEYBOARD_M                            0x81000432
#define DIKEYBOARD_COMMA                        0x81000433
#define DIKEYBOARD_PERIOD                       0x81000434    /* . on main keyboard */
#define DIKEYBOARD_SLASH                        0x81000435    /* / on main keyboard */
#define DIKEYBOARD_RSHIFT                       0x81000436
#define DIKEYBOARD_MULTIPLY                     0x81000437    /* * on numeric keypad */
#define DIKEYBOARD_LMENU                        0x81000438    /* left Alt */
#define DIKEYBOARD_SPACE                        0x81000439
#define DIKEYBOARD_CAPITAL                      0x8100043A
#define DIKEYBOARD_F1                           0x8100043B
#define DIKEYBOARD_F2                           0x8100043C
#define DIKEYBOARD_F3                           0x8100043D
#define DIKEYBOARD_F4                           0x8100043E
#define DIKEYBOARD_F5                           0x8100043F
#define DIKEYBOARD_F6                           0x81000440
#define DIKEYBOARD_F7                           0x81000441
#define DIKEYBOARD_F8                           0x81000442
#define DIKEYBOARD_F9                           0x81000443
#define DIKEYBOARD_F10                          0x81000444
#define DIKEYBOARD_NUMLOCK                      0x81000445
#define DIKEYBOARD_SCROLL                       0x81000446    /* Scroll Lock */
#define DIKEYBOARD_NUMPAD7                      0x81000447
#define DIKEYBOARD_NUMPAD8                      0x81000448
#define DIKEYBOARD_NUMPAD9                      0x81000449
#define DIKEYBOARD_SUBTRACT                     0x8100044A    /* - on numeric keypad */
#define DIKEYBOARD_NUMPAD4                      0x8100044B
#define DIKEYBOARD_NUMPAD5                      0x8100044C
#define DIKEYBOARD_NUMPAD6                      0x8100044D
#define DIKEYBOARD_ADD                          0x8100044E    /* + on numeric keypad */
#define DIKEYBOARD_NUMPAD1                      0x8100044F
#define DIKEYBOARD_NUMPAD2                      0x81000450
#define DIKEYBOARD_NUMPAD3                      0x81000451
#define DIKEYBOARD_NUMPAD0                      0x81000452
#define DIKEYBOARD_DECIMAL                      0x81000453    /* . on numeric keypad */
#define DIKEYBOARD_OEM_102                      0x81000456    /* < > | on UK/Germany keyboards */
#define DIKEYBOARD_F11                          0x81000457
#define DIKEYBOARD_F12                          0x81000458
#define DIKEYBOARD_F13                          0x81000464    /*                     (NEC PC98) */
#define DIKEYBOARD_F14                          0x81000465    /*                     (NEC PC98) */
#define DIKEYBOARD_F15                          0x81000466    /*                     (NEC PC98) */
#define DIKEYBOARD_KANA                         0x81000470    /* (Japanese keyboard)            */
#define DIKEYBOARD_ABNT_C1                      0x81000473    /* / ? on Portugese (Brazilian) keyboards */
#define DIKEYBOARD_CONVERT                      0x81000479    /* (Japanese keyboard)            */
#define DIKEYBOARD_NOCONVERT                    0x8100047B    /* (Japanese keyboard)            */
#define DIKEYBOARD_YEN                          0x8100047D    /* (Japanese keyboard)            */
#define DIKEYBOARD_ABNT_C2                      0x8100047E    /* Numpad . on Portugese (Brazilian) keyboards */
#define DIKEYBOARD_NUMPADEQUALS                 0x8100048D    /* = on numeric keypad (NEC PC98) */
#define DIKEYBOARD_PREVTRACK                    0x81000490    /* Previous Track (DIK_CIRCUMFLEX on Japanese keyboard) */
#define DIKEYBOARD_AT                           0x81000491    /*                     (NEC PC98) */
#define DIKEYBOARD_COLON                        0x81000492    /*                     (NEC PC98) */
#define DIKEYBOARD_UNDERLINE                    0x81000493    /*                     (NEC PC98) */
#define DIKEYBOARD_KANJI                        0x81000494    /* (Japanese keyboard)            */
#define DIKEYBOARD_STOP                         0x81000495    /*                     (NEC PC98) */
#define DIKEYBOARD_AX                           0x81000496    /*                     (Japan AX) */
#define DIKEYBOARD_UNLABELED                    0x81000497    /*                        (J3100) */
#define DIKEYBOARD_NEXTTRACK                    0x81000499    /* Next Track */
#define DIKEYBOARD_NUMPADENTER                  0x8100049C    /* Enter on numeric keypad */
#define DIKEYBOARD_RCONTROL                     0x8100049D
#define DIKEYBOARD_MUTE                         0x810004A0    /* Mute */
#define DIKEYBOARD_CALCULATOR                   0x810004A1    /* Calculator */
#define DIKEYBOARD_PLAYPAUSE                    0x810004A2    /* Play / Pause */
#define DIKEYBOARD_MEDIASTOP                    0x810004A4    /* Media Stop */
#define DIKEYBOARD_VOLUMEDOWN                   0x810004AE    /* Volume - */
#define DIKEYBOARD_VOLUMEUP                     0x810004B0    /* Volume + */
#define DIKEYBOARD_WEBHOME                      0x810004B2    /* Web home */
#define DIKEYBOARD_NUMPADCOMMA                  0x810004B3    /* , on numeric keypad (NEC PC98) */
#define DIKEYBOARD_DIVIDE                       0x810004B5    /* / on numeric keypad */
#define DIKEYBOARD_SYSRQ                        0x810004B7
#define DIKEYBOARD_RMENU                        0x810004B8    /* right Alt */
#define DIKEYBOARD_PAUSE                        0x810004C5    /* Pause */
#define DIKEYBOARD_HOME                         0x810004C7    /* Home on arrow keypad */
#define DIKEYBOARD_UP                           0x810004C8    /* UpArrow on arrow keypad */
#define DIKEYBOARD_PRIOR                        0x810004C9    /* PgUp on arrow keypad */
#define DIKEYBOARD_LEFT                         0x810004CB    /* LeftArrow on arrow keypad */
#define DIKEYBOARD_RIGHT                        0x810004CD    /* RightArrow on arrow keypad */
#define DIKEYBOARD_END                          0x810004CF    /* End on arrow keypad */
#define DIKEYBOARD_DOWN                         0x810004D0    /* DownArrow on arrow keypad */
#define DIKEYBOARD_NEXT                         0x810004D1    /* PgDn on arrow keypad */
#define DIKEYBOARD_INSERT                       0x810004D2    /* Insert on arrow keypad */
#define DIKEYBOARD_DELETE                       0x810004D3    /* Delete on arrow keypad */
#define DIKEYBOARD_LWIN                         0x810004DB    /* Left Windows key */
#define DIKEYBOARD_RWIN                         0x810004DC    /* Right Windows key */
#define DIKEYBOARD_APPS                         0x810004DD    /* AppMenu key */
#define DIKEYBOARD_POWER                        0x810004DE    /* System Power */
#define DIKEYBOARD_SLEEP                        0x810004DF    /* System Sleep */
#define DIKEYBOARD_WAKE                         0x810004E3    /* System Wake */
#define DIKEYBOARD_WEBSEARCH                    0x810004E5    /* Web Search */
#define DIKEYBOARD_WEBFAVORITES                 0x810004E6    /* Web Favorites */
#define DIKEYBOARD_WEBREFRESH                   0x810004E7    /* Web Refresh */
#define DIKEYBOARD_WEBSTOP                      0x810004E8    /* Web Stop */
#define DIKEYBOARD_WEBFORWARD                   0x810004E9    /* Web Forward */
#define DIKEYBOARD_WEBBACK                      0x810004EA    /* Web Back */
#define DIKEYBOARD_MYCOMPUTER                   0x810004EB    /* My Computer */
#define DIKEYBOARD_MAIL                         0x810004EC    /* Mail */
#define DIKEYBOARD_MEDIASELECT                  0x810004ED    /* Media Select */
  

/*--- MOUSE
      Physical Mouse Device             ---*/

#define DIMOUSE_XAXISAB                         (0x82000200 |DIMOFS_X ) /* X Axis-absolute: Some mice natively report absolute coordinates  */ 
#define DIMOUSE_YAXISAB                         (0x82000200 |DIMOFS_Y ) /* Y Axis-absolute: Some mice natively report absolute coordinates */
#define DIMOUSE_XAXIS                           (0x82000300 |DIMOFS_X ) /* X Axis */
#define DIMOUSE_YAXIS                           (0x82000300 |DIMOFS_Y ) /* Y Axis */
#define DIMOUSE_WHEEL                           (0x82000300 |DIMOFS_Z ) /* Z Axis */
#define DIMOUSE_BUTTON0                         (0x82000400 |DIMOFS_BUTTON0) /* Button 0 */
#define DIMOUSE_BUTTON1                         (0x82000400 |DIMOFS_BUTTON1) /* Button 1 */
#define DIMOUSE_BUTTON2                         (0x82000400 |DIMOFS_BUTTON2) /* Button 2 */
#define DIMOUSE_BUTTON3                         (0x82000400 |DIMOFS_BUTTON3) /* Button 3 */
#define DIMOUSE_BUTTON4                         (0x82000400 |DIMOFS_BUTTON4) /* Button 4 */
#define DIMOUSE_BUTTON5                         (0x82000400 |DIMOFS_BUTTON5) /* Button 5 */
#define DIMOUSE_BUTTON6                         (0x82000400 |DIMOFS_BUTTON6) /* Button 6 */
#define DIMOUSE_BUTTON7                         (0x82000400 |DIMOFS_BUTTON7) /* Button 7 */


/*--- VOICE
      Physical Dplay Voice Device       ---*/

#define DIVOICE_CHANNEL1                        0x83000401
#define DIVOICE_CHANNEL2                        0x83000402
#define DIVOICE_CHANNEL3                        0x83000403
#define DIVOICE_CHANNEL4                        0x83000404
#define DIVOICE_CHANNEL5                        0x83000405
#define DIVOICE_CHANNEL6                        0x83000406
#define DIVOICE_CHANNEL7                        0x83000407
#define DIVOICE_CHANNEL8                        0x83000408
#define DIVOICE_TEAM                            0x83000409
#define DIVOICE_ALL                             0x8300040A
#define DIVOICE_RECORDMUTE                      0x8300040B
#define DIVOICE_PLAYBACKMUTE                    0x8300040C
#define DIVOICE_TRANSMIT                        0x8300040D

#define DIVOICE_VOICECOMMAND                    0x83000410


/*--- Driving Simulator - Racing
      Vehicle control is primary objective  ---*/
#define DIVIRTUAL_DRIVING_RACE                  0x01000000
#define DIAXIS_DRIVINGR_STEER                   0x01008A01 /* Steering */
#define DIAXIS_DRIVINGR_ACCELERATE              0x01039202 /* Accelerate */
#define DIAXIS_DRIVINGR_BRAKE                   0x01041203 /* Brake-Axis */
#define DIBUTTON_DRIVINGR_SHIFTUP               0x01000C01 /* Shift to next higher gear */
#define DIBUTTON_DRIVINGR_SHIFTDOWN             0x01000C02 /* Shift to next lower gear */
#define DIBUTTON_DRIVINGR_VIEW                  0x01001C03 /* Cycle through view options */
#define DIBUTTON_DRIVINGR_MENU                  0x010004FD /* Show menu options */
/*--- Priority 2 controls                            ---*/

#define DIAXIS_DRIVINGR_ACCEL_AND_BRAKE         0x01014A04 /* Some devices combine accelerate and brake in a single axis */
#define DIHATSWITCH_DRIVINGR_GLANCE             0x01004601 /* Look around */
#define DIBUTTON_DRIVINGR_BRAKE                 0x01004C04 /* Brake-button */
#define DIBUTTON_DRIVINGR_DASHBOARD             0x01004405 /* Select next dashboard option */
#define DIBUTTON_DRIVINGR_AIDS                  0x01004406 /* Driver correction aids */
#define DIBUTTON_DRIVINGR_MAP                   0x01004407 /* Display Driving Map */
#define DIBUTTON_DRIVINGR_BOOST                 0x01004408 /* Turbo Boost */
#define DIBUTTON_DRIVINGR_PIT                   0x01004409 /* Pit stop notification */
#define DIBUTTON_DRIVINGR_ACCELERATE_LINK       0x0103D4E0 /* Fallback Accelerate button */
#define DIBUTTON_DRIVINGR_STEER_LEFT_LINK       0x0100CCE4 /* Fallback Steer Left button */
#define DIBUTTON_DRIVINGR_STEER_RIGHT_LINK      0x0100CCEC /* Fallback Steer Right button */
#define DIBUTTON_DRIVINGR_GLANCE_LEFT_LINK      0x0107C4E4 /* Fallback Glance Left button */
#define DIBUTTON_DRIVINGR_GLANCE_RIGHT_LINK     0x0107C4EC /* Fallback Glance Right button */
#define DIBUTTON_DRIVINGR_DEVICE                0x010044FE /* Show input device and controls */
#define DIBUTTON_DRIVINGR_PAUSE                 0x010044FC /* Start / Pause / Restart game */

/*--- Driving Simulator - Combat
      Combat from within a vehicle is primary objective  ---*/
#define DIVIRTUAL_DRIVING_COMBAT                0x02000000
#define DIAXIS_DRIVINGC_STEER                   0x02008A01 /* Steering  */
#define DIAXIS_DRIVINGC_ACCELERATE              0x02039202 /* Accelerate */
#define DIAXIS_DRIVINGC_BRAKE                   0x02041203 /* Brake-axis */
#define DIBUTTON_DRIVINGC_FIRE                  0x02000C01 /* Fire */
#define DIBUTTON_DRIVINGC_WEAPONS               0x02000C02 /* Select next weapon */
#define DIBUTTON_DRIVINGC_TARGET                0x02000C03 /* Select next available target */
#define DIBUTTON_DRIVINGC_MENU                  0x020004FD /* Show menu options */
/*--- Priority 2 controls                            ---*/

#define DIAXIS_DRIVINGC_ACCEL_AND_BRAKE         0x02014A04 /* Some devices combine accelerate and brake in a single axis */
#define DIHATSWITCH_DRIVINGC_GLANCE             0x02004601 /* Look around */
#define DIBUTTON_DRIVINGC_SHIFTUP               0x02004C04 /* Shift to next higher gear */
#define DIBUTTON_DRIVINGC_SHIFTDOWN             0x02004C05 /* Shift to next lower gear */
#define DIBUTTON_DRIVINGC_DASHBOARD             0x02004406 /* Select next dashboard option */
#define DIBUTTON_DRIVINGC_AIDS                  0x02004407 /* Driver correction aids */
#define DIBUTTON_DRIVINGC_BRAKE                 0x02004C08 /* Brake-button */
#define DIBUTTON_DRIVINGC_FIRESECONDARY         0x02004C09 /* Alternative fire button */
#define DIBUTTON_DRIVINGC_ACCELERATE_LINK       0x0203D4E0 /* Fallback Accelerate button */
#define DIBUTTON_DRIVINGC_STEER_LEFT_LINK       0x0200CCE4 /* Fallback Steer Left button */
#define DIBUTTON_DRIVINGC_STEER_RIGHT_LINK      0x0200CCEC /* Fallback Steer Right button */
#define DIBUTTON_DRIVINGC_GLANCE_LEFT_LINK      0x0207C4E4 /* Fallback Glance Left button */
#define DIBUTTON_DRIVINGC_GLANCE_RIGHT_LINK     0x0207C4EC /* Fallback Glance Right button */
#define DIBUTTON_DRIVINGC_DEVICE                0x020044FE /* Show input device and controls */
#define DIBUTTON_DRIVINGC_PAUSE                 0x020044FC /* Start / Pause / Restart game */

/*--- Driving Simulator - Tank
      Combat from withing a tank is primary objective  ---*/
#define DIVIRTUAL_DRIVING_TANK                  0x03000000
#define DIAXIS_DRIVINGT_STEER                   0x03008A01 /* Turn tank left / right */
#define DIAXIS_DRIVINGT_BARREL                  0x03010202 /* Raise / lower barrel */
#define DIAXIS_DRIVINGT_ACCELERATE              0x03039203 /* Accelerate */
#define DIAXIS_DRIVINGT_ROTATE                  0x03020204 /* Turn barrel left / right */
#define DIBUTTON_DRIVINGT_FIRE                  0x03000C01 /* Fire */
#define DIBUTTON_DRIVINGT_WEAPONS               0x03000C02 /* Select next weapon */
#define DIBUTTON_DRIVINGT_TARGET                0x03000C03 /* Selects next available target */
#define DIBUTTON_DRIVINGT_MENU                  0x030004FD /* Show menu options */
/*--- Priority 2 controls                            ---*/

#define DIHATSWITCH_DRIVINGT_GLANCE             0x03004601 /* Look around */
#define DIAXIS_DRIVINGT_BRAKE                   0x03045205 /* Brake-axis */
#define DIAXIS_DRIVINGT_ACCEL_AND_BRAKE         0x03014A06 /* Some devices combine accelerate and brake in a single axis */
#define DIBUTTON_DRIVINGT_VIEW                  0x03005C04 /* Cycle through view options */
#define DIBUTTON_DRIVINGT_DASHBOARD             0x03005C05 /* Select next dashboard option */
#define DIBUTTON_DRIVINGT_BRAKE                 0x03004C06 /* Brake-button */
#define DIBUTTON_DRIVINGT_FIRESECONDARY         0x03004C07 /* Alternative fire button */
#define DIBUTTON_DRIVINGT_ACCELERATE_LINK       0x0303D4E0 /* Fallback Accelerate button */
#define DIBUTTON_DRIVINGT_STEER_LEFT_LINK       0x0300CCE4 /* Fallback Steer Left button */
#define DIBUTTON_DRIVINGT_STEER_RIGHT_LINK      0x0300CCEC /* Fallback Steer Right button */
#define DIBUTTON_DRIVINGT_BARREL_UP_LINK        0x030144E0 /* Fallback Barrel up button */
#define DIBUTTON_DRIVINGT_BARREL_DOWN_LINK      0x030144E8 /* Fallback Barrel down button */
#define DIBUTTON_DRIVINGT_ROTATE_LEFT_LINK      0x030244E4 /* Fallback Rotate left button */
#define DIBUTTON_DRIVINGT_ROTATE_RIGHT_LINK     0x030244EC /* Fallback Rotate right button */
#define DIBUTTON_DRIVINGT_GLANCE_LEFT_LINK      0x0307C4E4 /* Fallback Glance Left button */
#define DIBUTTON_DRIVINGT_GLANCE_RIGHT_LINK     0x0307C4EC /* Fallback Glance Right button */
#define DIBUTTON_DRIVINGT_DEVICE                0x030044FE /* Show input device and controls */
#define DIBUTTON_DRIVINGT_PAUSE                 0x030044FC /* Start / Pause / Restart game */

/*--- Flight Simulator - Civilian 
      Plane control is the primary objective  ---*/
#define DIVIRTUAL_FLYING_CIVILIAN               0x04000000
#define DIAXIS_FLYINGC_BANK                     0x04008A01 /* Roll ship left / right */
#define DIAXIS_FLYINGC_PITCH                    0x04010A02 /* Nose up / down */
#define DIAXIS_FLYINGC_THROTTLE                 0x04039203 /* Throttle */
#define DIBUTTON_FLYINGC_VIEW                   0x04002401 /* Cycle through view options */
#define DIBUTTON_FLYINGC_DISPLAY                0x04002402 /* Select next dashboard / heads up display option */
#define DIBUTTON_FLYINGC_GEAR                   0x04002C03 /* Gear up / down */
#define DIBUTTON_FLYINGC_MENU                   0x040004FD /* Show menu options */
/*--- Priority 2 controls                            ---*/

#define DIHATSWITCH_FLYINGC_GLANCE              0x04004601 /* Look around */
#define DIAXIS_FLYINGC_BRAKE                    0x04046A04 /* Apply Brake */
#define DIAXIS_FLYINGC_RUDDER                   0x04025205 /* Yaw ship left/right */
#define DIAXIS_FLYINGC_FLAPS                    0x04055A06 /* Flaps */
#define DIBUTTON_FLYINGC_FLAPSUP                0x04006404 /* Increment stepping up until fully retracted */
#define DIBUTTON_FLYINGC_FLAPSDOWN              0x04006405 /* Decrement stepping down until fully extended */
#define DIBUTTON_FLYINGC_BRAKE_LINK             0x04046CE0 /* Fallback brake button */
#define DIBUTTON_FLYINGC_FASTER_LINK            0x0403D4E0 /* Fallback throttle up button */
#define DIBUTTON_FLYINGC_SLOWER_LINK            0x0403D4E8 /* Fallback throttle down button */
#define DIBUTTON_FLYINGC_GLANCE_LEFT_LINK       0x0407C4E4 /* Fallback Glance Left button */
#define DIBUTTON_FLYINGC_GLANCE_RIGHT_LINK      0x0407C4EC /* Fallback Glance Right button */
#define DIBUTTON_FLYINGC_GLANCE_UP_LINK         0x0407C4E0 /* Fallback Glance Up button */
#define DIBUTTON_FLYINGC_GLANCE_DOWN_LINK       0x0407C4E8 /* Fallback Glance Down button */
#define DIBUTTON_FLYINGC_DEVICE                 0x040044FE /* Show input device and controls */
#define DIBUTTON_FLYINGC_PAUSE                  0x040044FC /* Start / Pause / Restart game */

/*--- Flight Simulator - Military 
      Aerial combat is the primary objective  ---*/
#define DIVIRTUAL_FLYING_MILITARY               0x05000000
#define DIAXIS_FLYINGM_BANK                     0x05008A01 /* Bank - Roll ship left / right */
#define DIAXIS_FLYINGM_PITCH                    0x05010A02 /* Pitch - Nose up / down */
#define DIAXIS_FLYINGM_THROTTLE                 0x05039203 /* Throttle - faster / slower */
#define DIBUTTON_FLYINGM_FIRE                   0x05000C01 /* Fire */
#define DIBUTTON_FLYINGM_WEAPONS                0x05000C02 /* Select next weapon */
#define DIBUTTON_FLYINGM_TARGET                 0x05000C03 /* Selects next available target */
#define DIBUTTON_FLYINGM_MENU                   0x050004FD /* Show menu options */
/*--- Priority 2 controls                            ---*/

#define DIHATSWITCH_FLYINGM_GLANCE              0x05004601 /* Look around */
#define DIBUTTON_FLYINGM_COUNTER                0x05005C04 /* Activate counter measures */
#define DIAXIS_FLYINGM_RUDDER                   0x05024A04 /* Rudder - Yaw ship left/right */
#define DIAXIS_FLYINGM_BRAKE                    0x05046205 /* Brake-axis */
#define DIBUTTON_FLYINGM_VIEW                   0x05006405 /* Cycle through view options */
#define DIBUTTON_FLYINGM_DISPLAY                0x05006406 /* Select next dashboard option */
#define DIAXIS_FLYINGM_FLAPS                    0x05055206 /* Flaps */
#define DIBUTTON_FLYINGM_FLAPSUP                0x05005407 /* Increment stepping up until fully retracted */
#define DIBUTTON_FLYINGM_FLAPSDOWN              0x05005408 /* Decrement stepping down until fully extended */
#define DIBUTTON_FLYINGM_FIRESECONDARY          0x05004C09 /* Alternative fire button */
#define DIBUTTON_FLYINGM_GEAR                   0x0500640A /* Gear up / down */
#define DIBUTTON_FLYINGM_BRAKE_LINK             0x050464E0 /* Fallback brake button */
#define DIBUTTON_FLYINGM_FASTER_LINK            0x0503D4E0 /* Fallback throttle up button */
#define DIBUTTON_FLYINGM_SLOWER_LINK            0x0503D4E8 /* Fallback throttle down button */
#define DIBUTTON_FLYINGM_GLANCE_LEFT_LINK       0x0507C4E4 /* Fallback Glance Left button */
#define DIBUTTON_FLYINGM_GLANCE_RIGHT_LINK      0x0507C4EC /* Fallback Glance Right button */
#define DIBUTTON_FLYINGM_GLANCE_UP_LINK         0x0507C4E0 /* Fallback Glance Up button */
#define DIBUTTON_FLYINGM_GLANCE_DOWN_LINK       0x0507C4E8 /* Fallback Glance Down button */
#define DIBUTTON_FLYINGM_DEVICE                 0x050044FE /* Show input device and controls */
#define DIBUTTON_FLYINGM_PAUSE                  0x050044FC /* Start / Pause / Restart game */

/*--- Flight Simulator - Combat Helicopter
      Combat from helicopter is primary objective  ---*/
#define DIVIRTUAL_FLYING_HELICOPTER             0x06000000
#define DIAXIS_FLYINGH_BANK                     0x06008A01 /* Bank - Roll ship left / right */
#define DIAXIS_FLYINGH_PITCH                    0x06010A02 /* Pitch - Nose up / down */
#define DIAXIS_FLYINGH_COLLECTIVE               0x06018A03 /* Collective - Blade pitch/power */
#define DIBUTTON_FLYINGH_FIRE                   0x06001401 /* Fire */
#define DIBUTTON_FLYINGH_WEAPONS                0x06001402 /* Select next weapon */
#define DIBUTTON_FLYINGH_TARGET                 0x06001403 /* Selects next available target */
#define DIBUTTON_FLYINGH_MENU                   0x060004FD /* Show menu options */
/*--- Priority 2 controls                            ---*/

#define DIHATSWITCH_FLYINGH_GLANCE              0x06004601 /* Look around */
#define DIAXIS_FLYINGH_TORQUE                   0x06025A04 /* Torque - Rotate ship around left / right axis */
#define DIAXIS_FLYINGH_THROTTLE                 0x0603DA05 /* Throttle */
#define DIBUTTON_FLYINGH_COUNTER                0x06005404 /* Activate counter measures */
#define DIBUTTON_FLYINGH_VIEW                   0x06006405 /* Cycle through view options */
#define DIBUTTON_FLYINGH_GEAR                   0x06006406 /* Gear up / down */
#define DIBUTTON_FLYINGH_FIRESECONDARY          0x06004C07 /* Alternative fire button */
#define DIBUTTON_FLYINGH_FASTER_LINK            0x0603DCE0 /* Fallback throttle up button */
#define DIBUTTON_FLYINGH_SLOWER_LINK            0x0603DCE8 /* Fallback throttle down button */
#define DIBUTTON_FLYINGH_GLANCE_LEFT_LINK       0x0607C4E4 /* Fallback Glance Left button */
#define DIBUTTON_FLYINGH_GLANCE_RIGHT_LINK      0x0607C4EC /* Fallback Glance Right button */
#define DIBUTTON_FLYINGH_GLANCE_UP_LINK         0x0607C4E0 /* Fallback Glance Up button */
#define DIBUTTON_FLYINGH_GLANCE_DOWN_LINK       0x0607C4E8 /* Fallback Glance Down button */
#define DIBUTTON_FLYINGH_DEVICE                 0x060044FE /* Show input device and controls */
#define DIBUTTON_FLYINGH_PAUSE                  0x060044FC /* Start / Pause / Restart game */

/*--- Space Simulator - Combat
      Space Simulator with weapons  ---*/
#define DIVIRTUAL_SPACESIM                      0x07000000
#define DIAXIS_SPACESIM_LATERAL                 0x07008201 /* Move ship left / right */
#define DIAXIS_SPACESIM_MOVE                    0x07010202 /* Move ship forward/backward */
#define DIAXIS_SPACESIM_THROTTLE                0x07038203 /* Throttle - Engine speed */
#define DIBUTTON_SPACESIM_FIRE                  0x07000401 /* Fire */
#define DIBUTTON_SPACESIM_WEAPONS               0x07000402 /* Select next weapon */
#define DIBUTTON_SPACESIM_TARGET                0x07000403 /* Selects next available target */
#define DIBUTTON_SPACESIM_MENU                  0x070004FD /* Show menu options */
/*--- Priority 2 controls                            ---*/

#define DIHATSWITCH_SPACESIM_GLANCE             0x07004601 /* Look around */
#define DIAXIS_SPACESIM_CLIMB                   0x0701C204 /* Climb - Pitch ship up/down */
#define DIAXIS_SPACESIM_ROTATE                  0x07024205 /* Rotate - Turn ship left/right */
#define DIBUTTON_SPACESIM_VIEW                  0x07004404 /* Cycle through view options */
#define DIBUTTON_SPACESIM_DISPLAY               0x07004405 /* Select next dashboard / heads up display option */
#define DIBUTTON_SPACESIM_RAISE                 0x07004406 /* Raise ship while maintaining current pitch */
#define DIBUTTON_SPACESIM_LOWER                 0x07004407 /* Lower ship while maintaining current pitch */
#define DIBUTTON_SPACESIM_GEAR                  0x07004408 /* Gear up / down */
#define DIBUTTON_SPACESIM_FIRESECONDARY         0x07004409 /* Alternative fire button */
#define DIBUTTON_SPACESIM_LEFT_LINK             0x0700C4E4 /* Fallback move left button */
#define DIBUTTON_SPACESIM_RIGHT_LINK            0x0700C4EC /* Fallback move right button */
#define DIBUTTON_SPACESIM_FORWARD_LINK          0x070144E0 /* Fallback move forward button */
#define DIBUTTON_SPACESIM_BACKWARD_LINK         0x070144E8 /* Fallback move backwards button */
#define DIBUTTON_SPACESIM_FASTER_LINK           0x0703C4E0 /* Fallback throttle up button */
#define DIBUTTON_SPACESIM_SLOWER_LINK           0x0703C4E8 /* Fallback throttle down button */
#define DIBUTTON_SPACESIM_TURN_LEFT_LINK        0x070244E4 /* Fallback turn left button */
#define DIBUTTON_SPACESIM_TURN_RIGHT_LINK       0x070244EC /* Fallback turn right button */
#define DIBUTTON_SPACESIM_GLANCE_LEFT_LINK      0x0707C4E4 /* Fallback Glance Left button */
#define DIBUTTON_SPACESIM_GLANCE_RIGHT_LINK     0x0707C4EC /* Fallback Glance Right button */
#define DIBUTTON_SPACESIM_GLANCE_UP_LINK        0x0707C4E0 /* Fallback Glance Up button */
#define DIBUTTON_SPACESIM_GLANCE_DOWN_LINK      0x0707C4E8 /* Fallback Glance Down button */
#define DIBUTTON_SPACESIM_DEVICE                0x070044FE /* Show input device and controls */
#define DIBUTTON_SPACESIM_PAUSE                 0x070044FC /* Start / Pause / Restart game */

/*--- Fighting - First Person 
      Hand to Hand combat is primary objective  ---*/
#define DIVIRTUAL_FIGHTING_HAND2HAND            0x08000000
#define DIAXIS_FIGHTINGH_LATERAL                0x08008201 /* Sidestep left/right */
#define DIAXIS_FIGHTINGH_MOVE                   0x08010202 /* Move forward/backward */
#define DIBUTTON_FIGHTINGH_PUNCH                0x08000401 /* Punch */
#define DIBUTTON_FIGHTINGH_KICK                 0x08000402 /* Kick */
#define DIBUTTON_FIGHTINGH_BLOCK                0x08000403 /* Block */
#define DIBUTTON_FIGHTINGH_CROUCH               0x08000404 /* Crouch */
#define DIBUTTON_FIGHTINGH_JUMP                 0x08000405 /* Jump */
#define DIBUTTON_FIGHTINGH_SPECIAL1             0x08000406 /* Apply first special move */
#define DIBUTTON_FIGHTINGH_SPECIAL2             0x08000407 /* Apply second special move */
#define DIBUTTON_FIGHTINGH_MENU                 0x080004FD /* Show menu options */
/*--- Priority 2 controls                            ---*/

#define DIBUTTON_FIGHTINGH_SELECT               0x08004408 /* Select special move */
#define DIHATSWITCH_FIGHTINGH_SLIDE             0x08004601 /* Look around */
#define DIBUTTON_FIGHTINGH_DISPLAY              0x08004409 /* Shows next on-screen display option */
#define DIAXIS_FIGHTINGH_ROTATE                 0x08024203 /* Rotate - Turn body left/right */
#define DIBUTTON_FIGHTINGH_DODGE                0x0800440A /* Dodge */
#define DIBUTTON_FIGHTINGH_LEFT_LINK            0x0800C4E4 /* Fallback left sidestep button */
#define DIBUTTON_FIGHTINGH_RIGHT_LINK           0x0800C4EC /* Fallback right sidestep button */
#define DIBUTTON_FIGHTINGH_FORWARD_LINK         0x080144E0 /* Fallback forward button */
#define DIBUTTON_FIGHTINGH_BACKWARD_LINK        0x080144E8 /* Fallback backward button */
#define DIBUTTON_FIGHTINGH_DEVICE               0x080044FE /* Show input device and controls */
#define DIBUTTON_FIGHTINGH_PAUSE                0x080044FC /* Start / Pause / Restart game */

/*--- Fighting - First Person Shooting
      Navigation and combat are primary objectives  ---*/
#define DIVIRTUAL_FIGHTING_FPS                  0x09000000
#define DIAXIS_FPS_ROTATE                       0x09008201 /* Rotate character left/right */
#define DIAXIS_FPS_MOVE                         0x09010202 /* Move forward/backward */
#define DIBUTTON_FPS_FIRE                       0x09000401 /* Fire */
#define DIBUTTON_FPS_WEAPONS                    0x09000402 /* Select next weapon */
#define DIBUTTON_FPS_APPLY                      0x09000403 /* Use item */
#define DIBUTTON_FPS_SELECT                     0x09000404 /* Select next inventory item */
#define DIBUTTON_FPS_CROUCH                     0x09000405 /* Crouch/ climb down/ swim down */
#define DIBUTTON_FPS_JUMP                       0x09000406 /* Jump/ climb up/ swim up */
#define DIAXIS_FPS_LOOKUPDOWN                   0x09018203 /* Look up / down  */
#define DIBUTTON_FPS_STRAFE                     0x09000407 /* Enable strafing while active */
#define DIBUTTON_FPS_MENU                       0x090004FD /* Show menu options */
/*--- Priority 2 controls                            ---*/

#define DIHATSWITCH_FPS_GLANCE                  0x09004601 /* Look around */
#define DIBUTTON_FPS_DISPLAY                    0x09004408 /* Shows next on-screen display option/ map */
#define DIAXIS_FPS_SIDESTEP                     0x09024204 /* Sidestep */
#define DIBUTTON_FPS_DODGE                      0x09004409 /* Dodge */
#define DIBUTTON_FPS_GLANCEL                    0x0900440A /* Glance Left */
#define DIBUTTON_FPS_GLANCER                    0x0900440B /* Glance Right */
#define DIBUTTON_FPS_FIRESECONDARY              0x0900440C /* Alternative fire button */
#define DIBUTTON_FPS_ROTATE_LEFT_LINK           0x0900C4E4 /* Fallback rotate left button */
#define DIBUTTON_FPS_ROTATE_RIGHT_LINK          0x0900C4EC /* Fallback rotate right button */
#define DIBUTTON_FPS_FORWARD_LINK               0x090144E0 /* Fallback forward button */
#define DIBUTTON_FPS_BACKWARD_LINK              0x090144E8 /* Fallback backward button */
#define DIBUTTON_FPS_GLANCE_UP_LINK             0x0901C4E0 /* Fallback look up button */
#define DIBUTTON_FPS_GLANCE_DOWN_LINK           0x0901C4E8 /* Fallback look down button */
#define DIBUTTON_FPS_DEVICE                     0x090044FE /* Show input device and controls */
#define DIBUTTON_FPS_PAUSE                      0x090044FC /* Start / Pause / Restart game */

/*--- Fighting - Third Person action
      Perspective of camera is behind the main character  ---*/
#define DIVIRTUAL_FIGHTING_THIRDPERSON          0x0A000000
#define DIAXIS_TPS_TURN                         0x0A020201 /* Turn left/right */
#define DIAXIS_TPS_MOVE                         0x0A010202 /* Move forward/backward */
#define DIBUTTON_TPS_RUN                        0x0A000401 /* Run or walk toggle switch */
#define DIBUTTON_TPS_ACTION                     0x0A000402 /* Action Button */
#define DIBUTTON_TPS_SELECT                     0x0A000403 /* Select next weapon */
#define DIBUTTON_TPS_USE                        0x0A000404 /* Use inventory item currently selected */
#define DIBUTTON_TPS_JUMP                       0x0A000405 /* Character Jumps */
#define DIBUTTON_TPS_MENU                       0x0A0004FD /* Show menu options */
/*--- Priority 2 controls                            ---*/

#define DIHATSWITCH_TPS_GLANCE                  0x0A004601 /* Look around */
#define DIBUTTON_TPS_VIEW                       0x0A004406 /* Select camera view */
#define DIBUTTON_TPS_STEPLEFT                   0x0A004407 /* Character takes a left step */
#define DIBUTTON_TPS_STEPRIGHT                  0x0A004408 /* Character takes a right step */
#define DIAXIS_TPS_STEP                         0x0A00C203 /* Character steps left/right */
#define DIBUTTON_TPS_DODGE                      0x0A004409 /* Character dodges or ducks */
#define DIBUTTON_TPS_INVENTORY                  0x0A00440A /* Cycle through inventory */
#define DIBUTTON_TPS_TURN_LEFT_LINK             0x0A0244E4 /* Fallback turn left button */
#define DIBUTTON_TPS_TURN_RIGHT_LINK            0x0A0244EC /* Fallback turn right button */
#define DIBUTTON_TPS_FORWARD_LINK               0x0A0144E0 /* Fallback forward button */
#define DIBUTTON_TPS_BACKWARD_LINK              0x0A0144E8 /* Fallback backward button */
#define DIBUTTON_TPS_GLANCE_UP_LINK             0x0A07C4E0 /* Fallback look up button */
#define DIBUTTON_TPS_GLANCE_DOWN_LINK           0x0A07C4E8 /* Fallback look down button */
#define DIBUTTON_TPS_GLANCE_LEFT_LINK           0x0A07C4E4 /* Fallback glance up button */
#define DIBUTTON_TPS_GLANCE_RIGHT_LINK          0x0A07C4EC /* Fallback glance right button */
#define DIBUTTON_TPS_DEVICE                     0x0A0044FE /* Show input device and controls */
#define DIBUTTON_TPS_PAUSE                      0x0A0044FC /* Start / Pause / Restart game */

/*--- Strategy - Role Playing
      Navigation and problem solving are primary actions  ---*/
#define DIVIRTUAL_STRATEGY_ROLEPLAYING          0x0B000000
#define DIAXIS_STRATEGYR_LATERAL                0x0B008201 /* sidestep - left/right */
#define DIAXIS_STRATEGYR_MOVE                   0x0B010202 /* move forward/backward */
#define DIBUTTON_STRATEGYR_GET                  0x0B000401 /* Acquire item */
#define DIBUTTON_STRATEGYR_APPLY                0x0B000402 /* Use selected item */
#define DIBUTTON_STRATEGYR_SELECT               0x0B000403 /* Select nextitem */
#define DIBUTTON_STRATEGYR_ATTACK               0x0B000404 /* Attack */
#define DIBUTTON_STRATEGYR_CAST                 0x0B000405 /* Cast Spell */
#define DIBUTTON_STRATEGYR_CROUCH               0x0B000406 /* Crouch */
#define DIBUTTON_STRATEGYR_JUMP                 0x0B000407 /* Jump */
#define DIBUTTON_STRATEGYR_MENU                 0x0B0004FD /* Show menu options */
/*--- Priority 2 controls                            ---*/

#define DIHATSWITCH_STRATEGYR_GLANCE            0x0B004601 /* Look around */
#define DIBUTTON_STRATEGYR_MAP                  0x0B004408 /* Cycle through map options */
#define DIBUTTON_STRATEGYR_DISPLAY              0x0B004409 /* Shows next on-screen display option */
#define DIAXIS_STRATEGYR_ROTATE                 0x0B024203 /* Turn body left/right */
#define DIBUTTON_STRATEGYR_LEFT_LINK            0x0B00C4E4 /* Fallback sidestep left button */
#define DIBUTTON_STRATEGYR_RIGHT_LINK           0x0B00C4EC /* Fallback sidestep right button */
#define DIBUTTON_STRATEGYR_FORWARD_LINK         0x0B0144E0 /* Fallback move forward button */
#define DIBUTTON_STRATEGYR_BACK_LINK            0x0B0144E8 /* Fallback move backward button */
#define DIBUTTON_STRATEGYR_ROTATE_LEFT_LINK     0x0B0244E4 /* Fallback turn body left button */
#define DIBUTTON_STRATEGYR_ROTATE_RIGHT_LINK    0x0B0244EC /* Fallback turn body right button */
#define DIBUTTON_STRATEGYR_DEVICE               0x0B0044FE /* Show input device and controls */
#define DIBUTTON_STRATEGYR_PAUSE                0x0B0044FC /* Start / Pause / Restart game */

/*--- Strategy - Turn based
      Navigation and problem solving are primary actions  ---*/
#define DIVIRTUAL_STRATEGY_TURN                 0x0C000000
#define DIAXIS_STRATEGYT_LATERAL                0x0C008201 /* Sidestep left/right */
#define DIAXIS_STRATEGYT_MOVE                   0x0C010202 /* Move forward/backwards */
#define DIBUTTON_STRATEGYT_SELECT               0x0C000401 /* Select unit or object */
#define DIBUTTON_STRATEGYT_INSTRUCT             0x0C000402 /* Cycle through instructions */
#define DIBUTTON_STRATEGYT_APPLY                0x0C000403 /* Apply selected instruction */
#define DIBUTTON_STRATEGYT_TEAM                 0x0C000404 /* Select next team / cycle through all */
#define DIBUTTON_STRATEGYT_TURN                 0x0C000405 /* Indicate turn over */
#define DIBUTTON_STRATEGYT_MENU                 0x0C0004FD /* Show menu options */
/*--- Priority 2 controls                            ---*/

#define DIBUTTON_STRATEGYT_ZOOM                 0x0C004406 /* Zoom - in / out */
#define DIBUTTON_STRATEGYT_MAP                  0x0C004407 /* cycle through map options */
#define DIBUTTON_STRATEGYT_DISPLAY              0x0C004408 /* shows next on-screen display options */
#define DIBUTTON_STRATEGYT_LEFT_LINK            0x0C00C4E4 /* Fallback sidestep left button */
#define DIBUTTON_STRATEGYT_RIGHT_LINK           0x0C00C4EC /* Fallback sidestep right button */
#define DIBUTTON_STRATEGYT_FORWARD_LINK         0x0C0144E0 /* Fallback move forward button */
#define DIBUTTON_STRATEGYT_BACK_LINK            0x0C0144E8 /* Fallback move back button */
#define DIBUTTON_STRATEGYT_DEVICE               0x0C0044FE /* Show input device and controls */
#define DIBUTTON_STRATEGYT_PAUSE                0x0C0044FC /* Start / Pause / Restart game */

/*--- Sports - Hunting
      Hunting                ---*/
#define DIVIRTUAL_SPORTS_HUNTING                0x0D000000
#define DIAXIS_HUNTING_LATERAL                  0x0D008201 /* sidestep left/right */
#define DIAXIS_HUNTING_MOVE                     0x0D010202 /* move forward/backwards */
#define DIBUTTON_HUNTING_FIRE                   0x0D000401 /* Fire selected weapon */
#define DIBUTTON_HUNTING_AIM                    0x0D000402 /* Select aim/move */
#define DIBUTTON_HUNTING_WEAPON                 0x0D000403 /* Select next weapon */
#define DIBUTTON_HUNTING_BINOCULAR              0x0D000404 /* Look through Binoculars */
#define DIBUTTON_HUNTING_CALL                   0x0D000405 /* Make animal call */
#define DIBUTTON_HUNTING_MAP                    0x0D000406 /* View Map */
#define DIBUTTON_HUNTING_SPECIAL                0x0D000407 /* Special game operation */
#define DIBUTTON_HUNTING_MENU                   0x0D0004FD /* Show menu options */
/*--- Priority 2 controls                            ---*/

#define DIHATSWITCH_HUNTING_GLANCE              0x0D004601 /* Look around */
#define DIBUTTON_HUNTING_DISPLAY                0x0D004408 /* show next on-screen display option */
#define DIAXIS_HUNTING_ROTATE                   0x0D024203 /* Turn body left/right */
#define DIBUTTON_HUNTING_CROUCH                 0x0D004409 /* Crouch/ Climb / Swim down */
#define DIBUTTON_HUNTING_JUMP                   0x0D00440A /* Jump/ Climb up / Swim up */
#define DIBUTTON_HUNTING_FIRESECONDARY          0x0D00440B /* Alternative fire button */
#define DIBUTTON_HUNTING_LEFT_LINK              0x0D00C4E4 /* Fallback sidestep left button */
#define DIBUTTON_HUNTING_RIGHT_LINK             0x0D00C4EC /* Fallback sidestep right button */
#define DIBUTTON_HUNTING_FORWARD_LINK           0x0D0144E0 /* Fallback move forward button */
#define DIBUTTON_HUNTING_BACK_LINK              0x0D0144E8 /* Fallback move back button */
#define DIBUTTON_HUNTING_ROTATE_LEFT_LINK       0x0D0244E4 /* Fallback turn body left button */
#define DIBUTTON_HUNTING_ROTATE_RIGHT_LINK      0x0D0244EC /* Fallback turn body right button */
#define DIBUTTON_HUNTING_DEVICE                 0x0D0044FE /* Show input device and controls */
#define DIBUTTON_HUNTING_PAUSE                  0x0D0044FC /* Start / Pause / Restart game */

/*--- Sports - Fishing
      Catching Fish is primary objective   ---*/
#define DIVIRTUAL_SPORTS_FISHING                0x0E000000
#define DIAXIS_FISHING_LATERAL                  0x0E008201 /* sidestep left/right */
#define DIAXIS_FISHING_MOVE                     0x0E010202 /* move forward/backwards */
#define DIBUTTON_FISHING_CAST                   0x0E000401 /* Cast line */
#define DIBUTTON_FISHING_TYPE                   0x0E000402 /* Select cast type */
#define DIBUTTON_FISHING_BINOCULAR              0x0E000403 /* Look through Binocular */
#define DIBUTTON_FISHING_BAIT                   0x0E000404 /* Select type of Bait */
#define DIBUTTON_FISHING_MAP                    0x0E000405 /* View Map */
#define DIBUTTON_FISHING_MENU                   0x0E0004FD /* Show menu options */
/*--- Priority 2 controls                            ---*/

#define DIHATSWITCH_FISHING_GLANCE              0x0E004601 /* Look around */
#define DIBUTTON_FISHING_DISPLAY                0x0E004406 /* Show next on-screen display option */
#define DIAXIS_FISHING_ROTATE                   0x0E024203 /* Turn character left / right */
#define DIBUTTON_FISHING_CROUCH                 0x0E004407 /* Crouch/ Climb / Swim down */
#define DIBUTTON_FISHING_JUMP                   0x0E004408 /* Jump/ Climb up / Swim up */
#define DIBUTTON_FISHING_LEFT_LINK              0x0E00C4E4 /* Fallback sidestep left button */
#define DIBUTTON_FISHING_RIGHT_LINK             0x0E00C4EC /* Fallback sidestep right button */
#define DIBUTTON_FISHING_FORWARD_LINK           0x0E0144E0 /* Fallback move forward button */
#define DIBUTTON_FISHING_BACK_LINK              0x0E0144E8 /* Fallback move back button */
#define DIBUTTON_FISHING_ROTATE_LEFT_LINK       0x0E0244E4 /* Fallback turn body left button */
#define DIBUTTON_FISHING_ROTATE_RIGHT_LINK      0x0E0244EC /* Fallback turn body right button */
#define DIBUTTON_FISHING_DEVICE                 0x0E0044FE /* Show input device and controls */
#define DIBUTTON_FISHING_PAUSE                  0x0E0044FC /* Start / Pause / Restart game */

/*--- Sports - Baseball - Batting
      Batter control is primary objective  ---*/
#define DIVIRTUAL_SPORTS_BASEBALL_BAT           0x0F000000
#define DIAXIS_BASEBALLB_LATERAL                0x0F008201 /* Aim left / right */
#define DIAXIS_BASEBALLB_MOVE                   0x0F010202 /* Aim up / down */
#define DIBUTTON_BASEBALLB_SELECT               0x0F000401 /* cycle through swing options */
#define DIBUTTON_BASEBALLB_NORMAL               0x0F000402 /* normal swing */
#define DIBUTTON_BASEBALLB_POWER                0x0F000403 /* swing for the fence */
#define DIBUTTON_BASEBALLB_BUNT                 0x0F000404 /* bunt */
#define DIBUTTON_BASEBALLB_STEAL                0x0F000405 /* Base runner attempts to steal a base */
#define DIBUTTON_BASEBALLB_BURST                0x0F000406 /* Base runner invokes burst of speed */
#define DIBUTTON_BASEBALLB_SLIDE                0x0F000407 /* Base runner slides into base */
#define DIBUTTON_BASEBALLB_CONTACT              0x0F000408 /* Contact swing */
#define DIBUTTON_BASEBALLB_MENU                 0x0F0004FD /* Show menu options */
/*--- Priority 2 controls                            ---*/

#define DIBUTTON_BASEBALLB_NOSTEAL              0x0F004409 /* Base runner goes back to a base */
#define DIBUTTON_BASEBALLB_BOX                  0x0F00440A /* Enter or exit batting box */
#define DIBUTTON_BASEBALLB_LEFT_LINK            0x0F00C4E4 /* Fallback sidestep left button */
#define DIBUTTON_BASEBALLB_RIGHT_LINK           0x0F00C4EC /* Fallback sidestep right button */
#define DIBUTTON_BASEBALLB_FORWARD_LINK         0x0F0144E0 /* Fallback move forward button */
#define DIBUTTON_BASEBALLB_BACK_LINK            0x0F0144E8 /* Fallback move back button */
#define DIBUTTON_BASEBALLB_DEVICE               0x0F0044FE /* Show input device and controls */
#define DIBUTTON_BASEBALLB_PAUSE                0x0F0044FC /* Start / Pause / Restart game */

/*--- Sports - Baseball - Pitching
      Pitcher control is primary objective   ---*/
#define DIVIRTUAL_SPORTS_BASEBALL_PITCH         0x10000000
#define DIAXIS_BASEBALLP_LATERAL                0x10008201 /* Aim left / right */
#define DIAXIS_BASEBALLP_MOVE                   0x10010202 /* Aim up / down */
#define DIBUTTON_BASEBALLP_SELECT               0x10000401 /* cycle through pitch selections */
#define DIBUTTON_BASEBALLP_PITCH                0x10000402 /* throw pitch */
#define DIBUTTON_BASEBALLP_BASE                 0x10000403 /* select base to throw to */
#define DIBUTTON_BASEBALLP_THROW                0x10000404 /* throw to base */
#define DIBUTTON_BASEBALLP_FAKE                 0x10000405 /* Fake a throw to a base */
#define DIBUTTON_BASEBALLP_MENU                 0x100004FD /* Show menu options */
/*--- Priority 2 controls                            ---*/

#define DIBUTTON_BASEBALLP_WALK                 0x10004406 /* Throw intentional walk / pitch out */
#define DIBUTTON_BASEBALLP_LOOK                 0x10004407 /* Look at runners on bases */
#define DIBUTTON_BASEBALLP_LEFT_LINK            0x1000C4E4 /* Fallback sidestep left button */
#define DIBUTTON_BASEBALLP_RIGHT_LINK           0x1000C4EC /* Fallback sidestep right button */
#define DIBUTTON_BASEBALLP_FORWARD_LINK         0x100144E0 /* Fallback move forward button */
#define DIBUTTON_BASEBALLP_BACK_LINK            0x100144E8 /* Fallback move back button */
#define DIBUTTON_BASEBALLP_DEVICE               0x100044FE /* Show input device and controls */
#define DIBUTTON_BASEBALLP_PAUSE                0x100044FC /* Start / Pause / Restart game */

/*--- Sports - Baseball - Fielding
      Fielder control is primary objective  ---*/
#define DIVIRTUAL_SPORTS_BASEBALL_FIELD         0x11000000
#define DIAXIS_BASEBALLF_LATERAL                0x11008201 /* Aim left / right */
#define DIAXIS_BASEBALLF_MOVE                   0x11010202 /* Aim up / down */
#define DIBUTTON_BASEBALLF_NEAREST              0x11000401 /* Switch to fielder nearest to the ball */
#define DIBUTTON_BASEBALLF_THROW1               0x11000402 /* Make conservative throw */
#define DIBUTTON_BASEBALLF_THROW2               0x11000403 /* Make aggressive throw */
#define DIBUTTON_BASEBALLF_BURST                0x11000404 /* Invoke burst of speed */
#define DIBUTTON_BASEBALLF_JUMP                 0x11000405 /* Jump to catch ball */
#define DIBUTTON_BASEBALLF_DIVE                 0x11000406 /* Dive to catch ball */
#define DIBUTTON_BASEBALLF_MENU                 0x110004FD /* Show menu options */
/*--- Priority 2 controls                            ---*/

#define DIBUTTON_BASEBALLF_SHIFTIN              0x11004407 /* Shift the infield positioning */
#define DIBUTTON_BASEBALLF_SHIFTOUT             0x11004408 /* Shift the outfield positioning */
#define DIBUTTON_BASEBALLF_AIM_LEFT_LINK        0x1100C4E4 /* Fallback aim left button */
#define DIBUTTON_BASEBALLF_AIM_RIGHT_LINK       0x1100C4EC /* Fallback aim right button */
#define DIBUTTON_BASEBALLF_FORWARD_LINK         0x110144E0 /* Fallback move forward button */
#define DIBUTTON_BASEBALLF_BACK_LINK            0x110144E8 /* Fallback move back button */
#define DIBUTTON_BASEBALLF_DEVICE               0x110044FE /* Show input device and controls */
#define DIBUTTON_BASEBALLF_PAUSE                0x110044FC /* Start / Pause / Restart game */

/*--- Sports - Basketball - Offense
      Offense  ---*/
#define DIVIRTUAL_SPORTS_BASKETBALL_OFFENSE     0x12000000
#define DIAXIS_BBALLO_LATERAL                   0x12008201 /* left / right */
#define DIAXIS_BBALLO_MOVE                      0x12010202 /* up / down */
#define DIBUTTON_BBALLO_SHOOT                   0x12000401 /* shoot basket */
#define DIBUTTON_BBALLO_DUNK                    0x12000402 /* dunk basket */
#define DIBUTTON_BBALLO_PASS                    0x12000403 /* throw pass */
#define DIBUTTON_BBALLO_FAKE                    0x12000404 /* fake shot or pass */
#define DIBUTTON_BBALLO_SPECIAL                 0x12000405 /* apply special move */
#define DIBUTTON_BBALLO_PLAYER                  0x12000406 /* select next player */
#define DIBUTTON_BBALLO_BURST                   0x12000407 /* invoke burst */
#define DIBUTTON_BBALLO_CALL                    0x12000408 /* call for ball / pass to me */
#define DIBUTTON_BBALLO_MENU                    0x120004FD /* Show menu options */
/*--- Priority 2 controls                            ---*/

#define DIHATSWITCH_BBALLO_GLANCE               0x12004601 /* scroll view */
#define DIBUTTON_BBALLO_SCREEN                  0x12004409 /* Call for screen */
#define DIBUTTON_BBALLO_PLAY                    0x1200440A /* Call for specific offensive play */
#define DIBUTTON_BBALLO_JAB                     0x1200440B /* Initiate fake drive to basket */
#define DIBUTTON_BBALLO_POST                    0x1200440C /* Perform post move */
#define DIBUTTON_BBALLO_TIMEOUT                 0x1200440D /* Time Out */
#define DIBUTTON_BBALLO_SUBSTITUTE              0x1200440E /* substitute one player for another */
#define DIBUTTON_BBALLO_LEFT_LINK               0x1200C4E4 /* Fallback sidestep left button */
#define DIBUTTON_BBALLO_RIGHT_LINK              0x1200C4EC /* Fallback sidestep right button */
#define DIBUTTON_BBALLO_FORWARD_LINK            0x120144E0 /* Fallback move forward button */
#define DIBUTTON_BBALLO_BACK_LINK               0x120144E8 /* Fallback move back button */
#define DIBUTTON_BBALLO_DEVICE                  0x120044FE /* Show input device and controls */
#define DIBUTTON_BBALLO_PAUSE                   0x120044FC /* Start / Pause / Restart game */

/*--- Sports - Basketball - Defense
      Defense  ---*/
#define DIVIRTUAL_SPORTS_BASKETBALL_DEFENSE     0x13000000
#define DIAXIS_BBALLD_LATERAL                   0x13008201 /* left / right */
#define DIAXIS_BBALLD_MOVE                      0x13010202 /* up / down */
#define DIBUTTON_BBALLD_JUMP                    0x13000401 /* jump to block shot */
#define DIBUTTON_BBALLD_STEAL                   0x13000402 /* attempt to steal ball */
#define DIBUTTON_BBALLD_FAKE                    0x13000403 /* fake block or steal */
#define DIBUTTON_BBALLD_SPECIAL                 0x13000404 /* apply special move */
#define DIBUTTON_BBALLD_PLAYER                  0x13000405 /* select next player */
#define DIBUTTON_BBALLD_BURST                   0x13000406 /* invoke burst */
#define DIBUTTON_BBALLD_PLAY                    0x13000407 /* call for specific defensive play */
#define DIBUTTON_BBALLD_MENU                    0x130004FD /* Show menu options */
/*--- Priority 2 controls                            ---*/

#define DIHATSWITCH_BBALLD_GLANCE               0x13004601 /* scroll view */
#define DIBUTTON_BBALLD_TIMEOUT                 0x13004408 /* Time Out */
#define DIBUTTON_BBALLD_SUBSTITUTE              0x13004409 /* substitute one player for another */
#define DIBUTTON_BBALLD_LEFT_LINK               0x1300C4E4 /* Fallback sidestep left button */
#define DIBUTTON_BBALLD_RIGHT_LINK              0x1300C4EC /* Fallback sidestep right button */
#define DIBUTTON_BBALLD_FORWARD_LINK            0x130144E0 /* Fallback move forward button */
#define DIBUTTON_BBALLD_BACK_LINK               0x130144E8 /* Fallback move back button */
#define DIBUTTON_BBALLD_DEVICE                  0x130044FE /* Show input device and controls */
#define DIBUTTON_BBALLD_PAUSE                   0x130044FC /* Start / Pause / Restart game */

/*--- Sports - Football - Play
      Play selection  ---*/
#define DIVIRTUAL_SPORTS_FOOTBALL_FIELD         0x14000000
#define DIBUTTON_FOOTBALLP_PLAY                 0x14000401 /* cycle through available plays */
#define DIBUTTON_FOOTBALLP_SELECT               0x14000402 /* select play */
#define DIBUTTON_FOOTBALLP_HELP                 0x14000403 /* Bring up pop-up help */
#define DIBUTTON_FOOTBALLP_MENU                 0x140004FD /* Show menu options */
/*--- Priority 2 controls                            ---*/

#define DIBUTTON_FOOTBALLP_DEVICE               0x140044FE /* Show input device and controls */
#define DIBUTTON_FOOTBALLP_PAUSE                0x140044FC /* Start / Pause / Restart game */

/*--- Sports - Football - QB
      Offense: Quarterback / Kicker  ---*/
#define DIVIRTUAL_SPORTS_FOOTBALL_QBCK          0x15000000
#define DIAXIS_FOOTBALLQ_LATERAL                0x15008201 /* Move / Aim: left / right */
#define DIAXIS_FOOTBALLQ_MOVE                   0x15010202 /* Move / Aim: up / down */
#define DIBUTTON_FOOTBALLQ_SELECT               0x15000401 /* Select */
#define DIBUTTON_FOOTBALLQ_SNAP                 0x15000402 /* snap ball - start play */
#define DIBUTTON_FOOTBALLQ_JUMP                 0x15000403 /* jump over defender */
#define DIBUTTON_FOOTBALLQ_SLIDE                0x15000404 /* Dive/Slide */
#define DIBUTTON_FOOTBALLQ_PASS                 0x15000405 /* throws pass to receiver */
#define DIBUTTON_FOOTBALLQ_FAKE                 0x15000406 /* pump fake pass or fake kick */
#define DIBUTTON_FOOTBALLQ_MENU                 0x150004FD /* Show menu options */
/*--- Priority 2 controls                            ---*/

#define DIBUTTON_FOOTBALLQ_FAKESNAP             0x15004407 /* Fake snap  */
#define DIBUTTON_FOOTBALLQ_MOTION               0x15004408 /* Send receivers in motion */
#define DIBUTTON_FOOTBALLQ_AUDIBLE              0x15004409 /* Change offensive play at line of scrimmage */
#define DIBUTTON_FOOTBALLQ_LEFT_LINK            0x1500C4E4 /* Fallback sidestep left button */
#define DIBUTTON_FOOTBALLQ_RIGHT_LINK           0x1500C4EC /* Fallback sidestep right button */
#define DIBUTTON_FOOTBALLQ_FORWARD_LINK         0x150144E0 /* Fallback move forward button */
#define DIBUTTON_FOOTBALLQ_BACK_LINK            0x150144E8 /* Fallback move back button */
#define DIBUTTON_FOOTBALLQ_DEVICE               0x150044FE /* Show input device and controls */
#define DIBUTTON_FOOTBALLQ_PAUSE                0x150044FC /* Start / Pause / Restart game */

/*--- Sports - Football - Offense
      Offense - Runner  ---*/
#define DIVIRTUAL_SPORTS_FOOTBALL_OFFENSE       0x16000000
#define DIAXIS_FOOTBALLO_LATERAL                0x16008201 /* Move / Aim: left / right */
#define DIAXIS_FOOTBALLO_MOVE                   0x16010202 /* Move / Aim: up / down */
#define DIBUTTON_FOOTBALLO_JUMP                 0x16000401 /* jump or hurdle over defender */
#define DIBUTTON_FOOTBALLO_LEFTARM              0x16000402 /* holds out left arm */
#define DIBUTTON_FOOTBALLO_RIGHTARM             0x16000403 /* holds out right arm */
#define DIBUTTON_FOOTBALLO_THROW                0x16000404 /* throw pass or lateral ball to another runner */
#define DIBUTTON_FOOTBALLO_SPIN                 0x16000405 /* Spin to avoid defenders */
#define DIBUTTON_FOOTBALLO_MENU                 0x160004FD /* Show menu options */
/*--- Priority 2 controls                            ---*/

#define DIBUTTON_FOOTBALLO_JUKE                 0x16004406 /* Use special move to avoid defenders */
#define DIBUTTON_FOOTBALLO_SHOULDER             0x16004407 /* Lower shoulder to run over defenders */
#define DIBUTTON_FOOTBALLO_TURBO                0x16004408 /* Speed burst past defenders */
#define DIBUTTON_FOOTBALLO_DIVE                 0x16004409 /* Dive over defenders */
#define DIBUTTON_FOOTBALLO_ZOOM                 0x1600440A /* Zoom view in / out */
#define DIBUTTON_FOOTBALLO_SUBSTITUTE           0x1600440B /* substitute one player for another */
#define DIBUTTON_FOOTBALLO_LEFT_LINK            0x1600C4E4 /* Fallback sidestep left button */
#define DIBUTTON_FOOTBALLO_RIGHT_LINK           0x1600C4EC /* Fallback sidestep right button */
#define DIBUTTON_FOOTBALLO_FORWARD_LINK         0x160144E0 /* Fallback move forward button */
#define DIBUTTON_FOOTBALLO_BACK_LINK            0x160144E8 /* Fallback move back button */
#define DIBUTTON_FOOTBALLO_DEVICE               0x160044FE /* Show input device and controls */
#define DIBUTTON_FOOTBALLO_PAUSE                0x160044FC /* Start / Pause / Restart game */

/*--- Sports - Football - Defense
      Defense     ---*/
#define DIVIRTUAL_SPORTS_FOOTBALL_DEFENSE       0x17000000
#define DIAXIS_FOOTBALLD_LATERAL                0x17008201 /* Move / Aim: left / right */
#define DIAXIS_FOOTBALLD_MOVE                   0x17010202 /* Move / Aim: up / down */
#define DIBUTTON_FOOTBALLD_PLAY                 0x17000401 /* cycle through available plays */
#define DIBUTTON_FOOTBALLD_SELECT               0x17000402 /* select player closest to the ball */
#define DIBUTTON_FOOTBALLD_JUMP                 0x17000403 /* jump to intercept or block */
#define DIBUTTON_FOOTBALLD_TACKLE               0x17000404 /* tackler runner */
#define DIBUTTON_FOOTBALLD_FAKE                 0x17000405 /* hold down to fake tackle or intercept */
#define DIBUTTON_FOOTBALLD_SUPERTACKLE          0x17000406 /* Initiate special tackle */
#define DIBUTTON_FOOTBALLD_MENU                 0x170004FD /* Show menu options */
/*--- Priority 2 controls                            ---*/

#define DIBUTTON_FOOTBALLD_SPIN                 0x17004407 /* Spin to beat offensive line */
#define DIBUTTON_FOOTBALLD_SWIM                 0x17004408 /* Swim to beat the offensive line */
#define DIBUTTON_FOOTBALLD_BULLRUSH             0x17004409 /* Bull rush the offensive line */
#define DIBUTTON_FOOTBALLD_RIP                  0x1700440A /* Rip the offensive line */
#define DIBUTTON_FOOTBALLD_AUDIBLE              0x1700440B /* Change defensive play at the line of scrimmage */
#define DIBUTTON_FOOTBALLD_ZOOM                 0x1700440C /* Zoom view in / out */
#define DIBUTTON_FOOTBALLD_SUBSTITUTE           0x1700440D /* substitute one player for another */
#define DIBUTTON_FOOTBALLD_LEFT_LINK            0x1700C4E4 /* Fallback sidestep left button */
#define DIBUTTON_FOOTBALLD_RIGHT_LINK           0x1700C4EC /* Fallback sidestep right button */
#define DIBUTTON_FOOTBALLD_FORWARD_LINK         0x170144E0 /* Fallback move forward button */
#define DIBUTTON_FOOTBALLD_BACK_LINK            0x170144E8 /* Fallback move back button */
#define DIBUTTON_FOOTBALLD_DEVICE               0x170044FE /* Show input device and controls */
#define DIBUTTON_FOOTBALLD_PAUSE                0x170044FC /* Start / Pause / Restart game */

/*--- Sports - Golf
                                ---*/
#define DIVIRTUAL_SPORTS_GOLF                   0x18000000
#define DIAXIS_GOLF_LATERAL                     0x18008201 /* Move / Aim: left / right */
#define DIAXIS_GOLF_MOVE                        0x18010202 /* Move / Aim: up / down */
#define DIBUTTON_GOLF_SWING                     0x18000401 /* swing club */
#define DIBUTTON_GOLF_SELECT                    0x18000402 /* cycle between: club / swing strength / ball arc / ball spin */
#define DIBUTTON_GOLF_UP                        0x18000403 /* increase selection */
#define DIBUTTON_GOLF_DOWN                      0x18000404 /* decrease selection */
#define DIBUTTON_GOLF_TERRAIN                   0x18000405 /* shows terrain detail */
#define DIBUTTON_GOLF_FLYBY                     0x18000406 /* view the hole via a flyby */
#define DIBUTTON_GOLF_MENU                      0x180004FD /* Show menu options */
/*--- Priority 2 controls                            ---*/

#define DIHATSWITCH_GOLF_SCROLL                 0x18004601 /* scroll view */
#define DIBUTTON_GOLF_ZOOM                      0x18004407 /* Zoom view in / out */
#define DIBUTTON_GOLF_TIMEOUT                   0x18004408 /* Call for time out */
#define DIBUTTON_GOLF_SUBSTITUTE                0x18004409 /* substitute one player for another */
#define DIBUTTON_GOLF_LEFT_LINK                 0x1800C4E4 /* Fallback sidestep left button */
#define DIBUTTON_GOLF_RIGHT_LINK                0x1800C4EC /* Fallback sidestep right button */
#define DIBUTTON_GOLF_FORWARD_LINK              0x180144E0 /* Fallback move forward button */
#define DIBUTTON_GOLF_BACK_LINK                 0x180144E8 /* Fallback move back button */
#define DIBUTTON_GOLF_DEVICE                    0x180044FE /* Show input device and controls */
#define DIBUTTON_GOLF_PAUSE                     0x180044FC /* Start / Pause / Restart game */

/*--- Sports - Hockey - Offense
      Offense       ---*/
#define DIVIRTUAL_SPORTS_HOCKEY_OFFENSE         0x19000000
#define DIAXIS_HOCKEYO_LATERAL                  0x19008201 /* Move / Aim: left / right */
#define DIAXIS_HOCKEYO_MOVE                     0x19010202 /* Move / Aim: up / down */
#define DIBUTTON_HOCKEYO_SHOOT                  0x19000401 /* Shoot */
#define DIBUTTON_HOCKEYO_PASS                   0x19000402 /* pass the puck */
#define DIBUTTON_HOCKEYO_BURST                  0x19000403 /* invoke speed burst */
#define DIBUTTON_HOCKEYO_SPECIAL                0x19000404 /* invoke special move */
#define DIBUTTON_HOCKEYO_FAKE                   0x19000405 /* hold down to fake pass or kick */
#define DIBUTTON_HOCKEYO_MENU                   0x190004FD /* Show menu options */
/*--- Priority 2 controls                            ---*/

#define DIHATSWITCH_HOCKEYO_SCROLL              0x19004601 /* scroll view */
#define DIBUTTON_HOCKEYO_ZOOM                   0x19004406 /* Zoom view in / out */
#define DIBUTTON_HOCKEYO_STRATEGY               0x19004407 /* Invoke coaching menu for strategy help */
#define DIBUTTON_HOCKEYO_TIMEOUT                0x19004408 /* Call for time out */
#define DIBUTTON_HOCKEYO_SUBSTITUTE             0x19004409 /* substitute one player for another */
#define DIBUTTON_HOCKEYO_LEFT_LINK              0x1900C4E4 /* Fallback sidestep left button */
#define DIBUTTON_HOCKEYO_RIGHT_LINK             0x1900C4EC /* Fallback sidestep right button */
#define DIBUTTON_HOCKEYO_FORWARD_LINK           0x190144E0 /* Fallback move forward button */
#define DIBUTTON_HOCKEYO_BACK_LINK              0x190144E8 /* Fallback move back button */
#define DIBUTTON_HOCKEYO_DEVICE                 0x190044FE /* Show input device and controls */
#define DIBUTTON_HOCKEYO_PAUSE                  0x190044FC /* Start / Pause / Restart game */

/*--- Sports - Hockey - Defense
      Defense       ---*/
#define DIVIRTUAL_SPORTS_HOCKEY_DEFENSE         0x1A000000
#define DIAXIS_HOCKEYD_LATERAL                  0x1A008201 /* Move / Aim: left / right */
#define DIAXIS_HOCKEYD_MOVE                     0x1A010202 /* Move / Aim: up / down */
#define DIBUTTON_HOCKEYD_PLAYER                 0x1A000401 /* control player closest to the puck */
#define DIBUTTON_HOCKEYD_STEAL                  0x1A000402 /* attempt steal */
#define DIBUTTON_HOCKEYD_BURST                  0x1A000403 /* speed burst or body check */
#define DIBUTTON_HOCKEYD_BLOCK                  0x1A000404 /* block puck */
#define DIBUTTON_HOCKEYD_FAKE                   0x1A000405 /* hold down to fake tackle or intercept */
#define DIBUTTON_HOCKEYD_MENU                   0x1A0004FD /* Show menu options */
/*--- Priority 2 controls                            ---*/

#define DIHATSWITCH_HOCKEYD_SCROLL              0x1A004601 /* scroll view */
#define DIBUTTON_HOCKEYD_ZOOM                   0x1A004406 /* Zoom view in / out */
#define DIBUTTON_HOCKEYD_STRATEGY               0x1A004407 /* Invoke coaching menu for strategy help */
#define DIBUTTON_HOCKEYD_TIMEOUT                0x1A004408 /* Call for time out */
#define DIBUTTON_HOCKEYD_SUBSTITUTE             0x1A004409 /* substitute one player for another */
#define DIBUTTON_HOCKEYD_LEFT_LINK              0x1A00C4E4 /* Fallback sidestep left button */
#define DIBUTTON_HOCKEYD_RIGHT_LINK             0x1A00C4EC /* Fallback sidestep right button */
#define DIBUTTON_HOCKEYD_FORWARD_LINK           0x1A0144E0 /* Fallback move forward button */
#define DIBUTTON_HOCKEYD_BACK_LINK              0x1A0144E8 /* Fallback move back button */
#define DIBUTTON_HOCKEYD_DEVICE                 0x1A0044FE /* Show input device and controls */
#define DIBUTTON_HOCKEYD_PAUSE                  0x1A0044FC /* Start / Pause / Restart game */

/*--- Sports - Hockey - Goalie
      Goal tending  ---*/
#define DIVIRTUAL_SPORTS_HOCKEY_GOALIE          0x1B000000
#define DIAXIS_HOCKEYG_LATERAL                  0x1B008201 /* Move / Aim: left / right */
#define DIAXIS_HOCKEYG_MOVE                     0x1B010202 /* Move / Aim: up / down */
#define DIBUTTON_HOCKEYG_PASS                   0x1B000401 /* pass puck */
#define DIBUTTON_HOCKEYG_POKE                   0x1B000402 /* poke / check / hack */
#define DIBUTTON_HOCKEYG_STEAL                  0x1B000403 /* attempt steal */
#define DIBUTTON_HOCKEYG_BLOCK                  0x1B000404 /* block puck */
#define DIBUTTON_HOCKEYG_MENU                   0x1B0004FD /* Show menu options */
/*--- Priority 2 controls                            ---*/

#define DIHATSWITCH_HOCKEYG_SCROLL              0x1B004601 /* scroll view */
#define DIBUTTON_HOCKEYG_ZOOM                   0x1B004405 /* Zoom view in / out */
#define DIBUTTON_HOCKEYG_STRATEGY               0x1B004406 /* Invoke coaching menu for strategy help */
#define DIBUTTON_HOCKEYG_TIMEOUT                0x1B004407 /* Call for time out */
#define DIBUTTON_HOCKEYG_SUBSTITUTE             0x1B004408 /* substitute one player for another */
#define DIBUTTON_HOCKEYG_LEFT_LINK              0x1B00C4E4 /* Fallback sidestep left button */
#define DIBUTTON_HOCKEYG_RIGHT_LINK             0x1B00C4EC /* Fallback sidestep right button */
#define DIBUTTON_HOCKEYG_FORWARD_LINK           0x1B0144E0 /* Fallback move forward button */
#define DIBUTTON_HOCKEYG_BACK_LINK              0x1B0144E8 /* Fallback move back button */
#define DIBUTTON_HOCKEYG_DEVICE                 0x1B0044FE /* Show input device and controls */
#define DIBUTTON_HOCKEYG_PAUSE                  0x1B0044FC /* Start / Pause / Restart game */

/*--- Sports - Mountain Biking
                     ---*/
#define DIVIRTUAL_SPORTS_BIKING_MOUNTAIN        0x1C000000
#define DIAXIS_BIKINGM_TURN                     0x1C008201 /* left / right */
#define DIAXIS_BIKINGM_PEDAL                    0x1C010202 /* Pedal faster / slower / brake */
#define DIBUTTON_BIKINGM_JUMP                   0x1C000401 /* jump over obstacle */
#define DIBUTTON_BIKINGM_CAMERA                 0x1C000402 /* switch camera view */
#define DIBUTTON_BIKINGM_SPECIAL1               0x1C000403 /* perform first special move */
#define DIBUTTON_BIKINGM_SELECT                 0x1C000404 /* Select */
#define DIBUTTON_BIKINGM_SPECIAL2               0x1C000405 /* perform second special move */
#define DIBUTTON_BIKINGM_MENU                   0x1C0004FD /* Show menu options */
/*--- Priority 2 controls                            ---*/

#define DIHATSWITCH_BIKINGM_SCROLL              0x1C004601 /* scroll view */
#define DIBUTTON_BIKINGM_ZOOM                   0x1C004406 /* Zoom view in / out */
#define DIAXIS_BIKINGM_BRAKE                    0x1C044203 /* Brake axis  */
#define DIBUTTON_BIKINGM_LEFT_LINK              0x1C00C4E4 /* Fallback turn left button */
#define DIBUTTON_BIKINGM_RIGHT_LINK             0x1C00C4EC /* Fallback turn right button */
#define DIBUTTON_BIKINGM_FASTER_LINK            0x1C0144E0 /* Fallback pedal faster button */
#define DIBUTTON_BIKINGM_SLOWER_LINK            0x1C0144E8 /* Fallback pedal slower button */
#define DIBUTTON_BIKINGM_BRAKE_BUTTON_LINK      0x1C0444E8 /* Fallback brake button */
#define DIBUTTON_BIKINGM_DEVICE                 0x1C0044FE /* Show input device and controls */
#define DIBUTTON_BIKINGM_PAUSE                  0x1C0044FC /* Start / Pause / Restart game */

/*--- Sports: Skiing / Snowboarding / Skateboarding
        ---*/
#define DIVIRTUAL_SPORTS_SKIING                 0x1D000000
#define DIAXIS_SKIING_TURN                      0x1D008201 /* left / right */
#define DIAXIS_SKIING_SPEED                     0x1D010202 /* faster / slower */
#define DIBUTTON_SKIING_JUMP                    0x1D000401 /* Jump */
#define DIBUTTON_SKIING_CROUCH                  0x1D000402 /* crouch down */
#define DIBUTTON_SKIING_CAMERA                  0x1D000403 /* switch camera view */
#define DIBUTTON_SKIING_SPECIAL1                0x1D000404 /* perform first special move */
#define DIBUTTON_SKIING_SELECT                  0x1D000405 /* Select */
#define DIBUTTON_SKIING_SPECIAL2                0x1D000406 /* perform second special move */
#define DIBUTTON_SKIING_MENU                    0x1D0004FD /* Show menu options */
/*--- Priority 2 controls                            ---*/

#define DIHATSWITCH_SKIING_GLANCE               0x1D004601 /* scroll view */
#define DIBUTTON_SKIING_ZOOM                    0x1D004407 /* Zoom view in / out */
#define DIBUTTON_SKIING_LEFT_LINK               0x1D00C4E4 /* Fallback turn left button */
#define DIBUTTON_SKIING_RIGHT_LINK              0x1D00C4EC /* Fallback turn right button */
#define DIBUTTON_SKIING_FASTER_LINK             0x1D0144E0 /* Fallback increase speed button */
#define DIBUTTON_SKIING_SLOWER_LINK             0x1D0144E8 /* Fallback decrease speed button */
#define DIBUTTON_SKIING_DEVICE                  0x1D0044FE /* Show input device and controls */
#define DIBUTTON_SKIING_PAUSE                   0x1D0044FC /* Start / Pause / Restart game */

/*--- Sports - Soccer - Offense
      Offense       ---*/
#define DIVIRTUAL_SPORTS_SOCCER_OFFENSE         0x1E000000
#define DIAXIS_SOCCERO_LATERAL                  0x1E008201 /* Move / Aim: left / right */
#define DIAXIS_SOCCERO_MOVE                     0x1E010202 /* Move / Aim: up / down */
#define DIAXIS_SOCCERO_BEND                     0x1E018203 /* Bend to soccer shot/pass */
#define DIBUTTON_SOCCERO_SHOOT                  0x1E000401 /* Shoot the ball */
#define DIBUTTON_SOCCERO_PASS                   0x1E000402 /* Pass  */
#define DIBUTTON_SOCCERO_FAKE                   0x1E000403 /* Fake */
#define DIBUTTON_SOCCERO_PLAYER                 0x1E000404 /* Select next player */
#define DIBUTTON_SOCCERO_SPECIAL1               0x1E000405 /* Apply special move */
#define DIBUTTON_SOCCERO_SELECT                 0x1E000406 /* Select special move */
#define DIBUTTON_SOCCERO_MENU                   0x1E0004FD /* Show menu options */
/*--- Priority 2 controls                            ---*/

#define DIHATSWITCH_SOCCERO_GLANCE              0x1E004601 /* scroll view */
#define DIBUTTON_SOCCERO_SUBSTITUTE             0x1E004407 /* Substitute one player for another */
#define DIBUTTON_SOCCERO_SHOOTLOW               0x1E004408 /* Shoot the ball low */
#define DIBUTTON_SOCCERO_SHOOTHIGH              0x1E004409 /* Shoot the ball high */
#define DIBUTTON_SOCCERO_PASSTHRU               0x1E00440A /* Make a thru pass */
#define DIBUTTON_SOCCERO_SPRINT                 0x1E00440B /* Sprint / turbo boost */
#define DIBUTTON_SOCCERO_CONTROL                0x1E00440C /* Obtain control of the ball */
#define DIBUTTON_SOCCERO_HEAD                   0x1E00440D /* Attempt to head the ball */
#define DIBUTTON_SOCCERO_LEFT_LINK              0x1E00C4E4 /* Fallback sidestep left button */
#define DIBUTTON_SOCCERO_RIGHT_LINK             0x1E00C4EC /* Fallback sidestep right button */
#define DIBUTTON_SOCCERO_FORWARD_LINK           0x1E0144E0 /* Fallback move forward button */
#define DIBUTTON_SOCCERO_BACK_LINK              0x1E0144E8 /* Fallback move back button */
#define DIBUTTON_SOCCERO_DEVICE                 0x1E0044FE /* Show input device and controls */
#define DIBUTTON_SOCCERO_PAUSE                  0x1E0044FC /* Start / Pause / Restart game */

/*--- Sports - Soccer - Defense
      Defense       ---*/
#define DIVIRTUAL_SPORTS_SOCCER_DEFENSE         0x1F000000
#define DIAXIS_SOCCERD_LATERAL                  0x1F008201 /* Move / Aim: left / right */
#define DIAXIS_SOCCERD_MOVE                     0x1F010202 /* Move / Aim: up / down */
#define DIBUTTON_SOCCERD_BLOCK                  0x1F000401 /* Attempt to block shot */
#define DIBUTTON_SOCCERD_STEAL                  0x1F000402 /* Attempt to steal ball */
#define DIBUTTON_SOCCERD_FAKE                   0x1F000403 /* Fake a block or a steal */
#define DIBUTTON_SOCCERD_PLAYER                 0x1F000404 /* Select next player */
#define DIBUTTON_SOCCERD_SPECIAL                0x1F000405 /* Apply special move */
#define DIBUTTON_SOCCERD_SELECT                 0x1F000406 /* Select special move */
#define DIBUTTON_SOCCERD_SLIDE                  0x1F000407 /* Attempt a slide tackle */
#define DIBUTTON_SOCCERD_MENU                   0x1F0004FD /* Show menu options */
/*--- Priority 2 controls                            ---*/

#define DIHATSWITCH_SOCCERD_GLANCE              0x1F004601 /* scroll view */
#define DIBUTTON_SOCCERD_FOUL                   0x1F004408 /* Initiate a foul / hard-foul */
#define DIBUTTON_SOCCERD_HEAD                   0x1F004409 /* Attempt a Header */
#define DIBUTTON_SOCCERD_CLEAR                  0x1F00440A /* Attempt to clear the ball down the field */
#define DIBUTTON_SOCCERD_GOALIECHARGE           0x1F00440B /* Make the goalie charge out of the box */
#define DIBUTTON_SOCCERD_SUBSTITUTE             0x1F00440C /* Substitute one player for another */
#define DIBUTTON_SOCCERD_LEFT_LINK              0x1F00C4E4 /* Fallback sidestep left button */
#define DIBUTTON_SOCCERD_RIGHT_LINK             0x1F00C4EC /* Fallback sidestep right button */
#define DIBUTTON_SOCCERD_FORWARD_LINK           0x1F0144E0 /* Fallback move forward button */
#define DIBUTTON_SOCCERD_BACK_LINK              0x1F0144E8 /* Fallback move back button */
#define DIBUTTON_SOCCERD_DEVICE                 0x1F0044FE /* Show input device and controls */
#define DIBUTTON_SOCCERD_PAUSE                  0x1F0044FC /* Start / Pause / Restart game */

/*--- Sports - Racquet
      Tennis - Table-Tennis - Squash   ---*/
#define DIVIRTUAL_SPORTS_RACQUET                0x20000000
#define DIAXIS_RACQUET_LATERAL                  0x20008201 /* Move / Aim: left / right */
#define DIAXIS_RACQUET_MOVE                     0x20010202 /* Move / Aim: up / down */
#define DIBUTTON_RACQUET_SWING                  0x20000401 /* Swing racquet */
#define DIBUTTON_RACQUET_BACKSWING              0x20000402 /* Swing backhand */
#define DIBUTTON_RACQUET_SMASH                  0x20000403 /* Smash shot */
#define DIBUTTON_RACQUET_SPECIAL                0x20000404 /* Special shot */
#define DIBUTTON_RACQUET_SELECT                 0x20000405 /* Select special shot */
#define DIBUTTON_RACQUET_MENU                   0x200004FD /* Show menu options */
/*--- Priority 2 controls                            ---*/

#define DIHATSWITCH_RACQUET_GLANCE              0x20004601 /* scroll view */
#define DIBUTTON_RACQUET_TIMEOUT                0x20004406 /* Call for time out */
#define DIBUTTON_RACQUET_SUBSTITUTE             0x20004407 /* Substitute one player for another */
#define DIBUTTON_RACQUET_LEFT_LINK              0x2000C4E4 /* Fallback sidestep left button */
#define DIBUTTON_RACQUET_RIGHT_LINK             0x2000C4EC /* Fallback sidestep right button */
#define DIBUTTON_RACQUET_FORWARD_LINK           0x200144E0 /* Fallback move forward button */
#define DIBUTTON_RACQUET_BACK_LINK              0x200144E8 /* Fallback move back button */
#define DIBUTTON_RACQUET_DEVICE                 0x200044FE /* Show input device and controls */
#define DIBUTTON_RACQUET_PAUSE                  0x200044FC /* Start / Pause / Restart game */

/*--- Arcade- 2D
      Side to Side movement        ---*/
#define DIVIRTUAL_ARCADE_SIDE2SIDE              0x21000000
#define DIAXIS_ARCADES_LATERAL                  0x21008201 /* left / right */
#define DIAXIS_ARCADES_MOVE                     0x21010202 /* up / down */
#define DIBUTTON_ARCADES_THROW                  0x21000401 /* throw object */
#define DIBUTTON_ARCADES_CARRY                  0x21000402 /* carry object */
#define DIBUTTON_ARCADES_ATTACK                 0x21000403 /* attack */
#define DIBUTTON_ARCADES_SPECIAL                0x21000404 /* apply special move */
#define DIBUTTON_ARCADES_SELECT                 0x21000405 /* select special move */
#define DIBUTTON_ARCADES_MENU                   0x210004FD /* Show menu options */
/*--- Priority 2 controls                            ---*/

#define DIHATSWITCH_ARCADES_VIEW                0x21004601 /* scroll view left / right / up / down */
#define DIBUTTON_ARCADES_LEFT_LINK              0x2100C4E4 /* Fallback sidestep left button */
#define DIBUTTON_ARCADES_RIGHT_LINK             0x2100C4EC /* Fallback sidestep right button */
#define DIBUTTON_ARCADES_FORWARD_LINK           0x210144E0 /* Fallback move forward button */
#define DIBUTTON_ARCADES_BACK_LINK              0x210144E8 /* Fallback move back button */
#define DIBUTTON_ARCADES_VIEW_UP_LINK           0x2107C4E0 /* Fallback scroll view up button */
#define DIBUTTON_ARCADES_VIEW_DOWN_LINK         0x2107C4E8 /* Fallback scroll view down button */
#define DIBUTTON_ARCADES_VIEW_LEFT_LINK         0x2107C4E4 /* Fallback scroll view left button */
#define DIBUTTON_ARCADES_VIEW_RIGHT_LINK        0x2107C4EC /* Fallback scroll view right button */
#define DIBUTTON_ARCADES_DEVICE                 0x210044FE /* Show input device and controls */
#define DIBUTTON_ARCADES_PAUSE                  0x210044FC /* Start / Pause / Restart game */

/*--- Arcade - Platform Game
      Character moves around on screen  ---*/
#define DIVIRTUAL_ARCADE_PLATFORM               0x22000000
#define DIAXIS_ARCADEP_LATERAL                  0x22008201 /* Left / right */
#define DIAXIS_ARCADEP_MOVE                     0x22010202 /* Up / down */
#define DIBUTTON_ARCADEP_JUMP                   0x22000401 /* Jump */
#define DIBUTTON_ARCADEP_FIRE                   0x22000402 /* Fire */
#define DIBUTTON_ARCADEP_CROUCH                 0x22000403 /* Crouch */
#define DIBUTTON_ARCADEP_SPECIAL                0x22000404 /* Apply special move */
#define DIBUTTON_ARCADEP_SELECT                 0x22000405 /* Select special move */
#define DIBUTTON_ARCADEP_MENU                   0x220004FD /* Show menu options */
/*--- Priority 2 controls                            ---*/

#define DIHATSWITCH_ARCADEP_VIEW                0x22004601 /* Scroll view */
#define DIBUTTON_ARCADEP_FIRESECONDARY          0x22004406 /* Alternative fire button */
#define DIBUTTON_ARCADEP_LEFT_LINK              0x2200C4E4 /* Fallback sidestep left button */
#define DIBUTTON_ARCADEP_RIGHT_LINK             0x2200C4EC /* Fallback sidestep right button */
#define DIBUTTON_ARCADEP_FORWARD_LINK           0x220144E0 /* Fallback move forward button */
#define DIBUTTON_ARCADEP_BACK_LINK              0x220144E8 /* Fallback move back button */
#define DIBUTTON_ARCADEP_VIEW_UP_LINK           0x2207C4E0 /* Fallback scroll view up button */
#define DIBUTTON_ARCADEP_VIEW_DOWN_LINK         0x2207C4E8 /* Fallback scroll view down button */
#define DIBUTTON_ARCADEP_VIEW_LEFT_LINK         0x2207C4E4 /* Fallback scroll view left button */
#define DIBUTTON_ARCADEP_VIEW_RIGHT_LINK        0x2207C4EC /* Fallback scroll view right button */
#define DIBUTTON_ARCADEP_DEVICE                 0x220044FE /* Show input device and controls */
#define DIBUTTON_ARCADEP_PAUSE                  0x220044FC /* Start / Pause / Restart game */

/*--- CAD - 2D Object Control
      Controls to select and move objects in 2D  ---*/
#define DIVIRTUAL_CAD_2DCONTROL                 0x23000000
#define DIAXIS_2DCONTROL_LATERAL                0x23008201 /* Move view left / right */
#define DIAXIS_2DCONTROL_MOVE                   0x23010202 /* Move view up / down */
#define DIAXIS_2DCONTROL_INOUT                  0x23018203 /* Zoom - in / out */
#define DIBUTTON_2DCONTROL_SELECT               0x23000401 /* Select Object */
#define DIBUTTON_2DCONTROL_SPECIAL1             0x23000402 /* Do first special operation */
#define DIBUTTON_2DCONTROL_SPECIAL              0x23000403 /* Select special operation */
#define DIBUTTON_2DCONTROL_SPECIAL2             0x23000404 /* Do second special operation */
#define DIBUTTON_2DCONTROL_MENU                 0x230004FD /* Show menu options */
/*--- Priority 2 controls                            ---*/

#define DIHATSWITCH_2DCONTROL_HATSWITCH         0x23004601 /* Hat switch */
#define DIAXIS_2DCONTROL_ROTATEZ                0x23024204 /* Rotate view clockwise / counterclockwise */
#define DIBUTTON_2DCONTROL_DISPLAY              0x23004405 /* Shows next on-screen display options */
#define DIBUTTON_2DCONTROL_DEVICE               0x230044FE /* Show input device and controls */
#define DIBUTTON_2DCONTROL_PAUSE                0x230044FC /* Start / Pause / Restart game */

/*--- CAD - 3D object control
      Controls to select and move objects within a 3D environment  ---*/
#define DIVIRTUAL_CAD_3DCONTROL                 0x24000000
#define DIAXIS_3DCONTROL_LATERAL                0x24008201 /* Move view left / right */
#define DIAXIS_3DCONTROL_MOVE                   0x24010202 /* Move view up / down */
#define DIAXIS_3DCONTROL_INOUT                  0x24018203 /* Zoom - in / out */
#define DIBUTTON_3DCONTROL_SELECT               0x24000401 /* Select Object */
#define DIBUTTON_3DCONTROL_SPECIAL1             0x24000402 /* Do first special operation */
#define DIBUTTON_3DCONTROL_SPECIAL              0x24000403 /* Select special operation */
#define DIBUTTON_3DCONTROL_SPECIAL2             0x24000404 /* Do second special operation */
#define DIBUTTON_3DCONTROL_MENU                 0x240004FD /* Show menu options */
/*--- Priority 2 controls                            ---*/

#define DIHATSWITCH_3DCONTROL_HATSWITCH         0x24004601 /* Hat switch */
#define DIAXIS_3DCONTROL_ROTATEX                0x24034204 /* Rotate view forward or up / backward or down */
#define DIAXIS_3DCONTROL_ROTATEY                0x2402C205 /* Rotate view clockwise / counterclockwise */
#define DIAXIS_3DCONTROL_ROTATEZ                0x24024206 /* Rotate view left / right */
#define DIBUTTON_3DCONTROL_DISPLAY              0x24004405 /* Show next on-screen display options */
#define DIBUTTON_3DCONTROL_DEVICE               0x240044FE /* Show input device and controls */
#define DIBUTTON_3DCONTROL_PAUSE                0x240044FC /* Start / Pause / Restart game */

/*--- CAD - 3D Navigation - Fly through
      Controls for 3D modeling  ---*/
#define DIVIRTUAL_CAD_FLYBY                     0x25000000
#define DIAXIS_CADF_LATERAL                     0x25008201 /* move view left / right */
#define DIAXIS_CADF_MOVE                        0x25010202 /* move view up / down */
#define DIAXIS_CADF_INOUT                       0x25018203 /* in / out */
#define DIBUTTON_CADF_SELECT                    0x25000401 /* Select Object */
#define DIBUTTON_CADF_SPECIAL1                  0x25000402 /* do first special operation */
#define DIBUTTON_CADF_SPECIAL                   0x25000403 /* Select special operation */
#define DIBUTTON_CADF_SPECIAL2                  0x25000404 /* do second special operation */
#define DIBUTTON_CADF_MENU                      0x250004FD /* Show menu options */
/*--- Priority 2 controls                            ---*/

#define DIHATSWITCH_CADF_HATSWITCH              0x25004601 /* Hat switch */
#define DIAXIS_CADF_ROTATEX                     0x25034204 /* Rotate view forward or up / backward or down */
#define DIAXIS_CADF_ROTATEY                     0x2502C205 /* Rotate view clockwise / counterclockwise */
#define DIAXIS_CADF_ROTATEZ                     0x25024206 /* Rotate view left / right */
#define DIBUTTON_CADF_DISPLAY                   0x25004405 /* shows next on-screen display options */
#define DIBUTTON_CADF_DEVICE                    0x250044FE /* Show input device and controls */
#define DIBUTTON_CADF_PAUSE                     0x250044FC /* Start / Pause / Restart game */

/*--- CAD - 3D Model Control
      Controls for 3D modeling  ---*/
#define DIVIRTUAL_CAD_MODEL                     0x26000000
#define DIAXIS_CADM_LATERAL                     0x26008201 /* move view left / right */
#define DIAXIS_CADM_MOVE                        0x26010202 /* move view up / down */
#define DIAXIS_CADM_INOUT                       0x26018203 /* in / out */
#define DIBUTTON_CADM_SELECT                    0x26000401 /* Select Object */
#define DIBUTTON_CADM_SPECIAL1                  0x26000402 /* do first special operation */
#define DIBUTTON_CADM_SPECIAL                   0x26000403 /* Select special operation */
#define DIBUTTON_CADM_SPECIAL2                  0x26000404 /* do second special operation */
#define DIBUTTON_CADM_MENU                      0x260004FD /* Show menu options */
/*--- Priority 2 controls                            ---*/

#define DIHATSWITCH_CADM_HATSWITCH              0x26004601 /* Hat switch */
#define DIAXIS_CADM_ROTATEX                     0x26034204 /* Rotate view forward or up / backward or down */
#define DIAXIS_CADM_ROTATEY                     0x2602C205 /* Rotate view clockwise / counterclockwise */
#define DIAXIS_CADM_ROTATEZ                     0x26024206 /* Rotate view left / right */
#define DIBUTTON_CADM_DISPLAY                   0x26004405 /* shows next on-screen display options */
#define DIBUTTON_CADM_DEVICE                    0x260044FE /* Show input device and controls */
#define DIBUTTON_CADM_PAUSE                     0x260044FC /* Start / Pause / Restart game */

/*--- Control - Media Equipment
      Remote        ---*/
#define DIVIRTUAL_REMOTE_CONTROL                0x27000000
#define DIAXIS_REMOTE_SLIDER                    0x27050201 /* Slider for adjustment: volume / color / bass / etc */
#define DIBUTTON_REMOTE_MUTE                    0x27000401 /* Set volume on current device to zero */
#define DIBUTTON_REMOTE_SELECT                  0x27000402 /* Next/previous: channel/ track / chapter / picture / station */
#define DIBUTTON_REMOTE_PLAY                    0x27002403 /* Start or pause entertainment on current device */
#define DIBUTTON_REMOTE_CUE                     0x27002404 /* Move through current media */
#define DIBUTTON_REMOTE_REVIEW                  0x27002405 /* Move through current media */
#define DIBUTTON_REMOTE_CHANGE                  0x27002406 /* Select next device */
#define DIBUTTON_REMOTE_RECORD                  0x27002407 /* Start recording the current media */
#define DIBUTTON_REMOTE_MENU                    0x270004FD /* Show menu options */
/*--- Priority 2 controls                            ---*/

#define DIAXIS_REMOTE_SLIDER2                   0x27054202 /* Slider for adjustment: volume */
#define DIBUTTON_REMOTE_TV                      0x27005C08 /* Select TV */
#define DIBUTTON_REMOTE_CABLE                   0x27005C09 /* Select cable box */
#define DIBUTTON_REMOTE_CD                      0x27005C0A /* Select CD player */
#define DIBUTTON_REMOTE_VCR                     0x27005C0B /* Select VCR */
#define DIBUTTON_REMOTE_TUNER                   0x27005C0C /* Select tuner */
#define DIBUTTON_REMOTE_DVD                     0x27005C0D /* Select DVD player */
#define DIBUTTON_REMOTE_ADJUST                  0x27005C0E /* Enter device adjustment menu */
#define DIBUTTON_REMOTE_DIGIT0                  0x2700540F /* Digit 0 */
#define DIBUTTON_REMOTE_DIGIT1                  0x27005410 /* Digit 1 */
#define DIBUTTON_REMOTE_DIGIT2                  0x27005411 /* Digit 2 */
#define DIBUTTON_REMOTE_DIGIT3                  0x27005412 /* Digit 3 */
#define DIBUTTON_REMOTE_DIGIT4                  0x27005413 /* Digit 4 */
#define DIBUTTON_REMOTE_DIGIT5                  0x27005414 /* Digit 5 */
#define DIBUTTON_REMOTE_DIGIT6                  0x27005415 /* Digit 6 */
#define DIBUTTON_REMOTE_DIGIT7                  0x27005416 /* Digit 7 */
#define DIBUTTON_REMOTE_DIGIT8                  0x27005417 /* Digit 8 */
#define DIBUTTON_REMOTE_DIGIT9                  0x27005418 /* Digit 9 */
#define DIBUTTON_REMOTE_DEVICE                  0x270044FE /* Show input device and controls */
#define DIBUTTON_REMOTE_PAUSE                   0x270044FC /* Start / Pause / Restart game */

/*--- Control- Web
      Help or Browser            ---*/
#define DIVIRTUAL_BROWSER_CONTROL               0x28000000
#define DIAXIS_BROWSER_LATERAL                  0x28008201 /* Move on screen pointer */
#define DIAXIS_BROWSER_MOVE                     0x28010202 /* Move on screen pointer */
#define DIBUTTON_BROWSER_SELECT                 0x28000401 /* Select current item */
#define DIAXIS_BROWSER_VIEW                     0x28018203 /* Move view up/down */
#define DIBUTTON_BROWSER_REFRESH                0x28000402 /* Refresh */
#define DIBUTTON_BROWSER_MENU                   0x280004FD /* Show menu options */
/*--- Priority 2 controls                            ---*/

#define DIBUTTON_BROWSER_SEARCH                 0x28004403 /* Use search tool */
#define DIBUTTON_BROWSER_STOP                   0x28004404 /* Cease current update */
#define DIBUTTON_BROWSER_HOME                   0x28004405 /* Go directly to "home" location */
#define DIBUTTON_BROWSER_FAVORITES              0x28004406 /* Mark current site as favorite */
#define DIBUTTON_BROWSER_NEXT                   0x28004407 /* Select Next page */
#define DIBUTTON_BROWSER_PREVIOUS               0x28004408 /* Select Previous page */
#define DIBUTTON_BROWSER_HISTORY                0x28004409 /* Show/Hide History */
#define DIBUTTON_BROWSER_PRINT                  0x2800440A /* Print current page */
#define DIBUTTON_BROWSER_DEVICE                 0x280044FE /* Show input device and controls */
#define DIBUTTON_BROWSER_PAUSE                  0x280044FC /* Start / Pause / Restart game */

/*--- Driving Simulator - Giant Walking Robot
      Walking tank with weapons  ---*/
#define DIVIRTUAL_DRIVING_MECHA                 0x29000000
#define DIAXIS_MECHA_STEER                      0x29008201 /* Turns mecha left/right */
#define DIAXIS_MECHA_TORSO                      0x29010202 /* Tilts torso forward/backward */
#define DIAXIS_MECHA_ROTATE                     0x29020203 /* Turns torso left/right */
#define DIAXIS_MECHA_THROTTLE                   0x29038204 /* Engine Speed */
#define DIBUTTON_MECHA_FIRE                     0x29000401 /* Fire */
#define DIBUTTON_MECHA_WEAPONS                  0x29000402 /* Select next weapon group */
#define DIBUTTON_MECHA_TARGET                   0x29000403 /* Select closest enemy available target */
#define DIBUTTON_MECHA_REVERSE                  0x29000404 /* Toggles throttle in/out of reverse */
#define DIBUTTON_MECHA_ZOOM                     0x29000405 /* Zoom in/out targeting reticule */
#define DIBUTTON_MECHA_JUMP                     0x29000406 /* Fires jump jets */
#define DIBUTTON_MECHA_MENU                     0x290004FD /* Show menu options */
/*--- Priority 2 controls                            ---*/

#define DIBUTTON_MECHA_CENTER                   0x29004407 /* Center torso to legs */
#define DIHATSWITCH_MECHA_GLANCE                0x29004601 /* Look around */
#define DIBUTTON_MECHA_VIEW                     0x29004408 /* Cycle through view options */
#define DIBUTTON_MECHA_FIRESECONDARY            0x29004409 /* Alternative fire button */
#define DIBUTTON_MECHA_LEFT_LINK                0x2900C4E4 /* Fallback steer left button */
#define DIBUTTON_MECHA_RIGHT_LINK               0x2900C4EC /* Fallback steer right button */
#define DIBUTTON_MECHA_FORWARD_LINK             0x290144E0 /* Fallback tilt torso forward button */
#define DIBUTTON_MECHA_BACK_LINK                0x290144E8 /* Fallback tilt toroso backward button */
#define DIBUTTON_MECHA_ROTATE_LEFT_LINK         0x290244E4 /* Fallback rotate toroso right button */
#define DIBUTTON_MECHA_ROTATE_RIGHT_LINK        0x290244EC /* Fallback rotate torso left button */
#define DIBUTTON_MECHA_FASTER_LINK              0x2903C4E0 /* Fallback increase engine speed */
#define DIBUTTON_MECHA_SLOWER_LINK              0x2903C4E8 /* Fallback decrease engine speed */
#define DIBUTTON_MECHA_DEVICE                   0x290044FE /* Show input device and controls */
#define DIBUTTON_MECHA_PAUSE                    0x290044FC /* Start / Pause / Restart game */

/*
 *  "ANY" semantics can be used as a last resort to get mappings for actions 
 *  that match nothing in the chosen virtual genre.  These semantics will be 
 *  mapped at a lower priority that virtual genre semantics.  Also, hardware 
 *  vendors will not be able to provide sensible mappings for these unless 
 *  they provide application specific mappings.
 */
#define DIAXIS_ANY_X_1                          0xFF00C201 
#define DIAXIS_ANY_X_2                          0xFF00C202 
#define DIAXIS_ANY_Y_1                          0xFF014201 
#define DIAXIS_ANY_Y_2                          0xFF014202 
#define DIAXIS_ANY_Z_1                          0xFF01C201 
#define DIAXIS_ANY_Z_2                          0xFF01C202 
#define DIAXIS_ANY_R_1                          0xFF024201 
#define DIAXIS_ANY_R_2                          0xFF024202 
#define DIAXIS_ANY_U_1                          0xFF02C201 
#define DIAXIS_ANY_U_2                          0xFF02C202 
#define DIAXIS_ANY_V_1                          0xFF034201 
#define DIAXIS_ANY_V_2                          0xFF034202 
#define DIAXIS_ANY_A_1                          0xFF03C201 
#define DIAXIS_ANY_A_2                          0xFF03C202 
#define DIAXIS_ANY_B_1                          0xFF044201 
#define DIAXIS_ANY_B_2                          0xFF044202 
#define DIAXIS_ANY_C_1                          0xFF04C201 
#define DIAXIS_ANY_C_2                          0xFF04C202 
#define DIAXIS_ANY_S_1                          0xFF054201 
#define DIAXIS_ANY_S_2                          0xFF054202 

#define DIAXIS_ANY_1                            0xFF004201 
#define DIAXIS_ANY_2                            0xFF004202 
#define DIAXIS_ANY_3                            0xFF004203 
#define DIAXIS_ANY_4                            0xFF004204 

#define DIPOV_ANY_1                             0xFF004601 
#define DIPOV_ANY_2                             0xFF004602 
#define DIPOV_ANY_3                             0xFF004603 
#define DIPOV_ANY_4                             0xFF004604 

#define DIBUTTON_ANY(instance)                  ( 0xFF004400 | instance )


#ifdef __cplusplus
};
#endif

#endif  /* __DINPUT_INCLUDED__ */

/****************************************************************************
 *
 *  Definitions for non-IDirectInput (VJoyD) features defined more recently
 *  than the current sdk files
 *
 ****************************************************************************/

#ifdef _INC_MMSYSTEM
#ifndef MMNOJOY

#ifndef __VJOYDX_INCLUDED__
#define __VJOYDX_INCLUDED__

#ifdef __cplusplus
extern "C" {
#endif

/*
 * Flag to indicate that the dwReserved2 field of the JOYINFOEX structure
 * contains mini-driver specific data to be passed by VJoyD to the mini-
 * driver instead of doing a poll.
 */
#define JOY_PASSDRIVERDATA          0x10000000l

/*
 * Informs the joystick driver that the configuration has been changed
 * and should be reloaded from the registery.
 * dwFlags is reserved and should be set to zero
 */
WINMMAPI MMRESULT WINAPI joyConfigChanged( DWORD dwFlags );


/*
 * Hardware Setting indicating that the device is a headtracker
 */
#define JOY_HWS_ISHEADTRACKER       0x02000000l

/*
 * Hardware Setting indicating that the VxD is used to replace
 * the standard analog polling
 */
#define JOY_HWS_ISGAMEPORTDRIVER    0x04000000l

/*
 * Hardware Setting indicating that the driver needs a standard
 * gameport in order to communicate with the device.
 */
#define JOY_HWS_ISANALOGPORTDRIVER  0x08000000l

/*
 * Hardware Setting indicating that VJoyD should not load this
 * driver, it will be loaded externally and will register with
 * VJoyD of it's own accord.
 */
#define JOY_HWS_AUTOLOAD            0x10000000l

/*
 * Hardware Setting indicating that the driver acquires any
 * resources needed without needing a devnode through VJoyD.
 */
#define JOY_HWS_NODEVNODE           0x20000000l


/*
 * Hardware Setting indicating that the device is a gameport bus
 */
#define JOY_HWS_ISGAMEPORTBUS       0x80000000l
#define JOY_HWS_GAMEPORTBUSBUSY     0x00000001l

/*
 * Usage Setting indicating that the settings are volatile and
 * should be removed if still present on a reboot.
 */
#define JOY_US_VOLATILE             0x00000008L

#ifdef __cplusplus
};
#endif

#endif  /* __VJOYDX_INCLUDED__ */

#endif  /* not MMNOJOY */
#endif  /* _INC_MMSYSTEM */

/****************************************************************************
 *
 *  Definitions for non-IDirectInput (VJoyD) features defined more recently
 *  than the current ddk files
 *
 ****************************************************************************/

#ifndef DIJ_RINGZERO

#ifdef _INC_MMDDK
#ifndef MMNOJOYDEV

#ifndef __VJOYDXD_INCLUDED__
#define __VJOYDXD_INCLUDED__
/*
 * Poll type in which the do_other field of the JOYOEMPOLLDATA
 * structure contains mini-driver specific data passed from an app.
 */
#define JOY_OEMPOLL_PASSDRIVERDATA  7

#endif  /* __VJOYDXD_INCLUDED__ */

#endif  /* not MMNOJOYDEV */
#endif  /* _INC_MMDDK */

#endif /* DIJ_RINGZERO */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\dhcpcsdk.h ===
//================================================================================
//  Copyright (C) 1997-1999 Microsoft Corporation
//  Description: these are the exported dhcp client api function definitions
//================================================================================
#ifndef _DHCPCSDK_
#define _DHCPCSDK_

#ifdef __cplusplus
extern "C" {
#endif

#ifndef DHCP_OPTIONS_DEFINED
#define DHCP_OPTIONS_DEFINED

#if _MSC_VER > 1000
#pragma once
#endif

//
// DHCP Standard Options.
//

#define OPTION_PAD                      0
#define OPTION_SUBNET_MASK              1
#define OPTION_TIME_OFFSET              2
#define OPTION_ROUTER_ADDRESS           3
#define OPTION_TIME_SERVERS             4
#define OPTION_IEN116_NAME_SERVERS      5
#define OPTION_DOMAIN_NAME_SERVERS      6
#define OPTION_LOG_SERVERS              7
#define OPTION_COOKIE_SERVERS           8
#define OPTION_LPR_SERVERS              9
#define OPTION_IMPRESS_SERVERS          10
#define OPTION_RLP_SERVERS              11
#define OPTION_HOST_NAME                12
#define OPTION_BOOT_FILE_SIZE           13
#define OPTION_MERIT_DUMP_FILE          14
#define OPTION_DOMAIN_NAME              15
#define OPTION_SWAP_SERVER              16
#define OPTION_ROOT_DISK                17
#define OPTION_EXTENSIONS_PATH          18

//
// IP layer parameters - per host
//

#define OPTION_BE_A_ROUTER              19
#define OPTION_NON_LOCAL_SOURCE_ROUTING 20
#define OPTION_POLICY_FILTER_FOR_NLSR   21
#define OPTION_MAX_REASSEMBLY_SIZE      22
#define OPTION_DEFAULT_TTL              23
#define OPTION_PMTU_AGING_TIMEOUT       24
#define OPTION_PMTU_PLATEAU_TABLE       25

//
// Link layer parameters - per interface.
//

#define OPTION_MTU                      26
#define OPTION_ALL_SUBNETS_MTU          27
#define OPTION_BROADCAST_ADDRESS        28
#define OPTION_PERFORM_MASK_DISCOVERY   29
#define OPTION_BE_A_MASK_SUPPLIER       30
#define OPTION_PERFORM_ROUTER_DISCOVERY 31
#define OPTION_ROUTER_SOLICITATION_ADDR 32
#define OPTION_STATIC_ROUTES            33
#define OPTION_TRAILERS                 34
#define OPTION_ARP_CACHE_TIMEOUT        35
#define OPTION_ETHERNET_ENCAPSULATION   36

//
// TCP Paramters - per host
//

#define OPTION_TTL                      37
#define OPTION_KEEP_ALIVE_INTERVAL      38
#define OPTION_KEEP_ALIVE_DATA_SIZE     39

//
// Application Layer Parameters
//

#define OPTION_NETWORK_INFO_SERVICE_DOM 40
#define OPTION_NETWORK_INFO_SERVERS     41
#define OPTION_NETWORK_TIME_SERVERS     42

//
// Vender specific information option
//

#define OPTION_VENDOR_SPEC_INFO         43

//
// NetBIOS over TCP/IP Name server option
//

#define OPTION_NETBIOS_NAME_SERVER      44
#define OPTION_NETBIOS_DATAGRAM_SERVER  45
#define OPTION_NETBIOS_NODE_TYPE        46
#define OPTION_NETBIOS_SCOPE_OPTION     47

//
// X Window System Options.
//

#define OPTION_XWINDOW_FONT_SERVER      48
#define OPTION_XWINDOW_DISPLAY_MANAGER  49

//
// Other extensions
//

#define OPTION_REQUESTED_ADDRESS        50
#define OPTION_LEASE_TIME               51
#define OPTION_OK_TO_OVERLAY            52
#define OPTION_MESSAGE_TYPE             53
#define OPTION_SERVER_IDENTIFIER        54
#define OPTION_PARAMETER_REQUEST_LIST   55
#define OPTION_MESSAGE                  56
#define OPTION_MESSAGE_LENGTH           57
#define OPTION_RENEWAL_TIME             58      // T1
#define OPTION_REBIND_TIME              59      // T2
#define OPTION_CLIENT_CLASS_INFO        60
#define OPTION_CLIENT_ID                61

#define OPTION_TFTP_SERVER_NAME         66
#define OPTION_BOOTFILE_NAME            67


#define OPTION_END                      255

#endif  DHCP_OPTIONS_DEFINED

#ifndef DHCPAPI_PARAMS_DEFINED
#define DHCPAPI_PARAMS_DEFINED
typedef struct _DHCPAPI_PARAMS {                  // use this structure to request params
    ULONG                          Flags;         // for future use
    ULONG                          OptionId;      // what option is this?
    BOOL                           IsVendor;      // is this vendor specific?
    LPBYTE                         Data;          // the actual data
    DWORD                          nBytesData;    // how many bytes of data are there in Data?
} DHCPAPI_PARAMS, *PDHCPAPI_PARAMS, *LPDHCPAPI_PARAMS;
#endif DHCPAPI_PARAMS_DEFINED

typedef struct _DHCPAPI_PARAMS
DHCPCAPI_PARAMS, *PDHCPCAPI_PARAMS, *LPDHCPCAPI_PARAMS;

typedef struct _DHCPCAPI_PARAMS_ARARAY {          // array of params..
    ULONG                          nParams;       // size of array
    LPDHCPCAPI_PARAMS              Params;        // actual array
} DHCPCAPI_PARAMS_ARRAY, *PDHCPCAPI_PARAMS_ARRAY, *LPDHCPCAPI_PARAMS_ARRAY;

typedef struct _DHCPCAPI_CLASSID {                // defines a client class id.
    ULONG                          Flags;         // must be zero currently.
    LPBYTE                         Data;          // classid binary data.
    ULONG                          nBytesData;    // how many bytes of data are there?
} DHCPCAPI_CLASSID, *PDHCPCAPI_CLASSID, *LPDHCPCAPI_CLASSID;


#define     DHCPCAPI_REQUEST_PERSISTENT           0x01 // request this options "permanently"
#define     DHCPCAPI_REQUEST_SYNCHRONOUS          0x02 // request and block on it
#define     DHCPCAPI_REQUEST_ASYNCHRONOUS         0x04 // request and return, set event on completion
#define     DHCPCAPI_REQUEST_CANCEL               0x08 // cancel request
#define     DHCPCAPI_REQUEST_MASK                 0x0F // allowed flags..

DWORD
APIENTRY
DhcpCApiInitialize(
    OUT     LPDWORD                Version
);

VOID
APIENTRY
DhcpCApiCleanup(
    VOID
);

DWORD                                             // win32 status
APIENTRY
DhcpRequestParams(                                // request parameters of client
    IN      DWORD                  Flags,         // must be DHCPCAPI_REQUEST_SYNCHRONOUS
    IN      LPVOID                 Reserved,      // this parameter is reserved
    IN      LPWSTR                 AdapterName,   // adapter name to request for
    IN      LPDHCPCAPI_CLASSID     ClassId,       // reserved must be NULL
    IN      DHCPCAPI_PARAMS_ARRAY  SendParams,    // parameters to send.
    IN OUT  DHCPCAPI_PARAMS_ARRAY  RecdParams,    // parameters that are to be requested..
    IN      LPBYTE                 Buffer,        // a buffer to hold data for RecdParams
    IN OUT  LPDWORD                pSize,         // i/p: size of above in BYTES, o/p required bytes..
    IN      LPWSTR                 RequestIdStr   // needed for persistent requests
);  // returns ERROR_MORE_DATA if o/p buffer is of insufficient size, and fills in reqd size in # of bytes

DWORD                                             // win32 status
APIENTRY
DhcpUndoRequestParams(                            // undo the effect of a persistent request -- currently undo from registry
    IN      DWORD                  Flags,         // must be zero, reserved
    IN      LPVOID                 Reserved,      // this parameter is reserved
    IN      LPWSTR                 AdapterName,   // the name of the adpater to delete for
    IN      LPWSTR                 RequestIdStr   // needed for persistent requests..
);

#define     DHCPCAPI_REGISTER_HANDLE_EVENT        0x01 // handle returned is to an event
DWORD                                             // win32 status
APIENTRY
DhcpRegisterParamChange(                          // notify if a parameter has changed
    IN      DWORD                  Flags,         // must be zero, reserved
    IN      LPVOID                 Reserved,      // this parameter is reserved
    IN      LPWSTR                 AdapterName,   // adapter of interest
    IN      LPDHCPCAPI_CLASSID     ClassId,       // reserved must be NULL
    IN      DHCPCAPI_PARAMS_ARRAY  Params,        // parameters of interest
    IN OUT  LPVOID                 Handle         // handle to event that will be SetEvent'ed in case of param change
);

#define     DHCPCAPI_DEREGISTER_HANDLE_EVENT      0x01 // de-register handle that is an event
DWORD
APIENTRY
DhcpDeRegisterParamChange(                        // undo the registration
    IN      DWORD                  Flags,         // MUST BE ZERO --> No flags yet.
    IN      LPVOID                 Reserved,      // MUST BE NULL --> Reserved
    IN      LPVOID                 Event          // handle to event returned by DhcpRegisterParamChange.
);

DWORD
APIENTRY
DhcpRemoveDNSRegistrations(
    VOID
    );

#ifdef __cplusplus
}
#endif

//================================================================================
// end of file
//================================================================================
#endif _DHCPCSDK_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\dhtmled.h ===
/* Microsoft Corporation Copyright 1999 */
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.03.0110 */
/* at Thu Aug 06 10:08:26 1998
 */
/* Compiler settings for dhtmled.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __dhtmled_h__
#define __dhtmled_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IDEGetBlockFmtNamesParam_FWD_DEFINED__
#define __IDEGetBlockFmtNamesParam_FWD_DEFINED__
typedef interface IDEGetBlockFmtNamesParam IDEGetBlockFmtNamesParam;
#endif 	/* __IDEGetBlockFmtNamesParam_FWD_DEFINED__ */


#ifndef __IDHTMLSafe_FWD_DEFINED__
#define __IDHTMLSafe_FWD_DEFINED__
typedef interface IDHTMLSafe IDHTMLSafe;
#endif 	/* __IDHTMLSafe_FWD_DEFINED__ */


#ifndef __IDHTMLEdit_FWD_DEFINED__
#define __IDHTMLEdit_FWD_DEFINED__
typedef interface IDHTMLEdit IDHTMLEdit;
#endif 	/* __IDHTMLEdit_FWD_DEFINED__ */


#ifndef __IDEInsertTableParam_FWD_DEFINED__
#define __IDEInsertTableParam_FWD_DEFINED__
typedef interface IDEInsertTableParam IDEInsertTableParam;
#endif 	/* __IDEInsertTableParam_FWD_DEFINED__ */


#ifndef ___DHTMLSafeEvents_FWD_DEFINED__
#define ___DHTMLSafeEvents_FWD_DEFINED__
typedef interface _DHTMLSafeEvents _DHTMLSafeEvents;
#endif 	/* ___DHTMLSafeEvents_FWD_DEFINED__ */


#ifndef ___DHTMLEditEvents_FWD_DEFINED__
#define ___DHTMLEditEvents_FWD_DEFINED__
typedef interface _DHTMLEditEvents _DHTMLEditEvents;
#endif 	/* ___DHTMLEditEvents_FWD_DEFINED__ */


#ifndef __DHTMLEdit_FWD_DEFINED__
#define __DHTMLEdit_FWD_DEFINED__

#ifdef __cplusplus
typedef class DHTMLEdit DHTMLEdit;
#else
typedef struct DHTMLEdit DHTMLEdit;
#endif /* __cplusplus */

#endif 	/* __DHTMLEdit_FWD_DEFINED__ */


#ifndef __DHTMLSafe_FWD_DEFINED__
#define __DHTMLSafe_FWD_DEFINED__

#ifdef __cplusplus
typedef class DHTMLSafe DHTMLSafe;
#else
typedef struct DHTMLSafe DHTMLSafe;
#endif /* __cplusplus */

#endif 	/* __DHTMLSafe_FWD_DEFINED__ */


#ifndef __DEInsertTableParam_FWD_DEFINED__
#define __DEInsertTableParam_FWD_DEFINED__

#ifdef __cplusplus
typedef class DEInsertTableParam DEInsertTableParam;
#else
typedef struct DEInsertTableParam DEInsertTableParam;
#endif /* __cplusplus */

#endif 	/* __DEInsertTableParam_FWD_DEFINED__ */


#ifndef __DEGetBlockFmtNamesParam_FWD_DEFINED__
#define __DEGetBlockFmtNamesParam_FWD_DEFINED__

#ifdef __cplusplus
typedef class DEGetBlockFmtNamesParam DEGetBlockFmtNamesParam;
#else
typedef struct DEGetBlockFmtNamesParam DEGetBlockFmtNamesParam;
#endif /* __cplusplus */

#endif 	/* __DEGetBlockFmtNamesParam_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"
#include "docobj.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/****************************************
 * Generated header for interface: __MIDL_itf_dhtmled_0000
 * at Thu Aug 06 10:08:26 1998
 * using MIDL 3.03.0110
 ****************************************/
/* [local] */ 



#define DE_E_INVALIDARG                E_INVALIDARG
#define DE_E_PATH_NOT_FOUND            HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND)
#define DE_E_FILE_NOT_FOUND            HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)
#define DE_E_UNEXPECTED                E_UNEXPECTED
#define DE_E_DISK_FULL                 HRESULT_FROM_WIN32(ERROR_HANDLE_DISK_FULL)
#define DE_E_NOTSUPPORTED              OLECMDERR_E_NOTSUPPORTED
#define DE_E_ACCESS_DENIED             HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED)

#define DE_E_URL_SYNTAX                MK_E_SYNTAX
#define DE_E_INVALID_URL               0x800C0002
#define DE_E_NO_SESSION                0x800C0003
#define DE_E_CANNOT_CONNECT            0x800C0004
#define DE_E_RESOURCE_NOT_FOUND        0x800C0005
#define DE_E_OBJECT_NOT_FOUND          0x800C0006
#define DE_E_DATA_NOT_AVAILABLE        0x800C0007
#define DE_E_DOWNLOAD_FAILURE          0x800C0008
#define DE_E_AUTHENTICATION_REQUIRED   0x800C0009
#define DE_E_NO_VALID_MEDIA            0x800C000A
#define DE_E_CONNECTION_TIMEOUT        0x800C000B
#define DE_E_INVALID_REQUEST           0x800C000C
#define DE_E_UNKNOWN_PROTOCOL          0x800C000D
#define DE_E_SECURITY_PROBLEM          0x800C000E
#define DE_E_CANNOT_LOAD_DATA          0x800C000F
#define DE_E_CANNOT_INSTANTIATE_OBJECT 0x800C0010
#define DE_E_REDIRECT_FAILED           0x800C0014
#define DE_E_REDIRECT_TO_DIR           0x800C0015
#define DE_E_CANNOT_LOCK_REQUEST       0x800C0016

#define DE_E_FILTER_FRAMESET           0x80100001
#define DE_E_FILTER_SERVERSCRIPT       0x80100002
#define DE_E_FILTER_MULTIPLETAGS       0x80100004
#define DE_E_FILTER_SCRIPTLISTING      0x80100008
#define DE_E_FILTER_SCRIPTLABEL        0x80100010
#define DE_E_FILTER_SCRIPTTEXTAREA     0x80100020
#define DE_E_FILTER_SCRIPTSELECT       0x80100040


extern RPC_IF_HANDLE __MIDL_itf_dhtmled_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dhtmled_0000_v0_0_s_ifspec;


#ifndef __DHTMLEDLib_LIBRARY_DEFINED__
#define __DHTMLEDLib_LIBRARY_DEFINED__

/****************************************
 * Generated header for library: DHTMLEDLib
 * at Thu Aug 06 10:08:26 1998
 * using MIDL 3.03.0110
 ****************************************/
/* [helpstring][version][uuid] */ 


typedef /* [helpstring][uuid] */ 
enum DHTMLEDITCMDID
    {	DECMD_BOLD	= 5000,
	DECMD_COPY	= 5002,
	DECMD_CUT	= DECMD_COPY + 1,
	DECMD_DELETE	= DECMD_CUT + 1,
	DECMD_DELETECELLS	= DECMD_DELETE + 1,
	DECMD_DELETECOLS	= DECMD_DELETECELLS + 1,
	DECMD_DELETEROWS	= DECMD_DELETECOLS + 1,
	DECMD_FINDTEXT	= DECMD_DELETEROWS + 1,
	DECMD_FONT	= DECMD_FINDTEXT + 1,
	DECMD_GETBACKCOLOR	= DECMD_FONT + 1,
	DECMD_GETBLOCKFMT	= DECMD_GETBACKCOLOR + 1,
	DECMD_GETBLOCKFMTNAMES	= DECMD_GETBLOCKFMT + 1,
	DECMD_GETFONTNAME	= DECMD_GETBLOCKFMTNAMES + 1,
	DECMD_GETFONTSIZE	= DECMD_GETFONTNAME + 1,
	DECMD_GETFORECOLOR	= DECMD_GETFONTSIZE + 1,
	DECMD_HYPERLINK	= DECMD_GETFORECOLOR + 1,
	DECMD_IMAGE	= DECMD_HYPERLINK + 1,
	DECMD_INDENT	= DECMD_IMAGE + 1,
	DECMD_INSERTCELL	= DECMD_INDENT + 1,
	DECMD_INSERTCOL	= DECMD_INSERTCELL + 1,
	DECMD_INSERTROW	= DECMD_INSERTCOL + 1,
	DECMD_INSERTTABLE	= DECMD_INSERTROW + 1,
	DECMD_ITALIC	= DECMD_INSERTTABLE + 1,
	DECMD_JUSTIFYCENTER	= DECMD_ITALIC + 1,
	DECMD_JUSTIFYLEFT	= DECMD_JUSTIFYCENTER + 1,
	DECMD_JUSTIFYRIGHT	= DECMD_JUSTIFYLEFT + 1,
	DECMD_LOCK_ELEMENT	= DECMD_JUSTIFYRIGHT + 1,
	DECMD_MAKE_ABSOLUTE	= DECMD_LOCK_ELEMENT + 1,
	DECMD_MERGECELLS	= DECMD_MAKE_ABSOLUTE + 1,
	DECMD_ORDERLIST	= DECMD_MERGECELLS + 1,
	DECMD_OUTDENT	= DECMD_ORDERLIST + 1,
	DECMD_PASTE	= DECMD_OUTDENT + 1,
	DECMD_REDO	= DECMD_PASTE + 1,
	DECMD_REMOVEFORMAT	= DECMD_REDO + 1,
	DECMD_SELECTALL	= DECMD_REMOVEFORMAT + 1,
	DECMD_SEND_BACKWARD	= DECMD_SELECTALL + 1,
	DECMD_BRING_FORWARD	= DECMD_SEND_BACKWARD + 1,
	DECMD_SEND_BELOW_TEXT	= DECMD_BRING_FORWARD + 1,
	DECMD_BRING_ABOVE_TEXT	= DECMD_SEND_BELOW_TEXT + 1,
	DECMD_SEND_TO_BACK	= DECMD_BRING_ABOVE_TEXT + 1,
	DECMD_BRING_TO_FRONT	= DECMD_SEND_TO_BACK + 1,
	DECMD_SETBACKCOLOR	= DECMD_BRING_TO_FRONT + 1,
	DECMD_SETBLOCKFMT	= DECMD_SETBACKCOLOR + 1,
	DECMD_SETFONTNAME	= DECMD_SETBLOCKFMT + 1,
	DECMD_SETFONTSIZE	= DECMD_SETFONTNAME + 1,
	DECMD_SETFORECOLOR	= DECMD_SETFONTSIZE + 1,
	DECMD_SPLITCELL	= DECMD_SETFORECOLOR + 1,
	DECMD_UNDERLINE	= DECMD_SPLITCELL + 1,
	DECMD_UNDO	= DECMD_UNDERLINE + 1,
	DECMD_UNLINK	= DECMD_UNDO + 1,
	DECMD_UNORDERLIST	= DECMD_UNLINK + 1,
	DECMD_PROPERTIES	= DECMD_UNORDERLIST + 1
    }	DHTMLEDITCMDID;

typedef /* [helpstring][uuid] */ 
enum DHTMLEDITCMDF
    {	DECMDF_NOTSUPPORTED	= 0,
	DECMDF_DISABLED	= 0x1,
	DECMDF_ENABLED	= 0x3,
	DECMDF_LATCHED	= 0x7,
	DECMDF_NINCHED	= 0xb
    }	DHTMLEDITCMDF;

typedef /* [helpstring][uuid] */ 
enum DHTMLEDITAPPEARANCE
    {	DEAPPEARANCE_FLAT	= 0,
	DEAPPEARANCE_3D	= 0x1
    }	DHTMLEDITAPPEARANCE;


EXTERN_C const IID LIBID_DHTMLEDLib;

#ifndef __IDEGetBlockFmtNamesParam_INTERFACE_DEFINED__
#define __IDEGetBlockFmtNamesParam_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDEGetBlockFmtNamesParam
 * at Thu Aug 06 10:08:26 1998
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_IDEGetBlockFmtNamesParam;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8D91090D-B955-11D1-ADC5-006008A5848C")
    IDEGetBlockFmtNamesParam : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Names( 
            /* [retval][out] */ VARIANT __RPC_FAR *pVal) = 0;
        
        virtual /* [hidden][helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Names( 
            /* [in] */ VARIANT __RPC_FAR *newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDEGetBlockFmtNamesParamVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDEGetBlockFmtNamesParam __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDEGetBlockFmtNamesParam __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDEGetBlockFmtNamesParam __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDEGetBlockFmtNamesParam __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDEGetBlockFmtNamesParam __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDEGetBlockFmtNamesParam __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDEGetBlockFmtNamesParam __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Names )( 
            IDEGetBlockFmtNamesParam __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pVal);
        
        /* [hidden][helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Names )( 
            IDEGetBlockFmtNamesParam __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *newVal);
        
        END_INTERFACE
    } IDEGetBlockFmtNamesParamVtbl;

    interface IDEGetBlockFmtNamesParam
    {
        CONST_VTBL struct IDEGetBlockFmtNamesParamVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDEGetBlockFmtNamesParam_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDEGetBlockFmtNamesParam_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDEGetBlockFmtNamesParam_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDEGetBlockFmtNamesParam_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDEGetBlockFmtNamesParam_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDEGetBlockFmtNamesParam_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDEGetBlockFmtNamesParam_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDEGetBlockFmtNamesParam_get_Names(This,pVal)	\
    (This)->lpVtbl -> get_Names(This,pVal)

#define IDEGetBlockFmtNamesParam_put_Names(This,newVal)	\
    (This)->lpVtbl -> put_Names(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDEGetBlockFmtNamesParam_get_Names_Proxy( 
    IDEGetBlockFmtNamesParam __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pVal);


void __RPC_STUB IDEGetBlockFmtNamesParam_get_Names_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDEGetBlockFmtNamesParam_put_Names_Proxy( 
    IDEGetBlockFmtNamesParam __RPC_FAR * This,
    /* [in] */ VARIANT __RPC_FAR *newVal);


void __RPC_STUB IDEGetBlockFmtNamesParam_put_Names_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDEGetBlockFmtNamesParam_INTERFACE_DEFINED__ */


#ifndef __IDHTMLSafe_INTERFACE_DEFINED__
#define __IDHTMLSafe_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDHTMLSafe
 * at Thu Aug 06 10:08:26 1998
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_IDHTMLSafe;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CE04B590-2B1F-11d2-8D1E-00A0C959BC0A")
    IDHTMLSafe : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ExecCommand( 
            /* [in] */ DHTMLEDITCMDID cmdID,
            /* [defaultvalue][in] */ OLECMDEXECOPT cmdexecopt,
            /* [optional][in] */ VARIANT __RPC_FAR *pInVar,
            /* [retval][out] */ VARIANT __RPC_FAR *pOutVar) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE QueryStatus( 
            /* [in] */ DHTMLEDITCMDID cmdID,
            /* [retval][out] */ DHTMLEDITCMDF __RPC_FAR *retval) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetContextMenu( 
            /* [in] */ VARIANT __RPC_FAR *menuStrings,
            /* [in] */ VARIANT __RPC_FAR *menuStates) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE NewDocument( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE LoadURL( 
            /* [in] */ BSTR url) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE FilterSourceCode( 
            /* [in] */ BSTR sourceCodeIn,
            /* [retval][out] */ BSTR __RPC_FAR *sourceCodeOut) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Refresh( void) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DOM( 
            /* [retval][out] */ /* external definition not present */ IHTMLDocument2 __RPC_FAR *__RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DocumentHTML( 
            /* [retval][out] */ BSTR __RPC_FAR *docHTML) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_DocumentHTML( 
            /* [in] */ BSTR docHTML) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ActivateApplets( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ActivateApplets( 
            /* [in] */ VARIANT_BOOL newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ActivateActiveXControls( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ActivateActiveXControls( 
            /* [in] */ VARIANT_BOOL newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ActivateDTCs( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ActivateDTCs( 
            /* [in] */ VARIANT_BOOL newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ShowDetails( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ShowDetails( 
            /* [in] */ VARIANT_BOOL newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ShowBorders( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ShowBorders( 
            /* [in] */ VARIANT_BOOL newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Appearance( 
            /* [retval][out] */ DHTMLEDITAPPEARANCE __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Appearance( 
            /* [in] */ DHTMLEDITAPPEARANCE newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Scrollbars( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Scrollbars( 
            /* [in] */ VARIANT_BOOL newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ScrollbarAppearance( 
            /* [retval][out] */ DHTMLEDITAPPEARANCE __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ScrollbarAppearance( 
            /* [in] */ DHTMLEDITAPPEARANCE newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SourceCodePreservation( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_SourceCodePreservation( 
            /* [in] */ VARIANT_BOOL newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AbsoluteDropMode( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_AbsoluteDropMode( 
            /* [in] */ VARIANT_BOOL newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SnapToGridX( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_SnapToGridX( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SnapToGridY( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_SnapToGridY( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SnapToGrid( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_SnapToGrid( 
            /* [in] */ VARIANT_BOOL newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_IsDirty( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CurrentDocumentPath( 
            /* [retval][out] */ BSTR __RPC_FAR *docPath) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_BaseURL( 
            /* [retval][out] */ BSTR __RPC_FAR *baseURL) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_BaseURL( 
            /* [in] */ BSTR baseURL) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DocumentTitle( 
            /* [retval][out] */ BSTR __RPC_FAR *docTitle) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_UseDivOnCarriageReturn( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_UseDivOnCarriageReturn( 
            /* [in] */ VARIANT_BOOL newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Busy( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDHTMLSafeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDHTMLSafe __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDHTMLSafe __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDHTMLSafe __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDHTMLSafe __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDHTMLSafe __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDHTMLSafe __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDHTMLSafe __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ExecCommand )( 
            IDHTMLSafe __RPC_FAR * This,
            /* [in] */ DHTMLEDITCMDID cmdID,
            /* [defaultvalue][in] */ OLECMDEXECOPT cmdexecopt,
            /* [optional][in] */ VARIANT __RPC_FAR *pInVar,
            /* [retval][out] */ VARIANT __RPC_FAR *pOutVar);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryStatus )( 
            IDHTMLSafe __RPC_FAR * This,
            /* [in] */ DHTMLEDITCMDID cmdID,
            /* [retval][out] */ DHTMLEDITCMDF __RPC_FAR *retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetContextMenu )( 
            IDHTMLSafe __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *menuStrings,
            /* [in] */ VARIANT __RPC_FAR *menuStates);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NewDocument )( 
            IDHTMLSafe __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LoadURL )( 
            IDHTMLSafe __RPC_FAR * This,
            /* [in] */ BSTR url);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FilterSourceCode )( 
            IDHTMLSafe __RPC_FAR * This,
            /* [in] */ BSTR sourceCodeIn,
            /* [retval][out] */ BSTR __RPC_FAR *sourceCodeOut);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Refresh )( 
            IDHTMLSafe __RPC_FAR * This);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DOM )( 
            IDHTMLSafe __RPC_FAR * This,
            /* [retval][out] */ /* external definition not present */ IHTMLDocument2 __RPC_FAR *__RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DocumentHTML )( 
            IDHTMLSafe __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *docHTML);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_DocumentHTML )( 
            IDHTMLSafe __RPC_FAR * This,
            /* [in] */ BSTR docHTML);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ActivateApplets )( 
            IDHTMLSafe __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ActivateApplets )( 
            IDHTMLSafe __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ActivateActiveXControls )( 
            IDHTMLSafe __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ActivateActiveXControls )( 
            IDHTMLSafe __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ActivateDTCs )( 
            IDHTMLSafe __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ActivateDTCs )( 
            IDHTMLSafe __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ShowDetails )( 
            IDHTMLSafe __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ShowDetails )( 
            IDHTMLSafe __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ShowBorders )( 
            IDHTMLSafe __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ShowBorders )( 
            IDHTMLSafe __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Appearance )( 
            IDHTMLSafe __RPC_FAR * This,
            /* [retval][out] */ DHTMLEDITAPPEARANCE __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Appearance )( 
            IDHTMLSafe __RPC_FAR * This,
            /* [in] */ DHTMLEDITAPPEARANCE newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Scrollbars )( 
            IDHTMLSafe __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Scrollbars )( 
            IDHTMLSafe __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ScrollbarAppearance )( 
            IDHTMLSafe __RPC_FAR * This,
            /* [retval][out] */ DHTMLEDITAPPEARANCE __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ScrollbarAppearance )( 
            IDHTMLSafe __RPC_FAR * This,
            /* [in] */ DHTMLEDITAPPEARANCE newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SourceCodePreservation )( 
            IDHTMLSafe __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_SourceCodePreservation )( 
            IDHTMLSafe __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_AbsoluteDropMode )( 
            IDHTMLSafe __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_AbsoluteDropMode )( 
            IDHTMLSafe __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SnapToGridX )( 
            IDHTMLSafe __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_SnapToGridX )( 
            IDHTMLSafe __RPC_FAR * This,
            /* [in] */ long newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SnapToGridY )( 
            IDHTMLSafe __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_SnapToGridY )( 
            IDHTMLSafe __RPC_FAR * This,
            /* [in] */ long newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SnapToGrid )( 
            IDHTMLSafe __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_SnapToGrid )( 
            IDHTMLSafe __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_IsDirty )( 
            IDHTMLSafe __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CurrentDocumentPath )( 
            IDHTMLSafe __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *docPath);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_BaseURL )( 
            IDHTMLSafe __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *baseURL);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_BaseURL )( 
            IDHTMLSafe __RPC_FAR * This,
            /* [in] */ BSTR baseURL);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DocumentTitle )( 
            IDHTMLSafe __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *docTitle);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_UseDivOnCarriageReturn )( 
            IDHTMLSafe __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_UseDivOnCarriageReturn )( 
            IDHTMLSafe __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Busy )( 
            IDHTMLSafe __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        END_INTERFACE
    } IDHTMLSafeVtbl;

    interface IDHTMLSafe
    {
        CONST_VTBL struct IDHTMLSafeVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDHTMLSafe_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDHTMLSafe_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDHTMLSafe_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDHTMLSafe_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDHTMLSafe_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDHTMLSafe_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDHTMLSafe_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDHTMLSafe_ExecCommand(This,cmdID,cmdexecopt,pInVar,pOutVar)	\
    (This)->lpVtbl -> ExecCommand(This,cmdID,cmdexecopt,pInVar,pOutVar)

#define IDHTMLSafe_QueryStatus(This,cmdID,retval)	\
    (This)->lpVtbl -> QueryStatus(This,cmdID,retval)

#define IDHTMLSafe_SetContextMenu(This,menuStrings,menuStates)	\
    (This)->lpVtbl -> SetContextMenu(This,menuStrings,menuStates)

#define IDHTMLSafe_NewDocument(This)	\
    (This)->lpVtbl -> NewDocument(This)

#define IDHTMLSafe_LoadURL(This,url)	\
    (This)->lpVtbl -> LoadURL(This,url)

#define IDHTMLSafe_FilterSourceCode(This,sourceCodeIn,sourceCodeOut)	\
    (This)->lpVtbl -> FilterSourceCode(This,sourceCodeIn,sourceCodeOut)

#define IDHTMLSafe_Refresh(This)	\
    (This)->lpVtbl -> Refresh(This)

#define IDHTMLSafe_get_DOM(This,pVal)	\
    (This)->lpVtbl -> get_DOM(This,pVal)

#define IDHTMLSafe_get_DocumentHTML(This,docHTML)	\
    (This)->lpVtbl -> get_DocumentHTML(This,docHTML)

#define IDHTMLSafe_put_DocumentHTML(This,docHTML)	\
    (This)->lpVtbl -> put_DocumentHTML(This,docHTML)

#define IDHTMLSafe_get_ActivateApplets(This,pVal)	\
    (This)->lpVtbl -> get_ActivateApplets(This,pVal)

#define IDHTMLSafe_put_ActivateApplets(This,newVal)	\
    (This)->lpVtbl -> put_ActivateApplets(This,newVal)

#define IDHTMLSafe_get_ActivateActiveXControls(This,pVal)	\
    (This)->lpVtbl -> get_ActivateActiveXControls(This,pVal)

#define IDHTMLSafe_put_ActivateActiveXControls(This,newVal)	\
    (This)->lpVtbl -> put_ActivateActiveXControls(This,newVal)

#define IDHTMLSafe_get_ActivateDTCs(This,pVal)	\
    (This)->lpVtbl -> get_ActivateDTCs(This,pVal)

#define IDHTMLSafe_put_ActivateDTCs(This,newVal)	\
    (This)->lpVtbl -> put_ActivateDTCs(This,newVal)

#define IDHTMLSafe_get_ShowDetails(This,pVal)	\
    (This)->lpVtbl -> get_ShowDetails(This,pVal)

#define IDHTMLSafe_put_ShowDetails(This,newVal)	\
    (This)->lpVtbl -> put_ShowDetails(This,newVal)

#define IDHTMLSafe_get_ShowBorders(This,pVal)	\
    (This)->lpVtbl -> get_ShowBorders(This,pVal)

#define IDHTMLSafe_put_ShowBorders(This,newVal)	\
    (This)->lpVtbl -> put_ShowBorders(This,newVal)

#define IDHTMLSafe_get_Appearance(This,pVal)	\
    (This)->lpVtbl -> get_Appearance(This,pVal)

#define IDHTMLSafe_put_Appearance(This,newVal)	\
    (This)->lpVtbl -> put_Appearance(This,newVal)

#define IDHTMLSafe_get_Scrollbars(This,pVal)	\
    (This)->lpVtbl -> get_Scrollbars(This,pVal)

#define IDHTMLSafe_put_Scrollbars(This,newVal)	\
    (This)->lpVtbl -> put_Scrollbars(This,newVal)

#define IDHTMLSafe_get_ScrollbarAppearance(This,pVal)	\
    (This)->lpVtbl -> get_ScrollbarAppearance(This,pVal)

#define IDHTMLSafe_put_ScrollbarAppearance(This,newVal)	\
    (This)->lpVtbl -> put_ScrollbarAppearance(This,newVal)

#define IDHTMLSafe_get_SourceCodePreservation(This,pVal)	\
    (This)->lpVtbl -> get_SourceCodePreservation(This,pVal)

#define IDHTMLSafe_put_SourceCodePreservation(This,newVal)	\
    (This)->lpVtbl -> put_SourceCodePreservation(This,newVal)

#define IDHTMLSafe_get_AbsoluteDropMode(This,pVal)	\
    (This)->lpVtbl -> get_AbsoluteDropMode(This,pVal)

#define IDHTMLSafe_put_AbsoluteDropMode(This,newVal)	\
    (This)->lpVtbl -> put_AbsoluteDropMode(This,newVal)

#define IDHTMLSafe_get_SnapToGridX(This,pVal)	\
    (This)->lpVtbl -> get_SnapToGridX(This,pVal)

#define IDHTMLSafe_put_SnapToGridX(This,newVal)	\
    (This)->lpVtbl -> put_SnapToGridX(This,newVal)

#define IDHTMLSafe_get_SnapToGridY(This,pVal)	\
    (This)->lpVtbl -> get_SnapToGridY(This,pVal)

#define IDHTMLSafe_put_SnapToGridY(This,newVal)	\
    (This)->lpVtbl -> put_SnapToGridY(This,newVal)

#define IDHTMLSafe_get_SnapToGrid(This,pVal)	\
    (This)->lpVtbl -> get_SnapToGrid(This,pVal)

#define IDHTMLSafe_put_SnapToGrid(This,newVal)	\
    (This)->lpVtbl -> put_SnapToGrid(This,newVal)

#define IDHTMLSafe_get_IsDirty(This,pVal)	\
    (This)->lpVtbl -> get_IsDirty(This,pVal)

#define IDHTMLSafe_get_CurrentDocumentPath(This,docPath)	\
    (This)->lpVtbl -> get_CurrentDocumentPath(This,docPath)

#define IDHTMLSafe_get_BaseURL(This,baseURL)	\
    (This)->lpVtbl -> get_BaseURL(This,baseURL)

#define IDHTMLSafe_put_BaseURL(This,baseURL)	\
    (This)->lpVtbl -> put_BaseURL(This,baseURL)

#define IDHTMLSafe_get_DocumentTitle(This,docTitle)	\
    (This)->lpVtbl -> get_DocumentTitle(This,docTitle)

#define IDHTMLSafe_get_UseDivOnCarriageReturn(This,pVal)	\
    (This)->lpVtbl -> get_UseDivOnCarriageReturn(This,pVal)

#define IDHTMLSafe_put_UseDivOnCarriageReturn(This,newVal)	\
    (This)->lpVtbl -> put_UseDivOnCarriageReturn(This,newVal)

#define IDHTMLSafe_get_Busy(This,pVal)	\
    (This)->lpVtbl -> get_Busy(This,pVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IDHTMLSafe_ExecCommand_Proxy( 
    IDHTMLSafe __RPC_FAR * This,
    /* [in] */ DHTMLEDITCMDID cmdID,
    /* [defaultvalue][in] */ OLECMDEXECOPT cmdexecopt,
    /* [optional][in] */ VARIANT __RPC_FAR *pInVar,
    /* [retval][out] */ VARIANT __RPC_FAR *pOutVar);


void __RPC_STUB IDHTMLSafe_ExecCommand_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IDHTMLSafe_QueryStatus_Proxy( 
    IDHTMLSafe __RPC_FAR * This,
    /* [in] */ DHTMLEDITCMDID cmdID,
    /* [retval][out] */ DHTMLEDITCMDF __RPC_FAR *retval);


void __RPC_STUB IDHTMLSafe_QueryStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IDHTMLSafe_SetContextMenu_Proxy( 
    IDHTMLSafe __RPC_FAR * This,
    /* [in] */ VARIANT __RPC_FAR *menuStrings,
    /* [in] */ VARIANT __RPC_FAR *menuStates);


void __RPC_STUB IDHTMLSafe_SetContextMenu_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IDHTMLSafe_NewDocument_Proxy( 
    IDHTMLSafe __RPC_FAR * This);


void __RPC_STUB IDHTMLSafe_NewDocument_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IDHTMLSafe_LoadURL_Proxy( 
    IDHTMLSafe __RPC_FAR * This,
    /* [in] */ BSTR url);


void __RPC_STUB IDHTMLSafe_LoadURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IDHTMLSafe_FilterSourceCode_Proxy( 
    IDHTMLSafe __RPC_FAR * This,
    /* [in] */ BSTR sourceCodeIn,
    /* [retval][out] */ BSTR __RPC_FAR *sourceCodeOut);


void __RPC_STUB IDHTMLSafe_FilterSourceCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IDHTMLSafe_Refresh_Proxy( 
    IDHTMLSafe __RPC_FAR * This);


void __RPC_STUB IDHTMLSafe_Refresh_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDHTMLSafe_get_DOM_Proxy( 
    IDHTMLSafe __RPC_FAR * This,
    /* [retval][out] */ /* external definition not present */ IHTMLDocument2 __RPC_FAR *__RPC_FAR *pVal);


void __RPC_STUB IDHTMLSafe_get_DOM_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDHTMLSafe_get_DocumentHTML_Proxy( 
    IDHTMLSafe __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *docHTML);


void __RPC_STUB IDHTMLSafe_get_DocumentHTML_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDHTMLSafe_put_DocumentHTML_Proxy( 
    IDHTMLSafe __RPC_FAR * This,
    /* [in] */ BSTR docHTML);


void __RPC_STUB IDHTMLSafe_put_DocumentHTML_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDHTMLSafe_get_ActivateApplets_Proxy( 
    IDHTMLSafe __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);


void __RPC_STUB IDHTMLSafe_get_ActivateApplets_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDHTMLSafe_put_ActivateApplets_Proxy( 
    IDHTMLSafe __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL newVal);


void __RPC_STUB IDHTMLSafe_put_ActivateApplets_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDHTMLSafe_get_ActivateActiveXControls_Proxy( 
    IDHTMLSafe __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);


void __RPC_STUB IDHTMLSafe_get_ActivateActiveXControls_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDHTMLSafe_put_ActivateActiveXControls_Proxy( 
    IDHTMLSafe __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL newVal);


void __RPC_STUB IDHTMLSafe_put_ActivateActiveXControls_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDHTMLSafe_get_ActivateDTCs_Proxy( 
    IDHTMLSafe __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);


void __RPC_STUB IDHTMLSafe_get_ActivateDTCs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDHTMLSafe_put_ActivateDTCs_Proxy( 
    IDHTMLSafe __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL newVal);


void __RPC_STUB IDHTMLSafe_put_ActivateDTCs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDHTMLSafe_get_ShowDetails_Proxy( 
    IDHTMLSafe __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);


void __RPC_STUB IDHTMLSafe_get_ShowDetails_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDHTMLSafe_put_ShowDetails_Proxy( 
    IDHTMLSafe __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL newVal);


void __RPC_STUB IDHTMLSafe_put_ShowDetails_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDHTMLSafe_get_ShowBorders_Proxy( 
    IDHTMLSafe __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);


void __RPC_STUB IDHTMLSafe_get_ShowBorders_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDHTMLSafe_put_ShowBorders_Proxy( 
    IDHTMLSafe __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL newVal);


void __RPC_STUB IDHTMLSafe_put_ShowBorders_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDHTMLSafe_get_Appearance_Proxy( 
    IDHTMLSafe __RPC_FAR * This,
    /* [retval][out] */ DHTMLEDITAPPEARANCE __RPC_FAR *pVal);


void __RPC_STUB IDHTMLSafe_get_Appearance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDHTMLSafe_put_Appearance_Proxy( 
    IDHTMLSafe __RPC_FAR * This,
    /* [in] */ DHTMLEDITAPPEARANCE newVal);


void __RPC_STUB IDHTMLSafe_put_Appearance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDHTMLSafe_get_Scrollbars_Proxy( 
    IDHTMLSafe __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);


void __RPC_STUB IDHTMLSafe_get_Scrollbars_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDHTMLSafe_put_Scrollbars_Proxy( 
    IDHTMLSafe __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL newVal);


void __RPC_STUB IDHTMLSafe_put_Scrollbars_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDHTMLSafe_get_ScrollbarAppearance_Proxy( 
    IDHTMLSafe __RPC_FAR * This,
    /* [retval][out] */ DHTMLEDITAPPEARANCE __RPC_FAR *pVal);


void __RPC_STUB IDHTMLSafe_get_ScrollbarAppearance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDHTMLSafe_put_ScrollbarAppearance_Proxy( 
    IDHTMLSafe __RPC_FAR * This,
    /* [in] */ DHTMLEDITAPPEARANCE newVal);


void __RPC_STUB IDHTMLSafe_put_ScrollbarAppearance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDHTMLSafe_get_SourceCodePreservation_Proxy( 
    IDHTMLSafe __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);


void __RPC_STUB IDHTMLSafe_get_SourceCodePreservation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDHTMLSafe_put_SourceCodePreservation_Proxy( 
    IDHTMLSafe __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL newVal);


void __RPC_STUB IDHTMLSafe_put_SourceCodePreservation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDHTMLSafe_get_AbsoluteDropMode_Proxy( 
    IDHTMLSafe __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);


void __RPC_STUB IDHTMLSafe_get_AbsoluteDropMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDHTMLSafe_put_AbsoluteDropMode_Proxy( 
    IDHTMLSafe __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL newVal);


void __RPC_STUB IDHTMLSafe_put_AbsoluteDropMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDHTMLSafe_get_SnapToGridX_Proxy( 
    IDHTMLSafe __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IDHTMLSafe_get_SnapToGridX_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDHTMLSafe_put_SnapToGridX_Proxy( 
    IDHTMLSafe __RPC_FAR * This,
    /* [in] */ long newVal);


void __RPC_STUB IDHTMLSafe_put_SnapToGridX_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDHTMLSafe_get_SnapToGridY_Proxy( 
    IDHTMLSafe __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IDHTMLSafe_get_SnapToGridY_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDHTMLSafe_put_SnapToGridY_Proxy( 
    IDHTMLSafe __RPC_FAR * This,
    /* [in] */ long newVal);


void __RPC_STUB IDHTMLSafe_put_SnapToGridY_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDHTMLSafe_get_SnapToGrid_Proxy( 
    IDHTMLSafe __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);


void __RPC_STUB IDHTMLSafe_get_SnapToGrid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDHTMLSafe_put_SnapToGrid_Proxy( 
    IDHTMLSafe __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL newVal);


void __RPC_STUB IDHTMLSafe_put_SnapToGrid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDHTMLSafe_get_IsDirty_Proxy( 
    IDHTMLSafe __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);


void __RPC_STUB IDHTMLSafe_get_IsDirty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDHTMLSafe_get_CurrentDocumentPath_Proxy( 
    IDHTMLSafe __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *docPath);


void __RPC_STUB IDHTMLSafe_get_CurrentDocumentPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDHTMLSafe_get_BaseURL_Proxy( 
    IDHTMLSafe __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *baseURL);


void __RPC_STUB IDHTMLSafe_get_BaseURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDHTMLSafe_put_BaseURL_Proxy( 
    IDHTMLSafe __RPC_FAR * This,
    /* [in] */ BSTR baseURL);


void __RPC_STUB IDHTMLSafe_put_BaseURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDHTMLSafe_get_DocumentTitle_Proxy( 
    IDHTMLSafe __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *docTitle);


void __RPC_STUB IDHTMLSafe_get_DocumentTitle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDHTMLSafe_get_UseDivOnCarriageReturn_Proxy( 
    IDHTMLSafe __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);


void __RPC_STUB IDHTMLSafe_get_UseDivOnCarriageReturn_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDHTMLSafe_put_UseDivOnCarriageReturn_Proxy( 
    IDHTMLSafe __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL newVal);


void __RPC_STUB IDHTMLSafe_put_UseDivOnCarriageReturn_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDHTMLSafe_get_Busy_Proxy( 
    IDHTMLSafe __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);


void __RPC_STUB IDHTMLSafe_get_Busy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDHTMLSafe_INTERFACE_DEFINED__ */


#ifndef __IDHTMLEdit_INTERFACE_DEFINED__
#define __IDHTMLEdit_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDHTMLEdit
 * at Thu Aug 06 10:08:26 1998
 * using MIDL 3.03.0110
 ****************************************/
/* [object][unique][helpstring][dual][uuid] */ 



EXTERN_C const IID IID_IDHTMLEdit;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CE04B591-2B1F-11d2-8D1E-00A0C959BC0A")
    IDHTMLEdit : public IDHTMLSafe
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE LoadDocument( 
            /* [in] */ VARIANT __RPC_FAR *pathIn,
            /* [optional][in] */ VARIANT __RPC_FAR *promptUser) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SaveDocument( 
            /* [in] */ VARIANT __RPC_FAR *pathIn,
            /* [optional][in] */ VARIANT __RPC_FAR *promptUser) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE PrintDocument( 
            /* [optional][in] */ VARIANT __RPC_FAR *withUI) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_BrowseMode( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_BrowseMode( 
            /* [in] */ VARIANT_BOOL newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDHTMLEditVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDHTMLEdit __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDHTMLEdit __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDHTMLEdit __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDHTMLEdit __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDHTMLEdit __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDHTMLEdit __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDHTMLEdit __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ExecCommand )( 
            IDHTMLEdit __RPC_FAR * This,
            /* [in] */ DHTMLEDITCMDID cmdID,
            /* [defaultvalue][in] */ OLECMDEXECOPT cmdexecopt,
            /* [optional][in] */ VARIANT __RPC_FAR *pInVar,
            /* [retval][out] */ VARIANT __RPC_FAR *pOutVar);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryStatus )( 
            IDHTMLEdit __RPC_FAR * This,
            /* [in] */ DHTMLEDITCMDID cmdID,
            /* [retval][out] */ DHTMLEDITCMDF __RPC_FAR *retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetContextMenu )( 
            IDHTMLEdit __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *menuStrings,
            /* [in] */ VARIANT __RPC_FAR *menuStates);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NewDocument )( 
            IDHTMLEdit __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LoadURL )( 
            IDHTMLEdit __RPC_FAR * This,
            /* [in] */ BSTR url);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FilterSourceCode )( 
            IDHTMLEdit __RPC_FAR * This,
            /* [in] */ BSTR sourceCodeIn,
            /* [retval][out] */ BSTR __RPC_FAR *sourceCodeOut);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Refresh )( 
            IDHTMLEdit __RPC_FAR * This);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DOM )( 
            IDHTMLEdit __RPC_FAR * This,
            /* [retval][out] */ /* external definition not present */ IHTMLDocument2 __RPC_FAR *__RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DocumentHTML )( 
            IDHTMLEdit __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *docHTML);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_DocumentHTML )( 
            IDHTMLEdit __RPC_FAR * This,
            /* [in] */ BSTR docHTML);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ActivateApplets )( 
            IDHTMLEdit __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ActivateApplets )( 
            IDHTMLEdit __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ActivateActiveXControls )( 
            IDHTMLEdit __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ActivateActiveXControls )( 
            IDHTMLEdit __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ActivateDTCs )( 
            IDHTMLEdit __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ActivateDTCs )( 
            IDHTMLEdit __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ShowDetails )( 
            IDHTMLEdit __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ShowDetails )( 
            IDHTMLEdit __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ShowBorders )( 
            IDHTMLEdit __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ShowBorders )( 
            IDHTMLEdit __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Appearance )( 
            IDHTMLEdit __RPC_FAR * This,
            /* [retval][out] */ DHTMLEDITAPPEARANCE __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Appearance )( 
            IDHTMLEdit __RPC_FAR * This,
            /* [in] */ DHTMLEDITAPPEARANCE newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Scrollbars )( 
            IDHTMLEdit __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Scrollbars )( 
            IDHTMLEdit __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ScrollbarAppearance )( 
            IDHTMLEdit __RPC_FAR * This,
            /* [retval][out] */ DHTMLEDITAPPEARANCE __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ScrollbarAppearance )( 
            IDHTMLEdit __RPC_FAR * This,
            /* [in] */ DHTMLEDITAPPEARANCE newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SourceCodePreservation )( 
            IDHTMLEdit __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_SourceCodePreservation )( 
            IDHTMLEdit __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_AbsoluteDropMode )( 
            IDHTMLEdit __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_AbsoluteDropMode )( 
            IDHTMLEdit __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SnapToGridX )( 
            IDHTMLEdit __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_SnapToGridX )( 
            IDHTMLEdit __RPC_FAR * This,
            /* [in] */ long newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SnapToGridY )( 
            IDHTMLEdit __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_SnapToGridY )( 
            IDHTMLEdit __RPC_FAR * This,
            /* [in] */ long newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SnapToGrid )( 
            IDHTMLEdit __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_SnapToGrid )( 
            IDHTMLEdit __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_IsDirty )( 
            IDHTMLEdit __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CurrentDocumentPath )( 
            IDHTMLEdit __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *docPath);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_BaseURL )( 
            IDHTMLEdit __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *baseURL);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_BaseURL )( 
            IDHTMLEdit __RPC_FAR * This,
            /* [in] */ BSTR baseURL);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DocumentTitle )( 
            IDHTMLEdit __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *docTitle);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_UseDivOnCarriageReturn )( 
            IDHTMLEdit __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_UseDivOnCarriageReturn )( 
            IDHTMLEdit __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Busy )( 
            IDHTMLEdit __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LoadDocument )( 
            IDHTMLEdit __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *pathIn,
            /* [optional][in] */ VARIANT __RPC_FAR *promptUser);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SaveDocument )( 
            IDHTMLEdit __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *pathIn,
            /* [optional][in] */ VARIANT __RPC_FAR *promptUser);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PrintDocument )( 
            IDHTMLEdit __RPC_FAR * This,
            /* [optional][in] */ VARIANT __RPC_FAR *withUI);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_BrowseMode )( 
            IDHTMLEdit __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_BrowseMode )( 
            IDHTMLEdit __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        END_INTERFACE
    } IDHTMLEditVtbl;

    interface IDHTMLEdit
    {
        CONST_VTBL struct IDHTMLEditVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDHTMLEdit_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDHTMLEdit_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDHTMLEdit_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDHTMLEdit_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDHTMLEdit_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDHTMLEdit_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDHTMLEdit_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDHTMLEdit_ExecCommand(This,cmdID,cmdexecopt,pInVar,pOutVar)	\
    (This)->lpVtbl -> ExecCommand(This,cmdID,cmdexecopt,pInVar,pOutVar)

#define IDHTMLEdit_QueryStatus(This,cmdID,retval)	\
    (This)->lpVtbl -> QueryStatus(This,cmdID,retval)

#define IDHTMLEdit_SetContextMenu(This,menuStrings,menuStates)	\
    (This)->lpVtbl -> SetContextMenu(This,menuStrings,menuStates)

#define IDHTMLEdit_NewDocument(This)	\
    (This)->lpVtbl -> NewDocument(This)

#define IDHTMLEdit_LoadURL(This,url)	\
    (This)->lpVtbl -> LoadURL(This,url)

#define IDHTMLEdit_FilterSourceCode(This,sourceCodeIn,sourceCodeOut)	\
    (This)->lpVtbl -> FilterSourceCode(This,sourceCodeIn,sourceCodeOut)

#define IDHTMLEdit_Refresh(This)	\
    (This)->lpVtbl -> Refresh(This)

#define IDHTMLEdit_get_DOM(This,pVal)	\
    (This)->lpVtbl -> get_DOM(This,pVal)

#define IDHTMLEdit_get_DocumentHTML(This,docHTML)	\
    (This)->lpVtbl -> get_DocumentHTML(This,docHTML)

#define IDHTMLEdit_put_DocumentHTML(This,docHTML)	\
    (This)->lpVtbl -> put_DocumentHTML(This,docHTML)

#define IDHTMLEdit_get_ActivateApplets(This,pVal)	\
    (This)->lpVtbl -> get_ActivateApplets(This,pVal)

#define IDHTMLEdit_put_ActivateApplets(This,newVal)	\
    (This)->lpVtbl -> put_ActivateApplets(This,newVal)

#define IDHTMLEdit_get_ActivateActiveXControls(This,pVal)	\
    (This)->lpVtbl -> get_ActivateActiveXControls(This,pVal)

#define IDHTMLEdit_put_ActivateActiveXControls(This,newVal)	\
    (This)->lpVtbl -> put_ActivateActiveXControls(This,newVal)

#define IDHTMLEdit_get_ActivateDTCs(This,pVal)	\
    (This)->lpVtbl -> get_ActivateDTCs(This,pVal)

#define IDHTMLEdit_put_ActivateDTCs(This,newVal)	\
    (This)->lpVtbl -> put_ActivateDTCs(This,newVal)

#define IDHTMLEdit_get_ShowDetails(This,pVal)	\
    (This)->lpVtbl -> get_ShowDetails(This,pVal)

#define IDHTMLEdit_put_ShowDetails(This,newVal)	\
    (This)->lpVtbl -> put_ShowDetails(This,newVal)

#define IDHTMLEdit_get_ShowBorders(This,pVal)	\
    (This)->lpVtbl -> get_ShowBorders(This,pVal)

#define IDHTMLEdit_put_ShowBorders(This,newVal)	\
    (This)->lpVtbl -> put_ShowBorders(This,newVal)

#define IDHTMLEdit_get_Appearance(This,pVal)	\
    (This)->lpVtbl -> get_Appearance(This,pVal)

#define IDHTMLEdit_put_Appearance(This,newVal)	\
    (This)->lpVtbl -> put_Appearance(This,newVal)

#define IDHTMLEdit_get_Scrollbars(This,pVal)	\
    (This)->lpVtbl -> get_Scrollbars(This,pVal)

#define IDHTMLEdit_put_Scrollbars(This,newVal)	\
    (This)->lpVtbl -> put_Scrollbars(This,newVal)

#define IDHTMLEdit_get_ScrollbarAppearance(This,pVal)	\
    (This)->lpVtbl -> get_ScrollbarAppearance(This,pVal)

#define IDHTMLEdit_put_ScrollbarAppearance(This,newVal)	\
    (This)->lpVtbl -> put_ScrollbarAppearance(This,newVal)

#define IDHTMLEdit_get_SourceCodePreservation(This,pVal)	\
    (This)->lpVtbl -> get_SourceCodePreservation(This,pVal)

#define IDHTMLEdit_put_SourceCodePreservation(This,newVal)	\
    (This)->lpVtbl -> put_SourceCodePreservation(This,newVal)

#define IDHTMLEdit_get_AbsoluteDropMode(This,pVal)	\
    (This)->lpVtbl -> get_AbsoluteDropMode(This,pVal)

#define IDHTMLEdit_put_AbsoluteDropMode(This,newVal)	\
    (This)->lpVtbl -> put_AbsoluteDropMode(This,newVal)

#define IDHTMLEdit_get_SnapToGridX(This,pVal)	\
    (This)->lpVtbl -> get_SnapToGridX(This,pVal)

#define IDHTMLEdit_put_SnapToGridX(This,newVal)	\
    (This)->lpVtbl -> put_SnapToGridX(This,newVal)

#define IDHTMLEdit_get_SnapToGridY(This,pVal)	\
    (This)->lpVtbl -> get_SnapToGridY(This,pVal)

#define IDHTMLEdit_put_SnapToGridY(This,newVal)	\
    (This)->lpVtbl -> put_SnapToGridY(This,newVal)

#define IDHTMLEdit_get_SnapToGrid(This,pVal)	\
    (This)->lpVtbl -> get_SnapToGrid(This,pVal)

#define IDHTMLEdit_put_SnapToGrid(This,newVal)	\
    (This)->lpVtbl -> put_SnapToGrid(This,newVal)

#define IDHTMLEdit_get_IsDirty(This,pVal)	\
    (This)->lpVtbl -> get_IsDirty(This,pVal)

#define IDHTMLEdit_get_CurrentDocumentPath(This,docPath)	\
    (This)->lpVtbl -> get_CurrentDocumentPath(This,docPath)

#define IDHTMLEdit_get_BaseURL(This,baseURL)	\
    (This)->lpVtbl -> get_BaseURL(This,baseURL)

#define IDHTMLEdit_put_BaseURL(This,baseURL)	\
    (This)->lpVtbl -> put_BaseURL(This,baseURL)

#define IDHTMLEdit_get_DocumentTitle(This,docTitle)	\
    (This)->lpVtbl -> get_DocumentTitle(This,docTitle)

#define IDHTMLEdit_get_UseDivOnCarriageReturn(This,pVal)	\
    (This)->lpVtbl -> get_UseDivOnCarriageReturn(This,pVal)

#define IDHTMLEdit_put_UseDivOnCarriageReturn(This,newVal)	\
    (This)->lpVtbl -> put_UseDivOnCarriageReturn(This,newVal)

#define IDHTMLEdit_get_Busy(This,pVal)	\
    (This)->lpVtbl -> get_Busy(This,pVal)


#define IDHTMLEdit_LoadDocument(This,pathIn,promptUser)	\
    (This)->lpVtbl -> LoadDocument(This,pathIn,promptUser)

#define IDHTMLEdit_SaveDocument(This,pathIn,promptUser)	\
    (This)->lpVtbl -> SaveDocument(This,pathIn,promptUser)

#define IDHTMLEdit_PrintDocument(This,withUI)	\
    (This)->lpVtbl -> PrintDocument(This,withUI)

#define IDHTMLEdit_get_BrowseMode(This,pVal)	\
    (This)->lpVtbl -> get_BrowseMode(This,pVal)

#define IDHTMLEdit_put_BrowseMode(This,newVal)	\
    (This)->lpVtbl -> put_BrowseMode(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IDHTMLEdit_LoadDocument_Proxy( 
    IDHTMLEdit __RPC_FAR * This,
    /* [in] */ VARIANT __RPC_FAR *pathIn,
    /* [optional][in] */ VARIANT __RPC_FAR *promptUser);


void __RPC_STUB IDHTMLEdit_LoadDocument_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IDHTMLEdit_SaveDocument_Proxy( 
    IDHTMLEdit __RPC_FAR * This,
    /* [in] */ VARIANT __RPC_FAR *pathIn,
    /* [optional][in] */ VARIANT __RPC_FAR *promptUser);


void __RPC_STUB IDHTMLEdit_SaveDocument_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IDHTMLEdit_PrintDocument_Proxy( 
    IDHTMLEdit __RPC_FAR * This,
    /* [optional][in] */ VARIANT __RPC_FAR *withUI);


void __RPC_STUB IDHTMLEdit_PrintDocument_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDHTMLEdit_get_BrowseMode_Proxy( 
    IDHTMLEdit __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);


void __RPC_STUB IDHTMLEdit_get_BrowseMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDHTMLEdit_put_BrowseMode_Proxy( 
    IDHTMLEdit __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL newVal);


void __RPC_STUB IDHTMLEdit_put_BrowseMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDHTMLEdit_INTERFACE_DEFINED__ */


#ifndef __IDEInsertTableParam_INTERFACE_DEFINED__
#define __IDEInsertTableParam_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDEInsertTableParam
 * at Thu Aug 06 10:08:26 1998
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_IDEInsertTableParam;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("47B0DFC6-B7A3-11D1-ADC5-006008A5848C")
    IDEInsertTableParam : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_NumRows( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_NumRows( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_NumCols( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_NumCols( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TableAttrs( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_TableAttrs( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CellAttrs( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_CellAttrs( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Caption( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Caption( 
            /* [in] */ BSTR newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDEInsertTableParamVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDEInsertTableParam __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDEInsertTableParam __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDEInsertTableParam __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDEInsertTableParam __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDEInsertTableParam __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDEInsertTableParam __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDEInsertTableParam __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_NumRows )( 
            IDEInsertTableParam __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_NumRows )( 
            IDEInsertTableParam __RPC_FAR * This,
            /* [in] */ long newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_NumCols )( 
            IDEInsertTableParam __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_NumCols )( 
            IDEInsertTableParam __RPC_FAR * This,
            /* [in] */ long newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_TableAttrs )( 
            IDEInsertTableParam __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_TableAttrs )( 
            IDEInsertTableParam __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CellAttrs )( 
            IDEInsertTableParam __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_CellAttrs )( 
            IDEInsertTableParam __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Caption )( 
            IDEInsertTableParam __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Caption )( 
            IDEInsertTableParam __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        END_INTERFACE
    } IDEInsertTableParamVtbl;

    interface IDEInsertTableParam
    {
        CONST_VTBL struct IDEInsertTableParamVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDEInsertTableParam_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDEInsertTableParam_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDEInsertTableParam_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDEInsertTableParam_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDEInsertTableParam_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDEInsertTableParam_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDEInsertTableParam_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDEInsertTableParam_get_NumRows(This,pVal)	\
    (This)->lpVtbl -> get_NumRows(This,pVal)

#define IDEInsertTableParam_put_NumRows(This,newVal)	\
    (This)->lpVtbl -> put_NumRows(This,newVal)

#define IDEInsertTableParam_get_NumCols(This,pVal)	\
    (This)->lpVtbl -> get_NumCols(This,pVal)

#define IDEInsertTableParam_put_NumCols(This,newVal)	\
    (This)->lpVtbl -> put_NumCols(This,newVal)

#define IDEInsertTableParam_get_TableAttrs(This,pVal)	\
    (This)->lpVtbl -> get_TableAttrs(This,pVal)

#define IDEInsertTableParam_put_TableAttrs(This,newVal)	\
    (This)->lpVtbl -> put_TableAttrs(This,newVal)

#define IDEInsertTableParam_get_CellAttrs(This,pVal)	\
    (This)->lpVtbl -> get_CellAttrs(This,pVal)

#define IDEInsertTableParam_put_CellAttrs(This,newVal)	\
    (This)->lpVtbl -> put_CellAttrs(This,newVal)

#define IDEInsertTableParam_get_Caption(This,pVal)	\
    (This)->lpVtbl -> get_Caption(This,pVal)

#define IDEInsertTableParam_put_Caption(This,newVal)	\
    (This)->lpVtbl -> put_Caption(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDEInsertTableParam_get_NumRows_Proxy( 
    IDEInsertTableParam __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IDEInsertTableParam_get_NumRows_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDEInsertTableParam_put_NumRows_Proxy( 
    IDEInsertTableParam __RPC_FAR * This,
    /* [in] */ long newVal);


void __RPC_STUB IDEInsertTableParam_put_NumRows_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDEInsertTableParam_get_NumCols_Proxy( 
    IDEInsertTableParam __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IDEInsertTableParam_get_NumCols_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDEInsertTableParam_put_NumCols_Proxy( 
    IDEInsertTableParam __RPC_FAR * This,
    /* [in] */ long newVal);


void __RPC_STUB IDEInsertTableParam_put_NumCols_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDEInsertTableParam_get_TableAttrs_Proxy( 
    IDEInsertTableParam __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IDEInsertTableParam_get_TableAttrs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDEInsertTableParam_put_TableAttrs_Proxy( 
    IDEInsertTableParam __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IDEInsertTableParam_put_TableAttrs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDEInsertTableParam_get_CellAttrs_Proxy( 
    IDEInsertTableParam __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IDEInsertTableParam_get_CellAttrs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDEInsertTableParam_put_CellAttrs_Proxy( 
    IDEInsertTableParam __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IDEInsertTableParam_put_CellAttrs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDEInsertTableParam_get_Caption_Proxy( 
    IDEInsertTableParam __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IDEInsertTableParam_get_Caption_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDEInsertTableParam_put_Caption_Proxy( 
    IDEInsertTableParam __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IDEInsertTableParam_put_Caption_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDEInsertTableParam_INTERFACE_DEFINED__ */


#ifndef ___DHTMLSafeEvents_DISPINTERFACE_DEFINED__
#define ___DHTMLSafeEvents_DISPINTERFACE_DEFINED__

/****************************************
 * Generated header for dispinterface: _DHTMLSafeEvents
 * at Thu Aug 06 10:08:26 1998
 * using MIDL 3.03.0110
 ****************************************/
/* [helpstring][uuid] */ 



EXTERN_C const IID DIID__DHTMLSafeEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("D1FC78E8-B380-11d1-ADC5-006008A5848C")
    _DHTMLSafeEvents : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct _DHTMLSafeEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            _DHTMLSafeEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            _DHTMLSafeEvents __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            _DHTMLSafeEvents __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            _DHTMLSafeEvents __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            _DHTMLSafeEvents __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            _DHTMLSafeEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            _DHTMLSafeEvents __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        END_INTERFACE
    } _DHTMLSafeEventsVtbl;

    interface _DHTMLSafeEvents
    {
        CONST_VTBL struct _DHTMLSafeEventsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define _DHTMLSafeEvents_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define _DHTMLSafeEvents_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define _DHTMLSafeEvents_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define _DHTMLSafeEvents_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define _DHTMLSafeEvents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define _DHTMLSafeEvents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define _DHTMLSafeEvents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* ___DHTMLSafeEvents_DISPINTERFACE_DEFINED__ */


#ifndef ___DHTMLEditEvents_DISPINTERFACE_DEFINED__
#define ___DHTMLEditEvents_DISPINTERFACE_DEFINED__

/****************************************
 * Generated header for dispinterface: _DHTMLEditEvents
 * at Thu Aug 06 10:08:26 1998
 * using MIDL 3.03.0110
 ****************************************/
/* [helpstring][uuid] */ 



EXTERN_C const IID DIID__DHTMLEditEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("588D5040-CF28-11d1-8CD3-00A0C959BC0A")
    _DHTMLEditEvents : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct _DHTMLEditEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            _DHTMLEditEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            _DHTMLEditEvents __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            _DHTMLEditEvents __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            _DHTMLEditEvents __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            _DHTMLEditEvents __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            _DHTMLEditEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            _DHTMLEditEvents __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        END_INTERFACE
    } _DHTMLEditEventsVtbl;

    interface _DHTMLEditEvents
    {
        CONST_VTBL struct _DHTMLEditEventsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define _DHTMLEditEvents_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define _DHTMLEditEvents_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define _DHTMLEditEvents_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define _DHTMLEditEvents_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define _DHTMLEditEvents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define _DHTMLEditEvents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define _DHTMLEditEvents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* ___DHTMLEditEvents_DISPINTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_DHTMLEdit;

#ifdef __cplusplus

class DECLSPEC_UUID("2D360200-FFF5-11d1-8D03-00A0C959BC0A")
DHTMLEdit;
#endif

EXTERN_C const CLSID CLSID_DHTMLSafe;

#ifdef __cplusplus

class DECLSPEC_UUID("2D360201-FFF5-11d1-8D03-00A0C959BC0A")
DHTMLSafe;
#endif

EXTERN_C const CLSID CLSID_DEInsertTableParam;

#ifdef __cplusplus

class DECLSPEC_UUID("47B0DFC7-B7A3-11D1-ADC5-006008A5848C")
DEInsertTableParam;
#endif

EXTERN_C const CLSID CLSID_DEGetBlockFmtNamesParam;

#ifdef __cplusplus

class DECLSPEC_UUID("8D91090E-B955-11D1-ADC5-006008A5848C")
DEGetBlockFmtNamesParam;
#endif
#endif /* __DHTMLEDLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\dhtmldid.h ===
// DISPIDs for DHTMLEd.OCX
// Copyright 1998-1999 Microsoft Corporation.  All rights reserved.

#ifndef __DHTMLDID_H_
#define __DHTMLDID_H_


// methods and properties
#define DISPID_LOADDOCUMENT             1
#define DISPID_EXECCOMMAND              2
#define DISPID_QUERYSTATUS              3
#define DISPID_SAVEDOCUMENT             4
#define DISPID_SETCONTEXTMENU           5
#define DISPID_DOCUMENT                 6
#define DISPID_ACTIVATEAPPLETS          7
#define DISPID_ACTIVATEACTIVEXCONTROLS  8
#define DISPID_ACTIVATEDTCS             9	
#define DISPID_SHOWDETAILS              11
#define DISPID_SHOWBORDERS              12
#define DISPID_DHTMLEDITAPPEARANCE      13
#define DISPID_DHTMLEDITSCROLLBARS      14
#define DISPID_SCROLLBARAPPEARANCE      15
#define DISPID_SOURCECODEPRESERVATION   16
#define DISPID_DOCUMENTHTML             17
#define DISPID_ABSOLUTEDROPMODE         18
#define DISPID_SNAPTOGRIDX              19
#define DISPID_SNAPTOGRIDY              20
#define DISPID_SNAPTOGRID               21
#define DISPID_ISDIRTY                  22
#define DISPID_CURRENTDOCUMENTPATH      23
#define DISPID_BASEURL                  24
#define DISPID_DOCUMENTTITLE            25
#define DISPID_BROWSEMODE               26
#define DISPID_NEWDOCUMENT              27
#define DISPID_PRINT                    28
#define DISPID_LOADURL                  29
#define DISPID_USEDIVONCR               30
#define DISPID_FILTERSRCCODE            31
#define DISPID_REFRESHDOC               32
#define DISPID_BUSY                     33

// events
#define	DISPID_DOCUMENTCOMPLETE	        1
#define	DISPID_DISPLAYCHANGED           2
#define	DISPID_SHOWCONTEXTMENU          3
#define	DISPID_CONTEXTMENUACTION        4
#define DISPID_ONMOUSEDOWN              5
#define DISPID_ONMOUSEMOVE              6
#define DISPID_ONMOUSEUP                7
#define DISPID_ONMOUSEOUT               8
#define DISPID_ONMOUSEOVER              9
#define DISPID_ONCLICK                  10
#define DISPID_ONDBLCLICK               11
#define DISPID_ONKEYDOWN                12
#define DISPID_ONKEYPRESS               13
#define DISPID_ONKEYUP                  14
#define DISPID_ONBLUR                   15
#define DISPID_ONREADYSTATECHANGE       16


#define DISPID_TABLEPARAMS_NUMROWS      1
#define DISPID_TABLEPARAMS_NUMCOLS      2
#define DISPID_TABLEPARAMS_TABLEATTRS   3
#define DISPID_TABLEPARAMS_CELLATTRS    4
#define DISPID_TABLEPARAMS_CAPTION      5

#define DISPID_NAMESPARAM_NAMES         1

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\public\wsdk\inc\dimm.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0334 */
/* Compiler settings for dimm.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __dimm_h__
#define __dimm_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IEnumRegisterWordA_FWD_DEFINED__
#define __IEnumRegisterWordA_FWD_DEFINED__
typedef interface IEnumRegisterWordA IEnumRegisterWordA;
#endif 	/* __IEnumRegisterWordA_FWD_DEFINED__ */


#ifndef __IEnumRegisterWordW_FWD_DEFINED__
#define __IEnumRegisterWordW_FWD_DEFINED__
typedef interface IEnumRegisterWordW IEnumRegisterWordW;
#endif 	/* __IEnumRegisterWordW_FWD_DEFINED__ */


#ifndef __IEnumInputContext_FWD_DEFINED__
#define __IEnumInputContext_FWD_DEFINED__
typedef interface IEnumInputContext IEnumInputContext;
#endif 	/* __IEnumInputContext_FWD_DEFINED__ */


#ifndef __IActiveIMMRegistrar_FWD_DEFINED__
#define __IActiveIMMRegistrar_FWD_DEFINED__
typedef interface IActiveIMMRegistrar IActiveIMMRegistrar;
#endif 	/* __IActiveIMMRegistrar_FWD_DEFINED__ */


#ifndef __IActiveIMMMessagePumpOwner_FWD_DEFINED__
#define __IActiveIMMMessagePumpOwner_FWD_DEFINED__
typedef interface IActiveIMMMessagePumpOwner IActiveIMMMessagePumpOwner;
#endif 	/* __IActiveIMMMessagePumpOwner_FWD_DEFINED__ */


#ifndef __IActiveIMMApp_FWD_DEFINED__
#define __IActiveIMMApp_FWD_DEFINED__
typedef interface IActiveIMMApp IActiveIMMApp;
#endif 	/* __IActiveIMMApp_FWD_DEFINED__ */


#ifndef __IActiveIMMIME_FWD_DEFINED__
#define __IActiveIMMIME_FWD_DEFINED__
typedef interface IActiveIMMIME IActiveIMMIME;
#endif 	/* __IActiveIMMIME_FWD_DEFINED__ */


#ifndef __IActiveIME_FWD_DEFINED__
#define __IActiveIME_FWD_DEFINED__
typedef interface IActiveIME IActiveIME;
#endif 	/* __IActiveIME_FWD_DEFINED__ */


#ifndef __IActiveIME2_FWD_DEFINED__
#define __IActiveIME2_FWD_DEFINED__
typedef interface IActiveIME2 IActiveIME2;
#endif 	/* __IActiveIME2_FWD_DEFINED__ */


#ifndef __CActiveIMM_FWD_DEFINED__
#define __CActiveIMM_FWD_DEFINED__

#ifdef __cplusplus
typedef class CActiveIMM CActiveIMM;
#else
typedef struct CActiveIMM CActiveIMM;
#endif /* __cplusplus */

#endif 	/* __CActiveIMM_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_dimm_0000 */
/* [local] */ 

//=--------------------------------------------------------------------------=
// dimm.h
//=--------------------------------------------------------------------------=
// (C) Copyright 1995-1998 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=

#pragma comment(lib,"uuid.lib")

//--------------------------------------------------------------------------
// IActiveIMM Interfaces.




extern RPC_IF_HANDLE __MIDL_itf_dimm_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dimm_0000_v0_0_s_ifspec;


#ifndef __ActiveIMM_LIBRARY_DEFINED__
#define __ActiveIMM_LIBRARY_DEFINED__

/* library ActiveIMM */
/* [version][lcid][helpstring][uuid] */ 

#include <imm.h>
#if 0
typedef WORD LANGID;

typedef /* [public][public][public][public] */ struct __MIDL___MIDL_itf_dimm_0000_0001
    {
    LPSTR lpReading;
    LPSTR lpWord;
    } 	REGISTERWORDA;

typedef /* [public][public][public][public][public] */ struct __MIDL___MIDL_itf_dimm_0000_0002
    {
    LPWSTR lpReading;
    LPWSTR lpWord;
    } 	REGISTERWORDW;

typedef /* [public][public][public][public][public][public][public] */ struct __MIDL___MIDL_itf_dimm_0000_0003
    {
    LONG lfHeight;
    LONG lfWidth;
    LONG lfEscapement;
    LONG lfOrientation;
    LONG lfWeight;
    BYTE lfItalic;
    BYTE lfUnderline;
    BYTE lfStrikeOut;
    BYTE lfCharSet;
    BYTE lfOutPrecision;
    BYTE lfClipPrecision;
    BYTE lfQuality;
    BYTE lfPitchAndFamily;
    CHAR lfFaceName[ 32 ];
    } 	LOGFONTA;

typedef /* [public][public][public][public][public][public][public] */ struct __MIDL___MIDL_itf_dimm_0000_0004
    {
    LONG lfHeight;
    LONG lfWidth;
    LONG lfEscapement;
    LONG lfOrientation;
    LONG lfWeight;
    BYTE lfItalic;
    BYTE lfUnderline;
    BYTE lfStrikeOut;
    BYTE lfCharSet;
    BYTE lfOutPrecision;
    BYTE lfClipPrecision;
    BYTE lfQuality;
    BYTE lfPitchAndFamily;
    WCHAR lfFaceName[ 32 ];
    } 	LOGFONTW;

typedef DWORD HIMC;

typedef DWORD HIMCC;

typedef /* [public][public][public][public][public][public][public] */ struct __MIDL___MIDL_itf_dimm_0000_0005
    {
    DWORD dwIndex;
    DWORD dwStyle;
    POINT ptCurrentPos;
    RECT rcArea;
    } 	CANDIDATEFORM;

typedef /* [public][public][public][public][public][public][public] */ struct __MIDL___MIDL_itf_dimm_0000_0006
    {
    DWORD dwStyle;
    POINT ptCurrentPos;
    RECT rcArea;
    } 	COMPOSITIONFORM;

typedef /* [public][public][public][public][public][public][public][public][public][public] */ struct __MIDL___MIDL_itf_dimm_0000_0007
    {
    DWORD dwSize;
    DWORD dwStyle;
    DWORD dwCount;
    DWORD dwSelection;
    DWORD dwPageStart;
    DWORD dwPageSize;
    DWORD dwOffset[ 1 ];
    } 	CANDIDATELIST;

typedef /* [public][public][public] */ struct __MIDL___MIDL_itf_dimm_0000_0008
    {
    DWORD dwStyle;
    CHAR szDescription[ 32 ];
    } 	STYLEBUFA;

typedef /* [public][public][public][public] */ struct __MIDL___MIDL_itf_dimm_0000_0009
    {
    DWORD dwStyle;
    WCHAR szDescription[ 32 ];
    } 	STYLEBUFW;

typedef WORD ATOM;

#endif
#if (WINVER < 0x040A)
typedef /* [public][public][public][public][public] */ struct __MIDL___MIDL_itf_dimm_0000_0010
    {
    UINT cbSize;
    UINT fType;
    UINT fState;
    UINT wID;
    HBITMAP hbmpChecked;
    HBITMAP hbmpUnchecked;
    DWORD dwItemData;
    CHAR szString[ 80 ];
    HBITMAP hbmpItem;
    } 	IMEMENUITEMINFOA;

typedef /* [public][public][public][public][public] */ struct __MIDL___MIDL_itf_dimm_0000_0011
    {
    UINT cbSize;
    UINT fType;
    UINT fState;
    UINT wID;
    HBITMAP hbmpChecked;
    HBITMAP hbmpUnchecked;
    DWORD dwItemData;
    WCHAR szString[ 80 ];
    HBITMAP hbmpItem;
    } 	IMEMENUITEMINFOW;

#endif
#ifndef _DDKIMM_H_
typedef /* [public][public] */ struct __MIDL___MIDL_itf_dimm_0000_0012
    {
    HWND hWnd;
    BOOL fOpen;
    POINT ptStatusWndPos;
    POINT ptSoftKbdPos;
    DWORD fdwConversion;
    DWORD fdwSentence;
    union 
        {
        LOGFONTA A;
        LOGFONTW W;
        } 	lfFont;
    COMPOSITIONFORM cfCompForm;
    CANDIDATEFORM cfCandForm[ 4 ];
    HIMCC hCompStr;
    HIMCC hCandInfo;
    HIMCC hGuideLine;
    HIMCC hPrivate;
    DWORD dwNumMsgBuf;
    HIMCC hMsgBuf;
    DWORD fdwInit;
    DWORD dwReserve[ 3 ];
    } 	INPUTCONTEXT;

typedef /* [public][public] */ struct __MIDL___MIDL_itf_dimm_0000_0014
    {
    DWORD dwPrivateDataSize;
    DWORD fdwProperty;
    DWORD fdwConversionCaps;
    DWORD fdwSentenceCaps;
    DWORD fdwUICaps;
    DWORD fdwSCSCaps;
    DWORD fdwSelectCaps;
    } 	IMEINFO;

#endif

EXTERN_C const IID LIBID_ActiveIMM;

#ifndef __IEnumRegisterWordA_INTERFACE_DEFINED__
#define __IEnumRegisterWordA_INTERFACE_DEFINED__

/* interface IEnumRegisterWordA */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumRegisterWordA;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("08C03412-F96B-11d0-A475-00AA006BCC59")
    IEnumRegisterWordA : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumRegisterWordA **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG ulCount,
            /* [out] */ REGISTERWORDA *rgRegisterWord,
            /* [out] */ ULONG *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG ulCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumRegisterWordAVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumRegisterWordA * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumRegisterWordA * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumRegisterWordA * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumRegisterWordA * This,
            /* [out] */ IEnumRegisterWordA **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumRegisterWordA * This,
            /* [in] */ ULONG ulCount,
            /* [out] */ REGISTERWORDA *rgRegisterWord,
            /* [out] */ ULONG *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumRegisterWordA * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumRegisterWordA * This,
            /* [in] */ ULONG ulCount);
        
        END_INTERFACE
    } IEnumRegisterWordAVtbl;

    interface IEnumRegisterWordA
    {
        CONST_VTBL struct IEnumRegisterWordAVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumRegisterWordA_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumRegisterWordA_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumRegisterWordA_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumRegisterWordA_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IEnumRegisterWordA_Next(This,ulCount,rgRegisterWord,pcFetched)	\
    (This)->lpVtbl -> Next(This,ulCount,rgRegisterWord,pcFetched)

#define IEnumRegisterWordA_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumRegisterWordA_Skip(This,ulCount)	\
    (This)->lpVtbl -> Skip(This,ulCount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumRegisterWordA_Clone_Proxy( 
    IEnumRegisterWordA * This,
    /* [out] */ IEnumRegisterWordA **ppEnum);


void __RPC_STUB IEnumRegisterWordA_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumRegisterWordA_Next_Proxy( 
    IEnumRegisterWordA * This,
    /* [in] */ ULONG ulCount,
    /* [out] */ REGISTERWORDA *rgRegisterWord,
    /* [out] */ ULONG *pcFetched);


void __RPC_STUB IEnumRegisterWordA_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumRegisterWordA_Reset_Proxy( 
    IEnumRegisterWordA * This);


void __RPC_STUB IEnumRegisterWordA_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumRegisterWordA_Skip_Proxy( 
    IEnumRegisterWordA * This,
    /* [in] */ ULONG ulCount);


void __RPC_STUB IEnumRegisterWordA_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumRegisterWordA_INTERFACE_DEFINED__ */


#ifndef __IEnumRegisterWordW_INTERFACE_DEFINED__
#define __IEnumRegisterWordW_INTERFACE_DEFINED__

/* interface IEnumRegisterWordW */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumRegisterWordW;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4955DD31-B159-11d0-8FCF-00AA006BCC59")
    IEnumRegisterWordW : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumRegisterWordW **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG ulCount,
            /* [out] */ REGISTERWORDW *rgRegisterWord,
            /* [out] */ ULONG *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG ulCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumRegisterWordWVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumRegisterWordW * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumRegisterWordW * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumRegisterWordW * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumRegisterWordW * This,
            /* [out] */ IEnumRegisterWordW **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumRegisterWordW * This,
            /* [in] */ ULONG ulCount,
            /* [out] */ REGISTERWORDW *rgRegisterWord,
            /* [out] */ ULONG *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumRegisterWordW * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumRegisterWordW * This,
            /* [in] */ ULONG ulCount);
        
        END_INTERFACE
    } IEnumRegisterWordWVtbl;

    interface IEnumRegisterWordW
    {
        CONST_VTBL struct IEnumRegisterWordWVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumRegisterWordW_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumRegisterWordW_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumRegisterWordW_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumRegisterWordW_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IEnumRegisterWordW_Next(This,ulCount,rgRegisterWord,pcFetched)	\
    (This)->lpVtbl -> Next(This,ulCount,rgRegisterWord,pcFetched)

#define IEnumRegisterWordW_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumRegisterWordW_Skip(This,ulCount)	\
    (This)->lpVtbl -> Skip(This,ulCount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumRegisterWordW_Clone_Proxy( 
    IEnumRegisterWordW * This,
    /* [out] */ IEnumRegisterWordW **ppEnum);


void __RPC_STUB IEnumRegisterWordW_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumRegisterWordW_Next_Proxy( 
    IEnumRegisterWordW * This,
    /* [in] */ ULONG ulCount,
    /* [out] */ REGISTERWORDW *rgRegisterWord,
    /* [out] */ ULONG *pcFetched);


void __RPC_STUB IEnumRegisterWordW_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumRegisterWordW_Reset_Proxy( 
    IEnumRegisterWordW * This);


void __RPC_STUB IEnumRegisterWordW_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumRegisterWordW_Skip_Proxy( 
    IEnumRegisterWordW * This,
    /* [in] */ ULONG ulCount);


void __RPC_STUB IEnumRegisterWordW_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumRegisterWordW_INTERFACE_DEFINED__ */


#ifndef __IEnumInputContext_INTERFACE_DEFINED__
#define __IEnumInputContext_INTERFACE_DEFINED__

/* interface IEnumInputContext */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumInputContext;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("09b5eab0-f997-11d1-93d4-0060b067b86e")
    IEnumInputContext : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumInputContext **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG ulCount,
            /* [out] */ HIMC *rgInputContext,
            /* [out] */ ULONG *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG ulCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumInputContextVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumInputContext * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumInputContext * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumInputContext * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumInputContext * This,
            /* [out] */ IEnumInputContext **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumInputContext * This,
            /* [in] */ ULONG ulCount,
            /* [out] */ HIMC *rgInputContext,
            /* [out] */ ULONG *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumInputContext * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumInputContext * This,
            /* [in] */ ULONG ulCount);
        
        END_INTERFACE
    } IEnumInputContextVtbl;

    interface IEnumInputContext
    {
        CONST_VTBL struct IEnumInputContextVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumInputContext_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumInputContext_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumInputContext_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumInputContext_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IEnumInputContext_Next(This,ulCount,rgInputContext,pcFetched)	\
    (This)->lpVtbl -> Next(This,ulCount,rgInputContext,pcFetched)

#define IEnumInputContext_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumInputContext_Skip(This,ulCount)	\
    (This)->lpVtbl -> Skip(This,ulCount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumInputContext_Clone_Proxy( 
    IEnumInputContext * This,
    /* [out] */ IEnumInputContext **ppEnum);


void __RPC_STUB IEnumInputContext_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumInputContext_Next_Proxy( 
    IEnumInputContext * This,
    /* [in] */ ULONG ulCount,
    /* [out] */ HIMC *rgInputContext,
    /* [out] */ ULONG *pcFetched);


void __RPC_STUB IEnumInputContext_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumInputContext_Reset_Proxy( 
    IEnumInputContext * This);


void __RPC_STUB IEnumInputContext_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumInputContext_Skip_Proxy( 
    IEnumInputContext * This,
    /* [in] */ ULONG ulCount);


void __RPC_STUB IEnumInputContext_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumInputContext_INTERFACE_DEFINED__ */


#ifndef __IActiveIMMRegistrar_INTERFACE_DEFINED__
#define __IActiveIMMRegistrar_INTERFACE_DEFINED__

/* interface IActiveIMMRegistrar */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IActiveIMMRegistrar;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b3458082-bd00-11d1-939b-0060b067b86e")
    IActiveIMMRegistrar : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RegisterIME( 
            /* [in] */ REFCLSID rclsid,
            /* [in] */ LANGID lgid,
            /* [in] */ LPCWSTR pszIconFile,
            /* [in] */ LPCWSTR pszDesc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnregisterIME( 
            /* [in] */ REFCLSID rclsid) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveIMMRegistrarVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IActiveIMMRegistrar * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IActiveIMMRegistrar * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IActiveIMMRegistrar * This);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterIME )( 
            IActiveIMMRegistrar * This,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ LANGID lgid,
            /* [in] */ LPCWSTR pszIconFile,
            /* [in] */ LPCWSTR pszDesc);
        
        HRESULT ( STDMETHODCALLTYPE *UnregisterIME )( 
            IActiveIMMRegistrar * This,
            /* [in] */ REFCLSID rclsid);
        
        END_INTERFACE
    } IActiveIMMRegistrarVtbl;

    interface IActiveIMMRegistrar
    {
        CONST_VTBL struct IActiveIMMRegistrarVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveIMMRegistrar_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IActiveIMMRegistrar_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IActiveIMMRegistrar_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IActiveIMMRegistrar_RegisterIME(This,rclsid,lgid,pszIconFile,pszDesc)	\
    (This)->lpVtbl -> RegisterIME(This,rclsid,lgid,pszIconFile,pszDesc)

#define IActiveIMMRegistrar_UnregisterIME(This,rclsid)	\
    (This)->lpVtbl -> UnregisterIME(This,rclsid)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IActiveIMMRegistrar_RegisterIME_Proxy( 
    IActiveIMMRegistrar * This,
    /* [in] */ REFCLSID rclsid,
    /* [in] */ LANGID lgid,
    /* [in] */ LPCWSTR pszIconFile,
    /* [in] */ LPCWSTR pszDesc);


void __RPC_STUB IActiveIMMRegistrar_RegisterIME_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMRegistrar_UnregisterIME_Proxy( 
    IActiveIMMRegistrar * This,
    /* [in] */ REFCLSID rclsid);


void __RPC_STUB IActiveIMMRegistrar_UnregisterIME_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IActiveIMMRegistrar_INTERFACE_DEFINED__ */


#ifndef __IActiveIMMMessagePumpOwner_INTERFACE_DEFINED__
#define __IActiveIMMMessagePumpOwner_INTERFACE_DEFINED__

/* interface IActiveIMMMessagePumpOwner */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IActiveIMMMessagePumpOwner;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b5cf2cfa-8aeb-11d1-9364-0060b067b86e")
    IActiveIMMMessagePumpOwner : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Start( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE End( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnTranslateMessage( 
            /* [in] */ const MSG *pMsg) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Pause( 
            /* [out] */ DWORD *pdwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Resume( 
            /* [in] */ DWORD dwCookie) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveIMMMessagePumpOwnerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IActiveIMMMessagePumpOwner * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IActiveIMMMessagePumpOwner * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IActiveIMMMessagePumpOwner * This);
        
        HRESULT ( STDMETHODCALLTYPE *Start )( 
            IActiveIMMMessagePumpOwner * This);
        
        HRESULT ( STDMETHODCALLTYPE *End )( 
            IActiveIMMMessagePumpOwner * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnTranslateMessage )( 
            IActiveIMMMessagePumpOwner * This,
            /* [in] */ const MSG *pMsg);
        
        HRESULT ( STDMETHODCALLTYPE *Pause )( 
            IActiveIMMMessagePumpOwner * This,
            /* [out] */ DWORD *pdwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *Resume )( 
            IActiveIMMMessagePumpOwner * This,
            /* [in] */ DWORD dwCookie);
        
        END_INTERFACE
    } IActiveIMMMessagePumpOwnerVtbl;

    interface IActiveIMMMessagePumpOwner
    {
        CONST_VTBL struct IActiveIMMMessagePumpOwnerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveIMMMessagePumpOwner_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IActiveIMMMessagePumpOwner_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IActiveIMMMessagePumpOwner_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IActiveIMMMessagePumpOwner_Start(This)	\
    (This)->lpVtbl -> Start(This)

#define IActiveIMMMessagePumpOwner_End(This)	\
    (This)->lpVtbl -> End(This)

#define IActiveIMMMessagePumpOwner_OnTranslateMessage(This,pMsg)	\
    (This)->lpVtbl -> OnTranslateMessage(This,pMsg)

#define IActiveIMMMessagePumpOwner_Pause(This,pdwCookie)	\
    (This)->lpVtbl -> Pause(This,pdwCookie)

#define IActiveIMMMessagePumpOwner_Resume(This,dwCookie)	\
    (This)->lpVtbl -> Resume(This,dwCookie)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IActiveIMMMessagePumpOwner_Start_Proxy( 
    IActiveIMMMessagePumpOwner * This);


void __RPC_STUB IActiveIMMMessagePumpOwner_Start_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMMessagePumpOwner_End_Proxy( 
    IActiveIMMMessagePumpOwner * This);


void __RPC_STUB IActiveIMMMessagePumpOwner_End_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMMessagePumpOwner_OnTranslateMessage_Proxy( 
    IActiveIMMMessagePumpOwner * This,
    /* [in] */ const MSG *pMsg);


void __RPC_STUB IActiveIMMMessagePumpOwner_OnTranslateMessage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMMessagePumpOwner_Pause_Proxy( 
    IActiveIMMMessagePumpOwner * This,
    /* [out] */ DWORD *pdwCookie);


void __RPC_STUB IActiveIMMMessagePumpOwner_Pause_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMMessagePumpOwner_Resume_Proxy( 
    IActiveIMMMessagePumpOwner * This,
    /* [in] */ DWORD dwCookie);


void __RPC_STUB IActiveIMMMessagePumpOwner_Resume_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IActiveIMMMessagePumpOwner_INTERFACE_DEFINED__ */


#ifndef __IActiveIMMApp_INTERFACE_DEFINED__
#define __IActiveIMMApp_INTERFACE_DEFINED__

/* interface IActiveIMMApp */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IActiveIMMApp;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("08c0e040-62d1-11d1-9326-0060b067b86e")
    IActiveIMMApp : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AssociateContext( 
            /* [in] */ HWND hWnd,
            /* [in] */ HIMC hIME,
            /* [out] */ HIMC *phPrev) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConfigureIMEA( 
            /* [in] */ HKL hKL,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwMode,
            /* [in] */ REGISTERWORDA *pData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConfigureIMEW( 
            /* [in] */ HKL hKL,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwMode,
            /* [in] */ REGISTERWORDW *pData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateContext( 
            /* [out] */ HIMC *phIMC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DestroyContext( 
            /* [in] */ HIMC hIME) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumRegisterWordA( 
            /* [in] */ HKL hKL,
            /* [in] */ LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPSTR szRegister,
            /* [in] */ LPVOID pData,
            /* [out] */ IEnumRegisterWordA **pEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumRegisterWordW( 
            /* [in] */ HKL hKL,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szRegister,
            /* [in] */ LPVOID pData,
            /* [out] */ IEnumRegisterWordW **pEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EscapeA( 
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uEscape,
            /* [out][in] */ LPVOID pData,
            /* [out] */ LRESULT *plResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EscapeW( 
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uEscape,
            /* [out][in] */ LPVOID pData,
            /* [out] */ LRESULT *plResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCandidateListA( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ UINT uBufLen,
            /* [out] */ CANDIDATELIST *pCandList,
            /* [out] */ UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCandidateListW( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ UINT uBufLen,
            /* [out] */ CANDIDATELIST *pCandList,
            /* [out] */ UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCandidateListCountA( 
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD *pdwListSize,
            /* [out] */ DWORD *pdwBufLen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCandidateListCountW( 
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD *pdwListSize,
            /* [out] */ DWORD *pdwBufLen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCandidateWindow( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [out] */ CANDIDATEFORM *pCandidate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCompositionFontA( 
            /* [in] */ HIMC hIMC,
            /* [out] */ LOGFONTA *plf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCompositionFontW( 
            /* [in] */ HIMC hIMC,
            /* [out] */ LOGFONTW *plf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCompositionStringA( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LONG *plCopied,
            /* [out] */ LPVOID pBuf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCompositionStringW( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LONG *plCopied,
            /* [out] */ LPVOID pBuf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCompositionWindow( 
            /* [in] */ HIMC hIMC,
            /* [out] */ COMPOSITIONFORM *pCompForm) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetContext( 
            /* [in] */ HWND hWnd,
            /* [out] */ HIMC *phIMC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConversionListA( 
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ LPSTR pSrc,
            /* [in] */ UINT uBufLen,
            /* [in] */ UINT uFlag,
            /* [out] */ CANDIDATELIST *pDst,
            /* [out] */ UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConversionListW( 
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ LPWSTR pSrc,
            /* [in] */ UINT uBufLen,
            /* [in] */ UINT uFlag,
            /* [out] */ CANDIDATELIST *pDst,
            /* [out] */ UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConversionStatus( 
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD *pfdwConversion,
            /* [out] */ DWORD *pfdwSentence) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDefaultIMEWnd( 
            /* [in] */ HWND hWnd,
            /* [out] */ HWND *phDefWnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDescriptionA( 
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPSTR szDescription,
            /* [out] */ UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDescriptionW( 
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPWSTR szDescription,
            /* [out] */ UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGuideLineA( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LPSTR pBuf,
            /* [out] */ DWORD *pdwResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGuideLineW( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LPWSTR pBuf,
            /* [out] */ DWORD *pdwResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIMEFileNameA( 
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPSTR szFileName,
            /* [out] */ UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIMEFileNameW( 
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPWSTR szFileName,
            /* [out] */ UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOpenStatus( 
            /* [in] */ HIMC hIMC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProperty( 
            /* [in] */ HKL hKL,
            /* [in] */ DWORD fdwIndex,
            /* [out] */ DWORD *pdwProperty) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRegisterWordStyleA( 
            /* [in] */ HKL hKL,
            /* [in] */ UINT nItem,
            /* [out] */ STYLEBUFA *pStyleBuf,
            /* [out] */ UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRegisterWordStyleW( 
            /* [in] */ HKL hKL,
            /* [in] */ UINT nItem,
            /* [out] */ STYLEBUFW *pStyleBuf,
            /* [out] */ UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStatusWindowPos( 
            /* [in] */ HIMC hIMC,
            /* [out] */ POINT *pptPos) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVirtualKey( 
            /* [in] */ HWND hWnd,
            /* [out] */ UINT *puVirtualKey) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InstallIMEA( 
            /* [in] */ LPSTR szIMEFileName,
            /* [in] */ LPSTR szLayoutText,
            /* [out] */ HKL *phKL) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InstallIMEW( 
            /* [in] */ LPWSTR szIMEFileName,
            /* [in] */ LPWSTR szLayoutText,
            /* [out] */ HKL *phKL) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsIME( 
            /* [in] */ HKL hKL) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsUIMessageA( 
            /* [in] */ HWND hWndIME,
            /* [in] */ UINT msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsUIMessageW( 
            /* [in] */ HWND hWndIME,
            /* [in] */ UINT msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NotifyIME( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwAction,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterWordA( 
            /* [in] */ HKL hKL,
            /* [in] */ LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPSTR szRegister) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterWordW( 
            /* [in] */ HKL hKL,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szRegister) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReleaseContext( 
            /* [in] */ HWND hWnd,
            /* [in] */ HIMC hIMC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCandidateWindow( 
            /* [in] */ HIMC hIMC,
            /* [in] */ CANDIDATEFORM *pCandidate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCompositionFontA( 
            /* [in] */ HIMC hIMC,
            /* [in] */ LOGFONTA *plf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCompositionFontW( 
            /* [in] */ HIMC hIMC,
            /* [in] */ LOGFONTW *plf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCompositionStringA( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ LPVOID pComp,
            /* [in] */ DWORD dwCompLen,
            /* [in] */ LPVOID pRead,
            /* [in] */ DWORD dwReadLen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCompositionStringW( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ LPVOID pComp,
            /* [in] */ DWORD dwCompLen,
            /* [in] */ LPVOID pRead,
            /* [in] */ DWORD dwReadLen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCompositionWindow( 
            /* [in] */ HIMC hIMC,
            /* [in] */ COMPOSITIONFORM *pCompForm) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetConversionStatus( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD fdwConversion,
            /* [in] */ DWORD fdwSentence) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOpenStatus( 
            /* [in] */ HIMC hIMC,
            /* [in] */ BOOL fOpen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStatusWindowPos( 
            /* [in] */ HIMC hIMC,
            /* [in] */ POINT *pptPos) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SimulateHotKey( 
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwHotKeyID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnregisterWordA( 
            /* [in] */ HKL hKL,
            /* [in] */ LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPSTR szUnregister) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnregisterWordW( 
            /* [in] */ HKL hKL,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szUnregister) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Activate( 
            /* [in] */ BOOL fRestoreLayout) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Deactivate( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnDefWindowProc( 
            /* [in] */ HWND hWnd,
            /* [in] */ UINT Msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ LRESULT *plResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FilterClientWindows( 
            /* [in] */ ATOM *aaClassList,
            /* [in] */ UINT uSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCodePageA( 
            /* [in] */ HKL hKL,
            /* [out] */ UINT *uCodePage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLangId( 
            /* [in] */ HKL hKL,
            /* [out] */ LANGID *plid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AssociateContextEx( 
            /* [in] */ HWND hWnd,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DisableIME( 
            /* [in] */ DWORD idThread) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetImeMenuItemsA( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwType,
            /* [in] */ IMEMENUITEMINFOA *pImeParentMenu,
            /* [out] */ IMEMENUITEMINFOA *pImeMenu,
            /* [in] */ DWORD dwSize,
            /* [out] */ DWORD *pdwResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetImeMenuItemsW( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwType,
            /* [in] */ IMEMENUITEMINFOW *pImeParentMenu,
            /* [out] */ IMEMENUITEMINFOW *pImeMenu,
            /* [in] */ DWORD dwSize,
            /* [out] */ DWORD *pdwResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumInputContext( 
            /* [in] */ DWORD idThread,
            /* [out] */ IEnumInputContext **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveIMMAppVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IActiveIMMApp * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IActiveIMMApp * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IActiveIMMApp * This);
        
        HRESULT ( STDMETHODCALLTYPE *AssociateContext )( 
            IActiveIMMApp * This,
            /* [in] */ HWND hWnd,
            /* [in] */ HIMC hIME,
            /* [out] */ HIMC *phPrev);
        
        HRESULT ( STDMETHODCALLTYPE *ConfigureIMEA )( 
            IActiveIMMApp * This,
            /* [in] */ HKL hKL,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwMode,
            /* [in] */ REGISTERWORDA *pData);
        
        HRESULT ( STDMETHODCALLTYPE *ConfigureIMEW )( 
            IActiveIMMApp * This,
            /* [in] */ HKL hKL,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwMode,
            /* [in] */ REGISTERWORDW *pData);
        
        HRESULT ( STDMETHODCALLTYPE *CreateContext )( 
            IActiveIMMApp * This,
            /* [out] */ HIMC *phIMC);
        
        HRESULT ( STDMETHODCALLTYPE *DestroyContext )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIME);
        
        HRESULT ( STDMETHODCALLTYPE *EnumRegisterWordA )( 
            IActiveIMMApp * This,
            /* [in] */ HKL hKL,
            /* [in] */ LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPSTR szRegister,
            /* [in] */ LPVOID pData,
            /* [out] */ IEnumRegisterWordA **pEnum);
        
        HRESULT ( STDMETHODCALLTYPE *EnumRegisterWordW )( 
            IActiveIMMApp * This,
            /* [in] */ HKL hKL,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szRegister,
            /* [in] */ LPVOID pData,
            /* [out] */ IEnumRegisterWordW **pEnum);
        
        HRESULT ( STDMETHODCALLTYPE *EscapeA )( 
            IActiveIMMApp * This,
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uEscape,
            /* [out][in] */ LPVOID pData,
            /* [out] */ LRESULT *plResult);
        
        HRESULT ( STDMETHODCALLTYPE *EscapeW )( 
            IActiveIMMApp * This,
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uEscape,
            /* [out][in] */ LPVOID pData,
            /* [out] */ LRESULT *plResult);
        
        HRESULT ( STDMETHODCALLTYPE *GetCandidateListA )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ UINT uBufLen,
            /* [out] */ CANDIDATELIST *pCandList,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetCandidateListW )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ UINT uBufLen,
            /* [out] */ CANDIDATELIST *pCandList,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetCandidateListCountA )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD *pdwListSize,
            /* [out] */ DWORD *pdwBufLen);
        
        HRESULT ( STDMETHODCALLTYPE *GetCandidateListCountW )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD *pdwListSize,
            /* [out] */ DWORD *pdwBufLen);
        
        HRESULT ( STDMETHODCALLTYPE *GetCandidateWindow )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [out] */ CANDIDATEFORM *pCandidate);
        
        HRESULT ( STDMETHODCALLTYPE *GetCompositionFontA )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ LOGFONTA *plf);
        
        HRESULT ( STDMETHODCALLTYPE *GetCompositionFontW )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ LOGFONTW *plf);
        
        HRESULT ( STDMETHODCALLTYPE *GetCompositionStringA )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LONG *plCopied,
            /* [out] */ LPVOID pBuf);
        
        HRESULT ( STDMETHODCALLTYPE *GetCompositionStringW )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LONG *plCopied,
            /* [out] */ LPVOID pBuf);
        
        HRESULT ( STDMETHODCALLTYPE *GetCompositionWindow )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ COMPOSITIONFORM *pCompForm);
        
        HRESULT ( STDMETHODCALLTYPE *GetContext )( 
            IActiveIMMApp * This,
            /* [in] */ HWND hWnd,
            /* [out] */ HIMC *phIMC);
        
        HRESULT ( STDMETHODCALLTYPE *GetConversionListA )( 
            IActiveIMMApp * This,
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ LPSTR pSrc,
            /* [in] */ UINT uBufLen,
            /* [in] */ UINT uFlag,
            /* [out] */ CANDIDATELIST *pDst,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetConversionListW )( 
            IActiveIMMApp * This,
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ LPWSTR pSrc,
            /* [in] */ UINT uBufLen,
            /* [in] */ UINT uFlag,
            /* [out] */ CANDIDATELIST *pDst,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetConversionStatus )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD *pfdwConversion,
            /* [out] */ DWORD *pfdwSentence);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultIMEWnd )( 
            IActiveIMMApp * This,
            /* [in] */ HWND hWnd,
            /* [out] */ HWND *phDefWnd);
        
        HRESULT ( STDMETHODCALLTYPE *GetDescriptionA )( 
            IActiveIMMApp * This,
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPSTR szDescription,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetDescriptionW )( 
            IActiveIMMApp * This,
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPWSTR szDescription,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetGuideLineA )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LPSTR pBuf,
            /* [out] */ DWORD *pdwResult);
        
        HRESULT ( STDMETHODCALLTYPE *GetGuideLineW )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LPWSTR pBuf,
            /* [out] */ DWORD *pdwResult);
        
        HRESULT ( STDMETHODCALLTYPE *GetIMEFileNameA )( 
            IActiveIMMApp * This,
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPSTR szFileName,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetIMEFileNameW )( 
            IActiveIMMApp * This,
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPWSTR szFileName,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetOpenStatus )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC);
        
        HRESULT ( STDMETHODCALLTYPE *GetProperty )( 
            IActiveIMMApp * This,
            /* [in] */ HKL hKL,
            /* [in] */ DWORD fdwIndex,
            /* [out] */ DWORD *pdwProperty);
        
        HRESULT ( STDMETHODCALLTYPE *GetRegisterWordStyleA )( 
            IActiveIMMApp * This,
            /* [in] */ HKL hKL,
            /* [in] */ UINT nItem,
            /* [out] */ STYLEBUFA *pStyleBuf,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetRegisterWordStyleW )( 
            IActiveIMMApp * This,
            /* [in] */ HKL hKL,
            /* [in] */ UINT nItem,
            /* [out] */ STYLEBUFW *pStyleBuf,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetStatusWindowPos )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ POINT *pptPos);
        
        HRESULT ( STDMETHODCALLTYPE *GetVirtualKey )( 
            IActiveIMMApp * This,
            /* [in] */ HWND hWnd,
            /* [out] */ UINT *puVirtualKey);
        
        HRESULT ( STDMETHODCALLTYPE *InstallIMEA )( 
            IActiveIMMApp * This,
            /* [in] */ LPSTR szIMEFileName,
            /* [in] */ LPSTR szLayoutText,
            /* [out] */ HKL *phKL);
        
        HRESULT ( STDMETHODCALLTYPE *InstallIMEW )( 
            IActiveIMMApp * This,
            /* [in] */ LPWSTR szIMEFileName,
            /* [in] */ LPWSTR szLayoutText,
            /* [out] */ HKL *phKL);
        
        HRESULT ( STDMETHODCALLTYPE *IsIME )( 
            IActiveIMMApp * This,
            /* [in] */ HKL hKL);
        
        HRESULT ( STDMETHODCALLTYPE *IsUIMessageA )( 
            IActiveIMMApp * This,
            /* [in] */ HWND hWndIME,
            /* [in] */ UINT msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam);
        
        HRESULT ( STDMETHODCALLTYPE *IsUIMessageW )( 
            IActiveIMMApp * This,
            /* [in] */ HWND hWndIME,
            /* [in] */ UINT msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam);
        
        HRESULT ( STDMETHODCALLTYPE *NotifyIME )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwAction,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwValue);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterWordA )( 
            IActiveIMMApp * This,
            /* [in] */ HKL hKL,
            /* [in] */ LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPSTR szRegister);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterWordW )( 
            IActiveIMMApp * This,
            /* [in] */ HKL hKL,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szRegister);
        
        HRESULT ( STDMETHODCALLTYPE *ReleaseContext )( 
            IActiveIMMApp * This,
            /* [in] */ HWND hWnd,
            /* [in] */ HIMC hIMC);
        
        HRESULT ( STDMETHODCALLTYPE *SetCandidateWindow )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ CANDIDATEFORM *pCandidate);
        
        HRESULT ( STDMETHODCALLTYPE *SetCompositionFontA )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ LOGFONTA *plf);
        
        HRESULT ( STDMETHODCALLTYPE *SetCompositionFontW )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ LOGFONTW *plf);
        
        HRESULT ( STDMETHODCALLTYPE *SetCompositionStringA )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ LPVOID pComp,
            /* [in] */ DWORD dwCompLen,
            /* [in] */ LPVOID pRead,
            /* [in] */ DWORD dwReadLen);
        
        HRESULT ( STDMETHODCALLTYPE *SetCompositionStringW )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ LPVOID pComp,
            /* [in] */ DWORD dwCompLen,
            /* [in] */ LPVOID pRead,
            /* [in] */ DWORD dwReadLen);
        
        HRESULT ( STDMETHODCALLTYPE *SetCompositionWindow )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ COMPOSITIONFORM *pCompForm);
        
        HRESULT ( STDMETHODCALLTYPE *SetConversionStatus )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD fdwConversion,
            /* [in] */ DWORD fdwSentence);
        
        HRESULT ( STDMETHODCALLTYPE *SetOpenStatus )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ BOOL fOpen);
        
        HRESULT ( STDMETHODCALLTYPE *SetStatusWindowPos )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ POINT *pptPos);
        
        HRESULT ( STDMETHODCALLTYPE *SimulateHotKey )( 
            IActiveIMMApp * This,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwHotKeyID);
        
        HRESULT ( STDMETHODCALLTYPE *UnregisterWordA )( 
            IActiveIMMApp * This,
            /* [in] */ HKL hKL,
            /* [in] */ LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPSTR szUnregister);
        
        HRESULT ( STDMETHODCALLTYPE *UnregisterWordW )( 
            IActiveIMMApp * This,
            /* [in] */ HKL hKL,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szUnregister);
        
        HRESULT ( STDMETHODCALLTYPE *Activate )( 
            IActiveIMMApp * This,
            /* [in] */ BOOL fRestoreLayout);
        
        HRESULT ( STDMETHODCALLTYPE *Deactivate )( 
            IActiveIMMApp * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnDefWindowProc )( 
            IActiveIMMApp * This,
            /* [in] */ HWND hWnd,
            /* [in] */ UINT Msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ LRESULT *plResult);
        
        HRESULT ( STDMETHODCALLTYPE *FilterClientWindows )( 
            IActiveIMMApp * This,
            /* [in] */ ATOM *aaClassList,
            /* [in] */ UINT uSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetCodePageA )( 
            IActiveIMMApp * This,
            /* [in] */ HKL hKL,
            /* [out] */ UINT *uCodePage);
        
        HRESULT ( STDMETHODCALLTYPE *GetLangId )( 
            IActiveIMMApp * This,
            /* [in] */ HKL hKL,
            /* [out] */ LANGID *plid);
        
        HRESULT ( STDMETHODCALLTYPE *AssociateContextEx )( 
            IActiveIMMApp * This,
            /* [in] */ HWND hWnd,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *DisableIME )( 
            IActiveIMMApp * This,
            /* [in] */ DWORD idThread);
        
        HRESULT ( STDMETHODCALLTYPE *GetImeMenuItemsA )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwType,
            /* [in] */ IMEMENUITEMINFOA *pImeParentMenu,
            /* [out] */ IMEMENUITEMINFOA *pImeMenu,
            /* [in] */ DWORD dwSize,
            /* [out] */ DWORD *pdwResult);
        
        HRESULT ( STDMETHODCALLTYPE *GetImeMenuItemsW )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwType,
            /* [in] */ IMEMENUITEMINFOW *pImeParentMenu,
            /* [out] */ IMEMENUITEMINFOW *pImeMenu,
            /* [in] */ DWORD dwSize,
            /* [out] */ DWORD *pdwResult);
        
        HRESULT ( STDMETHODCALLTYPE *EnumInputContext )( 
            IActiveIMMApp * This,
            /* [in] */ DWORD idThread,
            /* [out] */ IEnumInputContext **ppEnum);
        
        END_INTERFACE
    } IActiveIMMAppVtbl;

    interface IActiveIMMApp
    {
        CONST_VTBL struct IActiveIMMAppVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveIMMApp_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IActiveIMMApp_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IActiveIMMApp_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IActiveIMMApp_AssociateContext(This,hWnd,hIME,phPrev)	\
    (This)->lpVtbl -> AssociateContext(This,hWnd,hIME,phPrev)

#define IActiveIMMApp_ConfigureIMEA(This,hKL,hWnd,dwMode,pData)	\
    (This)->lpVtbl -> ConfigureIMEA(This,hKL,hWnd,dwMode,pData)

#define IActiveIMMApp_ConfigureIMEW(This,hKL,hWnd,dwMode,pData)	\
    (This)->lpVtbl -> ConfigureIMEW(This,hKL,hWnd,dwMode,pData)

#define IActiveIMMApp_CreateContext(This,phIMC)	\
    (This)->lpVtbl -> CreateContext(This,phIMC)

#define IActiveIMMApp_DestroyContext(This,hIME)	\
    (This)->lpVtbl -> DestroyContext(This,hIME)

#define IActiveIMMApp_EnumRegisterWordA(This,hKL,szReading,dwStyle,szRegister,pData,pEnum)	\
    (This)->lpVtbl -> EnumRegisterWordA(This,hKL,szReading,dwStyle,szRegister,pData,pEnum)

#define IActiveIMMApp_EnumRegisterWordW(This,hKL,szReading,dwStyle,szRegister,pData,pEnum)	\
    (This)->lpVtbl -> EnumRegisterWordW(This,hKL,szReading,dwStyle,szRegister,pData,pEnum)

#define IActiveIMMApp_EscapeA(This,hKL,hIMC,uEscape,pData,plResult)	\
    (This)->lpVtbl -> EscapeA(This,hKL,hIMC,uEscape,pData,plResult)

#define IActiveIMMApp_EscapeW(This,hKL,hIMC,uEscape,pData,plResult)	\
    (This)->lpVtbl -> EscapeW(This,hKL,hIMC,uEscape,pData,plResult)

#define IActiveIMMApp_GetCandidateListA(This,hIMC,dwIndex,uBufLen,pCandList,puCopied)	\
    (This)->lpVtbl -> GetCandidateListA(This,hIMC,dwIndex,uBufLen,pCandList,puCopied)

#define IActiveIMMApp_GetCandidateListW(This,hIMC,dwIndex,uBufLen,pCandList,puCopied)	\
    (This)->lpVtbl -> GetCandidateListW(This,hIMC,dwIndex,uBufLen,pCandList,puCopied)

#define IActiveIMMApp_GetCandidateListCountA(This,hIMC,pdwListSize,pdwBufLen)	\
    (This)->lpVtbl -> GetCandidateListCountA(This,hIMC,pdwListSize,pdwBufLen)

#define IActiveIMMApp_GetCandidateListCountW(This,hIMC,pdwListSize,pdwBufLen)	\
    (This)->lpVtbl -> GetCandidateListCountW(This,hIMC,pdwListSize,pdwBufLen)

#define IActiveIMMApp_GetCandidateWindow(This,hIMC,dwIndex,pCandidate)	\
    (This)->lpVtbl -> GetCandidateWindow(This,hIMC,dwIndex,pCandidate)

#define IActiveIMMApp_GetCompositionFontA(This,hIMC,plf)	\
    (This)->lpVtbl -> GetCompositionFontA(This,hIMC,plf)

#define IActiveIMMApp_GetCompositionFontW(This,hIMC,plf)	\
    (This)->lpVtbl -> GetCompositionFontW(This,hIMC,plf)

#define IActiveIMMApp_GetCompositionStringA(This,hIMC,dwIndex,dwBufLen,plCopied,pBuf)	\
    (This)->lpVtbl -> GetCompositionStringA(This,hIMC,dwIndex,dwBufLen,plCopied,pBuf)

#define IActiveIMMApp_GetCompositionStringW(This,hIMC,dwIndex,dwBufLen,plCopied,pBuf)	\
    (This)->lpVtbl -> GetCompositionStringW(This,hIMC,dwIndex,dwBufLen,plCopied,pBuf)

#define IActiveIMMApp_GetCompositionWindow(This,hIMC,pCompForm)	\
    (This)->lpVtbl -> GetCompositionWindow(This,hIMC,pCompForm)

#define IActiveIMMApp_GetContext(This,hWnd,phIMC)	\
    (This)->lpVtbl -> GetContext(This,hWnd,phIMC)

#define IActiveIMMApp_GetConversionListA(This,hKL,hIMC,pSrc,uBufLen,uFlag,pDst,puCopied)	\
    (This)->lpVtbl -> GetConversionListA(This,hKL,hIMC,pSrc,uBufLen,uFlag,pDst,puCopied)

#define IActiveIMMApp_GetConversionListW(This,hKL,hIMC,pSrc,uBufLen,uFlag,pDst,puCopied)	\
    (This)->lpVtbl -> GetConversionListW(This,hKL,hIMC,pSrc,uBufLen,uFlag,pDst,puCopied)

#define IActiveIMMApp_GetConversionStatus(This,hIMC,pfdwConversion,pfdwSentence)	\
    (This)->lpVtbl -> GetConversionStatus(This,hIMC,pfdwConversion,pfdwSentence)

#define IActiveIMMApp_GetDefaultIMEWnd(This,hWnd,phDefWnd)	\
    (This)->lpVtbl -> GetDefaultIMEWnd(This,hWnd,phDefWnd)

#define IActiveIMMApp_GetDescriptionA(This,hKL,uBufLen,szDescription,puCopied)	\
    (This)->lpVtbl -> GetDescriptionA(This,hKL,uBufLen,szDescription,puCopied)

#define IActiveIMMApp_GetDescriptionW(This,hKL,uBufLen,szDescription,puCopied)	\
    (This)->lpVtbl -> GetDescriptionW(This,hKL,uBufLen,szDescription,puCopied)

#define IActiveIMMApp_GetGuideLineA(This,hIMC,dwIndex,dwBufLen,pBuf,pdwResult)	\
    (This)->lpVtbl -> GetGuideLineA(This,hIMC,dwIndex,dwBufLen,pBuf,pdwResult)

#define IActiveIMMApp_GetGuideLineW(This,hIMC,dwIndex,dwBufLen,pBuf,pdwResult)	\
    (This)->lpVtbl -> GetGuideLineW(This,hIMC,dwIndex,dwBufLen,pBuf,pdwResult)

#define IActiveIMMApp_GetIMEFileNameA(This,hKL,uBufLen,szFileName,puCopied)	\
    (This)->lpVtbl -> GetIMEFileNameA(This,hKL,uBufLen,szFileName,puCopied)

#define IActiveIMMApp_GetIMEFileNameW(This,hKL,uBufLen,szFileName,puCopied)	\
    (This)->lpVtbl -> GetIMEFileNameW(This,hKL,uBufLen,szFileName,puCopied)

#define IActiveIMMApp_GetOpenStatus(This,hIMC)	\
    (This)->lpVtbl -> GetOpenStatus(This,hIMC)

#define IActiveIMMApp_GetProperty(This,hKL,fdwIndex,pdwProperty)	\
    (This)->lpVtbl -> GetProperty(This,hKL,fdwIndex,pdwProperty)

#define IActiveIMMApp_GetRegisterWordStyleA(This,hKL,nItem,pStyleBuf,puCopied)	\
    (This)->lpVtbl -> GetRegisterWordStyleA(This,hKL,nItem,pStyleBuf,puCopied)

#define IActiveIMMApp_GetRegisterWordStyleW(This,hKL,nItem,pStyleBuf,puCopied)	\
    (This)->lpVtbl -> GetRegisterWordStyleW(This,hKL,nItem,pStyleBuf,puCopied)

#define IActiveIMMApp_GetStatusWindowPos(This,hIMC,pptPos)	\
    (This)->lpVtbl -> GetStatusWindowPos(This,hIMC,pptPos)

#define IActiveIMMApp_GetVirtualKey(This,hWnd,puVirtualKey)	\
    (This)->lpVtbl -> GetVirtualKey(This,hWnd,puVirtualKey)

#define IActiveIMMApp_InstallIMEA(This,szIMEFileName,szLayoutText,phKL)	\
    (This)->lpVtbl -> InstallIMEA(This,szIMEFileName,szLayoutText,phKL)

#define IActiveIMMApp_InstallIMEW(This,szIMEFileName,szLayoutText,phKL)	\
    (This)->lpVtbl -> InstallIMEW(This,szIMEFileName,szLayoutText,phKL)

#define IActiveIMMApp_IsIME(This,hKL)	\
    (This)->lpVtbl -> IsIME(This,hKL)

#define IActiveIMMApp_IsUIMessageA(This,hWndIME,msg,wParam,lParam)	\
    (This)->lpVtbl -> IsUIMessageA(This,hWndIME,msg,wParam,lParam)

#define IActiveIMMApp_IsUIMessageW(This,hWndIME,msg,wParam,lParam)	\
    (This)->lpVtbl -> IsUIMessageW(This,hWndIME,msg,wParam,lParam)

#define IActiveIMMApp_NotifyIME(This,hIMC,dwAction,dwIndex,dwValue)	\
    (This)->lpVtbl -> NotifyIME(This,hIMC,dwAction,dwIndex,dwValue)

#define IActiveIMMApp_RegisterWordA(This,hKL,szReading,dwStyle,szRegister)	\
    (This)->lpVtbl -> RegisterWordA(This,hKL,szReading,dwStyle,szRegister)

#define IActiveIMMApp_RegisterWordW(This,hKL,szReading,dwStyle,szRegister)	\
    (This)->lpVtbl -> RegisterWordW(This,hKL,szReading,dwStyle,szRegister)

#define IActiveIMMApp_ReleaseContext(This,hWnd,hIMC)	\
    (This)->lpVtbl -> ReleaseContext(This,hWnd,hIMC)

#define IActiveIMMApp_SetCandidateWindow(This,hIMC,pCandidate)	\
    (This)->lpVtbl -> SetCandidateWindow(This,hIMC,pCandidate)

#define IActiveIMMApp_SetCompositionFontA(This,hIMC,plf)	\
    (This)->lpVtbl -> SetCompositionFontA(This,hIMC,plf)

#define IActiveIMMApp_SetCompositionFontW(This,hIMC,plf)	\
    (This)->lpVtbl -> SetCompositionFontW(This,hIMC,plf)

#define IActiveIMMApp_SetCompositionStringA(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen)	\
    (This)->lpVtbl -> SetCompositionStringA(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen)

#define IActiveIMMApp_SetCompositionStringW(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen)	\
    (This)->lpVtbl -> SetCompositionStringW(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen)

#define IActiveIMMApp_SetCompositionWindow(This,hIMC,pCompForm)	\
    (This)->lpVtbl -> SetCompositionWindow(This,hIMC,pCompForm)

#define IActiveIMMApp_SetConversionStatus(This,hIMC,fdwConversion,fdwSentence)	\
    (This)->lpVtbl -> SetConversionStatus(This,hIMC,fdwConversion,fdwSentence)

#define IActiveIMMApp_SetOpenStatus(This,hIMC,fOpen)	\
    (This)->lpVtbl -> SetOpenStatus(This,hIMC,fOpen)

#define IActiveIMMApp_SetStatusWindowPos(This,hIMC,pptPos)	\
    (This)->lpVtbl -> SetStatusWindowPos(This,hIMC,pptPos)

#define IActiveIMMApp_SimulateHotKey(This,hWnd,dwHotKeyID)	\
    (This)->lpVtbl -> SimulateHotKey(This,hWnd,dwHotKeyID)

#define IActiveIMMApp_UnregisterWordA(This,hKL,szReading,dwStyle,szUnregister)	\
    (This)->lpVtbl -> UnregisterWordA(This,hKL,szReading,dwStyle,szUnregister)

#define IActiveIMMApp_UnregisterWordW(This,hKL,szReading,dwStyle,szUnregister)	\
    (This)->lpVtbl -> UnregisterWordW(This,hKL,szReading,dwStyle,szUnregister)

#define IActiveIMMApp_Activate(This,fRestoreLayout)	\
    (This)->lpVtbl -> Activate(This,fRestoreLayout)

#define IActiveIMMApp_Deactivate(This)	\
    (This)->lpVtbl -> Deactivate(This)

#define IActiveIMMApp_OnDefWindowProc(This,hWnd,Msg,wParam,lParam,plResult)	\
    (This)->lpVtbl -> OnDefWindowProc(This,hWnd,Msg,wParam,lParam,plResult)

#define IActiveIMMApp_FilterClientWindows(This,aaClassList,uSize)	\
    (This)->lpVtbl -> FilterClientWindows(This,aaClassList,uSize)

#define IActiveIMMApp_GetCodePageA(This,hKL,uCodePage)	\
    (This)->lpVtbl -> GetCodePageA(This,hKL,uCodePage)

#define IActiveIMMApp_GetLangId(This,hKL,plid)	\
    (This)->lpVtbl -> GetLangId(This,hKL,plid)

#define IActiveIMMApp_AssociateContextEx(This,hWnd,hIMC,dwFlags)	\
    (This)->lpVtbl -> AssociateContextEx(This,hWnd,hIMC,dwFlags)

#define IActiveIMMApp_DisableIME(This,idThread)	\
    (This)->lpVtbl -> DisableIME(This,idThread)

#define IActiveIMMApp_GetImeMenuItemsA(This,hIMC,dwFlags,dwType,pImeParentMenu,pImeMenu,dwSize,pdwResult)	\
    (This)->lpVtbl -> GetImeMenuItemsA(This,hIMC,dwFlags,dwType,pImeParentMenu,pImeMenu,dwSize,pdwResult)

#define IActiveIMMApp_GetImeMenuItemsW(This,hIMC,dwFlags,dwType,pImeParentMenu,pImeMenu,dwSize,pdwResult)	\
    (This)->lpVtbl -> GetImeMenuItemsW(This,hIMC,dwFlags,dwType,pImeParentMenu,pImeMenu,dwSize,pdwResult)

#define IActiveIMMApp_EnumInputContext(This,idThread,ppEnum)	\
    (This)->lpVtbl -> EnumInputContext(This,idThread,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IActiveIMMApp_AssociateContext_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HWND hWnd,
    /* [in] */ HIMC hIME,
    /* [out] */ HIMC *phPrev);


void __RPC_STUB IActiveIMMApp_AssociateContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_ConfigureIMEA_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HKL hKL,
    /* [in] */ HWND hWnd,
    /* [in] */ DWORD dwMode,
    /* [in] */ REGISTERWORDA *pData);


void __RPC_STUB IActiveIMMApp_ConfigureIMEA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_ConfigureIMEW_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HKL hKL,
    /* [in] */ HWND hWnd,
    /* [in] */ DWORD dwMode,
    /* [in] */ REGISTERWORDW *pData);


void __RPC_STUB IActiveIMMApp_ConfigureIMEW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_CreateContext_Proxy( 
    IActiveIMMApp * This,
    /* [out] */ HIMC *phIMC);


void __RPC_STUB IActiveIMMApp_CreateContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_DestroyContext_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIME);


void __RPC_STUB IActiveIMMApp_DestroyContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_EnumRegisterWordA_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HKL hKL,
    /* [in] */ LPSTR szReading,
    /* [in] */ DWORD dwStyle,
    /* [in] */ LPSTR szRegister,
    /* [in] */ LPVOID pData,
    /* [out] */ IEnumRegisterWordA **pEnum);


void __RPC_STUB IActiveIMMApp_EnumRegisterWordA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_EnumRegisterWordW_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HKL hKL,
    /* [in] */ LPWSTR szReading,
    /* [in] */ DWORD dwStyle,
    /* [in] */ LPWSTR szRegister,
    /* [in] */ LPVOID pData,
    /* [out] */ IEnumRegisterWordW **pEnum);


void __RPC_STUB IActiveIMMApp_EnumRegisterWordW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_EscapeA_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HKL hKL,
    /* [in] */ HIMC hIMC,
    /* [in] */ UINT uEscape,
    /* [out][in] */ LPVOID pData,
    /* [out] */ LRESULT *plResult);


void __RPC_STUB IActiveIMMApp_EscapeA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_EscapeW_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HKL hKL,
    /* [in] */ HIMC hIMC,
    /* [in] */ UINT uEscape,
    /* [out][in] */ LPVOID pData,
    /* [out] */ LRESULT *plResult);


void __RPC_STUB IActiveIMMApp_EscapeW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetCandidateListA_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ UINT uBufLen,
    /* [out] */ CANDIDATELIST *pCandList,
    /* [out] */ UINT *puCopied);


void __RPC_STUB IActiveIMMApp_GetCandidateListA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetCandidateListW_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ UINT uBufLen,
    /* [out] */ CANDIDATELIST *pCandList,
    /* [out] */ UINT *puCopied);


void __RPC_STUB IActiveIMMApp_GetCandidateListW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetCandidateListCountA_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [out] */ DWORD *pdwListSize,
    /* [out] */ DWORD *pdwBufLen);


void __RPC_STUB IActiveIMMApp_GetCandidateListCountA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetCandidateListCountW_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [out] */ DWORD *pdwListSize,
    /* [out] */ DWORD *pdwBufLen);


void __RPC_STUB IActiveIMMApp_GetCandidateListCountW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetCandidateWindow_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [out] */ CANDIDATEFORM *pCandidate);


void __RPC_STUB IActiveIMMApp_GetCandidateWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetCompositionFontA_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [out] */ LOGFONTA *plf);


void __RPC_STUB IActiveIMMApp_GetCompositionFontA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetCompositionFontW_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [out] */ LOGFONTW *plf);


void __RPC_STUB IActiveIMMApp_GetCompositionFontW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetCompositionStringA_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ DWORD dwBufLen,
    /* [out] */ LONG *plCopied,
    /* [out] */ LPVOID pBuf);


void __RPC_STUB IActiveIMMApp_GetCompositionStringA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetCompositionStringW_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ DWORD dwBufLen,
    /* [out] */ LONG *plCopied,
    /* [out] */ LPVOID pBuf);


void __RPC_STUB IActiveIMMApp_GetCompositionStringW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetCompositionWindow_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [out] */ COMPOSITIONFORM *pCompForm);


void __RPC_STUB IActiveIMMApp_GetCompositionWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetContext_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HWND hWnd,
    /* [out] */ HIMC *phIMC);


void __RPC_STUB IActiveIMMApp_GetContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetConversionListA_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HKL hKL,
    /* [in] */ HIMC hIMC,
    /* [in] */ LPSTR pSrc,
    /* [in] */ UINT uBufLen,
    /* [in] */ UINT uFlag,
    /* [out] */ CANDIDATELIST *pDst,
    /* [out] */ UINT *puCopied);


void __RPC_STUB IActiveIMMApp_GetConversionListA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetConversionListW_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HKL hKL,
    /* [in] */ HIMC hIMC,
    /* [in] */ LPWSTR pSrc,
    /* [in] */ UINT uBufLen,
    /* [in] */ UINT uFlag,
    /* [out] */ CANDIDATELIST *pDst,
    /* [out] */ UINT *puCopied);


void __RPC_STUB IActiveIMMApp_GetConversionListW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetConversionStatus_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [out] */ DWORD *pfdwConversion,
    /* [out] */ DWORD *pfdwSentence);


void __RPC_STUB IActiveIMMApp_GetConversionStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetDefaultIMEWnd_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HWND hWnd,
    /* [out] */ HWND *phDefWnd);


void __RPC_STUB IActiveIMMApp_GetDefaultIMEWnd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetDescriptionA_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HKL hKL,
    /* [in] */ UINT uBufLen,
    /* [out] */ LPSTR szDescription,
    /* [out] */ UINT *puCopied);


void __RPC_STUB IActiveIMMApp_GetDescriptionA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetDescriptionW_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HKL hKL,
    /* [in] */ UINT uBufLen,
    /* [out] */ LPWSTR szDescription,
    /* [out] */ UINT *puCopied);


void __RPC_STUB IActiveIMMApp_GetDescriptionW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetGuideLineA_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ DWORD dwBufLen,
    /* [out] */ LPSTR pBuf,
    /* [out] */ DWORD *pdwResult);


void __RPC_STUB IActiveIMMApp_GetGuideLineA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetGuideLineW_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ DWORD dwBufLen,
    /* [out] */ LPWSTR pBuf,
    /* [out] */ DWORD *pdwResult);


void __RPC_STUB IActiveIMMApp_GetGuideLineW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetIMEFileNameA_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HKL hKL,
    /* [in] */ UINT uBufLen,
    /* [out] */ LPSTR szFileName,
    /* [out] */ UINT *puCopied);


void __RPC_STUB IActiveIMMApp_GetIMEFileNameA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetIMEFileNameW_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HKL hKL,
    /* [in] */ UINT uBufLen,
    /* [out] */ LPWSTR szFileName,
    /* [out] */ UINT *puCopied);


void __RPC_STUB IActiveIMMApp_GetIMEFileNameW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetOpenStatus_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC);


void __RPC_STUB IActiveIMMApp_GetOpenStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetProperty_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HKL hKL,
    /* [in] */ DWORD fdwIndex,
    /* [out] */ DWORD *pdwProperty);


void __RPC_STUB IActiveIMMApp_GetProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetRegisterWordStyleA_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HKL hKL,
    /* [in] */ UINT nItem,
    /* [out] */ STYLEBUFA *pStyleBuf,
    /* [out] */ UINT *puCopied);


void __RPC_STUB IActiveIMMApp_GetRegisterWordStyleA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetRegisterWordStyleW_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HKL hKL,
    /* [in] */ UINT nItem,
    /* [out] */ STYLEBUFW *pStyleBuf,
    /* [out] */ UINT *puCopied);


void __RPC_STUB IActiveIMMApp_GetRegisterWordStyleW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetStatusWindowPos_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [out] */ POINT *pptPos);


void __RPC_STUB IActiveIMMApp_GetStatusWindowPos_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetVirtualKey_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HWND hWnd,
    /* [out] */ UINT *puVirtualKey);


void __RPC_STUB IActiveIMMApp_GetVirtualKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_InstallIMEA_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ LPSTR szIMEFileName,
    /* [in] */ LPSTR szLayoutText,
    /* [out] */ HKL *phKL);


void __RPC_STUB IActiveIMMApp_InstallIMEA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_InstallIMEW_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ LPWSTR szIMEFileName,
    /* [in] */ LPWSTR szLayoutText,
    /* [out] */ HKL *phKL);


void __RPC_STUB IActiveIMMApp_InstallIMEW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_IsIME_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HKL hKL);


void __RPC_STUB IActiveIMMApp_IsIME_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_IsUIMessageA_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HWND hWndIME,
    /* [in] */ UINT msg,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam);


void __RPC_STUB IActiveIMMApp_IsUIMessageA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_IsUIMessageW_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HWND hWndIME,
    /* [in] */ UINT msg,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam);


void __RPC_STUB IActiveIMMApp_IsUIMessageW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_NotifyIME_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwAction,
    /* [in] */ DWORD dwIndex,
    /* [in] */ DWORD dwValue);


void __RPC_STUB IActiveIMMApp_NotifyIME_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_RegisterWordA_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HKL hKL,
    /* [in] */ LPSTR szReading,
    /* [in] */ DWORD dwStyle,
    /* [in] */ LPSTR szRegister);


void __RPC_STUB IActiveIMMApp_RegisterWordA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_RegisterWordW_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HKL hKL,
    /* [in] */ LPWSTR szReading,
    /* [in] */ DWORD dwStyle,
    /* [in] */ LPWSTR szRegister);


void __RPC_STUB IActiveIMMApp_RegisterWordW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_ReleaseContext_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HWND hWnd,
    /* [in] */ HIMC hIMC);


void __RPC_STUB IActiveIMMApp_ReleaseContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_SetCandidateWindow_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ CANDIDATEFORM *pCandidate);


void __RPC_STUB IActiveIMMApp_SetCandidateWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_SetCompositionFontA_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ LOGFONTA *plf);


void __RPC_STUB IActiveIMMApp_SetCompositionFontA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_SetCompositionFontW_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ LOGFONTW *plf);


void __RPC_STUB IActiveIMMApp_SetCompositionFontW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_SetCompositionStringA_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ LPVOID pComp,
    /* [in] */ DWORD dwCompLen,
    /* [in] */ LPVOID pRead,
    /* [in] */ DWORD dwReadLen);


void __RPC_STUB IActiveIMMApp_SetCompositionStringA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_SetCompositionStringW_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ LPVOID pComp,
    /* [in] */ DWORD dwCompLen,
    /* [in] */ LPVOID pRead,
    /* [in] */ DWORD dwReadLen);


void __RPC_STUB IActiveIMMApp_SetCompositionStringW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_SetCompositionWindow_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ COMPOSITIONFORM *pCompForm);


void __RPC_STUB IActiveIMMApp_SetCompositionWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_SetConversionStatus_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD fdwConversion,
    /* [in] */ DWORD fdwSentence);


void __RPC_STUB IActiveIMMApp_SetConversionStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_SetOpenStatus_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ BOOL fOpen);


void __RPC_STUB IActiveIMMApp_SetOpenStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_SetStatusWindowPos_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ POINT *pptPos);


void __RPC_STUB IActiveIMMApp_SetStatusWindowPos_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_SimulateHotKey_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HWND hWnd,
    /* [in] */ DWORD dwHotKeyID);


void __RPC_STUB IActiveIMMApp_SimulateHotKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_UnregisterWordA_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HKL hKL,
    /* [in] */ LPSTR szReading,
    /* [in] */ DWORD dwStyle,
    /* [in] */ LPSTR szUnregister);


void __RPC_STUB IActiveIMMApp_UnregisterWordA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_UnregisterWordW_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HKL hKL,
    /* [in] */ LPWSTR szReading,
    /* [in] */ DWORD dwStyle,
    /* [in] */ LPWSTR szUnregister);


void __RPC_STUB IActiveIMMApp_UnregisterWordW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_Activate_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ BOOL fRestoreLayout);


void __RPC_STUB IActiveIMMApp_Activate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_Deactivate_Proxy( 
    IActiveIMMApp * This);


void __RPC_STUB IActiveIMMApp_Deactivate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_OnDefWindowProc_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HWND hWnd,
    /* [in] */ UINT Msg,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam,
    /* [out] */ LRESULT *plResult);


void __RPC_STUB IActiveIMMApp_OnDefWindowProc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_FilterClientWindows_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ ATOM *aaClassList,
    /* [in] */ UINT uSize);


void __RPC_STUB IActiveIMMApp_FilterClientWindows_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetCodePageA_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HKL hKL,
    /* [out] */ UINT *uCodePage);


void __RPC_STUB IActiveIMMApp_GetCodePageA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetLangId_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HKL hKL,
    /* [out] */ LANGID *plid);


void __RPC_STUB IActiveIMMApp_GetLangId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_AssociateContextEx_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HWND hWnd,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IActiveIMMApp_AssociateContextEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_DisableIME_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ DWORD idThread);


void __RPC_STUB IActiveIMMApp_DisableIME_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetImeMenuItemsA_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwFlags,
    /* [in] */ DWORD dwType,
    /* [in] */ IMEMENUITEMINFOA *pImeParentMenu,
    /* [out] */ IMEMENUITEMINFOA *pImeMenu,
    /* [in] */ DWORD dwSize,
    /* [out] */ DWORD *pdwResult);


void __RPC_STUB IActiveIMMApp_GetImeMenuItemsA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetImeMenuItemsW_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwFlags,
    /* [in] */ DWORD dwType,
    /* [in] */ IMEMENUITEMINFOW *pImeParentMenu,
    /* [out] */ IMEMENUITEMINFOW *pImeMenu,
    /* [in] */ DWORD dwSize,
    /* [out] */ DWORD *pdwResult);


void __RPC_STUB IActiveIMMApp_GetImeMenuItemsW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_EnumInputContext_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ DWORD idThread,
    /* [out] */ IEnumInputContext **ppEnum);


void __RPC_STUB IActiveIMMApp_EnumInputContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IActiveIMMApp_INTERFACE_DEFINED__ */


#ifndef __IActiveIMMIME_INTERFACE_DEFINED__
#define __IActiveIMMIME_INTERFACE_DEFINED__

/* interface IActiveIMMIME */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IActiveIMMIME;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("08C03411-F96B-11d0-A475-00AA006BCC59")
    IActiveIMMIME : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AssociateContext( 
            /* [in] */ HWND hWnd,
            /* [in] */ HIMC hIME,
            /* [out] */ HIMC *phPrev) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConfigureIMEA( 
            /* [in] */ HKL hKL,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwMode,
            /* [in] */ REGISTERWORDA *pData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConfigureIMEW( 
            /* [in] */ HKL hKL,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwMode,
            /* [in] */ REGISTERWORDW *pData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateContext( 
            /* [out] */ HIMC *phIMC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DestroyContext( 
            /* [in] */ HIMC hIME) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumRegisterWordA( 
            /* [in] */ HKL hKL,
            /* [in] */ LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPSTR szRegister,
            /* [in] */ LPVOID pData,
            /* [out] */ IEnumRegisterWordA **pEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumRegisterWordW( 
            /* [in] */ HKL hKL,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szRegister,
            /* [in] */ LPVOID pData,
            /* [out] */ IEnumRegisterWordW **pEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EscapeA( 
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uEscape,
            /* [out][in] */ LPVOID pData,
            /* [out] */ LRESULT *plResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EscapeW( 
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uEscape,
            /* [out][in] */ LPVOID pData,
            /* [out] */ LRESULT *plResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCandidateListA( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ UINT uBufLen,
            /* [out] */ CANDIDATELIST *pCandList,
            /* [out] */ UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCandidateListW( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ UINT uBufLen,
            /* [out] */ CANDIDATELIST *pCandList,
            /* [out] */ UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCandidateListCountA( 
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD *pdwListSize,
            /* [out] */ DWORD *pdwBufLen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCandidateListCountW( 
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD *pdwListSize,
            /* [out] */ DWORD *pdwBufLen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCandidateWindow( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [out] */ CANDIDATEFORM *pCandidate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCompositionFontA( 
            /* [in] */ HIMC hIMC,
            /* [out] */ LOGFONTA *plf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCompositionFontW( 
            /* [in] */ HIMC hIMC,
            /* [out] */ LOGFONTW *plf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCompositionStringA( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LONG *plCopied,
            /* [out] */ LPVOID pBuf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCompositionStringW( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LONG *plCopied,
            /* [out] */ LPVOID pBuf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCompositionWindow( 
            /* [in] */ HIMC hIMC,
            /* [out] */ COMPOSITIONFORM *pCompForm) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetContext( 
            /* [in] */ HWND hWnd,
            /* [out] */ HIMC *phIMC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConversionListA( 
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ LPSTR pSrc,
            /* [in] */ UINT uBufLen,
            /* [in] */ UINT uFlag,
            /* [out] */ CANDIDATELIST *pDst,
            /* [out] */ UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConversionListW( 
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ LPWSTR pSrc,
            /* [in] */ UINT uBufLen,
            /* [in] */ UINT uFlag,
            /* [out] */ CANDIDATELIST *pDst,
            /* [out] */ UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConversionStatus( 
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD *pfdwConversion,
            /* [out] */ DWORD *pfdwSentence) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDefaultIMEWnd( 
            /* [in] */ HWND hWnd,
            /* [out] */ HWND *phDefWnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDescriptionA( 
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPSTR szDescription,
            /* [out] */ UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDescriptionW( 
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPWSTR szDescription,
            /* [out] */ UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGuideLineA( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LPSTR pBuf,
            /* [out] */ DWORD *pdwResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGuideLineW( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LPWSTR pBuf,
            /* [out] */ DWORD *pdwResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIMEFileNameA( 
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPSTR szFileName,
            /* [out] */ UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIMEFileNameW( 
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPWSTR szFileName,
            /* [out] */ UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOpenStatus( 
            /* [in] */ HIMC hIMC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProperty( 
            /* [in] */ HKL hKL,
            /* [in] */ DWORD fdwIndex,
            /* [out] */ DWORD *pdwProperty) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRegisterWordStyleA( 
            /* [in] */ HKL hKL,
            /* [in] */ UINT nItem,
            /* [out] */ STYLEBUFA *pStyleBuf,
            /* [out] */ UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRegisterWordStyleW( 
            /* [in] */ HKL hKL,
            /* [in] */ UINT nItem,
            /* [out] */ STYLEBUFW *pStyleBuf,
            /* [out] */ UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStatusWindowPos( 
            /* [in] */ HIMC hIMC,
            /* [out] */ POINT *pptPos) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVirtualKey( 
            /* [in] */ HWND hWnd,
            /* [out] */ UINT *puVirtualKey) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InstallIMEA( 
            /* [in] */ LPSTR szIMEFileName,
            /* [in] */ LPSTR szLayoutText,
            /* [out] */ HKL *phKL) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InstallIMEW( 
            /* [in] */ LPWSTR szIMEFileName,
            /* [in] */ LPWSTR szLayoutText,
            /* [out] */ HKL *phKL) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsIME( 
            /* [in] */ HKL hKL) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsUIMessageA( 
            /* [in] */ HWND hWndIME,
            /* [in] */ UINT msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsUIMessageW( 
            /* [in] */ HWND hWndIME,
            /* [in] */ UINT msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NotifyIME( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwAction,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterWordA( 
            /* [in] */ HKL hKL,
            /* [in] */ LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPSTR szRegister) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterWordW( 
            /* [in] */ HKL hKL,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szRegister) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReleaseContext( 
            /* [in] */ HWND hWnd,
            /* [in] */ HIMC hIMC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCandidateWindow( 
            /* [in] */ HIMC hIMC,
            /* [in] */ CANDIDATEFORM *pCandidate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCompositionFontA( 
            /* [in] */ HIMC hIMC,
            /* [in] */ LOGFONTA *plf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCompositionFontW( 
            /* [in] */ HIMC hIMC,
            /* [in] */ LOGFONTW *plf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCompositionStringA( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ LPVOID pComp,
            /* [in] */ DWORD dwCompLen,
            /* [in] */ LPVOID pRead,
            /* [in] */ DWORD dwReadLen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCompositionStringW( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ LPVOID pComp,
            /* [in] */ DWORD dwCompLen,
            /* [in] */ LPVOID pRead,
            /* [in] */ DWORD dwReadLen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCompositionWindow( 
            /* [in] */ HIMC hIMC,
            /* [in] */ COMPOSITIONFORM *pCompForm) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetConversionStatus( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD fdwConversion,
            /* [in] */ DWORD fdwSentence) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOpenStatus( 
            /* [in] */ HIMC hIMC,
            /* [in] */ BOOL fOpen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStatusWindowPos( 
            /* [in] */ HIMC hIMC,
            /* [in] */ POINT *pptPos) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SimulateHotKey( 
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwHotKeyID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnregisterWordA( 
            /* [in] */ HKL hKL,
            /* [in] */ LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPSTR szUnregister) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnregisterWordW( 
            /* [in] */ HKL hKL,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szUnregister) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GenerateMessage( 
            /* [in] */ HIMC hIMC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LockIMC( 
            /* [in] */ HIMC hIMC,
            /* [out] */ INPUTCONTEXT **ppIMC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnlockIMC( 
            /* [in] */ HIMC hIMC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIMCLockCount( 
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD *pdwLockCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateIMCC( 
            /* [in] */ DWORD dwSize,
            /* [out] */ HIMCC *phIMCC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DestroyIMCC( 
            /* [in] */ HIMCC hIMCC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LockIMCC( 
            /* [in] */ HIMCC hIMCC,
            /* [out] */ void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnlockIMCC( 
            /* [in] */ HIMCC hIMCC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReSizeIMCC( 
            /* [in] */ HIMCC hIMCC,
            /* [in] */ DWORD dwSize,
            /* [out] */ HIMCC *phIMCC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIMCCSize( 
            /* [in] */ HIMCC hIMCC,
            /* [out] */ DWORD *pdwSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIMCCLockCount( 
            /* [in] */ HIMCC hIMCC,
            /* [out] */ DWORD *pdwLockCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetHotKey( 
            /* [in] */ DWORD dwHotKeyID,
            /* [out] */ UINT *puModifiers,
            /* [out] */ UINT *puVKey,
            /* [out] */ HKL *phKL) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetHotKey( 
            /* [in] */ DWORD dwHotKeyID,
            /* [in] */ UINT uModifiers,
            /* [in] */ UINT uVKey,
            /* [in] */ HKL hKL) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateSoftKeyboard( 
            /* [in] */ UINT uType,
            /* [in] */ HWND hOwner,
            /* [in] */ int x,
            /* [in] */ int y,
            /* [out] */ HWND *phSoftKbdWnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DestroySoftKeyboard( 
            /* [in] */ HWND hSoftKbdWnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ShowSoftKeyboard( 
            /* [in] */ HWND hSoftKbdWnd,
            /* [in] */ int nCmdShow) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCodePageA( 
            /* [in] */ HKL hKL,
            /* [out] */ UINT *uCodePage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLangId( 
            /* [in] */ HKL hKL,
            /* [out] */ LANGID *plid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE KeybdEvent( 
            /* [in] */ LANGID lgidIME,
            /* [in] */ BYTE bVk,
            /* [in] */ BYTE bScan,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwExtraInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LockModal( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnlockModal( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AssociateContextEx( 
            /* [in] */ HWND hWnd,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DisableIME( 
            /* [in] */ DWORD idThread) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetImeMenuItemsA( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwType,
            /* [in] */ IMEMENUITEMINFOA *pImeParentMenu,
            /* [out] */ IMEMENUITEMINFOA *pImeMenu,
            /* [in] */ DWORD dwSize,
            /* [out] */ DWORD *pdwResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetImeMenuItemsW( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwType,
            /* [in] */ IMEMENUITEMINFOW *pImeParentMenu,
            /* [out] */ IMEMENUITEMINFOW *pImeMenu,
            /* [in] */ DWORD dwSize,
            /* [out] */ DWORD *pdwResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumInputContext( 
            /* [in] */ DWORD idThread,
            /* [out] */ IEnumInputContext **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RequestMessageA( 
            /* [in] */ HIMC hIMC,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ LRESULT *plResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RequestMessageW( 
            /* [in] */ HIMC hIMC,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ LRESULT *plResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SendIMCA( 
            /* [in] */ HWND hWnd,
            /* [in] */ UINT uMsg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ LRESULT *plResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SendIMCW( 
            /* [in] */ HWND hWnd,
            /* [in] */ UINT uMsg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ LRESULT *plResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsSleeping( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveIMMIMEVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IActiveIMMIME * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IActiveIMMIME * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IActiveIMMIME * This);
        
        HRESULT ( STDMETHODCALLTYPE *AssociateContext )( 
            IActiveIMMIME * This,
            /* [in] */ HWND hWnd,
            /* [in] */ HIMC hIME,
            /* [out] */ HIMC *phPrev);
        
        HRESULT ( STDMETHODCALLTYPE *ConfigureIMEA )( 
            IActiveIMMIME * This,
            /* [in] */ HKL hKL,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwMode,
            /* [in] */ REGISTERWORDA *pData);
        
        HRESULT ( STDMETHODCALLTYPE *ConfigureIMEW )( 
            IActiveIMMIME * This,
            /* [in] */ HKL hKL,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwMode,
            /* [in] */ REGISTERWORDW *pData);
        
        HRESULT ( STDMETHODCALLTYPE *CreateContext )( 
            IActiveIMMIME * This,
            /* [out] */ HIMC *phIMC);
        
        HRESULT ( STDMETHODCALLTYPE *DestroyContext )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIME);
        
        HRESULT ( STDMETHODCALLTYPE *EnumRegisterWordA )( 
            IActiveIMMIME * This,
            /* [in] */ HKL hKL,
            /* [in] */ LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPSTR szRegister,
            /* [in] */ LPVOID pData,
            /* [out] */ IEnumRegisterWordA **pEnum);
        
        HRESULT ( STDMETHODCALLTYPE *EnumRegisterWordW )( 
            IActiveIMMIME * This,
            /* [in] */ HKL hKL,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szRegister,
            /* [in] */ LPVOID pData,
            /* [out] */ IEnumRegisterWordW **pEnum);
        
        HRESULT ( STDMETHODCALLTYPE *EscapeA )( 
            IActiveIMMIME * This,
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uEscape,
            /* [out][in] */ LPVOID pData,
            /* [out] */ LRESULT *plResult);
        
        HRESULT ( STDMETHODCALLTYPE *EscapeW )( 
            IActiveIMMIME * This,
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uEscape,
            /* [out][in] */ LPVOID pData,
            /* [out] */ LRESULT *plResult);
        
        HRESULT ( STDMETHODCALLTYPE *GetCandidateListA )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ UINT uBufLen,
            /* [out] */ CANDIDATELIST *pCandList,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetCandidateListW )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ UINT uBufLen,
            /* [out] */ CANDIDATELIST *pCandList,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetCandidateListCountA )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD *pdwListSize,
            /* [out] */ DWORD *pdwBufLen);
        
        HRESULT ( STDMETHODCALLTYPE *GetCandidateListCountW )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD *pdwListSize,
            /* [out] */ DWORD *pdwBufLen);
        
        HRESULT ( STDMETHODCALLTYPE *GetCandidateWindow )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [out] */ CANDIDATEFORM *pCandidate);
        
        HRESULT ( STDMETHODCALLTYPE *GetCompositionFontA )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ LOGFONTA *plf);
        
        HRESULT ( STDMETHODCALLTYPE *GetCompositionFontW )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ LOGFONTW *plf);
        
        HRESULT ( STDMETHODCALLTYPE *GetCompositionStringA )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LONG *plCopied,
            /* [out] */ LPVOID pBuf);
        
        HRESULT ( STDMETHODCALLTYPE *GetCompositionStringW )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LONG *plCopied,
            /* [out] */ LPVOID pBuf);
        
        HRESULT ( STDMETHODCALLTYPE *GetCompositionWindow )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ COMPOSITIONFORM *pCompForm);
        
        HRESULT ( STDMETHODCALLTYPE *GetContext )( 
            IActiveIMMIME * This,
            /* [in] */ HWND hWnd,
            /* [out] */ HIMC *phIMC);
        
        HRESULT ( STDMETHODCALLTYPE *GetConversionListA )( 
            IActiveIMMIME * This,
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ LPSTR pSrc,
            /* [in] */ UINT uBufLen,
            /* [in] */ UINT uFlag,
            /* [out] */ CANDIDATELIST *pDst,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetConversionListW )( 
            IActiveIMMIME * This,
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ LPWSTR pSrc,
            /* [in] */ UINT uBufLen,
            /* [in] */ UINT uFlag,
            /* [out] */ CANDIDATELIST *pDst,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetConversionStatus )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD *pfdwConversion,
            /* [out] */ DWORD *pfdwSentence);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultIMEWnd )( 
            IActiveIMMIME * This,
            /* [in] */ HWND hWnd,
            /* [out] */ HWND *phDefWnd);
        
        HRESULT ( STDMETHODCALLTYPE *GetDescriptionA )( 
            IActiveIMMIME * This,
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPSTR szDescription,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetDescriptionW )( 
            IActiveIMMIME * This,
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPWSTR szDescription,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetGuideLineA )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LPSTR pBuf,
            /* [out] */ DWORD *pdwResult);
        
        HRESULT ( STDMETHODCALLTYPE *GetGuideLineW )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LPWSTR pBuf,
            /* [out] */ DWORD *pdwResult);
        
        HRESULT ( STDMETHODCALLTYPE *GetIMEFileNameA )( 
            IActiveIMMIME * This,
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPSTR szFileName,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetIMEFileNameW )( 
            IActiveIMMIME * This,
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPWSTR szFileName,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetOpenStatus )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC);
        
        HRESULT ( STDMETHODCALLTYPE *GetProperty )( 
            IActiveIMMIME * This,
            /* [in] */ HKL hKL,
            /* [in] */ DWORD fdwIndex,
            /* [out] */ DWORD *pdwProperty);
        
        HRESULT ( STDMETHODCALLTYPE *GetRegisterWordStyleA )( 
            IActiveIMMIME * This,
            /* [in] */ HKL hKL,
            /* [in] */ UINT nItem,
            /* [out] */ STYLEBUFA *pStyleBuf,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetRegisterWordStyleW )( 
            IActiveIMMIME * This,
            /* [in] */ HKL hKL,
            /* [in] */ UINT nItem,
            /* [out] */ STYLEBUFW *pStyleBuf,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetStatusWindowPos )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ POINT *pptPos);
        
        HRESULT ( STDMETHODCALLTYPE *GetVirtualKey )( 
            IActiveIMMIME * This,
            /* [in] */ HWND hWnd,
            /* [out] */ UINT *puVirtualKey);
        
        HRESULT ( STDMETHODCALLTYPE *InstallIMEA )( 
            IActiveIMMIME * This,
            /* [in] */ LPSTR szIMEFileName,
            /* [in] */ LPSTR szLayoutText,
            /* [out] */ HKL *phKL);
        
        HRESULT ( STDMETHODCALLTYPE *InstallIMEW )( 
            IActiveIMMIME * This,
            /* [in] */ LPWSTR szIMEFileName,
            /* [in] */ LPWSTR szLayoutText,
            /* [out] */ HKL *phKL);
        
        HRESULT ( STDMETHODCALLTYPE *IsIME )( 
            IActiveIMMIME * This,
            /* [in] */ HKL hKL);
        
        HRESULT ( STDMETHODCALLTYPE *IsUIMessageA )( 
            IActiveIMMIME * This,
            /* [in] */ HWND hWndIME,
            /* [in] */ UINT msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam);
        
        HRESULT ( STDMETHODCALLTYPE *IsUIMessageW )( 
            IActiveIMMIME * This,
            /* [in] */ HWND hWndIME,
            /* [in] */ UINT msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam);
        
        HRESULT ( STDMETHODCALLTYPE *NotifyIME )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwAction,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwValue);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterWordA )( 
            IActiveIMMIME * This,
            /* [in] */ HKL hKL,
            /* [in] */ LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPSTR szRegister);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterWordW )( 
            IActiveIMMIME * This,
            /* [in] */ HKL hKL,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szRegister);
        
        HRESULT ( STDMETHODCALLTYPE *ReleaseContext )( 
            IActiveIMMIME * This,
            /* [in] */ HWND hWnd,
            /* [in] */ HIMC hIMC);
        
        HRESULT ( STDMETHODCALLTYPE *SetCandidateWindow )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ CANDIDATEFORM *pCandidate);
        
        HRESULT ( STDMETHODCALLTYPE *SetCompositionFontA )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ LOGFONTA *plf);
        
        HRESULT ( STDMETHODCALLTYPE *SetCompositionFontW )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ LOGFONTW *plf);
        
        HRESULT ( STDMETHODCALLTYPE *SetCompositionStringA )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ LPVOID pComp,
            /* [in] */ DWORD dwCompLen,
            /* [in] */ LPVOID pRead,
            /* [in] */ DWORD dwReadLen);
        
        HRESULT ( STDMETHODCALLTYPE *SetCompositionStringW )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ LPVOID pComp,
            /* [in] */ DWORD dwCompLen,
            /* [in] */ LPVOID pRead,
            /* [in] */ DWORD dwReadLen);
        
        HRESULT ( STDMETHODCALLTYPE *SetCompositionWindow )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ COMPOSITIONFORM *pCompForm);
        
        HRESULT ( STDMETHODCALLTYPE *SetConversionStatus )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD fdwConversion,
            /* [in] */ DWORD fdwSentence);
        
        HRESULT ( STDMETHODCALLTYPE *SetOpenStatus )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ BOOL fOpen);
        
        HRESULT ( STDMETHODCALLTYPE *SetStatusWindowPos )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ POINT *pptPos);
        
        HRESULT ( STDMETHODCALLTYPE *SimulateHotKey )( 
            IActiveIMMIME * This,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwHotKeyID);
        
        HRESULT ( STDMETHODCALLTYPE *UnregisterWordA )( 
            IActiveIMMIME * This,
            /* [in] */ HKL hKL,
            /* [in] */ LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPSTR szUnregister);
        
        HRESULT ( STDMETHODCALLTYPE *UnregisterWordW )( 
            IActiveIMMIME * This,
            /* [in] */ HKL hKL,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szUnregister);
        
        HRESULT ( STDMETHODCALLTYPE *GenerateMessage )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC);
        
        HRESULT ( STDMETHODCALLTYPE *LockIMC )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ INPUTCONTEXT **ppIMC);
        
        HRESULT ( STDMETHODCALLTYPE *UnlockIMC )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC);
        
        HRESULT ( STDMETHODCALLTYPE *GetIMCLockCount )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD *pdwLockCount);
        
        HRESULT ( STDMETHODCALLTYPE *CreateIMCC )( 
            IActiveIMMIME * This,
            /* [in] */ DWORD dwSize,
            /* [out] */ HIMCC *phIMCC);
        
        HRESULT ( STDMETHODCALLTYPE *DestroyIMCC )( 
            IActiveIMMIME * This,
            /* [in] */ HIMCC hIMCC);
        
        HRESULT ( STDMETHODCALLTYPE *LockIMCC )( 
            IActiveIMMIME * This,
            /* [in] */ HIMCC hIMCC,
            /* [out] */ void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *UnlockIMCC )( 
            IActiveIMMIME * This,
            /* [in] */ HIMCC hIMCC);
        
        HRESULT ( STDMETHODCALLTYPE *ReSizeIMCC )( 
            IActiveIMMIME * This,
            /* [in] */ HIMCC hIMCC,
            /* [in] */ DWORD dwSize,
            /* [out] */ HIMCC *phIMCC);
        
        HRESULT ( STDMETHODCALLTYPE *GetIMCCSize )( 
            IActiveIMMIME * This,
            /* [in] */ HIMCC hIMCC,
            /* [out] */ DWORD *pdwSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetIMCCLockCount )( 
            IActiveIMMIME * This,
            /* [in] */ HIMCC hIMCC,
            /* [out] */ DWORD *pdwLockCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetHotKey )( 
            IActiveIMMIME * This,
            /* [in] */ DWORD dwHotKeyID,
            /* [out] */ UINT *puModifiers,
            /* [out] */ UINT *puVKey,
            /* [out] */ HKL *phKL);
        
        HRESULT ( STDMETHODCALLTYPE *SetHotKey )( 
            IActiveIMMIME * This,
            /* [in] */ DWORD dwHotKeyID,
            /* [in] */ UINT uModifiers,
            /* [in] */ UINT uVKey,
            /* [in] */ HKL hKL);
        
        HRESULT ( STDMETHODCALLTYPE *CreateSoftKeyboard )( 
            IActiveIMMIME * This,
            /* [in] */ UINT uType,
            /* [in] */ HWND hOwner,
            /* [in] */ int x,
            /* [in] */ int y,
            /* [out] */ HWND *phSoftKbdWnd);
        
        HRESULT ( STDMETHODCALLTYPE *DestroySoftKeyboard )( 
            IActiveIMMIME * This,
            /* [in] */ HWND hSoftKbdWnd);
        
        HRESULT ( STDMETHODCALLTYPE *ShowSoftKeyboard )( 
            IActiveIMMIME * This,
            /* [in] */ HWND hSoftKbdWnd,
            /* [in] */ int nCmdShow);
        
        HRESULT ( STDMETHODCALLTYPE *GetCodePageA )( 
            IActiveIMMIME * This,
            /* [in] */ HKL hKL,
            /* [out] */ UINT *uCodePage);
        
        HRESULT ( STDMETHODCALLTYPE *GetLangId )( 
            IActiveIMMIME * This,
            /* [in] */ HKL hKL,
            /* [out] */ LANGID *plid);
        
        HRESULT ( STDMETHODCALLTYPE *KeybdEvent )( 
            IActiveIMMIME * This,
            /* [in] */ LANGID lgidIME,
            /* [in] */ BYTE bVk,
            /* [in] */ BYTE bScan,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwExtraInfo);
        
        HRESULT ( STDMETHODCALLTYPE *LockModal )( 
            IActiveIMMIME * This);
        
        HRESULT ( STDMETHODCALLTYPE *UnlockModal )( 
            IActiveIMMIME * This);
        
        HRESULT ( STDMETHODCALLTYPE *AssociateContextEx )( 
            IActiveIMMIME * This,
            /* [in] */ HWND hWnd,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *DisableIME )( 
            IActiveIMMIME * This,
            /* [in] */ DWORD idThread);
        
        HRESULT ( STDMETHODCALLTYPE *GetImeMenuItemsA )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwType,
            /* [in] */ IMEMENUITEMINFOA *pImeParentMenu,
            /* [out] */ IMEMENUITEMINFOA *pImeMenu,
            /* [in] */ DWORD dwSize,
            /* [out] */ DWORD *pdwResult);
        
        HRESULT ( STDMETHODCALLTYPE *GetImeMenuItemsW )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwType,
            /* [in] */ IMEMENUITEMINFOW *pImeParentMenu,
            /* [out] */ IMEMENUITEMINFOW *pImeMenu,
            /* [in] */ DWORD dwSize,
            /* [out] */ DWORD *pdwResult);
        
        HRESULT ( STDMETHODCALLTYPE *EnumInputContext )( 
            IActiveIMMIME * This,
            /* [in] */ DWORD idThread,
            /* [out] */ IEnumInputContext **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *RequestMessageA )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ LRESULT *plResult);
        
        HRESULT ( STDMETHODCALLTYPE *RequestMessageW )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ LRESULT *plResult);
        
        HRESULT ( STDMETHODCALLTYPE *SendIMCA )( 
            IActiveIMMIME * This,
            /* [in] */ HWND hWnd,
            /* [in] */ UINT uMsg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ LRESULT *plResult);
        
        HRESULT ( STDMETHODCALLTYPE *SendIMCW )( 
            IActiveIMMIME * This,
            /* [in] */ HWND hWnd,
            /* [in] */ UINT uMsg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ LRESULT *plResult);
        
        HRESULT ( STDMETHODCALLTYPE *IsSleeping )( 
            IActiveIMMIME * This);
        
        END_INTERFACE
    } IActiveIMMIMEVtbl;

    interface IActiveIMMIME
    {
        CONST_VTBL struct IActiveIMMIMEVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveIMMIME_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IActiveIMMIME_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IActiveIMMIME_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IActiveIMMIME_AssociateContext(This,hWnd,hIME,phPrev)	\
    (This)->lpVtbl -> AssociateContext(This,hWnd,hIME,phPrev)

#define IActiveIMMIME_ConfigureIMEA(This,hKL,hWnd,dwMode,pData)	\
    (This)->lpVtbl -> ConfigureIMEA(This,hKL,hWnd,dwMode,pData)

#define IActiveIMMIME_ConfigureIMEW(This,hKL,hWnd,dwMode,pData)	\
    (This)->lpVtbl -> ConfigureIMEW(This,hKL,hWnd,dwMode,pData)

#define IActiveIMMIME_CreateContext(This,phIMC)	\
    (This)->lpVtbl -> CreateContext(This,phIMC)

#define IActiveIMMIME_DestroyContext(This,hIME)	\
    (This)->lpVtbl -> DestroyContext(This,hIME)

#define IActiveIMMIME_EnumRegisterWordA(This,hKL,szReading,dwStyle,szRegister,pData,pEnum)	\
    (This)->lpVtbl -> EnumRegisterWordA(This,hKL,szReading,dwStyle,szRegister,pData,pEnum)

#define IActiveIMMIME_EnumRegisterWordW(This,hKL,szReading,dwStyle,szRegister,pData,pEnum)	\
    (This)->lpVtbl -> EnumRegisterWordW(This,hKL,szReading,dwStyle,szRegister,pData,pEnum)

#define IActiveIMMIME_EscapeA(This,hKL,hIMC,uEscape,pData,plResult)	\
    (This)->lpVtbl -> EscapeA(This,hKL,hIMC,uEscape,pData,plResult)

#define IActiveIMMIME_EscapeW(This,hKL,hIMC,uEscape,pData,plResult)	\
    (This)->lpVtbl -> EscapeW(This,hKL,hIMC,uEscape,pData,plResult)

#define IActiveIMMIME_GetCandidateListA(This,hIMC,dwIndex,uBufLen,pCandList,puCopied)	\
    (This)->lpVtbl -> GetCandidateListA(This,hIMC,dwIndex,uBufLen,pCandList,puCopied)

#define IActiveIMMIME_GetCandidateListW(This,hIMC,dwIndex,uBufLen,pCandList,puCopied)	\
    (This)->lpVtbl -> GetCandidateListW(This,hIMC,dwIndex,uBufLen,pCandList,puCopied)

#define IActiveIMMIME_GetCandidateListCountA(This,hIMC,pdwListSize,pdwBufLen)	\
    (This)->lpVtbl -> GetCandidateListCountA(This,hIMC,pdwListSize,pdwBufLen)

#define IActiveIMMIME_GetCandidateListCountW(This,hIMC,pdwListSize,pdwBufLen)	\
    (This)->lpVtbl -> GetCandidateListCountW(This,hIMC,pdwListSize,pdwBufLen)

#define IActiveIMMIME_GetCandidateWindow(This,hIMC,dwIndex,pCandidate)	\
    (This)->lpVtbl -> GetCandidateWindow(This,hIMC,dwIndex,pCandidate)

#define IActiveIMMIME_GetCompositionFontA(This,hIMC,plf)	\
    (This)->lpVtbl -> GetCompositionFontA(This,hIMC,plf)

#define IActiveIMMIME_GetCompositionFontW(This,hIMC,plf)	\
    (This)->lpVtbl -> GetCompositionFontW(This,hIMC,plf)

#define IActiveIMMIME_GetCompositionStringA(This,hIMC,dwIndex,dwBufLen,plCopied,pBuf)	\
    (This)->lpVtbl -> GetCompositionStringA(This,hIMC,dwIndex,dwBufLen,plCopied,pBuf)

#define IActiveIMMIME_GetCompositionStringW(This,hIMC,dwIndex,dwBufLen,plCopied,pBuf)	\
    (This)->lpVtbl -> GetCompositionStringW(This,hIMC,dwIndex,dwBufLen,plCopied,pBuf)

#define IActiveIMMIME_GetCompositionWindow(This,hIMC,pCompForm)	\
    (This)->lpVtbl -> GetCompositionWindow(This,hIMC,pCompForm)

#define IActiveIMMIME_GetContext(This,hWnd,phIMC)	\
    (This)->lpVtbl -> GetContext(This,hWnd,phIMC)

#define IActiveIMMIME_GetConversionListA(This,hKL,hIMC,pSrc,uBufLen,uFlag,pDst,puCopied)	\
    (This)->lpVtbl -> GetConversionListA(This,hKL,hIMC,pSrc,uBufLen,uFlag,pDst,puCopied)

#define IActiveIMMIME_GetConversionListW(This,hKL,hIMC,pSrc,uBufLen,uFlag,pDst,puCopied)	\
    (This)->lpVtbl -> GetConversionListW(This,hKL,hIMC,pSrc,uBufLen,uFlag,pDst,puCopied)

#define IActiveIMMIME_GetConversionStatus(This,hIMC,pfdwConversion,pfdwSentence)	\
    (This)->lpVtbl -> GetConversionStatus(This,hIMC,pfdwConversion,pfdwSentence)

#define IActiveIMMIME_GetDefaultIMEWnd(This,hWnd,phDefWnd)	\
    (This)->lpVtbl -> GetDefaultIMEWnd(This,hWnd,phDefWnd)

#define IActiveIMMIME_GetDescriptionA(This,hKL,uBufLen,szDescription,puCopied)	\
    (This)->lpVtbl -> GetDescriptionA(This,hKL,uBufLen,szDescription,puCopied)

#define IActiveIMMIME_GetDescriptionW(This,hKL,uBufLen,szDescription,puCopied)	\
    (This)->lpVtbl -> GetDescriptionW(This,hKL,uBufLen,szDescription,puCopied)

#define IActiveIMMIME_GetGuideLineA(This,hIMC,dwIndex,dwBufLen,pBuf,pdwResult)	\
    (This)->lpVtbl -> GetGuideLineA(This,hIMC,dwIndex,dwBufLen,pBuf,pdwResult)

#define IActiveIMMIME_GetGuideLineW(This,hIMC,dwIndex,dwBufLen,pBuf,pdwResult)	\
    (This)->lpVtbl -> GetGuideLineW(This,hIMC,dwIndex,dwBufLen,pBuf,pdwResult)

#define IActiveIMMIME_GetIMEFileNameA(This,hKL,uBufLen,szFileName,puCopied)	\
    (This)->lpVtbl -> GetIMEFileNameA(This,hKL,uBufLen,szFileName,puCopied)

#define IActiveIMMIME_GetIMEFileNameW(This,hKL,uBufLen,szFileName,puCopied)	\
    (This)->lpVtbl -> GetIMEFileNameW(This,hKL,uBufLen,szFileName,puCopied)

#define IActiveIMMIME_GetOpenStatus(This,hIMC)	\
    (This)->lpVtbl -> GetOpenStatus(This,hIMC)

#define IActiveIMMIME_GetProperty(This,hKL,fdwIndex,pdwProperty)	\
    (This)->lpVtbl -> GetProperty(This,hKL,fdwIndex,pdwProperty)

#define IActiveIMMIME_GetRegisterWordStyleA(This,hKL,nItem,pStyleBuf,puCopied)	\
    (This)->lpVtbl -> GetRegisterWordStyleA(This,hKL,nItem,pStyleBuf,puCopied)

#define IActiveIMMIME_GetRegisterWordStyleW(This,hKL,nItem,pStyleBuf,puCopied)	\
    (This)->lpVtbl -> GetRegisterWordStyleW(This,hKL,nItem,pStyleBuf,puCopied)

#define IActiveIMMIME_GetStatusWindowPos(This,hIMC,pptPos)	\
    (This)->lpVtbl -> GetStatusWindowPos(This,hIMC,pptPos)

#define IActiveIMMIME_GetVirtualKey(This,hWnd,puVirtualKey)	\
    (This)->lpVtbl -> GetVirtualKey(This,hWnd,puVirtualKey)

#define IActiveIMMIME_InstallIMEA(This,szIMEFileName,szLayoutText,phKL)	\
    (This)->lpVtbl -> InstallIMEA(This,szIMEFileName,szLayoutText,phKL)

#define IActiveIMMIME_InstallIMEW(This,szIMEFileName,szLayoutText,phKL)	\
    (This)->lpVtbl -> InstallIMEW(This,szIMEFileName,szLayoutText,phKL)

#define IActiveIMMIME_IsIME(This,hKL)	\
    (This)->lpVtbl -> IsIME(This,hKL)

#define IActiveIMMIME_IsUIMessageA(This,hWndIME,msg,wParam,lParam)	\
    (This)->lpVtbl -> IsUIMessageA(This,hWndIME,msg,wParam,lParam)

#define IActiveIMMIME_IsUIMessageW(This,hWndIME,msg,wParam,lParam)	\
    (This)->lpVtbl -> IsUIMessageW(This,hWndIME,msg,wParam,lParam)

#define IActiveIMMIME_NotifyIME(This,hIMC,dwAction,dwIndex,dwValue)	\
    (This)->lpVtbl -> NotifyIME(This,hIMC,dwAction,dwIndex,dwValue)

#define IActiveIMMIME_RegisterWordA(This,hKL,szReading,dwStyle,szRegister)	\
    (This)->lpVtbl -> RegisterWordA(This,hKL,szReading,dwStyle,szRegister)

#define IActiveIMMIME_RegisterWordW(This,hKL,szReading,dwStyle,szRegister)	\
    (This)->lpVtbl -> RegisterWordW(This,hKL,szReading,dwStyle,szRegister)

#define IActiveIMMIME_ReleaseContext(This,hWnd,hIMC)	\
    (This)->lpVtbl -> ReleaseContext(This,hWnd,hIMC)

#define IActiveIMMIME_SetCandidateWindow(This,hIMC,pCandidate)	\
    (This)->lpVtbl -> SetCandidateWindow(This,hIMC,pCandidate)

#define IActiveIMMIME_SetCompositionFontA(This,hIMC,plf)	\
    (This)->lpVtbl -> SetCompositionFontA(This,hIMC,plf)

#define IActiveIMMIME_SetCompositionFontW(This,hIMC,plf)	\
    (This)->lpVtbl -> SetCompositionFontW(This,hIMC,plf)

#define IActiveIMMIME_SetCompositionStringA(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen)	\
    (This)->lpVtbl -> SetCompositionStringA(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen)

#define IActiveIMMIME_SetCompositionStringW(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen)	\
    (This)->lpVtbl -> SetCompositionStringW(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen)

#define IActiveIMMIME_SetCompositionWindow(This,hIMC,pCompForm)	\
    (This)->lpVtbl -> SetCompositionWindow(This,hIMC,pCompForm)

#define IActiveIMMIME_SetConversionStatus(This,hIMC,fdwConversion,fdwSentence)	\
    (This)->lpVtbl -> SetConversionStatus(This,hIMC,fdwConversion,fdwSentence)

#define IActiveIMMIME_SetOpenStatus(This,hIMC,fOpen)	\
    (This)->lpVtbl -> SetOpenStatus(This,hIMC,fOpen)

#define IActiveIMMIME_SetStatusWindowPos(This,hIMC,pptPos)	\
    (This)->lpVtbl -> SetStatusWindowPos(This,hIMC,pptPos)

#define IActiveIMMIME_SimulateHotKey(This,hWnd,dwHotKeyID)	\
    (This)->lpVtbl -> SimulateHotKey(This,hWnd,dwHotKeyID)

#define IActiveIMMIME_UnregisterWordA(This,hKL,szReading,dwStyle,szUnregister)	\
    (This)->lpVtbl -> UnregisterWordA(This,hKL,szReading,dwStyle,szUnregister)

#define IActiveIMMIME_UnregisterWordW(This,hKL,szReading,dwStyle,szUnregister)	\
    (This)->lpVtbl -> UnregisterWordW(This,hKL,szReading,dwStyle,szUnregister)

#define IActiveIMMIME_GenerateMessage(This,hIMC)	\
    (This)->lpVtbl -> GenerateMessage(This,hIMC)

#define IActiveIMMIME_LockIMC(This,hIMC,ppIMC)	\
    (This)->lpVtbl -> LockIMC(This,hIMC,ppIMC)

#define IActiveIMMIME_UnlockIMC(This,hIMC)	\
    (This)->lpVtbl -> UnlockIMC(This,hIMC)

#define IActiveIMMIME_GetIMCLockCount(This,hIMC,pdwLockCount)	\
    (This)->lpVtbl -> GetIMCLockCount(This,hIMC,pdwLockCount)

#define IActiveIMMIME_CreateIMCC(This,dwSize,phIMCC)	\
    (This)->lpVtbl -> CreateIMCC(This,dwSize,phIMCC)

#define IActiveIMMIME_DestroyIMCC(This,hIMCC)	\
    (This)->lpVtbl -> DestroyIMCC(This,hIMCC)

#define IActiveIMMIME_LockIMCC(This,hIMCC,ppv)	\
    (This)->lpVtbl -> LockIMCC(This,hIMCC,ppv)

#define IActiveIMMIME_UnlockIMCC(This,hIMCC)	\
    (This)->lpVtbl -> UnlockIMCC(This,hIMCC)

#define IActiveIMMIME_ReSizeIMCC(This,hIMCC,dwSize,phIMCC)	\
    (This)->lpVtbl -> ReSizeIMCC(This,hIMCC,dwSize,phIMCC)

#define IActiveIMMIME_GetIMCCSize(This,hIMCC,pdwSize)	\
    (This)->lpVtbl -> GetIMCCSize(This,hIMCC,pdwSize)

#define IActiveIMMIME_GetIMCCLockCount(This,hIMCC,pdwLockCount)	\
    (This)->lpVtbl -> GetIMCCLockCount(This,hIMCC,pdwLockCount)

#define IActiveIMMIME_GetHotKey(This,dwHotKeyID,puModifiers,puVKey,phKL)	\
    (This)->lpVtbl -> GetHotKey(This,dwHotKeyID,puModifiers,puVKey,phKL)

#define IActiveIMMIME_SetHotKey(This,dwHotKeyID,uModifiers,uVKey,hKL)	\
    (This)->lpVtbl -> SetHotKey(This,dwHotKeyID,uModifiers,uVKey,hKL)

#define IActiveIMMIME_CreateSoftKeyboard(This,uType,hOwner,x,y,phSoftKbdWnd)	\
    (This)->lpVtbl -> CreateSoftKeyboard(This,uType,hOwner,x,y,phSoftKbdWnd)

#define IActiveIMMIME_DestroySoftKeyboard(This,hSoftKbdWnd)	\
    (This)->lpVtbl -> DestroySoftKeyboard(This,hSoftKbdWnd)

#define IActiveIMMIME_ShowSoftKeyboard(This,hSoftKbdWnd,nCmdShow)	\
    (This)->lpVtbl -> ShowSoftKeyboard(This,hSoftKbdWnd,nCmdShow)

#define IActiveIMMIME_GetCodePageA(This,hKL,uCodePage)	\
    (This)->lpVtbl -> GetCodePageA(This,hKL,uCodePage)

#define IActiveIMMIME_GetLangId(This,hKL,plid)	\
    (This)->lpVtbl -> GetLangId(This,hKL,plid)

#define IActiveIMMIME_KeybdEvent(This,lgidIME,bVk,bScan,dwFlags,dwExtraInfo)	\
    (This)->lpVtbl -> KeybdEvent(This,lgidIME,bVk,bScan,dwFlags,dwExtraInfo)

#define IActiveIMMIME_LockModal(This)	\
    (This)->lpVtbl -> LockModal(This)

#define IActiveIMMIME_UnlockModal(This)	\
    (This)->lpVtbl -> UnlockModal(This)

#define IActiveIMMIME_AssociateContextEx(This,hWnd,hIMC,dwFlags)	\
    (This)->lpVtbl -> AssociateContextEx(This,hWnd,hIMC,dwFlags)

#define IActiveIMMIME_DisableIME(This,idThread)	\
    (This)->lpVtbl -> DisableIME(This,idThread)

#define IActiveIMMIME_GetImeMenuItemsA(This,hIMC,dwFlags,dwType,pImeParentMenu,pImeMenu,dwSize,pdwResult)	\
    (This)->lpVtbl -> GetImeMenuItemsA(This,hIMC,dwFlags,dwType,pImeParentMenu,pImeMenu,dwSize,pdwResult)

#define IActiveIMMIME_GetImeMenuItemsW(This,hIMC,dwFlags,dwType,pImeParentMenu,pImeMenu,dwSize,pdwResult)	\
    (This)->lpVtbl -> GetImeMenuItemsW(This,hIMC,dwFlags,dwType,pImeParentMenu,pImeMenu,dwSize,pdwResult)

#define IActiveIMMIME_EnumInputContext(This,idThread,ppEnum)	\
    (This)->lpVtbl -> EnumInputContext(This,idThread,ppEnum)

#define IActiveIMMIME_RequestMessageA(This,hIMC,wParam,lParam,plResult)	\
    (This)->lpVtbl -> RequestMessageA(This,hIMC,wParam,lParam,plResult)

#define IActiveIMMIME_RequestMessageW(This,hIMC,wParam,lParam,plResult)	\
    (This)->lpVtbl -> RequestMessageW(This,hIMC,wParam,lParam,plResult)

#define IActiveIMMIME_SendIMCA(This,hWnd,uMsg,wParam,lParam,plResult)	\
    (This)->lpVtbl -> SendIMCA(This,hWnd,uMsg,wParam,lParam,plResult)

#define IActiveIMMIME_SendIMCW(This,hWnd,uMsg,wParam,lParam,plResult)	\
    (This)->lpVtbl -> SendIMCW(This,hWnd,uMsg,wParam,lParam,plResult)

#define IActiveIMMIME_IsSleeping(This)	\
    (This)->lpVtbl -> IsSleeping(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IActiveIMMIME_AssociateContext_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HWND hWnd,
    /* [in] */ HIMC hIME,
    /* [out] */ HIMC *phPrev);


void __RPC_STUB IActiveIMMIME_AssociateContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_ConfigureIMEA_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HKL hKL,
    /* [in] */ HWND hWnd,
    /* [in] */ DWORD dwMode,
    /* [in] */ REGISTERWORDA *pData);


void __RPC_STUB IActiveIMMIME_ConfigureIMEA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_ConfigureIMEW_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HKL hKL,
    /* [in] */ HWND hWnd,
    /* [in] */ DWORD dwMode,
    /* [in] */ REGISTERWORDW *pData);


void __RPC_STUB IActiveIMMIME_ConfigureIMEW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_CreateContext_Proxy( 
    IActiveIMMIME * This,
    /* [out] */ HIMC *phIMC);


void __RPC_STUB IActiveIMMIME_CreateContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_DestroyContext_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMC hIME);


void __RPC_STUB IActiveIMMIME_DestroyContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_EnumRegisterWordA_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HKL hKL,
    /* [in] */ LPSTR szReading,
    /* [in] */ DWORD dwStyle,
    /* [in] */ LPSTR szRegister,
    /* [in] */ LPVOID pData,
    /* [out] */ IEnumRegisterWordA **pEnum);


void __RPC_STUB IActiveIMMIME_EnumRegisterWordA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_EnumRegisterWordW_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HKL hKL,
    /* [in] */ LPWSTR szReading,
    /* [in] */ DWORD dwStyle,
    /* [in] */ LPWSTR szRegister,
    /* [in] */ LPVOID pData,
    /* [out] */ IEnumRegisterWordW **pEnum);


void __RPC_STUB IActiveIMMIME_EnumRegisterWordW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_EscapeA_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HKL hKL,
    /* [in] */ HIMC hIMC,
    /* [in] */ UINT uEscape,
    /* [out][in] */ LPVOID pData,
    /* [out] */ LRESULT *plResult);


void __RPC_STUB IActiveIMMIME_EscapeA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_EscapeW_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HKL hKL,
    /* [in] */ HIMC hIMC,
    /* [in] */ UINT uEscape,
    /* [out][in] */ LPVOID pData,
    /* [out] */ LRESULT *plResult);


void __RPC_STUB IActiveIMMIME_EscapeW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetCandidateListA_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ UINT uBufLen,
    /* [out] */ CANDIDATELIST *pCandList,
    /* [out] */ UINT *puCopied);


void __RPC_STUB IActiveIMMIME_GetCandidateListA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetCandidateListW_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ UINT uBufLen,
    /* [out] */ CANDIDATELIST *pCandList,
    /* [out] */ UINT *puCopied);


void __RPC_STUB IActiveIMMIME_GetCandidateListW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetCandidateListCountA_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMC hIMC,
    /* [out] */ DWORD *pdwListSize,
    /* [out] */ DWORD *pdwBufLen);


void __RPC_STUB IActiveIMMIME_GetCandidateListCountA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetCandidateListCountW_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMC hIMC,
    /* [out] */ DWORD *pdwListSize,
    /* [out] */ DWORD *pdwBufLen);


void __RPC_STUB IActiveIMMIME_GetCandidateListCountW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetCandidateWindow_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [out] */ CANDIDATEFORM *pCandidate);


void __RPC_STUB IActiveIMMIME_GetCandidateWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetCompositionFontA_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMC hIMC,
    /* [out] */ LOGFONTA *plf);


void __RPC_STUB IActiveIMMIME_GetCompositionFontA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetCompositionFontW_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMC hIMC,
    /* [out] */ LOGFONTW *plf);


void __RPC_STUB IActiveIMMIME_GetCompositionFontW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetCompositionStringA_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ DWORD dwBufLen,
    /* [out] */ LONG *plCopied,
    /* [out] */ LPVOID pBuf);


void __RPC_STUB IActiveIMMIME_GetCompositionStringA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetCompositionStringW_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ DWORD dwBufLen,
    /* [out] */ LONG *plCopied,
    /* [out] */ LPVOID pBuf);


void __RPC_STUB IActiveIMMIME_GetCompositionStringW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetCompositionWindow_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMC hIMC,
    /* [out] */ COMPOSITIONFORM *pCompForm);


void __RPC_STUB IActiveIMMIME_GetCompositionWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetContext_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HWND hWnd,
    /* [out] */ HIMC *phIMC);


void __RPC_STUB IActiveIMMIME_GetContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetConversionListA_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HKL hKL,
    /* [in] */ HIMC hIMC,
    /* [in] */ LPSTR pSrc,
    /* [in] */ UINT uBufLen,
    /* [in] */ UINT uFlag,
    /* [out] */ CANDIDATELIST *pDst,
    /* [out] */ UINT *puCopied);


void __RPC_STUB IActiveIMMIME_GetConversionListA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetConversionListW_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HKL hKL,
    /* [in] */ HIMC hIMC,
    /* [in] */ LPWSTR pSrc,
    /* [in] */ UINT uBufLen,
    /* [in] */ UINT uFlag,
    /* [out] */ CANDIDATELIST *pDst,
    /* [out] */ UINT *puCopied);


void __RPC_STUB IActiveIMMIME_GetConversionListW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetConversionStatus_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMC hIMC,
    /* [out] */ DWORD *pfdwConversion,
    /* [out] */ DWORD *pfdwSentence);


void __RPC_STUB IActiveIMMIME_GetConversionStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetDefaultIMEWnd_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HWND hWnd,
    /* [out] */ HWND *phDefWnd);


void __RPC_STUB IActiveIMMIME_GetDefaultIMEWnd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetDescriptionA_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HKL hKL,
    /* [in] */ UINT uBufLen,
    /* [out] */ LPSTR szDescription,
    /* [out] */ UINT *puCopied);


void __RPC_STUB IActiveIMMIME_GetDescriptionA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetDescriptionW_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HKL hKL,
    /* [in] */ UINT uBufLen,
    /* [out] */ LPWSTR szDescription,
    /* [out] */ UINT *puCopied);


void __RPC_STUB IActiveIMMIME_GetDescriptionW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetGuideLineA_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ DWORD dwBufLen,
    /* [out] */ LPSTR pBuf,
    /* [out] */ DWORD *pdwResult);


void __RPC_STUB IActiveIMMIME_GetGuideLineA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetGuideLineW_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ DWORD dwBufLen,
    /* [out] */ LPWSTR pBuf,
    /* [out] */ DWORD *pdwResult);


void __RPC_STUB IActiveIMMIME_GetGuideLineW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetIMEFileNameA_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HKL hKL,
    /* [in] */ UINT uBufLen,
    /* [out] */ LPSTR szFileName,
    /* [out] */ UINT *puCopied);


void __RPC_STUB IActiveIMMIME_GetIMEFileNameA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetIMEFileNameW_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HKL hKL,
    /* [in] */ UINT uBufLen,
    /* [out] */ LPWSTR szFileName,
    /* [out] */ UINT *puCopied);


void __RPC_STUB IActiveIMMIME_GetIMEFileNameW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetOpenStatus_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMC hIMC);


void __RPC_STUB IActiveIMMIME_GetOpenStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetProperty_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HKL hKL,
    /* [in] */ DWORD fdwIndex,
    /* [out] */ DWORD *pdwProperty);


void __RPC_STUB IActiveIMMIME_GetProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetRegisterWordStyleA_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HKL hKL,
    /* [in] */ UINT nItem,
    /* [out] */ STYLEBUFA *pStyleBuf,
    /* [out] */ UINT *puCopied);


void __RPC_STUB IActiveIMMIME_GetRegisterWordStyleA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetRegisterWordStyleW_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HKL hKL,
    /* [in] */ UINT nItem,
    /* [out] */ STYLEBUFW *pStyleBuf,
    /* [out] */ UINT *puCopied);


void __RPC_STUB IActiveIMMIME_GetRegisterWordStyleW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetStatusWindowPos_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMC hIMC,
    /* [out] */ POINT *pptPos);


void __RPC_STUB IActiveIMMIME_GetStatusWindowPos_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetVirtualKey_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HWND hWnd,
    /* [out] */ UINT *puVirtualKey);


void __RPC_STUB IActiveIMMIME_GetVirtualKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_InstallIMEA_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ LPSTR szIMEFileName,
    /* [in] */ LPSTR szLayoutText,
    /* [out] */ HKL *phKL);


void __RPC_STUB IActiveIMMIME_InstallIMEA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_InstallIMEW_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ LPWSTR szIMEFileName,
    /* [in] */ LPWSTR szLayoutText,
    /* [out] */ HKL *phKL);


void __RPC_STUB IActiveIMMIME_InstallIMEW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_IsIME_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HKL hKL);


void __RPC_STUB IActiveIMMIME_IsIME_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_IsUIMessageA_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HWND hWndIME,
    /* [in] */ UINT msg,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam);


void __RPC_STUB IActiveIMMIME_IsUIMessageA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_IsUIMessageW_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HWND hWndIME,
    /* [in] */ UINT msg,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam);


void __RPC_STUB IActiveIMMIME_IsUIMessageW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_NotifyIME_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwAction,
    /* [in] */ DWORD dwIndex,
    /* [in] */ DWORD dwValue);


void __RPC_STUB IActiveIMMIME_NotifyIME_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_RegisterWordA_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HKL hKL,
    /* [in] */ LPSTR szReading,
    /* [in] */ DWORD dwStyle,
    /* [in] */ LPSTR szRegister);


void __RPC_STUB IActiveIMMIME_RegisterWordA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_RegisterWordW_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HKL hKL,
    /* [in] */ LPWSTR szReading,
    /* [in] */ DWORD dwStyle,
    /* [in] */ LPWSTR szRegister);


void __RPC_STUB IActiveIMMIME_RegisterWordW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_ReleaseContext_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HWND hWnd,
    /* [in] */ HIMC hIMC);


void __RPC_STUB IActiveIMMIME_ReleaseContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_SetCandidateWindow_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ CANDIDATEFORM *pCandidate);


void __RPC_STUB IActiveIMMIME_SetCandidateWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_SetCompositionFontA_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ LOGFONTA *plf);


void __RPC_STUB IActiveIMMIME_SetCompositionFontA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_SetCompositionFontW_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ LOGFONTW *plf);


void __RPC_STUB IActiveIMMIME_SetCompositionFontW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_SetCompositionStringA_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ LPVOID pComp,
    /* [in] */ DWORD dwCompLen,
    /* [in] */ LPVOID pRead,
    /* [in] */ DWORD dwReadLen);


void __RPC_STUB IActiveIMMIME_SetCompositionStringA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_SetCompositionStringW_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ LPVOID pComp,
    /* [in] */ DWORD dwCompLen,
    /* [in] */ LPVOID pRead,
    /* [in] */ DWORD dwReadLen);


void __RPC_STUB IActiveIMMIME_SetCompositionStringW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_SetCompositionWindow_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ COMPOSITIONFORM *pCompForm);


void __RPC_STUB IActiveIMMIME_SetCompositionWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_SetConversionStatus_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD fdwConversion,
    /* [in] */ DWORD fdwSentence);


void __RPC_STUB IActiveIMMIME_SetConversionStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_SetOpenStatus_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ BOOL fOpen);


void __RPC_STUB IActiveIMMIME_SetOpenStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_SetStatusWindowPos_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ POINT *pptPos);


void __RPC_STUB IActiveIMMIME_SetStatusWindowPos_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_SimulateHotKey_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HWND hWnd,
    /* [in] */ DWORD dwHotKeyID);


void __RPC_STUB IActiveIMMIME_SimulateHotKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_UnregisterWordA_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HKL hKL,
    /* [in] */ LPSTR szReading,
    /* [in] */ DWORD dwStyle,
    /* [in] */ LPSTR szUnregister);


void __RPC_STUB IActiveIMMIME_UnregisterWordA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_UnregisterWordW_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HKL hKL,
    /* [in] */ LPWSTR szReading,
    /* [in] */ DWORD dwStyle,
    /* [in] */ LPWSTR szUnregister);


void __RPC_STUB IActiveIMMIME_UnregisterWordW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GenerateMessage_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMC hIMC);


void __RPC_STUB IActiveIMMIME_GenerateMessage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_LockIMC_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMC hIMC,
    /* [out] */ INPUTCONTEXT **ppIMC);


void __RPC_STUB IActiveIMMIME_LockIMC_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_UnlockIMC_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMC hIMC);


void __RPC_STUB IActiveIMMIME_UnlockIMC_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetIMCLockCount_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMC hIMC,
    /* [out] */ DWORD *pdwLockCount);


void __RPC_STUB IActiveIMMIME_GetIMCLockCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_CreateIMCC_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ DWORD dwSize,
    /* [out] */ HIMCC *phIMCC);


void __RPC_STUB IActiveIMMIME_CreateIMCC_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_DestroyIMCC_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMCC hIMCC);


void __RPC_STUB IActiveIMMIME_DestroyIMCC_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_LockIMCC_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMCC hIMCC,
    /* [out] */ void **ppv);


void __RPC_STUB IActiveIMMIME_LockIMCC_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_UnlockIMCC_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMCC hIMCC);


void __RPC_STUB IActiveIMMIME_UnlockIMCC_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_ReSizeIMCC_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMCC hIMCC,
    /* [in] */ DWORD dwSize,
    /* [out] */ HIMCC *phIMCC);


void __RPC_STUB IActiveIMMIME_ReSizeIMCC_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetIMCCSize_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMCC hIMCC,
    /* [out] */ DWORD *pdwSize);


void __RPC_STUB IActiveIMMIME_GetIMCCSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetIMCCLockCount_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMCC hIMCC,
    /* [out] */ DWORD *pdwLockCount);


void __RPC_STUB IActiveIMMIME_GetIMCCLockCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetHotKey_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ DWORD dwHotKeyID,
    /* [out] */ UINT *puModifiers,
    /* [out] */ UINT *puVKey,
    /* [out] */ HKL *phKL);


void __RPC_STUB IActiveIMMIME_GetHotKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_SetHotKey_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ DWORD dwHotKeyID,
    /* [in] */ UINT uModifiers,
    /* [in] */ UINT uVKey,
    /* [in] */ HKL hKL);


void __RPC_STUB IActiveIMMIME_SetHotKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_CreateSoftKeyboard_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ UINT uType,
    /* [in] */ HWND hOwner,
    /* [in] */ int x,
    /* [in] */ int y,
    /* [out] */ HWND *phSoftKbdWnd);


void __RPC_STUB IActiveIMMIME_CreateSoftKeyboard_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_DestroySoftKeyboard_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HWND hSoftKbdWnd);


void __RPC_STUB IActiveIMMIME_DestroySoftKeyboard_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_ShowSoftKeyboard_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HWND hSoftKbdWnd,
    /* [in] */ int nCmdShow);


void __RPC_STUB IActiveIMMIME_ShowSoftKeyboard_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetCodePageA_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HKL hKL,
    /* [out] */ UINT *uCodePage);


void __RPC_STUB IActiveIMMIME_GetCodePageA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetLangId_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HKL hKL,
    /* [out] */ LANGID *plid);


void __RPC_STUB IActiveIMMIME_GetLangId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_KeybdEvent_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ LANGID lgidIME,
    /* [in] */ BYTE bVk,
    /* [in] */ BYTE bScan,
    /* [in] */ DWORD dwFlags,
    /* [in] */ DWORD dwExtraInfo);


void __RPC_STUB IActiveIMMIME_KeybdEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_LockModal_Proxy( 
    IActiveIMMIME * This);


void __RPC_STUB IActiveIMMIME_LockModal_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_UnlockModal_Proxy( 
    IActiveIMMIME * This);


void __RPC_STUB IActiveIMMIME_UnlockModal_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_AssociateContextEx_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HWND hWnd,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IActiveIMMIME_AssociateContextEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_DisableIME_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ DWORD idThread);


void __RPC_STUB IActiveIMMIME_DisableIME_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetImeMenuItemsA_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwFlags,
    /* [in] */ DWORD dwType,
    /* [in] */ IMEMENUITEMINFOA *pImeParentMenu,
    /* [out] */ IMEMENUITEMINFOA *pImeMenu,
    /* [in] */ DWORD dwSize,
    /* [out] */ DWORD *pdwResult);


void __RPC_STUB IActiveIMMIME_GetImeMenuItemsA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetImeMenuItemsW_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwFlags,
    /* [in] */ DWORD dwType,
    /* [in] */ IMEMENUITEMINFOW *pImeParentMenu,
    /* [out] */ IMEMENUITEMINFOW *pImeMenu,
    /* [in] */ DWORD dwSize,
    /* [out] */ DWORD *pdwResult);


void __RPC_STUB IActiveIMMIME_GetImeMenuItemsW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_EnumInputContext_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ DWORD idThread,
    /* [out] */ IEnumInputContext **ppEnum);


void __RPC_STUB IActiveIMMIME_EnumInputContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_RequestMessageA_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam,
    /* [out] */ LRESULT *plResult);


void __RPC_STUB IActiveIMMIME_RequestMessageA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStub