----------------------------
        ///  <summary>
        ///  Routine to click on button OK
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickOK()
        {
            Controls.OKButton.Click();
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button Cancel
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickCancel()
        {
            Controls.CancelButton.Click();
        }

#endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XLASTAuto\Commands.cs ===
using System;
using Maui.Core;

namespace ServerTestFramework.xlast.XLASTAuto
{
	/// -----------------------------------------------------------------------------
	///  Project	: ServerTestFramework.xlast.XLASTAuto
	///  Class		: Commands
	///  Copyright (C) 2002, Microsoft Corporation
	/// -----------------------------------------------------------------------------
	/// <summary>
	///		Standard XLAST command descriptors.
	/// </summary>
	/// <history>
	///		[trevorm]	4/19/2005	Created
	/// </history>
	/// -----------------------------------------------------------------------------
	public class Commands
	{
		/// <summary>
		///	Command strings.
		/// </summary>
		internal class Strings
		{
			public const string File = ";&File;NativeMenuString;xlastui.dll;1128;1";
			public const string FileExit = ";E&xit;NativeMenuString;xlastui.dll;1128;57665";
			public const string FileNew = ";&NewCtrl+N;NativeMenuString;xlastui.dll;1128;57600";
			public const string FileOpen = ";&Open...Ctrl+O;NativeMenuString;xlastui.dll;1128;57601";
			public const string FileClose = ";&Close;NativeMenuString;xlastui.dll;1128;57602";
			public const string FileSave = ";&SaveCtrl+S;NativeMenuString;xlastui.dll;10005;57603";
			public const string FileSaveAs = ";Save &As...;NativeMenuString;xlastui.dll;10005;57604";

			public const string View = ";&View;NativeMenuString;xlastui.dll;1128;2";
			public const string ViewToolbar = ";&Toolbar;NativeMenuString;xlastui.dll;1128;59392";
			public const string ViewStatusBar = ";&Status Bar;NativeMenuString;xlastui.dll;1128;59393";
			public const string ViewSplit = ";S&plit;NativeMenuString;xlastui.dll;1128;57653";

			public const string Action = ";&Action;NativeMenuString;xlastui.dll;10005;3";
			public const string ActionSendtoPartnernet = ";Send to Partner&Net ...;NativeMenuString;xlastui.dll;10005;1303";
			public const string ActionBuild = ";&Build;NativeMenuString;xlastui.dll;14000;1319";
			public const string ActionClean = ";&Clean;NativeMenuString;xlastui.dll;14000;1306";
			public const string ActionNewAchievement = ";New &Achievement;NativeMenuString;xlastui.dll;16000;1326";
			public const string ActionNewRichPresenceString = ";New &Rich Presence String;NativeMenuString;xlastui.dll;16000;1327";
			public const string ActionNewContext = ";New Conte&xt;NativeMenuString;xlastui.dll;16000;1328";
			public const string ActionNewProperty = ";New &Property;NativeMenuString;xlastui.dll;16000;1329";
			public const string ActionNewLocalizedString = ";New &Localized String;NativeMenuString;xlastui.dll;16000;1330";
			public const string ActionNewLeaderboard = ";New Leaderboar&d;NativeMenuString;xlastui.dll;16000;1331";
			public const string ActionNewMatchmakingQuery = ";New Matchmaking &Query;NativeMenuString;xlastui.dll;16000;1332";

			public const string Window = ";&Window;NativeMenuString;xlastui.dll;16000;4";
			public const string WindowCascade = ";&Cascade;NativeMenuString;xlastui.dll;16000;57650";
			public const string WindowTile = ";&Tile;NativeMenuString;xlastui.dll;16000;57651";
			public const string WindowDefault = ";&Default Arrangement;NativeMenuString;xlastui.dll;16000;57649";

			public const string Help = ";&Help;NativeMenuString;xlastui.dll;16000;5";
			public const string HelpHelpTopics = ";&Help...;NativeMenuString;xlastui.dll;16000;1132";
			public const string HelpAbout = ";&About Xenon and Live Authoring Submission Tool (XLAST)...;NativeMenuString;xlastui.dll;16000;57664";

			/*public const string ToolbarCut = ";CutCut;Win32String;mmcbase.dll;13381";
			public const string ToolbarCopy = ";CopyCopy;Win32String;mmcbase.dll;13382";
			public const string ToolbarPaste = ";PastePaste;Win32String;mmcbase.dll;13383";
			public const string ToolbarDelete = ";DeleteDelete;Win32String;mmcbase.dll;13384";
			public const string ToolbarProperties = ";PropertiesProperties;Win32String;mmcbase.dll;13385";
			public const string ToolbarUpOneLevel = ";Up One LevelUp One Level;Win32String;mmcbase.dll;13386";
			public const string ToolbarShowHideConsoleTree = ";Show/Hide Console TreeShow/Hide Console Tree;Win32String;mmcbase.dll;13387";
			public const string ToolbarShowHideActionsPane = ";Show/Hide Action PaneShow/Hide Action Pane;Win32String;mmcbase.dll;13432";
			public const string ToolbarRefresh = ";RefreshRefresh;Win32String;mmcbase.dll;13388";
			public const string ToolbarPrint = ";PrintPrint;Win32String;mmcbase.dll;13389";
			public const string ToolbarRename = ";RenameRename;Win32String;mmcbase.dll;13390";
			public const string ToolbarOpen = ";OpenOpen;Win32String;mmcbase.dll;13391";
			public const string ToolbarBack = ";BackBack;Win32String;mmcbase.dll;13392";
			public const string ToolbarForward = ";ForwardForward;Win32String;mmcbase.dll;13393";
			public const string ToolbarStop = ";StopStop;Win32String;mmcbase.dll;13394";
			public const string ToolbarHome = ";HomeHome;Win32String;mmcbase.dll;13396";
			public const string ToolbarExportList = ";Export ListExport List;Win32String;mmcbase.dll;13398";*/
		}

		public static Command
			// File menu items
			FileNew = new Command(Strings.File + "|" + Strings.FileNew, null, "^N", null),
			FileOpen = new Command(Strings.File + "|" + Strings.FileOpen, null, "^O", null),
			FileClose = new Command(Strings.File + "|" + Strings.FileClose, null, null, null),
			FileSave = new Command(Strings.File + "|" + Strings.FileSave, null, "^S", null),
			FileSaveAs = new Command(Strings.File + "|" + Strings.FileSaveAs, null, null, null),
			FileExit = new Command(Strings.File + "|" + Strings.FileExit, null, null, null),

			// View menu items
			ViewToolbar = new Command(Strings.View + "|" + Strings.ViewToolbar, null, null, null),
			ViewStatusBar = new Command(Strings.View + "|" + Strings.ViewStatusBar, null, null, null),
			ViewSplit = new Command(Strings.View + "|" + Strings.ViewSplit, null, null, null),

			// Action menu items
			ActionSendtoPartnernet = new Command(Strings.Action + "|" + Strings.ActionSendtoPartnernet, Strings.ActionSendtoPartnernet),
			ActionBuild = new Command(Strings.Action + "|" + Strings.ActionBuild, Strings.ActionBuild),
			ActionClean = new Command(Strings.Action + "|" + Strings.ActionClean, Strings.ActionClean),
			ActionNewAchievement = new Command(Strings.Action + "|" + Strings.ActionNewAchievement, Strings.ActionNewAchievement),
			ActionNewRichPresenceString = new Command(Strings.Action + "|" + Strings.ActionNewRichPresenceString, Strings.ActionNewRichPresenceString),
			ActionNewContext = new Command(Strings.Action + "|" + Strings.ActionNewContext, Strings.ActionNewContext),
			ActionNewProperty = new Command(Strings.Action + "|" + Strings.ActionNewProperty, Strings.ActionNewProperty),
			ActionNewLocalizedString = new Command(Strings.Action + "|" + Strings.ActionNewLocalizedString, Strings.ActionNewLocalizedString),
			ActionNewLeaderboard = new Command(Strings.Action + "|" + Strings.ActionNewLeaderboard, Strings.ActionNewLeaderboard),
			ActionNewMatchmakingQuery = new Command(Strings.Action + "|" + Strings.ActionNewMatchmakingQuery, Strings.ActionNewMatchmakingQuery),

			// Window menu items
			WindowCascade = new Command(Strings.WindowCascade, null, null, null),
			WindowTile = new Command(Strings.WindowTile, null, null, null),
			WindowDefault = new Command(Strings.WindowDefault, null, null, null),

			// Help menu items
			HelpHelpTopics = new Command(Strings.HelpHelpTopics, null, null, null),
			HelpAbout = new Command(Strings.HelpAbout, null, null, null);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XLASTAuto\Dialogs\AddNewLocalizedStringDialog.cs ===
namespace ServerTestFramework.xlast.XLASTAuto.Dialogs
{


    using Maui.Core;
    using Maui.Core.WinControls;
    using Maui.Core.Utilities;
    using System.ComponentModel;


#region "IAddNewLocalizedStringDialogControls interface definition"
    
    
    [EditorBrowsable(EditorBrowsableState.Never)]
    public interface IAddNewLocalizedStringDialogControls
    {
        TextBox NameTextBox  {get;}
        Button OKButton  {get;}
        Button CancelButton  {get;}
    }

#endregion

    /// -----------------------------------------------------------------------------
    /// Project		: Maui
    /// Class		: AddNewLocalizedStringDialog
    ///  Copyright (C) 2002, Microsoft Corporation
    /// -----------------------------------------------------------------------------
    ///  <summary>
    ///  TODO: Add dialog functionality description here.
    ///  </summary>
    ///  <history>
    /// 	[trevorm] 4/5/2005 Created
    ///  </history>
    /// -----------------------------------------------------------------------------
    public class AddNewLocalizedStringDialog : Dialog, IAddNewLocalizedStringDialogControls
    {


#region "Strings"
        public class Strings
        {
			public const string DialogTitle = ";Add New Localized String;Win32String;xlastui.dll;16811";
            public const string OK = ";OK;Win32DialogItemString;xlastui.dll;16195;1";  // OK
            public const string Cancel = ";Cancel;Win32DialogItemString;xlastui.dll;16195;2";  // Cancel
        }

#endregion

#region "Control IDs"
        public class ControlIDs
        {
            public const int NameTextBox = 0x41A0;
            public const int OKButton = 0x1;
            public const int CancelButton = 0x2;
        }

#endregion

#region "Member Variables"
        private TextBox m_cachedNameTextBox;
        private Button m_cachedOKButton;
        private Button m_cachedCancelButton;

        private const int Timeout = 3000;

#endregion

#region "Constructor and Init function"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  TODO: Add a description for your constructor.
        ///  </summary>
        //  <param name="app">XenonandLiveAuthoringSubmissionToolApp object owning the dialog.</param>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public AddNewLocalizedStringDialog(XenonandLiveAuthoringSubmissionToolApp app) : 
                base(app, Init(app))
        {
            // TODO: Add Constructor logic here. 
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  This function will attempt to find a showing instance of the dialog.
        ///  </summary>
        ///  <returns>The dialog's Window</returns>
        ///  <param name="app">XenonandLiveAuthoringSubmissionToolApp owning the dialog.</param>)
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        private static Window Init(XenonandLiveAuthoringSubmissionToolApp app)
        {
            // First check if the dialog is already up.
            Window tempWindow = null;
            try
            {
                tempWindow = new Window(app.GetIntlStr(Strings.DialogTitle), StringMatchSyntax.ExactMatch, WindowClassNames.Alert, StringMatchSyntax.ExactMatch, app.MainWindow, Timeout);
            }
            catch (Exceptions.WindowNotFoundException ex)
            {
                // TODO:  Uncomment the following code and apply the appropriate command for invoking the dialog.
                // 
                // app.DTE.ExecuteCmd(Commands.COMMAND_NAME_HERE);
                // 
                // tempWindow = new Window(Strings.DialogTitle, Utilities.StringMatchSyntax.ExactMatch, strDialogClass, Utilities.StringMatchSyntax.ExactMatch, app.MainWindow, timeOut);
                // if (tempWindow != null)
                // 	return tempWindow;
                // 
                // throw new Window.Exceptions.WindowNotFoundException("Init function could not find or bring up the dialog with a title of " + Strings.DialogTitle + ".");
                // 
            }
            return tempWindow;
        }

#endregion

#region "Properties"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the raw controls for this dialog
        ///  </summary>
        ///  <value>An interface that groups all of the dialog's control properties together</value>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual IAddNewLocalizedStringDialogControls Controls
        {
            get
            {
                return this;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control Name
        ///  </summary>
        ///  <value>TODO: specify the value</value>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual string NameText
        {
            get
            {
                return Controls.NameTextBox.Text;
            }
            set
            {
                Controls.NameTextBox.Text = value;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the NameTextBox control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        TextBox IAddNewLocalizedStringDialogControls.NameTextBox
        {
            get
            {
                if ((m_cachedNameTextBox == null))
                {
                    m_cachedNameTextBox = new TextBox(this, ControlIDs.NameTextBox);
                }
                return m_cachedNameTextBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the OKButton control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IAddNewLocalizedStringDialogControls.OKButton
        {
            get
            {
                if ((m_cachedOKButton == null))
                {
                    m_cachedOKButton = new Button(this, ControlIDs.OKButton);
                }
                return m_cachedOKButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the CancelButton control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IAddNewLocalizedStringDialogControls.CancelButton
        {
            get
            {
                if ((m_cachedCancelButton == null))
                {
                    m_cachedCancelButton = new Button(this, ControlIDs.CancelButton);
                }
                return m_cachedCancelButton;
            }
        }

#endregion

#region "Methods"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button OK
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickOK()
        {
            Controls.OKButton.Click();
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button Cancel
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickCancel()
        {
            Controls.CancelButton.Click();
        }

#endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XLASTAuto\Dialogs\AddNewRichPresenceStringDialog.cs ===
namespace ServerTestFramework.xlast.XLASTAuto.Dialogs
{


    using Maui.Core;
    using Maui.Core.WinControls;
    using Maui.Core.Utilities;
    using System.ComponentModel;


#region "IAddNewRichPresenceStringDialogControls interface definition"
    
    
    [EditorBrowsable(EditorBrowsableState.Never)]
    public interface IAddNewRichPresenceStringDialogControls
    {
        TextBox NameTextBox  {get;}
        Button OKButton  {get;}
        Button CancelButton  {get;}
    }

#endregion

    /// -----------------------------------------------------------------------------
    /// Project		: Maui
    /// Class		: AddNewRichPresenceStringDialog
    ///  Copyright (C) 2002, Microsoft Corporation
    /// -----------------------------------------------------------------------------
    ///  <summary>
    ///  TODO: Add dialog functionality description here.
    ///  </summary>
    ///  <history>
    /// 	[trevorm] 4/5/2005 Created
    ///  </history>
    /// -----------------------------------------------------------------------------
    public class AddNewRichPresenceStringDialog : Dialog, IAddNewRichPresenceStringDialogControls
    {


#region "Strings"
        public class Strings
        {
			public const string DialogTitle = ";Add New Rich Presence String;Win32String;xlastui.dll;16814";
            public const string OK = ";OK;Win32DialogItemString;xlastui.dll;16195;1";  // OK
            public const string Cancel = ";Cancel;Win32DialogItemString;xlastui.dll;16195;2";  // Cancel
        }

#endregion

#region "Control IDs"
        public class ControlIDs
        {
            public const int NameTextBox = 0x41A0;
            public const int OKButton = 0x1;
            public const int CancelButton = 0x2;
        }

#endregion

#region "Member Variables"
        private TextBox m_cachedNameTextBox;
        private Button m_cachedOKButton;
        private Button m_cachedCancelButton;

        private const int Timeout = 3000;

#endregion

#region "Constructor and Init function"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  TODO: Add a description for your constructor.
        ///  </summary>
        //  <param name="app">XenonandLiveAuthoringSubmissionToolApp object owning the dialog.</param>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public AddNewRichPresenceStringDialog(XenonandLiveAuthoringSubmissionToolApp app) : 
                base(app, Init(app))
        {
            // TODO: Add Constructor logic here. 
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  This function will attempt to find a showing instance of the dialog.
        ///  </summary>
        ///  <returns>The dialog's Window</returns>
        ///  <param name="app">XenonandLiveAuthoringSubmissionToolApp owning the dialog.</param>)
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        private static Window Init(XenonandLiveAuthoringSubmissionToolApp app)
        {
            // First check if the dialog is already up.
            Window tempWindow = null;
            try
            {
                tempWindow = new Window(app.GetIntlStr(Strings.DialogTitle), StringMatchSyntax.ExactMatch, WindowClassNames.Alert, StringMatchSyntax.ExactMatch, app.MainWindow, Timeout);
            }
            catch (Exceptions.WindowNotFoundException ex)
            {
                // TODO:  Uncomment the following code and apply the appropriate command for invoking the dialog.
                // 
                // app.DTE.ExecuteCmd(Commands.COMMAND_NAME_HERE);
                // 
                // tempWindow = new Window(Strings.DialogTitle, Utilities.StringMatchSyntax.ExactMatch, strDialogClass, Utilities.StringMatchSyntax.ExactMatch, app.MainWindow, timeOut);
                // if (tempWindow != null)
                // 	return tempWindow;
                // 
                // throw new Window.Exceptions.WindowNotFoundException("Init function could not find or bring up the dialog with a title of " + Strings.DialogTitle + ".");
                // 
            }
            return tempWindow;
        }

#endregion

#region "Properties"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the raw controls for this dialog
        ///  </summary>
        ///  <value>An interface that groups all of the dialog's control properties together</value>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual IAddNewRichPresenceStringDialogControls Controls
        {
            get
            {
                return this;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control Name
        ///  </summary>
        ///  <value>TODO: specify the value</value>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual string NameText
        {
            get
            {
                return Controls.NameTextBox.Text;
            }
            set
            {
                Controls.NameTextBox.Text = value;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the NameTextBox control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        TextBox IAddNewRichPresenceStringDialogControls.NameTextBox
        {
            get
            {
                if ((m_cachedNameTextBox == null))
                {
                    m_cachedNameTextBox = new TextBox(this, ControlIDs.NameTextBox);
                }
                return m_cachedNameTextBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the OKButton control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IAddNewRichPresenceStringDialogControls.OKButton
        {
            get
            {
                if ((m_cachedOKButton == null))
                {
                    m_cachedOKButton = new Button(this, ControlIDs.OKButton);
                }
                return m_cachedOKButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the CancelButton control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IAddNewRichPresenceStringDialogControls.CancelButton
        {
            get
            {
                if ((m_cachedCancelButton == null))
                {
                    m_cachedCancelButton = new Button(this, ControlIDs.CancelButton);
                }
                return m_cachedCancelButton;
            }
        }

#endregion

#region "Methods"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button OK
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickOK()
        {
            Controls.OKButton.Click();
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button Cancel
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickCancel()
        {
            Controls.CancelButton.Click();
        }

#endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XLASTAuto\Dialogs\LeaderboardColumnPropertiesDialog.cs ===
namespace ServerTestFramework.xlast.XLASTAuto.Dialogs
{


    using Maui.Core;
    using Maui.Core.WinControls;
    using Maui.Core.Utilities;
    using System.ComponentModel;


#region "ILeaderboardColumnPropertiesDialogControls interface definition"
    
    
    [EditorBrowsable(EditorBrowsableState.Never)]
    public interface ILeaderboardColumnPropertiesDialogControls
    {
        TextBox ColumnFriendlyNameTextBox  {get;}
        ComboBox ColumnItemTypeComboBox  {get;}
        ComboBox ColumnItemComboBox  {get;}
        ComboBox ColumnHeaderDisplayStringComboBox  {get;}
        CheckBox RankLeaderboardOnThisColumnCheckBox  {get;}
        ComboBox SortOrderComboBox  {get;}
        ComboBox AggregationMethodComboBox  {get;}
        CheckBox HideThisColumnCheckBox  {get;}
        Button OKButton  {get;}
        Button CancelButton  {get;}
    }

#endregion

    /// -----------------------------------------------------------------------------
    /// Project		: Maui
    /// Class		: LeaderboardColumnPropertiesDialog
    ///  Copyright (C) 2002, Microsoft Corporation
    /// -----------------------------------------------------------------------------
    ///  <summary>
    ///  TODO: Add dialog functionality description here.
    ///  </summary>
    ///  <history>
    /// 	[trevorm] 4/5/2005 Created
    ///  </history>
    /// -----------------------------------------------------------------------------
    public class LeaderboardColumnPropertiesDialog : Dialog, ILeaderboardColumnPropertiesDialogControls
    {


#region "Strings"
        // TODO: Remove unused definitions.
        public class Strings
        {
            public const string DialogTitle = "xlastui.dll:5:16230:0";  // Leaderboard Column Properties
            public const string RankLeaderboardOnThisColumn = ";Rank Leaderboard On This Column?;Win32DialogItemString;xlastui.dll;16230;17253";  // Rank Leaderboard On This Column?
            public const string HideThisColumn = ";Hide this column;Win32DialogItemString;xlastui.dll;16230;17258";  // Hide this column
            public const string OK = ";OK;Win32DialogItemString;xlastui.dll;16230;1";  // OK
            public const string Cancel = ";Cancel;Win32DialogItemString;xlastui.dll;16230;2";  // Cancel
        }

#endregion

#region "Control IDs"
        public class ControlIDs
        {
            public const int ColumnFriendlyNameTextBox = 0x436B;
            public const int ColumnItemTypeComboBox = 0x4362;
            public const int ColumnItemComboBox = 0x4363;
            public const int ColumnHeaderDisplayStringComboBox = 0x4364;
            public const int RankLeaderboardOnThisColumnCheckBox = 0x4365;
            public const int SortOrderComboBox = 0x4366;
            public const int AggregationMethodComboBox = 0x4369;
            public const int HideThisColumnCheckBox = 0x436A;
            public const int OKButton = 0x1;
            public const int CancelButton = 0x2;
        }

#endregion

#region "Member Variables"
        private TextBox m_cachedColumnFriendlyNameTextBox;
        private ComboBox m_cachedColumnItemTypeComboBox;
        private ComboBox m_cachedColumnItemComboBox;
        private ComboBox m_cachedColumnHeaderDisplayStringComboBox;
        private CheckBox m_cachedRankLeaderboardOnThisColumnCheckBox;
        private ComboBox m_cachedSortOrderComboBox;
        private ComboBox m_cachedAggregationMethodComboBox;
        private CheckBox m_cachedHideThisColumnCheckBox;
        private Button m_cachedOKButton;
        private Button m_cachedCancelButton;

        private const int Timeout = 3000;

#endregion

#region "Constructor and Init function"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  TODO: Add a description for your constructor.
        ///  </summary>
        //  <param name="app">XenonandLiveAuthoringSubmissionToolApp object owning the dialog.</param>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public LeaderboardColumnPropertiesDialog(XenonandLiveAuthoringSubmissionToolApp app) : 
                base(app, Init(app))
        {
            // TODO: Add Constructor logic here. 
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  This function will attempt to find a showing instance of the dialog.
        ///  </summary>
        ///  <returns>The dialog's Window</returns>
        ///  <param name="app">XenonandLiveAuthoringSubmissionToolApp owning the dialog.</param>)
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        private static Window Init(XenonandLiveAuthoringSubmissionToolApp app)
        {
            // First check if the dialog is already up.
            Window tempWindow = null;
            try
            {
                tempWindow = new Window(app.GetIntlStr(Strings.DialogTitle), StringMatchSyntax.ExactMatch, WindowClassNames.Alert, StringMatchSyntax.ExactMatch, app.MainWindow, Timeout);
            }
            catch (Exceptions.WindowNotFoundException ex)
            {
                // TODO:  Uncomment the following code and apply the appropriate command for invoking the dialog.
                // 
                // app.DTE.ExecuteCmd(Commands.COMMAND_NAME_HERE);
                // 
                // tempWindow = new Window(Strings.DialogTitle, Utilities.StringMatchSyntax.ExactMatch, strDialogClass, Utilities.StringMatchSyntax.ExactMatch, app.MainWindow, timeOut);
                // if (tempWindow != null)
                // 	return tempWindow;
                // 
                // throw new Window.Exceptions.WindowNotFoundException("Init function could not find or bring up the dialog with a title of " + Strings.DialogTitle + ".");
                // 
            }
            return tempWindow;
        }

#endregion

#region "Properties"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the raw controls for this dialog
        ///  </summary>
        ///  <value>An interface that groups all of the dialog's control properties together</value>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual ILeaderboardColumnPropertiesDialogControls Controls
        {
            get
            {
                return this;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Property to handle checkbox RankLeaderboardOnThisColumn
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual bool RankLeaderboardOnThisColumn
        {
            get
            {
                return Controls.RankLeaderboardOnThisColumnCheckBox.Checked;
            }
            set
            {
                Controls.RankLeaderboardOnThisColumnCheckBox.Checked = value;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Property to handle checkbox HideThisColumn
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual bool HideThisColumn
        {
            get
            {
                return Controls.HideThisColumnCheckBox.Checked;
            }
            set
            {
                Controls.HideThisColumnCheckBox.Checked = value;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control ColumnFriendlyNameTextBox
        ///  </summary>
        ///  <value>TODO: specify the value</value>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual string ColumnFriendlyNameTextBoxText
        {
            get
            {
                return Controls.ColumnFriendlyNameTextBox.Text;
            }
            set
            {
                Controls.ColumnFriendlyNameTextBox.Text = value;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control ColumnItemTypeComboBox
        ///  </summary>
        ///  <value>TODO: specify the value</value>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual string ColumnItemTypeComboBoxText
        {
            get
            {
                return Controls.ColumnItemTypeComboBox.Text;
            }
            set
            {
                Controls.ColumnItemTypeComboBox.SelectByText(value, true);
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control ColumnItem
        ///  </summary>
        ///  <value>TODO: specify the value</value>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual string ColumnItemText
        {
            get
            {
                return Controls.ColumnItemComboBox.Text;
            }
            set
            {
                Controls.ColumnItemComboBox.SelectByText(value, true);
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control ColumnHeaderDisplayString
        ///  </summary>
        ///  <value>TODO: specify the value</value>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual string ColumnHeaderDisplayStringText
        {
            get
            {
                return Controls.ColumnHeaderDisplayStringComboBox.Text;
            }
            set
            {
                Controls.ColumnHeaderDisplayStringComboBox.SelectByText(value, true);
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control SortOrderComboBox
        ///  </summary>
        ///  <value>TODO: specify the value</value>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual string SortOrderComboBoxText
        {
            get
            {
                return Controls.SortOrderComboBox.Text;
            }
            set
            {
                Controls.SortOrderComboBox.SelectByText(value, true);
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control AggregationMethod
        ///  </summary>
        ///  <value>TODO: specify the value</value>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual string AggregationMethodText
        {
            get
            {
                return Controls.AggregationMethodComboBox.Text;
            }
            set
            {
                Controls.AggregationMethodComboBox.SelectByText(value, true);
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the ColumnFriendlyNameTextBox control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        TextBox ILeaderboardColumnPropertiesDialogControls.ColumnFriendlyNameTextBox
        {
            get
            {
                if ((m_cachedColumnFriendlyNameTextBox == null))
                {
                    m_cachedColumnFriendlyNameTextBox = new TextBox(this, ControlIDs.ColumnFriendlyNameTextBox);
                }
                return m_cachedColumnFriendlyNameTextBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the ColumnItemTypeComboBox control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        ComboBox ILeaderboardColumnPropertiesDialogControls.ColumnItemTypeComboBox
        {
            get
            {
                if ((m_cachedColumnItemTypeComboBox == null))
                {
                    m_cachedColumnItemTypeComboBox = new ComboBox(this, ControlIDs.ColumnItemTypeComboBox);
                }
                return m_cachedColumnItemTypeComboBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the ColumnItemComboBox control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        ComboBox ILeaderboardColumnPropertiesDialogControls.ColumnItemComboBox
        {
            get
            {
                if ((m_cachedColumnItemComboBox == null))
                {
                    m_cachedColumnItemComboBox = new ComboBox(this, ControlIDs.ColumnItemComboBox);
                }
                return m_cachedColumnItemComboBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the ColumnHeaderDisplayStringComboBox control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        ComboBox ILeaderboardColumnPropertiesDialogControls.ColumnHeaderDisplayStringComboBox
        {
            get
            {
                if ((m_cachedColumnHeaderDisplayStringComboBox == null))
                {
                    m_cachedColumnHeaderDisplayStringComboBox = new ComboBox(this, ControlIDs.ColumnHeaderDisplayStringComboBox);
                }
                return m_cachedColumnHeaderDisplayStringComboBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the RankLeaderboardOnThisColumnCheckBox control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        CheckBox ILeaderboardColumnPropertiesDialogControls.RankLeaderboardOnThisColumnCheckBox
        {
            get
            {
                if ((m_cachedRankLeaderboardOnThisColumnCheckBox == null))
                {
                    m_cachedRankLeaderboardOnThisColumnCheckBox = new CheckBox(this, ControlIDs.RankLeaderboardOnThisColumnCheckBox);
                }
                return m_cachedRankLeaderboardOnThisColumnCheckBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the SortOrderComboBox control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        ComboBox ILeaderboardColumnPropertiesDialogControls.SortOrderComboBox
        {
            get
            {
                if ((m_cachedSortOrderComboBox == null))
                {
                    m_cachedSortOrderComboBox = new ComboBox(this, ControlIDs.SortOrderComboBox);
                }
                return m_cachedSortOrderComboBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the AggregationMethodComboBox control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        ComboBox ILeaderboardColumnPropertiesDialogControls.AggregationMethodComboBox
        {
            get
            {
                if ((m_cachedAggregationMethodComboBox == null))
                {
                    m_cachedAggregationMethodComboBox = new ComboBox(this, ControlIDs.AggregationMethodComboBox);
                }
                return m_cachedAggregationMethodComboBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the HideThisColumnCheckBox control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        CheckBox ILeaderboardColumnPropertiesDialogControls.HideThisColumnCheckBox
        {
            get
            {
                if ((m_cachedHideThisColumnCheckBox == null))
                {
                    m_cachedHideThisColumnCheckBox = new CheckBox(this, ControlIDs.HideThisColumnCheckBox);
                }
                return m_cachedHideThisColumnCheckBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the OKButton control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button ILeaderboardColumnPropertiesDialogControls.OKButton
        {
            get
            {
                if ((m_cachedOKButton == null))
                {
                    m_cachedOKButton = new Button(this, ControlIDs.OKButton);
                }
                return m_cachedOKButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the CancelButton control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button ILeaderboardColumnPropertiesDialogControls.CancelButton
        {
            get
            {
                if ((m_cachedCancelButton == null))
                {
                    m_cachedCancelButton = new Button(this, ControlIDs.CancelButton);
                }
                return m_cachedCancelButton;
            }
        }

#endregion

#region "Methods"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button OK
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickOK()
        {
            Controls.OKButton.Click();
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button Cancel
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickCancel()
        {
            Controls.CancelButton.Click();
        }

#endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XLASTAuto\Dialogs\CreateaNewProjectDialog.cs ===
namespace ServerTestFramework.xlast.XLASTAuto.Dialogs
{


    using Maui.Core;
    using Maui.Core.WinControls;
    using Maui.Core.Utilities;
    using System.ComponentModel;


#region "ICreateaNewProjectDialogControls interface definition"
    
    
    [EditorBrowsable(EditorBrowsableState.Never)]
    public interface ICreateaNewProjectDialogControls
    {
        Button OKButton  {get;}
        Button CancelButton  {get;}
        ListBox ChooseAProjectTypeListBox  {get;}
    }

#endregion

    /// -----------------------------------------------------------------------------
    /// Project		: Maui
    /// Class		: CreateaNewProjectDialog
    ///  Copyright (C) 2002, Microsoft Corporation
    /// -----------------------------------------------------------------------------
    ///  <summary>
    ///  TODO: Add dialog functionality description here.
    ///  </summary>
    ///  <history>
    /// 	[trevorm] 4/4/2005 Created
    ///  </history>
    /// -----------------------------------------------------------------------------
    public class CreateaNewProjectDialog : Dialog, ICreateaNewProjectDialogControls
    {


#region "Strings"
        // TODO: Remove unused definitions.
        public class Strings
        {
            public const string DialogTitle = "xlastui.dll:5:1107:0";  // Create a New Project
            public const string OK = ";&OK;Win32DialogItemString;xlastui.dll;1107;1";  // &OK
            public const string Cancel = ";&Cancel;Win32DialogItemString;xlastui.dll;1107;2";  // &Cancel
			//public const string GameConfigurationPackage = ";Game Configuration Package;Win32String;xlastui.dll;16050";
			public const string GameConfigurationPackage = "Game Configuration Package";
			public const string ContentPackage = "Content Package";
		}

#endregion

#region "Control IDs"
        public class ControlIDs
        {
            public const int OKButton = 0x1;
            public const int CancelButton = 0x2;
            public const int ChooseAProjectTypeListBox = 0x2711;
        }

#endregion

#region "Member Variables"
        private Button m_cachedOKButton;
        private Button m_cachedCancelButton;
        private ListBox m_cachedChooseAProjectTypeListBox;

        private const int Timeout = 3000;

#endregion

#region "Constructor and Init function"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  TODO: Add a description for your constructor.
        ///  </summary>
        //  <param name="app">XenonandLiveAuthoringSubmissionToolApp object owning the dialog.</param>
        ///  <history>
        /// 	[trevorm] 4/4/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public CreateaNewProjectDialog(XenonandLiveAuthoringSubmissionToolApp app) : 
                base(app, Init(app))
        {
            // TODO: Add Constructor logic here. 
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  This function will attempt to find a showing instance of the dialog.
        ///  </summary>
        ///  <returns>The dialog's Window</returns>
        ///  <param name="app">XenonandLiveAuthoringSubmissionToolApp owning the dialog.</param>)
        ///  <history>
        /// 	[trevorm] 4/4/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        private static Window Init(XenonandLiveAuthoringSubmissionToolApp app)
        {
            // First check if the dialog is already up.
            Window tempWindow = null;
			try
            {
                tempWindow = new Window(app.GetIntlStr(Strings.DialogTitle), StringMatchSyntax.ExactMatch);
				//tempWindow = new Window(app.GetIntlStr(Strings.DialogTitle), StringMatchSyntax.ExactMatch, WindowClassNames.Alert, StringMatchSyntax.ExactMatch, app.MainWindow, Timeout);
			}
            catch (Exceptions.WindowNotFoundException ex)
            {
                // TODO:  Uncomment the following code and apply the appropriate command for invoking the dialog.
                // 
                // app.DTE.ExecuteCmd(Commands.COMMAND_NAME_HERE);
                // 
                // tempWindow = new Window(Strings.DialogTitle, Utilities.StringMatchSyntax.ExactMatch, strDialogClass, Utilities.StringMatchSyntax.ExactMatch, app.MainWindow, timeOut);
                // if (tempWindow != null)
                // 	return tempWindow;
                // 
                throw new Window.Exceptions.WindowNotFoundException("Init function could not find or bring up the dialog with a title of " + Strings.DialogTitle + ".");
                // 
            }
            return tempWindow;
        }

#endregion

#region "Properties"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the raw controls for this dialog
        ///  </summary>
        ///  <value>An interface that groups all of the dialog's control properties together</value>
        ///  <history>
        /// 	[trevorm] 4/4/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual ICreateaNewProjectDialogControls Controls
        {
            get
            {
                return this;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the OKButton control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/4/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button ICreateaNewProjectDialogControls.OKButton
        {
            get
            {
                if ((m_cachedOKButton == null))
                {
                    m_cachedOKButton = new Button(this, ControlIDs.OKButton);
                }
                return m_cachedOKButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the CancelButton control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/4/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button ICreateaNewProjectDialogControls.CancelButton
        {
            get
            {
                if ((m_cachedCancelButton == null))
                {
                    m_cachedCancelButton = new Button(this, ControlIDs.CancelButton);
                }
                return m_cachedCancelButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the ChooseAProjectTypeListBox control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/4/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        ListBox ICreateaNewProjectDialogControls.ChooseAProjectTypeListBox
        {
            get
            {
                if ((m_cachedChooseAProjectTypeListBox == null))
                {
                    m_cachedChooseAProjectTypeListBox = new ListBox(this, ControlIDs.ChooseAProjectTypeListBox);
                }
                return m_cachedChooseAProjectTypeListBox;
            }
        }

#endregion

#region "Methods"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button OK
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/4/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickOK()
        {
            Controls.OKButton.Click();
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button Cancel
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/4/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickCancel()
        {
            Controls.CancelButton.Click();
        }

#endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XLASTAuto\Dialogs\AddNewPropertyDialog.cs ===
namespace ServerTestFramework.xlast.XLASTAuto.Dialogs
{


    using Maui.Core;
    using Maui.Core.WinControls;
    using Maui.Core.Utilities;
    using System.ComponentModel;


#region "IAddNewPropertyDialogControls interface definition"
    
    
    [EditorBrowsable(EditorBrowsableState.Never)]
    public interface IAddNewPropertyDialogControls
    {
        TextBox NameTextBox  {get;}
        Button OKButton  {get;}
        Button CancelButton  {get;}
    }

#endregion

    /// -----------------------------------------------------------------------------
    /// Project		: Maui
    /// Class		: AddNewPropertyDialog
    ///  Copyright (C) 2002, Microsoft Corporation
    /// -----------------------------------------------------------------------------
    ///  <summary>
    ///  TODO: Add dialog functionality description here.
    ///  </summary>
    ///  <history>
    /// 	[trevorm] 4/5/2005 Created
    ///  </history>
    /// -----------------------------------------------------------------------------
    public class AddNewPropertyDialog : Dialog, IAddNewPropertyDialogControls
    {


#region "Strings"
        public class Strings
        {
			public const string DialogTitle = ";Add New Property;Win32String;xlastui.dll;16810";
            public const string OK = ";OK;Win32DialogItemString;xlastui.dll;16195;1";  // OK
            public const string Cancel = ";Cancel;Win32DialogItemString;xlastui.dll;16195;2";  // Cancel

        }

#endregion

#region "Control IDs"
        public class ControlIDs
        {
            public const int NameTextBox = 0x41A0;
            public const int OKButton = 0x1;
            public const int CancelButton = 0x2;
        }

#endregion

#region "Member Variables"
        private TextBox m_cachedNameTextBox;
        private Button m_cachedOKButton;
        private Button m_cachedCancelButton;

        private const int Timeout = 3000;

#endregion

#region "Constructor and Init function"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  TODO: Add a description for your constructor.
        ///  </summary>
        //  <param name="app">XenonandLiveAuthoringSubmissionToolApp object owning the dialog.</param>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public AddNewPropertyDialog(XenonandLiveAuthoringSubmissionToolApp app) : 
                base(app, Init(app))
        {
            // TODO: Add Constructor logic here. 
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  This function will attempt to find a showing instance of the dialog.
        ///  </summary>
        ///  <returns>The dialog's Window</returns>
        ///  <param name="app">XenonandLiveAuthoringSubmissionToolApp owning the dialog.</param>)
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        private static Window Init(XenonandLiveAuthoringSubmissionToolApp app)
        {
            // First check if the dialog is already up.
            Window tempWindow = null;
            try
            {
                tempWindow = new Window(app.GetIntlStr(Strings.DialogTitle), StringMatchSyntax.ExactMatch, WindowClassNames.Alert, StringMatchSyntax.ExactMatch, app.MainWindow, Timeout);
            }
            catch (Exceptions.WindowNotFoundException ex)
            {
                // TODO:  Uncomment the following code and apply the appropriate command for invoking the dialog.
                // 
                // app.DTE.ExecuteCmd(Commands.COMMAND_NAME_HERE);
                // 
                // tempWindow = new Window(Strings.DialogTitle, Utilities.StringMatchSyntax.ExactMatch, strDialogClass, Utilities.StringMatchSyntax.ExactMatch, app.MainWindow, timeOut);
                // if (tempWindow != null)
                // 	return tempWindow;
                // 
                // throw new Window.Exceptions.WindowNotFoundException("Init function could not find or bring up the dialog with a title of " + Strings.DialogTitle + ".");
                // 
            }
            return tempWindow;
        }

#endregion

#region "Properties"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the raw controls for this dialog
        ///  </summary>
        ///  <value>An interface that groups all of the dialog's control properties together</value>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual IAddNewPropertyDialogControls Controls
        {
            get
            {
                return this;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control Name
        ///  </summary>
        ///  <value>TODO: specify the value</value>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual string NameText
        {
            get
            {
                return Controls.NameTextBox.Text;
            }
            set
            {
                Controls.NameTextBox.Text = value;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the NameTextBox control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        TextBox IAddNewPropertyDialogControls.NameTextBox
        {
            get
            {
                if ((m_cachedNameTextBox == null))
                {
                    m_cachedNameTextBox = new TextBox(this, ControlIDs.NameTextBox);
                }
                return m_cachedNameTextBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the OKButton control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IAddNewPropertyDialogControls.OKButton
        {
            get
            {
                if ((m_cachedOKButton == null))
                {
                    m_cachedOKButton = new Button(this, ControlIDs.OKButton);
                }
                return m_cachedOKButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the CancelButton control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IAddNewPropertyDialogControls.CancelButton
        {
            get
            {
                if ((m_cachedCancelButton == null))
                {
                    m_cachedCancelButton = new Button(this, ControlIDs.CancelButton);
                }
                return m_cachedCancelButton;
            }
        }

#endregion

#region "Methods"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button OK
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickOK()
        {
            Controls.OKButton.Click();
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button Cancel
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickCancel()
        {
            Controls.CancelButton.Click();
        }

#endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XLASTAuto\Dialogs\MatchmakingAddModifyConstantDialog.cs ===
namespace ServerTestFramework.xlast.XLASTAuto.Dialogs
{


    using Maui.Core;
    using Maui.Core.WinControls;
    using Maui.Core.Utilities;
    using System.ComponentModel;


#region "IMatchmakingAddModifyConstantDialogControls interface definition"
    
    
    [EditorBrowsable(EditorBrowsableState.Never)]
    public interface IMatchmakingAddModifyConstantDialogControls
    {
        TextBox ConstantNameTextBox  {get;}
        ComboBox ConstantTypeComboBox  {get;}
        TextBox ConstantValueTextBox  {get;}
        Button OKButton  {get;}
        Button CancelButton  {get;}
    }

#endregion

    /// -----------------------------------------------------------------------------
    /// Project		: Maui
    /// Class		: MatchmakingAddModifyConstantDialog
    ///  Copyright (C) 2002, Microsoft Corporation
    /// -----------------------------------------------------------------------------
    ///  <summary>
    ///  TODO: Add dialog functionality description here.
    ///  </summary>
    ///  <history>
    /// 	[trevorm] 4/5/2005 Created
    ///  </history>
    /// -----------------------------------------------------------------------------
    public class MatchmakingAddModifyConstantDialog : Dialog, IMatchmakingAddModifyConstantDialogControls
    {


#region "Strings"
        public class Strings
        {
            public const string DialogTitle = "xlastui.dll:5:16246:0";  // Add/Modify Constant
            public const string OK = ";OK;Win32DialogItemString;xlastui.dll;16246;1";  // OK
            public const string Cancel = ";Cancel;Win32DialogItemString;xlastui.dll;16246;2";  // Cancel
			public const string TypeInteger = "Integer (4 bytes)";
			public const string TypeLongInteger = "Long Integer (8 bytes)";
			public const string TypeLongFloat = "Long Float (8 bytes)";
			public const string TypeFloat = "Float (4 bytes)";
			public const string TypeDateTime = "DateTime (8 bytes)";
		}

#endregion

#region "Control IDs"
        public class ControlIDs
        {
            public const int ConstantNameTextBox = 0x442A;
            public const int ConstantTypeComboBox = 0x442B;
            public const int ConstantValueTextBox = 0x442C;
            public const int OKButton = 0x1;
            public const int CancelButton = 0x2;
        }

#endregion

#region "Member Variables"

        private TextBox m_cachedConstantNameTextBox;
        private ComboBox m_cachedConstantTypeComboBox;
        private TextBox m_cachedConstantValueTextBox;
        private Button m_cachedOKButton;
        private Button m_cachedCancelButton;

        private const int Timeout = 3000;

#endregion

#region "Constructor and Init function"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  TODO: Add a description for your constructor.
        ///  </summary>
        //  <param name="app">XenonandLiveAuthoringSubmissionToolApp object owning the dialog.</param>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public MatchmakingAddModifyConstantDialog(XenonandLiveAuthoringSubmissionToolApp app) : 
                base(app, Init(app))
        {
            // TODO: Add Constructor logic here. 
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  This function will attempt to find a showing instance of the dialog.
        ///  </summary>
        ///  <returns>The dialog's Window</returns>
        ///  <param name="app">XenonandLiveAuthoringSubmissionToolApp owning the dialog.</param>)
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        private static Window Init(XenonandLiveAuthoringSubmissionToolApp app)
        {
            // First check if the dialog is already up.
            Window tempWindow = null;
            try
            {
                tempWindow = new Window(app.GetIntlStr(Strings.DialogTitle), StringMatchSyntax.ExactMatch, WindowClassNames.Alert, StringMatchSyntax.ExactMatch, app.MainWindow, Timeout);
            }
            catch (Exceptions.WindowNotFoundException ex)
            {
                // TODO:  Uncomment the following code and apply the appropriate command for invoking the dialog.
                // 
                // app.DTE.ExecuteCmd(Commands.COMMAND_NAME_HERE);
                // 
                // tempWindow = new Window(Strings.DialogTitle, Utilities.StringMatchSyntax.ExactMatch, strDialogClass, Utilities.StringMatchSyntax.ExactMatch, app.MainWindow, timeOut);
                // if (tempWindow != null)
                // 	return tempWindow;
                // 
                // throw new Window.Exceptions.WindowNotFoundException("Init function could not find or bring up the dialog with a title of " + Strings.DialogTitle + ".");
                // 
            }
            return tempWindow;
        }

#endregion

#region "Properties"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the raw controls for this dialog
        ///  </summary>
        ///  <value>An interface that groups all of the dialog's control properties together</value>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual IMatchmakingAddModifyConstantDialogControls Controls
        {
            get
            {
                return this;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control ConstantName
        ///  </summary>
        ///  <value>TODO: specify the value</value>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual string ConstantNameText
        {
            get
            {
                return Controls.ConstantNameTextBox.Text;
            }
            set
            {
                Controls.ConstantNameTextBox.Text = value;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control ConstantType
        ///  </summary>
        ///  <value>TODO: specify the value</value>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual string ConstantTypeText
        {
            get
            {
                return Controls.ConstantTypeComboBox.Text;
            }
            set
            {
                Controls.ConstantTypeComboBox.SelectByText(value, true);
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control ConstantValue
        ///  </summary>
        ///  <value>TODO: specify the value</value>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual string ConstantValueText
        {
            get
            {
                return Controls.ConstantValueTextBox.Text;
            }
            set
            {
                Controls.ConstantValueTextBox.Text = value;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the ConstantNameTextBox control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        TextBox IMatchmakingAddModifyConstantDialogControls.ConstantNameTextBox
        {
            get
            {
                if ((m_cachedConstantNameTextBox == null))
                {
                    m_cachedConstantNameTextBox = new TextBox(this, ControlIDs.ConstantNameTextBox);
                }
                return m_cachedConstantNameTextBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the ConstantTypeComboBox control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        ComboBox IMatchmakingAddModifyConstantDialogControls.ConstantTypeComboBox
        {
            get
            {
                if ((m_cachedConstantTypeComboBox == null))
                {
                    m_cachedConstantTypeComboBox = new ComboBox(this, ControlIDs.ConstantTypeComboBox);
                }
                return m_cachedConstantTypeComboBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the ConstantValueTextBox control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        TextBox IMatchmakingAddModifyConstantDialogControls.ConstantValueTextBox
        {
            get
            {
                if ((m_cachedConstantValueTextBox == null))
                {
                    m_cachedConstantValueTextBox = new TextBox(this, ControlIDs.ConstantValueTextBox);
                }
                return m_cachedConstantValueTextBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the OKButton control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IMatchmakingAddModifyConstantDialogControls.OKButton
        {
            get
            {
                if ((m_cachedOKButton == null))
                {
                    m_cachedOKButton = new Button(this, ControlIDs.OKButton);
                }
                return m_cachedOKButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the CancelButton control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IMatchmakingAddModifyConstantDialogControls.CancelButton
        {
            get
            {
                if ((m_cachedCancelButton == null))
                {
                    m_cachedCancelButton = new Button(this, ControlIDs.CancelButton);
                }
                return m_cachedCancelButton;
            }
        }

#endregion

#region "Methods"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button OK
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickOK()
        {
            Controls.OKButton.Click();
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button Cancel
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickCancel()
        {
            Controls.CancelButton.Click();
        }

#endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XLASTAuto\Dialogs\ContextandPropertyEditorDialog.cs ===
namespace ServerTestFramework.xlast.XLASTAuto.Dialogs
{


    using Maui.Core;
    using Maui.Core.WinControls;
    using Maui.Core.Utilities;
    using System.ComponentModel;


#region "IContextandPropertyEditorDialogControls interface definition"
    
    
    [EditorBrowsable(EditorBrowsableState.Never)]
    public interface IContextandPropertyEditorDialogControls
    {
        ListBox ContextPropertyListBox  {get;}
        Button NewContextButton  {get;}
        Button NewPropertyButton  {get;}
        Button OKButton  {get;}
        Button CancelButton  {get;}
    }

#endregion

    /// -----------------------------------------------------------------------------
    /// Project		: Maui
    /// Class		: ContextandPropertyEditorDialog
    ///  Copyright (C) 2002, Microsoft Corporation
    /// -----------------------------------------------------------------------------
    ///  <summary>
    ///  TODO: Add dialog functionality description here.
    ///  </summary>
    ///  <history>
    /// 	[trevorm] 4/5/2005 Created
    ///  </history>
    /// -----------------------------------------------------------------------------
    public class ContextandPropertyEditorDialog : Dialog, IContextandPropertyEditorDialogControls
    {


#region "Strings"
        public class Strings
        {
            public const string DialogTitle = "xlastui.dll:5:16197:0";  // Context and Property Editor
            public const string NewContext = ";New &Context;Win32DialogItemString;xlastui.dll;16197;16844";  // New &Context
            public const string NewProperty = ";New &Property;Win32DialogItemString;xlastui.dll;16197;16845";  // New &Property
            public const string OK = ";OK;Win32DialogItemString;xlastui.dll;16197;1";  // OK
            public const string Cancel = ";Cancel;Win32DialogItemString;xlastui.dll;16197;2";  // Cancel
        }

#endregion

#region "Control IDs"
        public class ControlIDs
        {
            public const int ContextPropertyListBox = 0x41C8;
            public const int NewContextButton = 0x41CC;
            public const int NewPropertyButton = 0x41CD;
            public const int OKButton = 0x1;
            public const int CancelButton = 0x2;
        }

#endregion

#region "Member Variables"
        private ListBox m_cachedContextPropertyListBox;
        private Button m_cachedNewContextButton;
        private Button m_cachedNewPropertyButton;
        private Button m_cachedOKButton;
        private Button m_cachedCancelButton;

        private const int Timeout = 3000;

#endregion

#region "Constructor and Init function"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  TODO: Add a description for your constructor.
        ///  </summary>
        //  <param name="app">XenonandLiveAuthoringSubmissionToolApp object owning the dialog.</param>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public ContextandPropertyEditorDialog(XenonandLiveAuthoringSubmissionToolApp app) : 
                base(app, Init(app))
        {
            // TODO: Add Constructor logic here. 
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  This function will attempt to find a showing instance of the dialog.
        ///  </summary>
        ///  <returns>The dialog's Window</returns>
        ///  <param name="app">XenonandLiveAuthoringSubmissionToolApp owning the dialog.</param>)
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        private static Window Init(XenonandLiveAuthoringSubmissionToolApp app)
        {
            // First check if the dialog is already up.
            Window tempWindow = null;
            try
            {
                tempWindow = new Window(app.GetIntlStr(Strings.DialogTitle), StringMatchSyntax.ExactMatch, WindowClassNames.Alert, StringMatchSyntax.ExactMatch, app.MainWindow, Timeout);
            }
            catch (Exceptions.WindowNotFoundException ex)
            {
                // TODO:  Uncomment the following code and apply the appropriate command for invoking the dialog.
                // 
                // app.DTE.ExecuteCmd(Commands.COMMAND_NAME_HERE);
                // 
                // tempWindow = new Window(Strings.DialogTitle, Utilities.StringMatchSyntax.ExactMatch, strDialogClass, Utilities.StringMatchSyntax.ExactMatch, app.MainWindow, timeOut);
                // if (tempWindow != null)
                // 	return tempWindow;
                // 
                // throw new Window.Exceptions.WindowNotFoundException("Init function could not find or bring up the dialog with a title of " + Strings.DialogTitle + ".");
                // 
            }
            return tempWindow;
        }

#endregion

#region "Properties"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the raw controls for this dialog
        ///  </summary>
        ///  <value>An interface that groups all of the dialog's control properties together</value>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual IContextandPropertyEditorDialogControls Controls
        {
            get
            {
                return this;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the ContextPropertyListBox control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        ListBox IContextandPropertyEditorDialogControls.ContextPropertyListBox
        {
            get
            {
                if ((m_cachedContextPropertyListBox == null))
                {
                    m_cachedContextPropertyListBox = new ListBox(this, ControlIDs.ContextPropertyListBox);
                }
                return m_cachedContextPropertyListBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the NewContextButton control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IContextandPropertyEditorDialogControls.NewContextButton
        {
            get
            {
                if ((m_cachedNewContextButton == null))
                {
                    m_cachedNewContextButton = new Button(this, ControlIDs.NewContextButton);
                }
                return m_cachedNewContextButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the NewPropertyButton control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IContextandPropertyEditorDialogControls.NewPropertyButton
        {
            get
            {
                if ((m_cachedNewPropertyButton == null))
                {
                    m_cachedNewPropertyButton = new Button(this, ControlIDs.NewPropertyButton);
                }
                return m_cachedNewPropertyButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the OKButton control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IContextandPropertyEditorDialogControls.OKButton
        {
            get
            {
                if ((m_cachedOKButton == null))
                {
                    m_cachedOKButton = new Button(this, ControlIDs.OKButton);
                }
                return m_cachedOKButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the CancelButton control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IContextandPropertyEditorDialogControls.CancelButton
        {
            get
            {
                if ((m_cachedCancelButton == null))
                {
                    m_cachedCancelButton = new Button(this, ControlIDs.CancelButton);
                }
                return m_cachedCancelButton;
            }
        }

#endregion

#region "Methods"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button NewContext
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickNewContext()
        {
            Controls.NewContextButton.Click();
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button NewProperty
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickNewProperty()
        {
            Controls.NewPropertyButton.Click();
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button OK
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickOK()
        {
            Controls.OKButton.Click();
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button Cancel
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickCancel()
        {
            Controls.CancelButton.Click();
        }

#endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XLASTAuto\Dialogs\MatchmakingAddModifyFilterDialog.cs ===
namespace ServerTestFramework.xlast.XLASTAuto.Dialogs
{


    using Maui.Core;
    using Maui.Core.WinControls;
    using Maui.Core.Utilities;
    using System.ComponentModel;


#region "IMatchmakingAddModifyFilterDialogControls interface definition"
    
    
    [EditorBrowsable(EditorBrowsableState.Never)]
    public interface IMatchmakingAddModifyFilterDialogControls
    {
        ComboBox LeftSideComboBox  {get;}
        ComboBox OperatorComboBox  {get;}
        ComboBox RightSideComboBox  {get;}
        TextBox FilterTextBox  {get;}
        Button OKButton  {get;}
        Button CancelButton  {get;}
    }

#endregion

    /// -----------------------------------------------------------------------------
    /// Project		: Maui
    /// Class		: MatchmakingAddModifyFilterDialog
    ///  Copyright (C) 2002, Microsoft Corporation
    /// -----------------------------------------------------------------------------
    ///  <summary>
    ///  TODO: Add dialog functionality description here.
    ///  </summary>
    ///  <history>
    /// 	[trevorm] 4/5/2005 Created
    ///  </history>
    /// -----------------------------------------------------------------------------
    public class MatchmakingAddModifyFilterDialog : Dialog, IMatchmakingAddModifyFilterDialogControls
    {


#region "Strings"
        // TODO: Remove unused definitions.
        public class Strings
        {
            public const string DialogTitle = "xlastui.dll:5:16243:0";  // Add/Modify Filter
            public const string OK = ";OK;Win32DialogItemString;xlastui.dll;16243;1";  // OK
            public const string Cancel = ";Cancel;Win32DialogItemString;xlastui.dll;16243;2";  // Cancel
			public const string OperatorEqual = "==";
			public const string OperatorNotEqual = "!=";
			public const string OperatorLessThan = "<";
			public const string OperatorGreaterThan = ">";
			public const string OperatorLessOrEqual = "<=";
			public const string OperatorGreaterOrEqual = ">=";
			public const string AttributePreString = "Attrib:";
			public const string ParameterPreString = "Param:";
			public const string ConstantPreString = "Const:";
			public const string ContextValuePreString = "CtxtVal:";
		}

#endregion

#region "Control IDs"
        public class ControlIDs
        {
            public const int LeftSideComboBox = 0x440C;
            public const int OperatorComboBox = 0x440D;
            public const int RightSideComboBox = 0x440F;
            public const int FilterTextBox = 0x4410;
            public const int OKButton = 0x1;
            public const int CancelButton = 0x2;
        }

#endregion

#region "Member Variables"
        private ComboBox m_cachedLeftSideComboBox;
        private ComboBox m_cachedOperatorComboBox;
        private ComboBox m_cachedRightSideComboBox;
        private TextBox m_cachedFilterTextBox;
        private Button m_cachedOKButton;
        private Button m_cachedCancelButton;

        private const int Timeout = 3000;

#endregion

#region "Constructor and Init function"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  TODO: Add a description for your constructor.
        ///  </summary>
        //  <param name="app">XenonandLiveAuthoringSubmissionToolApp object owning the dialog.</param>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public MatchmakingAddModifyFilterDialog(XenonandLiveAuthoringSubmissionToolApp app) : 
                base(app, Init(app))
        {
            // TODO: Add Constructor logic here. 
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  This function will attempt to find a showing instance of the dialog.
        ///  </summary>
        ///  <returns>The dialog's Window</returns>
        ///  <param name="app">XenonandLiveAuthoringSubmissionToolApp owning the dialog.</param>)
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        private static Window Init(XenonandLiveAuthoringSubmissionToolApp app)
        {
            // First check if the dialog is already up.
            Window tempWindow = null;
            try
            {
                tempWindow = new Window(app.GetIntlStr(Strings.DialogTitle), StringMatchSyntax.ExactMatch, WindowClassNames.Alert, StringMatchSyntax.ExactMatch, app.MainWindow, Timeout);
            }
            catch (Exceptions.WindowNotFoundException ex)
            {
                // TODO:  Uncomment the following code and apply the appropriate command for invoking the dialog.
                // 
                // app.DTE.ExecuteCmd(Commands.COMMAND_NAME_HERE);
                // 
                // tempWindow = new Window(Strings.DialogTitle, Utilities.StringMatchSyntax.ExactMatch, strDialogClass, Utilities.StringMatchSyntax.ExactMatch, app.MainWindow, timeOut);
                // if (tempWindow != null)
                // 	return tempWindow;
                // 
                // throw new Window.Exceptions.WindowNotFoundException("Init function could not find or bring up the dialog with a title of " + Strings.DialogTitle + ".");
                // 
            }
            return tempWindow;
        }

#endregion

#region "Properties"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the raw controls for this dialog
        ///  </summary>
        ///  <value>An interface that groups all of the dialog's control properties together</value>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual IMatchmakingAddModifyFilterDialogControls Controls
        {
            get
            {
                return this;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control LeftSide
        ///  </summary>
        ///  <value>TODO: specify the value</value>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual string LeftSideText
        {
            get
            {
                return Controls.LeftSideComboBox.Text;
            }
            set
            {
                Controls.LeftSideComboBox.SelectByText(value, true);
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control Operator
        ///  </summary>
        ///  <value>TODO: specify the value</value>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual string OperatorText
        {
            get
            {
                return Controls.OperatorComboBox.Text;
            }
            set
            {
                Controls.OperatorComboBox.SelectByText(value, true);
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control RightSide
        ///  </summary>
        ///  <value>TODO: specify the value</value>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual string RightSideText
        {
            get
            {
                return Controls.RightSideComboBox.Text;
            }
            set
            {
                Controls.RightSideComboBox.SelectByText(value, true);
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control Filter
        ///  </summary>
        ///  <value>TODO: specify the value</value>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual string FilterText
        {
            get
            {
                return Controls.FilterTextBox.Text;
            }
            set
            {
				// Should fail since it's read-only, but leaving in for testing read-only status
                Controls.FilterTextBox.Text = value;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the LeftSideComboBox control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        ComboBox IMatchmakingAddModifyFilterDialogControls.LeftSideComboBox
        {
            get
            {
                if ((m_cachedLeftSideComboBox == null))
                {
                    m_cachedLeftSideComboBox = new ComboBox(this, ControlIDs.LeftSideComboBox);
                }
                return m_cachedLeftSideComboBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the OperatorComboBox control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        ComboBox IMatchmakingAddModifyFilterDialogControls.OperatorComboBox
        {
            get
            {
                if ((m_cachedOperatorComboBox == null))
                {
                    m_cachedOperatorComboBox = new ComboBox(this, ControlIDs.OperatorComboBox);
                }
                return m_cachedOperatorComboBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the RightSideComboBox control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        ComboBox IMatchmakingAddModifyFilterDialogControls.RightSideComboBox
        {
            get
            {
                if ((m_cachedRightSideComboBox == null))
                {
                    m_cachedRightSideComboBox = new ComboBox(this, ControlIDs.RightSideComboBox);
                }
                return m_cachedRightSideComboBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the FilterTextBox control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        TextBox IMatchmakingAddModifyFilterDialogControls.FilterTextBox
        {
            get
            {
                if ((m_cachedFilterTextBox == null))
                {
                    m_cachedFilterTextBox = new TextBox(this, ControlIDs.FilterTextBox);
                }
                return m_cachedFilterTextBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the OKButton control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IMatchmakingAddModifyFilterDialogControls.OKButton
        {
            get
            {
                if ((m_cachedOKButton == null))
                {
                    m_cachedOKButton = new Button(this, ControlIDs.OKButton);
                }
                return m_cachedOKButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the CancelButton control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IMatchmakingAddModifyFilterDialogControls.CancelButton
        {
            get
            {
                if ((m_cachedCancelButton == null))
                {
                    m_cachedCancelButton = new Button(this, ControlIDs.CancelButton);
                }
                return m_cachedCancelButton;
            }
        }

#endregion

#region "Methods"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button OK
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickOK()
        {
            Controls.OKButton.Click();
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button Cancel
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickCancel()
        {
            Controls.CancelButton.Click();
        }

#endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XLASTAuto\Dialogs\SelectImageFileDialog.cs ===
namespace ServerTestFramework.xlast.XLASTAuto.Dialogs
{


    using Maui.Core;
    using Maui.Core.WinControls;
    using Maui.Core.Utilities;
    using System.ComponentModel;


#region "ISelectImageFileDialogControls interface definition"
    
    
    [EditorBrowsable(EditorBrowsableState.Never)]
    public interface ISelectImageFileDialogControls
    {
        ComboBox LookInComboBox  {get;}
        ListView FolderView  {get;}
        EditComboBox FileNameEditComboBox  {get;}
        EditComboBox FileNameEditComboBox2  {get;}
        ComboBox FilesOfTypeComboBox  {get;}
        Button OpenButton  {get;}
        Button CancelButton  {get;}
    }

#endregion

    /// -----------------------------------------------------------------------------
    /// Project		: Maui
    /// Class		: SelectImageFileDialog
    ///  Copyright (C) 2002, Microsoft Corporation
    /// -----------------------------------------------------------------------------
    ///  <summary>
    ///  TODO: Add dialog functionality description here.
    ///  </summary>
    ///  <history>
    /// 	[trevorm] 4/5/2005 Created
    ///  </history>
    /// -----------------------------------------------------------------------------
    public class SelectImageFileDialog : Dialog, ISelectImageFileDialogControls
    {


#region "Strings"
        // TODO: Remove unused definitions.
        public class Strings
        {
			public const string DialogTitle = ";Select Image File;Win32String;xlastui.dll;16342";
            public const string Open = "&Open";
            public const string Cancel = ";Cancel;Win32DialogItemString;xlastui.dll;16195;2";  // Cancel

        }

#endregion

#region "Control IDs"
        public class ControlIDs
        {
            public const int LookInComboBox = 0x471;
            public const int FolderView = 0x1;
            public const int FileNameEditComboBox = 0x47C;
            public const int FileNameEditComboBox2 = 0x47C;
            public const int FilesOfTypeComboBox = 0x470;
            public const int OpenButton = 0x1;
            public const int CancelButton = 0x2;
        }

#endregion

#region "Member Variables"
        private ComboBox m_cachedLookInComboBox;
        private ListView m_cachedFolderView;
        private EditComboBox m_cachedFileNameEditComboBox;
        private EditComboBox m_cachedFileNameEditComboBox2;
        private ComboBox m_cachedFilesOfTypeComboBox;
        private Button m_cachedOpenButton;
        private Button m_cachedCancelButton;

        private const int Timeout = 3000;

#endregion

#region "Constructor and Init function"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  TODO: Add a description for your constructor.
        ///  </summary>
        //  <param name="app">Window object owning the dialog.</param>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public SelectImageFileDialog(XenonandLiveAuthoringSubmissionToolApp app) : 
                base(app, Init(app))
        {
            // TODO: Add Constructor logic here. 
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  This function will attempt to find a showing instance of the dialog.
        ///  </summary>
        ///  <returns>The dialog's Window</returns>
        ///  <param name="app">Window owning the dialog.</param>)
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        private static Window Init(XenonandLiveAuthoringSubmissionToolApp app)
        {
            // First check if the dialog is already up.
            Window tempWindow = null;
            try
            {
                tempWindow = new Window(app.GetIntlStr(Strings.DialogTitle), StringMatchSyntax.ExactMatch, WindowClassNames.Alert, StringMatchSyntax.ExactMatch, app.MainWindow, Timeout);
            }
            catch (Exceptions.WindowNotFoundException ex)
            {
                // TODO:  Uncomment the following code and apply the appropriate command for invoking the dialog.
                // 
                // app.DTE.ExecuteCmd(Commands.COMMAND_NAME_HERE);
                // 
                // tempWindow = new Window(Strings.DialogTitle, Utilities.StringMatchSyntax.ExactMatch, strDialogClass, Utilities.StringMatchSyntax.ExactMatch, app.MainWindow, timeOut);
                // if (tempWindow != null)
                // 	return tempWindow;
                // 
                // throw new Window.Exceptions.WindowNotFoundException("Init function could not find or bring up the dialog with a title of " + Strings.DialogTitle + ".");
                // 
            }
            return tempWindow;
        }

#endregion

#region "Properties"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the raw controls for this dialog
        ///  </summary>
        ///  <value>An interface that groups all of the dialog's control properties together</value>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual ISelectImageFileDialogControls Controls
        {
            get
            {
                return this;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control LookIn
        ///  </summary>
        ///  <value>TODO: specify the value</value>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual string LookInText
        {
            get
            {
                return Controls.LookInComboBox.Text;
            }
            set
            {
                Controls.LookInComboBox.SelectByText(value, true);
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control FileName
        ///  </summary>
        ///  <value>TODO: specify the value</value>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual string FileNameText
        {
            get
            {
                return Controls.FileNameEditComboBox.Text;
            }
            set
            {
                Controls.FileNameEditComboBox.Text = value;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control FileName2
        ///  </summary>
        ///  <value>TODO: specify the value</value>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual string FileName2Text
        {
            get
            {
                return Controls.FileNameEditComboBox2.Text;
            }
            set
            {
                Controls.FileNameEditComboBox2.Text = value;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control FilesOfType
        ///  </summary>
        ///  <value>TODO: specify the value</value>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual string FilesOfTypeText
        {
            get
            {
                return Controls.FilesOfTypeComboBox.Text;
            }
            set
            {
                Controls.FilesOfTypeComboBox.SelectByText(value, true);
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the LookInComboBox control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        ComboBox ISelectImageFileDialogControls.LookInComboBox
        {
            get
            {
                if ((m_cachedLookInComboBox == null))
                {
                    m_cachedLookInComboBox = new ComboBox(this, ControlIDs.LookInComboBox);
                }
                return m_cachedLookInComboBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the FolderView control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        ListView ISelectImageFileDialogControls.FolderView
        {
            get
            {
                if ((m_cachedFolderView == null))
                {
                    m_cachedFolderView = new ListView(this, ControlIDs.FolderView);
                }
                return m_cachedFolderView;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the FileNameEditComboBox control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        EditComboBox ISelectImageFileDialogControls.FileNameEditComboBox
        {
            get
            {
                if ((m_cachedFileNameEditComboBox == null))
                {
                    m_cachedFileNameEditComboBox = new EditComboBox(this, ControlIDs.FileNameEditComboBox);
                }
                return m_cachedFileNameEditComboBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the FileNameEditComboBox2 control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        EditComboBox ISelectImageFileDialogControls.FileNameEditComboBox2
        {
            get
            {
                // The ID for this control (1148) is used multiple times in this dialog.
                //  Investigate why and report a bug if necessary.  The generated code follows the window
                //  hierarchy path to find the control to work around this problem.
                if ((m_cachedFileNameEditComboBox2 == null))
                {
                    Window wndTemp = this;
                    // Required to navigate to control
                    wndTemp = wndTemp.Extended.FirstChild;
                    int i;
                    for (i = 0; (i <= 7); i = (i + 1))
                    {
                        wndTemp = wndTemp.Extended.NextSibling;
                    }
                    wndTemp = wndTemp.Extended.FirstChild;
                    m_cachedFileNameEditComboBox2 = new EditComboBox(wndTemp);
                }
                return m_cachedFileNameEditComboBox2;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the FilesOfTypeComboBox control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        ComboBox ISelectImageFileDialogControls.FilesOfTypeComboBox
        {
            get
            {
                if ((m_cachedFilesOfTypeComboBox == null))
                {
                    m_cachedFilesOfTypeComboBox = new ComboBox(this, ControlIDs.FilesOfTypeComboBox);
                }
                return m_cachedFilesOfTypeComboBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the OpenButton control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button ISelectImageFileDialogControls.OpenButton
        {
            get
            {
                // The ID for this control (1) is used multiple times in this dialog.
                //  Investigate why and report a bug if necessary.  The generated code follows the window
                //  hierarchy path to find the control to work around this problem.
                if ((m_cachedOpenButton == null))
                {
                    Window wndTemp = this;
                    // Required to navigate to control
                    wndTemp = wndTemp.Extended.FirstChild;
                    int i;
                    for (i = 0; (i <= 11); i = (i + 1))
                    {
                        wndTemp = wndTemp.Extended.NextSibling;
                    }
                    m_cachedOpenButton = new Button(wndTemp);
                }
                return m_cachedOpenButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the CancelButton control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button ISelectImageFileDialogControls.CancelButton
        {
            get
            {
                if ((m_cachedCancelButton == null))
                {
                    m_cachedCancelButton = new Button(this, ControlIDs.CancelButton);
                }
                return m_cachedCancelButton;
            }
        }

#endregion

#region "Methods"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button Open
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickOpen()
        {
            Controls.OpenButton.Click();
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button Cancel
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickCancel()
        {
            Controls.CancelButton.Click();
        }

#endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XLASTAuto\Dialogs\NewMatchmakingQueryDialog.cs ===
namespace ServerTestFramework.xlast.XLASTAuto.Dialogs
{


    using Maui.Core;
    using Maui.Core.WinControls;
    using Maui.Core.Utilities;
    using System.ComponentModel;


#region "INewMatchmakingQueryDialogControls interface definition"
    
    
    [EditorBrowsable(EditorBrowsableState.Never)]
    public interface INewMatchmakingQueryDialogControls
    {
        TextBox QueryNameTextBox  {get;}
        TextBox MaxResultsTextBox  {get;}
        CheckBox QualityOfServiceProbingCodeGenerationCheckBox  {get;}
        Button OKButton  {get;}
        Button CancelButton  {get;}
    }

#endregion

    /// -----------------------------------------------------------------------------
    /// Project		: Maui
    /// Class		: NewMatchmakingQueryDialog
    ///  Copyright (C) 2002, Microsoft Corporation
    /// -----------------------------------------------------------------------------
    ///  <summary>
    ///  TODO: Add dialog functionality description here.
    ///  </summary>
    ///  <history>
    /// 	[trevorm] 4/5/2005 Created
    ///  </history>
    /// -----------------------------------------------------------------------------
    public class NewMatchmakingQueryDialog : Dialog, INewMatchmakingQueryDialogControls
    {


#region "Strings"
        public class Strings
        {
            public const string DialogTitle = "xlastui.dll:5:16231:0";  // New Query
            public const string QualityOfServiceProbingCodeGeneration = ";&Quality of Service Probing code generation;Win32DialogItemString;xlastui.dll;16231;17306";  // &Quality of Service Probing code generation
            public const string OK = ";OK;Win32DialogItemString;xlastui.dll;16231;1";  // OK
            public const string Cancel = ";Cancel;Win32DialogItemString;xlastui.dll;16231;2";  // Cancel
        }

#endregion

#region "Control IDs"
        public class ControlIDs
        {
            public const int QueryNameTextBox = 0x4394;
            public const int MaxResultsTextBox = 0x4395;
            public const int QualityOfServiceProbingCodeGenerationCheckBox = 0x439A;
            public const int OKButton = 0x1;
            public const int CancelButton = 0x2;
        }

#endregion

#region "Member Variables"
        private TextBox m_cachedQueryNameTextBox;
        private TextBox m_cachedMaxResultsTextBox;
        private CheckBox m_cachedQualityOfServiceProbingCodeGenerationCheckBox;
        private Button m_cachedOKButton;
        private Button m_cachedCancelButton;

        private const int Timeout = 3000;

#endregion

#region "Constructor and Init function"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  TODO: Add a description for your constructor.
        ///  </summary>
        //  <param name="app">XenonandLiveAuthoringSubmissionToolApp object owning the dialog.</param>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public NewMatchmakingQueryDialog(XenonandLiveAuthoringSubmissionToolApp app) : 
                base(app, Init(app))
        {
            // TODO: Add Constructor logic here. 
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  This function will attempt to find a showing instance of the dialog.
        ///  </summary>
        ///  <returns>The dialog's Window</returns>
        ///  <param name="app">XenonandLiveAuthoringSubmissionToolApp owning the dialog.</param>)
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        private static Window Init(XenonandLiveAuthoringSubmissionToolApp app)
        {
            // First check if the dialog is already up.
            Window tempWindow = null;
            try
            {
                tempWindow = new Window(app.GetIntlStr(Strings.DialogTitle), StringMatchSyntax.ExactMatch, WindowClassNames.Alert, StringMatchSyntax.ExactMatch, app.MainWindow, Timeout);
            }
            catch (Exceptions.WindowNotFoundException ex)
            {
                // TODO:  Uncomment the following code and apply the appropriate command for invoking the dialog.
                // 
                // app.DTE.ExecuteCmd(Commands.COMMAND_NAME_HERE);
                // 
                // tempWindow = new Window(Strings.DialogTitle, Utilities.StringMatchSyntax.ExactMatch, strDialogClass, Utilities.StringMatchSyntax.ExactMatch, app.MainWindow, timeOut);
                // if (tempWindow != null)
                // 	return tempWindow;
                // 
                // throw new Window.Exceptions.WindowNotFoundException("Init function could not find or bring up the dialog with a title of " + Strings.DialogTitle + ".");
                // 
            }
            return tempWindow;
        }

#endregion

#region "Properties"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the raw controls for this dialog
        ///  </summary>
        ///  <value>An interface that groups all of the dialog's control properties together</value>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual INewMatchmakingQueryDialogControls Controls
        {
            get
            {
                return this;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Property to handle checkbox QualityOfServiceProbingCodeGeneration
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual bool QualityOfServiceProbingCodeGeneration
        {
            get
            {
                return Controls.QualityOfServiceProbingCodeGenerationCheckBox.Checked;
            }
            set
            {
                Controls.QualityOfServiceProbingCodeGenerationCheckBox.Checked = value;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control QueryName
        ///  </summary>
        ///  <value>TODO: specify the value</value>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual string QueryNameText
        {
            get
            {
                return Controls.QueryNameTextBox.Text;
            }
            set
            {
                Controls.QueryNameTextBox.Text = value;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control MaxResults
        ///  </summary>
        ///  <value>TODO: specify the value</value>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual string MaxResultsText
        {
            get
            {
                return Controls.MaxResultsTextBox.Text;
            }
            set
            {
                Controls.MaxResultsTextBox.Text = value;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the QueryNameTextBox control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        TextBox INewMatchmakingQueryDialogControls.QueryNameTextBox
        {
            get
            {
                if ((m_cachedQueryNameTextBox == null))
                {
                    m_cachedQueryNameTextBox = new TextBox(this, ControlIDs.QueryNameTextBox);
                }
                return m_cachedQueryNameTextBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the MaxResultsTextBox control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        TextBox INewMatchmakingQueryDialogControls.MaxResultsTextBox
        {
            get
            {
                if ((m_cachedMaxResultsTextBox == null))
                {
                    m_cachedMaxResultsTextBox = new TextBox(this, ControlIDs.MaxResultsTextBox);
                }
                return m_cachedMaxResultsTextBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the QualityOfServiceProbingCodeGenerationCheckBox control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        CheckBox INewMatchmakingQueryDialogControls.QualityOfServiceProbingCodeGenerationCheckBox
        {
            get
            {
                if ((m_cachedQualityOfServiceProbingCodeGenerationCheckBox == null))
                {
                    m_cachedQualityOfServiceProbingCodeGenerationCheckBox = new CheckBox(this, ControlIDs.QualityOfServiceProbingCodeGenerationCheckBox);
                }
                return m_cachedQualityOfServiceProbingCodeGenerationCheckBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the OKButton control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button INewMatchmakingQueryDialogControls.OKButton
        {
            get
            {
                if ((m_cachedOKButton == null))
                {
                    m_cachedOKButton = new Button(this, ControlIDs.OKButton);
                }
                return m_cachedOKButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the CancelButton control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button INewMatchmakingQueryDialogControls.CancelButton
        {
            get
            {
                if ((m_cachedCancelButton == null))
                {
                    m_cachedCancelButton = new Button(this, ControlIDs.CancelButton);
                }
                return m_cachedCancelButton;
            }
        }

#endregion

#region "Methods"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button OK
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickOK()
        {
            Controls.OKButton.Click();
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button Cancel
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickCancel()
        {
            Controls.CancelButton.Click();
        }

#endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XLASTAuto\Dialogs\SelectAchievementsDialog.cs ===
namespace ServerTestFramework.xlast.XLASTAuto.Dialogs
{


    using Maui.Core;
    using Maui.Core.WinControls;
    using Maui.Core.Utilities;
    using System.ComponentModel;


#region "ISelectAchievementsDialogControls interface definition"
    
    
    [EditorBrowsable(EditorBrowsableState.Never)]
    public interface ISelectAchievementsDialogControls
    {
        ListBox NameListBox  {get;}
        Button OKButton  {get;}
        Button CancelButton  {get;}
    }

#endregion

    /// -----------------------------------------------------------------------------
    /// Project		: Maui
    /// Class		: SelectAchievementsDialog
    ///  Copyright (C) 2002, Microsoft Corporation
    /// -----------------------------------------------------------------------------
    ///  <summary>
    ///  TODO: Add dialog functionality description here.
    ///  </summary>
    ///  <history>
    /// 	[trevorm] 4/5/2005 Created
    ///  </history>
    /// -----------------------------------------------------------------------------
    public class SelectAchievementsDialog : Dialog, ISelectAchievementsDialogControls
    {


#region "Strings"
        public class Strings
        {
            public const string DialogTitle = "xlastui.dll:5:16198:0";  // Select Achievements
            public const string OK = ";OK;Win32DialogItemString;xlastui.dll;16198;1";  // OK
            public const string Cancel = ";Cancel;Win32DialogItemString;xlastui.dll;16198;2";  // Cancel
        }

#endregion

#region "Control IDs"
        public class ControlIDs
        {
            public const int NameListBox = 0x41D2;
            public const int OKButton = 0x1;
            public const int CancelButton = 0x2;
        }

#endregion

#region "Member Variables"
        private ListBox m_cachedNameListBox;
        private Button m_cachedOKButton;
        private Button m_cachedCancelButton;

        private const int Timeout = 3000;

#endregion

#region "Constructor and Init function"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  TODO: Add a description for your constructor.
        ///  </summary>
        //  <param name="app">Window object owning the dialog.</param>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public SelectAchievementsDialog(XenonandLiveAuthoringSubmissionToolApp app) : 
                base(app, Init(app))
        {
            // TODO: Add Constructor logic here. 
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  This function will attempt to find a showing instance of the dialog.
        ///  </summary>
        ///  <returns>The dialog's Window</returns>
        ///  <param name="app">Window owning the dialog.</param>)
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        private static Window Init(XenonandLiveAuthoringSubmissionToolApp app)
        {
            // First check if the dialog is already up.
            Window tempWindow = null;
            try
            {
                tempWindow = new Window(app.GetIntlStr(Strings.DialogTitle), StringMatchSyntax.ExactMatch, WindowClassNames.Alert, StringMatchSyntax.ExactMatch, app.MainWindow, Timeout);
            }
            catch (Exceptions.WindowNotFoundException ex)
            {
                // TODO:  Uncomment the following code and apply the appropriate command for invoking the dialog.
                // 
                // app.DTE.ExecuteCmd(Commands.COMMAND_NAME_HERE);
                // 
                // tempWindow = new Window(Strings.DialogTitle, Utilities.StringMatchSyntax.ExactMatch, strDialogClass, Utilities.StringMatchSyntax.ExactMatch, app.MainWindow, timeOut);
                // if (tempWindow != null)
                // 	return tempWindow;
                // 
                // throw new Window.Exceptions.WindowNotFoundException("Init function could not find or bring up the dialog with a title of " + Strings.DialogTitle + ".");
                // 
            }
            return tempWindow;
        }

#endregion

#region "Properties"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the raw controls for this dialog
        ///  </summary>
        ///  <value>An interface that groups all of the dialog's control properties together</value>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual ISelectAchievementsDialogControls Controls
        {
            get
            {
                return this;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the NameListBox control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        ListBox ISelectAchievementsDialogControls.NameListBox
        {
            get
            {
                if ((m_cachedNameListBox == null))
                {
                    m_cachedNameListBox = new ListBox(this, ControlIDs.NameListBox);
                }
                return m_cachedNameListBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the OKButton control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button ISelectAchievementsDialogControls.OKButton
        {
            get
            {
                if ((m_cachedOKButton == null))
                {
                    m_cachedOKButton = new Button(this, ControlIDs.OKButton);
                }
                return m_cachedOKButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the CancelButton control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button ISelectAchievementsDialogControls.CancelButton
        {
            get
            {
                if ((m_cachedCancelButton == null))
                {
                    m_cachedCancelButton = new Button(this, ControlIDs.CancelButton);
                }
                return m_cachedCancelButton;
            }
        }

#endregion

#region "Methods"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button OK
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickOK()
        {
            Controls.OKButton.Click();
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button Cancel
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickCancel()
        {
            Controls.CancelButton.Click();
        }

#endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XLASTAuto\Dialogs\MatchmakingAddModifySortOperatorDialog.cs ===
namespace ServerTestFramework.xlast.XLASTAuto.Dialogs
{


    using Maui.Core;
    using Maui.Core.WinControls;
    using Maui.Core.Utilities;
    using System.ComponentModel;


#region "IMatchmakingAddModifySortOperatorDialogControls interface definition"
    
    
    [EditorBrowsable(EditorBrowsableState.Never)]
    public interface IMatchmakingAddModifySortOperatorDialogControls
    {
        ComboBox SortCriteriaComboBox  {get;}
        ComboBox TypeComboBox  {get;}
        ComboBox AttributeComboBox  {get;}
        Button OKButton  {get;}
        Button CancelButton  {get;}
    }

#endregion

    /// -----------------------------------------------------------------------------
    /// Project		: Maui
    /// Class		: MatchmakingAddModifySortOperatorDialog
    ///  Copyright (C) 2002, Microsoft Corporation
    /// -----------------------------------------------------------------------------
    ///  <summary>
    ///  TODO: Add dialog functionality description here.
    ///  </summary>
    ///  <history>
    /// 	[trevorm] 4/5/2005 Created
    ///  </history>
    /// -----------------------------------------------------------------------------
    public class MatchmakingAddModifySortOperatorDialog : Dialog, IMatchmakingAddModifySortOperatorDialogControls
    {


#region "Strings"
        public class Strings
        {
            public const string DialogTitle = "xlastui.dll:5:16244:0";  // Add/Modify Sort Operator
            public const string OK = ";OK;Win32DialogItemString;xlastui.dll;16244;1";  // OK
            public const string Cancel = ";Cancel;Win32DialogItemString;xlastui.dll;16244;2";  // Cancel
			public const string SortTypeAscending = "Ascending";
			public const string SortTypeDescending = "Descending";
			public const string SortTypeNear = "Near";
			public const string SortTypeFar = "Far";
			public const string AttributePreString = "Attrib:";
			public const string ParameterPreString = "Param:";
			public const string ConstantPreString = "Const:";
			public const string ContextValuePreString = "CtxtVal:";
		}

#endregion

#region "Control IDs"
        public class ControlIDs
        {
            public const int SortCriteriaComboBox = 0x4416;
            public const int TypeComboBox = 0x4417;
            public const int AttributeComboBox = 0x4418;
            public const int OKButton = 0x1;
            public const int CancelButton = 0x2;
        }

#endregion

#region "Member Variables"
        private ComboBox m_cachedSortCriteriaComboBox;
        private ComboBox m_cachedTypeComboBox;
        private ComboBox m_cachedAttributeComboBox;
        private Button m_cachedOKButton;
        private Button m_cachedCancelButton;

        private const int Timeout = 3000;

#endregion

#region "Constructor and Init function"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  TODO: Add a description for your constructor.
        ///  </summary>
        //  <param name="app">XenonandLiveAuthoringSubmissionToolApp object owning the dialog.</param>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public MatchmakingAddModifySortOperatorDialog(XenonandLiveAuthoringSubmissionToolApp app) : 
                base(app, Init(app))
        {
            // TODO: Add Constructor logic here. 
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  This function will attempt to find a showing instance of the dialog.
        ///  </summary>
        ///  <returns>The dialog's Window</returns>
        ///  <param name="app">XenonandLiveAuthoringSubmissionToolApp owning the dialog.</param>)
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        private static Window Init(XenonandLiveAuthoringSubmissionToolApp app)
        {
            // First check if the dialog is already up.
            Window tempWindow = null;
            try
            {
                tempWindow = new Window(app.GetIntlStr(Strings.DialogTitle), StringMatchSyntax.ExactMatch, WindowClassNames.Alert, StringMatchSyntax.ExactMatch, app.MainWindow, Timeout);
            }
            catch (Exceptions.WindowNotFoundException ex)
            {
                // TODO:  Uncomment the following code and apply the appropriate command for invoking the dialog.
                // 
                // app.DTE.ExecuteCmd(Commands.COMMAND_NAME_HERE);
                // 
                // tempWindow = new Window(Strings.DialogTitle, Utilities.StringMatchSyntax.ExactMatch, strDialogClass, Utilities.StringMatchSyntax.ExactMatch, app.MainWindow, timeOut);
                // if (tempWindow != null)
                // 	return tempWindow;
                // 
                // throw new Window.Exceptions.WindowNotFoundException("Init function could not find or bring up the dialog with a title of " + Strings.DialogTitle + ".");
                // 
            }
            return tempWindow;
        }

#endregion

#region "Properties"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the raw controls for this dialog
        ///  </summary>
        ///  <value>An interface that groups all of the dialog's control properties together</value>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual IMatchmakingAddModifySortOperatorDialogControls Controls
        {
            get
            {
                return this;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control SortCriteria
        ///  </summary>
        ///  <value>TODO: specify the value</value>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual string SortCriteriaText
        {
            get
            {
                return Controls.SortCriteriaComboBox.Text;
            }
            set
            {
                Controls.SortCriteriaComboBox.SelectByText(value, true);
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control Type
        ///  </summary>
        ///  <value>TODO: specify the value</value>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual string TypeText
        {
            get
            {
                return Controls.TypeComboBox.Text;
            }
            set
            {
                Controls.TypeComboBox.SelectByText(value, true);
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control Attribute
        ///  </summary>
        ///  <value>TODO: specify the value</value>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual string AttributeText
        {
            get
            {
                return Controls.AttributeComboBox.Text;
            }
            set
            {
                Controls.AttributeComboBox.SelectByText(value, true);
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the SortCriteriaComboBox control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        ComboBox IMatchmakingAddModifySortOperatorDialogControls.SortCriteriaComboBox
        {
            get
            {
                if ((m_cachedSortCriteriaComboBox == null))
                {
                    m_cachedSortCriteriaComboBox = new ComboBox(this, ControlIDs.SortCriteriaComboBox);
                }
                return m_cachedSortCriteriaComboBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the TypeComboBox control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        ComboBox IMatchmakingAddModifySortOperatorDialogControls.TypeComboBox
        {
            get
            {
                if ((m_cachedTypeComboBox == null))
                {
                    m_cachedTypeComboBox = new ComboBox(this, ControlIDs.TypeComboBox);
                }
                return m_cachedTypeComboBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the AttributeComboBox control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        ComboBox IMatchmakingAddModifySortOperatorDialogControls.AttributeComboBox
        {
            get
            {
                if ((m_cachedAttributeComboBox == null))
                {
                    m_cachedAttributeComboBox = new ComboBox(this, ControlIDs.AttributeComboBox);
                }
                return m_cachedAttributeComboBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the OKButton control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IMatchmakingAddModifySortOperatorDialogControls.OKButton
        {
            get
            {
                if ((m_cachedOKButton == null))
                {
                    m_cachedOKButton = new Button(this, ControlIDs.OKButton);
                }
                return m_cachedOKButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the CancelButton control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IMatchmakingAddModifySortOperatorDialogControls.CancelButton
        {
            get
            {
                if ((m_cachedCancelButton == null))
                {
                    m_cachedCancelButton = new Button(this, ControlIDs.CancelButton);
                }
                return m_cachedCancelButton;
            }
        }

#endregion

#region "Methods"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button OK
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickOK()
        {
            Controls.OKButton.Click();
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button Cancel
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickCancel()
        {
            Controls.CancelButton.Click();
        }

#endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XLASTAuto\Dialogs\MatchmakingAddModifyReturnValueDialog.cs ===
namespace ServerTestFramework.xlast.XLASTAuto.Dialogs
{


    using Maui.Core;
    using Maui.Core.WinControls;
    using Maui.Core.Utilities;
    using System.ComponentModel;


#region "IMatchmakingAddModifyReturnValueDialogControls interface definition"
    
    
    [EditorBrowsable(EditorBrowsableState.Never)]
    public interface IMatchmakingAddModifyReturnValueDialogControls
    {
        ComboBox AttributeNameComboBox  {get;}
        Button OKButton  {get;}
        Button CancelButton  {get;}
        ComboBox ReturnTypeComboBox  {get;}
    }

#endregion

    /// -----------------------------------------------------------------------------
    /// Project		: Maui
    /// Class		: MatchmakingAddModifyReturnValueDialog
    ///  Copyright (C) 2002, Microsoft Corporation
    /// -----------------------------------------------------------------------------
    ///  <summary>
    ///  TODO: Add dialog functionality description here.
    ///  </summary>
    ///  <history>
    /// 	[trevorm] 4/5/2005 Created
    ///  </history>
    /// -----------------------------------------------------------------------------
    public class MatchmakingAddModifyReturnValueDialog : Dialog, IMatchmakingAddModifyReturnValueDialogControls
    {


#region "Strings"
        public class Strings
        {
            public const string DialogTitle = "xlastui.dll:5:16245:0";  // Add/Modify Return Value
            public const string OK = ";OK;Win32DialogItemString;xlastui.dll;16245;1";  // OK
            public const string Cancel = ";Cancel;Win32DialogItemString;xlastui.dll;16245;2";  // Cancel
			public const string AttributePropertyPostString = " (P)";
			public const string AttributeContextPostString = " (C)";
		}

#endregion

#region "Control IDs"
        public class ControlIDs
        {
            public const int AttributeNameComboBox = 0x4420;
            public const int OKButton = 0x1;
            public const int CancelButton = 0x2;
            public const int ReturnTypeComboBox = 0x4421;
        }

#endregion

#region "Member Variables"
        private ComboBox m_cachedAttributeNameComboBox;
        private Button m_cachedOKButton;
        private Button m_cachedCancelButton;
        private ComboBox m_cachedReturnTypeComboBox;

        private const int Timeout = 3000;

#endregion

#region "Constructor and Init function"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  TODO: Add a description for your constructor.
        ///  </summary>
        //  <param name="app">XenonandLiveAuthoringSubmissionToolApp object owning the dialog.</param>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public MatchmakingAddModifyReturnValueDialog(XenonandLiveAuthoringSubmissionToolApp app) : 
                base(app, Init(app))
        {
            // TODO: Add Constructor logic here. 
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  This function will attempt to find a showing instance of the dialog.
        ///  </summary>
        ///  <returns>The dialog's Window</returns>
        ///  <param name="app">XenonandLiveAuthoringSubmissionToolApp owning the dialog.</param>)
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        private static Window Init(XenonandLiveAuthoringSubmissionToolApp app)
        {
            // First check if the dialog is already up.
            Window tempWindow = null;
            try
            {
                tempWindow = new Window(app.GetIntlStr(Strings.DialogTitle), StringMatchSyntax.ExactMatch, WindowClassNames.Alert, StringMatchSyntax.ExactMatch, app.MainWindow, Timeout);
            }
            catch (Exceptions.WindowNotFoundException ex)
            {
                // TODO:  Uncomment the following code and apply the appropriate command for invoking the dialog.
                // 
                // app.DTE.ExecuteCmd(Commands.COMMAND_NAME_HERE);
                // 
                // tempWindow = new Window(Strings.DialogTitle, Utilities.StringMatchSyntax.ExactMatch, strDialogClass, Utilities.StringMatchSyntax.ExactMatch, app.MainWindow, timeOut);
                // if (tempWindow != null)
                // 	return tempWindow;
                // 
                // throw new Window.Exceptions.WindowNotFoundException("Init function could not find or bring up the dialog with a title of " + Strings.DialogTitle + ".");
                // 
            }
            return tempWindow;
        }

#endregion

#region "Properties"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the raw controls for this dialog
        ///  </summary>
        ///  <value>An interface that groups all of the dialog's control properties together</value>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual IMatchmakingAddModifyReturnValueDialogControls Controls
        {
            get
            {
                return this;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control AttributeName
        ///  </summary>
        ///  <value>TODO: specify the value</value>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual string AttributeNameText
        {
            get
            {
                return Controls.AttributeNameComboBox.Text;
            }
            set
            {
                Controls.AttributeNameComboBox.SelectByText(value, true);
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control ReturnType
        ///  </summary>
        ///  <value>TODO: specify the value</value>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual string ReturnTypeText
        {
            get
            {
                return Controls.ReturnTypeComboBox.Text;
            }
            set
            {
                Controls.ReturnTypeComboBox.SelectByText(value, true);
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the AttributeNameComboBox control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        ComboBox IMatchmakingAddModifyReturnValueDialogControls.AttributeNameComboBox
        {
            get
            {
                if ((m_cachedAttributeNameComboBox == null))
                {
                    m_cachedAttributeNameComboBox = new ComboBox(this, ControlIDs.AttributeNameComboBox);
                }
                return m_cachedAttributeNameComboBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the OKButton control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IMatchmakingAddModifyReturnValueDialogControls.OKButton
        {
            get
            {
                if ((m_cachedOKButton == null))
                {
                    m_cachedOKButton = new Button(this, ControlIDs.OKButton);
                }
                return m_cachedOKButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the CancelButton control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IMatchmakingAddModifyReturnValueDialogControls.CancelButton
        {
            get
            {
                if ((m_cachedCancelButton == null))
                {
                    m_cachedCancelButton = new Button(this, ControlIDs.CancelButton);
                }
                return m_cachedCancelButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the ReturnTypeComboBox control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        ComboBox IMatchmakingAddModifyReturnValueDialogControls.ReturnTypeComboBox
        {
            get
            {
                if ((m_cachedReturnTypeComboBox == null))
                {
                    m_cachedReturnTypeComboBox = new ComboBox(this, ControlIDs.ReturnTypeComboBox);
                }
                return m_cachedReturnTypeComboBox;
            }
        }

#endregion

#region "Methods"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button OK
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickOK()
        {
            Controls.OKButton.Click();
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button Cancel
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickCancel()
        {
            Controls.CancelButton.Click();
        }

#endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XLASTAuto\Dialogs\NewGameConfigurationProjectWizardDialog.cs ===
namespace ServerTestFramework.xlast.XLASTAuto.Dialogs
{


    using Maui.Core;
    using Maui.Core.WinControls;
    using Maui.Core.Utilities;
    using System.ComponentModel;


#region "INewGameConfigurationProjectWizardDialogControls interface definition"
    
    
    [EditorBrowsable(EditorBrowsableState.Never)]
    public interface INewGameConfigurationProjectWizardDialogControls
    {
        TextBox GameConfigurationProjectNameTextBox  {get;}
        TextBox ProjectDirectoryTextBox  {get;}
        Button ProjectDirectoryBrowseButton  {get;}
        TextBox TitleIDOfGameTextBox  {get;}
        TextBox NameOfGameTextBox  {get;}
        ComboBox DefaultLocaleComboBox  {get;}
        TabControl Tab1TabControl  {get;}
        Spinner UnknownSpinner  {get;}
        Button BackButton  {get;}
        Button NextButton  {get;}
		Button FinishButton  {get;}
		Button CancelButton  {get;}
        Button HelpButton  {get;}
		StaticControl ErrorStringStaticControl  {get;}
	}

#endregion

    /// -----------------------------------------------------------------------------
    /// Project		: Maui
    /// Class		: NewGameConfigurationProjectWizardDialog
    ///  Copyright (C) 2002, Microsoft Corporation
    /// -----------------------------------------------------------------------------
    ///  <summary>
    ///  TODO: Add dialog functionality description here.
    ///  </summary>
    ///  <history>
    /// 	[trevorm] 4/4/2005 Created
    ///  </history>
    /// -----------------------------------------------------------------------------
    public class NewGameConfigurationProjectWizardDialog : Dialog, INewGameConfigurationProjectWizardDialogControls
    {


#region "Strings"
        public class Strings
        {
            public const string DialogTitle = "xlastui.dll:5:16183:0";  // New Game Configuration Project Wizard
            public const string ProjectDirectoryBrowse = "";
            public const string Back = "< &Back";
            public const string Next = "&Next >";
			public const string Finish = "Finish";
			public const string Cancel = ";Cancel;Win32DialogItemString;xlastui.dll;16195;2";  // Cancel
            public const string Help = "Help";
        }

#endregion

#region "Control IDs"
        public class ControlIDs
        {
            public const int GameConfigurationProjectNameTextBox = 0x3F48;
            public const int ProjectDirectoryTextBox = 0x3F49;
            public const int ProjectDirectoryBrowseButton = 0x3F4A;
            public const int TitleIDOfGameTextBox = 0x3F4B;
            public const int NameOfGameTextBox = 0x3F4C;
            public const int DefaultLocaleComboBox = 0x3F4D;
            public const int Tab1TabControl = 0x3020;
            public const int UnknownSpinner = 0x1;
            public const int BackButton = 0x3023;
            public const int NextButton = 0x3024;
			public const int FinishButton = 0x3025;
			public const int CancelButton = 0x2;
            public const int HelpButton = 0x9;
			public const int ErrorStringStaticControl = 0x3F5D;
		}

#endregion

#region "Member Variables"
        private TextBox m_cachedGameConfigurationProjectNameTextBox;
        private TextBox m_cachedProjectDirectoryTextBox;
        private Button m_cachedProjectDirectoryBrowseButton;
        private TextBox m_cachedTitleIDOfGameTextBox;
        private TextBox m_cachedNameOfGameTextBox;
        private ComboBox m_cachedDefaultLocaleComboBox;
        private TabControl m_cachedTab1TabControl;
        private Spinner m_cachedUnknownSpinner;
        private Button m_cachedBackButton;
        private Button m_cachedNextButton;
		private Button m_cachedFinishButton;
		private Button m_cachedCancelButton;
        private Button m_cachedHelpButton;
		private StaticControl m_cachedErrorStringStaticControl;

        private const int Timeout = 3000;

#endregion

#region "Constructor and Init function"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  TODO: Add a description for your constructor.
        ///  </summary>
        //  <param name="app">XenonandLiveAuthoringSubmissionToolApp object owning the dialog.</param>
        ///  <history>
        /// 	[trevorm] 4/4/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public NewGameConfigurationProjectWizardDialog(XenonandLiveAuthoringSubmissionToolApp app) : 
                base(app, Init(app))
        {
            // TODO: Add Constructor logic here. 
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  This function will attempt to find a showing instance of the dialog.
        ///  </summary>
        ///  <returns>The dialog's Window</returns>
        ///  <param name="app">XenonandLiveAuthoringSubmissionToolApp owning the dialog.</param>)
        ///  <history>
        /// 	[trevorm] 4/4/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        private static Window Init(XenonandLiveAuthoringSubmissionToolApp app)
        {
            // First check if the dialog is already up.
            Window tempWindow = null;
            try
            {
				tempWindow = new Window(app.GetIntlStr(Strings.DialogTitle), StringMatchSyntax.ExactMatch);
				//tempWindow = new Window(app.GetIntlStr(Strings.DialogTitle), StringMatchSyntax.ExactMatch, WindowClassNames.Alert, StringMatchSyntax.ExactMatch, app.MainWindow, Timeout);
            }
            catch (Exceptions.WindowNotFoundException ex)
            {
                // TODO:  Uncomment the following code and apply the appropriate command for invoking the dialog.
                // 
                // app.DTE.ExecuteCmd(Commands.COMMAND_NAME_HERE);
                // 
                // tempWindow = new Window(Strings.DialogTitle, Utilities.StringMatchSyntax.ExactMatch, strDialogClass, Utilities.StringMatchSyntax.ExactMatch, app.MainWindow, timeOut);
                // if (tempWindow != null)
                // 	return tempWindow;
                // 
                // throw new Window.Exceptions.WindowNotFoundException("Init function could not find or bring up the dialog with a title of " + Strings.DialogTitle + ".");
                // 
            }
            return tempWindow;
        }

#endregion

#region "Properties"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the raw controls for this dialog
        ///  </summary>
        ///  <value>An interface that groups all of the dialog's control properties together</value>
        ///  <history>
        /// 	[trevorm] 4/4/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual INewGameConfigurationProjectWizardDialogControls Controls
        {
            get
            {
                return this;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control GameConfigurationProjectName
        ///  </summary>
        ///  <value>TODO: specify the value</value>
        ///  <history>
        /// 	[trevorm] 4/4/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual string GameConfigurationProjectNameText
        {
            get
            {
                return Controls.GameConfigurationProjectNameTextBox.Text;
            }
            set
            {
                Controls.GameConfigurationProjectNameTextBox.Text = value;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control ProjectDirectory
        ///  </summary>
        ///  <value>TODO: specify the value</value>
        ///  <history>
        /// 	[trevorm] 4/4/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual string ProjectDirectoryText
        {
            get
            {
                return Controls.ProjectDirectoryTextBox.Text;
            }
            set
            {
                Controls.ProjectDirectoryTextBox.Text = value;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control TitleIDOfGame
        ///  </summary>
        ///  <value>TODO: specify the value</value>
        ///  <history>
        /// 	[trevorm] 4/4/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual string TitleIDOfGameText
        {
            get
            {
                return Controls.TitleIDOfGameTextBox.Text;
            }
            set
            {
                Controls.TitleIDOfGameTextBox.Text = value;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control NameOfGame
        ///  </summary>
        ///  <value>TODO: specify the value</value>
        ///  <history>
        /// 	[trevorm] 4/4/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual string NameOfGameText
        {
            get
            {
                return Controls.NameOfGameTextBox.Text;
            }
            set
            {
                Controls.NameOfGameTextBox.Text = value;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control DefaultLocale
        ///  </summary>
        ///  <value>TODO: specify the value</value>
        ///  <history>
        /// 	[trevorm] 4/4/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual string DefaultLocaleText
        {
            get
            {
                return Controls.DefaultLocaleComboBox.Text;
            }
            set
            {
                Controls.DefaultLocaleComboBox.SelectByText(value, true);
            }
        }

		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Routine toget the text in control ErrorString
		///  </summary>
		///  <value>TODO: specify the value</value>
		///  <history>
		/// 	[trevorm] 4/4/2005 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public virtual string ErrorStringText
		{
			get
			{
				return Controls.ErrorStringStaticControl.Text;
			}
		}


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the GameConfigurationProjectNameTextBox control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/4/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        TextBox INewGameConfigurationProjectWizardDialogControls.GameConfigurationProjectNameTextBox
        {
            get
            {
                if ((m_cachedGameConfigurationProjectNameTextBox == null))
                {
                    m_cachedGameConfigurationProjectNameTextBox = new TextBox(this, ControlIDs.GameConfigurationProjectNameTextBox);
                }
                return m_cachedGameConfigurationProjectNameTextBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the ProjectDirectoryTextBox control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/4/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        TextBox INewGameConfigurationProjectWizardDialogControls.ProjectDirectoryTextBox
        {
            get
            {
                if ((m_cachedProjectDirectoryTextBox == null))
                {
                    m_cachedProjectDirectoryTextBox = new TextBox(this, ControlIDs.ProjectDirectoryTextBox);
                }
                return m_cachedProjectDirectoryTextBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the ProjectDirectoryBrowseButton control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/4/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button INewGameConfigurationProjectWizardDialogControls.ProjectDirectoryBrowseButton
        {
            get
            {
                if ((m_cachedProjectDirectoryBrowseButton == null))
                {
                    m_cachedProjectDirectoryBrowseButton = new Button(this, ControlIDs.ProjectDirectoryBrowseButton);
                }
                return m_cachedProjectDirectoryBrowseButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the TitleIDOfGameTextBox control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/4/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        TextBox INewGameConfigurationProjectWizardDialogControls.TitleIDOfGameTextBox
        {
            get
            {
                if ((m_cachedTitleIDOfGameTextBox == null))
                {
                    m_cachedTitleIDOfGameTextBox = new TextBox(this, ControlIDs.TitleIDOfGameTextBox);
                }
                return m_cachedTitleIDOfGameTextBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the NameOfGameTextBox control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/4/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        TextBox INewGameConfigurationProjectWizardDialogControls.NameOfGameTextBox
        {
            get
            {
                if ((m_cachedNameOfGameTextBox == null))
                {
                    m_cachedNameOfGameTextBox = new TextBox(this, ControlIDs.NameOfGameTextBox);
                }
                return m_cachedNameOfGameTextBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the DefaultLocaleComboBox control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/4/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        ComboBox INewGameConfigurationProjectWizardDialogControls.DefaultLocaleComboBox
        {
            get
            {
                if ((m_cachedDefaultLocaleComboBox == null))
                {
                    m_cachedDefaultLocaleComboBox = new ComboBox(this, ControlIDs.DefaultLocaleComboBox);
                }
                return m_cachedDefaultLocaleComboBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the Tab1TabControl control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/4/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        TabControl INewGameConfigurationProjectWizardDialogControls.Tab1TabControl
        {
            get
            {
                if ((m_cachedTab1TabControl == null))
                {
                    m_cachedTab1TabControl = new TabControl(this, ControlIDs.Tab1TabControl);
                }
                return m_cachedTab1TabControl;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the UnknownSpinner control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/4/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Spinner INewGameConfigurationProjectWizardDialogControls.UnknownSpinner
        {
            get
            {
                if ((m_cachedUnknownSpinner == null))
                {
                    m_cachedUnknownSpinner = new Spinner(this, ControlIDs.UnknownSpinner);
                }
                return m_cachedUnknownSpinner;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the BackButton control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/4/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button INewGameConfigurationProjectWizardDialogControls.BackButton
        {
            get
            {
                if ((m_cachedBackButton == null))
                {
                    m_cachedBackButton = new Button(this, ControlIDs.BackButton);
                }
                return m_cachedBackButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the NextButton control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/4/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button INewGameConfigurationProjectWizardDialogControls.NextButton
        {
            get
            {
                if ((m_cachedNextButton == null))
                {
                    m_cachedNextButton = new Button(this, ControlIDs.NextButton);
                }
                return m_cachedNextButton;
            }
        }

		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Exposes access to the FinishButton control
		///  </summary>
		///  <history>
		/// 	[trevorm] 4/5/2005 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		Button INewGameConfigurationProjectWizardDialogControls.FinishButton
		{
			get
			{
				if ((m_cachedFinishButton == null))
				{
					m_cachedFinishButton = new Button(this, ControlIDs.FinishButton);
				}
				return m_cachedFinishButton;
			}
		}

		/// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the CancelButton control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/4/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button INewGameConfigurationProjectWizardDialogControls.CancelButton
        {
            get
            {
                if ((m_cachedCancelButton == null))
                {
                    m_cachedCancelButton = new Button(this, ControlIDs.CancelButton);
                }
                return m_cachedCancelButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the HelpButton control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/4/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button INewGameConfigurationProjectWizardDialogControls.HelpButton
        {
            get
            {
                if ((m_cachedHelpButton == null))
                {
                    m_cachedHelpButton = new Button(this, ControlIDs.HelpButton);
                }
                return m_cachedHelpButton;
            }
        }

		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Exposes access to the ErrorStringStaticControl control
		///  </summary>
		///  <history>
		/// 	[trevorm] 4/5/2005 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		StaticControl INewGameConfigurationProjectWizardDialogControls.ErrorStringStaticControl
		{
			get
			{
				if ((m_cachedErrorStringStaticControl == null))
				{
					m_cachedErrorStringStaticControl = new StaticControl(this, ControlIDs.ErrorStringStaticControl);
				}
				return m_cachedErrorStringStaticControl;
			}
		}

		#endregion

#region "Methods"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button ProjectDirectoryBrowse
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/4/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickProjectDirectoryBrowse()
        {
            Controls.ProjectDirectoryBrowseButton.Click();
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button Back
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/4/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickBack()
        {
            Controls.BackButton.Click();
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button Next
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/4/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickNext()
        {
            Controls.NextButton.Click();
        }

		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Routine to click on button Finish
		///  </summary>
		///  <history>
		/// 	[trevorm] 4/5/2005 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public virtual void ClickFinish()
		{
			Controls.FinishButton.Click();
		}

		/// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button Cancel
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/4/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickCancel()
        {
            Controls.CancelButton.Click();
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button Help
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/4/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickHelp()
        {
            Controls.HelpButton.Click();
        }

#endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XLASTAuto\ErrorDialogs\DuplicateParameterDialog.cs ===
namespace ServerTestFramework.xlast.XLASTAuto.ErrorDialogs
{


    using Maui.Core;
    using Maui.Core.WinControls;
    using Maui.Core.Utilities;
    using System.ComponentModel;


#region "IDuplicateParameterDialogControls interface definition"
    
    
    [EditorBrowsable(EditorBrowsableState.Never)]
    public interface IDuplicateParameterDialogControls
    {
        Button OKButton  {get;}
    }

#endregion

    /// -----------------------------------------------------------------------------
    /// Project		: Maui
    /// Class		: DuplicateParameterDialog
    ///  Copyright (C) 2002, Microsoft Corporation
    /// -----------------------------------------------------------------------------
    ///  <summary>
    ///  TODO: Add dialog functionality description here.
    ///  </summary>
    ///  <history>
    /// 	[trevorm] 4/5/2005 Created
    ///  </history>
    /// -----------------------------------------------------------------------------
    public class DuplicateParameterDialog : Dialog, IDuplicateParameterDialogControls
    {


#region "Strings"
        public class Strings
        {
			public const string DialogTitle = ";Duplicate Parameter;Win32String;xlastui.dll;17365";
            public const string OK = ";OK;Win32DialogItemString;xlastui.dll;16195;1";  // OK
        }

#endregion

#region "Control IDs"
        public class ControlIDs
        {
            public const int OKButton = 0x2;
        }

#endregion

#region "Member Variables"
        private Button m_cachedOKButton;

        private const int Timeout = 3000;

#endregion

#region "Constructor and Init function"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  TODO: Add a description for your constructor.
        ///  </summary>
        //  <param name="app">XenonandLiveAuthoringSubmissionToolApp object owning the dialog.</param>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public DuplicateParameterDialog(XenonandLiveAuthoringSubmissionToolApp app) : 
                base(app, Init(app))
        {
            // TODO: Add Constructor logic here. 
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  This function will attempt to find a showing instance of the dialog.
        ///  </summary>
        ///  <returns>The dialog's Window</returns>
        ///  <param name="app">XenonandLiveAuthoringSubmissionToolApp owning the dialog.</param>)
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        private static Window Init(XenonandLiveAuthoringSubmissionToolApp app)
        {
            // First check if the dialog is already up.
            Window tempWindow = null;
            try
            {
                tempWindow = new Window(app.GetIntlStr(Strings.DialogTitle), StringMatchSyntax.ExactMatch, WindowClassNames.Alert, StringMatchSyntax.ExactMatch, app.MainWindow, Timeout);
            }
            catch (Exceptions.WindowNotFoundException ex)
            {
                // TODO:  Uncomment the following code and apply the appropriate command for invoking the dialog.
                // 
                // app.DTE.ExecuteCmd(Commands.COMMAND_NAME_HERE);
                // 
                // tempWindow = new Window(Strings.DialogTitle, Utilities.StringMatchSyntax.ExactMatch, strDialogClass, Utilities.StringMatchSyntax.ExactMatch, app.MainWindow, timeOut);
                // if (tempWindow != null)
                // 	return tempWindow;
                // 
                // throw new Window.Exceptions.WindowNotFoundException("Init function could not find or bring up the dialog with a title of " + Strings.DialogTitle + ".");
                // 
            }
            return tempWindow;
        }

#endregion

#region "Properties"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the raw controls for this dialog
        ///  </summary>
        ///  <value>An interface that groups all of the dialog's control properties together</value>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual IDuplicateParameterDialogControls Controls
        {
            get
            {
                return this;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the OKButton control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IDuplicateParameterDialogControls.OKButton
        {
            get
            {
                if ((m_cachedOKButton == null))
                {
                    m_cachedOKButton = new Button(this, ControlIDs.OKButton);
                }
                return m_cachedOKButton;
            }
        }

#endregion

#region "Methods"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button OK
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickOK()
        {
            Controls.OKButton.Click();
        }

#endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XLASTAuto\ErrorDialogs\InvalidNameDialog.cs ===
namespace ServerTestFramework.xlast.XLASTAuto.ErrorDialogs
{


    using Maui.Core;
    using Maui.Core.WinControls;
    using Maui.Core.Utilities;
    using System.ComponentModel;


#region "IInvalidNameDialogControls interface definition"
    
    
    [EditorBrowsable(EditorBrowsableState.Never)]
    public interface IInvalidNameDialogControls
    {
        Button OKButton  {get;}
    }

#endregion

    /// -----------------------------------------------------------------------------
    /// Project		: Maui
    /// Class		: InvalidNameDialog
    ///  Copyright (C) 2002, Microsoft Corporation
    /// -----------------------------------------------------------------------------
    ///  <summary>
    ///  TODO: Add dialog functionality description here.
    ///  </summary>
    ///  <history>
    /// 	[trevorm] 4/5/2005 Created
    ///  </history>
    /// -----------------------------------------------------------------------------
    public class InvalidNameDialog : Dialog, IInvalidNameDialogControls
    {


#region "Strings"
        public class Strings
        {
			public const string DialogTitle = ";Invalid Name;Win32String;xlastui.dll;16801";
            public const string OK = ";OK;Win32DialogItemString;xlastui.dll;16195;1";  // OK
        }

#endregion

#region "Control IDs"
        public class ControlIDs
        {
            public const int OKButton = 0x2;
        }

#endregion

#region "Member Variables"
        private Button m_cachedOKButton;

        private const int Timeout = 3000;

#endregion

#region "Constructor and Init function"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  TODO: Add a description for your constructor.
        ///  </summary>
        //  <param name="app">XenonandLiveAuthoringSubmissionToolApp object owning the dialog.</param>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public InvalidNameDialog(XenonandLiveAuthoringSubmissionToolApp app) : 
                base(app, Init(app))
        {
            // TODO: Add Constructor logic here. 
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  This function will attempt to find a showing instance of the dialog.
        ///  </summary>
        ///  <returns>The dialog's Window</returns>
        ///  <param name="app">XenonandLiveAuthoringSubmissionToolApp owning the dialog.</param>)
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        private static Window Init(XenonandLiveAuthoringSubmissionToolApp app)
        {
            // First check if the dialog is already up.
            Window tempWindow = null;
            try
            {
                tempWindow = new Window(app.GetIntlStr(Strings.DialogTitle), StringMatchSyntax.ExactMatch, WindowClassNames.Alert, StringMatchSyntax.ExactMatch, app.MainWindow, Timeout);
            }
            catch (Exceptions.WindowNotFoundException ex)
            {
                // TODO:  Uncomment the following code and apply the appropriate command for invoking the dialog.
                // 
                // app.DTE.ExecuteCmd(Commands.COMMAND_NAME_HERE);
                // 
                // tempWindow = new Window(Strings.DialogTitle, Utilities.StringMatchSyntax.ExactMatch, strDialogClass, Utilities.StringMatchSyntax.ExactMatch, app.MainWindow, timeOut);
                // if (tempWindow != null)
                // 	return tempWindow;
                // 
                // throw new Window.Exceptions.WindowNotFoundException("Init function could not find or bring up the dialog with a title of " + Strings.DialogTitle + ".");
                // 
            }
            return tempWindow;
        }

#endregion

#region "Properties"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the raw controls for this dialog
        ///  </summary>
        ///  <value>An interface that groups all of the dialog's control properties together</value>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual IInvalidNameDialogControls Controls
        {
            get
            {
                return this;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the OKButton control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IInvalidNameDialogControls.OKButton
        {
            get
            {
                if ((m_cachedOKButton == null))
                {
                    m_cachedOKButton = new Button(this, ControlIDs.OKButton);
                }
                return m_cachedOKButton;
            }
        }

#endregion

#region "Methods"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button OK
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickOK()
        {
            Controls.OKButton.Click();
        }

#endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XLASTAuto\Windows\ContextWindow.cs ===
namespace ServerTestFramework.xlast.XLASTAuto.Windows
{


    using Maui.Core;
    using Maui.Core.WinControls;
    using Maui.Core.Utilities;
    using System.ComponentModel;


#region "IContextWindowControls interface definition"
    
    
    [EditorBrowsable(EditorBrowsableState.Never)]
    public interface IContextWindowControls
    {
        ComboBox DisplayStringFriendlyNameComboBox  {get;}
        ListView ContextValuesListView  {get;}
        Button AddButton  {get;}
        Button EditButton  {get;}
        Button DeleteButton  {get;}
    }

#endregion

    /// -----------------------------------------------------------------------------
    /// Project		: Maui
    /// Class		: ContextWindow
    ///  Copyright (C) 2002, Microsoft Corporation
    /// -----------------------------------------------------------------------------
    ///  <summary>
    ///  TODO: Add window functionality description here.
    ///  </summary>
    ///  <history>
    /// 	[trevorm] 4/5/2005 Created
    ///  </history>
    /// -----------------------------------------------------------------------------
    public class ContextWindow : Window, IContextWindowControls
    {


#region "Strings"
        // TODO: Remove unused definitions.
        public class Strings
        {
            public const string WindowTitle = ";;Win32DialogItemString;xlastui.dll;16250;17470";  //

            public const string Add = ";&Add...;Win32DialogItemString;xlastui.dll;16189;16504";  // &Add...

            public const string Edit = ";&Edit...;Win32DialogItemString;xlastui.dll;16189;16505";  // &Edit...

            public const string Delete = ";&Delete;Win32DialogItemString;xlastui.dll;16239;17393";  // &Delete
        }

#endregion

#region "Control IDs"
        public class ControlIDs
        {
            public const int DisplayStringFriendlyNameComboBox = 0x4076;
            public const int ContextValuesListView = 0x4074;
            public const int AddButton = 0x4078;
            public const int EditButton = 0x4079;
            public const int DeleteButton = 0x407A;
        }

#endregion

#region "Member Variables"
        private ComboBox m_cachedDisplayStringFriendlyNameComboBox;
        private ListView m_cachedContextValuesListView;
        private Button m_cachedAddButton;
        private Button m_cachedEditButton;
        private Button m_cachedDeleteButton;

        private const int Timeout = 3000;
        protected internal static Window ActiveWindow;

#endregion

#region "Constructor and Init function"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  TODO: Add a description for your constructor.
        ///  </summary>
        //  <param name="app">Window object owning the window.</param>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public ContextWindow(Window ownerWindow, XenonandLiveAuthoringSubmissionToolApp app) : 
                base(Init(ownerWindow, app))
        {
            // TODO: Add Constructor logic here. 
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  This function will attempt to find the window.
        ///  </summary>
        ///  <returns>The window to find</returns>
        ///  <param name="ownerWindow">Window owning the window.</param>)
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        private static System.IntPtr Init(Window ownerWindow, XenonandLiveAuthoringSubmissionToolApp app)
        {
            // First check if the window is already up.
            Window tempWindow = null;
            try
            {
                tempWindow = new Window(app.GetIntlStr(Strings.WindowTitle), StringMatchSyntax.ExactMatch, WindowClassNames.Alert, StringMatchSyntax.ExactMatch, ownerWindow, Timeout);
            }
            catch (Exceptions.WindowNotFoundException ex)
            {
                // TODO:  Uncomment the following code and apply the appropriate command for invoking the window.
                // 
                // throw new Window.Exceptions.WindowNotFoundException("Init function could not find or bring up the window with a title of " + Strings.DialogTitle + ".");
                // 
            }
            return tempWindow.Extended.HWnd;
        }

#endregion

#region "Properties"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the raw controls for this window
        ///  </summary>
        ///  <value>An interface that groups all of the window's control properties together</value>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual IContextWindowControls Controls
        {
            get
            {
                return this;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control DisplayStringFriendlyName
        ///  </summary>
        ///  <value>TODO: specify the value</value>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual string DisplayStringFriendlyNameText
        {
            get
            {
                return Controls.DisplayStringFriendlyNameComboBox.Text;
            }
            set
            {
                Controls.DisplayStringFriendlyNameComboBox.SelectByText(value, true);
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the DisplayStringFriendlyNameComboBox control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        ComboBox IContextWindowControls.DisplayStringFriendlyNameComboBox
        {
            get
            {
                if ((m_cachedDisplayStringFriendlyNameComboBox == null))
                {
                    m_cachedDisplayStringFriendlyNameComboBox = new ComboBox(this, ControlIDs.DisplayStringFriendlyNameComboBox);
                }
                return m_cachedDisplayStringFriendlyNameComboBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the ContextValuesListView control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        ListView IContextWindowControls.ContextValuesListView
        {
            get
            {
                if ((m_cachedContextValuesListView == null))
                {
                    m_cachedContextValuesListView = new ListView(this, ControlIDs.ContextValuesListView);
                }
                return m_cachedContextValuesListView;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the AddButton control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IContextWindowControls.AddButton
        {
            get
            {
                if ((m_cachedAddButton == null))
                {
                    m_cachedAddButton = new Button(this, ControlIDs.AddButton);
                }
                return m_cachedAddButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the EditButton control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IContextWindowControls.EditButton
        {
            get
            {
                if ((m_cachedEditButton == null))
                {
                    m_cachedEditButton = new Button(this, ControlIDs.EditButton);
                }
                return m_cachedEditButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the DeleteButton control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IContextWindowControls.DeleteButton
        {
            get
            {
                if ((m_cachedDeleteButton == null))
                {
                    m_cachedDeleteButton = new Button(this, ControlIDs.DeleteButton);
                }
                return m_cachedDeleteButton;
            }
        }

#endregion

#region "Methods"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button Add
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickAdd()
        {
            Controls.AddButton.Click();
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button Edit
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickEdit()
        {
            Controls.EditButton.Click();
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button Delete
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickDelete()
        {
            Controls.DeleteButton.Click();
        }

#endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XLASTAuto\Windows\GameSettingsWindow.cs ===
namespace ServerTestFramework.xlast.XLASTAuto.Windows
{


    using Maui.Core;
    using Maui.Core.WinControls;
    using Maui.Core.Utilities;
    using System.ComponentModel;


#region "IGameSettingsWindowControls interface definition"
    
    
    [EditorBrowsable(EditorBrowsableState.Never)]
    public interface IGameSettingsWindowControls
    {
        TextBox TitleIDOfGameTextBox  {get;}
        TextBox NameOfGameTextBox  {get;}
    }

#endregion

    /// -----------------------------------------------------------------------------
    /// Project		: Maui
    /// Class		: GameSettingsWindow
    ///  Copyright (C) 2002, Microsoft Corporation
    /// -----------------------------------------------------------------------------
    ///  <summary>
    ///  TODO: Add window functionality description here.
    ///  </summary>
    ///  <history>
    /// 	[trevorm] 4/4/2005 Created
    ///  </history>
    /// -----------------------------------------------------------------------------
    public class GameSettingsWindow : Window, IGameSettingsWindowControls
    {


#region "Strings"
        // TODO: Remove unused definitions.
        public class Strings
        {
            public const string WindowTitle = ";;Win32DialogItemString;xlastui.dll;16250;17470";  //

        }

#endregion

#region "Control IDs"
        public class ControlIDs
        {
            public const int TitleIDOfGameTextBox = 0x3FAC;
            public const int NameOfGameTextBox = 0x3FAD;
        }

#endregion

#region "Member Variables"
        private TextBox m_cachedTitleIDOfGameTextBox;
        private TextBox m_cachedNameOfGameTextBox;

        private const int Timeout = 3000;
        protected internal static Window ActiveWindow;

#endregion

#region "Constructor and Init function"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  TODO: Add a description for your constructor.
        ///  </summary>
        //  <param name="app">Window object owning the window.</param>
        ///  <history>
        /// 	[trevorm] 4/4/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public GameSettingsWindow(Window ownerWindow, XenonandLiveAuthoringSubmissionToolApp app) : 
                base(Init(ownerWindow, app))
        {
            // TODO: Add Constructor logic here. 
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  This function will attempt to find the window.
        ///  </summary>
        ///  <returns>The window to find</returns>
        ///  <param name="ownerWindow">Window owning the window.</param>)
        ///  <history>
        /// 	[trevorm] 4/4/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        private static System.IntPtr Init(Window ownerWindow, XenonandLiveAuthoringSubmissionToolApp app)
        {
            // First check if the window is already up.
            Window tempWindow = null;
            try
            {
                tempWindow = new Window(app.GetIntlStr(Strings.WindowTitle), StringMatchSyntax.ExactMatch, WindowClassNames.Alert, StringMatchSyntax.ExactMatch, ownerWindow, Timeout);
            }
            catch (Exceptions.WindowNotFoundException ex)
            {
                // TODO:  Uncomment the following code and apply the appropriate command for invoking the window.
                // 
                // throw new Window.Exceptions.WindowNotFoundException("Init function could not find or bring up the window with a title of " + Strings.DialogTitle + ".");
                // 
            }
            return tempWindow.Extended.HWnd;
        }

#endregion

#region "Properties"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the raw controls for this window
        ///  </summary>
        ///  <value>An interface that groups all of the window's control properties together</value>
        ///  <history>
        /// 	[trevorm] 4/4/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual IGameSettingsWindowControls Controls
        {
            get
            {
                return this;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control TitleIDOfGame
        ///  </summary>
        ///  <value>TODO: specify the value</value>
        ///  <history>
        /// 	[trevorm] 4/4/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual string TitleIDOfGameText
        {
            get
            {
                return Controls.TitleIDOfGameTextBox.Text;
            }
            set
            {
                Controls.TitleIDOfGameTextBox.Text = value;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control NameOfGame
        ///  </summary>
        ///  <value>TODO: specify the value</value>
        ///  <history>
        /// 	[trevorm] 4/4/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual string NameOfGameText
        {
            get
            {
                return Controls.NameOfGameTextBox.Text;
            }
            set
            {
                Controls.NameOfGameTextBox.Text = value;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the TitleIDOfGameTextBox control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/4/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        TextBox IGameSettingsWindowControls.TitleIDOfGameTextBox
        {
            get
            {
                if ((m_cachedTitleIDOfGameTextBox == null))
                {
                    m_cachedTitleIDOfGameTextBox = new TextBox(this, ControlIDs.TitleIDOfGameTextBox);
                }
                return m_cachedTitleIDOfGameTextBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the NameOfGameTextBox control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/4/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        TextBox IGameSettingsWindowControls.NameOfGameTextBox
        {
            get
            {
                if ((m_cachedNameOfGameTextBox == null))
                {
                    m_cachedNameOfGameTextBox = new TextBox(this, ControlIDs.NameOfGameTextBox);
                }
                return m_cachedNameOfGameTextBox;
            }
        }

#endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XLASTAuto\ErrorDialogs\ItemRequiredDialog.cs ===
namespace ServerTestFramework.xlast.XLASTAuto.ErrorDialogs
{


    using Maui.Core;
    using Maui.Core.WinControls;
    using Maui.Core.Utilities;
    using System.ComponentModel;


#region "IItemRequiredDialogControls interface definition"
    
    
    [EditorBrowsable(EditorBrowsableState.Never)]
    public interface IItemRequiredDialogControls
    {
        Button OKButton  {get;}
    }

#endregion

    /// -----------------------------------------------------------------------------
    /// Project		: Maui
    /// Class		: ItemRequiredDialog
    ///  Copyright (C) 2002, Microsoft Corporation
    /// -----------------------------------------------------------------------------
    ///  <summary>
    ///  TODO: Add dialog functionality description here.
    ///  </summary>
    ///  <history>
    /// 	[trevorm] 4/5/2005 Created
    ///  </history>
    /// -----------------------------------------------------------------------------
    public class ItemRequiredDialog : Dialog, IItemRequiredDialogControls
    {


#region "Strings"
        public class Strings
        {
			public const string DialogTitle = ";Item Required;Win32String;xlastui.dll;17270";
            public const string OK = ";OK;Win32DialogItemString;xlastui.dll;16195;1";  // OK
        }

#endregion

#region "Control IDs"
        public class ControlIDs
        {
            public const int OKButton = 0x2;
        }

#endregion

#region "Member Variables"
        private Button m_cachedOKButton;

        private const int Timeout = 3000;

#endregion

#region "Constructor and Init function"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  TODO: Add a description for your constructor.
        ///  </summary>
        //  <param name="app">Window object owning the dialog.</param>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public ItemRequiredDialog(XenonandLiveAuthoringSubmissionToolApp app) : 
                base(app, Init(app))
        {
            // TODO: Add Constructor logic here. 
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  This function will attempt to find a showing instance of the dialog.
        ///  </summary>
        ///  <returns>The dialog's Window</returns>
        ///  <param name="app">Window owning the dialog.</param>)
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        private static Window Init(XenonandLiveAuthoringSubmissionToolApp app)
        {
            // First check if the dialog is already up.
            Window tempWindow = null;
            try
            {
                tempWindow = new Window(app.GetIntlStr(Strings.DialogTitle), StringMatchSyntax.ExactMatch, WindowClassNames.Alert, StringMatchSyntax.ExactMatch, app.MainWindow, Timeout);
            }
            catch (Exceptions.WindowNotFoundException ex)
            {
                // TODO:  Uncomment the following code and apply the appropriate command for invoking the dialog.
                // 
                // app.DTE.ExecuteCmd(Commands.COMMAND_NAME_HERE);
                // 
                // tempWindow = new Window(Strings.DialogTitle, Utilities.StringMatchSyntax.ExactMatch, strDialogClass, Utilities.StringMatchSyntax.ExactMatch, app.MainWindow, timeOut);
                // if (tempWindow != null)
                // 	return tempWindow;
                // 
                // throw new Window.Exceptions.WindowNotFoundException("Init function could not find or bring up the dialog with a title of " + Strings.DialogTitle + ".");
                // 
            }
            return tempWindow;
        }

#endregion

#region "Properties"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the raw controls for this dialog
        ///  </summary>
        ///  <value>An interface that groups all of the dialog's control properties together</value>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual IItemRequiredDialogControls Controls
        {
            get
            {
                return this;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the OKButton control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IItemRequiredDialogControls.OKButton
        {
            get
            {
                if ((m_cachedOKButton == null))
                {
                    m_cachedOKButton = new Button(this, ControlIDs.OKButton);
                }
                return m_cachedOKButton;
            }
        }

#endregion

#region "Methods"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button OK
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickOK()
        {
            Controls.OKButton.Click();
        }

#endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XLASTAuto\Windows\AchievementsWindow.cs ===
namespace ServerTestFramework.xlast.XLASTAuto.Windows
{


    using Maui.Core;
    using Maui.Core.WinControls;
    using Maui.Core.Utilities;
    using System.ComponentModel;


#region "IAchievementsWindowControls interface definition"
    
    
    [EditorBrowsable(EditorBrowsableState.Never)]
    public interface IAchievementsWindowControls
    {
        ComboBox TotalAvailableCredComboBox  {get;}
        ListView AchievementsListView  {get;}
        StaticControl CredRemainingStaticControl  {get;}
        Button NewAchievementButton  {get;}
    }

#endregion

    /// -----------------------------------------------------------------------------
    /// Project		: Maui
    /// Class		: AchievementsWindow
    ///  Copyright (C) 2002, Microsoft Corporation
    /// -----------------------------------------------------------------------------
    ///  <summary>
    ///  TODO: Add window functionality description here.
    ///  </summary>
    ///  <history>
    /// 	[trevorm] 4/5/2005 Created
    ///  </history>
    /// -----------------------------------------------------------------------------
    public class AchievementsWindow : Window, IAchievementsWindowControls
    {


#region "Strings"
        public class Strings
        {
            public const string WindowTitle = ";;Win32DialogItemString;xlastui.dll;16250;17470";  //
            public const string CredRemaining1000 = "Cred Remaining:  1000";
			public const string CredRemaining0 = "Cred Remaining:  0";
			public const string CredRemaining = "Cred Remaining";
			public const string NewAchievement = ";&New Achievement...;Win32DialogItemString;xlastui.dll;16186;16351";  // &New Achievement...

        }

#endregion

#region "Control IDs"
        public class ControlIDs
        {
            public const int TotalAvailableCredComboBox = 0x3FE0;
            public const int AchievementsListView = 0x3FDE;
            public const int CredRemainingStaticControl = 0x3FE1;
            public const int NewAchievementButton = 0x3FDF;
        }

#endregion

#region "Member Variables"
        private ComboBox m_cachedTotalAvailableCredComboBox;
        private ListView m_cachedAchievementsListView;
        private StaticControl m_cachedCredRemainingStaticControl;
        private Button m_cachedNewAchievementButton;

        private const int Timeout = 3000;
        protected internal static Window ActiveWindow;

#endregion

#region "Constructor and Init function"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  TODO: Add a description for your constructor.
        ///  </summary>
        //  <param name="app">Window object owning the window.</param>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public AchievementsWindow(Window ownerWindow, XenonandLiveAuthoringSubmissionToolApp app) : 
                base(Init(ownerWindow, app))
        {
            // TODO: Add Constructor logic here. 
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  This function will attempt to find the window.
        ///  </summary>
        ///  <returns>The window to find</returns>
        ///  <param name="ownerWindow">Window owning the window.</param>)
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        private static System.IntPtr Init(Window ownerWindow, XenonandLiveAuthoringSubmissionToolApp app)
        {
            // First check if the window is already up.
            Window tempWindow = null;
            try
            {
                tempWindow = new Window(app.GetIntlStr(Strings.WindowTitle), StringMatchSyntax.ExactMatch, WindowClassNames.Alert, StringMatchSyntax.ExactMatch, ownerWindow, Timeout);
            }
            catch (Exceptions.WindowNotFoundException ex)
            {
                // TODO:  Uncomment the following code and apply the appropriate command for invoking the window.
                // 
                // throw new Window.Exceptions.WindowNotFoundException("Init function could not find or bring up the window with a title of " + Strings.DialogTitle + ".");
                // 
            }
            return tempWindow.Extended.HWnd;
        }

#endregion

#region "Properties"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the raw controls for this window
        ///  </summary>
        ///  <value>An interface that groups all of the window's control properties together</value>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual IAchievementsWindowControls Controls
        {
            get
            {
                return this;
            }
        }


		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Routine to set/get the text in control TotalAvailableCredComboBox
		///  </summary>
		///  <value>TODO: specify the value</value>
		///  <history>
		/// 	[trevorm] 4/5/2005 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public virtual string TotalAvailableCredComboBoxText
		{
			get
			{
				return Controls.TotalAvailableCredComboBox.Text;
			}
			set
			{
				Controls.TotalAvailableCredComboBox.SelectByText(value, true);
			}
		}


		/// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the TotalAvailableCredComboBox control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        ComboBox IAchievementsWindowControls.TotalAvailableCredComboBox
        {
            get
            {
                if ((m_cachedTotalAvailableCredComboBox == null))
                {
                    m_cachedTotalAvailableCredComboBox = new ComboBox(this, ControlIDs.TotalAvailableCredComboBox);
                }
                return m_cachedTotalAvailableCredComboBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the AchievementsListView control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        ListView IAchievementsWindowControls.AchievementsListView
        {
            get
            {
                if ((m_cachedAchievementsListView == null))
                {
                    m_cachedAchievementsListView = new ListView(this, ControlIDs.AchievementsListView);
                }
                return m_cachedAchievementsListView;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the CredRemainingStaticControl control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        StaticControl IAchievementsWindowControls.CredRemainingStaticControl
        {
            get
            {
                if ((m_cachedCredRemainingStaticControl == null))
                {
                    m_cachedCredRemainingStaticControl = new StaticControl(this, ControlIDs.CredRemainingStaticControl);
                }
                return m_cachedCredRemainingStaticControl;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the NewAchievementButton control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IAchievementsWindowControls.NewAchievementButton
        {
            get
            {
                if ((m_cachedNewAchievementButton == null))
                {
                    m_cachedNewAchievementButton = new Button(this, ControlIDs.NewAchievementButton);
                }
                return m_cachedNewAchievementButton;
            }
        }

#endregion

#region "Methods"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button NewAchievement
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickNewAchievement()
        {
            Controls.NewAchievementButton.Click();
        }

#endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XLASTAuto\Windows\AchievementWindow.cs ===
namespace ServerTestFramework.xlast.XLASTAuto.Windows
{


    using Maui.Core;
    using Maui.Core.WinControls;
    using Maui.Core.Utilities;
    using System.ComponentModel;


#region "IAchievementWindowControls interface definition"
    
    
    [EditorBrowsable(EditorBrowsableState.Never)]
    public interface IAchievementWindowControls
    {
        ComboBox AchievementImageComboBox  {get;}
        ComboBox DisplayStringComboBox  {get;}
        ComboBox DescriptionStringComboBox  {get;}
        ComboBox HowToStringComboBox  {get;}
        CheckBox DisplayAchievementBeforeItIsEarnedCheckBox  {get;}
        ComboBox TypeComboBox  {get;}
        TextBox CredValueTextBox  {get;}
        Spinner CredValueSpinner  {get;}
        ComboBox AchievementReplacedComboBox  {get;}
        ComboBox NextAchievementsComboBox  {get;}
        Button NextAchievementsButton  {get;}
    }

#endregion

    /// -----------------------------------------------------------------------------
    /// Project		: Maui
    /// Class		: AchievementWindow
    ///  Copyright (C) 2002, Microsoft Corporation
    /// -----------------------------------------------------------------------------
    ///  <summary>
    ///  TODO: Add window functionality description here.
    ///  </summary>
    ///  <history>
    /// 	[trevorm] 4/5/2005 Created
    ///  </history>
    /// -----------------------------------------------------------------------------
    public class AchievementWindow : Window, IAchievementWindowControls
    {


#region "Strings"
        // TODO: Remove unused definitions.
        public class Strings
        {
            public const string WindowTitle = ";;Win32DialogItemString;xlastui.dll;16250;17470";  //

            public const string DisplayAchievementBeforeItIsEarned = ";Display Achievement before it is earned?;Win32DialogItemString;xlastui.dll;16185;16324";  // Display Achievement before it is earned?

            public const string Ellipsis5 = ";...;Win32DialogItemString;xlastui.dll;16185;16321";  // ...

        }

#endregion

#region "Control IDs"
        public class ControlIDs
        {
            public const int AchievementImageComboBox = 0x3FB6;
            public const int DisplayStringComboBox = 0x3FBA;
            public const int DescriptionStringComboBox = 0x3FBB;
            public const int HowToStringComboBox = 0x3FC3;
            public const int DisplayAchievementBeforeItIsEarnedCheckBox = 0x3FC4;
            public const int TypeComboBox = 0x3FBC;
            public const int CredValueTextBox = 0x3FBD;
            public const int CredValueSpinner = 0x3FC2;
            public const int AchievementReplacedComboBox = 0x3FBE;
            public const int NextAchievementsComboBox = 0x3FBF;
            public const int NextAchievementsButton = 0x3FC1;
        }

#endregion

#region "Member Variables"
        private ComboBox m_cachedAchievementImageComboBox;
        private ComboBox m_cachedDisplayStringComboBox;
        private ComboBox m_cachedDescriptionStringComboBox;
        private ComboBox m_cachedHowToStringComboBox;
        private CheckBox m_cachedDisplayAchievementBeforeItIsEarnedCheckBox;
        private ComboBox m_cachedTypeComboBox;
        private TextBox m_cachedCredValueTextBox;
        private Spinner m_cachedCredValueSpinner;
        private ComboBox m_cachedAchievementReplacedComboBox;
        private ComboBox m_cachedNextAchievementsComboBox;
        private Button m_cachedNextAchievementsButton;

        private const int Timeout = 3000;
        protected internal static Window ActiveWindow;

#endregion

#region "Constructor and Init function"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  TODO: Add a description for your constructor.
        ///  </summary>
        //  <param name="app">Window object owning the window.</param>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public AchievementWindow(Window ownerWindow, XenonandLiveAuthoringSubmissionToolApp app) : 
                base(Init(ownerWindow, app))
        {
            // TODO: Add Constructor logic here. 
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  This function will attempt to find the window.
        ///  </summary>
        ///  <returns>The window to find</returns>
        ///  <param name="ownerWindow">Window owning the window.</param>)
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        private static System.IntPtr Init(Window ownerWindow, XenonandLiveAuthoringSubmissionToolApp app)
        {
            // First check if the window is already up.
            Window tempWindow = null;
            try
            {
                tempWindow = new Window(app.GetIntlStr(Strings.WindowTitle), StringMatchSyntax.ExactMatch, WindowClassNames.Alert, StringMatchSyntax.ExactMatch, ownerWindow, Timeout);
            }
            catch (Exceptions.WindowNotFoundException ex)
            {
                // TODO:  Uncomment the following code and apply the appropriate command for invoking the window.
                // 
                // throw new Window.Exceptions.WindowNotFoundException("Init function could not find or bring up the window with a title of " + Strings.DialogTitle + ".");
                // 
            }
            return tempWindow.Extended.HWnd;
        }

#endregion

#region "Properties"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the raw controls for this window
        ///  </summary>
        ///  <value>An interface that groups all of the window's control properties together</value>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual IAchievementWindowControls Controls
        {
            get
            {
                return this;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Property to handle checkbox DisplayAchievementBeforeItIsEarned
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual bool DisplayAchievementBeforeItIsEarned
        {
            get
            {
                return Controls.DisplayAchievementBeforeItIsEarnedCheckBox.Checked;
            }
            set
            {
                Controls.DisplayAchievementBeforeItIsEarnedCheckBox.Checked = value;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control AchievementImage
        ///  </summary>
        ///  <value>TODO: specify the value</value>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual string AchievementImageText
        {
            get
            {
                return Controls.AchievementImageComboBox.Text;
            }
            set
            {
                Controls.AchievementImageComboBox.SelectByText(value, true);
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control DisplayString
        ///  </summary>
        ///  <value>TODO: specify the value</value>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual string DisplayStringText
        {
            get
            {
                return Controls.DisplayStringComboBox.Text;
            }
            set
            {
                Controls.DisplayStringComboBox.SelectByText(value, true);
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control DescriptionString
        ///  </summary>
        ///  <value>TODO: specify the value</value>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual string DescriptionStringText
        {
            get
            {
                return Controls.DescriptionStringComboBox.Text;
            }
            set
            {
                Controls.DescriptionStringComboBox.SelectByText(value, true);
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control HowToString
        ///  </summary>
        ///  <value>TODO: specify the value</value>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual string HowToStringText
        {
            get
            {
                return Controls.HowToStringComboBox.Text;
            }
            set
            {
                Controls.HowToStringComboBox.SelectByText(value, true);
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control Type
        ///  </summary>
        ///  <value>TODO: specify the value</value>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual string TypeText
        {
            get
            {
                return Controls.TypeComboBox.Text;
            }
            set
            {
                Controls.TypeComboBox.SelectByText(value, true);
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control CredValue
        ///  </summary>
        ///  <value>TODO: specify the value</value>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual string CredValueText
        {
            get
            {
                return Controls.CredValueTextBox.Text;
            }
            set
            {
                Controls.CredValueTextBox.Text = value;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control AchievementReplaced
        ///  </summary>
        ///  <value>TODO: specify the value</value>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual string AchievementReplacedText
        {
            get
            {
                return Controls.AchievementReplacedComboBox.Text;
            }
            set
            {
                Controls.AchievementReplacedComboBox.SelectByText(value, true);
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control NextAchievements
        ///  </summary>
        ///  <value>TODO: specify the value</value>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual string NextAchievementsText
        {
            get
            {
                return Controls.NextAchievementsComboBox.Text;
            }
            set
            {
                Controls.NextAchievementsComboBox.SelectByText(value, true);
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the AchievementImageComboBox control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        ComboBox IAchievementWindowControls.AchievementImageComboBox
        {
            get
            {
                if ((m_cachedAchievementImageComboBox == null))
                {
                    m_cachedAchievementImageComboBox = new ComboBox(this, ControlIDs.AchievementImageComboBox);
                }
                return m_cachedAchievementImageComboBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the DisplayStringComboBox control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        ComboBox IAchievementWindowControls.DisplayStringComboBox
        {
            get
            {
                if ((m_cachedDisplayStringComboBox == null))
                {
                    m_cachedDisplayStringComboBox = new ComboBox(this, ControlIDs.DisplayStringComboBox);
                }
                return m_cachedDisplayStringComboBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the DescriptionStringComboBox control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        ComboBox IAchievementWindowControls.DescriptionStringComboBox
        {
            get
            {
                if ((m_cachedDescriptionStringComboBox == null))
                {
                    m_cachedDescriptionStringComboBox = new ComboBox(this, ControlIDs.DescriptionStringComboBox);
                }
                return m_cachedDescriptionStringComboBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the HowToStringComboBox control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        ComboBox IAchievementWindowControls.HowToStringComboBox
        {
            get
            {
                if ((m_cachedHowToStringComboBox == null))
                {
                    m_cachedHowToStringComboBox = new ComboBox(this, ControlIDs.HowToStringComboBox);
                }
                return m_cachedHowToStringComboBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the DisplayAchievementBeforeItIsEarnedCheckBox control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        CheckBox IAchievementWindowControls.DisplayAchievementBeforeItIsEarnedCheckBox
        {
            get
            {
                if ((m_cachedDisplayAchievementBeforeItIsEarnedCheckBox == null))
                {
                    m_cachedDisplayAchievementBeforeItIsEarnedCheckBox = new CheckBox(this, ControlIDs.DisplayAchievementBeforeItIsEarnedCheckBox);
                }
                return m_cachedDisplayAchievementBeforeItIsEarnedCheckBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the TypeComboBox control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        ComboBox IAchievementWindowControls.TypeComboBox
        {
            get
            {
                if ((m_cachedTypeComboBox == null))
                {
                    m_cachedTypeComboBox = new ComboBox(this, ControlIDs.TypeComboBox);
                }
                return m_cachedTypeComboBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the CredValueTextBox control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        TextBox IAchievementWindowControls.CredValueTextBox
        {
            get
            {
                if ((m_cachedCredValueTextBox == null))
                {
                    m_cachedCredValueTextBox = new TextBox(this, ControlIDs.CredValueTextBox);
                }
                return m_cachedCredValueTextBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the CredValueSpinner control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Spinner IAchievementWindowControls.CredValueSpinner
        {
            get
            {
                if ((m_cachedCredValueSpinner == null))
                {
                    m_cachedCredValueSpinner = new Spinner(this, ControlIDs.CredValueSpinner);
                }
                return m_cachedCredValueSpinner;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the AchievementReplacedComboBox control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        ComboBox IAchievementWindowControls.AchievementReplacedComboBox
        {
            get
            {
                if ((m_cachedAchievementReplacedComboBox == null))
                {
                    m_cachedAchievementReplacedComboBox = new ComboBox(this, ControlIDs.AchievementReplacedComboBox);
                }
                return m_cachedAchievementReplacedComboBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the NextAchievementsComboBox control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        ComboBox IAchievementWindowControls.NextAchievementsComboBox
        {
            get
            {
                if ((m_cachedNextAchievementsComboBox == null))
                {
                    m_cachedNextAchievementsComboBox = new ComboBox(this, ControlIDs.NextAchievementsComboBox);
                }
                return m_cachedNextAchievementsComboBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the NextAchievementsButton control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IAchievementWindowControls.NextAchievementsButton
        {
            get
            {
                if ((m_cachedNextAchievementsButton == null))
                {
                    m_cachedNextAchievementsButton = new Button(this, ControlIDs.NextAchievementsButton);
                }
                return m_cachedNextAchievementsButton;
            }
        }

#endregion

#region "Methods"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button Ellipsis5
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickNextAchievementsButton()
        {
            Controls.NextAchievementsButton.Click();
        }

#endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XLASTAuto\ErrorDialogs\InvalidTitleIDDialog.cs ===
namespace ServerTestFramework.xlast.XLASTAuto.ErrorDialogs
{


    using Maui.Core;
    using Maui.Core.WinControls;
    using Maui.Core.Utilities;
    using System.ComponentModel;


#region "IInvalidTitleIDDialogControls interface definition"
    
    
    [EditorBrowsable(EditorBrowsableState.Never)]
    public interface IInvalidTitleIDDialogControls
    {
        Button OKButton  {get;}
    }

#endregion

    /// -----------------------------------------------------------------------------
    /// Project		: Maui
    /// Class		: InvalidTitleIDDialog
    ///  Copyright (C) 2002, Microsoft Corporation
    /// -----------------------------------------------------------------------------
    ///  <summary>
    ///  TODO: Add dialog functionality description here.
    ///  </summary>
    ///  <history>
    /// 	[trevorm] 4/5/2005 Created
    ///  </history>
    /// -----------------------------------------------------------------------------
    public class InvalidTitleIDDialog : Dialog, IInvalidTitleIDDialogControls
    {


#region "Strings"
        public class Strings
        {
			public const string DialogTitle = ";Invalid Title ID;Win32String;xlastui.dll;16871";
            public const string OK = ";OK;Win32DialogItemString;xlastui.dll;16195;1";  // OK
        }

#endregion

#region "Control IDs"
        public class ControlIDs
        {
            public const int OKButton = 0x2;
        }

#endregion

#region "Member Variables"
        private Button m_cachedOKButton;

        private const int Timeout = 3000;

#endregion

#region "Constructor and Init function"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  TODO: Add a description for your constructor.
        ///  </summary>
        //  <param name="app">XenonandLiveAuthoringSubmissionToolApp object owning the dialog.</param>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public InvalidTitleIDDialog(XenonandLiveAuthoringSubmissionToolApp app) : 
                base(app, Init(app))
        {
            // TODO: Add Constructor logic here. 
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  This function will attempt to find a showing instance of the dialog.
        ///  </summary>
        ///  <returns>The dialog's Window</returns>
        ///  <param name="app">XenonandLiveAuthoringSubmissionToolApp owning the dialog.</param>)
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        private static Window Init(XenonandLiveAuthoringSubmissionToolApp app)
        {
            // First check if the dialog is already up.
            Window tempWindow = null;
            try
            {
                tempWindow = new Window(app.GetIntlStr(Strings.DialogTitle), StringMatchSyntax.ExactMatch, WindowClassNames.Alert, StringMatchSyntax.ExactMatch, app.MainWindow, Timeout);
            }
            catch (Exceptions.WindowNotFoundException ex)
            {
                // TODO:  Uncomment the following code and apply the appropriate command for invoking the dialog.
                // 
                // app.DTE.ExecuteCmd(Commands.COMMAND_NAME_HERE);
                // 
                // tempWindow = new Window(Strings.DialogTitle, Utilities.StringMatchSyntax.ExactMatch, strDialogClass, Utilities.StringMatchSyntax.ExactMatch, app.MainWindow, timeOut);
                // if (tempWindow != null)
                // 	return tempWindow;
                // 
                // throw new Window.Exceptions.WindowNotFoundException("Init function could not find or bring up the dialog with a title of " + Strings.DialogTitle + ".");
                // 
            }
            return tempWindow;
        }

#endregion

#region "Properties"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the raw controls for this dialog
        ///  </summary>
        ///  <value>An interface that groups all of the dialog's control properties together</value>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual IInvalidTitleIDDialogControls Controls
        {
            get
            {
                return this;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the OKButton control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IInvalidTitleIDDialogControls.OKButton
        {
            get
            {
                if ((m_cachedOKButton == null))
                {
                    m_cachedOKButton = new Button(this, ControlIDs.OKButton);
                }
                return m_cachedOKButton;
            }
        }

#endregion

#region "Methods"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button OK
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickOK()
        {
            Controls.OKButton.Click();
        }

#endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XLASTAuto\Windows\ImagesWindow.cs ===
namespace ServerTestFramework.xlast.XLASTAuto.Windows
{


    using Maui.Core;
    using Maui.Core.WinControls;
    using Maui.Core.Utilities;
    using System.ComponentModel;


#region "IImagesWindowControls interface definition"
    
    
    [EditorBrowsable(EditorBrowsableState.Never)]
    public interface IImagesWindowControls
    {
        ListView NameListView  {get;}
    }

#endregion

    /// -----------------------------------------------------------------------------
    /// Project		: Maui
    /// Class		: ImagesWindow
    ///  Copyright (C) 2002, Microsoft Corporation
    /// -----------------------------------------------------------------------------
    ///  <summary>
    ///  TODO: Add window functionality description here.
    ///  </summary>
    ///  <history>
    /// 	[trevorm] 4/5/2005 Created
    ///  </history>
    /// -----------------------------------------------------------------------------
    public class ImagesWindow : Window, IImagesWindowControls
    {


#region "Strings"
        // TODO: Remove unused definitions.
        public class Strings
        {
            public const string WindowTitle = ";;Win32DialogItemString;xlastui.dll;16250;17470";  //

        }

#endregion

#region "Control IDs"
        public class ControlIDs
        {
            public const int NameListView = 0x443E;
        }

#endregion

#region "Member Variables"
        private ListView m_cachedNameListView;

        private const int Timeout = 3000;
        protected internal static Window ActiveWindow;

#endregion

#region "Constructor and Init function"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  TODO: Add a description for your constructor.
        ///  </summary>
        //  <param name="app">Window object owning the window.</param>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public ImagesWindow(Window ownerWindow, XenonandLiveAuthoringSubmissionToolApp app) : 
                base(Init(ownerWindow, app))
        {
            // TODO: Add Constructor logic here. 
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  This function will attempt to find the window.
        ///  </summary>
        ///  <returns>The window to find</returns>
        ///  <param name="ownerWindow">Window owning the window.</param>)
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        private static System.IntPtr Init(Window ownerWindow, XenonandLiveAuthoringSubmissionToolApp app)
        {
            // First check if the window is already up.
            Window tempWindow = null;
            try
            {
                tempWindow = new Window(app.GetIntlStr(Strings.WindowTitle), StringMatchSyntax.ExactMatch, WindowClassNames.Alert, StringMatchSyntax.ExactMatch, ownerWindow, Timeout);
            }
            catch (Exceptions.WindowNotFoundException ex)
            {
                // TODO:  Uncomment the following code and apply the appropriate command for invoking the window.
                // 
                // throw new Window.Exceptions.WindowNotFoundException("Init function could not find or bring up the window with a title of " + Strings.DialogTitle + ".");
                // 
            }
            return tempWindow.Extended.HWnd;
        }

#endregion

#region "Properties"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the raw controls for this window
        ///  </summary>
        ///  <value>An interface that groups all of the window's control properties together</value>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual IImagesWindowControls Controls
        {
            get
            {
                return this;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the NameListView control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        ListView IImagesWindowControls.NameListView
        {
            get
            {
                if ((m_cachedNameListView == null))
                {
                    m_cachedNameListView = new ListView(this, ControlIDs.NameListView);
                }
                return m_cachedNameListView;
            }
        }

#endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XLASTAuto\Windows\LeaderboardWindow.cs ===
namespace ServerTestFramework.xlast.XLASTAuto.Windows
{


    using Maui.Core;
    using Maui.Core.WinControls;
    using Maui.Core.Utilities;
    using System.ComponentModel;


#region "ILeaderboardWindowControls interface definition"
    
    
    [EditorBrowsable(EditorBrowsableState.Never)]
    public interface ILeaderboardWindowControls
    {
        ComboBox DisplayStringComboBox  {get;}
        ComboBox ResetTypeComboBox  {get;}
        TextBox MaximumOfAttachmentsTextBox  {get;}
        TextBox EntryExpirationTextBox  {get;}
        ComboBox OnlyKeepTopEntriesComboBox  {get;}
        CheckBox ArbitrateThisLeaderboardCheckBox  {get;}
        CheckBox ThisIsAnOnlineOnlyLeaderboardCheckBox  {get;}
        CheckBox ThisIsATeamsLeaderboardCheckBox  {get;}
        CheckBox ThisLeaderboardIsHiddenCheckBox  {get;}
        ListView LeaderboardColumnsListView  {get;}
        Button AddButton  {get;}
        Button EditButton  {get;}
        Button DeleteButton  {get;}
        Button MoveUpButton  {get;}
        Button MoveDownButton  {get;}
    }

#endregion

    /// -----------------------------------------------------------------------------
    /// Project		: Maui
    /// Class		: LeaderboardWindow
    ///  Copyright (C) 2002, Microsoft Corporation
    /// -----------------------------------------------------------------------------
    ///  <summary>
    ///  TODO: Add window functionality description here.
    ///  </summary>
    ///  <history>
    /// 	[trevorm] 4/5/2005 Created
    ///  </history>
    /// -----------------------------------------------------------------------------
    public class LeaderboardWindow : Window, ILeaderboardWindowControls
    {


#region "Strings"
        public class Strings
        {
            public const string WindowTitle = ";;Win32DialogItemString;xlastui.dll;16250;17470";  //
            public const string ArbitrateThisLeaderboard = ";Arbitrate this leaderboard;Win32DialogItemString;xlastui.dll;16199;16906";  // Arbitrate this leaderboard
            public const string ThisIsAnOnlineOnlyLeaderboard = ";This is an online-only leaderboard;Win32DialogItemString;xlastui.dll;16199;16909";  // This is an online-only leaderboard
			public const string ThisIsATeamsLeaderboard = ";This is a teams leaderboard;Win32DialogItemString;xlastui.dll;16199;16907";  // This is a teams leaderboard
            public const string ThisLeaderboardIsHidden = ";This leaderboard is hidden;Win32DialogItemString;xlastui.dll;16199;16908";  // This leaderboard is hidden
            public const string Add = ";Add...;Win32DialogItemString;xlastui.dll;16199;16917";  // Add...
            public const string Edit = ";Edit...;Win32DialogItemString;xlastui.dll;16199;16918";  // Edit...
            public const string Delete = ";Delete;Win32DialogItemString;xlastui.dll;16199;16919";  // Delete
            public const string MoveUp = ";Move Up;Win32DialogItemString;xlastui.dll;16199;16920";  // Move Up
            public const string MoveDown = ";Move Down;Win32DialogItemString;xlastui.dll;16199;16921";  // Move Down

        }

#endregion

#region "Control IDs"
        public class ControlIDs
        {
            public const int DisplayStringComboBox = 0x4204;
            public const int ResetTypeComboBox = 0x4205;
            public const int MaximumOfAttachmentsTextBox = 0x4206;
            public const int EntryExpirationTextBox = 0x4208;
            public const int OnlyKeepTopEntriesComboBox = 0x4210;
            public const int ArbitrateThisLeaderboardCheckBox = 0x420A;
            public const int ThisIsAnOnlineOnlyLeaderboardCheckBox = 0x420D;
            public const int ThisIsATeamsLeaderboardCheckBox = 0x420B;
            public const int ThisLeaderboardIsHiddenCheckBox = 0x420C;
            public const int LeaderboardColumnsListView = 0x4214;
            public const int AddButton = 0x4215;
            public const int EditButton = 0x4216;
            public const int DeleteButton = 0x4217;
            public const int MoveUpButton = 0x4218;
            public const int MoveDownButton = 0x4219;
        }

#endregion

#region "Member Variables"
        private ComboBox m_cachedDisplayStringComboBox;
        private ComboBox m_cachedResetTypeComboBox;
        private TextBox m_cachedMaximumOfAttachmentsTextBox;
        private TextBox m_cachedEntryExpirationTextBox;
        private ComboBox m_cachedOnlyKeepTopEntriesComboBox;
        private CheckBox m_cachedArbitrateThisLeaderboardCheckBox;
        private CheckBox m_cachedThisIsAnOnlineOnlyLeaderboardCheckBox;
        private CheckBox m_cachedThisIsATeamsLeaderboardCheckBox;
        private CheckBox m_cachedThisLeaderboardIsHiddenCheckBox;
        private ListView m_cachedLeaderboardColumnsListView;
        private Button m_cachedAddButton;
        private Button m_cachedEditButton;
        private Button m_cachedDeleteButton;
        private Button m_cachedMoveUpButton;
        private Button m_cachedMoveDownButton;

        private const int Timeout = 3000;
        protected internal static Window ActiveWindow;

#endregion

#region "Constructor and Init function"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  TODO: Add a description for your constructor.
        ///  </summary>
        //  <param name="app">Window object owning the window.</param>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public LeaderboardWindow(Window ownerWindow, XenonandLiveAuthoringSubmissionToolApp app) : 
                base(Init(ownerWindow, app))
        {
            // TODO: Add Constructor logic here. 
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  This function will attempt to find the window.
        ///  </summary>
        ///  <returns>The window to find</returns>
        ///  <param name="ownerWindow">Window owning the window.</param>)
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        private static System.IntPtr Init(Window ownerWindow, XenonandLiveAuthoringSubmissionToolApp app)
        {
            // First check if the window is already up.
            Window tempWindow = null;
            try
            {
                tempWindow = new Window(app.GetIntlStr(Strings.WindowTitle), StringMatchSyntax.ExactMatch, WindowClassNames.Alert, StringMatchSyntax.ExactMatch, ownerWindow, Timeout);
            }
            catch (Exceptions.WindowNotFoundException ex)
            {
                // TODO:  Uncomment the following code and apply the appropriate command for invoking the window.
                // 
                // throw new Window.Exceptions.WindowNotFoundException("Init function could not find or bring up the window with a title of " + Strings.DialogTitle + ".");
                // 
            }
            return tempWindow.Extended.HWnd;
        }

#endregion

#region "Properties"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the raw controls for this window
        ///  </summary>
        ///  <value>An interface that groups all of the window's control properties together</value>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual ILeaderboardWindowControls Controls
        {
            get
            {
                return this;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Property to handle checkbox ArbitrateThisLeaderboard
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual bool ArbitrateThisLeaderboard
        {
            get
            {
                return Controls.ArbitrateThisLeaderboardCheckBox.Checked;
            }
            set
            {
                Controls.ArbitrateThisLeaderboardCheckBox.Checked = value;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Property to handle checkbox ThisIsAnOnlineOnlyLeaderboard
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual bool ThisIsAnOnlineOnlyLeaderboard
        {
            get
            {
                return Controls.ThisIsAnOnlineOnlyLeaderboardCheckBox.Checked;
            }
            set
            {
                Controls.ThisIsAnOnlineOnlyLeaderboardCheckBox.Checked = value;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Property to handle checkbox ThisIsATeamsLeaderboard
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual bool ThisIsATeamsLeaderboard
        {
            get
            {
                return Controls.ThisIsATeamsLeaderboardCheckBox.Checked;
            }
            set
            {
                Controls.ThisIsATeamsLeaderboardCheckBox.Checked = value;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Property to handle checkbox ThisLeaderboardIsHidden
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual bool ThisLeaderboardIsHidden
        {
            get
            {
                return Controls.ThisLeaderboardIsHiddenCheckBox.Checked;
            }
            set
            {
                Controls.ThisLeaderboardIsHiddenCheckBox.Checked = value;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control DisplayString
        ///  </summary>
        ///  <value>TODO: specify the value</value>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual string DisplayStringText
        {
            get
            {
                return Controls.DisplayStringComboBox.Text;
            }
            set
            {
                Controls.DisplayStringComboBox.SelectByText(value, true);
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control ResetType
        ///  </summary>
        ///  <value>TODO: specify the value</value>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual string ResetTypeText
        {
            get
            {
                return Controls.ResetTypeComboBox.Text;
            }
            set
            {
                Controls.ResetTypeComboBox.SelectByText(value, true);
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control MaximumOfAttachments
        ///  </summary>
        ///  <value>TODO: specify the value</value>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual string MaximumOfAttachmentsText
        {
            get
            {
                return Controls.MaximumOfAttachmentsTextBox.Text;
            }
            set
            {
                Controls.MaximumOfAttachmentsTextBox.Text = value;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control EntryExpiration
        ///  </summary>
        ///  <value>TODO: specify the value</value>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual string EntryExpirationText
        {
            get
            {
                return Controls.EntryExpirationTextBox.Text;
            }
            set
            {
                Controls.EntryExpirationTextBox.Text = value;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control OnlyKeepTopEntries
        ///  </summary>
        ///  <value>TODO: specify the value</value>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual string OnlyKeepTopEntriesText
        {
            get
            {
                return Controls.OnlyKeepTopEntriesComboBox.Text;
            }
            set
            {
                Controls.OnlyKeepTopEntriesComboBox.SelectByText(value, true);
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the DisplayStringComboBox control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        ComboBox ILeaderboardWindowControls.DisplayStringComboBox
        {
            get
            {
                if ((m_cachedDisplayStringComboBox == null))
                {
                    m_cachedDisplayStringComboBox = new ComboBox(this, ControlIDs.DisplayStringComboBox);
                }
                return m_cachedDisplayStringComboBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the ResetTypeComboBox control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        ComboBox ILeaderboardWindowControls.ResetTypeComboBox
        {
            get
            {
                if ((m_cachedResetTypeComboBox == null))
                {
                    m_cachedResetTypeComboBox = new ComboBox(this, ControlIDs.ResetTypeComboBox);
                }
                return m_cachedResetTypeComboBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the MaximumOfAttachmentsTextBox control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        TextBox ILeaderboardWindowControls.MaximumOfAttachmentsTextBox
        {
            get
            {
                if ((m_cachedMaximumOfAttachmentsTextBox == null))
                {
                    m_cachedMaximumOfAttachmentsTextBox = new TextBox(this, ControlIDs.MaximumOfAttachmentsTextBox);
                }
                return m_cachedMaximumOfAttachmentsTextBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the EntryExpirationTextBox control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        TextBox ILeaderboardWindowControls.EntryExpirationTextBox
        {
            get
            {
                if ((m_cachedEntryExpirationTextBox == null))
                {
                    m_cachedEntryExpirationTextBox = new TextBox(this, ControlIDs.EntryExpirationTextBox);
                }
                return m_cachedEntryExpirationTextBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the OnlyKeepTopEntriesComboBox control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        ComboBox ILeaderboardWindowControls.OnlyKeepTopEntriesComboBox
        {
            get
            {
                if ((m_cachedOnlyKeepTopEntriesComboBox == null))
                {
                    m_cachedOnlyKeepTopEntriesComboBox = new ComboBox(this, ControlIDs.OnlyKeepTopEntriesComboBox);
                }
                return m_cachedOnlyKeepTopEntriesComboBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the ArbitrateThisLeaderboardCheckBox control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        CheckBox ILeaderboardWindowControls.ArbitrateThisLeaderboardCheckBox
        {
            get
            {
                if ((m_cachedArbitrateThisLeaderboardCheckBox == null))
                {
                    m_cachedArbitrateThisLeaderboardCheckBox = new CheckBox(this, ControlIDs.ArbitrateThisLeaderboardCheckBox);
                }
                return m_cachedArbitrateThisLeaderboardCheckBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the ThisIsAnOnlineOnlyLeaderboardCheckBox control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        CheckBox ILeaderboardWindowControls.ThisIsAnOnlineOnlyLeaderboardCheckBox
        {
            get
            {
                if ((m_cachedThisIsAnOnlineOnlyLeaderboardCheckBox == null))
                {
                    m_cachedThisIsAnOnlineOnlyLeaderboardCheckBox = new CheckBox(this, ControlIDs.ThisIsAnOnlineOnlyLeaderboardCheckBox);
                }
                return m_cachedThisIsAnOnlineOnlyLeaderboardCheckBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the ThisIsATeamsLeaderboardCheckBox control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        CheckBox ILeaderboardWindowControls.ThisIsATeamsLeaderboardCheckBox
        {
            get
            {
                if ((m_cachedThisIsATeamsLeaderboardCheckBox == null))
                {
                    m_cachedThisIsATeamsLeaderboardCheckBox = new CheckBox(this, ControlIDs.ThisIsATeamsLeaderboardCheckBox);
                }
                return m_cachedThisIsATeamsLeaderboardCheckBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the ThisLeaderboardIsHiddenCheckBox control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        CheckBox ILeaderboardWindowControls.ThisLeaderboardIsHiddenCheckBox
        {
            get
            {
                if ((m_cachedThisLeaderboardIsHiddenCheckBox == null))
                {
                    m_cachedThisLeaderboardIsHiddenCheckBox = new CheckBox(this, ControlIDs.ThisLeaderboardIsHiddenCheckBox);
                }
                return m_cachedThisLeaderboardIsHiddenCheckBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the LeaderboardColumnsListView control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        ListView ILeaderboardWindowControls.LeaderboardColumnsListView
        {
            get
            {
                if ((m_cachedLeaderboardColumnsListView == null))
                {
                    m_cachedLeaderboardColumnsListView = new ListView(this, ControlIDs.LeaderboardColumnsListView);
                }
                return m_cachedLeaderboardColumnsListView;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the AddButton control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button ILeaderboardWindowControls.AddButton
        {
            get
            {
                if ((m_cachedAddButton == null))
                {
                    m_cachedAddButton = new Button(this, ControlIDs.AddButton);
                }
                return m_cachedAddButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the EditButton control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button ILeaderboardWindowControls.EditButton
        {
            get
            {
                if ((m_cachedEditButton == null))
                {
                    m_cachedEditButton = new Button(this, ControlIDs.EditButton);
                }
                return m_cachedEditButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the DeleteButton control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button ILeaderboardWindowControls.DeleteButton
        {
            get
            {
                if ((m_cachedDeleteButton == null))
                {
                    m_cachedDeleteButton = new Button(this, ControlIDs.DeleteButton);
                }
                return m_cachedDeleteButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the MoveUpButton control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button ILeaderboardWindowControls.MoveUpButton
        {
            get
            {
                if ((m_cachedMoveUpButton == null))
                {
                    m_cachedMoveUpButton = new Button(this, ControlIDs.MoveUpButton);
                }
                return m_cachedMoveUpButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the MoveDownButton control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button ILeaderboardWindowControls.MoveDownButton
        {
            get
            {
                if ((m_cachedMoveDownButton == null))
                {
                    m_cachedMoveDownButton = new Button(this, ControlIDs.MoveDownButton);
                }
                return m_cachedMoveDownButton;
            }
        }

#endregion

#region "Methods"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button Add
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickAdd()
        {
            Controls.AddButton.Click();
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button Edit
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickEdit()
        {
            Controls.EditButton.Click();
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button Delete
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickDelete()
        {
            Controls.DeleteButton.Click();
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button MoveUp
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickMoveUp()
        {
            Controls.MoveUpButton.Click();
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button MoveDown
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickMoveDown()
        {
            Controls.MoveDownButton.Click();
        }

#endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XLASTAuto\Windows\LocalizedStringsWindow.cs ===
namespace ServerTestFramework.xlast.XLASTAuto.Windows
{


    using Maui.Core;
    using Maui.Core.WinControls;
    using Maui.Core.Utilities;
    using System.ComponentModel;


#region "ILocalizedStringsWindowControls interface definition"
    
    
    [EditorBrowsable(EditorBrowsableState.Never)]
    public interface ILocalizedStringsWindowControls
    {
        ComboBox DefaultLocaleComboBox  {get;}
    }

#endregion

    /// -----------------------------------------------------------------------------
    /// Project		: Maui
    /// Class		: LocalizedStringsWindow
    ///  Copyright (C) 2002, Microsoft Corporation
    /// -----------------------------------------------------------------------------
    ///  <summary>
    ///  TODO: Add window functionality description here.
    ///  </summary>
    ///  <history>
    /// 	[trevorm] 4/5/2005 Created
    ///  </history>
    /// -----------------------------------------------------------------------------
    public class LocalizedStringsWindow : Window, ILocalizedStringsWindowControls
    {


#region "Strings"
        public class Strings
        {
            public const string WindowTitle = ";;Win32DialogItemString;xlastui.dll;16250;17470";  //
			public const string Locale_enUS = "en-US";
			public const string Locale_deDE = "de-DE";
			public const string Locale_esES = "es-ES";
			public const string Locale_frFR = "fr-FR";
			public const string Locale_itIT = "it-IT";
			public const string Locale_jpJP = "jp-JP";
			public const string Locale_koKR = "ko-KR";
			public const string Locale_ptPT = "pt-PT";
			public const string Locale_zhCHT = "zh-CHT";
		}

#endregion

#region "Control IDs"
        public class ControlIDs
        {
            public const int DefaultLocaleComboBox = 0x4170;
        }

#endregion

#region "Member Variables"
        private ComboBox m_cachedDefaultLocaleComboBox;

        private const int Timeout = 3000;
        protected internal static Window ActiveWindow;

#endregion

#region "Constructor and Init function"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  TODO: Add a description for your constructor.
        ///  </summary>
        //  <param name="app">Window object owning the window.</param>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public LocalizedStringsWindow(Window ownerWindow, XenonandLiveAuthoringSubmissionToolApp app) : 
                base(Init(ownerWindow, app))
        {
            // TODO: Add Constructor logic here. 
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  This function will attempt to find the window.
        ///  </summary>
        ///  <returns>The window to find</returns>
        ///  <param name="ownerWindow">Window owning the window.</param>)
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        private static System.IntPtr Init(Window ownerWindow, XenonandLiveAuthoringSubmissionToolApp app)
        {
            // First check if the window is already up.
            Window tempWindow = null;
            try
            {
                tempWindow = new Window(app.GetIntlStr(Strings.WindowTitle), StringMatchSyntax.ExactMatch, WindowClassNames.Alert, StringMatchSyntax.ExactMatch, ownerWindow, Timeout);
            }
            catch (Exceptions.WindowNotFoundException ex)
            {
                // TODO:  Uncomment the following code and apply the appropriate command for invoking the window.
                // 
                // throw new Window.Exceptions.WindowNotFoundException("Init function could not find or bring up the window with a title of " + Strings.DialogTitle + ".");
                // 
            }
            return tempWindow.Extended.HWnd;
        }

#endregion

#region "Properties"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the raw controls for this window
        ///  </summary>
        ///  <value>An interface that groups all of the window's control properties together</value>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual ILocalizedStringsWindowControls Controls
        {
            get
            {
                return this;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control DefaultLocale
        ///  </summary>
        ///  <value>TODO: specify the value</value>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual string DefaultLocaleText
        {
            get
            {
                return Controls.DefaultLocaleComboBox.Text;
            }
            set
            {
                Controls.DefaultLocaleComboBox.SelectByText(value, true);
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the DefaultLocaleComboBox control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        ComboBox ILocalizedStringsWindowControls.DefaultLocaleComboBox
        {
            get
            {
                if ((m_cachedDefaultLocaleComboBox == null))
                {
                    m_cachedDefaultLocaleComboBox = new ComboBox(this, ControlIDs.DefaultLocaleComboBox);
                }
                return m_cachedDefaultLocaleComboBox;
            }
        }

#endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XLASTAuto\Windows\LocalizedStringWindow.cs ===
namespace ServerTestFramework.xlast.XLASTAuto.Windows
{


    using Maui.Core;
    using Maui.Core.WinControls;
    using Maui.Core.Utilities;
    using System.ComponentModel;


#region "ILocalizedStringWindowControls interface definition"
    
    
    [EditorBrowsable(EditorBrowsableState.Never)]
    public interface ILocalizedStringWindowControls
    {
        StaticControl DisplayStringFriendlyNameStaticControl  {get;}
        ComboBox LanguageComboBox  {get;}
        TextBox DefaultLanguageStringTextBox  {get;}
        TextBox TranslatedStringTextBox  {get;}
    }

#endregion

    /// -----------------------------------------------------------------------------
    /// Project		: Maui
    /// Class		: LocalizedStringWindow
    ///  Copyright (C) 2002, Microsoft Corporation
    /// -----------------------------------------------------------------------------
    ///  <summary>
    ///  TODO: Add window functionality description here.
    ///  </summary>
    ///  <history>
    /// 	[trevorm] 4/5/2005 Created
    ///  </history>
    /// -----------------------------------------------------------------------------
    public class LocalizedStringWindow : Window, ILocalizedStringWindowControls
    {


#region "Strings"
        public class Strings
        {
            public const string WindowTitle = ";;Win32DialogItemString;xlastui.dll;16250;17470";  //
        }

#endregion

#region "Control IDs"
        public class ControlIDs
        {
            public const int DisplayStringFriendlyNameStaticControl = 0x4140;
            public const int LanguageComboBox = 0x413E;
            public const int DefaultLanguageStringTextBox = 0x413D;
            public const int TranslatedStringTextBox = 0x413F;
        }

#endregion

#region "Member Variables"
        private StaticControl m_cachedDisplayStringFriendlyNameStaticControl;
        private ComboBox m_cachedLanguageComboBox;
        private TextBox m_cachedDefaultLanguageStringTextBox;
        private TextBox m_cachedTranslatedStringTextBox;

        private const int Timeout = 3000;
        protected internal static Window ActiveWindow;

#endregion

#region "Constructor and Init function"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  TODO: Add a description for your constructor.
        ///  </summary>
        //  <param name="app">Window object owning the window.</param>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public LocalizedStringWindow(Window ownerWindow, XenonandLiveAuthoringSubmissionToolApp app) : 
                base(Init(ownerWindow, app))
        {
            // TODO: Add Constructor logic here. 
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  This function will attempt to find the window.
        ///  </summary>
        ///  <returns>The window to find</returns>
        ///  <param name="ownerWindow">Window owning the window.</param>)
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        private static System.IntPtr Init(Window ownerWindow, XenonandLiveAuthoringSubmissionToolApp app)
        {
            // First check if the window is already up.
            Window tempWindow = null;
            try
            {
                tempWindow = new Window(app.GetIntlStr(Strings.WindowTitle), StringMatchSyntax.ExactMatch, WindowClassNames.Alert, StringMatchSyntax.ExactMatch, ownerWindow, Timeout);
            }
            catch (Exceptions.WindowNotFoundException ex)
            {
                // TODO:  Uncomment the following code and apply the appropriate command for invoking the window.
                // 
                // throw new Window.Exceptions.WindowNotFoundException("Init function could not find or bring up the window with a title of " + Strings.DialogTitle + ".");
                // 
            }
            return tempWindow.Extended.HWnd;
        }

#endregion

#region "Properties"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the raw controls for this window
        ///  </summary>
        ///  <value>An interface that groups all of the window's control properties together</value>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual ILocalizedStringWindowControls Controls
        {
            get
            {
                return this;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to get the text in control DisplayStringFriendlyName
        ///  </summary>
        ///  <value>TODO: specify the value</value>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual string DisplayStringFriendlyNameText
        {
            get
            {
                return Controls.DisplayStringFriendlyNameStaticControl.Text;
            }
        }

		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Routine to set/get the text in control Language
		///  </summary>
		///  <value>TODO: specify the value</value>
		///  <history>
		/// 	[trevorm] 4/5/2005 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public virtual string LanguageText
		{
			get
			{
				return Controls.LanguageComboBox.Text;
			}
			set
			{
				Controls.LanguageComboBox.SelectByText(value, true);
			}
		}

		/// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control DefaultLanguageString
        ///  </summary>
        ///  <value>TODO: specify the value</value>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual string DefaultLanguageStringText
        {
            get
            {
                return Controls.DefaultLanguageStringTextBox.Text;
            }
            set
            {
                Controls.DefaultLanguageStringTextBox.Text = value;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control TranslatedString
        ///  </summary>
        ///  <value>TODO: specify the value</value>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual string TranslatedStringText
        {
            get
            {
                return Controls.TranslatedStringTextBox.Text;
            }
            set
            {
                Controls.TranslatedStringTextBox.Text = value;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the DisplayStringFriendlyNameStaticControl control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        StaticControl ILocalizedStringWindowControls.DisplayStringFriendlyNameStaticControl
        {
            get
            {
                if ((m_cachedDisplayStringFriendlyNameStaticControl == null))
                {
                    m_cachedDisplayStringFriendlyNameStaticControl = new StaticControl(this, ControlIDs.DisplayStringFriendlyNameStaticControl);
                }
                return m_cachedDisplayStringFriendlyNameStaticControl;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the LanguageComboBox control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        ComboBox ILocalizedStringWindowControls.LanguageComboBox
        {
            get
            {
                if ((m_cachedLanguageComboBox == null))
                {
                    m_cachedLanguageComboBox = new ComboBox(this, ControlIDs.LanguageComboBox);
                }
                return m_cachedLanguageComboBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the DefaultLanguageStringTextBox control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        TextBox ILocalizedStringWindowControls.DefaultLanguageStringTextBox
        {
            get
            {
                if ((m_cachedDefaultLanguageStringTextBox == null))
                {
                    m_cachedDefaultLanguageStringTextBox = new TextBox(this, ControlIDs.DefaultLanguageStringTextBox);
                }
                return m_cachedDefaultLanguageStringTextBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the TranslatedStringTextBox control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        TextBox ILocalizedStringWindowControls.TranslatedStringTextBox
        {
            get
            {
                if ((m_cachedTranslatedStringTextBox == null))
                {
                    m_cachedTranslatedStringTextBox = new TextBox(this, ControlIDs.TranslatedStringTextBox);
                }
                return m_cachedTranslatedStringTextBox;
            }
        }

#endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XLASTAuto\Windows\MatchmakingAttributesWindow.cs ===
namespace ServerTestFramework.xlast.XLASTAuto.Windows
{


    using Maui.Core;
    using Maui.Core.WinControls;
    using Maui.Core.Utilities;
    using System.ComponentModel;


#region "IMatchmakingAttributesWindowControls interface definition"
    
    
    [EditorBrowsable(EditorBrowsableState.Never)]
    public interface IMatchmakingAttributesWindowControls
    {
        ListBox AttributesListBox  {get;}
        Button AddButton  {get;}
        Button DeleteButton  {get;}
    }

#endregion

    /// -----------------------------------------------------------------------------
    /// Project		: Maui
    /// Class		: MatchmakingAttributesWindow
    ///  Copyright (C) 2002, Microsoft Corporation
    /// -----------------------------------------------------------------------------
    ///  <summary>
    ///  TODO: Add window functionality description here.
    ///  </summary>
    ///  <history>
    /// 	[trevorm] 4/5/2005 Created
    ///  </history>
    /// -----------------------------------------------------------------------------
    public class MatchmakingAttributesWindow : Window, IMatchmakingAttributesWindowControls
    {


#region "Strings"
        public class Strings
        {
            public const string WindowTitle = ";;Win32DialogItemString;xlastui.dll;16250;17470";  //
            public const string Add = ";&Add;Win32DialogItemString;xlastui.dll;16237;17371";  // &Add
            public const string Delete = ";&Delete;Win32DialogItemString;xlastui.dll;16239;17393";  // &Delete
        }

#endregion

#region "Control IDs"
        public class ControlIDs
        {
            public const int AttributesListBox = 0x43A8;
            public const int AddButton = 0x43A9;
            public const int DeleteButton = 0x43AA;
        }

#endregion

#region "Member Variables"
        private ListBox m_cachedAttributesListBox;
        private Button m_cachedAddButton;
        private Button m_cachedDeleteButton;

        private const int Timeout = 3000;
        protected internal static Window ActiveWindow;

#endregion

#region "Constructor and Init function"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  TODO: Add a description for your constructor.
        ///  </summary>
        //  <param name="app">Window object owning the window.</param>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public MatchmakingAttributesWindow(Window ownerWindow, XenonandLiveAuthoringSubmissionToolApp app) : 
                base(Init(ownerWindow, app))
        {
            // TODO: Add Constructor logic here. 
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  This function will attempt to find the window.
        ///  </summary>
        ///  <returns>The window to find</returns>
        ///  <param name="ownerWindow">Window owning the window.</param>)
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        private static System.IntPtr Init(Window ownerWindow, XenonandLiveAuthoringSubmissionToolApp app)
        {
            // First check if the window is already up.
            Window tempWindow = null;
            try
            {
                tempWindow = new Window(app.GetIntlStr(Strings.WindowTitle), StringMatchSyntax.ExactMatch, WindowClassNames.Alert, StringMatchSyntax.ExactMatch, ownerWindow, Timeout);
            }
            catch (Exceptions.WindowNotFoundException ex)
            {
                // TODO:  Uncomment the following code and apply the appropriate command for invoking the window.
                // 
                // throw new Window.Exceptions.WindowNotFoundException("Init function could not find or bring up the window with a title of " + Strings.DialogTitle + ".");
                // 
            }
            return tempWindow.Extended.HWnd;
        }

#endregion

#region "Properties"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the raw controls for this window
        ///  </summary>
        ///  <value>An interface that groups all of the window's control properties together</value>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual IMatchmakingAttributesWindowControls Controls
        {
            get
            {
                return this;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the AttributesListBox control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        ListBox IMatchmakingAttributesWindowControls.AttributesListBox
        {
            get
            {
                if ((m_cachedAttributesListBox == null))
                {
                    m_cachedAttributesListBox = new ListBox(this, ControlIDs.AttributesListBox);
                }
                return m_cachedAttributesListBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the AddButton control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IMatchmakingAttributesWindowControls.AddButton
        {
            get
            {
                if ((m_cachedAddButton == null))
                {
                    m_cachedAddButton = new Button(this, ControlIDs.AddButton);
                }
                return m_cachedAddButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the DeleteButton control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IMatchmakingAttributesWindowControls.DeleteButton
        {
            get
            {
                if ((m_cachedDeleteButton == null))
                {
                    m_cachedDeleteButton = new Button(this, ControlIDs.DeleteButton);
                }
                return m_cachedDeleteButton;
            }
        }

#endregion

#region "Methods"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button Add
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickAdd()
        {
            Controls.AddButton.Click();
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button Delete
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickDelete()
        {
            Controls.DeleteButton.Click();
        }

#endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XLASTAuto\Windows\MatchmakingQueryGeneralWindow.cs ===
namespace ServerTestFramework.xlast.XLASTAuto.Windows
{


    using Maui.Core;
    using Maui.Core.WinControls;
    using Maui.Core.Utilities;
    using System.ComponentModel;


#region "IMatchmakingQueryGeneralWindowControls interface definition"
    
    
    [EditorBrowsable(EditorBrowsableState.Never)]
    public interface IMatchmakingQueryGeneralWindowControls
    {
        TextBox MaxResultsTextBox  {get;}
        CheckBox QualityOfServiceProbingCodeGenerationCheckBox  {get;}
    }

#endregion

    /// -----------------------------------------------------------------------------
    /// Project		: Maui
    /// Class		: MatchmakingQueryGeneralWindow
    ///  Copyright (C) 2002, Microsoft Corporation
    /// -----------------------------------------------------------------------------
    ///  <summary>
    ///  TODO: Add window functionality description here.
    ///  </summary>
    ///  <history>
    /// 	[trevorm] 4/5/2005 Created
    ///  </history>
    /// -----------------------------------------------------------------------------
    public class MatchmakingQueryGeneralWindow : Window, IMatchmakingQueryGeneralWindowControls
    {


#region "Strings"
        public class Strings
        {
            public const string WindowTitle = ";;Win32DialogItemString;xlastui.dll;16250;17470";  //

            public const string QualityOfServiceProbingCodeGeneration = ";Quality of Service Probing code generation;Win32DialogItemString;xlastui.dll;16235;17353";  // Quality of Service Probing code generation
        }

#endregion

#region "Control IDs"
        public class ControlIDs
        {
            public const int MaxResultsTextBox = 0x43C8;
            public const int QualityOfServiceProbingCodeGenerationCheckBox = 0x43C9;
        }

#endregion

#region "Member Variables"
        private TextBox m_cachedMaxResultsTextBox;
        private CheckBox m_cachedQualityOfServiceProbingCodeGenerationCheckBox;

        private const int Timeout = 3000;
        protected internal static Window ActiveWindow;

#endregion

#region "Constructor and Init function"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  TODO: Add a description for your constructor.
        ///  </summary>
        //  <param name="app">Window object owning the window.</param>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public MatchmakingQueryGeneralWindow(Window ownerWindow, XenonandLiveAuthoringSubmissionToolApp app) : 
                base(Init(ownerWindow, app))
        {
            // TODO: Add Constructor logic here. 
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  This function will attempt to find the window.
        ///  </summary>
        ///  <returns>The window to find</returns>
        ///  <param name="ownerWindow">Window owning the window.</param>)
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        private static System.IntPtr Init(Window ownerWindow, XenonandLiveAuthoringSubmissionToolApp app)
        {
            // First check if the window is already up.
            Window tempWindow = null;
            try
            {
                tempWindow = new Window(app.GetIntlStr(Strings.WindowTitle), StringMatchSyntax.ExactMatch, WindowClassNames.TabCtl32, StringMatchSyntax.ExactMatch, ownerWindow, Timeout);
            }
            catch (Exceptions.WindowNotFoundException ex)
            {
                // TODO:  Uncomment the following code and apply the appropriate command for invoking the window.
                // 
                // throw new Window.Exceptions.WindowNotFoundException("Init function could not find or bring up the window with a title of " + Strings.DialogTitle + ".");
                // 
            }
            return tempWindow.Extended.HWnd;
        }

#endregion

#region "Properties"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the raw controls for this window
        ///  </summary>
        ///  <value>An interface that groups all of the window's control properties together</value>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual IMatchmakingQueryGeneralWindowControls Controls
        {
            get
            {
                return this;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Property to handle checkbox QualityOfServiceProbingCodeGeneration
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual bool QualityOfServiceProbingCodeGeneration
        {
            get
            {
                return Controls.QualityOfServiceProbingCodeGenerationCheckBox.Checked;
            }
            set
            {
                Controls.QualityOfServiceProbingCodeGenerationCheckBox.Checked = value;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control MaxResults
        ///  </summary>
        ///  <value>TODO: specify the value</value>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual string MaxResultsText
        {
            get
            {
                return Controls.MaxResultsTextBox.Text;
            }
            set
            {
                Controls.MaxResultsTextBox.Text = value;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the MaxResultsTextBox control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        TextBox IMatchmakingQueryGeneralWindowControls.MaxResultsTextBox
        {
            get
            {
                if ((m_cachedMaxResultsTextBox == null))
                {
                    m_cachedMaxResultsTextBox = new TextBox(this, ControlIDs.MaxResultsTextBox);
                }
                return m_cachedMaxResultsTextBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the QualityOfServiceProbingCodeGenerationCheckBox control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        CheckBox IMatchmakingQueryGeneralWindowControls.QualityOfServiceProbingCodeGenerationCheckBox
        {
            get
            {
                if ((m_cachedQualityOfServiceProbingCodeGenerationCheckBox == null))
                {
                    m_cachedQualityOfServiceProbingCodeGenerationCheckBox = new CheckBox(this, ControlIDs.QualityOfServiceProbingCodeGenerationCheckBox);
                }
                return m_cachedQualityOfServiceProbingCodeGenerationCheckBox;
            }
        }

#endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XLASTAuto\Windows\MatchmakingConstantsWindow.cs ===
namespace ServerTestFramework.xlast.XLASTAuto.Windows
{


    using Maui.Core;
    using Maui.Core.WinControls;
    using Maui.Core.Utilities;
    using System.ComponentModel;


#region "IMatchmakingConstantsWindowControls interface definition"
    
    
    [EditorBrowsable(EditorBrowsableState.Never)]
    public interface IMatchmakingConstantsWindowControls
    {
        ListView ConstantsListView  {get;}
        Button AddButton  {get;}
        Button EditButton  {get;}
        Button DeleteButton  {get;}
    }

#endregion

    /// -----------------------------------------------------------------------------
    /// Project		: Maui
    /// Class		: MatchmakingConstantsWindow
    ///  Copyright (C) 2002, Microsoft Corporation
    /// -----------------------------------------------------------------------------
    ///  <summary>
    ///  TODO: Add window functionality description here.
    ///  </summary>
    ///  <history>
    /// 	[trevorm] 4/5/2005 Created
    ///  </history>
    /// -----------------------------------------------------------------------------
    public class MatchmakingConstantsWindow : Window, IMatchmakingConstantsWindowControls
    {


#region "Strings"
        public class Strings
        {
            public const string WindowTitle = ";;Win32DialogItemString;xlastui.dll;16250;17470";  //
            public const string Add = ";&Add;Win32DialogItemString;xlastui.dll;16237;17371";  // &Add
            public const string Edit = ";&Edit;Win32DialogItemString;xlastui.dll;16239;17392";  // &Edit
            public const string Delete = ";&Delete;Win32DialogItemString;xlastui.dll;16239;17393";  // &Delete
        }

#endregion

#region "Control IDs"
        public class ControlIDs
        {
            public const int ConstantsListView = 0x43B2;
            public const int AddButton = 0x43B3;
            public const int EditButton = 0x43B4;
            public const int DeleteButton = 0x43B5;
        }

#endregion

#region "Member Variables"

        private ListView m_cachedConstantsListView;
        private Button m_cachedAddButton;
        private Button m_cachedEditButton;
        private Button m_cachedDeleteButton;

        private const int Timeout = 3000;
        protected internal static Window ActiveWindow;

#endregion

#region "Constructor and Init function"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  TODO: Add a description for your constructor.
        ///  </summary>
        //  <param name="app">Window object owning the window.</param>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public MatchmakingConstantsWindow(Window ownerWindow, XenonandLiveAuthoringSubmissionToolApp app) : 
                base(Init(ownerWindow, app))
        {
            // TODO: Add Constructor logic here. 
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  This function will attempt to find the window.
        ///  </summary>
        ///  <returns>The window to find</returns>
        ///  <param name="ownerWindow">Window owning the window.</param>)
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        private static System.IntPtr Init(Window ownerWindow, XenonandLiveAuthoringSubmissionToolApp app)
        {
            // First check if the window is already up.
            Window tempWindow = null;
            try
            {
                tempWindow = new Window(app.GetIntlStr(Strings.WindowTitle), StringMatchSyntax.ExactMatch, WindowClassNames.Alert, StringMatchSyntax.ExactMatch, ownerWindow, Timeout);
            }
            catch (Exceptions.WindowNotFoundException ex)
            {
                // TODO:  Uncomment the following code and apply the appropriate command for invoking the window.
                // 
                // throw new Window.Exceptions.WindowNotFoundException("Init function could not find or bring up the window with a title of " + Strings.DialogTitle + ".");
                // 
            }
            return tempWindow.Extended.HWnd;
        }

#endregion

#region "Properties"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the raw controls for this window
        ///  </summary>
        ///  <value>An interface that groups all of the window's control properties together</value>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual IMatchmakingConstantsWindowControls Controls
        {
            get
            {
                return this;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the ConstantsListView control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        ListView IMatchmakingConstantsWindowControls.ConstantsListView
        {
            get
            {
                if ((m_cachedConstantsListView == null))
                {
                    m_cachedConstantsListView = new ListView(this, ControlIDs.ConstantsListView);
                }
                return m_cachedConstantsListView;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the AddButton control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IMatchmakingConstantsWindowControls.AddButton
        {
            get
            {
                if ((m_cachedAddButton == null))
                {
                    m_cachedAddButton = new Button(this, ControlIDs.AddButton);
                }
                return m_cachedAddButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the EditButton control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IMatchmakingConstantsWindowControls.EditButton
        {
            get
            {
                if ((m_cachedEditButton == null))
                {
                    m_cachedEditButton = new Button(this, ControlIDs.EditButton);
                }
                return m_cachedEditButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the DeleteButton control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IMatchmakingConstantsWindowControls.DeleteButton
        {
            get
            {
                if ((m_cachedDeleteButton == null))
                {
                    m_cachedDeleteButton = new Button(this, ControlIDs.DeleteButton);
                }
                return m_cachedDeleteButton;
            }
        }

#endregion

#region "Methods"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button Add
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickAdd()
        {
            Controls.AddButton.Click();
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button Edit
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickEdit()
        {
            Controls.EditButton.Click();
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button Delete
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickDelete()
        {
            Controls.DeleteButton.Click();
        }

#endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XLASTAuto\Windows\ProjectViewInnerWindow.cs ===
namespace ServerTestFramework.xlast.XLASTAuto.Windows
{


    using Maui.Core;
    using Maui.Core.WinControls;
    using Maui.Core.Utilities;
    using System.ComponentModel;


#region "IProjectViewInnerWindowControls interface definition"
    
    
    [EditorBrowsable(EditorBrowsableState.Never)]
    public interface IProjectViewInnerWindowControls
    {
    }

#endregion

    /// -----------------------------------------------------------------------------
    /// Project		: Maui
    /// Class		: ProjectViewInnerWindow
    ///  Copyright (C) 2002, Microsoft Corporation
    /// -----------------------------------------------------------------------------
    ///  <summary>
    ///  TODO: Add window functionality description here.
    ///  </summary>
    ///  <history>
    /// 	[trevorm] 4/4/2005 Created
    ///  </history>
    /// -----------------------------------------------------------------------------
    public class ProjectViewInnerWindow : Window, IProjectViewInnerWindowControls
    {


#region "Strings"
        public class Strings
        {
            public const string WindowTitle = ";;Win32DialogItemString;xlastui.dll;16250;17470";  //
        }

#endregion

#region "Control IDs"
        public class ControlIDs
        {
        }

#endregion

#region "Member Variables"

        private const int Timeout = 3000;
        protected internal static Window ActiveWindow;

#endregion

#region "Constructor and Init function"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  TODO: Add a description for your constructor.
        ///  </summary>
        //  <param name="app">Window object owning the window.</param>
        ///  <history>
        /// 	[trevorm] 4/4/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public ProjectViewInnerWindow(Window ownerWindow, XenonandLiveAuthoringSubmissionToolApp app) : 
                base(Init(ownerWindow, app))
        {
            // TODO: Add Constructor logic here. 
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  This function will attempt to find the window.
        ///  </summary>
        ///  <returns>The window to find</returns>
        ///  <param name="ownerWindow">Window owning the window.</param>)
        ///  <history>
        /// 	[trevorm] 4/4/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        private static System.IntPtr Init(Window ownerWindow, XenonandLiveAuthoringSubmissionToolApp app)
        {
            // First check if the window is already up.
            Window tempWindow = null;
            try
            {
                tempWindow = new Window(app.GetIntlStr(Strings.WindowTitle), StringMatchSyntax.ExactMatch, "AfxMDIFrame70u", StringMatchSyntax.ExactMatch, ownerWindow, Timeout);
            }
            catch (Exceptions.WindowNotFoundException ex)
            {
                // TODO:  Uncomment the following code and apply the appropriate command for invoking the window.
                // 
                // throw new Window.Exceptions.WindowNotFoundException("Init function could not find or bring up the window with a title of " + Strings.DialogTitle + ".");
                // 
            }
            return tempWindow.Extended.HWnd;
        }

#endregion

#region "Properties"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the raw controls for this window
        ///  </summary>
        ///  <value>An interface that groups all of the window's control properties together</value>
        ///  <history>
        /// 	[trevorm] 4/4/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual IProjectViewInnerWindowControls Controls
        {
            get
            {
                return this;
            }
        }


#endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XLASTAuto\Windows\ProjectViewRightInnerWindow.cs ===
namespace ServerTestFramework.xlast.XLASTAuto.Windows
{


    using Maui.Core;
    using Maui.Core.WinControls;
    using Maui.Core.Utilities;
    using System.ComponentModel;


#region "IProjectViewRightInnerWindowControls interface definition"
    
    
    [EditorBrowsable(EditorBrowsableState.Never)]
    public interface IProjectViewRightInnerWindowControls
    {
    }

#endregion

    /// -----------------------------------------------------------------------------
    /// Project		: Maui
    /// Class		: ProjectViewRightInnerWindow
    ///  Copyright (C) 2002, Microsoft Corporation
    /// -----------------------------------------------------------------------------
    ///  <summary>
    ///  TODO: Add window functionality description here.
    ///  </summary>
    ///  <history>
    /// 	[trevorm] 4/4/2005 Created
    ///  </history>
    /// -----------------------------------------------------------------------------
    public class ProjectViewRightInnerWindow : Window, IProjectViewRightInnerWindowControls
    {


#region "Strings"
        public class Strings
        {
            public const string WindowTitle = ";;Win32DialogItemString;xlastui.dll;16250;17470";  //
        }

#endregion

#region "Control IDs"
        public class ControlIDs
        {
        }

#endregion

#region "Member Variables"

        private const int Timeout = 3000;
        protected internal static Window ActiveWindow;

#endregion

#region "Constructor and Init function"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  TODO: Add a description for your constructor.
        ///  </summary>
        //  <param name="app">Window object owning the window.</param>
        ///  <history>
        /// 	[trevorm] 4/4/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public ProjectViewRightInnerWindow(Window ownerWindow, XenonandLiveAuthoringSubmissionToolApp app) : 
                base(Init(ownerWindow, app))
        {
            // TODO: Add Constructor logic here. 
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  This function will attempt to find the window.
        ///  </summary>
        ///  <returns>The window to find</returns>
        ///  <param name="ownerWindow">Window owning the window.</param>)
        ///  <history>
        /// 	[trevorm] 4/4/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        private static System.IntPtr Init(Window ownerWindow, XenonandLiveAuthoringSubmissionToolApp app)
        {
            // First check if the window is already up.
            Window tempWindow = null;
            try
            {
                tempWindow = new Window(app.GetIntlStr(Strings.WindowTitle), StringMatchSyntax.ExactMatch, "AfxMDIFrame70u", StringMatchSyntax.ExactMatch, ownerWindow, Timeout);
            }
            catch (Exceptions.WindowNotFoundException ex)
            {
                // TODO:  Uncomment the following code and apply the appropriate command for invoking the window.
                // 
                // throw new Window.Exceptions.WindowNotFoundException("Init function could not find or bring up the window with a title of " + Strings.DialogTitle + ".");
                // 
            }
            return tempWindow.Extended.HWnd;
        }

#endregion

#region "Properties"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the raw controls for this window
        ///  </summary>
        ///  <value>An interface that groups all of the window's control properties together</value>
        ///  <history>
        /// 	[trevorm] 4/4/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual IProjectViewRightInnerWindowControls Controls
        {
            get
            {
                return this;
            }
        }


#endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XLASTAuto\Windows\ProjectViewOuterWindow.cs ===
namespace ServerTestFramework.xlast.XLASTAuto.Windows
{


    using Maui.Core;
    using Maui.Core.WinControls;
    using Maui.Core.Utilities;
    using System.ComponentModel;


#region "IProjectViewOuterWindowControls interface definition"
    
    
    [EditorBrowsable(EditorBrowsableState.Never)]
    public interface IProjectViewOuterWindowControls
    {
    }

#endregion

    /// -----------------------------------------------------------------------------
    /// Project		: Maui
    /// Class		: ProjectViewOuterWindow
    ///  Copyright (C) 2002, Microsoft Corporation
    /// -----------------------------------------------------------------------------
    ///  <summary>
    ///  TODO: Add window functionality description here.
    ///  </summary>
    ///  <history>
    /// 	[trevorm] 4/4/2005 Created
    ///  </history>
    /// -----------------------------------------------------------------------------
    public class ProjectViewOuterWindow : Window, IProjectViewOuterWindowControls
    {


#region "Strings"
        public class Strings
        {
            public const string WindowTitle = "Project View : ";
        }

#endregion

#region "Control IDs"
        public class ControlIDs
        {
        }

#endregion

#region "Member Variables"

        private const int Timeout = 3000;
        protected internal static Window ActiveWindow;

#endregion

#region "Constructor and Init function"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  TODO: Add a description for your constructor.
        ///  </summary>
        //  <param name="app">Window object owning the window.</param>
        ///  <history>
        /// 	[trevorm] 4/4/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public ProjectViewOuterWindow(Window ownerWindow, XenonandLiveAuthoringSubmissionToolApp app) : 
                base(Init(ownerWindow, app))
        {
            // TODO: Add Constructor logic here. 
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  This function will attempt to find the window.
        ///  </summary>
        ///  <returns>The window to find</returns>
        ///  <param name="ownerWindow">Window owning the window.</param>)
        ///  <history>
        /// 	[trevorm] 4/4/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        private static System.IntPtr Init(Window ownerWindow, XenonandLiveAuthoringSubmissionToolApp app)
        {
            // First check if the window is already up.
            Window tempWindow = null;
            try
            {
                tempWindow = new Window(app.GetIntlStr(Strings.WindowTitle), StringMatchSyntax.ExactMatch, "AfxMDIFrame70u", StringMatchSyntax.ExactMatch, ownerWindow, Timeout);
            }
            catch (Exceptions.WindowNotFoundException ex)
            {
                // TODO:  Uncomment the following code and apply the appropriate command for invoking the window.
                // 
                // throw new Window.Exceptions.WindowNotFoundException("Init function could not find or bring up the window with a title of " + Strings.DialogTitle + ".");
                // 
            }
            return tempWindow.Extended.HWnd;
        }

#endregion

#region "Properties"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the raw controls for this window
        ///  </summary>
        ///  <value>An interface that groups all of the window's control properties together</value>
        ///  <history>
        /// 	[trevorm] 4/4/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual IProjectViewOuterWindowControls Controls
        {
            get
            {
                return this;
            }
        }


#endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\xlTransTest\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XLASTAuto\Windows\XLASTInnerWindow.cs ===
namespace ServerTestFramework.xlast.XLASTAuto.Windows
{


    using Maui.Core;
    using Maui.Core.WinControls;
    using Maui.Core.Utilities;
    using System.ComponentModel;


#region "IXLASTInnerWindowControls interface definition"
    
    
	[EditorBrowsable(EditorBrowsableState.Never)]
	public interface IXLASTInnerWindowControls
	{
	}

#endregion

    
    
    /// -----------------------------------------------------------------------------
    /// Project		: Maui
    /// Class		: XLASTInnerWindow
    ///  Copyright (C) 2002, Microsoft Corporation
    /// -----------------------------------------------------------------------------
    ///  <summary>
    ///  TODO: Add window functionality description here.
    ///  </summary>
    ///  <history>
    /// 	[trevorm] 4/4/2005 Created
    ///  </history>
    /// -----------------------------------------------------------------------------
    public class XLASTInnerWindow : Window, IXLASTInnerWindowControls
    {


#region "Strings"
        // TODO: Remove unused definitions.
        public class Strings
        {
            public const string WindowTitle = ";;Win32DialogItemString;xlastui.dll;16250;17470";  //

        }

#endregion

#region "Control IDs"
        public class ControlIDs
        {
        }

#endregion

#region "Member Variables"
#endregion

#region "Constructor and Init function"
        private const int Timeout = 3000;
        
        protected internal static Window ActiveWindow;
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  TODO: Add a description for your constructor.
        ///  </summary>
        //  <param name="app">Window object owning the window.</param>
        ///  <history>
        /// 	[trevorm] 4/4/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public XLASTInnerWindow(Window ownerWindow, XenonandLiveAuthoringSubmissionToolApp app) : 
                base(Init(ownerWindow, app))
        {
            // TODO: Add Constructor logic here. 
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  This function will attempt to find the window.
        ///  </summary>
        ///  <returns>The window to find</returns>
        ///  <param name="ownerWindow">Window owning the window.</param>)
        ///  <history>
        /// 	[trevorm] 4/4/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        private static System.IntPtr Init(Window ownerWindow, XenonandLiveAuthoringSubmissionToolApp app)
        {
            // First check if the window is already up.
            Window tempWindow = null;
            try
            {
                tempWindow = new Window(app.GetIntlStr(Strings.WindowTitle), StringMatchSyntax.ExactMatch, WindowClassNames.MDIClient, StringMatchSyntax.ExactMatch, ownerWindow, Timeout);
            }
            catch (Exceptions.WindowNotFoundException ex)
            {
                // TODO:  Uncomment the following code and apply the appropriate command for invoking the window.
                // 
                // throw new Window.Exceptions.WindowNotFoundException("Init function could not find or bring up the window with a title of " + Strings.DialogTitle + ".");
                // 
            }
            return tempWindow.Extended.HWnd;
        }

#endregion

#region "Properties"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the raw controls for this window
        ///  </summary>
        ///  <value>An interface that groups all of the window's control properties together</value>
        ///  <history>
        /// 	[trevorm] 4/4/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual IXLASTInnerWindowControls Controls
        {
            get
            {
                return this;
            }
        }


#endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XLASTAuto\Windows\RichPresenceWindow.cs ===
namespace ServerTestFramework.xlast.XLASTAuto.Windows
{


    using Maui.Core;
    using Maui.Core.WinControls;
    using Maui.Core.Utilities;
    using System.ComponentModel;


#region "IRichPresenceWindowControls interface definition"
    
    
    [EditorBrowsable(EditorBrowsableState.Never)]
    public interface IRichPresenceWindowControls
    {
        TextBox PresenceModeTextBox  {get;}
        Spinner PresenceModeSpinner  {get;}
        ComboBox LanguageComboBox  {get;}
        TextBox DefaultLanguageStringTextBox  {get;}
        TextBox TranslatedStringTextBox  {get;}
        Button InsertButton  {get;}
    }

#endregion

    /// -----------------------------------------------------------------------------
    /// Project		: Maui
    /// Class		: RichPresenceWindow
    ///  Copyright (C) 2002, Microsoft Corporation
    /// -----------------------------------------------------------------------------
    ///  <summary>
    ///  TODO: Add window functionality description here.
    ///  </summary>
    ///  <history>
    /// 	[trevorm] 4/5/2005 Created
    ///  </history>
    /// -----------------------------------------------------------------------------
    public class RichPresenceWindow : Window, IRichPresenceWindowControls
    {


#region "Strings"
        // TODO: Remove unused definitions.
        public class Strings
        {
            public const string WindowTitle = ";;Win32DialogItemString;xlastui.dll;16250;17470";  //
            public const string Insert = ";&Insert...;Win32DialogItemString;xlastui.dll;16187;16401";  // &Insert...
        }

#endregion

#region "Control IDs"
        public class ControlIDs
        {
            public const int PresenceModeTextBox = 0x4014;
            public const int PresenceModeSpinner = 0x4015;
            public const int LanguageComboBox = 0x4013;
            public const int DefaultLanguageStringTextBox = 0x4010;
            public const int TranslatedStringTextBox = 0x4012;
            public const int InsertButton = 0x4011;
        }

#endregion

#region "Member Variables"
        private TextBox m_cachedPresenceModeTextBox;
        private Spinner m_cachedPresenceModeSpinner;
        private ComboBox m_cachedLanguageComboBox;
        private TextBox m_cachedDefaultLanguageStringTextBox;
        private TextBox m_cachedTranslatedStringTextBox;
        private Button m_cachedInsertButton;

        private const int Timeout = 3000;
        protected internal static Window ActiveWindow;

#endregion

#region "Constructor and Init function"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  TODO: Add a description for your constructor.
        ///  </summary>
        //  <param name="app">Window object owning the window.</param>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public RichPresenceWindow(Window ownerWindow, XenonandLiveAuthoringSubmissionToolApp app) : 
                base(Init(ownerWindow, app))
        {
            // TODO: Add Constructor logic here. 
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  This function will attempt to find the window.
        ///  </summary>
        ///  <returns>The window to find</returns>
        ///  <param name="ownerWindow">Window owning the window.</param>)
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        private static System.IntPtr Init(Window ownerWindow, XenonandLiveAuthoringSubmissionToolApp app)
        {
            // First check if the window is already up.
            Window tempWindow = null;
            try
            {
                tempWindow = new Window(app.GetIntlStr(Strings.WindowTitle), StringMatchSyntax.ExactMatch, WindowClassNames.Alert, StringMatchSyntax.ExactMatch, ownerWindow, Timeout);
            }
            catch (Exceptions.WindowNotFoundException ex)
            {
                // TODO:  Uncomment the following code and apply the appropriate command for invoking the window.
                // 
                // throw new Window.Exceptions.WindowNotFoundException("Init function could not find or bring up the window with a title of " + Strings.DialogTitle + ".");
                // 
            }
            return tempWindow.Extended.HWnd;
        }

#endregion

#region "Properties"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the raw controls for this window
        ///  </summary>
        ///  <value>An interface that groups all of the window's control properties together</value>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual IRichPresenceWindowControls Controls
        {
            get
            {
                return this;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control PresenceMode
        ///  </summary>
        ///  <value>TODO: specify the value</value>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual string PresenceModeText
        {
            get
            {
                return Controls.PresenceModeTextBox.Text;
            }
            set
            {
                Controls.PresenceModeTextBox.Text = value;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control Language
        ///  </summary>
        ///  <value>TODO: specify the value</value>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual string LanguageText
        {
            get
            {
                return Controls.LanguageComboBox.Text;
            }
            set
            {
                Controls.LanguageComboBox.SelectByText(value, true);
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control DefaultLanguageString
        ///  </summary>
        ///  <value>TODO: specify the value</value>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual string DefaultLanguageStringText
        {
            get
            {
                return Controls.DefaultLanguageStringTextBox.Text;
            }
            set
            {
                Controls.DefaultLanguageStringTextBox.Text = value;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control TranslatedString
        ///  </summary>
        ///  <value>TODO: specify the value</value>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual string TranslatedStringText
        {
            get
            {
                return Controls.TranslatedStringTextBox.Text;
            }
            set
            {
                Controls.TranslatedStringTextBox.Text = value;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the PresenceModeTextBox control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        TextBox IRichPresenceWindowControls.PresenceModeTextBox
        {
            get
            {
                if ((m_cachedPresenceModeTextBox == null))
                {
                    m_cachedPresenceModeTextBox = new TextBox(this, ControlIDs.PresenceModeTextBox);
                }
                return m_cachedPresenceModeTextBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the PresenceModeSpinner control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Spinner IRichPresenceWindowControls.PresenceModeSpinner
        {
            get
            {
                if ((m_cachedPresenceModeSpinner == null))
                {
                    m_cachedPresenceModeSpinner = new Spinner(this, ControlIDs.PresenceModeSpinner);
                }
                return m_cachedPresenceModeSpinner;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the LanguageComboBox control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        ComboBox IRichPresenceWindowControls.LanguageComboBox
        {
            get
            {
                if ((m_cachedLanguageComboBox == null))
                {
                    m_cachedLanguageComboBox = new ComboBox(this, ControlIDs.LanguageComboBox);
                }
                return m_cachedLanguageComboBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the DefaultLanguageStringTextBox control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        TextBox IRichPresenceWindowControls.DefaultLanguageStringTextBox
        {
            get
            {
                if ((m_cachedDefaultLanguageStringTextBox == null))
                {
                    m_cachedDefaultLanguageStringTextBox = new TextBox(this, ControlIDs.DefaultLanguageStringTextBox);
                }
                return m_cachedDefaultLanguageStringTextBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the TranslatedStringTextBox control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        TextBox IRichPresenceWindowControls.TranslatedStringTextBox
        {
            get
            {
                if ((m_cachedTranslatedStringTextBox == null))
                {
                    m_cachedTranslatedStringTextBox = new TextBox(this, ControlIDs.TranslatedStringTextBox);
                }
                return m_cachedTranslatedStringTextBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the InsertButton control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IRichPresenceWindowControls.InsertButton
        {
            get
            {
                if ((m_cachedInsertButton == null))
                {
                    m_cachedInsertButton = new Button(this, ControlIDs.InsertButton);
                }
                return m_cachedInsertButton;
            }
        }

#endregion

#region "Methods"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button Insert
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickInsert()
        {
            Controls.InsertButton.Click();
        }

#endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XLASTAuto\Windows\ProjectViewTreeWindow.cs ===
namespace ServerTestFramework.xlast.XLASTAuto.Windows
{


    using Maui.Core;
    using Maui.Core.WinControls;
    using Maui.Core.Utilities;
    using System.ComponentModel;


#region "IProjectViewTreeWindowControls interface definition"
    
    
	[EditorBrowsable(EditorBrowsableState.Never)]
	public interface IProjectViewTreeWindowControls
	{
	}

#endregion

    
    
    /// -----------------------------------------------------------------------------
    /// Project		: Maui
    /// Class		: ProjectViewTreeWindow
    ///  Copyright (C) 2002, Microsoft Corporation
    /// -----------------------------------------------------------------------------
    ///  <summary>
    ///  TODO: Add window functionality description here.
    ///  </summary>
    ///  <history>
    /// 	[trevorm] 4/4/2005 Created
    ///  </history>
    /// -----------------------------------------------------------------------------
    public class ProjectViewTreeWindow : Window, IProjectViewTreeWindowControls
    {


#region "Strings"
        // TODO: Remove unused definitions.
        public class Strings
        {
            public const string WindowTitle = ";;Win32DialogItemString;xlastui.dll;16250;17470";  //

        }

#endregion

#region "Control IDs"
        public class ControlIDs
        {
        }

#endregion

#region "Member Variables"
#endregion

#region "Constructor and Init function"
        private const int Timeout = 3000;
        
        protected internal static Window ActiveWindow;
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  TODO: Add a description for your constructor.
        ///  </summary>
        //  <param name="app">Window object owning the window.</param>
        ///  <history>
        /// 	[trevorm] 4/4/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public ProjectViewTreeWindow(Window ownerWindow, XenonandLiveAuthoringSubmissionToolApp app) : 
                base(Init(ownerWindow, app))
        {
            // TODO: Add Constructor logic here. 
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  This function will attempt to find the window.
        ///  </summary>
        ///  <returns>The window to find</returns>
        ///  <param name="ownerWindow">Window owning the window.</param>)
        ///  <history>
        /// 	[trevorm] 4/4/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        private static System.IntPtr Init(Window ownerWindow, XenonandLiveAuthoringSubmissionToolApp app)
        {
            // First check if the window is already up.
            Window tempWindow = null;
            try
            {
                tempWindow = new Window(app.GetIntlStr(Strings.WindowTitle), StringMatchSyntax.ExactMatch, WindowClassNames.TreeView, StringMatchSyntax.ExactMatch, ownerWindow, Timeout);
            }
            catch (Exceptions.WindowNotFoundException ex)
            {
                // TODO:  Uncomment the following code and apply the appropriate command for invoking the window.
                // 
                // throw new Window.Exceptions.WindowNotFoundException("Init function could not find or bring up the window with a title of " + Strings.DialogTitle + ".");
                // 
            }
            return tempWindow.Extended.HWnd;
        }

#endregion

#region "Properties"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the raw controls for this window
        ///  </summary>
        ///  <value>An interface that groups all of the window's control properties together</value>
        ///  <history>
        /// 	[trevorm] 4/4/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual IProjectViewTreeWindowControls Controls
        {
            get
            {
                return this;
            }
        }


#endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XLASTAuto\Windows\PropertyWindow.cs ===
namespace ServerTestFramework.xlast.XLASTAuto.Windows
{


    using Maui.Core;
    using Maui.Core.WinControls;
    using Maui.Core.Utilities;
    using System.ComponentModel;


#region "IPropertyWindowControls interface definition"
    
    
    [EditorBrowsable(EditorBrowsableState.Never)]
    public interface IPropertyWindowControls
    {
        ComboBox DisplayStringFriendlyNameComboBox  {get;}
        ComboBox DataTypeComboBox  {get;}
    }

#endregion

    /// -----------------------------------------------------------------------------
    /// Project		: Maui
    /// Class		: PropertyWindow
    ///  Copyright (C) 2002, Microsoft Corporation
    /// -----------------------------------------------------------------------------
    ///  <summary>
    ///  TODO: Add window functionality description here.
    ///  </summary>
    ///  <history>
    /// 	[trevorm] 4/5/2005 Created
    ///  </history>
    /// -----------------------------------------------------------------------------
    public class PropertyWindow : Window, IPropertyWindowControls
    {


#region "Strings"
        public class Strings
        {
            public const string WindowTitle = ";;Win32DialogItemString;xlastui.dll;16250;17470";  //
        }

#endregion

#region "Control IDs"
        public class ControlIDs
        {
            public const int DisplayStringFriendlyNameComboBox = 0x40D9;
            public const int DataTypeComboBox = 0x40DA;
        }

#endregion

#region "Member Variables"
        private ComboBox m_cachedDisplayStringFriendlyNameComboBox;
        private ComboBox m_cachedDataTypeComboBox;

        private const int Timeout = 3000;
        protected internal static Window ActiveWindow;

#endregion

#region "Constructor and Init function"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  TODO: Add a description for your constructor.
        ///  </summary>
        //  <param name="app">Window object owning the window.</param>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public PropertyWindow(Window ownerWindow, XenonandLiveAuthoringSubmissionToolApp app) : 
                base(Init(ownerWindow, app))
        {
            // TODO: Add Constructor logic here. 
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  This function will attempt to find the window.
        ///  </summary>
        ///  <returns>The window to find</returns>
        ///  <param name="ownerWindow">Window owning the window.</param>)
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        private static System.IntPtr Init(Window ownerWindow, XenonandLiveAuthoringSubmissionToolApp app)
        {
            // First check if the window is already up.
            Window tempWindow = null;
            try
            {
                tempWindow = new Window(app.GetIntlStr(Strings.WindowTitle), StringMatchSyntax.ExactMatch, WindowClassNames.Alert, StringMatchSyntax.ExactMatch, ownerWindow, Timeout);
            }
            catch (Exceptions.WindowNotFoundException ex)
            {
                // TODO:  Uncomment the following code and apply the appropriate command for invoking the window.
                // 
                // throw new Window.Exceptions.WindowNotFoundException("Init function could not find or bring up the window with a title of " + Strings.DialogTitle + ".");
                // 
            }
            return tempWindow.Extended.HWnd;
        }

#endregion

#region "Properties"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the raw controls for this window
        ///  </summary>
        ///  <value>An interface that groups all of the window's control properties together</value>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual IPropertyWindowControls Controls
        {
            get
            {
                return this;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control DisplayStringFriendlyName
        ///  </summary>
        ///  <value>TODO: specify the value</value>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual string DisplayStringFriendlyNameText
        {
            get
            {
                return Controls.DisplayStringFriendlyNameComboBox.Text;
            }
            set
            {
                Controls.DisplayStringFriendlyNameComboBox.SelectByText(value, true);
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control DataType
        ///  </summary>
        ///  <value>TODO: specify the value</value>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual string DataTypeText
        {
            get
            {
                return Controls.DataTypeComboBox.Text;
            }
            set
            {
                Controls.DataTypeComboBox.SelectByText(value, true);
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the DisplayStringFriendlyNameComboBox control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        ComboBox IPropertyWindowControls.DisplayStringFriendlyNameComboBox
        {
            get
            {
                if ((m_cachedDisplayStringFriendlyNameComboBox == null))
                {
                    m_cachedDisplayStringFriendlyNameComboBox = new ComboBox(this, ControlIDs.DisplayStringFriendlyNameComboBox);
                }
                return m_cachedDisplayStringFriendlyNameComboBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the DataTypeComboBox control
        ///  </summary>
        ///  <history>
        /// 	[trevorm] 4/5/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        ComboBox IPropertyWindowControls.DataTypeComboBox
        {
            get
            {
                if ((m_cachedDataTypeComboBox == null))
                {
                    m_cachedDataTypeComboBox = new ComboBox(this, ControlIDs.DataTypeComboBox);
                }
                return m_cachedDataTypeComboBox;
            }
        }

#endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\xlTransTest\XLTransImpl.cs ===
using System;
using System.IO;
using System.Net;
using System.Security.Cryptography.X509Certificates;
using System.Xml;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.WebWidget;
using xonline.common.config;

namespace xonline.tools.xltrans.test
{
    public class XLTransImpl : XlTrans
    {
        protected RequestInfo requestInfo = null;

        public XLTransImpl(LiveServer ls) : this(ls.EPDefault)
        {
        }

        public XLTransImpl(IPEndPoint endpoint)
        {
            Url = "http://" + endpoint.ToString() + "/xltrans/xltrans.asmx";
            requestInfo = new RequestInfo();
        }

        public XLTransImpl(IPEndPoint endpoint, CertificateEntry certificate)
        {
            Url = "https://" + endpoint.ToString() + "/xltrans/xltrans.asmx";
            this.ClientCertificates.Add(new X509Certificate(certificate.Cert));
        }

        public XLTransImpl(IPEndPoint endpoint, X509Certificate certificate)
        {
            Url = "https://" + endpoint.ToString() + "/xltrans/xltrans.asmx";
            this.ClientCertificates.Add(certificate);
        }

        public XLTransImpl(IPEndPoint endpoint, RequestInfo requestInfo)
        {
            Url = "http://" + endpoint.ToString() + "/xltrans/xltrans.asmx";
            this.requestInfo = requestInfo;
        }

        override protected WebRequest GetWebRequest(Uri url)
        {
            WebRequest wr = base.GetWebRequest(new Uri(Url));

            if (requestInfo != null)
            {
                wr.Headers.Add("Subject-Name", requestInfo.SubjectName);
                wr.Headers.Add("Client-IP-Port", requestInfo.ClientIPPort);
                wr.Headers.Add("RequestId", requestInfo.RequestId);
            }

            return wr;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\xlTransTest\XLTransBase.cs ===
using System;
using System.IO;
using System.Net;
using System.Reflection;
using System.Security.Cryptography.X509Certificates;
using System.Xml;
using System.Collections.Generic;

using ServerTestFramework;
using ServerTestFramework.Utilities;
using xonline.common.config;
using xonline.tools.xltrans.test;
using xonline.server.webcache.toolsmgmt.test.dvt;

namespace XLTransTest
{
    /// <summary>
    /// Summary description for XLTransTestBase.
    /// </summary>
    /// 
    abstract public class XLTransTestBase : TestBase
    {
        protected static Dictionary<string, bool> _titleProppedDict = new Dictionary<string, bool>();
        protected Report _report = new Report("xlTransTest");
        protected IPEndPoint _xlTransAddress;
        protected X509Certificate _certificate;
        protected XLTransImpl _service;
        protected static ToolsMgmtImpl _toolsMgmt = new ToolsMgmtImpl();
        protected string _localStartPoint;
        protected string _localEndPoint;
        protected string _remoteStartPoint;
        protected string _remoteEndPoint;
        protected string _remoteLongEndPoint;
        protected string _sshStartPoint;
        protected string _sshEndPoint;
        protected string _invalidLocalEndPoint;
        protected string _invalidRemoteEndPoint;
        protected string _invalidEndPointString;
        protected string _testFile = "TestFile_128MB.bar";

        /// <summary>
        /// How to run automation:
        ///     Testfiles must be places at the location defined in the endpoints.conf file.
        /// </summary>
        protected const string DefaultLocalStartPoint = "TestStart";
        protected const string DefaultLocalEndPoint = "TestEnd";
        protected const string DefaultRemoteStartPoint = "RemoteStart";
        protected const string DefaultRemoteEndPoint = "RemoteEnd";
        protected const string DefaultRemoteLongEndPoint = "RemoteLong";
        protected const string DefaultSshStartPoint = "SshStart";
        protected const string DefaultSshEndPoint = "SshEnd";
        protected const string DefaultInvalidLocalEndPoint = "TestInvalid";
        protected const string DefaultInvalidRemoteEndPoint = "TestInvalid";
        protected const string DefaultInvalidEndPointString = "TestBogusInvalid";
        protected const int MaxNotFoundAllowed = 10;
        //protected const string TestnetEndPoint = "TestNet";
        //protected const string PartnernetEndPoint = "Partnernet";
        //protected const string CertnetEndPoint = "Certnet";


        public IPEndPoint XLTransAddress
        {
            get
            {
                return _xlTransAddress;
            }
        }

        public X509Certificate ClientCertificate
        {
            get { return _certificate; }
            set { _certificate = value; }
        }


        public string LocalStartPoint
        {
            get
            {
                return _localStartPoint;
            }
        }

        public string LocalEndPoint
        {
            get
            {
                return _localEndPoint;
            }
        }

        public string RemoteStartPoint
        {
            get
            {
                return _remoteStartPoint;
            }
        }

        public string RemoteEndPoint
        {
            get
            {
                return _remoteEndPoint;
            }
        }

        public string RemoteLongEndPoint
        {
            get
            {
                return _remoteLongEndPoint;
            }
        }

        public string SshStartPoint
        {
            get
            {
                return _sshStartPoint;
            }
        }

        public string SshEndPoint
        {
            get
            {
                return _sshEndPoint;
            }
        }

        public string InvalidLocalEndPoint
        {
            get
            {
                return _invalidLocalEndPoint;
            }
        }

        public string InvalidRemoteEndPoint
        {
            get
            {
                return _invalidRemoteEndPoint;
            }
        }

        public string InvalidEndPointString
        {
            get
            {
                return _invalidEndPointString;
            }
        }

        #region XLTrans API wrapper methods

        protected long TransferFile(string srcRootID, string srcFilePath, string dstRootID, string dstFilePath)
        {
            long lResult = _service.TransferFile(srcRootID, srcFilePath, dstRootID, dstFilePath);

            ValueCheck.TestNonZero("lResult", lResult);

            return lResult;
        }

        protected long JobTransferFile(string srcRootID, string srcFilePath, string dstRootID, long jobId, string dstFilePath)
        {
            long lResult = _service.JobTransferFile(srcRootID, srcFilePath, dstRootID, jobId, dstFilePath);

            ValueCheck.TestNonZero("lResult", lResult);

            return lResult;
        }

        protected TransferState GetTransferStatus(long transferId)
        {
            TransferState gtsr = _service.GetTransferStatus(transferId);

            ValueCheck.TestNotNull("GetTransferStatusResult", gtsr);

            return gtsr;
        }

        protected TransferState GetTransferStatusSafe(long transferId)
        {
            TransferState gtsr;
            try
            {
                gtsr = _service.GetTransferStatus(transferId);
            }
            catch(Exception ex)
            {
                _report.Warn("Exception Caught calling GetTransferStatus: " + ex.ToString());
                gtsr = TransferState.NotFound;
            }

            ValueCheck.TestNotNull("GetTransferStatusResult", gtsr);

            return gtsr;
        }

        protected TransferStatus GetTransferStatusEx(long transferID)
        {
            TransferStatus status = null;
            try
            {
                status = _service.GetTransferStatusEx(transferID);
            }
            catch (Exception ex)
            {
                _report.Warn("Exception Caught calling GetTransferStatusEx: " + ex.ToString());
                status = new TransferStatus();
                status.state = TransferState.NotFound;
            }
            ValueCheck.TestNotNull("GetTransferStatusObject", status);
            return status;
        }

        protected TransferStatus GetTransferStatusExSafe(long transferID)
        {
            TransferStatus status = _service.GetTransferStatusEx(transferID);
            ValueCheck.TestNotNull("GetTransferStatusObject", status);
            return status;
        }

        protected FileStats GetFileStats(string srcRootID, string srcFilePath)
        {
            FileStats gfsr = _service.GetFileStats(srcRootID, srcFilePath);

            ValueCheck.TestNotNull("GetFileStatsResult", gfsr);

            return gfsr;
        }

        protected string GetPhysicalPath(string srcRootID, string srcFilePath)
        {
            string physicalPath = _service.GetPhysicalPath(srcRootID, srcFilePath);
            ValueCheck.TestNotNull("GetPhysicalPathResult", physicalPath);
            return physicalPath;
        }

        protected void PropTitle(string titleID, bool force, params string[] workFiles)
        {
            if ((_titleProppedDict.ContainsKey(titleID) == false) || (force == true))
            {
                int transferIter = 0;
                int numTransfers = workFiles.Length;
                int xlastFileloc = 0;
                TransferStatus[] transferStatus = new TransferStatus[numTransfers];
                long[] transferIds = new long[numTransfers];
                long jobId;
                JobInfo jobInfo;
                ActionInfo actionInfo;

                // CreateJob
                jobId = _toolsMgmt.Service.CreateJob("LiveTitle job " + titleID.ToString(), out jobInfo);
                _report.Info("JobId: {0}", jobId);

                // TransferFiles
                for (transferIter = 0; transferIter < numTransfers; transferIter++)
                {
                    if (workFiles[transferIter].EndsWith(".xlast") == true)
                        xlastFileloc = transferIter;
                    transferIds[transferIter] = JobTransferFile(RemoteStartPoint, workFiles[transferIter], SshStartPoint, jobId, workFiles[transferIter]);
                    _report.Debug("JobTransfer{0} ID: {1}", transferIter, transferIds[transferIter].ToString());
                }

                // Wait for Complete
                transferStatus = WaitForCompleteEx(transferIds);

                // Check Result
                for (transferIter = 0; transferIter < numTransfers; transferIter++)
                {
                    if (transferStatus[transferIter].state != TransferState.Complete)
                    {
                        throw new System.Exception(String.Format("TranferStatus{0} = {1}:{2}",
                                        transferIter,
                                        transferStatus[transferIter].state.ToString(),
                                        transferStatus[transferIter].message));
                    }
                    else
                    {
                        _report.Success("TranferStatus{0} = {1}:{2}",
                                        transferIter,
                                        transferStatus[transferIter].state.ToString(),
                                        transferStatus[transferIter].message);
                    }
                }

                // Run Toolsmgmt/LiveTitle
                actionInfo = _toolsMgmt.RunLiveTitleDefault(jobId, titleID, workFiles[xlastFileloc]);
                int rank = _toolsMgmt.Service.AddAction(actionInfo);
                _report.Debug("rank: {0}", rank);

                actionInfo = _toolsMgmt.RunLiveTitleDeploy(jobId, titleID, workFiles[xlastFileloc]);
                rank = _toolsMgmt.Service.AddAction(actionInfo);
                _report.Debug("rank: {0}", rank);

                int execResult = _toolsMgmt.Service.ExecuteJob(jobId);
                _report.Info("ExecuteJob() returned : {0}", execResult);

                //Wait for complete
                JobState js;
                _report.Debug("Wait for complete");
                while (true)
                {
                    js = _toolsMgmt.Service.GetJobStatus(jobId);
                    if (js == JobState.Canceled)
                    {
                        _report.Info("Cancelled");
                        break;
                    }
                    if (js == JobState.Complete)
                    {
                        _report.Success("Completed");
                        break;
                    }
                    if (js == JobState.Failed)
                    {
                        _report.Error("Failed");
                        break;
                    }
                    _report.Debug("State: {0}", js.ToString());

                    System.Threading.Thread.Sleep(1000);
                }

                ActionResult result = _toolsMgmt.Service.GetActionResult(jobId, 0);
                _report.Info("ReturnCode: {0}", result.returnCode);
                _report.Debug("Output:");
                _report.Debug(result.consoleOutput);
                result = _toolsMgmt.Service.GetActionResult(jobId, 1);
                _report.Info("ReturnCode: {0}", result.returnCode);
                _report.Debug("Output:");
                _report.Debug(result.consoleOutput);
                _toolsMgmt.Service.CleanupJob((ulong)jobId);


                if (_titleProppedDict.ContainsKey(titleID) == false)
                {
                    _titleProppedDict.Add(titleID, true);
                }
            }
        }

        #endregion

        public XLTransTestBase()
        {
            XmlNode xlTransTestConfig = Global.Config.SelectSingleNode("descendant::XLTransTest");

            XmlElement tempXmlElement;

            _localStartPoint = DefaultLocalStartPoint;
            tempXmlElement = (XmlElement)xlTransTestConfig.SelectSingleNode("LocalStartPoint");
            if(tempXmlElement != null)
            {
                _localStartPoint = tempXmlElement.InnerText;
            }

            _localEndPoint = DefaultLocalEndPoint;
            tempXmlElement = (XmlElement)xlTransTestConfig.SelectSingleNode("LocalEndPoint");
            if(tempXmlElement != null)
            {
                _localEndPoint = tempXmlElement.InnerText;
            }

            _remoteStartPoint = DefaultRemoteStartPoint;
            tempXmlElement = (XmlElement)xlTransTestConfig.SelectSingleNode("RemoteStartPoint");
            if(tempXmlElement != null)
            {
                _remoteStartPoint = tempXmlElement.InnerText;
            }

            _remoteEndPoint = DefaultRemoteEndPoint;
            tempXmlElement = (XmlElement)xlTransTestConfig.SelectSingleNode("RemoteEndPoint");
            if(tempXmlElement != null)
            {
                _remoteEndPoint = tempXmlElement.InnerText;
            }

            _remoteLongEndPoint = DefaultRemoteLongEndPoint;
            tempXmlElement = (XmlElement)xlTransTestConfig.SelectSingleNode("RemoteLongEndPoint");
            if(tempXmlElement != null)
            {
                _remoteLongEndPoint = tempXmlElement.InnerText;
            }

            _sshStartPoint = DefaultSshStartPoint;
            tempXmlElement = (XmlElement)xlTransTestConfig.SelectSingleNode("SshStartPoint");
            if (tempXmlElement != null)
            {
                _sshStartPoint = tempXmlElement.InnerText;
            }

            _sshEndPoint = DefaultSshEndPoint;
            tempXmlElement = (XmlElement)xlTransTestConfig.SelectSingleNode("SshEndPoint");
            if (tempXmlElement != null)
            {
                _sshEndPoint = tempXmlElement.InnerText;
            }

            _invalidLocalEndPoint = DefaultInvalidLocalEndPoint;
            tempXmlElement = (XmlElement)xlTransTestConfig.SelectSingleNode("InvalidLocalEndPoint");
            if(tempXmlElement != null)
            {
                _invalidLocalEndPoint = tempXmlElement.InnerText;
            }

            _invalidRemoteEndPoint = DefaultInvalidRemoteEndPoint;
            tempXmlElement = (XmlElement)xlTransTestConfig.SelectSingleNode("InvalidRemoteEndPoint");
            if (tempXmlElement != null)
            {
                _invalidRemoteEndPoint = tempXmlElement.InnerText;
            }

            _invalidEndPointString = DefaultInvalidEndPointString;
            tempXmlElement = (XmlElement)xlTransTestConfig.SelectSingleNode("InvalidEndPointString");
            if(tempXmlElement != null)
            {
                _invalidEndPointString = tempXmlElement.InnerText;
            }

            _certificate = null;
            XmlElement clientCertificate = (XmlElement)xlTransTestConfig.SelectSingleNode("ClientCertificateFile");
            if (clientCertificate != null)
            {
                try
                {
                    _certificate = X509Certificate.CreateFromCertFile(clientCertificate.InnerText);
                }
                catch (Exception e)
                {
                    throw new ApplicationException(string.Format("Failed to load client certificate {0} specified in config file.  Error = {1}.  Tests will likely fail if being performed through a WebSG.", clientCertificate.InnerText, e.Message), e);
                }
            }

            _xlTransAddress = null;
            XmlElement xlTransAddress = (XmlElement)xlTransTestConfig.SelectSingleNode("XLTransAddress");
            if (xlTransAddress != null)
            {
                //  If cert is null, then we're talking directly to xltrans on port 0
                //  Otherwise we're going through websg on port 443
                int port = (_certificate == null ? 80 : 443);

                IPAddress addr;

                try
                {
                    if (xlTransAddress.InnerText.IndexOf(":") != -1)
                    {
                        string[] components = xlTransAddress.InnerText.Split(':');
                        addr = IPAddress.Parse(components[0]);
                        port = Int32.Parse(components[1]);
                    }
                    else
                    {
                        addr = IPAddress.Parse(xlTransAddress.InnerText);
                    }

                    _xlTransAddress = new IPEndPoint(addr, port);
                }
                catch (FormatException)
                {
                    IPHostEntry host = Dns.GetHostEntry(xlTransAddress.InnerText);
                    if (host != null)
                    {
                        _xlTransAddress = new IPEndPoint(host.AddressList[0], port);
                    }
                }
            }

            if (_xlTransAddress == null)
                _xlTransAddress = Global.XEnv.GetVirtualInterface(VirtualInterface.wctoolsmgmt);

            //if (_certificate != null)
            //    _service = new XLTransImpl(_xlTransAddress, _certificate);
            //else
                _service = new XLTransImpl(_xlTransAddress);

            //_service.Credentials = System.Net.CredentialCache.DefaultCredentials;
        }

        protected TransferState WaitForComplete(long transferId)
        {
            return WaitForComplete(transferId, -1);
        }

        protected TransferState WaitForComplete(long transferId, int timeout)
        {
            TransferState ts = TransferState.NotFound;
            DateTime startTime = DateTime.Now;
            int notFoundCount = 0;

            bool keepRunning = true;
            while (keepRunning == true)
            {
                ts = GetTransferStatusSafe(transferId);
                switch (ts)
                {
                    case TransferState.Complete:
                        keepRunning = false;
                        notFoundCount = 0;
                        _report.Success("TranferStatus = {0}", ts.ToString());
                        break;
                    case TransferState.Failed:
                        keepRunning = false;
                        notFoundCount = 0;
                        _report.Error("TranferStatus = {0}", ts.ToString());
                        break;
                    case TransferState.NotFound:
                        notFoundCount++;
                        if (notFoundCount > MaxNotFoundAllowed)
                            keepRunning = false;
                        _report.Debug("TranferStatus = {0}", ts.ToString());
                        break;
                    default:
                        notFoundCount = 0;
                        _report.Debug("TranferStatus = {0}", ts.ToString());
                        break;
                }
                if (timeout >= 0)
                {
                    if (startTime.AddSeconds(timeout) > DateTime.Now)
                        keepRunning = false;
                }
                System.Threading.Thread.Sleep(1000);
            }

            return ts;
        }

        protected TransferStatus WaitForCompleteEx(long transferId)
        {
            return WaitForCompleteEx(transferId, -1);
        }

        protected TransferStatus WaitForCompleteEx(long transferId, int timeout)
        {
            return WaitForCompleteEx(transferId, timeout, 1000);
        }

        protected TransferStatus WaitForCompleteEx(long transferId, int timeout, int sleepTime)
        {
            TransferStatus ts = new TransferStatus();
            ts.state = TransferState.NotFound;
            DateTime startTime = DateTime.Now;
            int notFoundCount = 0;

            bool keepRunning = true;
            while (keepRunning == true)
            {
                System.Threading.Thread.Sleep(sleepTime);
                ts = GetTransferStatusExSafe(transferId);
                switch (ts.state)
                {
                    case TransferState.Complete:
                        keepRunning = false;
                        notFoundCount = 0;
                        _report.Success("TranferStatusEx = {0}:{1}", ts.state.ToString(), ts.message);
                        break;
                    case TransferState.Failed:
                        keepRunning = false;
                        notFoundCount = 0;
                        _report.Error("TranferStatusEx = {0}:{1}", ts.state.ToString(), ts.message);
                        break;
                    case TransferState.NotFound:
                        notFoundCount++;
                        if (notFoundCount > MaxNotFoundAllowed)
                            keepRunning = false;
                        _report.Debug("TranferStatusEx = {0}:{1}", ts.state.ToString(), ts.message);
                        break;
                    default:
                        notFoundCount = 0;
                        _report.Debug("TranferStatusEx = {0}:{1}", ts.state.ToString(), ts.message);
                        break;
                }
                if (timeout >= 0)
                {
                    if (startTime.AddSeconds(timeout) > DateTime.Now)
                        keepRunning = false;
                }
            }

            return ts;
        }

        protected TransferStatus[] WaitForCompleteEx(long[] transferIds)
        {
            return WaitForCompleteEx(transferIds, -1);
        }

        protected TransferStatus[] WaitForCompleteEx(long[] transferIds, int timeout)
        {
            return WaitForCompleteEx(transferIds, timeout, 1000);
        }

        protected TransferStatus[] WaitForCompleteEx(long[] transferIds, int timeout, int sleepTime)
        {
            int numTransfers = transferIds.Length;
            int transferIter = 0;
            int[] notFoundCount = new int[numTransfers];
            TransferStatus[] transferStatus = new TransferStatus[numTransfers];
            for (transferIter = 0; transferIter < numTransfers; transferIter++)
            {
                transferStatus[transferIter] = new TransferStatus();
                transferStatus[transferIter].state = TransferState.NotFound;
                notFoundCount[transferIter] = 0;
            }
            DateTime startTime = DateTime.Now;

            bool keepRunning = true;
            bool transferRunning = true;
            while ((keepRunning == true) && (transferRunning == true))
            {
                System.Threading.Thread.Sleep(sleepTime);
                transferRunning = false;
                string debugState = "Current Status:\n";
                for (transferIter = 0; transferIter < numTransfers; transferIter++)
                {
                    transferStatus[transferIter] = GetTransferStatusExSafe(transferIds[transferIter]);
                    debugState += string.Format("{0} = {1}:{2}\t", transferIter, transferStatus[transferIter].state.ToString(), transferStatus[transferIter].message);
                    if (transferIter % 6 == 5)
                        debugState += "\n";
                    switch (transferStatus[transferIter].state)
                    {
                        case TransferState.Complete:
                            notFoundCount[transferIter] = 0;
                            break;
                        case TransferState.Failed:
                            notFoundCount[transferIter] = 0;
                            break;
                        case TransferState.NotFound:
                            transferRunning = true;
                            notFoundCount[transferIter]++;
                            if (notFoundCount[transferIter] > MaxNotFoundAllowed)
                            {
                                keepRunning = false;
                            }
                            break;
                        default:
                            transferRunning = true;
                            notFoundCount[transferIter] = 0;
                            break;
                    }
                }
                _report.Debug(debugState);
                if (timeout >= 0)
                {
                    if (startTime.AddSeconds(timeout) > DateTime.Now)
                        keepRunning = false;
                }
            }

            return transferStatus;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\xlTransTest\xlTransSuite.cs ===
using System;
using ServerTestFramework;

namespace XLTransTest
{
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\xlTransTest\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\xlTransTest\XLTransPositive.cs ===
using System;
using System.IO;
using System.Net;
using System.Reflection;
using System.Security.Cryptography.X509Certificates;
using System.Xml;

using ServerTestFramework;
using ServerTestFramework.Utilities;
using xonline.common.config;
using xonline.tools.xltrans.test;

namespace XLTransTest
{
    /// <summary>
    /// Summary description for XLTransTestPositive.
    /// </summary>
    /// 
    [TestGroup, Owner("mifish"), TestFrequency("Daily"), EnvRequirement("Deprecated")]
    public class XLTransTestPositive : TestNode
    {
        [TestCase, DVT]
        public class LocalToRemote_Pos : XLTransTestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;
                TransferState ts;
                long transferResult;
                string testFile = _testFile;

                try
                {
                    transferResult = TransferFile(LocalStartPoint, testFile, RemoteEndPoint, testFile);
                    _report.Debug("Transfer ID: " + transferResult.ToString());

                    ts = WaitForComplete(transferResult);

                    if (ts != TransferState.Complete)
                    {
                        throw new System.Exception("GetTransferStatus returned: " + ts.ToString());
                    }
                    ResultCode = TEST_RESULTS.PASSED;
                }
                catch(System.Exception excep)
                {
                    _report.Error(excep.ToString());
                }
            }
        }

        [TestCase]
        public class RemoteToLocalEX : XLTransTestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;
                TransferStatus ts;
                long transferResult;
                string testFile = _testFile;

                try
                {
                    transferResult = TransferFile(RemoteStartPoint, testFile, LocalEndPoint, testFile);
                    _report.Debug("Transfer ID: " + transferResult.ToString());

                    ts = WaitForCompleteEx(transferResult);

                    if (ts.state != TransferState.Complete)
                    {
                        throw new System.Exception( String.Format("GetTransferStatus returned: {0}:{1}:{2}", ts.state.ToString(), ts.message,ts.errorcode));
                    }
                    if (ts.message == "") 
                    {
                        throw new System.Exception("GetTransferStatusEx returned a blank string!!!!!");
                    }
                    ResultCode = TEST_RESULTS.PASSED;
                }
                catch (System.Exception excep)
                {
                    _report.Error(excep.ToString());
                }
            }
        }

        [TestCase]
        public class RemoteToSsh_Pos : XLTransTestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;
                TransferState ts;
                long transferResult;
                string testFile = _testFile;

                try
                {
                    transferResult = TransferFile(RemoteStartPoint, testFile, SshEndPoint, testFile);
                    _report.Debug("Transfer ID: " + transferResult.ToString());

                    ts = WaitForComplete(transferResult);

                    if (ts != TransferState.Complete)
                    {
                        TransferStatus transState = GetTransferStatusEx(transferResult);
                        _report.Debug("GetTransferStatusEx returned: {0}:{1}:{2}", transState.state.ToString(), transState.message, transState.errorcode);
                        throw new System.Exception("GetTransferStatus returned: " + transState.ToString());
                    }
                    ResultCode = TEST_RESULTS.PASSED;
                }
                catch (System.Exception excep)
                {
                    _report.Error(excep.ToString());
                }
            }
        }

        [TestCase]
        public class SshToRemote_Pos : XLTransTestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;
                TransferState ts;
                long transferResult;
                string testFile = _testFile;

                try
                {
                    transferResult = TransferFile(SshStartPoint, testFile, RemoteEndPoint, testFile);
                    _report.Debug("Transfer ID: " + transferResult.ToString());

                    ts = WaitForComplete(transferResult);

                    if (ts != TransferState.Complete)
                    {
                        TransferStatus transState = GetTransferStatusEx(transferResult);
                        _report.Debug("GetTransferStatusEx returned: {0}:{1}:{2}", transState.state.ToString(), transState.message, transState.errorcode);
                        throw new System.Exception("GetTransferStatus returned: " + ts.ToString());
                    }
                    ResultCode = TEST_RESULTS.PASSED;
                }
                catch (System.Exception excep)
                {
                    _report.Error(excep.ToString());
                }
            }
        }

        [TestCase]
        public class JobIdTransfer_Pos : XLTransTestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;
                TransferState ts;
                long transferResult;
                string testFile = _testFile;
                Random rand = new Random(unchecked((int)DateTime.Now.Ticks));
                long jobId = (long)rand.Next();

                try
                {
                    transferResult = JobTransferFile(LocalStartPoint, testFile, RemoteEndPoint, jobId, testFile);
                    _report.Debug("Transfer ID: " + transferResult.ToString());

                    ts = WaitForComplete(transferResult);

                    if (ts != TransferState.Complete)
                    {
                        throw new System.Exception("GetTransferStatus returned: " + ts.ToString());
                    }
                    ResultCode = TEST_RESULTS.PASSED;
                }
                catch (System.Exception excep)
                {
                    _report.Error(excep.ToString());
                }
            }
        }

        [TestCase]
        public class LongSourceAddress_Pos : XLTransTestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;
                TransferState ts;
                long transferResult;
                string testFile = "LongPath.txt";

                try
                {
                    transferResult = TransferFile(RemoteLongEndPoint, testFile, LocalEndPoint, testFile);
                    _report.Debug("Transfer ID: " + transferResult.ToString());

                    ts = WaitForComplete(transferResult);

                    if (ts != TransferState.Complete)
                    {
                        throw new System.Exception("GetTransferStatus returned: " + ts.ToString());
                    }
                    ResultCode = TEST_RESULTS.PASSED;
                }
                catch (System.Exception excep)
                {
                    _report.Error(excep.ToString());
                }
            }
        }

        [TestCase]
        public class LongDestAddress_Pos : XLTransTestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;
                TransferState ts;
                long transferResult;
                string testFile = _testFile;

                try
                {
                    transferResult = TransferFile(LocalStartPoint, testFile, RemoteLongEndPoint, testFile);
                    _report.Debug("Transfer ID: " + transferResult.ToString());

                    ts = WaitForComplete(transferResult);

                    if (ts != TransferState.Complete)
                    {
                        throw new System.Exception("GetTransferStatus returned: " + ts.ToString());
                    }
                    ResultCode = TEST_RESULTS.PASSED;
                }
                catch (System.Exception excep)
                {
                    _report.Error(excep.ToString());
                }
            }
        }

        [TestCase]
        public class SmallFile_Pos : XLTransTestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;
                TransferState ts;
                long transferResult;
                string testFile = "testsmall.txt";

                try
                {
                    transferResult = TransferFile(LocalStartPoint, testFile, RemoteEndPoint, testFile);
                    _report.Debug("Transfer ID: " + transferResult.ToString());

                    ts = WaitForComplete(transferResult);

                    if (ts != TransferState.Complete)
                    {
                        throw new System.Exception("GetTransferStatus returned: " + ts.ToString());
                    }
                    ResultCode = TEST_RESULTS.PASSED;
                }
                catch (System.Exception excep)
                {
                    _report.Error(excep.ToString());
                }
            }
        }

        [TestCase]
        public class LargeFile_Pos : XLTransTestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;
                TransferState ts;
                long transferResult;
                string testFile = "h3_e32006_announce_large.wmv";
                //string testFile = @"TRDemo\534387D80DD00000.cab";
                
                try
                {
                    transferResult = TransferFile(LocalStartPoint, testFile, SshEndPoint, testFile);
                    _report.Debug("Transfer ID: " + transferResult.ToString());

                    ts = WaitForComplete(transferResult);

                    if (ts != TransferState.Complete)
                    {
                        throw new System.Exception("GetTransferStatus returned: " + ts.ToString());
                    }
                    ResultCode = TEST_RESULTS.PASSED;
                }
                catch (System.Exception excep)
                {
                    _report.Error(excep.ToString());
                }
            }
        }

        [TestCase]
        public class GetTransferStatus_Pos : XLTransTestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;
                TransferState ts;
                long transferResult;
                string testFile = _testFile;

                try
                {
                    transferResult = TransferFile(LocalStartPoint, testFile, RemoteEndPoint, testFile);
                    _report.Debug("Transfer ID: " + transferResult.ToString());

                    ts = WaitForComplete(transferResult);

                    if (ts != TransferState.Complete)
                    {
                        throw new System.Exception("GetTransferStatus returned: " + ts.ToString());
                    }
                    ResultCode = TEST_RESULTS.PASSED;
                }
                catch (System.Exception excep)
                {
                    _report.Error(excep.ToString());
                }
            }
        }

        [TestCase]
        public class GetPhysicalPath_Pos : XLTransTestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;
                TransferState ts;
                long transferResult;
                string testFile = _testFile;

                try
                {
                    transferResult = TransferFile(LocalStartPoint, testFile, RemoteEndPoint, testFile);
                    _report.Debug("Transfer ID: " + transferResult.ToString());

                    ts = WaitForComplete(transferResult);

                    if (ts != TransferState.Complete)
                    {
                        throw new System.Exception("GetTransferStatus returned: " + ts.ToString());
                    }
                    string filePath = GetPhysicalPath(RemoteEndPoint, testFile);
                    if (filePath.IndexOf(testFile, StringComparison.CurrentCultureIgnoreCase) < 0)
                    {
                        throw new System.Exception("GetPhysicalPath returned file path: " + filePath);
                    }
                    _report.Debug("GetPhysicalPath returned file path: " + filePath);
                    ResultCode = TEST_RESULTS.PASSED;
                }
                catch (System.Exception excep)
                {
                    _report.Error(excep.ToString());
                }
            }
        }

        [TestCase]
        public class GetFileStats_Pos : XLTransTestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;
                TransferState ts;
                long transferResult;
                string testFile = _testFile;

                try
                {
                    transferResult = TransferFile(LocalStartPoint, testFile, RemoteEndPoint, testFile);
                    _report.Debug("Transfer ID: " + transferResult.ToString());

                    ts = WaitForComplete(transferResult);

                    if (ts != TransferState.Complete)
                    {
                        throw new System.Exception("GetTransferStatus returned: " + ts.ToString());
                    }
                    FileStats fileStats = GetFileStats(RemoteEndPoint, testFile);
                    if (fileStats.Name != testFile)
                    {
                        throw new System.Exception("GetFileStats returned filename: " + fileStats.Name);
                    }
                    _report.Debug("fileStats.Name = " + fileStats.Name);
                    _report.Debug("fileStats.DirectoryName = " + fileStats.DirectoryName);
                    _report.Debug("fileStats.Length = " + fileStats.Length);
                    _report.Debug("fileStats.CreationTime = " + fileStats.CreationTime);
                    _report.Debug("fileStats.LastAccessTime = " + fileStats.LastAccessTime);
                    _report.Debug("fileStats.LastWriteTime = " + fileStats.LastWriteTime);
                    ResultCode = TEST_RESULTS.PASSED;
                }
                catch (System.Exception excep)
                {
                    _report.Error(excep.ToString());
                }
            }
        }

        [TestCase]
        public class DoublePeriodinFileName : XLTransTestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;
                TransferStatus ts;
                long transferResult;
                string testFile = "Halo2..Copy.png";

                try
                {
                    transferResult = TransferFile(LocalStartPoint, testFile, RemoteEndPoint, testFile);
                    _report.Debug("Transfer ID: " + transferResult.ToString());

                    ts = WaitForCompleteEx(transferResult);

                    if (ts.state != TransferState.Complete)
                    {
                        throw new System.Exception("GetTransferStatus returned: " + ts.ToString());
                    }
                    ResultCode = TEST_RESULTS.PASSED;
                }
                catch (System.Exception excep)
                {
                    _report.Error(excep.ToString());
                }
            }
        }

        [TestCase]
        public class MultipleFilesLocaltoRemote : XLTransTestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;
                int transferIter = 0;
                int numTransfers = 4;
                TransferStatus[] transferStatus = new TransferStatus[numTransfers];
                long[] transferIds = new long[numTransfers];
                string[] testFile = new string[numTransfers];
                testFile[0] = "masseffect_e3demo2006_HD720p.wmv";
                testFile[1] = "alanwake_720p60_51_15mbps.wmv";
                testFile[2] = "Alan_Wake_video.wmv";
                testFile[3] = "Alan_Wake_Teaser.wmv";
                
                try
                {
                    for (transferIter = 0; transferIter < numTransfers; transferIter++)
                    {
                        transferIds[transferIter] = TransferFile(LocalStartPoint, testFile[transferIter], RemoteEndPoint, testFile[transferIter]);
                        _report.Debug("Transfer{0} ID: {1}", transferIter, transferIds[transferIter].ToString());
                        System.Threading.Thread.Sleep(1000); // sleep so we make sure the large file starts before the two small to test for concurrency
                    }

                    // Wait for Complete
                    transferStatus = WaitForCompleteEx(transferIds);

                    // Check Result
                    for (transferIter = 0; transferIter < numTransfers; transferIter++)
                    {
                        if (transferStatus[transferIter].state != TransferState.Complete)
                        {
                            throw new System.Exception(String.Format("TranferStatus{0} = {1}:{2}",
                                            transferIter,
                                            transferStatus[transferIter].state.ToString(),
                                            transferStatus[transferIter].message));
                        }
                        else
                        {
                            _report.Success("TranferStatus{0} = {1}:{2}",
                                            transferIter,
                                            transferStatus[transferIter].state.ToString(),
                                            transferStatus[transferIter].message);
                        }
                    }
                    
                    ResultCode = TEST_RESULTS.PASSED;
                }
                catch (System.Exception excep)
                {
                    _report.Error(excep.ToString());
                }
            }
        }

        [TestCase]
        public class MultipleFilesRemotetoSsh : XLTransTestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;
                int transferIter = 0;
                int numTransfers = 4;
                TransferStatus[] transferStatus = new TransferStatus[numTransfers];
                long[] transferIds = new long[numTransfers];
                string[] testFile = new string[numTransfers];
                testFile[0] = "masseffect_e3demo2006_HD720p.wmv";
                testFile[1] = "alanwake_720p60_51_15mbps.wmv";
                testFile[2] = "Alan_Wake_video.wmv";
                testFile[3] = "Alan_Wake_Teaser.wmv";

                try
                {
                    for (transferIter = 0; transferIter < numTransfers; transferIter++)
                    {
                        transferIds[transferIter] = TransferFile(RemoteStartPoint, testFile[transferIter], SshStartPoint, testFile[transferIter]);
                        _report.Debug("Transfer{0} ID: {1}", transferIter, transferIds[transferIter].ToString());
                        System.Threading.Thread.Sleep(1000); // sleep so we make sure the large file starts before the two small to test for concurrency
                    }

                    // Wait for Complete
                    transferStatus = WaitForCompleteEx(transferIds);

                    // Check Result
                    for (transferIter = 0; transferIter < numTransfers; transferIter++)
                    {
                        if (transferStatus[transferIter].state != TransferState.Complete)
                        {
                            throw new System.Exception(String.Format("TranferStatus{0} = {1}:{2}",
                                            transferIter,
                                            transferStatus[transferIter].state.ToString(),
                                            transferStatus[transferIter].message));
                        }
                        else
                        {
                            _report.Success("TranferStatus{0} = {1}:{2}",
                                            transferIter,
                                            transferStatus[transferIter].state.ToString(),
                                            transferStatus[transferIter].message);
                        }
                    }

                    ResultCode = TEST_RESULTS.PASSED;
                }
                catch (System.Exception excep)
                {
                    _report.Error(excep.ToString());
                }
            }
        }

        [TestCase]
        public class MultipleFilesSshtoRemote : XLTransTestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;
                int transferIter = 0;
                int numTransfers = 4;
                TransferStatus[] transferStatus = new TransferStatus[numTransfers];
                long[] transferIds = new long[numTransfers];
                string[] testFile = new string[numTransfers];
                testFile[0] = "masseffect_e3demo2006_HD720p.wmv";
                testFile[1] = "alanwake_720p60_51_15mbps.wmv";
                testFile[2] = "Alan_Wake_video.wmv";
                testFile[3] = "Alan_Wake_Teaser.wmv";

                try
                {
                    for (transferIter = 0; transferIter < numTransfers; transferIter++)
                    {
                        transferIds[transferIter] = TransferFile(SshStartPoint, testFile[transferIter], RemoteEndPoint, testFile[transferIter]);
                        _report.Debug("Transfer{0} ID: {1}", transferIter, transferIds[transferIter].ToString());
                        System.Threading.Thread.Sleep(1000); // sleep so we make sure the large file starts before the two small to test for concurrency
                    }

                    // Wait for Complete
                    transferStatus = WaitForCompleteEx(transferIds);

                    // Check Result
                    for (transferIter = 0; transferIter < numTransfers; transferIter++)
                    {
                        if (transferStatus[transferIter].state != TransferState.Complete)
                        {
                            throw new System.Exception(String.Format("TranferStatus{0} = {1}:{2}",
                                            transferIter,
                                            transferStatus[transferIter].state.ToString(),
                                            transferStatus[transferIter].message));
                        }
                        else
                        {
                            _report.Success("TranferStatus{0} = {1}:{2}",
                                            transferIter,
                                            transferStatus[transferIter].state.ToString(),
                                            transferStatus[transferIter].message);
                        }
                    }

                    ResultCode = TEST_RESULTS.PASSED;
                }
                catch (System.Exception excep)
                {
                    _report.Error(excep.ToString());
                }
            }
        }

        [TestCase]
        public class SingleFileMultipleMove : XLTransTestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;
                int transferIter = 0;
                int numTransfers = 6;
                TransferStatus[] transferStatus = new TransferStatus[numTransfers];
                long[] transferIds = new long[numTransfers];
                string testFile = "masseffect_e3demo2006_HD720p.wmv";

                try
                {
                    transferIds[0] = TransferFile(RemoteStartPoint, testFile, LocalStartPoint, testFile);
                    _report.Debug("Transfer0 ID: {0}", transferIds[0].ToString());
                    System.Threading.Thread.Sleep(1000); // sleep so we make sure the large file starts before the two small to test for concurrency
                    transferIds[1] = TransferFile(LocalStartPoint, testFile, SshStartPoint, testFile);
                    _report.Debug("Transfer1 ID: {0}", transferIds[1].ToString());
                    transferIds[2] = TransferFile(SshStartPoint, testFile, RemoteStartPoint, testFile);
                    _report.Debug("Transfer2 ID: {0}", transferIds[2].ToString());
                    transferIds[3] = TransferFile(RemoteStartPoint, testFile, SshStartPoint, testFile);
                    _report.Debug("Transfer3 ID: {0}", transferIds[3].ToString());
                    transferIds[4] = TransferFile(SshStartPoint, testFile, LocalStartPoint, testFile);
                    _report.Debug("Transfer4 ID: {0}", transferIds[4].ToString());
                    transferIds[5] = TransferFile(LocalStartPoint, testFile, RemoteStartPoint, testFile);
                    _report.Debug("Transfer5 ID: {0}", transferIds[5].ToString());

                    // Wait for Complete
                    transferStatus = WaitForCompleteEx(transferIds);

                    // Check Result
                    for (transferIter = 0; transferIter < numTransfers; transferIter++)
                    {
                        if (transferStatus[transferIter].state != TransferState.Complete)
                        {
                            throw new System.Exception(String.Format("TranferStatus{0} = {1}:{2}",
                                            transferIter,
                                            transferStatus[transferIter].state.ToString(),
                                            transferStatus[transferIter].message));
                        }
                        else
                        {
                            _report.Success("TranferStatus{0} = {1}:{2}",
                                            transferIter,
                                            transferStatus[transferIter].state.ToString(),
                                            transferStatus[transferIter].message);
                        }
                    }

                    ResultCode = TEST_RESULTS.PASSED;
                }
                catch (System.Exception excep)
                {
                    _report.Error(excep.ToString());
                }
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\xlTransTest\XLTransToolsMgmt.cs ===
using System;
using System.IO;
using System.Net;
using System.Reflection;
using System.Security.Cryptography.X509Certificates;
using System.Xml;

using ServerTestFramework;
using ServerTestFramework.Utilities;
using xonline.common.config;
using xonline.tools.xltrans.test;
using xonline.server.webcache.toolsmgmt.test.dvt;

namespace XLTransTest
{
    /// <summary>
    /// Summary description for XLTransTestToolsMgmt.
    /// </summary>
    /// 
    [TestGroup, Owner("mifish"), TestFrequency("Daily"), EnvRequirement("Deprecated")]
    public class XLTransTestToolsMgmt : TestNode
    {
        [TestCase]
        public class XLTranstoToolsMgmt_Pos : XLTransTestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;
                int transferIter = 0;
                int numTransfers = 3;
                TransferStatus[] transferStatus = new TransferStatus[numTransfers];
                long[] transferIds = new long[numTransfers];
                string[] testFiles = new string[numTransfers];
                long jobId;
                JobInfo jobInfo;
                ActionInfo actionInfo;
                string titleID = "ffffab28";
                string offerID = titleID + "0BB00001";

                testFiles[0] = "Halo2.png";
                testFiles[1] = "itembox.png";
                testFiles[2] = titleID + ".xlast";
                PropTitle(titleID, false, testFiles);

                try
                {
                    // CreateJob
                    jobId = _toolsMgmt.Service.CreateJob("LiveContent job " + titleID.ToString(), out jobInfo);
                    _report.Info("JobId: {0}", jobId);

                    // TransferFiles
                    testFiles[0] = "0xFFFFAB28.MPlaceBanner.png";
                    testFiles[1] = "0xFFFFAB280BB00001.trailer.offer";
                    testFiles[2] = offerID + ".cab";
                    for (transferIter = 0; transferIter < numTransfers; transferIter++)
                    {
                        transferIds[transferIter] = JobTransferFile(RemoteStartPoint, testFiles[transferIter], SshStartPoint, jobId, testFiles[transferIter]);
                        _report.Debug("JobTransfer{0} ID: {1}", transferIter, transferIds[transferIter].ToString());
                    }

                    // Wait for Complete - The current orchestration uses a 3 second sleep
                    transferStatus = WaitForCompleteEx(transferIds, -1, 3000);

                    // Check Result
                    for (transferIter = 0; transferIter < numTransfers; transferIter++)
                    {
                        if (transferStatus[transferIter].state != TransferState.Complete)
                        {
                            throw new System.Exception(String.Format("TranferStatus{0} = {1}:{2}",
                                            transferIter,
                                            transferStatus[transferIter].state.ToString(),
                                            transferStatus[transferIter].message));
                        }
                        else
                        {
                            _report.Success("TranferStatus{0} = {1}:{2}",
                                            transferIter,
                                            transferStatus[transferIter].state.ToString(),
                                            transferStatus[transferIter].message);
                        }
                    }

                    // Run Toolsmgmt/LiveContent
                    actionInfo = _toolsMgmt.RunLiveContentBuild(jobId, titleID, testFiles[2], testFiles[1], offerID);
                    int rank = _toolsMgmt.Service.AddAction(actionInfo);
                    _report.Debug("rank: {0}", rank);

                    actionInfo = _toolsMgmt.RunLiveOfferProp(jobId, titleID, testFiles[1]);
                    rank = _toolsMgmt.Service.AddAction(actionInfo);
                    _report.Debug("rank: {0}", rank);

                    int execResult = _toolsMgmt.Service.ExecuteJob(jobId);
                    _report.Info("ExecuteJob() returned : {0}", execResult);

                    //Wait for complete
                    JobState js;
                    _report.Debug("Wait for complete");
                    while (true)
                    {
                        System.Threading.Thread.Sleep(1000);
                        js = _toolsMgmt.Service.GetJobStatus(jobId);
                        if (js == JobState.Canceled)
                        {
                            _report.Info("Cancelled");
                            break;
                        }
                        if (js == JobState.Complete)
                        {
                            _report.Success("Completed");
                            break;
                        }
                        if (js == JobState.Failed)
                        {
                            _report.Error("Failed");
                            break;
                        }
                        _report.Debug("ToolsMgmt State: {0}", js.ToString());
                    }

                    ActionResult result = _toolsMgmt.Service.GetActionResult(jobId, 0);
                    _report.Info("ReturnCode: {0}", result.returnCode);
                    _report.Debug("Output:");
                    _report.Debug(result.consoleOutput);
                    result = _toolsMgmt.Service.GetActionResult(jobId, 1);
                    _report.Info("ReturnCode: {0}", result.returnCode);
                    _report.Debug("Output:");
                    _report.Debug(result.consoleOutput);
                    _toolsMgmt.Service.CleanupJob((ulong)jobId);

                    ResultCode = TEST_RESULTS.PASSED;
                }
                catch (System.Exception excep)
                {
                    _report.Error(excep.ToString());
                }
            }
        }

        [TestCase]
        public class XLTranstoToolsMgmtZeroSleep_Pos : XLTransTestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;
                int transferIter = 0;
                int numTransfers = 3;
                TransferStatus[] transferStatus = new TransferStatus[numTransfers];
                long[] transferIds = new long[numTransfers];
                string[] testFiles = new string[numTransfers];
                long jobId;
                JobInfo jobInfo;
                ActionInfo actionInfo;
                string titleID = "ffffab28";
                string offerID = titleID + "0BB00001";

                testFiles[0] = "Halo2.png";
                testFiles[1] = "itembox.png";
                testFiles[2] = titleID + ".xlast";
                PropTitle(titleID, false, testFiles);

                try
                {
                    // TransferFiles
                    testFiles[0] = "0xFFFFAB28.MPlaceBanner.png";
                    testFiles[1] = "0xFFFFAB280BB00001.trailer.offer";
                    testFiles[2] = offerID + ".cab";

                    // CreateJob
                    jobId = _toolsMgmt.Service.CreateJob("LiveContent job " + titleID.ToString(), out jobInfo);
                    _report.Info("JobId: {0}", jobId);
                    // Run Toolsmgmt/LiveContent
                    actionInfo = _toolsMgmt.RunLiveContentBuild(jobId, titleID, testFiles[2], testFiles[1], offerID);
                    int rank = _toolsMgmt.Service.AddAction(actionInfo);
                    _report.Debug("rank: {0}", rank);

                    actionInfo = _toolsMgmt.RunLiveOfferProp(jobId, titleID, testFiles[1]);
                    rank = _toolsMgmt.Service.AddAction(actionInfo);
                    _report.Debug("rank: {0}", rank);

                    // Transfer Files
                    for (transferIter = 0; transferIter < numTransfers; transferIter++)
                    {
                        transferIds[transferIter] = JobTransferFile(RemoteStartPoint, testFiles[transferIter], SshStartPoint, jobId, testFiles[transferIter]);
                        _report.Debug("JobTransfer{0} ID: {1}", transferIter, transferIds[transferIter].ToString());
                    }

                    // Wait for Complete - The current orchestration uses a 3 second sleep
                    transferStatus = WaitForCompleteEx(transferIds, -1, 0);

                    // Check Result
                    for (transferIter = 0; transferIter < numTransfers; transferIter++)
                    {
                        if (transferStatus[transferIter].state != TransferState.Complete)
                        {
                            throw new System.Exception(String.Format("TranferStatus{0} = {1}:{2}",
                                            transferIter,
                                            transferStatus[transferIter].state.ToString(),
                                            transferStatus[transferIter].message));
                        }
                        else
                        {
                            _report.Success("TranferStatus{0} = {1}:{2}",
                                            transferIter,
                                            transferStatus[transferIter].state.ToString(),
                                            transferStatus[transferIter].message);
                        }
                    }

                    // Execute LiveContent
                    int execResult = _toolsMgmt.Service.ExecuteJob(jobId);
                    _report.Info("ExecuteJob() returned : {0}", execResult);

                    //Wait for complete
                    JobState js;
                    _report.Debug("Wait for complete");
                    while (true)
                    {
                        System.Threading.Thread.Sleep(1000);
                        js = _toolsMgmt.Service.GetJobStatus(jobId);
                        if (js == JobState.Canceled)
                        {
                            _report.Info("Cancelled");
                            break;
                        }
                        if (js == JobState.Complete)
                        {
                            _report.Success("Completed");
                            break;
                        }
                        if (js == JobState.Failed)
                        {
                            _report.Error("Failed");
                            break;
                        }
                        _report.Debug("ToolsMgmt State: {0}", js.ToString());
                    }

                    ActionResult result = _toolsMgmt.Service.GetActionResult(jobId, 0);
                    _report.Info("ReturnCode: {0}", result.returnCode);
                    _report.Debug("Output:");
                    _report.Debug(result.consoleOutput);
                    result = _toolsMgmt.Service.GetActionResult(jobId, 1);
                    _report.Info("ReturnCode: {0}", result.returnCode);
                    _report.Debug("Output:");
                    _report.Debug(result.consoleOutput);
                    _toolsMgmt.Service.CleanupJob((ulong)jobId);

                    ResultCode = TEST_RESULTS.PASSED;
                }
                catch (System.Exception excep)
                {
                    _report.Error(excep.ToString());
                }
            }
        }

        [TestCase]
        public class XLTranstoToolsMgmtTransferRunning_Neg : XLTransTestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;
                int transferIter = 0;
                int numTransfers = 3;
                //TransferStatus[] transferStatus = new TransferStatus[numTransfers];
                long[] transferIds = new long[numTransfers];
                string[] testFiles = new string[numTransfers];
                long jobId;
                JobInfo jobInfo;
                ActionInfo actionInfo;
                string titleID = "ffffab28";
                string offerID = titleID + "0BB00001";

                testFiles[0] = "Halo2.png";
                testFiles[1] = "itembox.png";
                testFiles[2] = titleID + ".xlast";
                PropTitle(titleID, false, testFiles);

                try
                {
                    // CreateJob
                    jobId = _toolsMgmt.Service.CreateJob("LiveContent job " + titleID.ToString(), out jobInfo);
                    _report.Info("JobId: {0}", jobId);

                    // TransferFiles
                    testFiles[0] = "0xFFFFAB28.MPlaceBanner.png";
                    testFiles[1] = "0xFFFFAB280BB00001.trailer.offer";
                    testFiles[2] = offerID + ".cab";
                    for (transferIter = 0; transferIter < numTransfers; transferIter++)
                    {
                        transferIds[transferIter] = JobTransferFile(RemoteStartPoint, testFiles[transferIter], SshStartPoint, jobId, testFiles[transferIter]);
                        _report.Debug("JobTransfer{0} ID: {1}", transferIter, transferIds[transferIter].ToString());
                    }

                    // Wait for Running - The current orchestration uses a 3 second sleep
                    bool keepRunning = true;
                    int notFoundCount = 0;
                    TransferStatus ts;
                    while (keepRunning == true)
                    {
                        ts = GetTransferStatusExSafe(transferIds[2]);
                        switch (ts.state)
                        {
                            case TransferState.Complete:
                                keepRunning = false;
                                notFoundCount = 0;
                                _report.Success("TranferStatusEx = {0}:{1}", ts.state.ToString(), ts.message);
                                break;
                            case TransferState.Failed:
                                keepRunning = false;
                                notFoundCount = 0;
                                _report.Error("TranferStatusEx = {0}:{1}", ts.state.ToString(), ts.message);
                                break;
                            case TransferState.Running:
                                keepRunning = false;
                                notFoundCount = 0;
                                _report.Info("TranferStatusEx = {0}:{1}", ts.state.ToString(), ts.message);
                                break;
                            case TransferState.NotFound:
                                notFoundCount++;
                                if (notFoundCount > MaxNotFoundAllowed)
                                    keepRunning = false;
                                _report.Debug("TranferStatusEx = {0}:{1}", ts.state.ToString(), ts.message);
                                break;
                            default:
                                notFoundCount = 0;
                                _report.Debug("TranferStatusEx = {0}:{1}", ts.state.ToString(), ts.message);
                                break;
                        }
                    }
                    System.Threading.Thread.Sleep(5000);

                    // Run Toolsmgmt/LiveContent
                    actionInfo = _toolsMgmt.RunLiveContentBuild(jobId, titleID, testFiles[2], testFiles[1], offerID);
                    int rank = _toolsMgmt.Service.AddAction(actionInfo);
                    _report.Debug("rank: {0}", rank);

                    actionInfo = _toolsMgmt.RunLiveOfferProp(jobId, titleID, testFiles[1]);
                    rank = _toolsMgmt.Service.AddAction(actionInfo);
                    _report.Debug("rank: {0}", rank);

                    int execResult = _toolsMgmt.Service.ExecuteJob(jobId);
                    _report.Info("ExecuteJob() returned : {0}", execResult);

                    //Wait for complete
                    JobState js;
                    _report.Debug("Wait for Toolsmgmt complete");
                    while (true)
                    {
                        System.Threading.Thread.Sleep(1000);
                        js = _toolsMgmt.Service.GetJobStatus(jobId);
                        if (js == JobState.Canceled)
                        {
                            _report.Info("Cancelled");
                            break;
                        }
                        if (js == JobState.Complete)
                        {
                            _report.Success("Completed");
                            break;
                        }
                        if (js == JobState.Failed)
                        {
                            _report.Error("Failed");
                            break;
                        }
                        _report.Debug("ToolsMgmt State: {0}", js.ToString());
                    }

                    ActionResult result = _toolsMgmt.Service.GetActionResult(jobId, 0);
                    _report.Info("ReturnCode: {0}", result.returnCode);
                    _report.Debug("Output:");
                    _report.Debug(result.consoleOutput);
                    result = _toolsMgmt.Service.GetActionResult(jobId, 1);
                    _report.Info("ReturnCode: {0}", result.returnCode);
                    _report.Debug("Output:");
                    _report.Debug(result.consoleOutput);
                    _toolsMgmt.Service.CleanupJob((ulong)jobId);

                    ResultCode = TEST_RESULTS.PASSED;
                }
                catch (System.Exception excep)
                {
                    _report.Error(excep.ToString());
                }
            }
        }

    }

    /// <summary>
    /// Summary description for XLTransTestToolsMgmt.
    /// </summary>
    /// 
    public class ToolsMgmtImpl : ToolsMgmtBase
    {
        protected override void Execute()
        {
        }

        public WCToolsMgmt Service
        {
            get { return _service; }
        }

        new public string GetActionTable()
        {
            return base.GetActionTable();
        }

        new public ulong BeginWork(string titleid, uint workType)
        {
            return base.BeginWork(titleid, workType);
        }

        new public bool WorkFilesReady(ulong workId, string relativePath)
        {
            return base.WorkFilesReady(workId, relativePath);
        }

        new public bool GetWorkStatus(ulong workId, ref int returnCode, ref string output)
        {
            return base.GetWorkStatus(workId, ref returnCode, ref output);
        }

        new public void PropWorkFile(string file, string relativePath)
        {
            base.PropWorkFile(file, relativePath);
        }

        new public void ClearOffers(string titleID)
        {
            base.ClearOffers(titleID);
        }

        new public void PropTitle(bool force)
        {
            base.PropTitle(force);
        }

        new public void PropTitle(string titleID, bool force, params string[] workFiles)
        {
            base.PropTitle(titleID, force, workFiles);
        }

        new public void PropLiveTitleOnly(string titleID, bool force, string xlastFilename, params string[] workFiles)
        {
            base.PropLiveTitleOnly(titleID, force, xlastFilename, workFiles);
        }

        new public string AddFilePath(long jobID, string filename)
        {
            return base.AddFilePath(jobID, filename);
        }

        new public ActionInfo RunLiveTitleDefault(long jobID, string titleID, string xlastFilename)
        {
            return base.RunLiveTitleDefault(jobID, titleID, xlastFilename);
        }

        new public ActionInfo RunLiveTitleDeploy(long jobID, string titleID, string xlastFilename)
        {
            return base.RunLiveTitleDeploy(jobID, titleID, xlastFilename);
        }

        new public ActionInfo RunLiveStatsDeploy(long jobID, string titleID)
        {
            return base.RunLiveStatsDeploy(jobID, titleID);
        }

        new public ActionInfo RunLiveMatchDeploy(long jobID, string titleID)
        {
            return base.RunLiveMatchDeploy(jobID, titleID);
        }

        new public ActionInfo RunLiveContentBuild(long jobID, string titleID, string cabFilename, string offerFilename, string offerID)
        {
            return base.RunLiveContentBuild(jobID, titleID, cabFilename, offerFilename, offerID);
        }

        new public ActionInfo RunLiveOfferProp(long jobID, string titleID, string offerFilename)
        {
            return base.RunLiveOfferProp(jobID, titleID, offerFilename);
        }

        new public ActionInfo CreateDirCdriveAction(long jobID)
        {
            return base.CreateDirCdriveAction(jobID);
        }

        new public ActionInfo CreateTypeOfferAction(long jobID, string fileName)
        {
            return base.CreateTypeOfferAction(jobID, fileName);
        }

        new public void WaitForWorkCompleted(ulong[] workIds, ref int[] returnCodes, ref string[] outputs)
        {
            base.WaitForWorkCompleted(workIds, ref returnCodes, ref outputs);
        }

        new public JobState[] WaitForJobsCompleted(long[] jobIDs)
        {
            return base.WaitForJobsCompleted(jobIDs);
        }

        new public JobState[] WaitForWorkandJobsCompleted(ulong[] workIds, ref int[] returnCodes, ref string[] outputs, long[] jobIDs)
        {
            return base.WaitForWorkandJobsCompleted(workIds, ref returnCodes, ref outputs, jobIDs);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\xlTransTest\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_xltranstest_none_12.4.56.0_none_245c075dea7419b5
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_xltranstest_no-public-key_12.4.56.0_x-ww_aa5be849
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xltranstest
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_xltranstest_no-public-key_12.4.56.0_x-ww_aa5be849
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_xltranstest_no-public-key_12.4.56.0_x-ww_aa5be849.manifest
XP_MANIFEST_PATH=manifests\msil_xltranstest_no-public-key_12.4.56.0_x-ww_aa5be849.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_xltranstest_no-public-key_12.4.56.0_x-ww_aa5be849.cat
XP_CATALOG_PATH=manifests\msil_xltranstest_no-public-key_12.4.56.0_x-ww_aa5be849.cat
XP_PAYLOAD_PATH=msil_xltranstest_no-public-key_12.4.56.0_x-ww_aa5be849
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xltranstest,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\xlTransTest\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_xltranstest_none_12.4.56.0_none_245c075dea7419b5
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_xltranstest_no-public-key_12.4.56.0_x-ww_aa5be849
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xltranstest
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_xltranstest_no-public-key_12.4.56.0_x-ww_aa5be849
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_xltranstest_no-public-key_12.4.56.0_x-ww_aa5be849.manifest
XP_MANIFEST_PATH=manifests\msil_xltranstest_no-public-key_12.4.56.0_x-ww_aa5be849.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_xltranstest_no-public-key_12.4.56.0_x-ww_aa5be849.cat
XP_CATALOG_PATH=manifests\msil_xltranstest_no-public-key_12.4.56.0_x-ww_aa5be849.cat
XP_PAYLOAD_PATH=msil_xltranstest_no-public-key_12.4.56.0_x-ww_aa5be849
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xltranstest,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\xlTransTest\XLTransNegative.cs ===
using System;
using System.IO;
using System.Net;
using System.Reflection;
using System.Security.Cryptography.X509Certificates;
using System.Xml;

using ServerTestFramework;
using ServerTestFramework.Utilities;
using xonline.common.config;
using xonline.tools.xltrans.test;

namespace XLTransTest
{
    /// <summary>
    /// Summary description for XLTransTestNegative.
    /// </summary>
    /// 
    [TestGroup, Owner("mifish"), TestFrequency("Daily"), EnvRequirement("Deprecated")]
    public class XLTransTestNegative : TestNode
    {
        [TestCase]
        public class InvalidLocalSource_Neg : XLTransTestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;
                TransferState ts;
                long transferResult;
                string testFile = _testFile;
                string errorMsg = "Could not find a part of the path";

                try
                {
                    transferResult = TransferFile(InvalidLocalEndPoint, testFile, RemoteEndPoint, testFile);

                    ts = GetTransferStatus(transferResult);
                    _report.Debug("TranferStatus = " + ts.ToString());
                    while ((ts == TransferState.Pending) || (ts == TransferState.Running))
                    {
                        System.Threading.Thread.Sleep(1000);
                        ts = GetTransferStatus(transferResult);
                        _report.Debug("TranferStatus = " + ts.ToString());
                    }

                    if (ts != TransferState.Failed)
                    {
                        throw new System.Exception("GetTransferStatus returned: " + ts.ToString());
                    }
                    TransferStatus transState = GetTransferStatusEx(transferResult);
                    _report.Debug("GetTransferStatus returned: {0}:{1}:{2}", transState.state.ToString(), transState.message, transState.errorcode);
                    if (transState.message.IndexOf(errorMsg, StringComparison.CurrentCultureIgnoreCase) < 0)
                    {
                        _report.Error("Expected Error message: " + errorMsg);   
                        _report.Error("Received Error message: " + transState.message);
                        throw new System.Exception("GetTransferStatusEx returned incorrect Error message: " + transState.message);
                    }
                    ResultCode = TEST_RESULTS.PASSED;
                }
                catch (System.Exception excep)
                {
                    _report.Error(excep.ToString());
                }
            }
        }

        [TestCase]
        public class InvalidLocalDest_Neg : XLTransTestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;
                TransferState ts;
                long transferResult;
                string testFile = _testFile;
                string errorMsg = "Could not find a part of the path";

                try
                {
                    transferResult = TransferFile(RemoteStartPoint, testFile, InvalidLocalEndPoint, testFile);

                    ts = GetTransferStatus(transferResult);
                    _report.Debug("TranferStatus = " + ts.ToString());
                    while ((ts == TransferState.Pending) || (ts == TransferState.Running))
                    {
                        System.Threading.Thread.Sleep(1000);
                        ts = GetTransferStatus(transferResult);
                        _report.Debug("TranferStatus = " + ts.ToString());
                    }

                    if (ts != TransferState.Failed)
                    {
                        throw new System.Exception("GetTransferStatus returned: " + ts.ToString());
                    }
                    TransferStatus transState = GetTransferStatusEx(transferResult);
                    _report.Debug("GetTransferStatus returned: {0}:{1}:{2}", transState.state.ToString(), transState.message, transState.errorcode);
                    if (transState.message.IndexOf(errorMsg, StringComparison.CurrentCultureIgnoreCase) < 0)
                    {
                        _report.Error("Expected Error message: " + errorMsg);
                        _report.Error("Received Error message: " + transState.message);
                        throw new System.Exception("GetTransferStatusEx returned incorrect Error message: " + transState.message);
                    }
                    ResultCode = TEST_RESULTS.PASSED;
                }
                catch (System.Exception excep)
                {
                    _report.Error(excep.ToString());
                }
            }
        }

        [TestCase]
        public class InvalidRemoteSource_Neg : XLTransTestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;
                TransferState ts;
                long transferResult;
                string testFile = _testFile;
                string errorMsg = "The network path was not found";

                try
                {
                    transferResult = TransferFile(InvalidRemoteEndPoint, testFile, RemoteEndPoint, testFile);

                    ts = GetTransferStatus(transferResult);
                    _report.Debug("TranferStatus = " + ts.ToString());
                    while ((ts == TransferState.Pending) || (ts == TransferState.Running))
                    {
                        System.Threading.Thread.Sleep(1000);
                        ts = GetTransferStatus(transferResult);
                        _report.Debug("TranferStatus = " + ts.ToString());
                    }

                    if (ts != TransferState.Failed)
                    {
                        throw new System.Exception("GetTransferStatus returned: " + ts.ToString());
                    }
                    TransferStatus transState = GetTransferStatusEx(transferResult);
                    _report.Debug("GetTransferStatus returned: {0}:{1}:{2}", transState.state.ToString(), transState.message, transState.errorcode);
                    if (transState.message.IndexOf(errorMsg, StringComparison.CurrentCultureIgnoreCase) < 0)
                    {
                        _report.Error("Expected Error message: " + errorMsg);
                        _report.Error("Received Error message: " + transState.message);
                        throw new System.Exception("GetTransferStatusEx returned incorrect Error message: " + transState.message);
                    }
                    ResultCode = TEST_RESULTS.PASSED;
                }
                catch (System.Exception excep)
                {
                    _report.Error(excep.ToString());
                }
            }
        }

        [TestCase]
        public class InvalidRemoteDest_Neg : XLTransTestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;
                TransferState ts;
                long transferResult;
                string testFile = _testFile;
                string errorMsg = "The network path was not found";

                try
                {
                    transferResult = TransferFile(RemoteStartPoint, testFile, InvalidRemoteEndPoint, testFile);

                    ts = GetTransferStatus(transferResult);
                    _report.Debug("TranferStatus = " + ts.ToString());
                    while ((ts == TransferState.Pending) || (ts == TransferState.Running))
                    {
                        System.Threading.Thread.Sleep(1000);
                        ts = GetTransferStatus(transferResult);
                        _report.Debug("TranferStatus = " + ts.ToString());
                    }

                    if (ts != TransferState.Failed)
                    {
                        throw new System.Exception("GetTransferStatus returned: " + ts.ToString());
                    }
                    TransferStatus transState = GetTransferStatusEx(transferResult);
                    _report.Debug("GetTransferStatus returned: {0}:{1}:{2}", transState.state.ToString(), transState.message, transState.errorcode);
                    if (transState.message.IndexOf(errorMsg, StringComparison.CurrentCultureIgnoreCase) < 0)
                    {
                        _report.Error("Expected Error message: " + errorMsg);
                        _report.Error("Received Error message: " + transState.message);
                        throw new System.Exception("GetTransferStatusEx returned incorrect Error message: " + transState.message);
                    }
                    ResultCode = TEST_RESULTS.PASSED;
                }
                catch (System.Exception excep)
                {
                    _report.Error(excep.ToString());
                }
            }
        }

        [TestCase]
        public class InvalidSourceString_Neg : XLTransTestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;
                TransferState ts;
                long transferResult;
                string testFile = _testFile;
                string errorMsg = "Unknown Source Endpoint";

                try
                {
                    transferResult = TransferFile(InvalidEndPointString, testFile, RemoteEndPoint, testFile);

                    ts = GetTransferStatus(transferResult);
                    _report.Debug("TranferStatus = " + ts.ToString());
                    while ((ts == TransferState.Pending) || (ts == TransferState.Running))
                    {
                        System.Threading.Thread.Sleep(1000);
                        ts = GetTransferStatus(transferResult);
                        _report.Debug("TranferStatus = " + ts.ToString());
                    }

                    if (ts != TransferState.Failed)
                    {
                        throw new System.Exception("GetTransferStatus returned: " + ts.ToString());
                    } 
                    TransferStatus transState = GetTransferStatusEx(transferResult);
                    _report.Debug("GetTransferStatus returned: {0}:{1}:{2}", transState.state.ToString(), transState.message, transState.errorcode);
                    if (transState.message.IndexOf(errorMsg, StringComparison.CurrentCultureIgnoreCase) < 0)
                    {
                        _report.Error("Expected Error message: " + errorMsg);
                        _report.Error("Received Error message: " + transState.message);
                        throw new System.Exception("GetTransferStatusEx returned incorrect Error message: " + transState.message);
                    }

                    ResultCode = TEST_RESULTS.PASSED;
                }
                catch (System.Exception excep)
                {
                    _report.Error(excep.ToString());
                }
            }
        }

        [TestCase]
        public class InvalidDestString_Neg : XLTransTestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;
                TransferState ts;
                long transferResult;
                string testFile = _testFile;
                string errorMsg = "Unknown Destination Endpoint";

                try
                {
                    transferResult = TransferFile(RemoteStartPoint, testFile, InvalidEndPointString, testFile);

                    ts = GetTransferStatus(transferResult);
                    _report.Debug("TranferStatus = " + ts.ToString());
                    while ((ts == TransferState.Pending) || (ts == TransferState.Running))
                    {
                        System.Threading.Thread.Sleep(1000);
                        ts = GetTransferStatus(transferResult);
                        _report.Debug("TranferStatus = " + ts.ToString());
                    }

                    if (ts != TransferState.Failed)
                    {
                        throw new System.Exception("GetTransferStatus returned: " + ts.ToString());
                    }
                    TransferStatus transState = GetTransferStatusEx(transferResult);
                    _report.Debug("GetTransferStatus returned: {0}:{1}:{2}", transState.state.ToString(), transState.message, transState.errorcode);
                    if (transState.message.IndexOf(errorMsg, StringComparison.CurrentCultureIgnoreCase) < 0)
                    {
                        _report.Error("Expected Error message: " + errorMsg);
                        _report.Error("Received Error message: " + transState.message);
                        throw new System.Exception("GetTransferStatusEx returned incorrect Error message: " + transState.message);
                    }
                    ResultCode = TEST_RESULTS.PASSED;
                }
                catch (System.Exception excep)
                {
                    _report.Error(excep.ToString());
                }
            }
        }

        [TestCase]
        public class GetTransferStatusInvalidJobID_Neg : XLTransTestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;
                TransferState ts;
                long transferResult = 10;
                string errorMsg = "Transfer not found";

                try
                {
                    ts = GetTransferStatus(transferResult);
                    _report.Debug("TranferStatus = " + ts.ToString());
                    while ((ts == TransferState.Pending) || (ts == TransferState.Running))
                    {
                        System.Threading.Thread.Sleep(1000);
                        ts = GetTransferStatus(transferResult);
                        _report.Debug("TranferStatus = " + ts.ToString());
                    }

                    if (ts != TransferState.NotFound)
                    {
                        throw new System.Exception("GetTransferStatus returned: " + ts.ToString());
                    }
                    TransferStatus transState = GetTransferStatusEx(transferResult);
                    _report.Debug("GetTransferStatus returned: {0}:{1}:{2}", transState.state.ToString(), transState.message, transState.errorcode);
                    if (transState.message.IndexOf(errorMsg, StringComparison.CurrentCultureIgnoreCase) < 0)
                    {
                        _report.Error("Expected Error message: " + errorMsg);
                        _report.Error("Received Error message: " + transState.message);
                        throw new System.Exception("GetTransferStatusEx returned incorrect Error message: " + transState.message);
                    }
                    ResultCode = TEST_RESULTS.PASSED;
                }
                catch (System.Exception excep)
                {
                    _report.Error(excep.ToString());
                }
            }
        }

        [TestCase]
        public class WildCardFilename : XLTransTestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;
                TransferStatus ts;
                long transferResult;
                string testFile = @"al\*.wmv";
                string errorMsg = "Illegal characters in path";

                try
                {
                    transferResult = TransferFile(LocalStartPoint, testFile, RemoteEndPoint, testFile);

                    ts = GetTransferStatusEx(transferResult);
                    _report.Debug("TranferStatus={0}:{1}", ts.state.ToString(), ts.message);
                    while ((ts.state == TransferState.Pending) || (ts.state == TransferState.Running))
                    {
                        System.Threading.Thread.Sleep(1000);
                        ts = GetTransferStatusEx(transferResult);
                        _report.Debug("TranferStatus={0}:{1}", ts.state.ToString(), ts.message);
                    }

                    if (ts.state != TransferState.Failed)
                    {
                        throw new System.Exception("GetTransferStatus returned: " + ts.ToString());
                    }
                    if (ts.message.IndexOf(errorMsg, StringComparison.CurrentCultureIgnoreCase) < 0)
                    {
                        _report.Error("Expected Error message: " + errorMsg);
                        _report.Error("Received Error message: " + ts.message);
                        throw new System.Exception("GetTransferStatusEx returned incorrect Error message: " + ts.message);
                    }
                    ResultCode = TEST_RESULTS.PASSED;
                }
                catch (System.Exception excep)
                {
                    _report.Error(excep.ToString());
                }
            }
        }

        [TestCase]
        public class InvalidCharacters : XLTransTestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;
                TransferStatus ts;
                long transferResult;
                string testFile = @"!@#$%^&*()_+-=[]\\;',./{}|:""<>?";
                string errorMsg = "Illegal characters in path";

                try
                {
                    transferResult = TransferFile(LocalStartPoint, testFile, RemoteEndPoint, testFile);

                    ts = GetTransferStatusEx(transferResult);
                    _report.Debug("TranferStatus={0}:{1}", ts.state.ToString(), ts.message);
                    while ((ts.state == TransferState.Pending) || (ts.state == TransferState.Running))
                    {
                        System.Threading.Thread.Sleep(1000);
                        ts = GetTransferStatusEx(transferResult);
                        _report.Debug("TranferStatus={0}:{1}", ts.state.ToString(), ts.message);
                    }

                    if (ts.state != TransferState.Failed)
                    {
                        throw new System.Exception("GetTransferStatus returned: " + ts.ToString());
                    }
                    if (ts.message.IndexOf(errorMsg, StringComparison.CurrentCultureIgnoreCase) < 0)
                    {
                        _report.Error("Expected Error message: " + errorMsg);
                        _report.Error("Received Error message: " + ts.message);
                        throw new System.Exception("GetTransferStatusEx returned incorrect Error message: " + ts.message);
                    }
                    ResultCode = TEST_RESULTS.PASSED;
                }
                catch (System.Exception excep)
                {
                    _report.Error(excep.ToString());
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\xlTransTest\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\xlTransTest\XLTrans.cs ===
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.312
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by wsdl, Version=2.0.50727.42.
// 
namespace xonline.tools.xltrans.test {
    using System.Diagnostics;
    using System.Web.Services;
    using System.ComponentModel;
    using System.Web.Services.Protocols;
    using System;
    using System.Xml.Serialization;
    
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Web.Services.WebServiceBindingAttribute(Name="XlTransSoap", Namespace="http://websvc.xboxlive.com/xltrans/")]
    public partial class XlTrans : System.Web.Services.Protocols.SoapHttpClientProtocol {
        
        private System.Threading.SendOrPostCallback TransferFileOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetTransferStatusExOperationCompleted;
        
        private System.Threading.SendOrPostCallback JobTransferFileOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetTransferStatusOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetFileStatsOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetPhysicalPathOperationCompleted;
        
        /// <remarks/>
        public XlTrans() {
            this.Url = "http://paulram004/xltrans/xltrans.asmx";
        }
        
        /// <remarks/>
        public event TransferFileCompletedEventHandler TransferFileCompleted;
        
        /// <remarks/>
        public event GetTransferStatusExCompletedEventHandler GetTransferStatusExCompleted;
        
        /// <remarks/>
        public event JobTransferFileCompletedEventHandler JobTransferFileCompleted;
        
        /// <remarks/>
        public event GetTransferStatusCompletedEventHandler GetTransferStatusCompleted;
        
        /// <remarks/>
        public event GetFileStatsCompletedEventHandler GetFileStatsCompleted;
        
        /// <remarks/>
        public event GetPhysicalPathCompletedEventHandler GetPhysicalPathCompleted;
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/xltrans/TransferFile", RequestNamespace="http://websvc.xboxlive.com/xltrans/", ResponseNamespace="http://websvc.xboxlive.com/xltrans/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public long TransferFile(string sourceEndpoint, string sourceFilePath, string destEndpoint, string destFilePath) {
            object[] results = this.Invoke("TransferFile", new object[] {
                        sourceEndpoint,
                        sourceFilePath,
                        destEndpoint,
                        destFilePath});
            return ((long)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginTransferFile(string sourceEndpoint, string sourceFilePath, string destEndpoint, string destFilePath, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("TransferFile", new object[] {
                        sourceEndpoint,
                        sourceFilePath,
                        destEndpoint,
                        destFilePath}, callback, asyncState);
        }
        
        /// <remarks/>
        public long EndTransferFile(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((long)(results[0]));
        }
        
        /// <remarks/>
        public void TransferFileAsync(string sourceEndpoint, string sourceFilePath, string destEndpoint, string destFilePath) {
            this.TransferFileAsync(sourceEndpoint, sourceFilePath, destEndpoint, destFilePath, null);
        }
        
        /// <remarks/>
        public void TransferFileAsync(string sourceEndpoint, string sourceFilePath, string destEndpoint, string destFilePath, object userState) {
            if ((this.TransferFileOperationCompleted == null)) {
                this.TransferFileOperationCompleted = new System.Threading.SendOrPostCallback(this.OnTransferFileOperationCompleted);
            }
            this.InvokeAsync("TransferFile", new object[] {
                        sourceEndpoint,
                        sourceFilePath,
                        destEndpoint,
                        destFilePath}, this.TransferFileOperationCompleted, userState);
        }
        
        private void OnTransferFileOperationCompleted(object arg) {
            if ((this.TransferFileCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.TransferFileCompleted(this, new TransferFileCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/xltrans/GetTransferStatusEx", RequestNamespace="http://websvc.xboxlive.com/xltrans/", ResponseNamespace="http://websvc.xboxlive.com/xltrans/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public TransferStatus GetTransferStatusEx(long transferId) {
            object[] results = this.Invoke("GetTransferStatusEx", new object[] {
                        transferId});
            return ((TransferStatus)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetTransferStatusEx(long transferId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetTransferStatusEx", new object[] {
                        transferId}, callback, asyncState);
        }
        
        /// <remarks/>
        public TransferStatus EndGetTransferStatusEx(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((TransferStatus)(results[0]));
        }
        
        /// <remarks/>
        public void GetTransferStatusExAsync(long transferId) {
            this.GetTransferStatusExAsync(transferId, null);
        }
        
        /// <remarks/>
        public void GetTransferStatusExAsync(long transferId, object userState) {
            if ((this.GetTransferStatusExOperationCompleted == null)) {
                this.GetTransferStatusExOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetTransferStatusExOperationCompleted);
            }
            this.InvokeAsync("GetTransferStatusEx", new object[] {
                        transferId}, this.GetTransferStatusExOperationCompleted, userState);
        }
        
        private void OnGetTransferStatusExOperationCompleted(object arg) {
            if ((this.GetTransferStatusExCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetTransferStatusExCompleted(this, new GetTransferStatusExCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/xltrans/JobTransferFile", RequestNamespace="http://websvc.xboxlive.com/xltrans/", ResponseNamespace="http://websvc.xboxlive.com/xltrans/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public long JobTransferFile(string srcRootID, string srcFilePath, string dstRootID, long jobId, string dstFilePath) {
            object[] results = this.Invoke("JobTransferFile", new object[] {
                        srcRootID,
                        srcFilePath,
                        dstRootID,
                        jobId,
                        dstFilePath});
            return ((long)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginJobTransferFile(string srcRootID, string srcFilePath, string dstRootID, long jobId, string dstFilePath, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("JobTransferFile", new object[] {
                        srcRootID,
                        srcFilePath,
                        dstRootID,
                        jobId,
                        dstFilePath}, callback, asyncState);
        }
        
        /// <remarks/>
        public long EndJobTransferFile(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((long)(results[0]));
        }
        
        /// <remarks/>
        public void JobTransferFileAsync(string srcRootID, string srcFilePath, string dstRootID, long jobId, string dstFilePath) {
            this.JobTransferFileAsync(srcRootID, srcFilePath, dstRootID, jobId, dstFilePath, null);
        }
        
        /// <remarks/>
        public void JobTransferFileAsync(string srcRootID, string srcFilePath, string dstRootID, long jobId, string dstFilePath, object userState) {
            if ((this.JobTransferFileOperationCompleted == null)) {
                this.JobTransferFileOperationCompleted = new System.Threading.SendOrPostCallback(this.OnJobTransferFileOperationCompleted);
            }
            this.InvokeAsync("JobTransferFile", new object[] {
                        srcRootID,
                        srcFilePath,
                        dstRootID,
                        jobId,
                        dstFilePath}, this.JobTransferFileOperationCompleted, userState);
        }
        
        private void OnJobTransferFileOperationCompleted(object arg) {
            if ((this.JobTransferFileCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.JobTransferFileCompleted(this, new JobTransferFileCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/xltrans/GetTransferStatus", RequestNamespace="http://websvc.xboxlive.com/xltrans/", ResponseNamespace="http://websvc.xboxlive.com/xltrans/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public TransferState GetTransferStatus(long transferId) {
            object[] results = this.Invoke("GetTransferStatus", new object[] {
                        transferId});
            return ((TransferState)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetTransferStatus(long transferId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetTransferStatus", new object[] {
                        transferId}, callback, asyncState);
        }
        
        /// <remarks/>
        public TransferState EndGetTransferStatus(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((TransferState)(results[0]));
        }
        
        /// <remarks/>
        public void GetTransferStatusAsync(long transferId) {
            this.GetTransferStatusAsync(transferId, null);
        }
        
        /// <remarks/>
        public void GetTransferStatusAsync(long transferId, object userState) {
            if ((this.GetTransferStatusOperationCompleted == null)) {
                this.GetTransferStatusOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetTransferStatusOperationCompleted);
            }
            this.InvokeAsync("GetTransferStatus", new object[] {
                        transferId}, this.GetTransferStatusOperationCompleted, userState);
        }
        
        private void OnGetTransferStatusOperationCompleted(object arg) {
            if ((this.GetTransferStatusCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetTransferStatusCompleted(this, new GetTransferStatusCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/xltrans/GetFileStats", RequestNamespace="http://websvc.xboxlive.com/xltrans/", ResponseNamespace="http://websvc.xboxlive.com/xltrans/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public FileStats GetFileStats(string endpointName, string fileName) {
            object[] results = this.Invoke("GetFileStats", new object[] {
                        endpointName,
                        fileName});
            return ((FileStats)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetFileStats(string endpointName, string fileName, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetFileStats", new object[] {
                        endpointName,
                        fileName}, callback, asyncState);
        }
        
        /// <remarks/>
        public FileStats EndGetFileStats(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((FileStats)(results[0]));
        }
        
        /// <remarks/>
        public void GetFileStatsAsync(string endpointName, string fileName) {
            this.GetFileStatsAsync(endpointName, fileName, null);
        }
        
        /// <remarks/>
        public void GetFileStatsAsync(string endpointName, string fileName, object userState) {
            if ((this.GetFileStatsOperationCompleted == null)) {
                this.GetFileStatsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetFileStatsOperationCompleted);
            }
            this.InvokeAsync("GetFileStats", new object[] {
                        endpointName,
                        fileName}, this.GetFileStatsOperationCompleted, userState);
        }
        
        private void OnGetFileStatsOperationCompleted(object arg) {
            if ((this.GetFileStatsCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetFileStatsCompleted(this, new GetFileStatsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/xltrans/GetPhysicalPath", RequestNamespace="http://websvc.xboxlive.com/xltrans/", ResponseNamespace="http://websvc.xboxlive.com/xltrans/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string GetPhysicalPath(string endpointName, string fileName) {
            object[] results = this.Invoke("GetPhysicalPath", new object[] {
                        endpointName,
                        fileName});
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetPhysicalPath(string endpointName, string fileName, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetPhysicalPath", new object[] {
                        endpointName,
                        fileName}, callback, asyncState);
        }
        
        /// <remarks/>
        public string EndGetPhysicalPath(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void GetPhysicalPathAsync(string endpointName, string fileName) {
            this.GetPhysicalPathAsync(endpointName, fileName, null);
        }
        
        /// <remarks/>
        public void GetPhysicalPathAsync(string endpointName, string fileName, object userState) {
            if ((this.GetPhysicalPathOperationCompleted == null)) {
                this.GetPhysicalPathOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetPhysicalPathOperationCompleted);
            }
            this.InvokeAsync("GetPhysicalPath", new object[] {
                        endpointName,
                        fileName}, this.GetPhysicalPathOperationCompleted, userState);
        }
        
        private void OnGetPhysicalPathOperationCompleted(object arg) {
            if ((this.GetPhysicalPathCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetPhysicalPathCompleted(this, new GetPhysicalPathCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        public new void CancelAsync(object userState) {
            base.CancelAsync(userState);
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/xltrans/")]
    public partial class TransferStatus {
        
        private TransferState stateField;
        
        private int errorcodeField;
        
        private string messageField;
        
        /// <remarks/>
        public TransferState state {
            get {
                return this.stateField;
            }
            set {
                this.stateField = value;
            }
        }
        
        /// <remarks/>
        public int errorcode {
            get {
                return this.errorcodeField;
            }
            set {
                this.errorcodeField = value;
            }
        }
        
        /// <remarks/>
        public string message {
            get {
                return this.messageField;
            }
            set {
                this.messageField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/xltrans/")]
    public enum TransferState {
        
        /// <remarks/>
        NotFound,
        
        /// <remarks/>
        Failed,
        
        /// <remarks/>
        Pending,
        
        /// <remarks/>
        Running,
        
        /// <remarks/>
        Complete,
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/xltrans/")]
    public partial class FileStats {
        
        private string directoryNameField;
        
        private long lengthField;
        
        private string nameField;
        
        private System.DateTime creationTimeField;
        
        private System.DateTime lastAccessTimeField;
        
        private System.DateTime lastWriteTimeField;
        
        /// <remarks/>
        public string DirectoryName {
            get {
                return this.directoryNameField;
            }
            set {
                this.directoryNameField = value;
            }
        }
        
        /// <remarks/>
        public long Length {
            get {
                return this.lengthField;
            }
            set {
                this.lengthField = value;
            }
        }
        
        /// <remarks/>
        public string Name {
            get {
                return this.nameField;
            }
            set {
                this.nameField = value;
            }
        }
        
        /// <remarks/>
        public System.DateTime CreationTime {
            get {
                return this.creationTimeField;
            }
            set {
                this.creationTimeField = value;
            }
        }
        
        /// <remarks/>
        public System.DateTime LastAccessTime {
            get {
                return this.lastAccessTimeField;
            }
            set {
                this.lastAccessTimeField = value;
            }
        }
        
        /// <remarks/>
        public System.DateTime LastWriteTime {
            get {
                return this.lastWriteTimeField;
            }
            set {
                this.lastWriteTimeField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void TransferFileCompletedEventHandler(object sender, TransferFileCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class TransferFileCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal TransferFileCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public long Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((long)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetTransferStatusExCompletedEventHandler(object sender, GetTransferStatusExCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetTransferStatusExCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetTransferStatusExCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public TransferStatus Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((TransferStatus)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void JobTransferFileCompletedEventHandler(object sender, JobTransferFileCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class JobTransferFileCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal JobTransferFileCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public long Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((long)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetTransferStatusCompletedEventHandler(object sender, GetTransferStatusCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetTransferStatusCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetTransferStatusCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public TransferState Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((TransferState)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetFileStatsCompletedEventHandler(object sender, GetFileStatsCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetFileStatsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetFileStatsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public FileStats Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((FileStats)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetPhysicalPathCompletedEventHandler(object sender, GetPhysicalPathCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetPhysicalPathCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetPhysicalPathCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XMatchTest\ConfigDBTest.cs ===
using System;
using System.Collections;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using xonline.common.config;

namespace XMatchTest
{
    /// <summary>
    /// Summary description for ConfigDBTest.
    /// </summary>

    public class ConfigDBTest : TestNode
    {
        public ConfigDBTest()
        {
            ConfigTestBase.component = Component.xmatchfd;
            AddChild(new ConfigTestBase(Setting.xmatchfd_sessioncacheexpiration, "300"));//default is 300000
            AddChild(new ConfigTestBase(Setting.xmatchfd_relaxXenonValidation, "true"));//default is false
            AddChild(new ConfigTestBase(Setting.xmatchfd_defaultSessionExpiration, "300"));//default is 86400
            AddChild(new ConfigTestBase(Setting.xmatchfd_sessioncacheexpiration, "300"));
            AddChild(new ConfigTestBase(Setting.xmatchfd_disableAffiliateQuery, "true"));
            AddChild(new ConfigTestBase(Setting.xmatchfd_valueOfFriend, "5"));
            AddChild(new ConfigTestBase(Setting.xmatchfd_valueOfPositiveFeedback, "3"));
            AddChild(new ConfigTestBase(Setting.xmatchfd_valueOfCompletedGame, "3"));
            AddChild(new ConfigTestBase(Setting.xmatchfd_valueOfNegativeFeedback, "5"));
            AddChild(new ConfigTestBase(Setting.xmatchfd_valueOfAvoidingMe, "3"));
            AddChild(new ConfigTestBase(Setting.xmatchfd_enableTitlePerfCounters, "false"));
            AddChild(new ConfigTestBase(Setting.xmatchfd_nolockRetries, "5"));
            AddChild(new ConfigTestBase(Setting.xmatchfd_insertRetries, "5"));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XMatchTest\Func2RankedMatch.cs ===
using System;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.LiveService.Matchmaking;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.Utilities;
using xonline.common.config;
using xonline.common.protocol;

namespace XMatchTest
{
    internal abstract class RankedMatchTestBase : TestBase
    {
        protected bool validMuSigmaBase(double MuRange)
        {
            const int NUM_OTHER_SESSIONS = 95;
            bool	ret = true;
            double searchUserMu = 3, searchUserSigma = 0.01;
            double	nextRange = searchUserMu - MuRange;
            // create 1 session within next mu range 0.0048, with sigma value set to the same as searchUser
            // title defined int32 constant=88
            XRLXeAttribParam	[]		Attribs = new XRLXeAttribParam[10];
            Attribs[0] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_TYPE,new XRLXeIntValue(Constants.X_ATTRIBUTE_GAME_TYPE_RANKED));
            Attribs[1] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE, new XRLXeIntValue(Constants.CONTEXT_GAME_MODE_MODEA));
            Attribs[2] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_ZONE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_ZONE));
            Attribs[3] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_COUNTRY, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_COUNTRY));
            Attribs[4] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_LANGUAGE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_LANG));
            Attribs[5] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_RATING, new XRLXeFloatValue(Constants.XENON_TEST_DEFAULT_GAMER_RATING));
            Attribs[6] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_MU,new XRLXeDoubleValue(nextRange));
            Attribs[7] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_SIGMA, new XRLXeDoubleValue(searchUserSigma));
            Attribs[8] = new XRLXeAttribParam(Constants.PROPERTY_MYINT32PROP1, new XRLXeIntValue(88));
            Attribs[9] = new XRLXeAttribParam(Constants.PROPERTY_MYFLOAT32PROP1_XENON_TITLE2,new XRLXeFloatValue(1.0f));

            XRL2CreateUpdateSession		outOfRangeCreateReq = new XRL2CreateUpdateSession(Attribs);
            outOfRangeCreateReq.baseCreateUpdate.baseSession.dwTitleID = Constants.XENON_TITLE2;
            XRLSessionInfo				outOfRangeSessionInfo;
            if(!outOfRangeCreateReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out outOfRangeSessionInfo))
            {
                Global.RO.Warn("outOfRangeCreateReq failed");
                Global.RO.Error(Global.XErrToString(outOfRangeCreateReq.XErr));
                return false;
            }
            // create 1 session that's doesn't meet title defined search criteria, but has large draw probability
            Attribs[6] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_MU,new XRLXeDoubleValue(searchUserMu));
            Attribs[7] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_SIGMA, new XRLXeDoubleValue(searchUserSigma));
            Attribs[8] = new XRLXeAttribParam(Constants.PROPERTY_MYINT32PROP1, new XRLXeIntValue(87));

            XRL2CreateUpdateSession		badCreateReq = new XRL2CreateUpdateSession(Attribs);
            badCreateReq.baseCreateUpdate.baseSession.dwTitleID = Constants.XENON_TITLE2;
            XRLSessionInfo				badSessionInfo;
            if(!badCreateReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out badSessionInfo))
            {
                Global.RO.Warn("badCreateReq failed");
                new XRL2DeleteSession(outOfRangeSessionInfo.SessionID,Constants.XENON_TITLE2).Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                return false;
            }

            // create 95 sessions that has the same mu (within range 0.00096), but
            // different sigma.  We use 95 because we want to stay under 100, where
            // hashing starts to take effect.  SQL will hash things close together if
            // they're created at the same time, meaning all sessions could be filtered
            // by hashing during these tests.  Hence staying below max results*4, or 100.

            double		tempMu = searchUserMu-MuRange,tempSigma = 0;
            Attribs[6] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_MU,new XRLXeDoubleValue(tempMu));
            Attribs[8] = new XRLXeAttribParam(Constants.PROPERTY_MYINT32PROP1, new XRLXeIntValue(88));
            XRL2CreateUpdateSession	[]	OtherCreateReqs = new XRL2CreateUpdateSession[100];
            XRLSessionInfo			[]	OtherSessionInfo = new XRLSessionInfo[100];
            for(int i = 0; i < NUM_OTHER_SESSIONS; i++)
            {
                tempSigma = 1/(i+1);
                Attribs[9] = new XRLXeAttribParam(Constants.PROPERTY_MYFLOAT32PROP1_XENON_TITLE2,new XRLXeFloatValue(i));
                Attribs[7] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_SIGMA, new XRLXeDoubleValue(tempSigma));
                OtherCreateReqs[i] = new XRL2CreateUpdateSession(Attribs);
                OtherCreateReqs[i].baseCreateUpdate.baseSession.dwTitleID = Constants.XENON_TITLE2;
                if(!OtherCreateReqs[i].Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out OtherSessionInfo[i]))
                {
                    Global.RO.Warn("OtherCreateReqs failed");
                    new XRL2DeleteSession(outOfRangeSessionInfo.SessionID,Constants.XENON_TITLE2).Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                    new XRL2DeleteSession(badSessionInfo.SessionID,Constants.XENON_TITLE2).Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                    return false;
                }
            }

            // do a ranked search
            XRLXeAttribParam	[]		searchParams = new XRLXeAttribParam[9];
            searchParams[0] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_TYPE,new XRLXeIntValue(Constants.X_ATTRIBUTE_GAME_TYPE_RANKED));
            searchParams[1] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE, new XRLXeIntValue(Constants.CONTEXT_GAME_MODE_MODEA));
            searchParams[2] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_ZONE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_ZONE));
            searchParams[3] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_COUNTRY, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_COUNTRY));
            searchParams[4] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_LANGUAGE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_LANG));
            searchParams[5] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_RATING, new XRLXeFloatValue(Constants.XENON_TEST_DEFAULT_GAMER_RATING));
            searchParams[6] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_MU,new XRLXeDoubleValue(searchUserMu));
            searchParams[7] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_SIGMA, new XRLXeDoubleValue(searchUserSigma));
            searchParams[8] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_PUID, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_PUID));

            XRL2SearchSession	searchReq = new XRL2SearchSession(searchParams,Constants.SESSION_MATCH_QUERY_RANKEDMATCHQUERYFORTITLEONSINGLEDB);
            searchReq.baseSearchSession.dwTitleID = Constants.XENON_TITLE2;
            XRL2SearchResults	searchResp;
            if(searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out searchResp))
            {	
                uint	numSessions = 0;
                if (searchResp == null)
                {
                    Global.RO.Warn("No search results returned.");
                    ret = false;
                    goto exit;
                }
                if ((numSessions = searchResp.resultsLen) != 25)
                {
                    Global.RO.Warn("# of sessions returned is not 25; numSessions == " + numSessions);
                    ret = false;
                    goto exit;
                }
                // check outOfRangeSessionInfo and badSessionInfo is not returned
                for(uint i = 0; i < numSessions; i++)
                {
                    if( searchResp.results[i].SessionID.Equals(outOfRangeSessionInfo) ||
                        searchResp.results[i].SessionID.Equals(badSessionInfo))
                    {
                        Global.RO.Warn("outOfRangeSessionInfo or badSessionInfo is returned");
                        ret = false;
                        goto exit;
                    }
                }
            }
            else
            {
                Global.RO.Warn("Search results failed:"+Global.XErrToString(searchReq.XErr));
                ret = false;
                goto exit;
            }
            exit:
            new XRL2DeleteSession(outOfRangeSessionInfo.SessionID,Constants.XENON_TITLE2).Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
            new XRL2DeleteSession(badSessionInfo.SessionID,Constants.XENON_TITLE2).Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
            for(int i = 0; i < NUM_OTHER_SESSIONS; i++)
                new XRL2DeleteSession(OtherSessionInfo[i].SessionID,Constants.XENON_TITLE2).Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
            return ret;
        }
    }
    internal abstract class MinMaxMuSigmaTestBase : TestBase
    {
        protected bool VerifyReturnOrder(double searchUserMu, double searchUserSigma)
        {
            double	tempMu = 0, nextRange = 0;
            if(searchUserMu == 0)
            {
                tempMu = 0.046875;
                nextRange = 0.046876;
            }
            else if (searchUserMu == 6)
            {
                tempMu =5.25;	// 6-0.75
                nextRange = 5.24;
            }
            // create 100 sessions that mu is 0.0234375, sigma is different
            XRLXeAttribParam	[]		Attribs = new XRLXeAttribParam[10];
            Attribs[0] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_TYPE,new XRLXeIntValue(Constants.X_ATTRIBUTE_GAME_TYPE_RANKED));
            Attribs[1] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE, new XRLXeIntValue(Constants.CONTEXT_GAME_MODE_MODEA));
            Attribs[2] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_ZONE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_ZONE));
            Attribs[3] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_COUNTRY, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_COUNTRY));
            Attribs[4] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_LANGUAGE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_LANG));
            Attribs[5] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_RATING, new XRLXeFloatValue(Constants.XENON_TEST_DEFAULT_GAMER_RATING));
            Attribs[6] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_MU,new XRLXeDoubleValue(tempMu));
            Attribs[8] = new XRLXeAttribParam(Constants.PROPERTY_MYINT32PROP1, new XRLXeIntValue(88));//titledefined constant=88

            XRL2CreateUpdateSession	[]	OtherCreateReqs = new XRL2CreateUpdateSession[100];
            double						tempSigma = 0;
            XRLSessionInfo			[]	OtherSessionInfo = new XRLSessionInfo[100];
            for(int i = 0; i < 100; i++)
            {
                // the larger the sigma, the smaller the draw probability
                tempSigma = i * 0.01;
                Attribs[7] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_SIGMA, new XRLXeDoubleValue(tempSigma));
                Attribs[9] = new XRLXeAttribParam(Constants.PROPERTY_MYFLOAT32PROP1_XENON_TITLE2, new XRLXeFloatValue(i));

                OtherCreateReqs[i] = new XRL2CreateUpdateSession(Attribs);
                OtherCreateReqs[i].baseCreateUpdate.baseSession.dwTitleID = Constants.XENON_TITLE2;
                if(!OtherCreateReqs[i].Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out OtherSessionInfo[i]))
                {
                    Global.RO.Warn("OtherCreateReqs failed");
                    return false;
                }
            }

            // create another session that mu is 0.0.0234376, sigma is 0
            Attribs[6] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_MU,new XRLXeDoubleValue(nextRange));
            Attribs[7] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_SIGMA, new XRLXeDoubleValue(0));
            Attribs[9] = new XRLXeAttribParam(Constants.PROPERTY_MYFLOAT32PROP1_XENON_TITLE2, new XRLXeFloatValue(888));
            XRL2CreateUpdateSession	badCreate = new XRL2CreateUpdateSession(Attribs);
            badCreate.baseCreateUpdate.baseSession.dwTitleID = Constants.XENON_TITLE2;

            XRLSessionInfo			badSessionInfo;
            if(!badCreate.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out badSessionInfo))
            {
                Global.RO.Warn("badCreate failed");
                return false;
            }

            bool	ret = true;
            // do a ranked search
            XRLXeAttribParam	[]		searchParams = new XRLXeAttribParam[9];
            searchParams[0] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_TYPE,new XRLXeIntValue(Constants.X_ATTRIBUTE_GAME_TYPE_RANKED));
            searchParams[1] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE, new XRLXeIntValue(Constants.CONTEXT_GAME_MODE_MODEA));
            searchParams[2] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_ZONE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_ZONE));
            searchParams[3] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_COUNTRY, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_COUNTRY));
            searchParams[4] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_LANGUAGE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_LANG));
            searchParams[5] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_RATING, new XRLXeFloatValue(Constants.XENON_TEST_DEFAULT_GAMER_RATING));
            searchParams[6] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_MU,new XRLXeDoubleValue(searchUserMu));
            searchParams[7] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_SIGMA, new XRLXeDoubleValue(searchUserSigma));
            searchParams[8] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_PUID, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_PUID));

            XRL2SearchSession	searchReq = new XRL2SearchSession(searchParams,Constants.SESSION_MATCH_QUERY_RANKEDMATCHQUERYFORTITLEONSINGLEDB);
            searchReq.baseSearchSession.dwTitleID = Constants.XENON_TITLE2;
            XRL2SearchResults	searchResp;
            if(searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out searchResp))
            {	
                if((searchResp == null) || (searchResp.resultsLen != 25))
                {
                    Global.RO.Warn("no search results returned or numOf sessions returned is not 25");
                    ret = false;
                    goto exit;
                }
                float	fValue = 0;
                for(int i = 0; i < 25; i++)
                {
                    if (searchResp.results[i].Attribs == null)
                    {
                        Global.RO.Warn("No attributes returned with search result at index " + i);
                        ret = false;
                        break;
                    }
                    if (searchResp.results[i].Attribs[1] == null)
                    {
                        Global.RO.Warn("Attribute expected at index 1 does not exist.");
                        ret = false;
                        break;
                    }
                    XRLXeFloatValue fAttrib = searchResp.results[i].Attribs[1].aValue as XRLXeFloatValue;
                    if (fAttrib == null)
                    {
                        Global.RO.Warn("Attribute at index 1 is not of expected type XRLXeFloatValue.");
                        ret = false;
                        break;
                    }
                    fValue = (searchResp.results[i].Attribs[1].aValue as XRLXeFloatValue).fValue;
                    if(fValue == 888)
                    {
                        Global.RO.Warn("A session with a broader mu value was returned.");
                        ret = false;
                        break;
                    }
                    if(fValue != i)
                    {
                        Global.RO.Warn("The returned order was not correct");
                        ret = false;
                        goto exit;
                    }
                }
            }
            exit:
            for(int i = 0; i < 100; i++)
                new XRL2DeleteSession(OtherSessionInfo[i].SessionID,Constants.XENON_TITLE2).Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
            new XRL2DeleteSession(badSessionInfo.SessionID,Constants.XENON_TITLE2).Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
            return ret;
        }
    }
    [TestGroup]
    public class Func2RankedMatch : TestNode
    {
        [TestGroupSetup]
        public void Setup()
        {
            MatchUtil.TruncateSessionsForTitle(Constants.XENON_TITLE2, SessionType.Ranked);
        }

        [BVT]
        [TestCase, Description("All available sessions have valid mu,sigma. using 0.00096")]
        class PValidMuSigmaRange1 : RankedMatchTestBase
        {
            override protected void Execute()
            {
                double range = 0.00096;
                if(validMuSigmaBase(range))
                    ResultCode=TEST_RESULTS.PASSED;	
            }
        }
        [TestCase, Description("All available sessions have valid mu,sigma. using range 0.0048")]
        class PValidMuSigmaRange2 : RankedMatchTestBase
        {
            override protected void Execute()
            {		
                double range = 0.0048;
                if(validMuSigmaBase(range))
                    ResultCode=TEST_RESULTS.PASSED;	
            }
        }
        [TestCase, Description("All available sessions have valid mu,sigma. using range 0.024")]
        class PValidMuSigmaRange3 : RankedMatchTestBase
        {
            override protected void Execute()
            {		
                double range = 0.024;
                if(validMuSigmaBase(range))
                    ResultCode=TEST_RESULTS.PASSED;	
            }
        }
        [TestCase, Description("All available sessions have valid mu,sigma. using range 0.12")]
        class PValidMuSigmaRange4 : RankedMatchTestBase
        {
            override protected void Execute()
            {		
                double range = 0.12;
                if(validMuSigmaBase(range))
                    ResultCode=TEST_RESULTS.PASSED;	
            }
        }
        [TestCase, Description("All available sessions have valid mu,sigma. using range 0.6")]
        class PValidMuSigmaRange5 : RankedMatchTestBase
        {
            override protected void Execute()
            {		
                double range = 0.6;
                if(validMuSigmaBase(range))
                    ResultCode=TEST_RESULTS.PASSED;	
            }
        }
        [TestCase, Description("searchUser's mu and sigma are 0, available sessions mu is 6*2^(-7)=0.046875")]
        class PSearchUserZeroMuSigma : MinMaxMuSigmaTestBase
        {
            override protected void Execute()
            {	
                double	searchUserMu = 0, searchUserSigma = 0;
                if(this.VerifyReturnOrder(searchUserMu,searchUserSigma))
                    ResultCode=TEST_RESULTS.PASSED;	
            }
        }
        [TestCase, Description("searchUser's mu and sigma are max, available sessions mu is 5.88")]
        class PSearchUserMaxMuSigma : MinMaxMuSigmaTestBase
        {
            override protected void Execute()
            {	
                double	searchUserMu = 6, searchUserSigma = 1;
                if(this.VerifyReturnOrder(searchUserMu,searchUserSigma))
                    ResultCode=TEST_RESULTS.PASSED;	
            }
        }
        [TestCase, Description("All available sessions's mu and sigma is 0, searchUser's mu and sigma is 0")]
        class PAllZeroMuSigma : TestBase
        {
            override protected void Execute()
            {	
                // create 100 sessions
                XRLXeAttribParam	[]		Attribs = new XRLXeAttribParam[9];
                Attribs[0] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_TYPE,new XRLXeIntValue(Constants.X_ATTRIBUTE_GAME_TYPE_RANKED));
                Attribs[1] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE, new XRLXeIntValue(Constants.CONTEXT_GAME_MODE_MODEA));
                Attribs[2] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_ZONE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_ZONE));
                Attribs[3] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_COUNTRY, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_COUNTRY));
                Attribs[4] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_LANGUAGE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_LANG));
                Attribs[5] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_RATING, new XRLXeFloatValue(Constants.XENON_TEST_DEFAULT_GAMER_RATING));
                Attribs[6] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_MU,new XRLXeDoubleValue(0));
                Attribs[7] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_SIGMA, new XRLXeDoubleValue(0));
                Attribs[8] = new XRLXeAttribParam(Constants.PROPERTY_MYINT32PROP1, new XRLXeIntValue(88));

                XRL2CreateUpdateSession	[]	OtherCreateReqs = new XRL2CreateUpdateSession[100];
                XRLSessionInfo			[]	OtherSessionInfo = new XRLSessionInfo[100];
                for(int i = 0; i < 100; i++)
                {
                    OtherCreateReqs[i] = new XRL2CreateUpdateSession(Attribs);
                    OtherCreateReqs[i].baseCreateUpdate.baseSession.dwTitleID = Constants.XENON_TITLE2;
                    if(!OtherCreateReqs[i].Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out OtherSessionInfo[i]))
                    {
                        Global.RO.Warn("OtherCreateReqs failed");
                        return;
                    }
                }

                // do a ranked search
                XRLXeAttribParam	[]		searchParams = new XRLXeAttribParam[9];
                searchParams[0] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_TYPE,new XRLXeIntValue(Constants.X_ATTRIBUTE_GAME_TYPE_RANKED));
                searchParams[1] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE, new XRLXeIntValue(Constants.CONTEXT_GAME_MODE_MODEA));
                searchParams[2] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_ZONE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_ZONE));
                searchParams[3] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_COUNTRY, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_COUNTRY));
                searchParams[4] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_LANGUAGE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_LANG));
                searchParams[5] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_RATING, new XRLXeFloatValue(Constants.XENON_TEST_DEFAULT_GAMER_RATING));
                searchParams[6] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_MU,new XRLXeDoubleValue(0));
                searchParams[7] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_SIGMA, new XRLXeDoubleValue(0));
                searchParams[8] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_PUID, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_PUID));

                XRL2SearchSession	searchReq = new XRL2SearchSession(searchParams,Constants.SESSION_MATCH_QUERY_RANKEDMATCHQUERYFORTITLEONSINGLEDB);
                searchReq.baseSearchSession.dwTitleID = Constants.XENON_TITLE2;
                XRL2SearchResults	searchResp;
                if(searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out searchResp))
                {	
                    if((searchResp == null) || (searchResp.resultsLen != 25))
                    {
                        Global.RO.Warn("no search results returned or numOf sessions returned is not 25");
                        return;
                    }
                    ResultCode=TEST_RESULTS.PASSED;	
                }
                for(int i = 0; i < 100; i++)
                    new XRL2DeleteSession(OtherSessionInfo[i].SessionID,Constants.XENON_TITLE2).Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
            }
        }
        [TestCase, Description("All available sessions and searcher's mu are 6 and sigma are 1")]
        class PAllMaxMuSigma : TestBase
        {
            override protected void Execute()
            {		
                // create 100 sessions
                XRLXeAttribParam	[]		Attribs = new XRLXeAttribParam[9];
                Attribs[0] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_TYPE,new XRLXeIntValue(Constants.X_ATTRIBUTE_GAME_TYPE_RANKED));
                Attribs[1] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE, new XRLXeIntValue(Constants.CONTEXT_GAME_MODE_MODEA));
                Attribs[2] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_ZONE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_ZONE));
                Attribs[3] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_COUNTRY, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_COUNTRY));
                Attribs[4] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_LANGUAGE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_LANG));
                Attribs[5] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_RATING, new XRLXeFloatValue(Constants.XENON_TEST_DEFAULT_GAMER_RATING));
                Attribs[6] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_MU,new XRLXeDoubleValue(6));
                Attribs[7] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_SIGMA, new XRLXeDoubleValue(1));
                Attribs[8] = new XRLXeAttribParam(Constants.PROPERTY_MYINT32PROP1, new XRLXeIntValue(88));

                XRL2CreateUpdateSession	[]	OtherCreateReqs = new XRL2CreateUpdateSession[100];
                XRLSessionInfo			[]	OtherSessionInfo = new XRLSessionInfo[100];
                for(int i = 0; i < 100; i++)
                {
                    OtherCreateReqs[i] = new XRL2CreateUpdateSession(Attribs);
                    OtherCreateReqs[i].baseCreateUpdate.baseSession.dwTitleID = Constants.XENON_TITLE2;
                    if(!OtherCreateReqs[i].Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out OtherSessionInfo[i]))
                    {
                        Global.RO.Warn("OtherCreateReqs failed");
                        return;
                    }
                }

                // do a ranked search
                XRLXeAttribParam	[]		searchParams = new XRLXeAttribParam[9];
                searchParams[0] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_TYPE,new XRLXeIntValue(Constants.X_ATTRIBUTE_GAME_TYPE_RANKED));
                searchParams[1] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE, new XRLXeIntValue(Constants.CONTEXT_GAME_MODE_MODEA));
                searchParams[2] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_ZONE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_ZONE));
                searchParams[3] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_COUNTRY, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_COUNTRY));
                searchParams[4] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_LANGUAGE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_LANG));
                searchParams[5] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_RATING, new XRLXeFloatValue(Constants.XENON_TEST_DEFAULT_GAMER_RATING));
                searchParams[6] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_MU,new XRLXeDoubleValue(6));
                searchParams[7] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_SIGMA, new XRLXeDoubleValue(1));
                searchParams[8] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_PUID, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_PUID));

                XRL2SearchSession	searchReq = new XRL2SearchSession(searchParams,Constants.SESSION_MATCH_QUERY_RANKEDMATCHQUERYFORTITLEONSINGLEDB);
                searchReq.baseSearchSession.dwTitleID = Constants.XENON_TITLE2;
                XRL2SearchResults	searchResp;
                if(searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out searchResp))
                {	
                    if((searchResp == null) || (searchResp.resultsLen) != 25)
                    {
                        Global.RO.Warn("no search results returned or numOf sessions returned is not 25");
                        return;
                    }
                    ResultCode=TEST_RESULTS.PASSED;	
                }
                for(int i = 0; i < 100; i++)
                    new XRL2DeleteSession(OtherSessionInfo[i].SessionID,Constants.XENON_TITLE2).Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
            }
        }
        [TestCase, Description("use a query that has title defined sort")]
        class PTitleDefinedSort : TestBase
        {
            override protected void Execute()
            {		
                // create 100 sessions. 10 with sortBy =5, 15 with sortBy=4; 75 with sortBy=3
                XRLXeAttribParam	[]		Attribs = new XRLXeAttribParam[10];
                Attribs[0] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_TYPE,new XRLXeIntValue(Constants.X_ATTRIBUTE_GAME_TYPE_RANKED));
                Attribs[1] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE, new XRLXeIntValue(Constants.CONTEXT_GAME_MODE_MODEA));
                Attribs[2] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_ZONE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_ZONE));
                Attribs[3] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_COUNTRY, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_COUNTRY));
                Attribs[4] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_LANGUAGE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_LANG));
                Attribs[5] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_RATING, new XRLXeFloatValue(Constants.XENON_TEST_DEFAULT_GAMER_RATING));
                Attribs[7] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_SIGMA, new XRLXeDoubleValue(1));
                Attribs[9] = new XRLXeAttribParam(Constants.PROPERTY_MYFLOAT32PROP1_XENON_TITLE2, new XRLXeFloatValue(0.1f));

                XRL2CreateUpdateSession	[]	OtherCreateReqs = new XRL2CreateUpdateSession[100];
                XRLSessionInfo			[]	OtherSessionInfo = new XRLSessionInfo[100];
                double					tempMu = 0;
                for(int i = 0; i < 100; i++)
                {
                    tempMu = 1.0+0.0048-i*0.0001;
                    if(i < 10)
                    {
                        Attribs[8] = new XRLXeAttribParam(Constants.PROPERTY_MYINT32PROP1, new XRLXeIntValue(5));
                        Attribs[6] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_MU,new XRLXeDoubleValue(tempMu));
                    }
                    else if ( i < 25)
                    {
                        Attribs[8] = new XRLXeAttribParam(Constants.PROPERTY_MYINT32PROP1, new XRLXeIntValue(4));
                        Attribs[6] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_MU,new XRLXeDoubleValue(tempMu));
                    }
                    else	// 75 sessions with sortBy=3 and mu's range is 0.00096
                    {
                        Attribs[8] = new XRLXeAttribParam(Constants.PROPERTY_MYINT32PROP1, new XRLXeIntValue(3));
                        Attribs[6] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_MU,new XRLXeDoubleValue(0.99904));
                        if(i == 49)
                            tempMu = 0;
                    }

                    OtherCreateReqs[i] = new XRL2CreateUpdateSession(Attribs);
                    OtherCreateReqs[i].baseCreateUpdate.baseSession.dwTitleID = Constants.XENON_TITLE2;
                    if(!OtherCreateReqs[i].Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out OtherSessionInfo[i]))
                    {
                        Global.RO.Warn("OtherCreateReqs failed");
                        return;
                    }
                }
                bool	fail = false;
                // do a ranked search; searchUser's mu and sigma are both 1.
                XRLXeAttribParam	[]		searchParams = new XRLXeAttribParam[9];
                searchParams[0] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_TYPE,new XRLXeIntValue(Constants.X_ATTRIBUTE_GAME_TYPE_RANKED));
                searchParams[1] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE, new XRLXeIntValue(Constants.CONTEXT_GAME_MODE_MODEA));
                searchParams[2] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_ZONE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_ZONE));
                searchParams[3] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_COUNTRY, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_COUNTRY));
                searchParams[4] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_LANGUAGE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_LANG));
                searchParams[5] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_RATING, new XRLXeFloatValue(Constants.XENON_TEST_DEFAULT_GAMER_RATING));
                searchParams[6] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_MU,new XRLXeDoubleValue(1));
                searchParams[7] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_SIGMA, new XRLXeDoubleValue(1));
                searchParams[8] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_PUID, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_PUID));

                XRL2SearchSession	searchReq = new XRL2SearchSession(searchParams,Constants.SESSION_MATCH_QUERY_RANKEDMATCHWITHTITLEDEFINEDSORT);
                searchReq.baseSearchSession.dwTitleID = Constants.XENON_TITLE2;
                XRL2SearchResults	searchResp;
                if(searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out searchResp))
                {	
                    if((searchResp == null) || (searchResp.resultsLen) != 25)
                    {
                        Global.RO.Warn("no search results returned or numOf sessions returned is not 25");
                        return;
                    }
                    // check 75 sessions with sortBy=3 are not returned.
                    long	retInt;
                    for(int i = 0; i < 25; i++)
                    {
                        retInt = (searchResp.results[i].Attribs[0].aValue as XRLXeIntValue).intValue;
                        if(retInt == 3)
                        {
                            Global.RO.Warn("session with sortBy attribute=3 returned");
                            fail = true;
                            break;
                        }
                        if(i < 10)
                        {
                            if(retInt != 5)
                            {
                                Global.RO.Warn("session with sortBy attribute=5 are not returned 1st");
                                fail = true;
                                break;
                            }
                        }
                        else if (i<25)
                        {
                            if(retInt != 4)
                            {
                                Global.RO.Warn("session with sortBy attribute=4 are not returned next");
                                fail = true;
                                break;
                            }
                        }
                    }
                    if(!fail)
                        ResultCode=TEST_RESULTS.PASSED;	
                }
                for(int i = 0; i < 100; i++)
                    new XRL2DeleteSession(OtherSessionInfo[i].SessionID,Constants.XENON_TITLE2).Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
            }
        }
        [TestCase, Description("Bug 29901:create 11 sessions with evenly distributed mu and sigma")]
        class PRankedMatchMainline : TestBase
        {
            override protected void Execute()
            {	
                // create 11 sessions
                XRLXeAttribParam	[]		Attribs = new XRLXeAttribParam[9];
                Attribs[0] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_TYPE,new XRLXeIntValue(Constants.X_ATTRIBUTE_GAME_TYPE_RANKED));
                Attribs[1] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE, new XRLXeIntValue(Constants.CONTEXT_GAME_MODE_MODEA));
                Attribs[2] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_ZONE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_ZONE));
                Attribs[3] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_COUNTRY, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_COUNTRY));
                Attribs[4] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_LANGUAGE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_LANG));
                Attribs[5] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_RATING, new XRLXeFloatValue(Constants.XENON_TEST_DEFAULT_GAMER_RATING));
                Attribs[8] = new XRLXeAttribParam(Constants.PROPERTY_MYINT32PROP1, new XRLXeIntValue(88));

                XRL2CreateUpdateSession	[]	OtherCreateReqs = new XRL2CreateUpdateSession[11];
                XRLSessionInfo			[]	OtherSessionInfo = new XRLSessionInfo[11];
                double						tempSigma = 0, tempMu = 0;
                for(int i = 0; i < 11; i++)
                {
                    tempSigma = i*0.1;
                    if(i < 6)
                        tempMu = i+0.1;
                    else if (i == 6)
                        tempMu = 6.0;
                    else
                        tempMu = 2.1;
                    Attribs[6] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_MU,new XRLXeDoubleValue(tempMu));
                    Attribs[7] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_SIGMA, new XRLXeDoubleValue(tempSigma));
                    OtherCreateReqs[i] = new XRL2CreateUpdateSession(Attribs);
                    OtherCreateReqs[i].baseCreateUpdate.baseSession.dwTitleID = Constants.XENON_TITLE2;
                    if(!OtherCreateReqs[i].Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out OtherSessionInfo[i]))
                    {
                        Global.RO.Warn("OtherCreateReqs failed");
                        return;
                    }
                }

                // do a ranked search
                XRLXeAttribParam	[]		searchParams = new XRLXeAttribParam[9];
                searchParams[0] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_TYPE,new XRLXeIntValue(Constants.X_ATTRIBUTE_GAME_TYPE_RANKED));
                searchParams[1] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE, new XRLXeIntValue(Constants.CONTEXT_GAME_MODE_MODEA));
                searchParams[2] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_ZONE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_ZONE));
                searchParams[3] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_COUNTRY, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_COUNTRY));
                searchParams[4] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_LANGUAGE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_LANG));
                searchParams[5] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_RATING, new XRLXeFloatValue(Constants.XENON_TEST_DEFAULT_GAMER_RATING));
                searchParams[6] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_MU,new XRLXeDoubleValue(3));
                searchParams[7] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_SIGMA, new XRLXeDoubleValue(0.5));
                searchParams[8] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_PUID, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_PUID));

                XRL2SearchSession	searchReq = new XRL2SearchSession(searchParams,Constants.SESSION_MATCH_QUERY_RANKEDMATCHQUERYFORTITLEONSINGLEDB);
                searchReq.baseSearchSession.dwTitleID = Constants.XENON_TITLE2;
                XRL2SearchResults	searchResp;
                if(searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out searchResp))
                {
                    if (searchResp == null)
                    {
                        Global.RO.Warn("No search results returned.");
                        goto exit;
                    }
                    if (searchResp.resultsLen != 11)
                    {
                        Global.RO.Warn("# sessions returned is not 11; searchResp.resultsLen == " + 
                                       searchResp.resultsLen);
                        goto exit;
                    }
                    // check the order of the 11 sessions: should be in draw_probability descending order.
                    long	retSessionID = 0, expSessionID = 0;
                    retSessionID = Constants.sessionIDConvert(searchResp.results[0].SessionID);
                    expSessionID = Constants.sessionIDConvert(OtherSessionInfo[3].SessionID);
                    if(retSessionID != expSessionID)
                    {
                        Global.RO.Warn("1st returned session is not correct");
                        goto exit;
                    }
                    retSessionID = Constants.sessionIDConvert(searchResp.results[1].SessionID);
                    expSessionID = Constants.sessionIDConvert(OtherSessionInfo[2].SessionID);
                    if(retSessionID != expSessionID)
                    {
                        Global.RO.Warn("2nd returned session is not correct");
                        goto exit;
                    }
                    retSessionID = Constants.sessionIDConvert(searchResp.results[2].SessionID);
                    expSessionID = Constants.sessionIDConvert(OtherSessionInfo[7].SessionID);
                    if(retSessionID != expSessionID)
                    {
                        Global.RO.Warn("3rd returned session is not correct");
                        goto exit;
                    }
                    retSessionID = Constants.sessionIDConvert(searchResp.results[3].SessionID);
                    expSessionID = Constants.sessionIDConvert(OtherSessionInfo[4].SessionID);
                    if(retSessionID != expSessionID)
                    {
                        Global.RO.Warn("4th returned session is not correct");
                        goto exit;
                    }
                    retSessionID = Constants.sessionIDConvert(searchResp.results[4].SessionID);
                    expSessionID = Constants.sessionIDConvert(OtherSessionInfo[8].SessionID);
                    if(retSessionID != expSessionID)
                    {
                        Global.RO.Warn("5yh returned session is not correct");
                        goto exit;
                    }
                    retSessionID = Constants.sessionIDConvert(searchResp.results[5].SessionID);
                    expSessionID = Constants.sessionIDConvert(OtherSessionInfo[9].SessionID);
                    if(retSessionID != expSessionID)
                    {
                        Global.RO.Warn("6th returned session is not correct");
                        goto exit;
                    }
                    retSessionID = Constants.sessionIDConvert(searchResp.results[6].SessionID);
                    expSessionID = Constants.sessionIDConvert(OtherSessionInfo[10].SessionID);
                    if(retSessionID != expSessionID)
                    {
                        Global.RO.Warn("7th returned session is not correct");
                        goto exit;
                    }
                    retSessionID = Constants.sessionIDConvert(searchResp.results[7].SessionID);
                    expSessionID = Constants.sessionIDConvert(OtherSessionInfo[1].SessionID);
                    if(retSessionID != expSessionID)
                    {
                        Global.RO.Warn("8th returned session is not correct");
                        goto exit;
                    }
                    retSessionID = Constants.sessionIDConvert(searchResp.results[8].SessionID);
                    expSessionID = Constants.sessionIDConvert(OtherSessionInfo[5].SessionID);
                    if(retSessionID != expSessionID)
                    {
                        Global.RO.Warn("9th returned session is not correct");
                        goto exit;
                    }
                    retSessionID = Constants.sessionIDConvert(searchResp.results[9].SessionID);
                    expSessionID = Constants.sessionIDConvert(OtherSessionInfo[0].SessionID);
                    if(retSessionID != expSessionID)
                    {
                        Global.RO.Warn("10th returned session is not correct");
                        goto exit;
                    }
                    retSessionID = Constants.sessionIDConvert(searchResp.results[10].SessionID);
                    expSessionID = Constants.sessionIDConvert(OtherSessionInfo[6].SessionID);
                    if(retSessionID != expSessionID)
                    {
                        Global.RO.Warn("11th returned session is not correct");
                        goto exit;
                    }
                    ResultCode=TEST_RESULTS.PASSED;	
                }
                exit:
                for(int i = 0; i < 11; i++)
                    new XRL2DeleteSession(OtherSessionInfo[i].SessionID,Constants.XENON_TITLE2).Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
            }
        }
        [TestCase, Description("send a match request with missing all default parameters")]
        class PMatchMissingParams : TestBase
        {
            override protected void Execute()
            {
                XRL2SearchSession   searchReq = new XRL2SearchSession(false,Constants.SESSION_MATCH_QUERY_NOPARAMQUERY);
                XRLXeAttribParam	[] searchParams = new XRLXeAttribParam[2];
                searchParams[0] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_TYPE, new XRLXeIntValue(Constants.X_ATTRIBUTE_GAME_TYPE_STANDARD));
                searchParams[1] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE, new XRLXeIntValue(Constants.CONTEXT_GAME_MODE_MODEA));
                searchReq.AddParams(searchParams);

                XRL2SearchResults	searchResp;
                if(searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out searchResp))
                    ResultCode=TEST_RESULTS.PASSED;			
            }
        }
        [TestCase, Description("Create 1001 sessions with the same mu")]
        class PLotsSessions : TestBase
        {
            override protected void Execute()
            {	
                XRLXeAttribParam	[]		Attribs = new XRLXeAttribParam[1];
                Attribs[0] = new XRLXeAttribParam(Constants.PROPERTY_MYINT32PROP1, new XRLXeIntValue(88));
				
                // create 1000 sessions
                XRL2CreateUpdateSession	[]	OtherCreateReqs = new XRL2CreateUpdateSession[1000];
                XRLSessionInfo			[]	OtherSessionInfo = new XRLSessionInfo[1000];
                for(int i = 0; i < 1000; i++)
                {
                    OtherCreateReqs[i] = new XRL2CreateUpdateSession();
                    OtherCreateReqs[i].AddAttribs(Attribs);
                    OtherCreateReqs[i].baseCreateUpdate.baseSession.dwTitleID = Constants.XENON_TITLE2;
                    if(!OtherCreateReqs[i].Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out OtherSessionInfo[i]))
                    {
                        Global.RO.Warn("OtherCreateReqs failed");
                        return;
                    }
                    System.Threading.Thread.Sleep(100);  //slow it down.  hopefully we get
                    //better
                    //randomization...
                    if ((i % 100) == 0) {
                        Global.RO.Info("Creating " + i + "th user.  Creation is slowed because SQL's randomizer makes bad hash numbers otherwise.");
                    }
                }

                // do a ranked search
                XRL2SearchSession searchReq = new XRL2SearchSession(true, Constants.SESSION_MATCH_QUERY_RANKEDMATCHQUERYFORTITLEONSINGLEDB);
                searchReq.baseSearchSession.dwTitleID = Constants.XENON_TITLE2;
                XRL2SearchResults searchResp;
                if (searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out searchResp))
                {
                    if (searchResp == null)
                    {
                        Global.RO.Warn("No search results returned.");
                        goto exit;
                    }
                    if (searchResp.resultsLen != 25)
                    {
                        Global.RO.Warn("# of sessions returned is not 25; searchResp.resultsLen == " + 
                                       searchResp.resultsLen);
                        goto exit;
                    }
                    ResultCode = TEST_RESULTS.PASSED;
                }
                exit:
                for (int i = 0; i < 1000; i++)
                    new XRL2DeleteSession(OtherSessionInfo[i].SessionID, Constants.XENON_TITLE2).Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
            }
        }
        /*****************************************************************************************************
         *	Negative test cases
         *****************************************************************************************************/
        [TestCase, Description("Bug 28185:Check closest mu and sigma values are being used.")]
        class NSearchUserBadMuSigma : TestBase
        {
            override protected void Execute()
            {		
                // create 100 sessions that mu is 6 and sigma is 0.001
                XRLXeAttribParam	[]		Attribs = new XRLXeAttribParam[9];
                Attribs[0] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_TYPE,new XRLXeIntValue(Constants.X_ATTRIBUTE_GAME_TYPE_RANKED));
                Attribs[1] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE, new XRLXeIntValue(Constants.CONTEXT_GAME_MODE_MODEA));
                Attribs[2] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_ZONE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_ZONE));
                Attribs[3] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_COUNTRY, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_COUNTRY));
                Attribs[4] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_LANGUAGE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_LANG));
                Attribs[5] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_RATING, new XRLXeFloatValue(Constants.XENON_TEST_DEFAULT_GAMER_RATING));
                Attribs[6] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_MU,new XRLXeDoubleValue(6));
                Attribs[7] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_SIGMA, new XRLXeDoubleValue(0.001));
                Attribs[8] = new XRLXeAttribParam(Constants.PROPERTY_MYINT32PROP1, new XRLXeIntValue(88));

                XRL2CreateUpdateSession	[]	OtherCreateReqs = new XRL2CreateUpdateSession[100];
                XRLSessionInfo			[]	OtherSessionInfo = new XRLSessionInfo[100];
                for(int i = 0; i < 100; i++)
                {
                    OtherCreateReqs[i] = new XRL2CreateUpdateSession(Attribs);
                    OtherCreateReqs[i].baseCreateUpdate.baseSession.dwTitleID = Constants.XENON_TITLE2;
                    if(!OtherCreateReqs[i].Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out OtherSessionInfo[i]))
                    {
                        Global.RO.Warn("OtherCreateReqs failed");
                        return;
                    }
                }
                // create another session with mu set to 3 sigma set to 0.5
                Attribs[6] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_MU,new XRLXeDoubleValue(3));
                Attribs[7] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_SIGMA, new XRLXeDoubleValue(0.5));
                XRL2CreateUpdateSession	badCreate = new XRL2CreateUpdateSession(Attribs);
                badCreate.baseCreateUpdate.baseSession.dwTitleID = Constants.XENON_TITLE2;
                XRLSessionInfo			badSessionInfo;
                if(!badCreate.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out badSessionInfo))
                {
                    Global.RO.Warn("badCreate failed");
                    return;
                }

                // do a ranked search with searchUser's mu set to 6.001, sigma set to -0.001
                XRLXeAttribParam	[]		searchParams = new XRLXeAttribParam[9];
                searchParams[0] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_TYPE,new XRLXeIntValue(Constants.X_ATTRIBUTE_GAME_TYPE_RANKED));
                searchParams[1] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE, new XRLXeIntValue(Constants.CONTEXT_GAME_MODE_MODEA));
                searchParams[2] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_ZONE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_ZONE));
                searchParams[3] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_COUNTRY, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_COUNTRY));
                searchParams[4] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_LANGUAGE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_LANG));
                searchParams[5] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_RATING, new XRLXeFloatValue(Constants.XENON_TEST_DEFAULT_GAMER_RATING));
                searchParams[6] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_MU,new XRLXeDoubleValue(6.001));
                searchParams[7] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_SIGMA, new XRLXeDoubleValue(-0.001));
                searchParams[8] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_PUID, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_PUID));

                XRL2SearchSession	searchReq = new XRL2SearchSession(searchParams,Constants.SESSION_MATCH_QUERY_RANKEDMATCHQUERYFORTITLEONSINGLEDB);
                searchReq.baseSearchSession.dwTitleID = Constants.XENON_TITLE2;
                XRL2SearchResults	searchResp;
                // check the badSessionInfo is not returned.
                if(searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out searchResp))
                {	
                    if((searchResp == null) || (searchResp.resultsLen) != 25)
                    {
                        Global.RO.Warn("no search results returned or numOf sessions returned is not 25");
                        goto exit;
                    }
                    bool found = false;
                    long	retSessionID = 0;
                    for(int i = 0; i < 25; i ++)
                    {	
                        retSessionID = Constants.sessionIDConvert(searchResp.results[i].SessionID);
                        if(retSessionID == Constants.sessionIDConvert(badSessionInfo.SessionID))
                        {
                            found= true;
                            break;
                        }
                    }
                    if(!found)
                        ResultCode=TEST_RESULTS.PASSED;	
                }
                exit:
                for(int i = 0; i < 100; i++)
                    new XRL2DeleteSession(OtherSessionInfo[i].SessionID,Constants.XENON_TITLE2).Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                new XRL2DeleteSession(badSessionInfo.SessionID, Constants.XENON_TITLE2).Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
            }
        }
        [TestCase, Description("passing no mu and sigma in a search request.")]
        class NSearchUserNoMuSigma : TestBase
        {
            override protected void Execute()
            {		
                // create 100 sessions that mu is 3 and sigma is 1
                XRLXeAttribParam	[]		Attribs = new XRLXeAttribParam[9];
                Attribs[0] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_TYPE,new XRLXeIntValue(Constants.X_ATTRIBUTE_GAME_TYPE_RANKED));
                Attribs[1] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE, new XRLXeIntValue(Constants.CONTEXT_GAME_MODE_MODEA));
                Attribs[2] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_ZONE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_ZONE));
                Attribs[3] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_COUNTRY, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_COUNTRY));
                Attribs[4] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_LANGUAGE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_LANG));
                Attribs[5] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_RATING, new XRLXeFloatValue(Constants.XENON_TEST_DEFAULT_GAMER_RATING));
                Attribs[6] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_MU,new XRLXeDoubleValue(3));
                Attribs[7] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_SIGMA, new XRLXeDoubleValue(1));
                Attribs[8] = new XRLXeAttribParam(Constants.PROPERTY_MYINT32PROP1, new XRLXeIntValue(88));

                XRL2CreateUpdateSession	[]	OtherCreateReqs = new XRL2CreateUpdateSession[100];
                XRLSessionInfo			[]	OtherSessionInfo = new XRLSessionInfo[100];
                for(int i = 0; i < 100; i++)
                {
                    OtherCreateReqs[i] = new XRL2CreateUpdateSession(Attribs);
                    OtherCreateReqs[i].baseCreateUpdate.baseSession.dwTitleID = Constants.XENON_TITLE2;
                    if(!OtherCreateReqs[i].Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out OtherSessionInfo[i]))
                    {
                        Global.RO.Warn("OtherCreateReqs failed");
                        return;
                    }
                }
                // create another session with mu set to 6 sigma set to 0.5
                Attribs[6] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_MU,new XRLXeDoubleValue(6));
                Attribs[7] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_SIGMA, new XRLXeDoubleValue(0.5));
                XRL2CreateUpdateSession	badCreate = new XRL2CreateUpdateSession(Attribs);
                badCreate.baseCreateUpdate.baseSession.dwTitleID = Constants.XENON_TITLE2;
                XRLSessionInfo			badSessionInfo;
                if(!badCreate.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out badSessionInfo))
                {
                    Global.RO.Warn("badCreate failed");
                    return;
                }

                // do a ranked search without passing mu and sigma
                XRLXeAttribParam	[]		searchParams = new XRLXeAttribParam[7];
                searchParams[0] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_TYPE,new XRLXeIntValue(Constants.X_ATTRIBUTE_GAME_TYPE_RANKED));
                searchParams[1] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE, new XRLXeIntValue(Constants.CONTEXT_GAME_MODE_MODEA));
                searchParams[2] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_ZONE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_ZONE));
                searchParams[3] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_COUNTRY, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_COUNTRY));
                searchParams[4] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_LANGUAGE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_LANG));
                searchParams[5] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_RATING, new XRLXeFloatValue(Constants.XENON_TEST_DEFAULT_GAMER_RATING));
                searchParams[6] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_PUID, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_PUID));

                XRL2SearchSession	searchReq = new XRL2SearchSession(searchParams,Constants.SESSION_MATCH_QUERY_RANKEDMATCHQUERYFORTITLEONSINGLEDB);
                searchReq.baseSearchSession.dwTitleID = Constants.XENON_TITLE2;
                XRL2SearchResults	searchResp;
                // check the badSessionInfo is not returned.
                if(searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out searchResp))
                {	
                    if((searchResp == null) || (searchResp.resultsLen) != 25)
                    {
                        Global.RO.Warn("no search results returned or numOf sessions returned is not 25");
                        goto exit;
                    }
                    bool found = false;
                    long	retSessionID = 0;
                    for(int i = 0; i < 25; i ++)
                    {	
                        retSessionID = Constants.sessionIDConvert(searchResp.results[i].SessionID);
                        if(retSessionID == Constants.sessionIDConvert(badSessionInfo.SessionID))
                        {
                            Global.RO.Error("Found the session of mu = 6, sigma = 0.5 when we shouldn't have!");
                            found= true;
                            break;
                        }
                    }
                    if(!found)
                        ResultCode=TEST_RESULTS.PASSED;	
                }
                exit:
                for (int i = 0; i < 100; i++)
                    new XRL2DeleteSession(OtherSessionInfo[i].SessionID, Constants.XENON_TITLE2).Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                new XRL2DeleteSession(badSessionInfo.SessionID, Constants.XENON_TITLE2).Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
            }
        }
        [TestCase, Description("do not pass gameMode in search request")]
        class NSearchUserNoGameMode : TestBase
        {
            override protected void Execute()
            {
                // create a session with gameMode set to 0
                XRL2CreateUpdateSession		createReq;
                XRLXeAttribParam	[]		Attribs = new XRLXeAttribParam[9];
                Attribs[0] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_TYPE,new XRLXeIntValue(Constants.X_ATTRIBUTE_GAME_TYPE_RANKED));
                Attribs[1] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE, new XRLXeIntValue(0));
                Attribs[2] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_ZONE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_ZONE));
                Attribs[3] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_COUNTRY, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_COUNTRY));
                Attribs[4] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_LANGUAGE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_LANG));
                Attribs[5] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_RATING, new XRLXeFloatValue(Constants.XENON_TEST_DEFAULT_GAMER_RATING));
                Attribs[6] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_MU,new XRLXeDoubleValue(Constants.XENON_TEST_DEFAULT_GAMER_MU));
                Attribs[7] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_SIGMA, new XRLXeDoubleValue(Constants.XENON_TEST_DEFAULT_GAMER_SIGMA));
                Attribs[8] = new XRLXeAttribParam(Constants.PROPERTY_MYFLOAT32PROP1_XENON_TITLE2, new XRLXeFloatValue(0.1f));
				
                createReq = new XRL2CreateUpdateSession(Attribs);
                createReq.baseCreateUpdate.baseSession.dwTitleID = Constants.XENON_TITLE2;
                XRLSessionInfo	createResp;
                if(createReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out createResp))
                {

                    XRLXeAttribParam	[]		searchParams = new XRLXeAttribParam[8];
                    searchParams[0] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_TYPE,new XRLXeIntValue(Constants.X_ATTRIBUTE_GAME_TYPE_RANKED));
                    searchParams[2] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_ZONE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_ZONE));
                    searchParams[3] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_COUNTRY, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_COUNTRY));
                    searchParams[4] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_LANGUAGE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_LANG));
                    searchParams[5] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_RATING, new XRLXeFloatValue(Constants.XENON_TEST_DEFAULT_GAMER_RATING));
                    searchParams[6] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_MU,new XRLXeDoubleValue(Constants.XENON_TEST_DEFAULT_GAMER_MU));
                    searchParams[7] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_SIGMA, new XRLXeDoubleValue(Constants.XENON_TEST_DEFAULT_GAMER_SIGMA));
                    searchParams[1] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_PUID, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_PUID));

                    XRL2SearchSession	searchReq = new XRL2SearchSession(searchParams,Constants.SESSION_MATCH_QUERY_SOCIALMATCHQUERYFORTITLEONSINGLEDB);
                    searchReq.baseSearchSession.dwTitleID = Constants.XENON_TITLE2;
                    XRL2SearchResults	searchResp;
                    if(!searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out searchResp))
                    {
                        //see #106671 for the debate on why this is invalid
                        //param, while the create tests use PARAM_MISSING
                        if(searchReq.XErr == HResult.XONLINE_E_MATCH_INVALID_PARAM) {
                            ResultCode=TEST_RESULTS.PASSED;
                        } else {
                            Global.RO.Error("Search request returns " + Global.XErrToString(searchReq.XErr) + 
                                            " when it should have retunred XONLINE_E_MATCH_INVALID_PARAM!");
                        }
                    }
                    new XRL2DeleteSession(createResp.SessionID,Constants.XENON_TITLE2).Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                }
            }
        }
        [TestCase, Description("Bug 29905:do not pass game type in search request")]
        class NSearchUserNoGameType : TestBase
        {
            override protected void Execute()
            {
                // create a session with gameType set to 0
                XRL2CreateUpdateSession		createReq;
                XRLXeAttribParam	[]		Attribs = new XRLXeAttribParam[9];
                Attribs[0] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_TYPE,new XRLXeIntValue(0));
                Attribs[1] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE, new XRLXeIntValue(Constants.CONTEXT_GAME_MODE_MODEA));
                Attribs[2] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_ZONE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_ZONE));
                Attribs[3] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_COUNTRY, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_COUNTRY));
                Attribs[4] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_LANGUAGE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_LANG));
                Attribs[5] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_RATING, new XRLXeFloatValue(Constants.XENON_TEST_DEFAULT_GAMER_RATING));
                Attribs[6] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_MU,new XRLXeDoubleValue(Constants.XENON_TEST_DEFAULT_GAMER_MU));
                Attribs[7] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_SIGMA, new XRLXeDoubleValue(Constants.XENON_TEST_DEFAULT_GAMER_SIGMA));
                Attribs[8] = new XRLXeAttribParam(Constants.PROPERTY_MYFLOAT32PROP1_XENON_TITLE2, new XRLXeFloatValue(0.1f));

                createReq = new XRL2CreateUpdateSession(Attribs);
                createReq.baseCreateUpdate.baseSession.dwTitleID = Constants.XENON_TITLE2;
                XRLSessionInfo	createResp;
                if(createReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out createResp))
                {
                    XRLXeAttribParam	[]		searchParams = new XRLXeAttribParam[8];
                    searchParams[0] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE,new XRLXeIntValue(Constants.CONTEXT_GAME_MODE_MODEA));
                    searchParams[2] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_ZONE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_ZONE));
                    searchParams[3] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_COUNTRY, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_COUNTRY));
                    searchParams[4] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_LANGUAGE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_LANG));
                    searchParams[5] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_RATING, new XRLXeFloatValue(Constants.XENON_TEST_DEFAULT_GAMER_RATING));
                    searchParams[6] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_MU,new XRLXeDoubleValue(Constants.XENON_TEST_DEFAULT_GAMER_MU));
                    searchParams[7] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_SIGMA, new XRLXeDoubleValue(Constants.XENON_TEST_DEFAULT_GAMER_SIGMA));
                    searchParams[1] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_PUID, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_PUID));

                    XRL2SearchSession	searchReq = new XRL2SearchSession(searchParams,Constants.SESSION_MATCH_QUERY_SOCIALMATCHQUERYFORTITLEONSINGLEDB);
                    searchReq.baseSearchSession.dwTitleID = Constants.XENON_TITLE2;
                    XRL2SearchResults	searchResp;
                    if(!searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out searchResp))
                    {
                        //see #106671 for the debate on why this is invalid
                        //param, while the create tests use PARAM_MISSING
                        if(searchReq.XErr == HResult.XONLINE_E_MATCH_INVALID_PARAM)
                            ResultCode=TEST_RESULTS.PASSED;
                    }
                    new XRL2DeleteSession(createResp.SessionID,Constants.XENON_TITLE2).Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                }			
            }
        }
        [TestCase, Description("do not pass game zone in search request")]
        class NSearchUserNoGamerZone : NegativeSocialRankedMatchTestBase
        {
            override protected void Execute()
            {
                // create a session with gamerZone set to 0
                XRL2CreateUpdateSession		createReq;
                XRLXeAttribParam	[]		Attribs = new XRLXeAttribParam[9];
                Attribs[0] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_TYPE,new XRLXeIntValue(Constants.X_ATTRIBUTE_GAME_TYPE_RANKED));
                Attribs[1] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE, new XRLXeIntValue(Constants.CONTEXT_GAME_MODE_MODEA));
                Attribs[2] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_ZONE,new XRLXeIntValue(0));
                Attribs[3] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_COUNTRY, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_COUNTRY));
                Attribs[4] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_LANGUAGE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_LANG));
                Attribs[5] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_RATING, new XRLXeFloatValue(Constants.XENON_TEST_DEFAULT_GAMER_RATING));
                Attribs[6] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_MU,new XRLXeDoubleValue(Constants.XENON_TEST_DEFAULT_GAMER_MU));
                Attribs[7] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_SIGMA, new XRLXeDoubleValue(Constants.XENON_TEST_DEFAULT_GAMER_SIGMA));
                Attribs[8] = new XRLXeAttribParam(Constants.PROPERTY_MYFLOAT32PROP1_XENON_TITLE2, new XRLXeFloatValue(0.1f));

                createReq = new XRL2CreateUpdateSession(Attribs);
                createReq.baseCreateUpdate.baseSession.dwTitleID = Constants.XENON_TITLE2;
                XRLSessionInfo	createResp;
                if(createReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out createResp))
                {
                    XRLXeAttribParam	[]		searchParams = new XRLXeAttribParam[8];
                    searchParams[0] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE,new XRLXeIntValue(Constants.CONTEXT_GAME_MODE_MODEA));
                    searchParams[2] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_TYPE,new XRLXeIntValue(Constants.X_ATTRIBUTE_GAME_TYPE_RANKED));
                    searchParams[3] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_COUNTRY, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_COUNTRY));
                    searchParams[4] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_LANGUAGE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_LANG));
                    searchParams[5] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_RATING, new XRLXeFloatValue(Constants.XENON_TEST_DEFAULT_GAMER_RATING));
                    searchParams[6] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_MU,new XRLXeDoubleValue(Constants.XENON_TEST_DEFAULT_GAMER_MU));
                    searchParams[7] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_SIGMA, new XRLXeDoubleValue(Constants.XENON_TEST_DEFAULT_GAMER_SIGMA));
                    searchParams[1] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_PUID, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_PUID));

                    XRL2SearchSession	searchReq = new XRL2SearchSession(searchParams,Constants.SESSION_MATCH_QUERY_SOCIALMATCHQUERYFORTITLEONSINGLEDB);
                    searchReq.baseSearchSession.dwTitleID = Constants.XENON_TITLE2;
                    XRL2SearchResults	searchResp;
                    if(searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out searchResp))
                    {
                        if((searchResp != null) && (searchResp.resultsLen == 1))
                            ResultCode=TEST_RESULTS.PASSED;
                    }
                    new XRL2DeleteSession(createResp.SessionID,Constants.XENON_TITLE2).Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                }						
            }
        }
        [TestCase, Description("")]
        class NCreateNoMuSigmaRating: NegativeSocialRankedMatchTestBase
        {
            override protected void Execute()
            {
                XRLXeAttribParam	[]		Attribs = new XRLXeAttribParam[5];
                Attribs[0] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_TYPE,new XRLXeIntValue(Constants.X_ATTRIBUTE_GAME_TYPE_RANKED));
                Attribs[1] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE, new XRLXeIntValue(Constants.CONTEXT_GAME_MODE_MODEA));
                Attribs[2] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_ZONE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_ZONE));
                Attribs[3] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_COUNTRY, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_COUNTRY));
                Attribs[4] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_LANGUAGE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_LANG));

                XRL2CreateUpdateSession	createReq = new XRL2CreateUpdateSession(Attribs);
                createReq.baseCreateUpdate.baseSession.dwTitleID = Constants.XENON_TITLE2;
                XRLSessionInfo			createResp;
                if((createReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out createResp)))
                {
                    long sessionID = Constants.sessionIDConvert(createResp.SessionID);
                    // check database mu=3,sigma=1 and rating=58.72
                    if(VerifyDB(true,sessionID,3,1,58.72f))
                        ResultCode=TEST_RESULTS.PASSED;
                }
                new XRL2DeleteSession(createResp.SessionID,Constants.XENON_TITLE2).Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
            }
        }
        [TestCase, Description("Bug 28190:create a ranked match with mu set to -0.001,sigma set to -0.001,rating set to -0.001")]
        class NCreateBadMuSigmaRating1 : NegativeSocialRankedMatchTestBase
        {
            override protected void Execute()
            {
                XRLXeAttribParam	[]		Attribs = new XRLXeAttribParam[8];
                Attribs[0] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_TYPE,new XRLXeIntValue(Constants.X_ATTRIBUTE_GAME_TYPE_RANKED));
                Attribs[1] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE, new XRLXeIntValue(Constants.CONTEXT_GAME_MODE_MODEA));
                Attribs[2] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_ZONE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_ZONE));
                Attribs[3] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_COUNTRY, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_COUNTRY));
                Attribs[4] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_LANGUAGE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_LANG));
                Attribs[5] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_RATING, new XRLXeFloatValue(-0.001f));
                Attribs[6] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_MU,new XRLXeDoubleValue(-0.001));
                Attribs[7] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_SIGMA, new XRLXeDoubleValue(-0.001));

                XRL2CreateUpdateSession	createReq = new XRL2CreateUpdateSession(Attribs);
                createReq.baseCreateUpdate.baseSession.dwTitleID = Constants.XENON_TITLE2;
                XRLSessionInfo			createResp;
                if((createReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out createResp)))
                {
                    long sessionID = Constants.sessionIDConvert(createResp.SessionID);
                    // check database mu=0,sigma=0 and rating=0
                    if(VerifyDB(true,sessionID,0,0,0))
                        ResultCode=TEST_RESULTS.PASSED;
                }
                new XRL2DeleteSession(createResp.SessionID,Constants.XENON_TITLE2).Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
            }
        }
        [TestCase, Description("Bug 28190:create a ranked match with mu set to 6.001,sigma set to 1.001,rating set to 100.001")]
        class NCreateBadMuSigmaRating2 : NegativeSocialRankedMatchTestBase
        {
            override protected void Execute()
            {
                XRLXeAttribParam	[]		Attribs = new XRLXeAttribParam[8];
                Attribs[0] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_TYPE,new XRLXeIntValue(Constants.X_ATTRIBUTE_GAME_TYPE_RANKED));
                Attribs[1] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE, new XRLXeIntValue(Constants.CONTEXT_GAME_MODE_MODEA));
                Attribs[2] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_ZONE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_ZONE));
                Attribs[3] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_COUNTRY, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_COUNTRY));
                Attribs[4] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_LANGUAGE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_LANG));
                Attribs[5] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_RATING, new XRLXeFloatValue(100.001f));
                Attribs[6] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_MU,new XRLXeDoubleValue(6.001));
                Attribs[7] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_SIGMA, new XRLXeDoubleValue(1.001));

                XRL2CreateUpdateSession	createReq = new XRL2CreateUpdateSession(Attribs);
                createReq.baseCreateUpdate.baseSession.dwTitleID = Constants.XENON_TITLE2;
                XRLSessionInfo			createResp;
                if((createReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out createResp)))
                {
                    long sessionID = Constants.sessionIDConvert(createResp.SessionID);
                    // check database mu=6,sigma=1 and rating=100
                    if(VerifyDB(true,sessionID,6,1,100))
                        ResultCode=TEST_RESULTS.PASSED;
                }
                new XRL2DeleteSession(createResp.SessionID,Constants.XENON_TITLE2).Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
            }
        }
        [TestCase, Description("Bug 28190:update a ranked match with mu set to -0.001,sigma set to -0.001,rating set to -0.001")]
        class NUpdateBadMuSigmaRating1 : NegativeSocialRankedMatchTestBase
        {
            override protected void Execute()
            {
                XRL2CreateUpdateSession	createReq = new XRL2CreateUpdateSession();
                createReq.baseCreateUpdate.baseSession.dwTitleID = Constants.XENON_TITLE2;
                XRLSessionInfo			createResp;
                if((createReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out createResp)))
                {
                    XRLXeAttribParam	[]		Attribs = new XRLXeAttribParam[3];
                    Attribs[0] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_RATING, new XRLXeFloatValue(-0.001f));
                    Attribs[1] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_MU,new XRLXeDoubleValue(-0.001));
                    Attribs[2] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_SIGMA, new XRLXeDoubleValue(-0.001));

                    long					sessionID = Constants.sessionIDConvert(createResp.SessionID);
                    XRL2CreateUpdateSession	updateReq = new XRL2CreateUpdateSession(createResp.SessionID);
                    updateReq.baseCreateUpdate.baseSession.dwTitleID = Constants.XENON_TITLE2;
                    updateReq.AddAttribs(Attribs);
                    if(updateReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd)))
                    {
                        // check database mu=0,sigma=0 and rating=0
                        if(VerifyDB(true,sessionID,0,0,0))
                            ResultCode=TEST_RESULTS.PASSED;
                    }
                }
                new XRL2DeleteSession(createResp.SessionID,Constants.XENON_TITLE2).Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
            }
        }
        [TestCase, Description("Bug 28190:update a ranked match with mu set to 6.001,sigma set to 1.001,rating set to 100.001")]
        class NUpdateBadMuSigmaRating2 : NegativeSocialRankedMatchTestBase
        {
            override protected void Execute()
            {
                XRL2CreateUpdateSession	createReq = new XRL2CreateUpdateSession();
                createReq.baseCreateUpdate.baseSession.dwTitleID = Constants.XENON_TITLE2;
                XRLSessionInfo			createResp;
                if((createReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out createResp)))
                {
                    XRLXeAttribParam	[]		Attribs = new XRLXeAttribParam[3];
                    Attribs[0] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_RATING, new XRLXeFloatValue(100.001f));
                    Attribs[1] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_MU,new XRLXeDoubleValue(6.001));
                    Attribs[2] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_SIGMA, new XRLXeDoubleValue(1.001));

                    long					sessionID = Constants.sessionIDConvert(createResp.SessionID);
                    XRL2CreateUpdateSession	updateReq = new XRL2CreateUpdateSession(createResp.SessionID);
                    updateReq.AddAttribs(Attribs);
                    updateReq.baseCreateUpdate.baseSession.dwTitleID = Constants.XENON_TITLE2;

                    if(updateReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd)))
                    {
                        // check database mu=6,sigma=1 and rating=100
                        if(VerifyDB(true,sessionID,6,1,100))
                            ResultCode=TEST_RESULTS.PASSED;
                    }
                }
                new XRL2DeleteSession(createResp.SessionID,Constants.XENON_TITLE2).Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
            }
        }

        abstract class NFastFail : RankedMatchTestBase
        {
            protected const string timeoutSproc = @"
ALTER PROCEDURE [dbo].[p_match_session_v2_0xFFED94B2_0x00000000_search_ranked]
    @i_max_results                  int OUTPUT
   ,@si_required_slots              smallint
   ,@i_client_ip                    int
   ,@ti_nat_type                    tinyint
   ,@ti_server_count                tinyint
   ,@param_0x0000800A               bigint
   ,@param_0x0000800B               bigint
   ,@param_0x10008101               int = 1
   ,@param_0x10008102               int = 103
   ,@param_0x10008103               int = 1
   ,@param_0x50008104               real = 58.72
   ,@param_0x30008105               float = 3
   ,@param_0x30008106               float = 1
   ,@param_0x20008107               bigint = 0
   ,@param_0x40008109               nvarchar(400) = ''
   ,@param_0x10008201               int = 0
   ,@param_0x10008202               int = 0
   ,@param_0x10000002               int = NULL
   ,@param_0x20000003               bigint = NULL
   ,@param_0x70000006               bigint = NULL
   ,@param_0x50000007               real = NULL
   ,@param_0x30000008               float = NULL
   ,@param_0x00000002               bigint = NULL

AS
-- Match Code Generator Version - !!Version=5.1.62.0
-- Xlast (XDK) Version = 2.0.3528.0
-- Xlast Project Version = 1.00.0193.0
BEGIN
   -- Force a timeout by sleeping for 1 minute
   WAITFOR DELAY '00:01:00'
END";

            protected string CreateToAlterSproc(string createSproc)
            {
                if (!createSproc.Trim().ToUpper().StartsWith("CREATE"))
                {
                    throw new UnexpectedTestResultException("CREATE not found in expected location");
                }
                createSproc = createSproc.Trim().Remove(0, "CREATE".Length);
                return "ALTER" + createSproc;
            }

            protected class SearchSessionParams
            {
                public MatchSession session = null;
                public uint titleID;
                public XRLXeAttribParam[] searchParams = null;
                public uint spIndex;
                public XRL2SearchResults searchResults = null;

                public SearchSessionParams(MatchSession session, uint titleID, XRLXeAttribParam[] searchParams, uint spIndex)
                {
                    this.session = session;
                    this.titleID = titleID;
                    this.searchParams = searchParams;
                    this.spIndex = spIndex;
                }
            }

            protected void SearchSessionExecutor(ref object sessionParams)
            {
                SearchSessionParams p = (SearchSessionParams)sessionParams;
                p.searchResults = MatchUtil.CustomSearch(p.titleID, CSGInfo.ClientType.Xenon, p.searchParams, p.spIndex);
            }
        }

        [TestCase, Description("Verify FastFail/DB Blacklisting with 2 Title SQL Servers")]
        class NFastFail_Timeout : NFastFail
        {
            override protected void Execute()
            {
                MatchSession session = new MatchSession();
                uint titleID = Constants.XENON_TITLE;
                uint spIndex = Constants.SESSION_MATCH_QUERY_QUERY1;

                // Verify fast search response
                TimeBomb timer = new TimeBomb(3 * 1000);
                timer.Start();
                XRL2SearchResults searchResults = MatchUtil.CustomSearch(titleID, CSGInfo.ClientType.Xenon, null, spIndex);
                timer.Stop();

                // Set a new ranked search sproc to force a timeout
                TitleSqlServerSet sqlServers = new TitleSqlServerSet(titleID);
                string[] originalSprocs = sqlServers.GetCreateSproc(
                    "p_match_session_v2_0x" + titleID.ToString("X").PadLeft(8, '0') +
                    "_0x" + spIndex.ToString("X").PadLeft(8, '0') + "_search_ranked");
                System.Diagnostics.Debug.WriteLine(originalSprocs[0]);
                sqlServers.ExecuteScalar(timeoutSproc);

                // Attempt to force all of the FDs to simultaneously blacklist the title sql servers
                SimpleJobMgr jobMgr = new SimpleJobMgr();
                SimpleJobMgr.ExecutorDelegate sessionExector = new SimpleJobMgr.ExecutorDelegate(SearchSessionExecutor);
                for (int i = 0; i < 50; i++)
                {
                    jobMgr.AddJob(sessionExector, new SearchSessionParams(session, titleID, null, spIndex));
                }
                jobMgr.StartJobs(50);
                while (!jobMgr.Empty())
                {
                    SimpleJobMgr.Job job = jobMgr.GetCompletedJob();
                    if (job.Exception != null)
                    {
                        Global.RO.Debug("SearchSessionExecutor failed with exception:\r\n{0}", job.Exception);
                    }
                    if (((SearchSessionParams)job.State).searchResults != null)
                    {
                        Global.RO.Info("SearchSessionExecutor returned resultsLen: " + ((SearchSessionParams)job.State).searchResults.resultsLen);
                    }
                }

                try
                {
                    timer = new TimeBomb(4 * 1000);
                    timer.Start();
                    searchResults = MatchUtil.CustomSearch(titleID, CSGInfo.ClientType.Xenon, null, spIndex);
                }
                catch (Exception ex)
                {
                    timer.Stop();

                    Global.RO.Info("Exception caught: " + ex.Message);

                    // Allow server blacklistings to expire
                    //TODO: 60 secs is current default, this should be pulled from NPDB however
                    Thread.Sleep(65 * 1000);
                }
                finally
                {
                    // Restore the original sproc
                    sqlServers.ExecuteScalar(CreateToAlterSproc(originalSprocs[0]));

                    // Verify the change took place
                    timer = new TimeBomb(5 * 1000);
                    timer.Start();
                    searchResults = MatchUtil.CustomSearch(titleID, CSGInfo.ClientType.Xenon, null, spIndex);
                    timer.Stop();
                }
                ResultCode = TEST_RESULTS.PASSED;               
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XMatchTest\Func2CreateSession.cs ===
using System;
using System.Data.SqlClient;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Matchmaking;
using ServerTestFramework.LiveService.FakeSG;
using xonline.common.config;

namespace XMatchTest
{
    internal abstract class Create2TestBase : TestBase
    {
        /// <summary>
        /// 
        /// </summary>
        /// <param name="Req"></param>
        /// <param name="ranked">false if this session is a standard session</param>
        /// <returns></returns>
        protected bool CreateAndVerify(bool ranked, XRL2CreateUpdateSession Req)
        {
            XRLSessionInfo resp = null;
            bool ret = true;
            try
            {
                if (!Req.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out resp))
                {
                    Global.RO.Warn("CreateSession request failed:" + Global.XErrToString(Req.XErr));
                    return false;
                }
                XRL2SearchResults searchResults;
                ret = FindSession(resp.SessionID, out searchResults) && ret;

                // check if session created correctly in the t_match_sessions_<title>
                if (!Req.Verify(searchResults, ranked))
                {
                    Global.RO.Warn("The session is not setup correctly in the db");
                    ret = false;
                }
            }
            catch (Exception e)
            {
                Global.RO.Warn("Unexpected exception thrown:" + e.Message);
                ret = false;
            }

            // delete the session
            XRL2DeleteSession delReq = new XRL2DeleteSession(resp.SessionID, Req.baseCreateUpdate.baseSession.dwTitleID);
            if (!delReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd)))
            {
                Global.RO.Warn("Session deletion failed");
            }

            return ret;
        }

        protected XRL2SearchSession CreateSearchRequest(byte [] SessionID) {
            XRL2SearchSession searchReq = new XRL2SearchSession(false, Constants.X_SSINDEX_GET_SESSION);
            // convert byte[8] to long; integer is little endian on the wire:
            // 01020304 on the wire is actually interpreted as int=0x04030201 internally
            // little endian locally
            long lSessID = Constants.sessionIDConvert(SessionID);
            XRLXeAttribParam[] Params = new XRLXeAttribParam[1] {
                new XRLXeAttribParam(Constants.X_ATTRIBUTE_SESSION_ID,
                                     new XRLXeIntValue(lSessID)) };
            searchReq.AddParams(Params);
            return searchReq;
        }

        protected bool FindSession(byte [] SessionID, out XRL2SearchResults searchResults) {
            bool ret = true;
            XRL2SearchSession searchReq = CreateSearchRequest(SessionID);

            if (!searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out searchResults))
            {
                Global.RO.Warn("search for the newly created session failed:" + Global.XErrToString(searchReq.XErr));
                ret = false;
            }
            if (searchResults == null)
            {
                Global.RO.Warn("The newly created session couldn't be found");
                ret = false;
            }
            return ret;
        }


        protected bool VerifyDB(bool ranked, long lSessID, double mu, double sigma, float rating, long country, long lang, long gamerZone, long gameType, long gameMode)
        {
            // in xbox 360, we might not have title tables created across all servers, 
            // instead, we will only have title tables created in the actual servers that they live
            bool ret = false;
            double rMu = 0, rSigma = 0;
            long rCountry = 0, rLang = 0, rZone = 0, rGameType = 0, rGameMode = 0;
            float rRating = 0;
            string hexTitleID = "0x" + Constants.XENON_TITLE.ToString("X");
            string[] dbList = Constants.getDBListForTitle(Constants.XENON_TITLE);
            if (dbList == null)
            {
                Global.RO.Warn("Can't find the title in the npdb");
                return false;
            }

            bool found = false;
            foreach (string server in dbList)
            {
                found = false;
                // connect to the db
                string myConnStr = "Data Source=" + server + @";Database=xmatch;" +
                    "Trusted_Connection=true";
                SqlConnection mySqlConn;
                mySqlConn = new SqlConnection(myConnStr);
                // get the row according to bi_session_id
                string myQuery;
                if (ranked)
                    myQuery = @"SELECT		att_0x30008105,att_0x30008106,att_0x50008104,att_0x10008102,att_0x10008103,att_0x10008101,att_0x0000800A,att_0x0000800B
											FROM dbo.t_match_sessions_" + hexTitleID + @"_ranked s
											WHERE s.bi_session_id=" + lSessID;
                else //standard
                    myQuery = @"SELECT		att_0x30008105,att_0x30008106,att_0x50008104,att_0x10008102,att_0x10008103,att_0x10008101,att_0x0000800A,att_0x0000800B
											FROM dbo.t_match_sessions_" + hexTitleID + @"_standard s
											WHERE s.bi_session_id=" + lSessID;

                SqlCommand myCommand = new SqlCommand(myQuery, mySqlConn);
                myCommand.Connection.Open();
                SqlDataReader myReader = myCommand.ExecuteReader();
                while (myReader.Read())
                {
                    found = true;
                    rMu = myReader.GetDouble(0);
                    rSigma = myReader.GetDouble(1);
                    rRating = myReader.GetFloat(2);
                    rCountry = myReader.GetInt32(3);
                    rLang = myReader.GetInt32(4);
                    rZone = myReader.GetInt32(5);
                    rGameType = myReader.GetInt64(6);
                    rGameMode = myReader.GetInt64(7);
                }
                myReader.Close();
                myCommand.Connection.Close();
                if (found)
                    break;
            }
            if (found)
            {
                if ((rMu == mu) && (rSigma == sigma) && (rRating == rating)
                    && (rCountry == country) && (rZone == gamerZone) && (rLang == lang)
                    && (rGameType == gameType) && (rGameMode == gameMode))
                    ret = true;
                else Global.RO.Warn("returned mu/sigma/rating/country/zone/lang/type/mode is not correct");
            }
            else
            {
                Global.RO.Warn("Couldn't not find the session");
            }
            return ret;
        }
    }
    internal abstract class NegativeCreate2TestBase : TestBase
    {
        protected bool CreateTestNegative(XRL2CreateUpdateSession Req, uint XErr)
        {
            XRLSessionInfo resp;
            if (Req.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out resp))
            {
                Global.RO.Warn("Negative CreateSession request succeed unexpectedly");
                XRL2DeleteSession delReq = new XRL2DeleteSession(resp.SessionID, Req.baseCreateUpdate.baseSession.dwTitleID);
                delReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                return false;
            }
            if ((Req.XErr != XErr) || (resp != null))
            {
                Global.RO.Warn("Wrong error code (" + Global.XErrToString(Req.XErr) + " != " + Global.XErrToString(XErr) + ") returned or response is not null");
                return false;
            }
            return true;
        }
    }
    // there are lots of createSession test cases that were covered in the
    // searchSession cases: session with multiple attributes, etc
    [BVT]
    [TestGroup]
    public class Func2CreateSession : TestNode
    {
        /***********************************************************************
         * The followings are positive cases
         ***********************************************************************/
        [TestCase, Description("Create a session with maximum attributes: 40 customize + 10 system")]
        class PMaxAttribs : Create2TestBase
        {
            override protected void Execute()
            {
                XRL2CreateUpdateSession req = new XRL2CreateUpdateSession();
                XRLXeAttribParam[] attrib = new XRLXeAttribParam[38]{ 
                    new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP1,new XRLXeIntValue(1)),
                    new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP2,new XRLXeIntValue(1)),
                    new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP3,new XRLXeIntValue(1)),
                    new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP4,new XRLXeIntValue(1)),
                    new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP5,new XRLXeIntValue(1)),
                    new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP6,new XRLXeIntValue(1)),
                    new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP7,new XRLXeIntValue(1)),
                    new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP8,new XRLXeIntValue(1)),
                    new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP9,new XRLXeIntValue(1)),
                    new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP10,new XRLXeIntValue(1)),
                    new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP11,new XRLXeIntValue(1)),
                    new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP12,new XRLXeIntValue(1)),
                    new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP13,new XRLXeIntValue(1)),
                    new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP14,new XRLXeIntValue(1)),
                    new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP15,new XRLXeIntValue(1)),
                    new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP16,new XRLXeIntValue(1)),
                    new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP17,new XRLXeIntValue(1)),
                    new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP18,new XRLXeIntValue(1)),
                    new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP19,new XRLXeIntValue(1)),
                    new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP20,new XRLXeIntValue(1)),
                    new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP21,new XRLXeIntValue(1)),
                    new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP22,new XRLXeIntValue(1)),
                    new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP23,new XRLXeIntValue(1)),
                    new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP24,new XRLXeIntValue(1)),
                    new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP25,new XRLXeIntValue(1)),
                    new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP26,new XRLXeIntValue(1)),
                    new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP27,new XRLXeIntValue(1)),
                    new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP28,new XRLXeIntValue(1)),
                    new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP29,new XRLXeIntValue(1)),
                    new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP30,new XRLXeIntValue(1)),
                    new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP31,new XRLXeIntValue(1)),
                    new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP32,new XRLXeIntValue(1)),
                    //new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP33,new XRLXeIntValue(1)),
                    //new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP34,new XRLXeIntValue(1)),
                    new XRLXeAttribParam(Constants.PROPERTY_MYFLOAT64PROP1,new XRLXeDoubleValue(1.0)),
                    new XRLXeAttribParam(Constants.PROPERTY_MYFLOAT32PROP1,new XRLXeFloatValue(1.0f)),
                    new XRLXeAttribParam(Constants.PROPERTY_MYINT32PROP1,new XRLXeIntValue(1)),
                    new XRLXeAttribParam(Constants.PROPERTY_MYDATETIMEPROP1,new XRLXeDateTimeValue(DateTime.Now.ToFileTimeUtc())),
                    new XRLXeAttribParam(Constants.PROPERTY_GAMERNAME,new XRLXeStringValue("abc\0")),
                    new XRLXeAttribParam(Constants.CONTEXT_MYCONTEXT1,new XRLXeIntValue(1))
                };
                req.AddAttribs(attrib);

                XRLSessionInfo resp;
                if (!req.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out resp))
                {
                    throw new UnexpectedTestResultException(MatchUtil.ErrMsgFromXRLPayload("Create failed.", req));
                }
                ResultCode = TEST_RESULTS.PASSED;
                new XRL2DeleteSession(resp.SessionID, req.baseCreateUpdate.baseSession.dwTitleID).Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
            }
        }


        [TestCase, Description("Create a session with the new maximum attributes: 50 title defined.")]
        class PMaxAttribsUpdated : Create2TestBase
        {
            override protected void Execute()
            {
                XRL2CreateUpdateSession req = new XRL2CreateUpdateSession();
                XRLXeAttribParam[] attrib = new XRLXeAttribParam[50]{ 
                    new XRLXeAttribParam(Constants.PROPERTY_MYINT32PROP1,new XRLXeIntValue(1)),
                    new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP1,new XRLXeIntValue(1)),
                    new XRLXeAttribParam(Constants.PROPERTY_MYDATETIMEPROP1,new XRLXeDateTimeValue(DateTime.Now.ToFileTimeUtc())),
                    new XRLXeAttribParam(Constants.PROPERTY_MYFLOAT32PROP1,new XRLXeFloatValue(1.0f)),
                    new XRLXeAttribParam(Constants.PROPERTY_MYFLOAT64PROP1,new XRLXeDoubleValue(1.0)),
                    new XRLXeAttribParam(Constants.PROPERTY_MYFLOAT64PROP2,new XRLXeDoubleValue(1.0)),
                    new XRLXeAttribParam(Constants.CONTEXT_MYCONTEXT1,new XRLXeIntValue(1)),
                    new XRLXeAttribParam(Constants.PROPERTY_GAMERNAME,new XRLXeStringValue("abc\0")),
                    new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP2,new XRLXeIntValue(1)),
                    new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP3,new XRLXeIntValue(1)),

                    new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP4,new XRLXeIntValue(1)),
                    new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP5,new XRLXeIntValue(1)),
                    new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP6,new XRLXeIntValue(1)),
                    new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP7,new XRLXeIntValue(1)),
                    new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP8,new XRLXeIntValue(1)),
                    new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP9,new XRLXeIntValue(1)),
                    new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP10,new XRLXeIntValue(1)),
                    new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP11,new XRLXeIntValue(1)),
                    new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP12,new XRLXeIntValue(1)),
                    new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP13,new XRLXeIntValue(1)),

                    new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP14,new XRLXeIntValue(1)),
                    new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP15,new XRLXeIntValue(1)),
                    new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP16,new XRLXeIntValue(1)),
                    new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP17,new XRLXeIntValue(1)),
                    new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP18,new XRLXeIntValue(1)),
                    new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP19,new XRLXeIntValue(1)),
                    new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP20,new XRLXeIntValue(1)),
                    new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP21,new XRLXeIntValue(1)),
                    new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP22,new XRLXeIntValue(1)),
                    new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP23,new XRLXeIntValue(1)),

                    new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP24,new XRLXeIntValue(1)),
                    new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP25,new XRLXeIntValue(1)),
                    new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP26,new XRLXeIntValue(1)),
                    new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP27,new XRLXeIntValue(1)),
                    new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP28,new XRLXeIntValue(1)),
                    new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP29,new XRLXeIntValue(1)),
                    new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP30,new XRLXeIntValue(1)),
                    new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP31,new XRLXeIntValue(1)),
                    new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP32,new XRLXeIntValue(1)),
                    new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP33,new XRLXeIntValue(1)),

                    new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP34,new XRLXeIntValue(1)),
                    new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP35,new XRLXeIntValue(1)),
                    new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP36,new XRLXeIntValue(1)),
                    new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP37,new XRLXeIntValue(1)),
                    new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP38,new XRLXeIntValue(1)),
                    new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP39,new XRLXeIntValue(1)),
                    new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP40,new XRLXeIntValue(1)),
                    new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP41,new XRLXeIntValue(1)),
                    new XRLXeAttribParam(Constants.PROPERTY_MYINT32PROP2,new XRLXeIntValue(1)),
                    new XRLXeAttribParam(Constants.PROPERTY_MYFLOAT32PROP2,new XRLXeFloatValue(1.0f))
                };
                req.AddAttribs(attrib);

                XRLSessionInfo resp;
                if (!req.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out resp))
                {
                    throw new UnexpectedTestResultException(MatchUtil.ErrMsgFromXRLPayload("Create failed.", req));
                }
                ResultCode = TEST_RESULTS.PASSED;
                new XRL2DeleteSession(resp.SessionID, req.baseCreateUpdate.baseSession.dwTitleID).Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
            }
        }

        [TestCase, Description("Create a session with X_ATTRIBUTE_DATATYPE_NULL as attributeID")]
        class PNullAttribID : Create2TestBase
        {
            override protected void Execute()
            {
                XRL2CreateUpdateSession req = new XRL2CreateUpdateSession();
                XRLXeAttribParam[] attrib = new XRLXeAttribParam[1] { new XRLXeAttribParam(Constants.X_ATTRIBUTE_DATATYPE_NULL, new XRLXeNullValue()) };
                req.AddAttribs(attrib);

                if (CreateAndVerify(true, req))
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("Create a session with all 8 default session attributes")]
        class PDefaultSessionAttribsOnly : Create2TestBase
        {
            override protected void Execute()
            {
                XRL2CreateUpdateSession req = new XRL2CreateUpdateSession();

                if (CreateAndVerify(true, req))
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("Create a session with a string attribute gamername along with all default attributes.")]
        class PSystemStringAttrib : Create2TestBase
        {
            override protected void Execute()
            {
                XRL2CreateUpdateSession req = new XRL2CreateUpdateSession();
                XRLXeAttribParam Attribs = new XRLXeAttribParam(Constants.X_ATTRIBUTE_HOST_NAME, "myHostName\0");
                req.UpdateAttrib(Attribs);

                if (CreateAndVerify(true, req))
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("Create a session with gamerPUID along with other default attributes.")]
        class PGamerPUID : Create2TestBase
        {
            override protected void Execute()
            {
                XRL2CreateUpdateSession req = new XRL2CreateUpdateSession();
                XRLXeAttribParam[] Attribs = new XRLXeAttribParam[1]{
                    new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_PUID,new XRLXeIntValue(Int64.MaxValue))};
                req.AddAttribs(Attribs);

                if (CreateAndVerify(true, req))
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("Create a session with a title-specific int32 attribute with max value")]
        class PInt32Attrib : Create2TestBase
        {
            override protected void Execute()
            {
                XRL2CreateUpdateSession req = new XRL2CreateUpdateSession();
                XRLXeAttribParam[] atts = new XRLXeAttribParam[1]{new XRLXeAttribParam(Constants.PROPERTY_MYINT32PROP1,
                                                                                       new XRLXeIntValue(Int32.MaxValue))};
                req.AddAttribs(atts);

                // verification of int attributes will be done in the searchSession test cases.
                if (CreateAndVerify(true, req))
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("Create a session with a title-specific int64 attribute with max value")]
        class PInt64Attrib1 : Create2TestBase
        {
            override protected void Execute()
            {
                XRL2CreateUpdateSession req = new XRL2CreateUpdateSession();
                XRLXeAttribParam[] atts = new XRLXeAttribParam[1]{new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP1,
                                                                                       new XRLXeIntValue(Int64.MaxValue))};
                req.AddAttribs(atts);

                // verification of int attributes will be done in the searchSession test cases.
                if (CreateAndVerify(true, req))
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("pass int32 value to a int64 attribute")]
        class PInt64Attrib2 : Create2TestBase
        {
            override protected void Execute()
            {
                XRL2CreateUpdateSession req = new XRL2CreateUpdateSession();
                XRLXeAttribParam[] atts = new XRLXeAttribParam[1]{new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP1,
                                                                                       new XRLXeIntValue(Int32.MinValue))};
                req.AddAttribs(atts);

                // verification of int attributes will be done in the searchSession test cases.
                if (CreateAndVerify(true, req))
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("Create a session with a title-specific float32 attribute with max value")]
        class PFloat32Attrib : Create2TestBase
        {
            override protected void Execute()
            {
                XRL2CreateUpdateSession req = new XRL2CreateUpdateSession();
                XRLXeAttribParam[] atts = new XRLXeAttribParam[1]{
                    new XRLXeAttribParam(Constants.PROPERTY_MYFLOAT32PROP1,
                                         new XRLXeFloatValue(float.MaxValue))};
                req.AddAttribs(atts);

                // verification of float attributes will be done in the searchSession test cases.
                if (CreateAndVerify(true, req))
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("Create a session with a title-specific int64 attribute with max value")]
        class PFloat64Attrib : Create2TestBase
        {
            override protected void Execute()
            {
                XRL2CreateUpdateSession req = new XRL2CreateUpdateSession();
                XRLXeAttribParam[] atts = new XRLXeAttribParam[1]{new XRLXeAttribParam(Constants.PROPERTY_MYFLOAT64PROP1,
                                                                                       new XRLXeDoubleValue(double.MaxValue))};
                req.AddAttribs(atts);

                // verification of float attributes will be done in the searchSession test cases.
                if (CreateAndVerify(true, req))
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("Create a session with a title-specific datetime attribute")]
        class PDateTimeAttribute : Create2TestBase
        {
            override protected void Execute()
            {
                long val = DateTime.MaxValue.ToFileTimeUtc();
                XRL2CreateUpdateSession req = new XRL2CreateUpdateSession();
                XRLXeAttribParam[] atts = new XRLXeAttribParam[1]{new XRLXeAttribParam(Constants.PROPERTY_MYDATETIMEPROP1,
                                                                                       new XRLXeDateTimeValue(val))};
                req.AddAttribs(atts);

                // verification of datetime attributes will be done in the searchSession test cases.
                if (CreateAndVerify(true, req))
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("Create a session with a title-specific session 400 char string attribute")]
        class PMaxStringAttrib : Create2TestBase
        {
            override protected void Execute()
            {
                XRL2CreateUpdateSession req = new XRL2CreateUpdateSession();
                string strValue = new string('a', (int)Constants.X_MAX_STRING_ATTRIBUTE_LEN);
                strValue += '\0';
                XRLXeAttribParam attrib = new XRLXeAttribParam(Constants.PROPERTY_GAMERNAME, strValue);
                req.AddAttrib(attrib);

                // verification of string attributes will be done in the searchSession test cases.
                if (CreateAndVerify(true, req))
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("Create a session with an empty title session string(only have '\\0')attribute")]
        class PEmptyStringAttrib : Create2TestBase
        {
            override protected void Execute()
            {
                XRL2CreateUpdateSession req = new XRL2CreateUpdateSession();
                // actually string length is 1, on the wire is shows "00"
                String strValue = "\0";
                XRLXeAttribParam attrib = new XRLXeAttribParam(Constants.PROPERTY_GAMERNAME, strValue);
                req.AddAttrib(attrib);

                // verification of string attributes will be done in the searchSession test cases.
                if (CreateAndVerify(true, req))
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("Create a session with an empty title session string(only have '\\0')attribute")]
        class PEmptyStringAttribBeforeInt : Create2TestBase
        {
            override protected void Execute()
            {
                XRL2CreateUpdateSession req = new XRL2CreateUpdateSession();
                // actually string length is 1, on the wire is shows "00"
                String strValue = "\0";
                XRLXeAttribParam[] atts = new XRLXeAttribParam[2]{
                    new XRLXeAttribParam(Constants.PROPERTY_GAMERNAME, new XRLXeStringValue(strValue)),
                    new XRLXeAttribParam(Constants.PROPERTY_MYINT32PROP1, new XRLXeIntValue(1234)),
                };
                req.AddAttribs(atts);

                // verification of string attributes will be done in the searchSession test cases.
                if (CreateAndVerify(true, req))
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("Create a session with 16 byte(including '\\0')title session string attribute")]
        class PSmallStringAttrib : Create2TestBase
        {
            override protected void Execute()
            {
                XRL2CreateUpdateSession req = new XRL2CreateUpdateSession();
                String strValue = new string('a', 15);
                strValue += '\0';
                XRLXeAttribParam[] atts = new XRLXeAttribParam[1] {
                    new XRLXeAttribParam(Constants.PROPERTY_GAMERNAME, new XRLXeStringValue(strValue)) };
                req.AddAttribs(atts);

                // verification of string attributes will be done in the searchSession test cases.
                if (CreateAndVerify(true, req))
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("Create a session with a 16 character unicode string w/ appended nul")]
        class PSmallStringAttribUnicode : Create2TestBase
        {
            override protected void Execute()
            {
                XRL2CreateUpdateSession req = new XRL2CreateUpdateSession();
                String strValue = new string((char)0x6c34, 16); // water in chinese
                XRLXeAttribParam[] atts = new XRLXeAttribParam[1] { new XRLXeAttribParam(Constants.PROPERTY_GAMERNAME, new XRLXeStringValue(strValue)) };
                req.AddAttribs(atts);

                // verification of string attributes will be done in the searchSession test cases.
                if (CreateAndVerify(true, req))
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("Create a session with public/private available slots set to 0")]
        class PNoAvailableSlots : Create2TestBase
        {
            override protected void Execute()
            {
                XRL2CreateUpdateSession req = new XRL2CreateUpdateSession();
                req.baseCreateUpdate.baseSession.dwPublicFilled = req.baseCreateUpdate.baseSession.dwPublicOpen = 0;
                req.baseCreateUpdate.baseSession.dwPrivateFilled = req.baseCreateUpdate.baseSession.dwPrivateOpen = 0;
                if (CreateAndVerify(true, req))
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("Create a online xenon hosted session")]
        class POnlinexenonSession : Create2TestBase
        {
            override protected void Execute()
            {    // online xenon hosted and moderate NAT: 1010
                XRL2CreateUpdateSession req = new XRL2CreateUpdateSession();
                req.baseCreateUpdate.baseSession.SessionID = new byte[] { 0xA0, 0, 0, 0, 0, 0, 0, 0 };
                if (CreateAndVerify(true, req))
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("Create an online PC hosted session")]
        class PPcServerSession : Create2TestBase
        {
            override protected void Execute()
            {    // online PC hosted and open NAT: 1101
                XRL2CreateUpdateSession req = new XRL2CreateUpdateSession();
                req.baseCreateUpdate.baseSession.SessionID = new byte[] { 0xD0, 0, 0, 0, 0, 0, 0, 0 };
                if (CreateAndVerify(true, req))
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("Create an online title server hosted session")]
        class PTitleServerSession : Create2TestBase
        {
            override protected void Execute()
            {    // online PC hosted and open NAT: 1111
                XRL2CreateUpdateSession req = new XRL2CreateUpdateSession();
                req.baseCreateUpdate.baseSession.SessionID = new byte[] { 0xF0, 0, 0, 0, 0, 0, 0, 0 };
                if (CreateAndVerify(true, req))
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("pass int value to a string attrib")]
        class PMismatchedAttrib1 : Create2TestBase
        {
            override protected void Execute()
            {
                XRL2CreateUpdateSession req = new XRL2CreateUpdateSession();
                XRLXeAttribParam[] atts = new XRLXeAttribParam[1]{new XRLXeAttribParam(Constants.PROPERTY_GAMERNAME,
                                                                                       new XRLXeIntValue(1))};
                req.AddAttribs(atts);

                if (CreateAndVerify(true, req))
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("pass int64 value to a int32 attrib")]
        class PMismatchedAttrib2 : Create2TestBase
        {
            override protected void Execute()
            {
                XRL2CreateUpdateSession req = new XRL2CreateUpdateSession();
                XRLXeAttribParam[] atts = new XRLXeAttribParam[1]{new XRLXeAttribParam(Constants.PROPERTY_MYINT32PROP1,
                                                                                       new XRLXeIntValue(Int64.MaxValue))};
                req.AddAttribs(atts);

                if (CreateAndVerify(true, req))
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("pass float64 value to a float32 attrib")]
        class PMismatchedAttrib3 : Create2TestBase
        {
            override protected void Execute()
            {
                XRL2CreateUpdateSession req = new XRL2CreateUpdateSession();
                XRLXeAttribParam[] atts = new XRLXeAttribParam[1]{new XRLXeAttribParam(Constants.PROPERTY_MYFLOAT32PROP1,
                                                                                       new XRLXeDoubleValue(float.MaxValue))};
                req.AddAttribs(atts);

                if (CreateAndVerify(true, req))
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("pass float32 value to a int32 attrib")]
        class PMismatchedAttrib4 : Create2TestBase
        {
            override protected void Execute()
            {
                XRL2CreateUpdateSession req = new XRL2CreateUpdateSession();
                XRLXeAttribParam[] atts = new XRLXeAttribParam[1]{new XRLXeAttribParam(Constants.PROPERTY_MYINT32PROP1,
                                                                                       new XRLXeFloatValue(float.MaxValue))};
                req.AddAttribs(atts);

                if (CreateAndVerify(true, req))
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("pass float64 value to a int64 attrib")]
        class PMismatchedAttrib5 : Create2TestBase
        {
            override protected void Execute()
            {
                XRL2CreateUpdateSession req = new XRL2CreateUpdateSession();
                XRLXeAttribParam[] atts = new XRLXeAttribParam[1]{new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP1,
                                                                                       new XRLXeDoubleValue(Double.MaxValue))};
                req.AddAttribs(atts);
                if (CreateAndVerify(true, req))
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("pass float value to a Context attrib")]
        class PMismatchedAttrib6 : Create2TestBase
        {
            override protected void Execute()
            {
                XRL2CreateUpdateSession req = new XRL2CreateUpdateSession();
                XRLXeAttribParam[] atts = new XRLXeAttribParam[1]{new XRLXeAttribParam(Constants.CONTEXT_MYCONTEXT1,
                                                                                       new XRLXeDoubleValue(1.1))};
                req.AddAttribs(atts);

                if (CreateAndVerify(true, req))
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("pass string value to a context attrib")]
        class PMismatchedAttrib7 : Create2TestBase
        {
            override protected void Execute()
            {
                XRL2CreateUpdateSession req = new XRL2CreateUpdateSession();
                XRLXeAttribParam[] atts = new XRLXeAttribParam[1]{new XRLXeAttribParam(Constants.CONTEXT_MYCONTEXT1,
                                                                                       new XRLXeStringValue("xyzwxu\0"))};
                req.AddAttribs(atts);
                if (CreateAndVerify(true, req))
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("pass string value to a dateTime attrib")]
        class PMismatchedAttrib8 : Create2TestBase
        {
            override protected void Execute()
            {
                XRL2CreateUpdateSession req = new XRL2CreateUpdateSession();
                XRLXeAttribParam[] atts = new XRLXeAttribParam[1]{new XRLXeAttribParam(Constants.PROPERTY_MYDATETIMEPROP1,
                                                                                       new XRLXeStringValue("abcda\0"))};
                req.AddAttribs(atts);

                if (CreateAndVerify(true, req))
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("pass float value to a datetime attrib")]
        class PMismatchedAttrib9 : Create2TestBase
        {
            override protected void Execute()
            {
                XRL2CreateUpdateSession req = new XRL2CreateUpdateSession();
                XRLXeAttribParam[] atts = new XRLXeAttribParam[1]{new XRLXeAttribParam(Constants.PROPERTY_MYDATETIMEPROP1,
                                                                                       new XRLXeDoubleValue(0.123))};
                req.AddAttribs(atts);

                if (CreateAndVerify(true, req))
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("pass an invalid long to a dateTime attrib")]
        class PMismatchedAttrib10 : Create2TestBase
        {
            override protected void Execute()
            {
                XRL2CreateUpdateSession req = new XRL2CreateUpdateSession();
                XRLXeAttribParam[] atts = new XRLXeAttribParam[1]{new XRLXeAttribParam(Constants.PROPERTY_MYDATETIMEPROP1,
                                                                                       new XRLXeIntValue(123))};
                req.AddAttribs(atts);

                if (CreateAndVerify(true, req))
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("create a session with userPUID passed as attribute")]
        class PWithUserPUID : Create2TestBase
        {
            override protected void Execute()
            {
                XRL2CreateUpdateSession req = new XRL2CreateUpdateSession();
                XRLXeAttribParam[] atts = new XRLXeAttribParam[1]{new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_PUID,
                                                                                       new XRLXeIntValue(123))};
                req.AddAttribs(atts);

                if (CreateAndVerify(true, req))
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("create a session without userPUID passed as attribute")]
        class PWithoutUserPUID : Create2TestBase
        {
            override protected void Execute()
            {
                XRL2CreateUpdateSession req = new XRL2CreateUpdateSession();

                if (CreateAndVerify(true, req))
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }


        [TestCase, Description("Create a session on a platform-locked title, and ensure the lock is enforced.")]
        class PPlatformLockTest : Create2TestBase
        {
            override protected void Execute()
            {
                bool ret = false;
                //prep to try to make a session that isn't cross-platform revoked(non-xenon, lock = 0)

                XRL2CreateUpdateSession req = new XRL2CreateUpdateSession();
                XRLXeAttribParam[] atts = new XRLXeAttribParam[2]{new XRLXeAttribParam(Constants.X_ATTRIBUTE_PLATFORM_TYPE,
                                                                                       new XRLXeIntValue(0)),
                                                                  new XRLXeAttribParam(Constants.X_ATTRIBUTE_PLATFORM_LOCK,
                                                                                       new XRLXeIntValue(0))};
                req.AddAttribs(atts);

                //Modify the title for this request so it's cross-platform-revoked.  This means on
                //create, the session will become locked, and because it's xenon, the platform
                //attribute changes to xenon.
                TitleCrossPlatformRevoker titleRevoker = new TitleCrossPlatformRevoker();
                titleRevoker.Revoke(req.baseCreateUpdate.baseSession.dwTitleID);

                try {
                    //Create
                    XRLSessionInfo resp = null;
                    if (!req.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out resp))
                    {
                        Global.RO.Warn("CreateSession request failed:" + Global.XErrToString(req.XErr));
                    }

                    //Find
                    XRL2SearchResults searchResults;
                    ret = FindSession(resp.SessionID, out searchResults);

                    //Verify
                    // check if session created correctly in the t_match_sessions_<title>
                    if (!req.Verify(searchResults, true))  //true==ranked, which this session is
                    {
                        Global.RO.Warn("The session is not setup correctly in the db");
                        ret = false;
                    }
                    //get search request.  Let's look for Xbox--the type we passed in, that should
                    //be overriden by the FD.  If the type wasn't changed, this would fail.
                    //using MatchSession to avoid a findbyid search.
                    MatchSession session = new MatchSession(req.baseCreateUpdate.baseSession.dwTitleID, req, resp);
                    XRL2SearchSession searchReq = session.CreateSearchSession(Constants.SESSION_MATCH_QUERY_QUERY1);
                    searchReq.SetToPlatform(CSGInfo.ClientType.Xbox);

                    //search, verify not found.
                    if (!searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out searchResults))
                    {
                        Global.RO.Warn("search for the newly created session failed:" + Global.XErrToString(searchReq.XErr));
                        ret = false;
                    }
                    if (searchResults != null)
                    {
                        Global.RO.Warn("The newly created session could be found, when searching as a different platform.");
                        ret = false;
                    }

                    XRL2DeleteSession delReq = new XRL2DeleteSession(resp.SessionID, req.baseCreateUpdate.baseSession.dwTitleID);
                    if (!delReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd)))
                    {
                        Global.RO.Warn("Session deletion failed");
                    }

                } catch (Exception) {
                    Global.RO.Warn("Unexpected exception thrown!");
                    ret = false;
                }
                titleRevoker.Restore();
                if (ret) {
                    ResultCode = TEST_RESULTS.PASSED;
                }
            }

        }


        //one day refactor this into the other platform lock test.
        [TestCase, Description("Create a session on a non-platform locked title, and ensure type is still enforced anyway..")]
        class PPlatformLockTestForTypes : Create2TestBase
        {
            override protected void Execute()
            {
                bool ret = true;
                //prep to try to make a session that is locked, but xbox.(non-xenon, lock = 1)

                XRL2CreateUpdateSession req = new XRL2CreateUpdateSession();
                XRLXeAttribParam[] atts = new XRLXeAttribParam[2]{new XRLXeAttribParam(Constants.X_ATTRIBUTE_PLATFORM_TYPE,
                                                                                       new XRLXeIntValue(1)),
                                                                  new XRLXeAttribParam(Constants.X_ATTRIBUTE_PLATFORM_LOCK,
                                                                                       new XRLXeIntValue(1))};
                req.AddAttribs(atts);
                
                //leave the title alone.

                try {
                    //Create
                    XRLSessionInfo resp = null;
                    if (!req.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out resp))
                    {
                        Global.RO.Warn("CreateSession request failed:" + Global.XErrToString(req.XErr));
                    }
                    //get search request.  Let's look for Xbox--the type we passed in, that should
                    //be overriden by the FD.  Because it's a xenon request, the passed in type
                    //should be overridden, and we shouldn't be able to see it on an xbox search.
                    //Let's run this with a MatchSession search, which shouldn't be findbyid.
                    MatchSession session = new MatchSession(req.baseCreateUpdate.baseSession.dwTitleID, req, resp);
                    XRL2SearchSession searchReq = session.CreateSearchSession(Constants.SESSION_MATCH_QUERY_QUERY1);

                    searchReq.UpdateAttrib(new XRLXeAttribParam(Constants.X_ATTRIBUTE_PLATFORM_TYPE, 
                                                                new XRLXeIntValue(0)));

                    //search, verify not found.
                    XRL2SearchResults searchResults;
                    if (!searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out searchResults))
                    {
                        Global.RO.Warn("search for the newly created session failed:" + Global.XErrToString(searchReq.XErr));
                        ret = false;
                    }
                    if (searchResults != null)
                    {
                        Global.RO.Warn("The newly created session could be found, when searching as a different platform.");
                        ret = false;
                    }

                    XRL2DeleteSession delReq = new XRL2DeleteSession(resp.SessionID, req.baseCreateUpdate.baseSession.dwTitleID);
                    if (!delReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd)))
                    {
                        Global.RO.Warn("Session deletion failed");
                    }

                } catch (Exception) {
                    Global.RO.Warn("Unexpected exception thrown!");
                    ret = false;
                }
                if (ret) {
                    ResultCode = TEST_RESULTS.PASSED;
                }
            }

        }

        [TestCase, Description("Create a session with a large number as public available.  Proof there's no server-side public limit.")]
        class PCreate_Many_Public_Avail : Create2TestBase
        {
            override protected void Execute()
            {
                XRL2CreateUpdateSession req = new XRL2CreateUpdateSession();
                req.baseCreateUpdate.baseSession.dwPublicOpen = 512;  

                if (CreateAndVerify(true, req))
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }



        /***********************************************************************
         * The followings are negative cases
         ***********************************************************************/
        [TestCase, Description("Create a session without gameType attribute")]
        class NNoGameType : NegativeCreate2TestBase
        {
            override protected void Execute()
            {
                XRLXeAttribParam[] Attribs = new XRLXeAttribParam[1] { new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE, new XRLXeIntValue(Constants.CONTEXT_GAME_MODE_MODEA)) };
                XRL2CreateUpdateSession req = new XRL2CreateUpdateSession(Attribs);
                if (this.CreateTestNegative(req, HResult.XONLINE_E_MATCH_INVALID_PARAM))
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("Create a session without gameMode attribute")]
        class NNoGameMode : NegativeCreate2TestBase
        {
            override protected void Execute()
            {
                XRLXeAttribParam[] Attribs = new XRLXeAttribParam[1] { new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_TYPE, new XRLXeIntValue(Constants.X_ATTRIBUTE_GAME_TYPE_RANKED)) };
                XRL2CreateUpdateSession req = new XRL2CreateUpdateSession(Attribs);
                if (this.CreateTestNegative(req, HResult.XONLINE_E_MATCH_INVALID_PARAM))
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("Create a systemLink xenon session")]
        class NSystemLinkxenonSession : NegativeCreate2TestBase
        {
            override protected void Execute()
            {    // system link and open NAT: 0001
                XRL2CreateUpdateSession req = new XRL2CreateUpdateSession();
                req.baseCreateUpdate.baseSession.SessionID = new byte[] { 0x10, 0, 0, 0, 0, 0, 0, 0 };
                if (this.CreateTestNegative(req, HResult.XONLINE_E_MATCH_INVALID_FLAGS))
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("Create a session with the same Context attribute IDs")]
        class NRepeatedContextAttributeIDs : NegativeCreate2TestBase
        {
            override protected void Execute()
            {
                XRL2CreateUpdateSession req = new XRL2CreateUpdateSession();
                XRLXeAttribParam[] atts = new XRLXeAttribParam[1]{new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_TYPE,
                                                                                       new XRLXeIntValue(Constants.X_ATTRIBUTE_GAME_TYPE_RANKED))};
                req.AddAttribs(atts);

                if (this.CreateTestNegative(req, HResult.XONLINE_E_MATCH_CRITICAL_DB_ERR))
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("Create a session with the duplicate property attribute IDs")]
        class NRepeatedPropertyAttributeIDs : NegativeCreate2TestBase
        {
            override protected void Execute()
            {
                XRL2CreateUpdateSession req = new XRL2CreateUpdateSession();
                XRLXeAttribParam[] atts = new XRLXeAttribParam[2]{new XRLXeAttribParam(Constants.PROPERTY_MYINT32PROP1,
                                                                                       new XRLXeIntValue(1)),
                                                                  new XRLXeAttribParam(Constants.PROPERTY_MYINT32PROP1,new XRLXeIntValue(2))};
                req.AddAttribs(atts);

                if (this.CreateTestNegative(req, HResult.XONLINE_E_MATCH_CRITICAL_DB_ERR))
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("Create a session with the duplicate gameType attribute")]
        class NDuplicateGameType : NegativeCreate2TestBase
        {
            override protected void Execute()
            {
                XRL2CreateUpdateSession req = new XRL2CreateUpdateSession();
                XRLXeAttribParam[] atts = new XRLXeAttribParam[1] {
                    new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_TYPE,
                                         new XRLXeIntValue(Constants.X_ATTRIBUTE_GAME_TYPE_STANDARD))};
                req.AddAttribs(atts);

                if (this.CreateTestNegative(req, HResult.XONLINE_E_MATCH_CRITICAL_DB_ERR))
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("Create a session with the duplicate gamerZone attribute")]
        class NDuplicateGamerZone : NegativeCreate2TestBase
        {
            override protected void Execute()
            {
                XRL2CreateUpdateSession req = new XRL2CreateUpdateSession();
                XRLXeAttribParam[] atts = new XRLXeAttribParam[1]{
                    new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_ZONE,
                                         new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_ZONE))};
                req.AddAttribs(atts);

                if (this.CreateTestNegative(req, HResult.XONLINE_E_MATCH_CRITICAL_DB_ERR))
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("Create a session with the duplicate gamer country attribute")]
        class NDuplicateGamerCountry : NegativeCreate2TestBase
        {
            override protected void Execute()
            {
                XRL2CreateUpdateSession req = new XRL2CreateUpdateSession();
                XRLXeAttribParam[] atts = new XRLXeAttribParam[1]{
                    new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_COUNTRY,
                                         new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_COUNTRY))};
                req.AddAttribs(atts);

                if (this.CreateTestNegative(req, HResult.XONLINE_E_MATCH_CRITICAL_DB_ERR))
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("Create a session with the duplicate gamer language attribute")]
        class NDuplicateGamerLang : NegativeCreate2TestBase
        {
            override protected void Execute()
            {
                XRL2CreateUpdateSession req = new XRL2CreateUpdateSession();
                XRLXeAttribParam[] atts = new XRLXeAttribParam[1]{
                    new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_LANGUAGE,
                                         new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_LANG))};
                req.AddAttribs(atts);

                if (this.CreateTestNegative(req, HResult.XONLINE_E_MATCH_CRITICAL_DB_ERR))
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("Create a session with the duplicate gamer rating attribute")]
        class NDuplicateGamerRating : NegativeCreate2TestBase
        {
            override protected void Execute()
            {
                XRL2CreateUpdateSession req = new XRL2CreateUpdateSession();
                XRLXeAttribParam[] atts = new XRLXeAttribParam[1]{
                    new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_RATING,
                                         new XRLXeFloatValue(Constants.XENON_TEST_DEFAULT_GAMER_RATING))};
                req.AddAttribs(atts);

                if (this.CreateTestNegative(req, HResult.XONLINE_E_MATCH_CRITICAL_DB_ERR))
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("Create a session with the duplicate gamer mu attribute")]
        class NDuplicateGamerMu : NegativeCreate2TestBase
        {
            override protected void Execute()
            {
                XRL2CreateUpdateSession req = new XRL2CreateUpdateSession();
                XRLXeAttribParam[] atts = new XRLXeAttribParam[1]{
                    new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_MU,
                                         new XRLXeDoubleValue(Constants.XENON_TEST_DEFAULT_GAMER_MU))};
                req.AddAttribs(atts);

                if (this.CreateTestNegative(req, HResult.XONLINE_E_MATCH_CRITICAL_DB_ERR))
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("Create a session with the duplicate gamer sigma attribute")]
        class NDuplicateGamerSigma : NegativeCreate2TestBase
        {
            override protected void Execute()
            {
                XRL2CreateUpdateSession req = new XRL2CreateUpdateSession();
                XRLXeAttribParam[] atts = new XRLXeAttribParam[1]{
                    new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_SIGMA,
                                         new XRLXeDoubleValue(Constants.XENON_TEST_DEFAULT_GAMER_SIGMA))};
                req.AddAttribs(atts);

                if (this.CreateTestNegative(req, HResult.XONLINE_E_MATCH_CRITICAL_DB_ERR))
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("passing null value as game Type")]
        class NNullGameType : NegativeCreate2TestBase
        {
            override protected void Execute()
            {
                XRLXeAttribParam[] Attribs = new XRLXeAttribParam[8];
                Attribs[0] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_TYPE, new XRLXeNullValue());
                Attribs[1] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE, new XRLXeIntValue(Constants.CONTEXT_GAME_MODE_MODEA));
                Attribs[2] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_ZONE, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_ZONE));
                Attribs[3] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_COUNTRY, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_COUNTRY));
                Attribs[4] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_LANGUAGE, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_LANG));
                Attribs[5] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_RATING, new XRLXeFloatValue(Constants.XENON_TEST_DEFAULT_GAMER_RATING));
                Attribs[6] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_MU, new XRLXeDoubleValue(Constants.XENON_TEST_DEFAULT_GAMER_MU));
                Attribs[7] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_SIGMA, new XRLXeDoubleValue(Constants.XENON_TEST_DEFAULT_GAMER_SIGMA));

                XRL2CreateUpdateSession req = new XRL2CreateUpdateSession(Attribs);

                if (this.CreateTestNegative(req, HResult.XONLINE_E_MATCH_INVALID_OFFSET))
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("passing null value as game mode")]
        class NNullGameMode : NegativeCreate2TestBase
        {
            override protected void Execute()
            {
                XRLXeAttribParam[] Attribs = new XRLXeAttribParam[8];
                Attribs[0] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_TYPE, new XRLXeIntValue(Constants.X_ATTRIBUTE_GAME_TYPE_RANKED));
                Attribs[1] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE, new XRLXeNullValue());
                Attribs[2] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_ZONE, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_ZONE));
                Attribs[3] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_COUNTRY, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_COUNTRY));
                Attribs[4] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_LANGUAGE, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_LANG));
                Attribs[5] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_RATING, new XRLXeFloatValue(Constants.XENON_TEST_DEFAULT_GAMER_RATING));
                Attribs[6] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_MU, new XRLXeDoubleValue(Constants.XENON_TEST_DEFAULT_GAMER_MU));
                Attribs[7] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_SIGMA, new XRLXeDoubleValue(Constants.XENON_TEST_DEFAULT_GAMER_SIGMA));

                XRL2CreateUpdateSession req = new XRL2CreateUpdateSession(Attribs);

                if (this.CreateTestNegative(req, HResult.XONLINE_E_MATCH_INVALID_OFFSET))
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("passing null value as gamer zone")]
        class NNullGamerZone : NegativeCreate2TestBase
        {
            override protected void Execute()
            {
                XRLXeAttribParam[] Attribs = new XRLXeAttribParam[8];
                Attribs[0] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_TYPE, new XRLXeIntValue(Constants.X_ATTRIBUTE_GAME_TYPE_RANKED));
                Attribs[1] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE, new XRLXeIntValue(Constants.CONTEXT_GAME_MODE_MODEA));
                Attribs[2] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_ZONE, new XRLXeNullValue());
                Attribs[3] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_COUNTRY, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_COUNTRY));
                Attribs[4] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_LANGUAGE, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_LANG));
                Attribs[5] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_RATING, new XRLXeFloatValue(Constants.XENON_TEST_DEFAULT_GAMER_RATING));
                Attribs[6] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_MU, new XRLXeDoubleValue(Constants.XENON_TEST_DEFAULT_GAMER_MU));
                Attribs[7] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_SIGMA, new XRLXeDoubleValue(Constants.XENON_TEST_DEFAULT_GAMER_SIGMA));

                XRL2CreateUpdateSession req = new XRL2CreateUpdateSession(Attribs);

                if (this.CreateTestNegative(req, HResult.XONLINE_E_MATCH_INVALID_OFFSET))
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("passing null value as gamer country")]
        class NNullGameCountry : NegativeCreate2TestBase
        {
            override protected void Execute()
            {
                XRLXeAttribParam[] Attribs = new XRLXeAttribParam[8];
                Attribs[0] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_TYPE, new XRLXeIntValue(Constants.X_ATTRIBUTE_GAME_TYPE_RANKED));
                Attribs[1] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE, new XRLXeIntValue(Constants.CONTEXT_GAME_MODE_MODEA));
                Attribs[2] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_ZONE, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_ZONE));
                Attribs[3] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_COUNTRY, new XRLXeNullValue());
                Attribs[4] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_LANGUAGE, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_LANG));
                Attribs[5] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_RATING, new XRLXeFloatValue(Constants.XENON_TEST_DEFAULT_GAMER_RATING));
                Attribs[6] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_MU, new XRLXeDoubleValue(Constants.XENON_TEST_DEFAULT_GAMER_MU));
                Attribs[7] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_SIGMA, new XRLXeDoubleValue(Constants.XENON_TEST_DEFAULT_GAMER_SIGMA));

                XRL2CreateUpdateSession req = new XRL2CreateUpdateSession(Attribs);

                if (this.CreateTestNegative(req, HResult.XONLINE_E_MATCH_INVALID_OFFSET))
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("passing null value as game lang")]
        class NNullGamerLang : NegativeCreate2TestBase
        {
            override protected void Execute()
            {
                XRLXeAttribParam[] Attribs = new XRLXeAttribParam[8];
                Attribs[0] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_TYPE, new XRLXeIntValue(Constants.X_ATTRIBUTE_GAME_TYPE_RANKED));
                Attribs[1] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE, new XRLXeIntValue(Constants.CONTEXT_GAME_MODE_MODEA));
                Attribs[2] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_ZONE, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_ZONE));
                Attribs[3] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_COUNTRY, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_COUNTRY));
                Attribs[4] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_LANGUAGE, new XRLXeNullValue());
                Attribs[5] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_RATING, new XRLXeFloatValue(Constants.XENON_TEST_DEFAULT_GAMER_RATING));
                Attribs[6] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_MU, new XRLXeDoubleValue(Constants.XENON_TEST_DEFAULT_GAMER_MU));
                Attribs[7] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_SIGMA, new XRLXeDoubleValue(Constants.XENON_TEST_DEFAULT_GAMER_SIGMA));

                XRL2CreateUpdateSession req = new XRL2CreateUpdateSession(Attribs);

                if (this.CreateTestNegative(req, HResult.XONLINE_E_MATCH_INVALID_OFFSET))
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("passing null value as gamer rating")]
        class NNullGamerRating : NegativeCreate2TestBase
        {
            override protected void Execute()
            {
                XRLXeAttribParam[] Attribs = new XRLXeAttribParam[8];
                Attribs[0] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_TYPE, new XRLXeIntValue(Constants.X_ATTRIBUTE_GAME_TYPE_RANKED));
                Attribs[1] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE, new XRLXeIntValue(Constants.CONTEXT_GAME_MODE_MODEA));
                Attribs[2] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_ZONE, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_ZONE));
                Attribs[3] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_COUNTRY, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_COUNTRY));
                Attribs[4] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_LANGUAGE, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_LANG));
                Attribs[5] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_RATING, new XRLXeNullValue());
                Attribs[6] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_MU, new XRLXeDoubleValue(Constants.XENON_TEST_DEFAULT_GAMER_MU));
                Attribs[7] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_SIGMA, new XRLXeDoubleValue(Constants.XENON_TEST_DEFAULT_GAMER_SIGMA));

                XRL2CreateUpdateSession req = new XRL2CreateUpdateSession(Attribs);

                if (this.CreateTestNegative(req, HResult.XONLINE_E_MATCH_INVALID_OFFSET))
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("passing null value as gamer Mu")]
        class NNullGameMu : NegativeCreate2TestBase
        {
            override protected void Execute()
            {
                XRLXeAttribParam[] Attribs = new XRLXeAttribParam[8];
                Attribs[0] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_TYPE, new XRLXeIntValue(Constants.X_ATTRIBUTE_GAME_TYPE_RANKED));
                Attribs[1] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE, new XRLXeIntValue(Constants.CONTEXT_GAME_MODE_MODEA));
                Attribs[2] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_ZONE, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_ZONE));
                Attribs[3] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_COUNTRY, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_COUNTRY));
                Attribs[4] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_LANGUAGE, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_LANG));
                Attribs[5] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_RATING, new XRLXeFloatValue(Constants.XENON_TEST_DEFAULT_GAMER_RATING));
                Attribs[6] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_MU, new XRLXeNullValue());
                Attribs[7] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_SIGMA, new XRLXeDoubleValue(Constants.XENON_TEST_DEFAULT_GAMER_SIGMA));

                XRL2CreateUpdateSession req = new XRL2CreateUpdateSession(Attribs);

                if (this.CreateTestNegative(req, HResult.XONLINE_E_MATCH_INVALID_OFFSET))
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("passing null value as game Sigma")]
        class NNullGamerSigma : NegativeCreate2TestBase
        {
            override protected void Execute()
            {
                XRLXeAttribParam[] Attribs = new XRLXeAttribParam[8];
                Attribs[0] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_TYPE, new XRLXeIntValue(Constants.X_ATTRIBUTE_GAME_TYPE_RANKED));
                Attribs[1] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE, new XRLXeIntValue(Constants.CONTEXT_GAME_MODE_MODEA));
                Attribs[2] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_ZONE, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_ZONE));
                Attribs[3] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_COUNTRY, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_COUNTRY));
                Attribs[4] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_LANGUAGE, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_LANG));
                Attribs[5] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_RATING, new XRLXeFloatValue(Constants.XENON_TEST_DEFAULT_GAMER_RATING));
                Attribs[6] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_MU, new XRLXeDoubleValue(Constants.XENON_TEST_DEFAULT_GAMER_MU));
                Attribs[7] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_SIGMA, new XRLXeNullValue());

                XRL2CreateUpdateSession req = new XRL2CreateUpdateSession(Attribs);

                if (this.CreateTestNegative(req, HResult.XONLINE_E_END_OF_STREAM))
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("Create a session with blob attribute")]
        class NBlobAttrib : NegativeCreate2TestBase
        {
            override protected void Execute()
            {
                XRL2CreateUpdateSession req = new XRL2CreateUpdateSession();
                XRLXeAttribParam[] atts = new XRLXeAttribParam[1]{new XRLXeAttribParam(Constants.SAMPLE_BLOB_ATTRIB,
                                                                                       new XRLXeStringValue("abc"))};
                req.AddAttribs(atts);

                // verification of string attributes will be done in the searchSession test cases.
                if (this.CreateTestNegative(req, HResult.XONLINE_E_MATCH_INVALID_DATA_TYPE))
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("Message Length shorter than the sizeof(XMATCH_SESSION)")]
        class NSmallMsgLen : NegativeCreate2TestBase
        {
            override protected void Execute()
            {
                XRL2CreateUpdateSession req = new XRL2CreateUpdateSession();
                req.baseCreateUpdate.baseSession.dwMessageLength = 1;
                if (CreateTestNegative(req, HResult.XONLINE_E_MATCH_REQUEST_TOO_SMALL))
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("Message Length longer than available bytes")]
        class NOverflowMsgLen : NegativeCreate2TestBase
        {
            override protected void Execute()
            {
                XRL2CreateUpdateSession req = new XRL2CreateUpdateSession();
                req.baseCreateUpdate.baseSession.dwMessageLength += 1;
                if (CreateTestNegative(req, HResult.XONLINE_E_MATCH_REQUEST_TRUNCATED))
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("create a session with unknown titleID")]
        class NUnknowTitleID : NegativeCreate2TestBase
        {
            override protected void Execute()
            {
                XRL2CreateUpdateSession req = new XRL2CreateUpdateSession();
                req.baseCreateUpdate.baseSession.dwTitleID = Constants.UNKNOWN_TITLE;
                if (CreateTestNegative(req, HResult.XONLINE_E_MATCH_INVALID_TITLE_ID))
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("use a titleID that only exists in t_match_titles, but no matching session table")]
        class NMissingTableTitleID : NegativeCreate2TestBase
        {
            override protected void Execute()
            {
                XRL2CreateUpdateSession req = new XRL2CreateUpdateSession();
                req.baseCreateUpdate.baseSession.dwTitleID = 0x00001111;
                if (CreateTestNegative(req, HResult.XONLINE_E_MATCH_INVALID_TITLE_ID))
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("create a session with a non-existent Context attribute ID")]
        class NNonExistentContextAttrib : NegativeCreate2TestBase
        {
            override protected void Execute()
            {
                XRL2CreateUpdateSession req = new XRL2CreateUpdateSession();
                // the title doesn't have 0x8 as attribute
                XRLXeAttribParam[] Attribs = new XRLXeAttribParam[1] { new XRLXeAttribParam(0x00000008, new XRLXeIntValue(1)) };
                req.AddAttribs(Attribs);
                if (CreateTestNegative(req, HResult.XONLINE_E_MATCH_INVALID_ATTRIBUTE_ID))
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("create a session with a non-existent Property attribute ID")]
        class NNonExistentPropertyAttrib : NegativeCreate2TestBase
        {
            override protected void Execute()
            {
                XRL2CreateUpdateSession req = new XRL2CreateUpdateSession();
                XRLXeAttribParam[] Attribs = new XRLXeAttribParam[1] { new XRLXeAttribParam(0x1000000F, new XRLXeIntValue(1)) };
                req.AddAttribs(Attribs);
                if (CreateTestNegative(req, HResult.XONLINE_E_MATCH_INVALID_ATTRIBUTE_ID))
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("create a session with 1 custom attribute, but attrib offset is inside session header")]
        class NWrongAttribOffset1 : NegativeCreate2TestBase
        {
            override protected void Execute()
            {
                XRL2CreateUpdateSession req = new XRL2CreateUpdateSession();
                XRLXeAttribParam[] Attribs = new XRLXeAttribParam[1] { new XRLXeAttribParam(Constants.CONTEXT_MYCONTEXT1, new XRLXeIntValue(1)) };
                req.AddAttribs(Attribs);
                req.baseCreateUpdate.AttribOffsets[0] -= 4;
                if (CreateTestNegative(req, HResult.XONLINE_E_MATCH_INVALID_OFFSET))
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("create a session with 1 custom attribute, but attribOffset beyong available")]
        class NWrongAttribOffset2 : NegativeCreate2TestBase
        {
            override protected void Execute()
            {
                XRL2CreateUpdateSession req = new XRL2CreateUpdateSession();
                XRLXeAttribParam[] Attribs = new XRLXeAttribParam[1] { new XRLXeAttribParam(Constants.CONTEXT_MYCONTEXT1, new XRLXeIntValue(1)) };
                req.AddAttribs(Attribs);
                req.baseCreateUpdate.AttribOffsets[2] += 4;
                if (CreateTestNegative(req, HResult.XONLINE_E_MATCH_INVALID_OFFSET))
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("create a session with 1 custom attribute, but attribOffset equal to current offset")]
        class NWrongAttribOffset3 : NegativeCreate2TestBase
        {
            override protected void Execute()
            {
                XRL2CreateUpdateSession req = new XRL2CreateUpdateSession();
                XRLXeAttribParam[] Attribs = new XRLXeAttribParam[1] { new XRLXeAttribParam(Constants.CONTEXT_MYCONTEXT1, new XRLXeIntValue(1)) };
                req.AddAttribs(Attribs);
                req.baseCreateUpdate.AttribOffsets[2] = req.baseCreateUpdate.AttribOffsets[1];
                if (CreateTestNegative(req, HResult.XONLINE_E_MATCH_INVALID_OFFSET))
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("indicate more attributes than available")]
        class NOverflowAttrib : NegativeCreate2TestBase
        {
            override protected void Execute()
            {
                XRLXeAttribParam[] Attribs = null;
                XRL2CreateUpdateSession req = new XRL2CreateUpdateSession(Attribs);
                req.baseCreateUpdate.ManualArraySize = true;
                req.baseCreateUpdate.AttribOffsetsLen = 1;
                if (CreateTestNegative(req, HResult.XONLINE_E_END_OF_STREAM))
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("create session with zero-length title session string attribute")]
        class NZeroLenStringAttrib : NegativeCreate2TestBase
        {
            override protected void Execute()
            {
                XRL2CreateUpdateSession req = new XRL2CreateUpdateSession();
                // string length is 0
                XRLXeAttribParam[] atts = new XRLXeAttribParam[1] { new XRLXeAttribParam(Constants.PROPERTY_GAMERNAME, new XRLXeStringValue(null, 0)) };
                req.AddAttribs(atts);

                if (CreateTestNegative(req, HResult.XONLINE_E_MATCH_INVALID_STRING))
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("create session with a string attrib whose length goes beyong the number of bytes available")]
        class NOverflowStringAttrib : NegativeCreate2TestBase
        {
            override protected void Execute()
            {
                XRL2CreateUpdateSession req = new XRL2CreateUpdateSession();
                String strValue = "abc\0";
                XRLXeAttribParam[] atts = new XRLXeAttribParam[1] { new XRLXeAttribParam(Constants.PROPERTY_GAMERNAME, new XRLXeStringValue(strValue)) };
                req.AddAttribs(atts);
                req.baseCreateUpdate.baseSession.dwMessageLength -= 1;

                if (CreateTestNegative(req, HResult.XONLINE_E_MATCH_REQUEST_TOO_SMALL))
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("create session with a string attrib of MAXLEN + 1 bytes(null not included)")]
        class NOverflowStringAttrib2 : NegativeCreate2TestBase
        {
            override protected void Execute()
            {
                XRL2CreateUpdateSession req = new XRL2CreateUpdateSession();
                String strValue = new string('b', (int)(Constants.X_MAX_STRING_ATTRIBUTE_LEN + 1));
                strValue += '\0';
                XRLXeAttribParam[] atts = new XRLXeAttribParam[1] { new XRLXeAttribParam(Constants.PROPERTY_GAMERNAME, new XRLXeStringValue(strValue)) };
                req.AddAttribs(atts);

                if (CreateTestNegative(req, HResult.XONLINE_E_MATCH_STRING_TOO_LONG))
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("create session with a non-null terminated string attrib")]
        class NNonNullTerminatedString : NegativeCreate2TestBase
        {
            override protected void Execute()
            {
                XRL2CreateUpdateSession req = new XRL2CreateUpdateSession();
                String strValue = "katie";
                XRLXeAttribParam[] atts = new XRLXeAttribParam[1] { new XRLXeAttribParam(Constants.PROPERTY_GAMERNAME, new XRLXeStringValue(strValue, 5)) };
                req.AddAttribs(atts);

                if (CreateTestNegative(req, HResult.XONLINE_E_MATCH_INVALID_STRING))
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("create session with non existent attribID")]
        class NNonExistentAttribID : NegativeCreate2TestBase
        {
            override protected void Execute()
            {
                XRLXeAttribParam[] atts = new XRLXeAttribParam[1] { new XRLXeAttribParam(Constants.XENON_TEST_NONEXIST_ATTRIBID, new XRLXeIntValue(10)) };
                XRL2CreateUpdateSession req = new XRL2CreateUpdateSession();
                req.AddAttribs(atts);

                if (CreateTestNegative(req, HResult.XONLINE_E_MATCH_INVALID_ATTRIBUTE_ID))
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XMatchTest\Func2DeleteSession.cs ===
using System;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Matchmaking;
using xonline.common.config;

namespace XMatchTest
{
	internal abstract class NegativeDelete2TestBase : TestBase
	{
		protected bool DeleteTestNegative(XRL2DeleteSession Req, uint XErr)
		{
			if (Req.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd)))
			{
				Global.RO.Warn("Negative DeleteSession request succeed unexpectedly");
				return false;
			}
			if(Req.XErr != XErr)
			{
				Global.RO.Warn("Wrong error code (" + Global.XErrToString(Req.XErr) + " != " + Global.XErrToString(XErr) + ") returned");
				return false;
			}
			return true;
		}
	}
	[TestGroup]
	public class Func2DeleteSession : TestNode
	{
		/*****************************************************************************
		 * The following cases are positive cases
		 * some of the cases are done through FuncCreateUpdateSession verification
		 *****************************************************************************/
            [BVT]
		[TestCase, Description("Delete a newly created Session")]
			class PNormalCase : TestBase
		{
			override protected void Execute()
			{
				XRL2CreateUpdateSession    req = new XRL2CreateUpdateSession();
				XRLSessionInfo            Resp;
				if(req.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out Resp))
				{
					XRL2DeleteSession    delReq = new XRL2DeleteSession(Resp.SessionID, Constants.XENON_TITLE);
					if(delReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd)))
						ResultCode=TEST_RESULTS.PASSED;
				}
				else
					Global.RO.Warn("CreateSession failed:"+Global.XErrToString(req.XErr));
			}
		}

		/************************************************************************************
		 * The following is for Tsunami Wave2
		 ************************************************************************************/
		[TestCase, Description("delete a session for a title that lives on multiple db")]
			class PTitleOnMultiDB : TestBase
		{
			// this is to test if the db that the session is on can be detected correctly
			override protected void Execute()
			{    // create 2 sessions so we can gurantee there is on created on 2nd db
				XRL2CreateUpdateSession    req1 = new XRL2CreateUpdateSession(), req2 = new XRL2CreateUpdateSession();
				XRLSessionInfo            Resp1=null, Resp2 = null;
				if(    req1.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out Resp1) &&
					req2.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out Resp2))
				{
					XRL2DeleteSession    delReq1 = new XRL2DeleteSession(Resp1.SessionID,Constants.XENON_TITLE), delReq2;
					delReq2 = new XRL2DeleteSession(Resp2.SessionID,Constants.XENON_TITLE);
					if(delReq1.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd))&& delReq2.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd)))
						ResultCode=TEST_RESULTS.PASSED;
				}
				else
					Global.RO.Warn("CreateSession failed:"+Global.XErrToString(req1.XErr)+"Or"+Global.XErrToString(req2.XErr));
			}
		}
		/*****************************************************************************
		 * The following cases are negative cases
		 *****************************************************************************/
		[TestCase, Description("Try to delete an invalid session")]
			class NInvalidSession : NegativeDelete2TestBase
		{
			override protected void Execute()
			{
				byte []SessID = new byte[8]{0,0,0,0,0,0,0,1};
				XRL2DeleteSession    req = new XRL2DeleteSession(SessID, Constants.XENON_TITLE);
				if(DeleteTestNegative(req,HResult.XONLINE_E_MATCH_INVALID_SESSION_ID))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("Try to delete an session with invalid Title")]
			class NInvalidTitle : NegativeDelete2TestBase
		{
			override protected void Execute()
			{
				XRL2CreateUpdateSession    Createreq = new XRL2CreateUpdateSession();
				XRLSessionInfo            Resp;
				if(Createreq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out Resp))
				{
					XRL2DeleteSession    req = new XRL2DeleteSession(Resp.SessionID,Constants.XENON_TITLE);
					req.dwTitleID = 0xDEADBEEF;
					if(DeleteTestNegative(req,HResult.XONLINE_E_MATCH_INVALID_TITLE_ID))
						ResultCode=TEST_RESULTS.PASSED;
					XRL2DeleteSession    delReq = new XRL2DeleteSession(Resp.SessionID,Constants.XENON_TITLE);
					delReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
				}
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XMatchTest\Func2DeadXBox.cs ===
using System;
using System.Text;
using System.IO;
using System.Net;
using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Matchmaking;
using xonline.common.config;

namespace XMatchTest
{
	/// <summary>
	/// The only difference between this Func2DeadXBox and FuncDeadXBox is that 
	/// it use xenon title, which will exercise the new session table name
	/// </summary>
	[TestGroup]
	public class Func2DeadXBox : TestNode
	{
        private bool MatchTitleUpdated = false;

        [TestGroupSetup]
        public void Setup()
        {
            MatchTitle matchTitle = MatchTitleMgr.GetMatchTitle(Constants.XENON_TITLE);
            if (matchTitle.DeleteDelaySeconds != 0)
            {
                matchTitle = MatchTitleMgr.SnapshotMatchTitle(Constants.XENON_TITLE);
                matchTitle.DeleteDelaySeconds = 0;
                MatchTitleMgr.UpdateMatchTitle(matchTitle);
                MatchTitleUpdated = true;
                MatchFDs.ReloadTitleInfo();
            }
        }

        [TestGroupTearDown]
        public void TearDown()
        {
            if (MatchTitleUpdated)
            {
                MatchTitleMgr.RestoreMatchTitleFromSnapshot(Constants.XENON_TITLE);
                MatchFDs.ReloadTitleInfo();
            }
        }

		// this is for batched deadxbox requests
		protected static bool    MyOwnExecute(XRLDeadXBox[] batchReq, uint dwTotalMsgLen,uint XErr)
		{
			MemoryStream        reqStream = new MemoryStream();
			BinaryWriter        bw = new BinaryWriter(reqStream);
			// get reqStream from the batchReq;
			for(int i = 0; i < batchReq.Length; i++)
			{
				bw.Write(batchReq[i].wType);
				bw.Write(batchReq[i].cbEnt);
				bw.Write(batchReq[i].sgaddr.inaSg);
				bw.Write(batchReq[i].sgaddr.dwSpiSg);
				bw.Write(batchReq[i].sgaddr.qwXboxID);
				bw.Write(batchReq[i].sgaddr.abReserved);
				bw.Write(batchReq[i].dwTitleID);
			}
			if(dwTotalMsgLen > (batchReq.Length*(Constants.SIZEDEADXBOX)))
				bw.Write("a");    // this is a negative case that passed in extra data at the end of deadxbox requests
			else if(dwTotalMsgLen < (batchReq.Length*(Constants.SIZEDEADXBOX)))
				reqStream.SetLength(dwTotalMsgLen);

			StringBuilder sbURL = new StringBuilder();
			sbURL.Append("http://");
			sbURL.Append(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd).ToString());
			sbURL.Append("/xmatch/deadxbox.ashx");

			HttpWebRequest    httpReq;
			HttpWebResponse    httpResp = null;
			HttpStatusCode    statusCode;
			Stream            httpStream;
			httpReq = (HttpWebRequest)WebRequest.Create(sbURL.ToString());
			httpReq.ProtocolVersion = HttpVersion.Version11;
			httpReq.Method = "POST";
			httpReq.UserAgent = ((int)XOService.Matchmaking).ToString("x") + "/1.0.5849";
			httpReq.ContentType = "xon/" + ((int)XOService.Matchmaking).ToString("x");
			httpReq.ContentLength = reqStream.Length;
			try
			{
				httpStream = httpReq.GetRequestStream();
				reqStream.WriteTo(httpStream);
				httpStream.Close();
				httpResp = (HttpWebResponse)httpReq.GetResponse();
			}
			catch (WebException e)
			{
				if(XErr == 0)    // this request is expected to succeed
				{
					Global.RO.Warn("Positive deadxbox requests failed: " + e.ToString());
					return false;
				}
				// else this is a negative case
				httpResp = (HttpWebResponse)e.Response;
				if(httpResp != null)
				{
					statusCode = httpResp.StatusCode;
					if(statusCode == HttpStatusCode.InternalServerError)
					{    // check XErr
						string	strErr = httpResp.GetResponseHeader("X-Err");
                        if (strErr.StartsWith("0x") || strErr.StartsWith("0X")) strErr = strErr.Substring(2);

                        if (Convert.ToUInt32(strErr, 16) == XErr)
							return true;
						else
						{
							Global.RO.Warn("Wrong error code (" + strErr + " != " + XErr.ToString("X") + ") returned");
							return false;
						}
					}
					else // other error returned instead of 500
						return false;
				}
				// httpResp is null
				return false;
			}
			if(XErr == 0)
				return true;
			else
				return false;
		}
            //this no longer works because the SGAddr must have a valid boxID.
            [Ignore]
            [TestCase, Description("call deadxbox with SgAddr/TitleRegion/aqwUserID set to max value")]
            class PMaxSgAddr : TestBase
            {
            override protected void Execute()
            {
                SGADDR sg = new SGADDR();
                sg.dwSpiSg = 0xffffffff;
                sg.qwXboxID = 0xffffffffffffffff;
                sg.inaSg = new byte[4] { 0xff, 0xff, 0xff, 0xff };
                byte[] sgbytes = sg.toByteArray();

                // create a session with maximum SGADDR
                XRL2CreateUpdateSession createReq = new XRL2CreateUpdateSession();
                XRLSessionInfo Resp;
                Array.Copy(sgbytes, createReq.baseCreateUpdate.baseSession.HostAddress.abOnline, (long)Constants.SIZESGADDR);
                if (createReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out Resp))
                {
                    XRLDeadXBox req = new XRLDeadXBox(Constants.XENON_TITLE);
                    req.sgaddr.dwSpiSg = sg.dwSpiSg;
                    req.sgaddr.qwXboxID = sg.qwXboxID;
                    Array.Copy(sg.inaSg, req.sgaddr.inaSg, 4);
                    // same DeadXbox message will be sent twice to the matchmaking front door
                    if (!req.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd)))
                    {
                        throw new UnexpectedTestResultException(MatchUtil.ErrMsgFromXRLPayload(
                            "DeadXbox message failed to execute.", req));
                    }
                    // the session will be deleted right away
                    XRL2DeleteSession delReq = new XRL2DeleteSession(Resp.SessionID, Constants.XENON_TITLE);
                    if (!delReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd)))
                    {
                        if (delReq.XErr == HResult.XONLINE_E_MATCH_INVALID_SESSION_ID)
                        {
                            ResultCode = TEST_RESULTS.PASSED;
                        }
                        else
                        {
                            throw new UnexpectedTestResultException(MatchUtil.ErrMsgFromXRLPayload(
                                "DeadXbox message failed to delete session.", delReq));
                        }
                    }
                    else
                    {
                        throw new UnexpectedTestResultException(MatchUtil.ErrMsgFromXRLPayload(
                            "Delete request succeeded unexpectedly.", delReq));
                    }
                }
            }
        }

            [Ignore]  //like PMinSgAddr, this no longer works because we check the boxID.
        [TestCase, Description("call deadxbox with SgAddr/TitleRegion/aqwUserID set to min value")]
		class PMinSgAddr : TestBase
		{
			override protected void Execute()
			{
				SGADDR        sg = new SGADDR();
				sg.dwSpiSg = 0;
				sg.qwXboxID = 0;
				sg.inaSg = new byte[4]{0,0,0,0};
				byte[]        sgbytes = sg.toByteArray();

				// create a session with minimum SGADDR
				XRL2CreateUpdateSession        createReq = new XRL2CreateUpdateSession();
				XRLSessionInfo                Resp;
				Array.Copy(sgbytes,createReq.baseCreateUpdate.baseSession.HostAddress.abOnline,(long)Constants.SIZESGADDR);
				if(createReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out Resp))
				{
                    XRLDeadXBox req = new XRLDeadXBox(Constants.XENON_TITLE);
                    req.sgaddr.dwSpiSg = sg.dwSpiSg;
                    req.sgaddr.qwXboxID = sg.qwXboxID;
                    Array.Copy(sg.inaSg, req.sgaddr.inaSg, 4);
                    // same DeadXbox message will be sent twice to the matchmaking front door
                    if (!req.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd)))
                    {
                        throw new UnexpectedTestResultException(MatchUtil.ErrMsgFromXRLPayload(
                            "DeadXbox message failed to execute.", req));
                    }
                    // the session will be deleted right away
                    XRL2DeleteSession delReq = new XRL2DeleteSession(Resp.SessionID, Constants.XENON_TITLE);
                    if (!delReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd)))
                    {
                        if (delReq.XErr == HResult.XONLINE_E_MATCH_INVALID_SESSION_ID)
                        {
                            ResultCode = TEST_RESULTS.PASSED;
                        }
                        else
                        {
                            throw new UnexpectedTestResultException(MatchUtil.ErrMsgFromXRLPayload(
                                "DeadXbox message failed to delete session.", delReq));
                        }
                    }
                    else
                    {
                        throw new UnexpectedTestResultException(MatchUtil.ErrMsgFromXRLPayload(
                            "Delete request succeeded unexpectedly.", delReq));
                    }
                }
			}
		}
        [BVT]
        [TestCase, Description("call deadxbox so that more than 1 sessions are deleted")]
		class PMoreSessions : TestBase
		{
			override protected void Execute()
			{
				SGADDR        sg = new SGADDR();
				byte[]        sgbytes = sg.toByteArray();
				// create two sessions with the same SGAddr set
				XRL2CreateUpdateSession        createReq1, createReq2;
				createReq1 = new XRL2CreateUpdateSession();
				createReq2 = new XRL2CreateUpdateSession();
				XRLSessionInfo                Resp1, Resp2;

				Array.Copy(sgbytes,createReq1.baseCreateUpdate.baseSession.HostAddress.abOnline,(long)Constants.SIZESGADDR);
				Array.Copy(sgbytes,createReq2.baseCreateUpdate.baseSession.HostAddress.abOnline,(long)Constants.SIZESGADDR);
                if (createReq1.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out Resp1) &&
                    createReq2.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out Resp2))
                {
                    XRLDeadXBox req = new XRLDeadXBox(Constants.XENON_TITLE);
                    req.sgaddr.dwSpiSg = sg.dwSpiSg;
                    req.sgaddr.qwXboxID = sg.qwXboxID;
                    Array.Copy(sg.inaSg, req.sgaddr.inaSg, 4);
                    // same DeadXbox message will be sent twice to the matchmaking front door
                    if (req.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd)))
                    {
                        // the session will be deleted right away
                        XRL2DeleteSession delReq1 = new XRL2DeleteSession(Resp1.SessionID, Constants.XENON_TITLE);
                        if (!delReq1.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd)))
                        {
                            if (delReq1.XErr != HResult.XONLINE_E_MATCH_INVALID_SESSION_ID)
                            {
                                throw new UnexpectedTestResultException(MatchUtil.ErrMsgFromXRLPayload(
                                    "DeadXbox message failed to delete session.", delReq1));
                            }
                        }
                        else
                        {
                            throw new UnexpectedTestResultException(MatchUtil.ErrMsgFromXRLPayload(
                                "Delete request succeeded unexpectedly.", delReq1));
                        }
                        XRL2DeleteSession delReq2 = new XRL2DeleteSession(Resp2.SessionID, Constants.XENON_TITLE);
                        if (!delReq2.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd)))
                        {
                            if (delReq2.XErr == HResult.XONLINE_E_MATCH_INVALID_SESSION_ID)
                            {
                                ResultCode = TEST_RESULTS.PASSED;
                            }
                            else
                            {
                                throw new UnexpectedTestResultException(MatchUtil.ErrMsgFromXRLPayload(
                                    "DeadXbox message failed to delete session.", delReq2));
                            }
                        }
                        else
                        {
                            throw new UnexpectedTestResultException(MatchUtil.ErrMsgFromXRLPayload(
                                "Delete request succeeded unexpectedly.", delReq2));
                        }
                    }
                }
			}
		}

        [TestCase, Description("send six batched deadxbox messages in one request")]
		class PBatchedMsg : TestBase
		{
			override protected void Execute()
			{
				SGADDR        sg = new SGADDR();
				byte[]        sgbytes;
				// create six sessions with different SGAddr
				XRL2CreateUpdateSession    []    createReqs = new XRL2CreateUpdateSession[6];
				XRLSessionInfo            []    Resp = new XRLSessionInfo[6];
				for(int i = 0; i < 6; i++)
				{
					createReqs[i] = new XRL2CreateUpdateSession();

					sg.dwSpiSg = (uint)(0x12345678 + i);
					sgbytes = sg.toByteArray();
					Array.Copy(sgbytes,createReqs[i].baseCreateUpdate.baseSession.HostAddress.abOnline,(long)Constants.SIZESGADDR);
					if(!createReqs[i].Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out Resp[i]))
					{
						Global.RO.Warn("create session failed");
						return;
					}
				}
				// create a request that has 6 batched deadxbox message
				XRLDeadXBox    []    reqs = new XRLDeadXBox[6];
				for(int i = 0; i < 6; i++)
				{
					reqs[i] = new XRLDeadXBox(Constants.XENON_TITLE);
					reqs[i].sgaddr.dwSpiSg = (uint)(0x12345678+i);
					reqs[i].sgaddr.qwXboxID = sg.qwXboxID;
					Array.Copy(sg.inaSg,reqs[i].sgaddr.inaSg,4);
				}
				if(    MyOwnExecute(reqs, Constants.SIZEDEADXBOX*6,0))
				{
					XRL2DeleteSession[]    delReqs = new XRL2DeleteSession[6];
					for(int i = 0; i < 6; i++)
					{
						delReqs[i] = new XRL2DeleteSession(Resp[i].SessionID,Constants.XENON_TITLE);
                        if ((delReqs[i].Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd))) ||
                            (delReqs[i].XErr != HResult.XONLINE_E_MATCH_INVALID_SESSION_ID))
                        {
                            throw new UnexpectedTestResultException(MatchUtil.ErrMsgFromXRLPayload(
                                "Delete request succeeded unexpectedly or XErr != XONLINE_E_MATCH_INVALID_SESSION_ID.",
                                delReqs[i]));
                        }
					}
					ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}

        [TestCase, Description("send mixed batched deadxbox messages")]
		class PMixedBatchedMsg : TestBase
		{
			override protected void Execute()
			{
				SGADDR        sg = new SGADDR();
				byte[]        sgbytes;
				// create 50 sessions with different SGAddr
				XRL2CreateUpdateSession    []    createReqs = new XRL2CreateUpdateSession[50];
				XRLSessionInfo            []    Resp = new XRLSessionInfo[50];
				for(int i = 0, j=0; i < 100; i++, j++)
				{
					createReqs[j] = new XRL2CreateUpdateSession();

					sg.dwSpiSg = (uint)(0x12345678 + i);
					sgbytes = sg.toByteArray();
					Array.Copy(sgbytes,createReqs[j].baseCreateUpdate.baseSession.HostAddress.abOnline,(long)Constants.SIZESGADDR);
					if(!createReqs[j].Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out Resp[j]))
					{
						Global.RO.Warn("create session failed");
						return;
					}
					i++;
				}
				// create a request that has 100 batched deadxbox message
				XRLDeadXBox    []    reqs = new XRLDeadXBox[100];
				for(int i = 0; i < 100; i++)
				{
					reqs[i] = new XRLDeadXBox(Constants.XENON_TITLE);
					if(i%2 == 0)
						reqs[i].dwTitleID = Constants.XENON_TITLE;
					else
						reqs[i].dwTitleID = 4019;    // nonexistent title ID
					reqs[i].sgaddr.dwSpiSg = (uint)(0x12345678+i);
					reqs[i].sgaddr.qwXboxID = sg.qwXboxID;
					Array.Copy(sg.inaSg,reqs[i].sgaddr.inaSg,4);
				}
                if (MyOwnExecute(reqs, Constants.SIZEDEADXBOX * 100, 0))
                {
                    XRL2DeleteSession[] delReqs = new XRL2DeleteSession[50];
                    for (int i = 0; i < 50; i++)
                    {
                        delReqs[i] = new XRL2DeleteSession(Resp[i].SessionID, Constants.XENON_TITLE);
                        if ((delReqs[i].Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd))) ||
                            (delReqs[i].XErr != HResult.XONLINE_E_MATCH_INVALID_SESSION_ID))
                        {
                            throw new UnexpectedTestResultException(MatchUtil.ErrMsgFromXRLPayload(
                                "Delete request succeeded unexpectedly or XErr != XONLINE_E_MATCH_INVALID_SESSION_ID.",
                                delReqs[i]));
                        }
                    }
                    ResultCode = TEST_RESULTS.PASSED;
                }
			}
		}

        /***************************************************************************************
		 * The followings are negative cases
		 ***************************************************************************************/
		[TestCase, Description("malformed deadxbox messages")]
		class NMalformedMsg : TestBase
		{
			override protected void Execute()
			{
				XRLDeadXBox    []    reqs = new XRLDeadXBox[2]{new XRLDeadXBox(Constants.XENON_TITLE), new XRLDeadXBox(Constants.XENON_TITLE)};
				uint    dwTotalMsgLen = 2 * Constants.SIZEDEADXBOX + 1;
				// same DeadXbox message will be sent twice to the matchmaking front door
				if(    MyOwnExecute(reqs, dwTotalMsgLen,HResult.XONLINE_E_MATCH_REQUEST_TRUNCATED))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}

        [TestCase, Description("truncated deadxbox messages")]
		class NTruncateMsg : TestBase
		{
			override protected void Execute()
			{
				XRLDeadXBox    []    reqs = new XRLDeadXBox[2]{new XRLDeadXBox(Constants.XENON_TITLE), new XRLDeadXBox(Constants.XENON_TITLE)};
				uint    dwTotalMsgLen = 2 * Constants.SIZEDEADXBOX -1;
				// same DeadXbox message will be sent twice to the matchmaking front door
				if(    MyOwnExecute(reqs, dwTotalMsgLen,HResult.XONLINE_E_MATCH_REQUEST_TRUNCATED))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}

        [TestCase, Description("call DeadXbox with nonexistent title ID")]
		class NUnknownTitle : TestBase
		{
			override protected void Execute()
			{
				XRLDeadXBox    req = new XRLDeadXBox(Constants.XENON_TITLE);
				req.dwTitleID = 9;
				// although XStorage will throw these requests, but it still returns S_OK
				if(req.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd)))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XMatchTest\Func2SocialMatch.cs ===
using System;
using System.Threading;
using System.Data.SqlClient;
using System.Collections;
using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Matchmaking;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.PresNotiCommon;
using xonline.common.config;
using xonline.common.protocol;

namespace XMatchTest
{
    internal abstract class SocialMatchTestBase : TestBase {
        protected bool CheckNumResults(XRL2SearchResults searchResp, int expectedResults) {

            if (searchResp == null) {
                Global.RO.Warn("Search response was null!  Expected " + expectedResults + "!");
                return false;
            }
                
            if (searchResp.resultsLen != expectedResults) {
                Global.RO.Warn("Search response contains incorrect number of results.  Expected " + expectedResults + 
                               " but got " + searchResp.resultsLen);
                return false;
            }

            Global.RO.Success("Search response contains " + expectedResults + " result(s), as expected.");
            return true;
        }

    }

    internal abstract class NegativeSocialRankedMatchTestBase : SocialMatchTestBase
    {
        protected bool SearchTestNegative(XRL2SearchSession Req, uint XErr)
        {
            XRL2SearchResults        resp;
            if (Req.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out resp))
            {
                Global.RO.Warn("Negative CreateSession request succeed unexpectedly");
                return false;
            }
            if((Req.XErr != XErr) || (resp != null))
            {
                Global.RO.Warn("Wrong error code (" + Global.XErrToString(Req.XErr) + " != " + Global.XErrToString(XErr) + ") returned or response is not null");
                return false;
            }
            return true;
        }
        protected bool VerifyDB(bool ranked,long lSessID, double mu, double sigma, float rating)
        {
            // in xbox 360, we might not have title tables created across all servers, 
            // instead, we will only have title tables created in the actual servers that they live
            bool			ret = false;
            double			rMu = 0,rSigma = 0;
            float			rRating = 0;
            string			hexTitleID = "0x"+Constants.XENON_TITLE2.ToString("X");
            string		[]	dbList = Constants.getDBListForTitle(Constants.XENON_TITLE2);
            if(dbList == null)
            {
                Global.RO.Warn("Can't find the title in the npdb");
                return false;
            }

            bool found = false;
            foreach (string server in dbList)
            {
                found = false;
                // connect to the db
                string myConnStr = "Data Source=" +server+ @";Database=xmatch;" +
                    "Trusted_Connection=true";
                SqlConnection	mySqlConn;
                mySqlConn =  new SqlConnection(myConnStr);
                // get the row according to bi_session_id
                string			myQuery;
                if(ranked)
                    myQuery = @"SELECT		att_0x30008105,att_0x30008106,att_0x50008104
											FROM dbo.t_match_sessions_"+hexTitleID+@"_ranked s
											WHERE s.bi_session_id=" + lSessID;
                else //standard
                    myQuery = @"SELECT		att_0x30008105,att_0x30008106,att_0x50008104
											FROM dbo.t_match_sessions_"+hexTitleID+@"_standard s
											WHERE s.bi_session_id=" + lSessID;

                SqlCommand		myCommand = new SqlCommand(myQuery, mySqlConn);
                myCommand.Connection.Open();
                SqlDataReader	myReader = myCommand.ExecuteReader();
                while (myReader.Read())
                {
                    found = true;
                    rMu = myReader.GetDouble(0);
                    rSigma = myReader.GetDouble(1);
                    rRating = myReader.GetFloat(2);
                }
                myReader.Close();
                myCommand.Connection.Close();
                if(found)
                    break;
            }
            if(found)
            {
                if((rMu == mu) && (rSigma == sigma) && (rRating == rating))
                    ret = true;
                else Global.RO.Warn("returned mu/sigma/rating is not correct");
            }
            else
            {
                Global.RO.Warn("Couldn't not find the session");
            }
            return ret;
        }
    }
    internal abstract class PositiveSocialMatchTestBase : SocialMatchTestBase
    {
        //		SessionValue	Positive(2)	Negative(-3)	Friend(4)	Complete(1)	AvoidMe(-3)
        //		-3				0	0	0	0	1		
        //		1				0	0	0	1	0
        //		-2				0	0	0	1	1
        //		4				0	0	1	0	0
        //		1				0	0	1	0	1
        //		5				0	0	1	1	0
        //		2				0	0	1	1	1
        //		-3				0	1	0	0	0
        //		-6				0	1	0	0	1
        //		-2				0	1	0	1	0
        //		-5				0	1	0	1	1
        //		1				0	1	1	0	0
        //		-2				0	1	1	0	1
        //		2				0	1	1	1	0
        //		-1				0	1	1	1	1
        //		2				1	0	0	0	0
        //		-1				1	0	0	0	1
        //		3				1	0	0	1	0
        //		0				1	0	0	1	1
        //		6				1	0	1	0	0
        //		3				1	0	1	0	1
        //		7				1	0	1	1	0
        //		4				1	0	1	1	1
        //		-1				1	1	0	0	0
        //		-4				1	1	0	0	1
        //		0				1	1	0	1	0
        //		-3				1	1	0	1	1
        //		3				1	1	1	0	0
        //		0				1	1	1	0	1
        //		4				1	1	1	1	0
        //		1				1	1	1	1	1
        /******************************************************************************
         *  create 31 different combination of affiliate sessions
         *	some of the sessions with positive 
         ******************************************************************************/
        protected bool CreateAffiliateBaseSessions(uint titleID,PNUser primaryUser, out XRLSessionInfo	[]	goodSessionInfos, bool diffGameZone)
        {
            uint				numSessions = 31;
            if(diffGameZone)
            {
                if(CreateDiffZoneGoodSessions(titleID,numSessions,out goodSessionInfos) == false)
                    return false;
            }
            else
            {
                if(CreateSameZoneGoodSessions(titleID,numSessions,out goodSessionInfos) == false)
                    return false;
            }
            // assign the above sessions to affiliates
            uint	[]	affiliatesStatesInOneSession = new uint[numSessions];
            // we will use the bits of affiliateStatsInOneSession[i] as affiliate flags:
            // bit 0: AvoidMe
            // bit 1: Complete
            // bit 2: Friend
            // bit 3: negative
            // bit 4: positive
            for(uint i = 0; i < numSessions; i++)
                affiliatesStatesInOneSession[i] = i+1;
            AssignAffiliateSessions(primaryUser,goodSessionInfos,affiliatesStatesInOneSession);
            return true;
        }

        protected void CreateSingleAffiliateSession(uint titleID, PNUser primaryUser, XRLSessionInfo sessionInfo, uint affiliateFlags)
        {
            FriendsCommon fc = new FriendsCommon();
            CreateSingleAffiliateSession(fc, titleID, primaryUser, sessionInfo, affiliateFlags);
        }

        protected void CreateSingleAffiliateSession(FriendsCommon fc, uint titleID, PNUser primaryUser, XRLSessionInfo sessionInfo, uint affiliateFlags)
        {
            PNUser	affiliate = fc.CreateUser(true, titleID, XboxVersion.DEC_2004_ALPHA_XEDK, true);
            AffiliateState	state = new AffiliateState(primaryUser);
            if(affiliateFlags == (uint)AffiliateFlags.Friend)
            {
                fc.MakeFriend(primaryUser, affiliate);
            }
            else if (affiliateFlags == (uint)AffiliateFlags.AvoidingMe)
            {
                AffiliateState	negState = new AffiliateState(affiliate);
                negState.Add(primaryUser,(uint)AffiliateFlags.NegativeFeedback);
            }
            else
            {
                state.Add(affiliate,affiliateFlags);
            }
            affiliate.SetTitleData((ulong)Constants.sessionIDConvert(sessionInfo.SessionID));
        }

        protected void CreateSingleAffiliateSessionFast(FriendsCommon fc, uint titleID, PNUser primaryUser, XRLSessionInfo sessionInfo, uint affiliateFlags)
        {
            PNUser	affiliate = fc.CreateUser(true, titleID, XboxVersion.DEC_2004_ALPHA_XEDK, true);
            AffiliateState	state = new AffiliateState(primaryUser);
            state.SetAddPostSleep(500);
            if(affiliateFlags == (uint)AffiliateFlags.Friend)
            {
                fc.MakeFriend(primaryUser, affiliate);
            } 
            else if (affiliateFlags == (uint)AffiliateFlags.AvoidingMe)
            {
                AffiliateState	negState = new AffiliateState(affiliate);
                negState.Add(primaryUser, (uint)AffiliateFlags.NegativeFeedback);
            }
            else
            {
                state.Add(affiliate, affiliateFlags);
            }
            affiliate.SetTitleData((ulong)Constants.sessionIDConvert(sessionInfo.SessionID));
        }

        /// <summary>
        /// create sessions that meet title defined criteira; game_type is standard; game_mode is the same as searchUser
        /// has available slots and with compatible NAT
        /// </summary>
        protected bool CreateSameZoneGoodSessions(uint titleID, uint numSessions, out XRLSessionInfo[] GoodSessionInfos)
        {
            GoodSessionInfos = new XRLSessionInfo[numSessions];
            XRL2CreateUpdateSession[]	createReqs = new XRL2CreateUpdateSession[numSessions];
            // title defined search criteria
            float					floatV = 0.1f; // constant value defined in xlast
            XRLXeAttribParam	[]		Attribs = new XRLXeAttribParam[10];
            Attribs[0] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_TYPE,new XRLXeIntValue(Constants.X_ATTRIBUTE_GAME_TYPE_STANDARD));
            Attribs[1] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE, new XRLXeIntValue(Constants.CONTEXT_GAME_MODE_MODEA));
            Attribs[2] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_ZONE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_ZONE));
            Attribs[3] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_COUNTRY, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_COUNTRY));
            Attribs[4] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_LANGUAGE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_LANG));
            Attribs[5] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_RATING, new XRLXeFloatValue(Constants.XENON_TEST_DEFAULT_GAMER_RATING));
            Attribs[6] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_MU,new XRLXeDoubleValue(Constants.XENON_TEST_DEFAULT_GAMER_MU));
            Attribs[7] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_SIGMA, new XRLXeDoubleValue(Constants.XENON_TEST_DEFAULT_GAMER_SIGMA));
            if(titleID == Constants.XENON_TITLE)
                Attribs[8] = new XRLXeAttribParam(Constants.PROPERTY_MYFLOAT32PROP1,new XRLXeFloatValue(floatV));
            else if (titleID == Constants.XENON_TITLE2)
                Attribs[8] = new XRLXeAttribParam(Constants.PROPERTY_MYFLOAT32PROP1_XENON_TITLE2,new XRLXeFloatValue(floatV));
			
            long		intValue = 0;
            for(int i = 0; i < numSessions; i++)
            {
                intValue = i;
                Attribs[9] = new XRLXeAttribParam(Constants.PROPERTY_MYINT32PROP1,new XRLXeIntValue(intValue));
                createReqs[i] = new XRL2CreateUpdateSession(Attribs);
                createReqs[i].baseCreateUpdate.baseSession.dwTitleID = titleID;
                if(!(createReqs[i].Execute(Global.XEnv.GetInterface(Interface.xmatchfd)[0],out GoodSessionInfos[i])))
                    return false;
            }
            return true;
        }

        protected bool CreateDiffZoneGoodSessions(uint titleID, uint numSessions, out XRLSessionInfo[] SessionInfos)
        {
            SessionInfos = new XRLSessionInfo[numSessions];
            XRL2CreateUpdateSession[]	createReqs = new XRL2CreateUpdateSession[numSessions];
            // title defined search criteria
            float					floatV = 0.1f; // constant value defined in xlast
            XRLXeAttribParam	[]		Attribs = new XRLXeAttribParam[10];
            Attribs[0] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_TYPE,new XRLXeIntValue(Constants.X_ATTRIBUTE_GAME_TYPE_STANDARD));
            Attribs[1] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE, new XRLXeIntValue(Constants.CONTEXT_GAME_MODE_MODEA));
            Attribs[2] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_ZONE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_ZONE+1));
            Attribs[3] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_COUNTRY, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_COUNTRY));
            Attribs[4] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_LANGUAGE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_LANG));
            Attribs[5] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_RATING, new XRLXeFloatValue(Constants.XENON_TEST_DEFAULT_GAMER_RATING));
            Attribs[6] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_MU,new XRLXeDoubleValue(Constants.XENON_TEST_DEFAULT_GAMER_MU));
            Attribs[7] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_SIGMA, new XRLXeDoubleValue(Constants.XENON_TEST_DEFAULT_GAMER_SIGMA));
            if(titleID == Constants.XENON_TITLE)
                Attribs[8] = new XRLXeAttribParam(Constants.PROPERTY_MYFLOAT32PROP1,new XRLXeFloatValue(floatV));
            else if (titleID == Constants.XENON_TITLE2)
                Attribs[8] = new XRLXeAttribParam(Constants.PROPERTY_MYFLOAT32PROP1_XENON_TITLE2,new XRLXeFloatValue(floatV));

            long					intValue = 0;
            for(int i = 0; i < numSessions; i++)
            {
                intValue = i;
                Attribs[9] = new XRLXeAttribParam(Constants.PROPERTY_MYINT32PROP1,new XRLXeIntValue(intValue));
                createReqs[i] = new XRL2CreateUpdateSession(Attribs);
                createReqs[i].baseCreateUpdate.baseSession.dwTitleID = titleID;
                if(!(createReqs[i].Execute(Global.XEnv.GetInterface(Interface.xmatchfd)[0],out SessionInfos[i])))
                    return false;
            }
            return true;
        }
        /// <summary>
        /// create sessions that doesn't meet title defined criteria
        /// </summary>
        protected bool CreateBadSessions(uint titleID, bool diffZone,uint numSessions,out XRLSessionInfo[] BadSessionInfos)
        {
            BadSessionInfos = new XRLSessionInfo[numSessions];
            XRL2CreateUpdateSession[]	createReqs = new XRL2CreateUpdateSession[numSessions];
			
            float					floatV = 0.2f; // constant value defined in xlast is 0.1f
            XRLXeAttribParam	[]		Attribs = new XRLXeAttribParam[10];
            Attribs[0] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_TYPE,new XRLXeIntValue(Constants.X_ATTRIBUTE_GAME_TYPE_STANDARD));
            Attribs[1] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE, new XRLXeIntValue(Constants.CONTEXT_GAME_MODE_MODEA));
            if(diffZone)
                Attribs[2] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_ZONE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_ZONE+1));
            else
                Attribs[2] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_ZONE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_ZONE));
            Attribs[3] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_COUNTRY, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_COUNTRY));
            Attribs[4] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_LANGUAGE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_LANG));
            Attribs[5] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_RATING, new XRLXeFloatValue(Constants.XENON_TEST_DEFAULT_GAMER_RATING));
            Attribs[6] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_MU,new XRLXeDoubleValue(Constants.XENON_TEST_DEFAULT_GAMER_MU));
            Attribs[7] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_SIGMA, new XRLXeDoubleValue(Constants.XENON_TEST_DEFAULT_GAMER_SIGMA));
            if(titleID == Constants.XENON_TITLE)
                Attribs[8] = new XRLXeAttribParam(Constants.PROPERTY_MYFLOAT32PROP1,new XRLXeFloatValue(floatV));
            else if (titleID == Constants.XENON_TITLE2)
                Attribs[8] = new XRLXeAttribParam(Constants.PROPERTY_MYFLOAT32PROP1_XENON_TITLE2,new XRLXeFloatValue(floatV));

            Attribs[9] = new XRLXeAttribParam(Constants.PROPERTY_MYINT32PROP1,new XRLXeIntValue(200));

            for(int i = 0; i < numSessions; i++)
            {
                createReqs[i] = new XRL2CreateUpdateSession(Attribs);
                createReqs[i].baseCreateUpdate.baseSession.dwTitleID = titleID;
                if(!(createReqs[i].Execute(Global.XEnv.GetInterface(Interface.xmatchfd)[0],out BadSessionInfos[i])))
                    return false;
            }
            return true;
        }	
        protected bool CreateRankedSessions(uint titleID, bool diffZone, uint numSessions,out XRLSessionInfo[] SessionInfos)
        {
            SessionInfos = new XRLSessionInfo[numSessions];
            XRL2CreateUpdateSession[]	createReqs = new XRL2CreateUpdateSession[numSessions];
			
            float					floatV = 0.1f; // constant value defined in xlast is 0.1f
            XRLXeAttribParam	[]		Attribs = new XRLXeAttribParam[10];
            Attribs[0] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_TYPE,new XRLXeIntValue(Constants.X_ATTRIBUTE_GAME_TYPE_RANKED));
            Attribs[1] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE, new XRLXeIntValue(Constants.CONTEXT_GAME_MODE_MODEA));
            if(diffZone)
                Attribs[2] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_ZONE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_ZONE+1));
            else
                Attribs[2] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_ZONE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_ZONE));	
            Attribs[3] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_COUNTRY, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_COUNTRY));
            Attribs[4] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_LANGUAGE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_LANG));
            Attribs[5] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_RATING, new XRLXeFloatValue(Constants.XENON_TEST_DEFAULT_GAMER_RATING));
            Attribs[6] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_MU,new XRLXeDoubleValue(Constants.XENON_TEST_DEFAULT_GAMER_MU));
            Attribs[7] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_SIGMA, new XRLXeDoubleValue(Constants.XENON_TEST_DEFAULT_GAMER_SIGMA));
            if(titleID == Constants.XENON_TITLE)
                Attribs[8] = new XRLXeAttribParam(Constants.PROPERTY_MYFLOAT32PROP1,new XRLXeFloatValue(floatV));
            else if (titleID == Constants.XENON_TITLE2)
                Attribs[8] = new XRLXeAttribParam(Constants.PROPERTY_MYFLOAT32PROP1_XENON_TITLE2,new XRLXeFloatValue(floatV));

            Attribs[9] = new XRLXeAttribParam(Constants.PROPERTY_MYINT32PROP1,new XRLXeIntValue(200));

            for(int i = 0; i < numSessions; i++)
            {
                createReqs[i] = new XRL2CreateUpdateSession(Attribs);
                createReqs[i].baseCreateUpdate.baseSession.dwTitleID = titleID;
                if(!(createReqs[i].Execute(Global.XEnv.GetInterface(Interface.xmatchfd)[0],out SessionInfos[i])))
                    return false;
            }
            return true;
        }	
        protected bool CreateDiffGameModeSessions(uint titleID, bool diffZone, uint numSessions,out XRLSessionInfo[] SessionInfos)
        {
            SessionInfos = new XRLSessionInfo[numSessions];
            XRL2CreateUpdateSession[]	createReqs = new XRL2CreateUpdateSession[numSessions];
			
            float					floatV = 0.1f; // constant value defined in xlast is 0.1f
            XRLXeAttribParam	[]		Attribs = new XRLXeAttribParam[10];
            Attribs[0] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_TYPE,new XRLXeIntValue(Constants.X_ATTRIBUTE_GAME_TYPE_STANDARD));
            Attribs[1] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE, new XRLXeIntValue(Constants.CONTEXT_GAME_MODE_MODEB));
            if(diffZone)
                Attribs[2] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_ZONE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_ZONE+1));
            else
                Attribs[2] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_ZONE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_ZONE));
            Attribs[3] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_COUNTRY, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_COUNTRY));
            Attribs[4] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_LANGUAGE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_LANG));
            Attribs[5] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_RATING, new XRLXeFloatValue(Constants.XENON_TEST_DEFAULT_GAMER_RATING));
            Attribs[6] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_MU,new XRLXeDoubleValue(Constants.XENON_TEST_DEFAULT_GAMER_MU));
            Attribs[7] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_SIGMA, new XRLXeDoubleValue(Constants.XENON_TEST_DEFAULT_GAMER_SIGMA));
            if(titleID == Constants.XENON_TITLE)
                Attribs[8] = new XRLXeAttribParam(Constants.PROPERTY_MYFLOAT32PROP1,new XRLXeFloatValue(floatV));
            else if (titleID == Constants.XENON_TITLE2)
                Attribs[8] = new XRLXeAttribParam(Constants.PROPERTY_MYFLOAT32PROP1_XENON_TITLE2,new XRLXeFloatValue(floatV));

            Attribs[9] = new XRLXeAttribParam(Constants.PROPERTY_MYINT32PROP1,new XRLXeIntValue(200));

            for(int i = 0; i < numSessions; i++)
            {
                createReqs[i] = new XRL2CreateUpdateSession(Attribs);
                createReqs[i].baseCreateUpdate.baseSession.dwTitleID = titleID;
                if(!(createReqs[i].Execute(Global.XEnv.GetInterface(Interface.xmatchfd)[0],out SessionInfos[i])))
                    return false;
            }
            return true;
        }	
        protected bool CreateNonAvailableSessions(uint titleID, bool diffZone, uint numSessions,out XRLSessionInfo[] SessionInfos)
        {
            SessionInfos = new XRLSessionInfo[numSessions];
            XRL2CreateUpdateSession[]	createReqs = new XRL2CreateUpdateSession[numSessions];
			
            float					floatV = 0.1f; // constant value defined in xlast is 0.1f
            XRLXeAttribParam	[]		Attribs = new XRLXeAttribParam[10];
            Attribs[0] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_TYPE,new XRLXeIntValue(Constants.X_ATTRIBUTE_GAME_TYPE_STANDARD));
            Attribs[1] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE, new XRLXeIntValue(Constants.CONTEXT_GAME_MODE_MODEA));
            if(diffZone)
                Attribs[2] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_ZONE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_ZONE+1));
            else
                Attribs[2] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_ZONE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_ZONE));
            Attribs[3] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_COUNTRY, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_COUNTRY));
            Attribs[4] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_LANGUAGE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_LANG));
            Attribs[5] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_RATING, new XRLXeFloatValue(Constants.XENON_TEST_DEFAULT_GAMER_RATING));
            Attribs[6] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_MU,new XRLXeDoubleValue(Constants.XENON_TEST_DEFAULT_GAMER_MU));
            Attribs[7] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_SIGMA, new XRLXeDoubleValue(Constants.XENON_TEST_DEFAULT_GAMER_SIGMA));
            if(titleID == Constants.XENON_TITLE)
                Attribs[8] = new XRLXeAttribParam(Constants.PROPERTY_MYFLOAT32PROP1,new XRLXeFloatValue(floatV));
            else if (titleID == Constants.XENON_TITLE2)
                Attribs[8] = new XRLXeAttribParam(Constants.PROPERTY_MYFLOAT32PROP1_XENON_TITLE2,new XRLXeFloatValue(floatV));

            Attribs[9] = new XRLXeAttribParam(Constants.PROPERTY_MYINT32PROP1,new XRLXeIntValue(200));

            for(int i = 0; i < numSessions; i++)
            {
                createReqs[i] = new XRL2CreateUpdateSession(Attribs);
                createReqs[i].baseCreateUpdate.baseSession.dwPublicOpen = 3;//search request needs 4.
                createReqs[i].baseCreateUpdate.baseSession.dwTitleID = titleID;
                if(!(createReqs[i].Execute(Global.XEnv.GetInterface(Interface.xmatchfd)[0],out SessionInfos[i])))
                    return false;
            }
            return true;
        }	
        protected bool CreateInCompNATSessions(uint titleID, bool diffZone, uint numSessions,out XRLSessionInfo[] SessionInfos)
        {
            SessionInfos = new XRLSessionInfo[numSessions];
            XRL2CreateUpdateSession[]	createReqs = new XRL2CreateUpdateSession[numSessions];
			
            float					floatV = 0.1f; // constant value defined in xlast is 0.1f
            XRLXeAttribParam	[]		Attribs = new XRLXeAttribParam[10];
            Attribs[0] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_TYPE,new XRLXeIntValue(Constants.X_ATTRIBUTE_GAME_TYPE_STANDARD));
            Attribs[1] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE, new XRLXeIntValue(Constants.CONTEXT_GAME_MODE_MODEA));
            if(diffZone)
                Attribs[2] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_ZONE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_ZONE+1));
            else
                Attribs[2] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_ZONE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_ZONE));
            Attribs[3] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_COUNTRY, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_COUNTRY));
            Attribs[4] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_LANGUAGE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_LANG));
            Attribs[5] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_RATING, new XRLXeFloatValue(Constants.XENON_TEST_DEFAULT_GAMER_RATING));
            Attribs[6] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_MU,new XRLXeDoubleValue(Constants.XENON_TEST_DEFAULT_GAMER_MU));
            Attribs[7] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_SIGMA, new XRLXeDoubleValue(Constants.XENON_TEST_DEFAULT_GAMER_SIGMA));
            if(titleID == Constants.XENON_TITLE)
                Attribs[8] = new XRLXeAttribParam(Constants.PROPERTY_MYFLOAT32PROP1,new XRLXeFloatValue(floatV));
            else if (titleID == Constants.XENON_TITLE2)
                Attribs[8] = new XRLXeAttribParam(Constants.PROPERTY_MYFLOAT32PROP1_XENON_TITLE2,new XRLXeFloatValue(floatV));

            Attribs[9] = new XRLXeAttribParam(Constants.PROPERTY_MYINT32PROP1,new XRLXeIntValue(200));

            for(int i = 0; i < numSessions; i++)
            {
                createReqs[i] = new XRL2CreateUpdateSession(Attribs);
                createReqs[i].baseCreateUpdate.baseSession.dwTitleID = titleID;
                createReqs[i].baseCreateUpdate.baseSession.SessionID=new byte[]{0xB0,0,0,0,0,0,0,0};// sessions with moderate NAT
                if(!(createReqs[i].Execute(Global.XEnv.GetInterface(Interface.xmatchfd)[0],out SessionInfos[i])))
                    return false;
            }
            return true;
        }	
        protected void AssignAffiliateSessions(PNUser primaryUser,XRLSessionInfo[] sessionInfo, uint [] affiliatesStatesInOneSession)
        {
            AffiliateState		state = new AffiliateState(primaryUser);
            FriendsCommon		fc = new FriendsCommon();
			
            // create 80 affiliates that's online and in the same title as PrimaryUser
            uint			numAffiliates = 80;
            PNUser[]		affiliateUsers = new PNUser[numAffiliates];

            // assign different affiliate combinations to sessionID
            uint			numSessions = (uint)sessionInfo.Length;
            uint			j = 0;
            for(uint i = 0; i < numSessions; i++)
            {
                if((affiliatesStatesInOneSession[i] & 1) != 0)	// avoidMe 00001
                {
                    // create AvoidMe user and assign sessionInfo[i] to it
                    affiliateUsers[j] = fc.CreateUser(true, Constants.XENON_TITLE, XboxVersion.DEC_2004_ALPHA_XEDK,true);
                    //state.Add(affiliateUsers[j],(uint)AffiliateFlags.AvoidingMe);
                    AffiliateState avoidState = new AffiliateState(affiliateUsers[j]);
                    avoidState.Add(primaryUser, (uint)AffiliateFlags.NegativeFeedback);
                    affiliateUsers[j].SetTitleData((ulong)Constants.sessionIDConvert(sessionInfo[i].SessionID));
                    j++;
                }
                if((affiliatesStatesInOneSession[i] & 2) != 0)	// complete game 00010
                {
                    affiliateUsers[j] = fc.CreateUser(true, Constants.XENON_TITLE, XboxVersion.DEC_2004_ALPHA_XEDK,true);
                    state.Add(affiliateUsers[j],(uint)AffiliateFlags.CompletedGame);
                    affiliateUsers[j].SetTitleData((ulong)Constants.sessionIDConvert(sessionInfo[i].SessionID));
                    j++;
                }
                if((affiliatesStatesInOneSession[i] & 4) != 0)	// friend 00100
                {
                    affiliateUsers[j] = fc.CreateUser(true, Constants.XENON_TITLE, XboxVersion.DEC_2004_ALPHA_XEDK,true);
                    new FriendsCommon().MakeFriend(primaryUser, affiliateUsers[j]);
                    affiliateUsers[j].SetTitleData((ulong)Constants.sessionIDConvert(sessionInfo[i].SessionID));
                    j++;
                }
                if((affiliatesStatesInOneSession[i] & 8) != 0)	// negative feedback 01000
                {
                    affiliateUsers[j] = fc.CreateUser(true, Constants.XENON_TITLE, XboxVersion.DEC_2004_ALPHA_XEDK,true);
                    state.Add(affiliateUsers[j],(uint)AffiliateFlags.NegativeFeedback);
                    affiliateUsers[j].SetTitleData((ulong)Constants.sessionIDConvert(sessionInfo[i].SessionID));
                    j++;
                }
                if((affiliatesStatesInOneSession[i] & 16) != 0)	// positive feedback 10000
                {
                    affiliateUsers[j] = fc.CreateUser(true, Constants.XENON_TITLE, XboxVersion.DEC_2004_ALPHA_XEDK,true);
                    state.Add(affiliateUsers[j],(uint)AffiliateFlags.PositiveFeedback);
                    affiliateUsers[j].SetTitleData((ulong)Constants.sessionIDConvert(sessionInfo[i].SessionID));
                    j++;
                }
            }
        }

        protected bool socialMatchSearch(uint titleID, float searchUserRating, uint spIndex, ulong primaryUserID,
                                         long[] expectedSessionValues, out XRL2SearchResults searchResp)
        {
            XRLXeAttribParam[]		searchParams = new XRLXeAttribParam[9];
            searchParams[0] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_TYPE,new XRLXeIntValue(Constants.X_ATTRIBUTE_GAME_TYPE_STANDARD));
            searchParams[1] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE, new XRLXeIntValue(Constants.CONTEXT_GAME_MODE_MODEA));
            searchParams[2] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_ZONE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_ZONE));
            searchParams[3] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_COUNTRY, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_COUNTRY));
            searchParams[4] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_LANGUAGE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_LANG));
            searchParams[5] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_RATING, new XRLXeFloatValue(searchUserRating));
            searchParams[6] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_MU,new XRLXeDoubleValue(Constants.XENON_TEST_DEFAULT_GAMER_MU));
            searchParams[7] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_SIGMA, new XRLXeDoubleValue(Constants.XENON_TEST_DEFAULT_GAMER_SIGMA));
            searchParams[8] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_PUID,new XRLXeIntValue((long)primaryUserID));

            XRL2SearchSession	searchReq = new XRL2SearchSession(searchParams,spIndex);
            searchReq.baseSearchSession.wFlags = 3;	//searchUser has strict NAT
            searchReq.baseSearchSession.dwTitleID = titleID;
            if (!searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out searchResp))
            {
                Global.RO.Warn("socialMatchSearch request failed:"+ Global.XErrToString(searchReq.XErr));
                return false;
            }
            // check search results
            uint expectedNumResults = 0;
            if (expectedSessionValues != null)
            {
                expectedNumResults = (uint)expectedSessionValues.Length;
            }
            else // expected result is 0
            {
                if (searchResp != null)
                {
                    Global.RO.Warn("There are sessions (count: {0}) returned in the search results when none were expected", searchResp.resultsLen);
                    return false;
                }
                else
                {
                    return true;
                }
            }
            if (searchResp == null)
            {
                Global.RO.Warn("No search results returned");
                return false;
            }
            if (searchResp.resultsLen != expectedNumResults)
            {
                Global.RO.Warn("Number of sessions returned is not " + expectedNumResults + "; got: " + searchResp.resultsLen);
                return false;
            }
            for (int i = 0; i < expectedNumResults; i++)
            {
                if (searchResp.results[i].AttribOffsetsLen != 6)//3 defined in xlast + 3 default (gamer_zone,sessionvalue,hostname)
                {
                    Global.RO.Warn("The number of attributes returned is not 6!");
                    return false;
                }
                if ((searchResp.results[i].Attribs[3].attribParamID != Constants.X_ATTRIBUTE_GAMER_ZONE) ||
                    (((searchResp.results[i].Attribs[3].aValue as XRLXeIntValue).intValue != Constants.XENON_TEST_DEFAULT_GAMER_ZONE) &&
                     ((searchResp.results[i].Attribs[3].aValue as XRLXeIntValue).intValue != Constants.XENON_TEST_DEFAULT_GAMER_ZONE+1)))
                {
                    Global.RO.Warn("1st attribute in the session is either not X_ATTRIBUTE_GAMER_ZONE or value is wrong!");
                    return false;
                }
                if (searchResp.results[i].Attribs[5].attribParamID != Constants.X_ATTRIBUTE_AFFILIATE_VALUE)
                {
                    Global.RO.Warn("2nd attribute in the session is not X_ATTRIBUTE_AFFILIATE_VALUE!");
                    return false;
                }
                long	affValue = 0;
                if ((affValue=(searchResp.results[i].Attribs[5].aValue as XRLXeIntValue).intValue) != expectedSessionValues[i])
                {
                    Global.RO.Warn("Affiliate value is wrong:" + affValue+" while expected is "+expectedSessionValues[i]);
                    return false;
                }
            }
            return true;
        }

        /// <summary>
        /// This method is called in XENON_TITLE2
        /// </summary>
        /// <param name="diffZone"></param>
        /// <param name="ratingRange"></param>
        /// <param name="searchUserRating"></param>
        /// <returns></returns>
        protected bool VerifyRatings(bool diffZone, float ratingRange, float searchUserRating)
        {
            bool				ret = true;
            PNUser				primaryUser = new FriendsCommon().CreateUser(true,Constants.XENON_TITLE2,XboxVersion.DEC_2004_ALPHA_XEDK,true);
            ulong				primaryUserID = primaryUser.UserId;
            // create one positive and one negative affiliate same gamerZone session
            XRLSessionInfo	[]	affSessionInfos = new XRLSessionInfo[2];
            uint				flags = 0;
            if(CreateSameZoneGoodSessions(Constants.XENON_TITLE2,2,out affSessionInfos) == false)
                return false;
            for(int i = 0; i < affSessionInfos.Length; i++)
            {
                if(i == 0)
                    flags = (uint)AffiliateFlags.Friend;
                else
                    flags = (uint)AffiliateFlags.AvoidingMe;
                CreateSingleAffiliateSession(Constants.XENON_TITLE2,primaryUser,affSessionInfos[i],flags);
            }

            // the stored proc is looking for maxresults + neg_sessions = 25 + 2 = 27 results.
            // therefore the broadening algorithm will terminate when it finds more than 
            // 27 * 2 = 54 rows. So we create 55 sessions. The first 53 sessions have the same
            // rating, the 54th session is just inside the rating range, and the 55th session
            // is just outside the rating range and shouldn't even be considered by the
            // stored proc.
            uint	numSessions = 55;
            XRL2CreateUpdateSession	[]	createReqs = new XRL2CreateUpdateSession[numSessions];
            XRLSessionInfo	[]	nonAffSameZonesessionInfos = new XRLSessionInfo[numSessions];
            XRLXeAttribParam	[]		Attribs = new XRLXeAttribParam[10];
            Attribs[0] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_TYPE,new XRLXeIntValue(Constants.X_ATTRIBUTE_GAME_TYPE_STANDARD));
            Attribs[1] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE, new XRLXeIntValue(Constants.CONTEXT_GAME_MODE_MODEA));
            if(diffZone)
                Attribs[2] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_ZONE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_ZONE+1));
            else
                Attribs[2] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_ZONE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_ZONE));
            Attribs[3] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_COUNTRY, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_COUNTRY));
            Attribs[4] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_LANGUAGE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_LANG));
            Attribs[6] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_MU,new XRLXeDoubleValue(Constants.XENON_TEST_DEFAULT_GAMER_MU));
            Attribs[7] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_SIGMA, new XRLXeDoubleValue(Constants.XENON_TEST_DEFAULT_GAMER_SIGMA));
            Attribs[8] = new XRLXeAttribParam(Constants.PROPERTY_MYFLOAT32PROP1_XENON_TITLE2,new XRLXeFloatValue(0.1f));
            Attribs[9] = new XRLXeAttribParam(Constants.PROPERTY_MYINT32PROP1,new XRLXeIntValue(500));

            float	narrowRatingRange = ratingRange/2;
            if(searchUserRating <0)
                searchUserRating = 0.0f;
            else if (searchUserRating >100)
                searchUserRating = 100.0f;

            float	nextLevelRating = searchUserRating;
            string	rating = ratingRange+"";
            switch(rating)
            {
                case "0.390625":
                    nextLevelRating += 0.78125f;
                    break;
                case "0.78125":
                    nextLevelRating -= 1.5625f;
                    break;
                case "1.5625":
                    nextLevelRating += 3.125f;
                    break;
                case "3.125":
                    nextLevelRating -= 6.25f;
                    break;
                case "6.25":
                    nextLevelRating += 12.5f;
                    break;
                case "12.5":
                    nextLevelRating += 25.0f;
                    break;
                case "25":
                    nextLevelRating += 50.0f;
                    break;
                default:
                    break;
            }
			
            // floating point math is not exact, so we give ourselves a tiny bit of
            // slack by reducing the range by 0.0001. If we don't do this, sometimes
            // the roundoff errors conspire to make ratingRange just a bit outside the
            // range the server will search on.
            float	finalRating1=0,finalRating2 = searchUserRating+ratingRange-0.0000001f;
            if(searchUserRating == 0.0f)
            {
                finalRating1 = 0+narrowRatingRange-0.0000001f;
                finalRating2 = 0+ratingRange-0.0000001f;
                nextLevelRating = 100;
            }
            else if (searchUserRating == 100.0f)
            {
                finalRating1 = 100-narrowRatingRange+0.0000001f;
                finalRating2 = 100-ratingRange+0.0000001f;
                nextLevelRating = 0;
            }

            double tempMu=0;
            for(int i = 0; i < numSessions; i++)
            {
                /*********************************************************************************************
                 * create 1 session with same language and different country, just inside the rating range
                 *    -- we expect this session to be considered, and sorted to the top of the list
                 * create 5 sessions with same country and different language, very close to searcher's rating
                 *    -- we expect these 5 sessions to be returned next in the result set
                 * create 48 sessions with same different country and language, very close to seracher's rating
                 *    -- we expect these sessions to fill out the rest of the result set
                 * create 1 session with same language and different country, just outside the rating range
                 *    -- we expect this session will not be considered, and therefore not appear in the results
                 ********************************************************************************************/
                if(i < numSessions-2)	
                {
                    // WARNING:if and else clauses are identical!  Potential bug!
                    if(searchUserRating == 50.0f && (i % 2 == 0))
                    {
                        finalRating1 = searchUserRating + narrowRatingRange - 0.0000001f;
                    }
                    else if(searchUserRating == 50.0f && (i % 2 == 0))
                    {
                        finalRating1 = searchUserRating - narrowRatingRange + 0.0000001f;
                    }
                    Attribs[5] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_RATING, new XRLXeFloatValue(finalRating1));
					
                    if(i < 5)	// these sessions has same country, but different language. i =0,1,2,3,4
                    {
                        Attribs[3] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_COUNTRY, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_COUNTRY));
                        Attribs[4] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_LANGUAGE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_LANG+1));
                        // within these 5 sessions, title defined sortBy is either 0 or 1
                        // they have different mu (draw probability is different for each session)
                        tempMu=1+0.2*i;
                        if(i<2)
                        {
                            Attribs[9] = new XRLXeAttribParam(Constants.PROPERTY_MYINT32PROP1,new XRLXeIntValue(1));
                            if(i==0)
                                tempMu = 1.0;
                            else
                                tempMu = 1.2;
                        }
                        else
                            Attribs[9] = new XRLXeAttribParam(Constants.PROPERTY_MYINT32PROP1,new XRLXeIntValue(0));
                        Attribs[6] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_MU,new XRLXeDoubleValue(tempMu));
                    }
                    else	// both country and language are different; i=5,6,7...
                    {
                        Attribs[3] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_COUNTRY, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_COUNTRY+1));
                        Attribs[4] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_LANGUAGE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_LANG+1));
                    }
                }
                else if ( i == numSessions-2)	// language is the same as searchUser, but with broader rating
                {
                    Attribs[3] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_COUNTRY, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_COUNTRY+1));
                    Attribs[4] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_LANGUAGE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_LANG));
                    Attribs[5] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_RATING, new XRLXeFloatValue(finalRating2));
                    Attribs[9] = new XRLXeAttribParam(Constants.PROPERTY_MYINT32PROP1,new XRLXeIntValue(9999));
                }
                /**********************************************************************************************
                 * create another session that is out of the 1st level range and will be filtered out
                 **********************************************************************************************/
                //note that to fall off the end, this session must have non-matching
                //country and language as well.
                if ( i == numSessions-1)	// language is the same as searchUser, but is out of the 1st level range 
                {
                    Attribs[3] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_COUNTRY, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_COUNTRY+1));
                    Attribs[4] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_LANGUAGE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_LANG+1));
                    Attribs[5] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_RATING, new XRLXeFloatValue(nextLevelRating));
                    Attribs[9] = new XRLXeAttribParam(Constants.PROPERTY_MYINT32PROP1,new XRLXeIntValue(9999));
                    //Add something to the mu insetad of the rating so that this
                    //session is not used.  At one time rating was used instead
                    //of mu in social matches, but because reputation seemed
                    //inaccurate, mu was used instead.
                    Attribs[6] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_MU,
                                                      new XRLXeDoubleValue(Constants.XENON_TEST_DEFAULT_GAMER_MU + 
                                                                           (200 * ratingRange)));
                }

                createReqs[i] = new XRL2CreateUpdateSession(Attribs);
                createReqs[i].baseCreateUpdate.baseSession.dwTitleID = Constants.XENON_TITLE2;
                if(!(createReqs[i].Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out nonAffSameZonesessionInfos[i])))
                {
                    DeleteTestSessions(Constants.XENON_TITLE2,affSessionInfos);
                    return false;
                }
            }

            // create 1 positive affiliate different gamer zone
            XRLSessionInfo	[]	AffDiffZoneSess;
            CreateDiffZoneGoodSessions(Constants.XENON_TITLE2,1,out AffDiffZoneSess);
            CreateSingleAffiliateSession(Constants.XENON_TITLE2,primaryUser,AffDiffZoneSess[0],(uint)AffiliateFlags.PositiveFeedback);

            // create 1 non affiliate different gamer zone
            uint	totalSessions = 1;
            XRLSessionInfo	[]	nonAffDiffZoneSess;
            CreateDiffZoneGoodSessions(Constants.XENON_TITLE2,totalSessions,out nonAffDiffZoneSess);

            long[] expectedSessionValue = new long[]{4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}; //expectedNumResults = 25
            if(diffZone)
            {
                expectedSessionValue[1] = 2;	// positive affiliate different gamer zone session
            }
            XRL2SearchResults   searchResp;
            if(socialMatchSearch(Constants.XENON_TITLE2,searchUserRating,Constants.SESSION_MATCH_QUERY_SOCIALMATCHQUERYFORTITLEONSINGLEDB,primaryUserID,expectedSessionValue,out searchResp))
            {
                // check results that friends affiliate same zone returned 1st.
                long	retSessionID = Constants.sessionIDConvert(searchResp.results[0].SessionID);
                long	expSessionID = Constants.sessionIDConvert(affSessionInfos[0].SessionID),badSessionID1,badSessionID2;
                if(retSessionID != expSessionID)
                {
                    Global.RO.Warn("The 1st returned session is not correct");
                    ret = false;
                    goto exit;
                }
                // the one with nextLevelRating ratings won't be returned except the current level is 50.0f
                bool	found1 = false, found2 = false;
                badSessionID1 = Constants.sessionIDConvert(AffDiffZoneSess[0].SessionID);
                badSessionID2 = Constants.sessionIDConvert(nonAffSameZonesessionInfos[numSessions-1].SessionID);

                for(int i = 1; i < 25; i++)
                {
                    retSessionID = Constants.sessionIDConvert(searchResp.results[i].SessionID);
                    if(retSessionID==badSessionID2)
                    {
                        Global.RO.Warn("nextLevelRating session is returned in the search results");
                        ret = false;
                        found1 = true;
                        break;
                    }
                }	

                if(diffZone == false) // check AffDiffZoneSess[0] is not being returned; 
                {
                    for(int i = 1; i < 25; i++)
                    {
                        retSessionID = Constants.sessionIDConvert(searchResp.results[i].SessionID);
                        if(retSessionID == badSessionID1)
                        {
                            Global.RO.Warn("AffDiffZoneSess session is returned in the search results");
                            ret = false;
                            found2 = true;
                            break;
                        }
                    }
                }
                else	// AffDiffZoneSess[0] will be returned 2nd.
                {
                    retSessionID = Constants.sessionIDConvert(searchResp.results[1].SessionID);
                    if(retSessionID != badSessionID1)
                    {
                        Global.RO.Warn("AffDiffZoneSess[0] is not returned 2nd");
                        ret = false;
                    }
                    else	
                        found2 = false;
                }
                if(!found1 && !found2)
                {	
                    if(diffZone)
                        goto exit;	// we have verified 1st and 2nd sessions returne correctly, exit now.
                    long retSessID = 0, expSessID = 0;
                    // check the session with the same lang and same country returned 1st among 24 sessions
                    retSessID = Constants.sessionIDConvert(searchResp.results[1].SessionID);
                    expSessID = Constants.sessionIDConvert(nonAffSameZonesessionInfos[numSessions-2].SessionID);
                    if(retSessID != expSessID)
                    {
                        Global.RO.Warn("The 2nd returned session is not correct (same lang, diff country)");
                        ret = false;
                        goto exit;
                    }
                    // check the rest of 23 sessions are in the right order
                    // within each group(lang or country the same), title defined sort criteria applied first
                    // then draw probability applied second
                    for(int j = 2; j < 25; j++)
                    {
                        retSessID = Constants.sessionIDConvert(searchResp.results[j].SessionID);
                        // check same country, different language returned next; i =0,1,2,3,4
                        if(j < 5)// j=2,3,4
                        {
                            // within this group, sortBy=0 returned 1st(i=2,3,4), sortBy=1(i=0,1) returned 2nd
                            // within sortBy=1, smallerMu returned first(i=1,0); within sortBy=0,smallermureturned first
                            expSessID = Constants.sessionIDConvert(nonAffSameZonesessionInfos[j].SessionID);
                            if(retSessID != expSessID)
                            {
                                Global.RO.Warn("Same Lang different country:SortBy=0 sessions is not in the right order");
                                ret = false;
                                break;
                            }
                        }
                        else if (j < 7) // j = 5,6
                        {// same country, differnet language, sortBy=1, bigger mu returned first (i = 0,1)
                            expSessID = Constants.sessionIDConvert(nonAffSameZonesessionInfos[j-5].SessionID);
                            if(retSessID != expSessID)
                            {
                                Global.RO.Warn("SameLangDifferntCountry:SortBy=1 is not in the right order");
                                ret = false;
                                break;
                            }
                        }
                    }
                }
            }
            else
            {
                ret = false;
            }
            exit:
            DeleteTestSessions(Constants.XENON_TITLE2,affSessionInfos);
            DeleteTestSessions(Constants.XENON_TITLE2,nonAffSameZonesessionInfos);
            DeleteTestSessions(Constants.XENON_TITLE2,AffDiffZoneSess);
            DeleteTestSessions(Constants.XENON_TITLE2,nonAffDiffZoneSess);
            return ret;
        }

        protected bool DeleteTestSessions(uint titleID, XRLSessionInfo[] sessionInfos)
        {
            if(sessionInfos == null)
            {
                return false;
            }
            for(int i = 0; i < sessionInfos.Length; i++)
            {
                if (sessionInfos[i] == null)
                {
                    continue;
                }
                XRL2DeleteSession delReq = new XRL2DeleteSession(sessionInfos[i].SessionID, titleID);
                if(!delReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd)))
                {
                    Global.RO.Warn("Session Delete failed:" + Global.XErrToString(delReq.XErr));
                    return false;
                }
            }
            return true;
        }
    }

    [TestGroup]
    public class Func2SocialMatch : TestNode
    {
        private bool MatchTitleUpdated = false;

        [TestGroupSetup]
        public void Setup()
        {
            //make sure table is cleaned out before we begin.
            Global.RO.Info("Cleaning tables before run for title " + Constants.XENON_TITLE.ToString("X"));
            MatchUtil.TruncateSessionsForTitle(Constants.XENON_TITLE, SessionType.Social);
            Global.RO.Info("Cleaning tables before run for title " + Constants.XENON_TITLE2.ToString("X"));
            MatchUtil.TruncateSessionsForTitle(Constants.XENON_TITLE2, SessionType.Social);

            MatchTitle matchTitle = MatchTitleMgr.GetMatchTitle(Constants.XENON_TITLE2);
            if (matchTitle.DeleteDelaySeconds != 0)
            {
                matchTitle = MatchTitleMgr.SnapshotMatchTitle(Constants.XENON_TITLE2);
                matchTitle.DeleteDelaySeconds = 0;
                MatchTitleMgr.UpdateMatchTitle(matchTitle);
                MatchTitleUpdated = true;
                MatchFDs.ReloadTitleInfo();
            }
        }

        [TestGroupTearDown]
        public void TearDown()
        {
            if (MatchTitleUpdated)
            {
                MatchTitleMgr.RestoreMatchTitleFromSnapshot(Constants.XENON_TITLE2);
                MatchFDs.ReloadTitleInfo();
            }
        }

        /***************************************************************************************
         * Xbox 360: Social Match Testing
         ***************************************************************************************/
        [TestCase, Description("a single user is friend, complete and positive with searchUser and in the sametitle online. ")]
        class PSingleUserMultiPosAffiliate : PositiveSocialMatchTestBase
        {
            override protected void Execute()
            {	
                PNUser				primaryUser = new FriendsCommon().CreateUser(true,Constants.XENON_TITLE,XboxVersion.DEC_2004_ALPHA_XEDK,true);
                ulong				primaryUserID = primaryUser.UserId;
                // create one session for the user
                XRLSessionInfo	[]	affSessionInfos = new XRLSessionInfo[1];
                if(CreateSameZoneGoodSessions(Constants.XENON_TITLE,1,out affSessionInfos) == false)
                    return;
                // add friend/complete/positive affiliations for this single user.
                FriendsCommon	fc = new FriendsCommon();
                PNUser affiliate = fc.CreateUser(true, Constants.XENON_TITLE, XboxVersion.DEC_2004_ALPHA_XEDK, true);
                AffiliateState	state = new AffiliateState(primaryUser);
                fc.MakeFriend(primaryUser, affiliate);
                state.Add(affiliate,(uint)AffiliateFlags.CompletedGame);
                state.Add(affiliate,(uint)AffiliateFlags.PositiveFeedback);
                affiliate.SetTitleData((ulong)Constants.sessionIDConvert(affSessionInfos[0].SessionID));

                // check the session returned with the right session value
                long[] expectedSessionValue = new long[]{7}; //expectedNumResults = 1
                XRL2SearchResults   searchResp;
                if(socialMatchSearch(Constants.XENON_TITLE,1.0f,Constants.SESSION_MATCH_QUERY_SOCIALMATCHQUERY1,primaryUserID,expectedSessionValue,out searchResp))
                    ResultCode=TEST_RESULTS.PASSED;

                DeleteTestSessions(Constants.XENON_TITLE,affSessionInfos);
            }
        }
        [TestCase, Description("a single user is avoidMe and negative feedback with searchUser and in the sametitle online. ")]
        class PSingleUserMultiNegAffiliate : PositiveSocialMatchTestBase
        {
            override protected void Execute()
            {	
                PNUser				primaryUser = new FriendsCommon().CreateUser(true,Constants.XENON_TITLE,XboxVersion.DEC_2004_ALPHA_XEDK,true);
                ulong				primaryUserID = primaryUser.UserId;
                // create one session for the user
                XRLSessionInfo	[]	affSessionInfos = new XRLSessionInfo[1];
                if(CreateSameZoneGoodSessions(Constants.XENON_TITLE,1,out affSessionInfos) == false)
                    return;
                // add avoidMe and negative affiliations for this single user.
                FriendsCommon	fc = new FriendsCommon();
                PNUser	affiliate = fc.CreateUser(true, Constants.XENON_TITLE, XboxVersion.DEC_2004_ALPHA_XEDK,true);
                AffiliateState	state = new AffiliateState(primaryUser);
                state.Add(affiliate,(uint)AffiliateFlags.NegativeFeedback);
                AffiliateState	state2 = new AffiliateState(affiliate);
                state2.Add(primaryUser,(uint)AffiliateFlags.NegativeFeedback);
                affiliate.SetTitleData((ulong)Constants.sessionIDConvert(affSessionInfos[0].SessionID));

                // check the session returned with the right session value
                long[] expectedSessionValue = null; //expectedNumResults = 0
                XRL2SearchResults   searchResp;
                if(socialMatchSearch(Constants.XENON_TITLE,1.0f,Constants.SESSION_MATCH_QUERY_SOCIALMATCHQUERY1,primaryUserID,expectedSessionValue,out searchResp))
                    ResultCode=TEST_RESULTS.PASSED;

                DeleteTestSessions(Constants.XENON_TITLE,affSessionInfos);
            }
        }

        [TestCase, Description("Test 31 affiliate combinations that can be in one session ")]
        class PAffSameZoneMainLine : PositiveSocialMatchTestBase
        {
            override protected void Execute()
            {	
                PNUser				primaryUser = new FriendsCommon().CreateUser(true,Constants.XENON_TITLE,XboxVersion.DEC_2004_ALPHA_XEDK,true);
                ulong				primaryUserID = primaryUser.UserId;
                XRLSessionInfo	[]	SessionInfos;
                if(CreateAffiliateBaseSessions(Constants.XENON_TITLE,primaryUser, out SessionInfos, false) == false)
                    return;
				
                // check only sessions with positive affiliate values returned and in the right order	
                long[] expectedSessionValue = new long[]{7,6,5,4,4,4,3,3,3,2,2,2,1,1,1,1,0,0,0}; //expectedNumResults = 19
                XRL2SearchResults   searchResp;
                if(socialMatchSearch(Constants.XENON_TITLE,1.0f,Constants.SESSION_MATCH_QUERY_SOCIALMATCHQUERY1,primaryUserID,expectedSessionValue,out searchResp))
                    ResultCode=TEST_RESULTS.PASSED;

                DeleteTestSessions(Constants.XENON_TITLE,SessionInfos);
            }
        }

        [TestCase, Description("has both good and bad sessions available")]
        class PAffSameZoneMixedSessions : PositiveSocialMatchTestBase
        {
            override protected void Execute()
            {
                PNUser				primaryUser = new FriendsCommon().CreateUser(true,Constants.XENON_TITLE,XboxVersion.DEC_2004_ALPHA_XEDK,true);
                ulong				primaryUserID = primaryUser.UserId;
                XRLSessionInfo	[]	goodSessionInfos;
                if(CreateAffiliateBaseSessions(Constants.XENON_TITLE,primaryUser,out goodSessionInfos,false) == false)
                    return;

                // create addtional 5 positive affiliate values sessions
                XRLSessionInfo	[]	badSessionInfos = new XRLSessionInfo[5];
                XRLSessionInfo[]	tempSessionInfo;
                CreateRankedSessions(Constants.XENON_TITLE,false,1,out tempSessionInfo);
                badSessionInfos[0] = tempSessionInfo[0];
                CreateDiffGameModeSessions(Constants.XENON_TITLE,false,1,out tempSessionInfo);
                badSessionInfos[1] = tempSessionInfo[0];
                CreateNonAvailableSessions(Constants.XENON_TITLE,false,1,out tempSessionInfo);
                badSessionInfos[2] = tempSessionInfo[0];
                CreateInCompNATSessions(Constants.XENON_TITLE,false, 1,out tempSessionInfo);
                badSessionInfos[3] = tempSessionInfo[0];
                CreateBadSessions(Constants.XENON_TITLE,false, 1,out tempSessionInfo);
                badSessionInfos[4] = tempSessionInfo[0];

                for(int i = 0; i < badSessionInfos.Length; i++)
                    CreateSingleAffiliateSession(Constants.XENON_TITLE,primaryUser,badSessionInfos[i],(uint)AffiliateFlags.Friend);

                // check results that the above sessions won't be returned.	
                long[] expectedSessionValue = new long[]{7,6,5,4,4,4,3,3,3,2,2,2,1,1,1,1,0,0,0}; //expectedNumResults = 19
                XRL2SearchResults   searchResp;
                if(socialMatchSearch(Constants.XENON_TITLE,1.0f,Constants.SESSION_MATCH_QUERY_SOCIALMATCHQUERY1,primaryUserID,expectedSessionValue,out searchResp))
                    ResultCode=TEST_RESULTS.PASSED;

                DeleteTestSessions(Constants.XENON_TITLE,goodSessionInfos);
                DeleteTestSessions(Constants.XENON_TITLE,badSessionInfos);
            }
        }
        [TestCase, Description("non-affiliateSameGameZone will be returned in the title defined sort order")]
        class PNonAffSameZoneMainLine : PositiveSocialMatchTestBase
        {
            override protected void Execute()
            {
                PNUser				primaryUser = new FriendsCommon().CreateUser(true,Constants.XENON_TITLE,XboxVersion.DEC_2004_ALPHA_XEDK,true);
                ulong				primaryUserID = primaryUser.UserId;
                // create one positive and 1 negative affiliate same gamerZone sessions
                XRLSessionInfo	[]	affSessionInfos = new XRLSessionInfo[2];
                uint				flags = 0;
                if(CreateSameZoneGoodSessions(Constants.XENON_TITLE,2,out affSessionInfos) == false)
                    return;
                for(int i = 0; i < affSessionInfos.Length; i++)
                {
                    if(i == 0)
                        flags = (uint)AffiliateFlags.Friend;
                    else
                        flags = (uint)AffiliateFlags.AvoidingMe;
                    CreateSingleAffiliateSession(Constants.XENON_TITLE,primaryUser,affSessionInfos[i],flags);
                }

                // create 3 non-affiliate same gamer zone session in each db that the title lives in with different int32 attribute
                uint    numDB = Constants.getNumDBForTitle(Constants.XENON_TITLE);
                uint	numSessions = numDB * 3;
                XRLSessionInfo	[]	nonAffsessionInfos;
                CreateSameZoneGoodSessions(Constants.XENON_TITLE,numSessions,out nonAffsessionInfos);

                // check results that 1 posAff session returned 1st, and 3 non-affilite returned in the acending int32 attrib order
                long[] expectedSessionValue = new long[]{4,0,0,0}; //expectedNumResults = 4
                XRL2SearchResults   searchResp;
                if(socialMatchSearch(Constants.XENON_TITLE,1.0f,Constants.SESSION_MATCH_QUERY_SOCIALMATCHQUERY1,primaryUserID,expectedSessionValue,out searchResp))
                {
                    // check the order in which the 3 sessions returned
                    long	intValue1 = (searchResp.results[1].Attribs[0].aValue as XRLXeIntValue).intValue;
                    long	intValue2 = (searchResp.results[2].Attribs[0].aValue as XRLXeIntValue).intValue;
                    long	intValue3 = (searchResp.results[3].Attribs[0].aValue as XRLXeIntValue).intValue;
                    if((intValue1<intValue2) && (intValue2<intValue3))
                        ResultCode=TEST_RESULTS.PASSED;
                }

                DeleteTestSessions(Constants.XENON_TITLE,affSessionInfos);
                DeleteTestSessions(Constants.XENON_TITLE,nonAffsessionInfos);
            }
        }
        [TestCase, Description("non-affiliateSameGameZone: has both good and bad sessions available")]
        class PNonAffSameZoneMixedSessions : PositiveSocialMatchTestBase
        {
            override protected void Execute()
            {
                PNUser				primaryUser = new FriendsCommon().CreateUser(true,Constants.XENON_TITLE,XboxVersion.DEC_2004_ALPHA_XEDK,true);
                ulong				primaryUserID = primaryUser.UserId;
                // create one positive and 1 negative affiliate same gamerZone sessions
                XRLSessionInfo	[]	affSessionInfos = new XRLSessionInfo[2];
                uint				flags = 0;
                if(CreateSameZoneGoodSessions(Constants.XENON_TITLE,2,out affSessionInfos) == false)
                    return;
                for(int i = 0; i < affSessionInfos.Length; i++)
                {
                    if(i == 0)
                        flags = (uint)AffiliateFlags.Friend;
                    else
                        flags = (uint)AffiliateFlags.AvoidingMe;
                    CreateSingleAffiliateSession(Constants.XENON_TITLE,primaryUser,affSessionInfos[i],flags);
                }

                // create 3 non-affiliate same gamer zone session in each db that the title lives in with different int32 attribute
                uint    numDB = Constants.getNumDBForTitle(Constants.XENON_TITLE);
                uint	numSessions = numDB * 3;
                XRLSessionInfo	[]	nonAffsessionInfos;
                CreateSameZoneGoodSessions(Constants.XENON_TITLE,numSessions,out nonAffsessionInfos);

                // create 5 bad sessions on each db the title lives in:
                // non-affiliate ranked session; different game mode session; notAvailable session; imcompatible nat session; bad session
                // these sessions has int32 attribute set to 200
                uint	numBadSessions = numDB * 1;
                XRLSessionInfo[]	tempSessionInfo1 = new XRLSessionInfo[numBadSessions],tempSessionInfo2 = new XRLSessionInfo[numBadSessions],
                    tempSessionInfo3 = new XRLSessionInfo[numBadSessions],tempSessionInfo5 = new XRLSessionInfo[numBadSessions],
                    tempSessionInfo4 = new XRLSessionInfo[numBadSessions];
                CreateRankedSessions(Constants.XENON_TITLE,false,numBadSessions,out tempSessionInfo1);
                CreateDiffGameModeSessions(Constants.XENON_TITLE,false,numBadSessions,out tempSessionInfo2);
                CreateNonAvailableSessions(Constants.XENON_TITLE,false,numBadSessions,out tempSessionInfo3);
                CreateInCompNATSessions(Constants.XENON_TITLE,false,numBadSessions,out tempSessionInfo4);
                CreateBadSessions(Constants.XENON_TITLE,false,numBadSessions,out tempSessionInfo5);

                // check results that 1 posAff session returned 1st, and 3 non-affilite returned in the acending int32 attrib order
                // all the other bad sessions won't be returned
                long[] expectedSessionValue = new long[]{4,0,0,0}; //expectedNumResults = 4
                XRL2SearchResults   searchResp;
                if(socialMatchSearch(Constants.XENON_TITLE,1.0f,Constants.SESSION_MATCH_QUERY_SOCIALMATCHQUERY1,primaryUserID,expectedSessionValue,out searchResp))
                {
                    // check the order in which the 3 sessions returned
                    long	intValue1 = (searchResp.results[1].Attribs[0].aValue as XRLXeIntValue).intValue;
                    long	intValue2 = (searchResp.results[2].Attribs[0].aValue as XRLXeIntValue).intValue;
                    long	intValue3 = (searchResp.results[3].Attribs[0].aValue as XRLXeIntValue).intValue;
                    if((intValue1==200) || (intValue2==200) || (intValue3==200))	// check bad sessions are not returned
                    {
                        Global.RO.Warn("Bad Sessions are returned");
                        return;
                    }
                    if((intValue1<intValue2) && (intValue2<intValue3))
                        ResultCode=TEST_RESULTS.PASSED;
                }

                DeleteTestSessions(Constants.XENON_TITLE,affSessionInfos);
                DeleteTestSessions(Constants.XENON_TITLE,nonAffsessionInfos);
                DeleteTestSessions(Constants.XENON_TITLE,tempSessionInfo1);
                DeleteTestSessions(Constants.XENON_TITLE,tempSessionInfo2);
                DeleteTestSessions(Constants.XENON_TITLE,tempSessionInfo3);
                DeleteTestSessions(Constants.XENON_TITLE,tempSessionInfo4);
                DeleteTestSessions(Constants.XENON_TITLE,tempSessionInfo5);
            }
        }
        [TestCase, Description("Different gamer zone:Test 31 affiliate combinations that can be in one session ")]
        class PAffDiffZoneMainLine : PositiveSocialMatchTestBase
        {
            override protected void Execute()
            {	
                // create 31 different gamer zone sessions that has different combination of affiliate values
                PNUser				primaryUser = new FriendsCommon().CreateUser(true,Constants.XENON_TITLE,XboxVersion.DEC_2004_ALPHA_XEDK,true);
                ulong				primaryUserID = primaryUser.UserId;
                XRLSessionInfo	[]	SessionInfos;
                if(CreateAffiliateBaseSessions(Constants.XENON_TITLE,primaryUser,out SessionInfos,true) == false)
                    return;
				
                // check only sessions with positive affiliate values returned and in the right order	
                long[] expectedSessionValue = new long[]{7,6,5,4,4,4,3,3,3,2,2,2,1,1,1,1,0,0,0}; //expectedNumResults = 19
                XRL2SearchResults   searchResp;
                if(socialMatchSearch(Constants.XENON_TITLE,1.0f,Constants.SESSION_MATCH_QUERY_SOCIALMATCHQUERY1,primaryUserID,expectedSessionValue,out searchResp))
                    ResultCode=TEST_RESULTS.PASSED;

                DeleteTestSessions(Constants.XENON_TITLE,SessionInfos);
            }
        }
        [TestCase, Description("Different gamer zone sessions availabe: with both good and bad sessions.")]
        class PAffDiffZoneMixedSessions : PositiveSocialMatchTestBase
        {
            override protected void Execute()
            {	
                // create 31 different gamer zone sessions that has different combination of affiliate values
                PNUser				primaryUser = new FriendsCommon().CreateUser(true,Constants.XENON_TITLE,XboxVersion.DEC_2004_ALPHA_XEDK,true);
                ulong				primaryUserID = primaryUser.UserId;
                XRLSessionInfo	[]	SessionInfos;
                if(CreateAffiliateBaseSessions(Constants.XENON_TITLE,primaryUser,out SessionInfos,true) == false)
                    return;
	
                // create 5 bad sessions on each db the title lives in:
                // non-affiliate ranked session; different game mode session; notAvailable session; imcompatible nat session; bad session
                // these sessions has int32 attribute set to 200
                uint    numDB = Constants.getNumDBForTitle(Constants.XENON_TITLE);
                uint	numBadSessions = numDB * 1;
                XRLSessionInfo[]	tempSessionInfo1 = new XRLSessionInfo[numBadSessions],tempSessionInfo2 = new XRLSessionInfo[numBadSessions],
                    tempSessionInfo3 = new XRLSessionInfo[numBadSessions],tempSessionInfo5 = new XRLSessionInfo[numBadSessions],
                    tempSessionInfo4 = new XRLSessionInfo[numBadSessions];
                CreateRankedSessions(Constants.XENON_TITLE,true,numBadSessions,out tempSessionInfo1);
                CreateDiffGameModeSessions(Constants.XENON_TITLE,true,numBadSessions,out tempSessionInfo2);
                CreateNonAvailableSessions(Constants.XENON_TITLE,true,numBadSessions,out tempSessionInfo3);
                CreateInCompNATSessions(Constants.XENON_TITLE,true,numBadSessions,out tempSessionInfo4);
                CreateBadSessions(Constants.XENON_TITLE,true,numBadSessions,out tempSessionInfo5);

                // check only sessions with positive affiliate values returned and in the right order	
                long[] expectedSessionValue = new long[]{7,6,5,4,4,4,3,3,3,2,2,2,1,1,1,1,0,0,0}; //expectedNumResults = 19
                XRL2SearchResults   searchResp;
                if(socialMatchSearch(Constants.XENON_TITLE,1.0f,Constants.SESSION_MATCH_QUERY_SOCIALMATCHQUERY1,primaryUserID,expectedSessionValue,out searchResp))
                    ResultCode=TEST_RESULTS.PASSED;

                DeleteTestSessions(Constants.XENON_TITLE,SessionInfos);
                DeleteTestSessions(Constants.XENON_TITLE,tempSessionInfo1);
                DeleteTestSessions(Constants.XENON_TITLE,tempSessionInfo2);
                DeleteTestSessions(Constants.XENON_TITLE,tempSessionInfo3);
                DeleteTestSessions(Constants.XENON_TITLE,tempSessionInfo4);
                DeleteTestSessions(Constants.XENON_TITLE,tempSessionInfo5);
            }
        }
        [TestCase, Description("both same zone and different gamer zone sessions availabe.")]
        class PAffDiffZoneMixedSessions2 : PositiveSocialMatchTestBase
        {
            override protected void Execute()
            {
                // create one positive and 1 negative affiliate same gamerZone sessions
                PNUser				primaryUser = new FriendsCommon().CreateUser(true,Constants.XENON_TITLE,XboxVersion.DEC_2004_ALPHA_XEDK,true);
                ulong				primaryUserID = primaryUser.UserId;
                XRLSessionInfo	[]	affSessionInfos = new XRLSessionInfo[2];
                uint				flags = 0;
                if(CreateSameZoneGoodSessions(Constants.XENON_TITLE,2,out affSessionInfos) == false)
                    return;
                for(int i = 0; i < affSessionInfos.Length; i++)
                {
                    if(i == 0)
                        flags = (uint)AffiliateFlags.Friend;
                    else
                        flags = (uint)AffiliateFlags.AvoidingMe;
                    CreateSingleAffiliateSession(Constants.XENON_TITLE,primaryUser,affSessionInfos[i],flags);
                }

                // create 1 non-affiliate same gamer zone session in each titledb
                uint    numDB = Constants.getNumDBForTitle(Constants.XENON_TITLE);
                uint	numSessions = numDB * 1;
                XRLSessionInfo	[]	nonAffsessionInfos;
                CreateSameZoneGoodSessions(Constants.XENON_TITLE,numSessions,out nonAffsessionInfos);

                // create 1 positive affiliate different gamer zone
                XRLSessionInfo	[]	AffDiffZoneSess;
                CreateDiffZoneGoodSessions(Constants.XENON_TITLE,numSessions,out AffDiffZoneSess);
                CreateSingleAffiliateSession(Constants.XENON_TITLE,primaryUser,AffDiffZoneSess[0],(uint)AffiliateFlags.Friend);

                // check results that different gamer zone returned last
                long[] expectedSessionValue = new long[]{4,0,4}; //expectedNumResults = 3
                XRL2SearchResults   searchResp;
                if(socialMatchSearch(Constants.XENON_TITLE,1.0f,Constants.SESSION_MATCH_QUERY_SOCIALMATCHQUERY1,primaryUserID,expectedSessionValue,out searchResp))
                {
                    long	retSessionID1 = Constants.sessionIDConvert(searchResp.results[0].SessionID);
                    long	retSessionID2=Constants.sessionIDConvert(searchResp.results[2].SessionID);
                    long	expSessionID1 = Constants.sessionIDConvert(affSessionInfos[0].SessionID);
                    long	expSessionID2=Constants.sessionIDConvert(AffDiffZoneSess[0].SessionID);
                    if((retSessionID1==expSessionID1) && (retSessionID2==expSessionID2))
                        ResultCode=TEST_RESULTS.PASSED;
                }

                DeleteTestSessions(Constants.XENON_TITLE,affSessionInfos);
                DeleteTestSessions(Constants.XENON_TITLE,nonAffsessionInfos);
                DeleteTestSessions(Constants.XENON_TITLE,AffDiffZoneSess);
            }
        }
        [TestCase, Description("NonaffiliateDifferentGameZone will be returned.")]
        class PNonAffDiffZoneMainLine : PositiveSocialMatchTestBase
        {
            override protected void Execute()
            {
                PNUser				primaryUser = new FriendsCommon().CreateUser(true,Constants.XENON_TITLE,XboxVersion.DEC_2004_ALPHA_XEDK,true);
                ulong				primaryUserID = primaryUser.UserId;
                // create one positive and 1 negative affiliate same gamerZone sessions
                XRLSessionInfo	[]	affSessionInfos = new XRLSessionInfo[2];
                uint				flags = 0;
                if(CreateSameZoneGoodSessions(Constants.XENON_TITLE,2,out affSessionInfos) == false)
                    return;
                for(int i = 0; i < affSessionInfos.Length; i++)
                {
                    if(i == 0)
                        flags = (uint)AffiliateFlags.Friend;
                    else
                        flags = (uint)AffiliateFlags.AvoidingMe;
                    CreateSingleAffiliateSession(Constants.XENON_TITLE,primaryUser,affSessionInfos[i],flags);
                }
				
                // create 1 non-affiliate same gamer zone session in each titledb
                uint    numDB = Constants.getNumDBForTitle(Constants.XENON_TITLE);
                uint	numSessions = numDB * 1;
                XRLSessionInfo	[]	nonAffSameZonesessionInfos;
                CreateSameZoneGoodSessions(Constants.XENON_TITLE,numSessions,out nonAffSameZonesessionInfos);

                // create 1 positive affiliate different gamer zone
                XRLSessionInfo	[]	AffDiffZoneSess;
                CreateDiffZoneGoodSessions(Constants.XENON_TITLE,1,out AffDiffZoneSess);
                CreateSingleAffiliateSession(Constants.XENON_TITLE,primaryUser,AffDiffZoneSess[0],(uint)AffiliateFlags.Friend);

                // create 3 non affiliate different gamer zone with different int32 attribute value
                uint	totalSessions = numDB * 3;
                XRLSessionInfo	[]	nonAffDiffZoneSess;
                CreateDiffZoneGoodSessions(Constants.XENON_TITLE,totalSessions,out nonAffDiffZoneSess);

                // check results that non affiliate different gamer zone returned last
                long[] expectedSessionValue = new long[]{4,0,4,0,0,0}; //expectedNumResults = 6
                XRL2SearchResults   searchResp;
                if(socialMatchSearch(Constants.XENON_TITLE,1.0f,Constants.SESSION_MATCH_QUERY_SOCIALMATCHQUERY1,primaryUserID,expectedSessionValue,out searchResp))
                {
                    long	retSessionID1 = Constants.sessionIDConvert(searchResp.results[0].SessionID);
                    long	retSessionID2=Constants.sessionIDConvert(searchResp.results[2].SessionID);
                    long	expSessionID1 = Constants.sessionIDConvert(affSessionInfos[0].SessionID);
                    long	expSessionID2=Constants.sessionIDConvert(AffDiffZoneSess[0].SessionID);
                    if((retSessionID1!=expSessionID1) || (retSessionID2!=expSessionID2))
                    {
                        Global.RO.Warn("The 1st  or 3rd returned session is not correct");
                        return;
                    }
                    // check the last 3 returned non affiliate different zone sessions are in the right order
                    long	intValue1 = (searchResp.results[3].Attribs[0].aValue as XRLXeIntValue).intValue;
                    long	intValue2 = (searchResp.results[4].Attribs[0].aValue as XRLXeIntValue).intValue;
                    long	intValue3 = (searchResp.results[5].Attribs[0].aValue as XRLXeIntValue).intValue;
                    if((intValue1<intValue2) && (intValue2<intValue3))
                        ResultCode=TEST_RESULTS.PASSED;
                }

                DeleteTestSessions(Constants.XENON_TITLE,affSessionInfos);
                DeleteTestSessions(Constants.XENON_TITLE,nonAffSameZonesessionInfos);
                DeleteTestSessions(Constants.XENON_TITLE,AffDiffZoneSess);
                DeleteTestSessions(Constants.XENON_TITLE,nonAffDiffZoneSess);
            }
        }
        [TestCase, Description("Non Affiliate different gamerzone: both good and bad sessions")]
        class PNonAffDiffZoneMixedSession : PositiveSocialMatchTestBase
        {
            override protected void Execute()
            {
                PNUser				primaryUser = new FriendsCommon().CreateUser(true,Constants.XENON_TITLE,XboxVersion.DEC_2004_ALPHA_XEDK,true);
                ulong				primaryUserID = primaryUser.UserId;
                // create one positive and 1 negative affiliate same gamerZone sessions
                XRLSessionInfo	[]	affSessionInfos = new XRLSessionInfo[2];
                uint				flags = 0;
                if(CreateSameZoneGoodSessions(Constants.XENON_TITLE,2,out affSessionInfos) == false)
                    return;
                for(int i = 0; i < affSessionInfos.Length; i++)
                {
                    if(i == 0)
                        flags = (uint)AffiliateFlags.Friend;
                    else
                        flags = (uint)AffiliateFlags.AvoidingMe;
                    CreateSingleAffiliateSession(Constants.XENON_TITLE,primaryUser,affSessionInfos[i],flags);
                }
				
                // create 1 non-affiliate same gamer zone session in each titledb
                uint    numDB = Constants.getNumDBForTitle(Constants.XENON_TITLE);
                uint	numSessions = numDB * 1;
                XRLSessionInfo	[]	nonAffSameZonesessionInfos;
                CreateSameZoneGoodSessions(Constants.XENON_TITLE,numSessions,out nonAffSameZonesessionInfos);

                // create 1 positive affiliate different gamer zone
                XRLSessionInfo	[]	AffDiffZoneSess;
                CreateDiffZoneGoodSessions(Constants.XENON_TITLE,1,out AffDiffZoneSess);
                CreateSingleAffiliateSession(Constants.XENON_TITLE,primaryUser,AffDiffZoneSess[0],(uint)AffiliateFlags.Friend);

                // create 3 non affiliate different gamer zone with different int32 attribute value
                uint	totalSessions = numDB * 3;
                XRLSessionInfo	[]	nonAffDiffZoneSess;
                CreateDiffZoneGoodSessions(Constants.XENON_TITLE,totalSessions,out nonAffDiffZoneSess);

                // create 5 non-affiliate different gamer zone sessions on each db the title lives in:
                // non-affiliate ranked session; different game mode session; notAvailable session; imcompatible nat session; bad session
                // these sessions has int32 attribute set to 200
                uint	numBadSessions = numDB * 1;
                XRLSessionInfo[]	tempSessionInfo1 = new XRLSessionInfo[numBadSessions],tempSessionInfo2 = new XRLSessionInfo[numBadSessions],
                    tempSessionInfo3 = new XRLSessionInfo[numBadSessions],tempSessionInfo5 = new XRLSessionInfo[numBadSessions],
                    tempSessionInfo4 = new XRLSessionInfo[numBadSessions];
                CreateRankedSessions(Constants.XENON_TITLE,true,numBadSessions,out tempSessionInfo1);
                CreateDiffGameModeSessions(Constants.XENON_TITLE,true,numBadSessions,out tempSessionInfo2);
                CreateNonAvailableSessions(Constants.XENON_TITLE,true,numBadSessions,out tempSessionInfo3);
                CreateInCompNATSessions(Constants.XENON_TITLE,true,numBadSessions,out tempSessionInfo4);
                CreateBadSessions(Constants.XENON_TITLE,true,numBadSessions,out tempSessionInfo5);

                // check results that non affiliate different gamer zone returned last
                long[] expectedSessionValue = new long[]{4,0,4,0,0,0}; //expectedNumResults = 6
                XRL2SearchResults   searchResp;
                if(socialMatchSearch(Constants.XENON_TITLE,1.0f,Constants.SESSION_MATCH_QUERY_SOCIALMATCHQUERY1,primaryUserID,expectedSessionValue,out searchResp))
                {
                    long	retSessionID1 = Constants.sessionIDConvert(searchResp.results[0].SessionID);
                    long	retSessionID2=Constants.sessionIDConvert(searchResp.results[2].SessionID);
                    long	expSessionID1 = Constants.sessionIDConvert(affSessionInfos[0].SessionID);
                    long	expSessionID2=Constants.sessionIDConvert(AffDiffZoneSess[0].SessionID);
                    if((retSessionID1!=expSessionID1) || (retSessionID2!=expSessionID2))
                    {
                        Global.RO.Warn("The 1st  or 3rd returned session is not correct");
                        return;
                    }
                    // check the last 3 returned non affiliate different zone sessions are in the right order
                    long	intValue1 = (searchResp.results[3].Attribs[0].aValue as XRLXeIntValue).intValue;
                    long	intValue2 = (searchResp.results[4].Attribs[0].aValue as XRLXeIntValue).intValue;
                    long	intValue3 = (searchResp.results[5].Attribs[0].aValue as XRLXeIntValue).intValue;
                    if((intValue1<intValue2) && (intValue2<intValue3))
                        ResultCode=TEST_RESULTS.PASSED;
                }

                DeleteTestSessions(Constants.XENON_TITLE,affSessionInfos);
                DeleteTestSessions(Constants.XENON_TITLE,nonAffSameZonesessionInfos);
                DeleteTestSessions(Constants.XENON_TITLE,AffDiffZoneSess);
                DeleteTestSessions(Constants.XENON_TITLE,nonAffDiffZoneSess);
                DeleteTestSessions(Constants.XENON_TITLE,tempSessionInfo1);
                DeleteTestSessions(Constants.XENON_TITLE,tempSessionInfo2);
                DeleteTestSessions(Constants.XENON_TITLE,tempSessionInfo3);
                DeleteTestSessions(Constants.XENON_TITLE,tempSessionInfo4);
                DeleteTestSessions(Constants.XENON_TITLE,tempSessionInfo5);
            }
        }
        [TestCase, Description("searchUser has no affiliate that is online and in the same title")]
        class PEmptyAffiliateList : PositiveSocialMatchTestBase
        {
            override protected void Execute()
            {
                PNUser				primaryUser = new FriendsCommon().CreateUser(true,Constants.XENON_TITLE,XboxVersion.DEC_2004_ALPHA_XEDK,true);
                ulong				primaryUserID = primaryUser.UserId;

                // create 2 non-affiliate sessions on each db
                uint    numDB = Constants.getNumDBForTitle(Constants.XENON_TITLE);
                uint	numSessions = numDB * 2;
                XRLSessionInfo	[]	nonAffsessionInfos = new XRLSessionInfo[numSessions];
                if(CreateSameZoneGoodSessions(Constants.XENON_TITLE,numSessions,out nonAffsessionInfos) == false)
                    return;

                // check results 2 sessions are returned.
                long[] expectedSessionValue = new long[]{0,0}; //expectedNumResults = 2
                XRL2SearchResults   searchResp;
                if(socialMatchSearch(Constants.XENON_TITLE,1.0f,Constants.SESSION_MATCH_QUERY_SOCIALMATCHQUERY1,primaryUserID,expectedSessionValue,out searchResp))
                    ResultCode=TEST_RESULTS.PASSED;

                DeleteTestSessions(Constants.XENON_TITLE,nonAffsessionInfos);
            }
        }

        [TestCase, Description("searchUser has 2100 affiliates that is online and in the same title")]
        class PMaxAffiliateList : PositiveSocialMatchTestBase
        {
            private class CreateSingleAffiliateSessionFastParams
            {
                public FriendsCommon fc;
                public uint titleID;
                public PNUser primaryUser;
                public XRLSessionInfo sessionInfo;
                public uint affiliateFlags;

                public CreateSingleAffiliateSessionFastParams(FriendsCommon fc, uint titleID, PNUser primaryUser, XRLSessionInfo sessionInfo, uint affiliateFlags)
                {
                    this.fc = fc;
                    this.titleID = titleID;
                    this.primaryUser = primaryUser;
                    this.sessionInfo = sessionInfo;
                    this.affiliateFlags = affiliateFlags;
                }
            }

            private void CreateSingleAffiliateSessionFastExecutor(ref object sessionParams)
            {
                CreateSingleAffiliateSessionFastParams p = (CreateSingleAffiliateSessionFastParams)sessionParams;
                CreateSingleAffiliateSessionFast(p.fc, p.titleID, p.primaryUser, p.sessionInfo, p.affiliateFlags);
            }

            //Friends: 100
            //Positive Feedback: 500
            //Negative Feedback: 500
            //Completed Games: 500
            //Avoiding Me: 500
            override protected void Execute()
            {
                uint originalBlockSize = FriendsCommon.UserAllocBlockSize;
                FriendsCommon.UserAllocBlockSize = 1075;
                XRLSessionInfo[]	affSessionInfos = null;
                XRLSessionInfo[]	nonAffsessionInfos = null;
                try
                {
                    FriendsCommon fc = new FriendsCommon();

                    PNUser				primaryUser = fc.CreateUser(true,Constants.XENON_TITLE,XboxVersion.DEC_2004_ALPHA_XEDK,true);
                    ulong				primaryUserID = primaryUser.UserId;

                    // create 2100 affiliates same gamerZone sessions
                    affSessionInfos = new XRLSessionInfo[2100];
                    StopWatch timer = new StopWatch();
                    timer.Start();
                    if(CreateSameZoneGoodSessions(Constants.XENON_TITLE,2100,out affSessionInfos) == false)
                    {
                        return;
                    }
                    Global.RO.Debug("PMaxAffiliateList: Call to CreateSameZoneGoodSessions took {0} secs", timer.Stop().TotalSeconds);

                    SimpleJobMgr jobMgr = new SimpleJobMgr();
                    SimpleJobMgr.ExecutorDelegate sessionExector = new SimpleJobMgr.ExecutorDelegate(CreateSingleAffiliateSessionFastExecutor);
                    timer.Start();
                    uint flags = 0;
                    for(int i = 0; i < affSessionInfos.Length; i++)
                    {
                        if(i < 500)
                            flags = (uint)AffiliateFlags.CompletedGame;
                        else if (i < 1000)
                            flags = (uint)AffiliateFlags.PositiveFeedback;
                        else if (i < 1100)
                            flags = (uint)AffiliateFlags.Friend;
                        else if ( i < 1600)
                            flags = (uint)AffiliateFlags.NegativeFeedback;
                        else
                            flags = (uint)AffiliateFlags.AvoidingMe;
                        //CreateSingleAffiliateSessionFast(fc, Constants.XENON_TITLE, primaryUser, affSessionInfos[i], flags);
                        CreateSingleAffiliateSessionFastParams sessionParams = new CreateSingleAffiliateSessionFastParams(fc, Constants.XENON_TITLE, primaryUser, affSessionInfos[i], flags);
                        jobMgr.AddJob(sessionExector, sessionParams);
                    }
                    jobMgr.StartJobs(20);
                    while (!jobMgr.Empty())
                    {
                        SimpleJobMgr.Job job = jobMgr.GetCompletedJob();
                        if (job.Exception != null)
                        {
                            Global.RO.Error("CreateSingleAffiliateSessionFast failed with exception:\r\n{0}", job.Exception);
                        }
                    }
                    Thread.Sleep(2000);
                    Global.RO.Debug("PMaxAffiliateList: Calls to CreateSingleAffiliateSession took {0} secs", timer.Stop().TotalSeconds);

                    // create 3 non-affiliate same gamer zone session in each db that the title lives in with different int32 attribute
                    uint    numDB = Constants.getNumDBForTitle(Constants.XENON_TITLE);
                    uint	numSessions = numDB * 3;
                    CreateSameZoneGoodSessions(Constants.XENON_TITLE,numSessions,out nonAffsessionInfos);

                    // check results that positive affiliate sessions are returned.
                    long[] expectedSessionValue = new long[]{4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4}; //expectedNumResults = 25
                    XRL2SearchResults   searchResp;
                    if(socialMatchSearch(Constants.XENON_TITLE,1.0f,Constants.SESSION_MATCH_QUERY_SOCIALMATCHQUERY1,primaryUserID,expectedSessionValue,out searchResp))
                        ResultCode=TEST_RESULTS.PASSED;
                }
                finally
                {
                    FriendsCommon.UserAllocBlockSize = originalBlockSize;
                    DeleteTestSessions(Constants.XENON_TITLE,nonAffsessionInfos);
                    DeleteTestSessions(Constants.XENON_TITLE,affSessionInfos);
                }
            }
        }

        // create maxResults (25) InZone nonAffiliate sessions:
        // 1. within the same rating range and 
        // 2. both country and language are the same
        // create 26th InZone nonAffiliate session with only country is the same
        // check 26th session is not being returned.
        [TestCase, Description("")]
        class PInZoneNonAffSameCountrySameLang : PositiveSocialMatchTestBase
        {
            override protected void Execute()
            {
                XRLSessionInfo	[]	goodSessionInfos;
                // country and lang is XENON_TEST_DEFAULT_GAMER_LANG, XENON_TEST_DEFAULT_GAMER_COUNTRY
                if(!CreateSameZoneGoodSessions(Constants.XENON_TITLE2,25,out goodSessionInfos))
                    return;
                // create 26th session with only country is the same
                XRLXeAttribParam	[]		Attribs = new XRLXeAttribParam[10];
                Attribs[0] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_TYPE,new XRLXeIntValue(Constants.X_ATTRIBUTE_GAME_TYPE_STANDARD));
                Attribs[1] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE, new XRLXeIntValue(Constants.CONTEXT_GAME_MODE_MODEA));
                Attribs[2] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_ZONE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_ZONE));
                Attribs[3] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_COUNTRY, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_COUNTRY));
                Attribs[4] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_LANGUAGE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_LANG+1));
                Attribs[5] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_RATING, new XRLXeFloatValue(Constants.XENON_TEST_DEFAULT_GAMER_RATING));
                Attribs[6] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_MU,new XRLXeDoubleValue(Constants.XENON_TEST_DEFAULT_GAMER_MU));
                Attribs[7] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_SIGMA, new XRLXeDoubleValue(Constants.XENON_TEST_DEFAULT_GAMER_SIGMA));
                Attribs[8] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_HOST_NAME, new XRLXeStringValue("newmom\0"));
                Attribs[9] = new XRLXeAttribParam(Constants.PROPERTY_MYFLOAT32PROP1_XENON_TITLE2,new XRLXeFloatValue(0.1f));
                XRL2CreateUpdateSession		badCreate = new XRL2CreateUpdateSession(Attribs);
                badCreate.baseCreateUpdate.baseSession.dwTitleID = Constants.XENON_TITLE2;
                XRLSessionInfo				badSessionInfo;
                if(!badCreate.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out badSessionInfo))
                    return;
                // do a search
                XRLXeAttribParam	[]		searchParams = new XRLXeAttribParam[10];
                searchParams[0] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_TYPE,new XRLXeIntValue(Constants.X_ATTRIBUTE_GAME_TYPE_STANDARD));
                searchParams[1] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE, new XRLXeIntValue(Constants.CONTEXT_GAME_MODE_MODEA));
                searchParams[2] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_ZONE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_ZONE));
                searchParams[3] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_COUNTRY, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_COUNTRY));
                searchParams[4] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_LANGUAGE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_LANG));
                searchParams[5] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_RATING, new XRLXeFloatValue(Constants.XENON_TEST_DEFAULT_GAMER_RATING));
                searchParams[6] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_MU,new XRLXeDoubleValue(Constants.XENON_TEST_DEFAULT_GAMER_MU));
                searchParams[7] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_SIGMA, new XRLXeDoubleValue(Constants.XENON_TEST_DEFAULT_GAMER_SIGMA));
                searchParams[8] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_PUID, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_PUID));
                searchParams[9] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_HOST_NAME, new XRLXeStringValue("newmom\0"));
                XRL2SearchResults	searchResp;
                XRL2SearchSession	searchReq = new XRL2SearchSession(searchParams,Constants.SESSION_MATCH_QUERY_SOCIALMATCHQUERYFORTITLEONSINGLEDB);
                searchReq.baseSearchSession.dwTitleID = Constants.XENON_TITLE2;
                if(searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out searchResp))
                {	// check search results
                    if(CheckNumResults(searchResp, 25))
                    {
                        long	resultSessionID = 0, badSessionID = Constants.sessionIDConvert(badSessionInfo.SessionID);
                        for(int i = 0; i < 25; i++)
                        {
                            resultSessionID = Constants.sessionIDConvert(searchResp.results[i].SessionID);
                            if(resultSessionID == badSessionID)
                            {
                                Global.RO.Warn("The session with different lang is being returned");
                                goto delete;
                            }
                        }
                        ResultCode=TEST_RESULTS.PASSED;
                    }
                }
		delete:	DeleteTestSessions(Constants.XENON_TITLE2,goodSessionInfos);
                new XRL2DeleteSession(badSessionInfo.SessionID,Constants.XENON_TITLE2).Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
            }
        }
        // we will use a test title that lives on one db for this test case
        [TestCase, Description("Enough sessions available that ratings/country/lang will be used in sort:0.390625 rating range")]
        class PSameZoneDiffRatings1 : PositiveSocialMatchTestBase
        {
            override protected void Execute()
            {
                float	searchUserRating = 50.0f, ratingRange = 0.390625f;
                bool	diffZone = false;
                if(VerifyRatings(diffZone,ratingRange,searchUserRating))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("Bug 29986:Enough sessions available that ratings/country/lang will be used in sort:1.5625f rating range")]
        class PSameZoneDiffRatings2 : PositiveSocialMatchTestBase
        {
            override protected void Execute()
            {
                float	searchUserRating = 50.0f, ratingRange = 1.5625f;
                bool	diffZone = false;
                if(VerifyRatings(diffZone,ratingRange,searchUserRating))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("Enough sessions available that ratings/country/lang will be used in sort:6.25 rating range")]
        class PSameZoneDiffRatings3 : PositiveSocialMatchTestBase
        {
            override protected void Execute()
            {
                float	searchUserRating = 50.0f, ratingRange = 6.25f;
                bool	diffZone = false;
                if(VerifyRatings(diffZone,ratingRange,searchUserRating))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("Enough sessions available that ratings/country/lang will be used in sort:25.0 rating range")]
        class PSameZoneDiffRatings4 : PositiveSocialMatchTestBase
        {
            override protected void Execute()
            {
                float	searchUserRating = 50.0f, ratingRange = 25.0f;
                bool	diffZone = false;
                if(VerifyRatings(diffZone,ratingRange,searchUserRating))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        class PSameZoneDiffRatings5 : PositiveSocialMatchTestBase
        {
            override protected void Execute()
            {
                float	searchUserRating = 0.0f, ratingRange = 0.390625f;
                bool	diffZone = false;
                if(VerifyRatings(diffZone,ratingRange,searchUserRating))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("searchUser rating is 100, range is 10")]
        class PSameZoneDiffRatings6 : PositiveSocialMatchTestBase
        {
            override protected void Execute()
            {
                float	searchUserRating = 100.0f, ratingRange = 10.0f;
                bool	diffZone = false;
                if(VerifyRatings(diffZone,ratingRange,searchUserRating))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("Enough sessions available that ratings/country/lang will be used in sort:0.390625 rating range")]
        class PDiffZoneDiffRatings1 : PositiveSocialMatchTestBase
        {
            override protected void Execute()
            {
                float	searchUserRating = 50.0f, ratingRange = 0.390625f;
                bool	diffZone = true;
                if(VerifyRatings(diffZone,ratingRange,searchUserRating))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("Enough sessions available that ratings/country/lang will be used in sort:1.5625 rating range")]
        class PDiffZoneDiffRatings2 : PositiveSocialMatchTestBase
        {
            override protected void Execute()
            {
                float	searchUserRating = 50.0f, ratingRange = 1.5625f;
                bool	diffZone = true;
                if(VerifyRatings(diffZone,ratingRange,searchUserRating))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("Enough sessions available that ratings/country/lang will be used in sort:6.25 rating range")]
        class PDiffZoneDiffRatings3 : PositiveSocialMatchTestBase
        {
            override protected void Execute()
            {
                float	searchUserRating = 50.0f, ratingRange = 6.25f;
                bool	diffZone = true;
                if(VerifyRatings(diffZone,ratingRange,searchUserRating))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("Enough sessions available that ratings/country/lang will be used in sort:25 rating range")]
        class PDiffZoneDiffRatings4 : PositiveSocialMatchTestBase
        {
            override protected void Execute()
            {
                float	searchUserRating = 50.0f, ratingRange = 25.0f;
                bool	diffZone = true;
                if(VerifyRatings(diffZone,ratingRange,searchUserRating))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        class PDiffZoneDiffRatings5 : PositiveSocialMatchTestBase
        {
            override protected void Execute()
            {
                float	searchUserRating = 0.0f, ratingRange = 0.390625f;
                bool	diffZone = true;
                if(VerifyRatings(diffZone,ratingRange,searchUserRating))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("searchUser rating is 100, range is 25")]
        class PDiffZoneDiffRatings6 : PositiveSocialMatchTestBase
        {
            override protected void Execute()
            {
                float	searchUserRating = 100.0f, ratingRange = 25.0f;
                bool	diffZone = true;
                if(VerifyRatings(diffZone,ratingRange,searchUserRating))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }			
        [TestCase, Description("send a match request with missing all default parameters")]
        class PMatchMissingParams : TestBase
        {
            override protected void Execute()
            {
                XRL2SearchSession   searchReq = new XRL2SearchSession(false,Constants.SESSION_MATCH_QUERY_NOPARAMQUERY);
                XRLXeAttribParam	[] searchParams = new XRLXeAttribParam[2];
                searchParams[0] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_TYPE, new XRLXeIntValue(Constants.X_ATTRIBUTE_GAME_TYPE_STANDARD));
                searchParams[1] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE, new XRLXeIntValue(Constants.CONTEXT_GAME_MODE_MODEA));
                searchReq.AddParams(searchParams);

                XRL2SearchResults	searchResp;
                if(searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out searchResp))
                    ResultCode=TEST_RESULTS.PASSED;	
            }
        }
        [TestCase, Description("Create 1001 sessions with the same ranking")]
        class PLotsSessions : PositiveSocialMatchTestBase
        {
            override protected void Execute()
            {	
                XRLXeAttribParam	[]		Attribs = new XRLXeAttribParam[10];
                Attribs[0] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_TYPE,new XRLXeIntValue(Constants.X_ATTRIBUTE_GAME_TYPE_STANDARD));
                Attribs[1] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE, new XRLXeIntValue(Constants.CONTEXT_GAME_MODE_MODEA));
                Attribs[2] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_ZONE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_ZONE));
                Attribs[3] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_COUNTRY, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_COUNTRY));
                Attribs[4] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_LANGUAGE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_LANG));
                Attribs[5] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_RATING, new XRLXeFloatValue(Constants.XENON_TEST_DEFAULT_GAMER_RATING));
                Attribs[6] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_MU,new XRLXeDoubleValue(Constants.XENON_TEST_DEFAULT_GAMER_MU));
                Attribs[7] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_SIGMA, new XRLXeDoubleValue(Constants.XENON_TEST_DEFAULT_GAMER_SIGMA));
                Attribs[8] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_HOST_NAME, new XRLXeStringValue("newmom\0"));
                Attribs[9] = new XRLXeAttribParam(Constants.PROPERTY_MYINT32PROP1, new XRLXeIntValue(88));
				
                // create 1000 sessions
                XRL2CreateUpdateSession	[]	OtherCreateReqs = new XRL2CreateUpdateSession[1000];
                XRLSessionInfo			[]	OtherSessionInfo = new XRLSessionInfo[1000];
                for(int i = 0; i < 1000; i++)
                {
                    OtherCreateReqs[i] = new XRL2CreateUpdateSession(Attribs);
                    OtherCreateReqs[i].baseCreateUpdate.baseSession.dwTitleID = Constants.XENON_TITLE2;
                    if(!OtherCreateReqs[i].Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out OtherSessionInfo[i]))
                    {
                        Global.RO.Warn("OtherCreateReqs failed");
                        return;
                    }
                }

                // do a social search
                XRL2SearchSession	searchReq = new XRL2SearchSession(true,Constants.SESSION_MATCH_QUERY_RANKEDMATCHQUERYFORTITLEONSINGLEDB);
                searchReq.searchParams[0] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_TYPE,new XRLXeIntValue(Constants.X_ATTRIBUTE_GAME_TYPE_STANDARD));
                searchReq.baseSearchSession.dwTitleID = Constants.XENON_TITLE2;
                XRL2SearchResults	searchResp;
                if(searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out searchResp))
                {   
                    if(CheckNumResults(searchResp, 25))
                    {
                        ResultCode=TEST_RESULTS.PASSED;	                        
                    }
                }
                for(int i = 0; i < 1000; i++)
                    new XRL2DeleteSession(OtherSessionInfo[i].SessionID,Constants.XENON_TITLE2).Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
            }
        }

        [TestCase, Description("check country and language are used to sort returned sessions")]
        class PLessSessionsCountryLang : PositiveSocialMatchTestBase
        {
            override protected void Execute()
            {	
                XRLXeAttribParam	[]		Attribs = new XRLXeAttribParam[10];
                Attribs[0] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_TYPE,new XRLXeIntValue(Constants.X_ATTRIBUTE_GAME_TYPE_STANDARD));
                Attribs[1] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE, new XRLXeIntValue(Constants.CONTEXT_GAME_MODE_MODEA));
                Attribs[2] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_ZONE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_ZONE));
                Attribs[3] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_COUNTRY, new XRLXeIntValue(888));
                Attribs[4] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_LANGUAGE,new XRLXeIntValue(666));
                Attribs[5] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_RATING, new XRLXeFloatValue(Constants.XENON_TEST_DEFAULT_GAMER_RATING));
                Attribs[6] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_MU,new XRLXeDoubleValue(Constants.XENON_TEST_DEFAULT_GAMER_MU));
                Attribs[7] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_SIGMA, new XRLXeDoubleValue(Constants.XENON_TEST_DEFAULT_GAMER_SIGMA));
                Attribs[8] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_HOST_NAME, new XRLXeStringValue("newmom\0"));
                Attribs[9] = new XRLXeAttribParam(Constants.PROPERTY_MYINT32PROP1, new XRLXeIntValue(88));
				
                // create 1 session with both the same country and lang as search user
                Attribs[3] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_COUNTRY, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_COUNTRY));
                Attribs[4] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_LANGUAGE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_LANG));
                XRL2CreateUpdateSession	sameCountryLang = new XRL2CreateUpdateSession(Attribs);
                sameCountryLang.baseCreateUpdate.baseSession.dwTitleID = Constants.XENON_TITLE2;
                XRLSessionInfo			sameCountryLangInfo = new XRLSessionInfo();
                if(!sameCountryLang.Execute(Global.XEnv.GetInterface(Interface.xmatchfd)[0], out sameCountryLangInfo))
                {
                    Global.RO.Warn("sameCountryLang failed");
                    return;
                }	
                // create 1 session with the same lang as search user
                Attribs[3] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_COUNTRY, new XRLXeIntValue(888));
                Attribs[4] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_LANGUAGE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_LANG));
                XRL2CreateUpdateSession	sameLang = new XRL2CreateUpdateSession(Attribs);
                sameLang.baseCreateUpdate.baseSession.dwTitleID = Constants.XENON_TITLE2;
                XRLSessionInfo			sameLangInfo = new XRLSessionInfo();
                if(!sameLang.Execute(Global.XEnv.GetInterface(Interface.xmatchfd)[0], out sameLangInfo))
                {
                    Global.RO.Warn("sameCountry failed");
                    return;
                }
                // create 1 session with the same country as search user
                Attribs[3] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_COUNTRY, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_COUNTRY));
                Attribs[4] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_LANGUAGE,new XRLXeIntValue(666));
                XRL2CreateUpdateSession	sameCountry = new XRL2CreateUpdateSession(Attribs);
                sameCountry.baseCreateUpdate.baseSession.dwTitleID = Constants.XENON_TITLE2;
                XRLSessionInfo			sameCountryInfo = new XRLSessionInfo();
                if(!sameCountry.Execute(Global.XEnv.GetInterface(Interface.xmatchfd)[0], out sameCountryInfo))
                {
                    Global.RO.Warn("sameCountry failed");
                    return;
                }
                // create 1 session with neither the same lang nor country as search user
                Attribs[3] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_COUNTRY, new XRLXeIntValue(888));
                Attribs[4] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_LANGUAGE,new XRLXeIntValue(666));
                XRL2CreateUpdateSession	diffCountryLang = new XRL2CreateUpdateSession(Attribs);
                diffCountryLang.baseCreateUpdate.baseSession.dwTitleID = Constants.XENON_TITLE2;
                XRLSessionInfo			diffCountryLangInfo = new XRLSessionInfo();
                if(!diffCountryLang.Execute(Global.XEnv.GetInterface(Interface.xmatchfd)[0], out diffCountryLangInfo))
                {
                    Global.RO.Warn("diffCountryLang failed");
                    return;
                }

                // do a social search with searcher's XENON_TEST_DEFAULT_GAMER_LANG and XENON_TEST_DEFAULT_GAMER_COUNTRY
                XRL2SearchSession	searchReq = new XRL2SearchSession(true,Constants.SESSION_MATCH_QUERY_RANKEDMATCHQUERYFORTITLEONSINGLEDB);
                searchReq.searchParams[0] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_TYPE,new XRLXeIntValue(Constants.X_ATTRIBUTE_GAME_TYPE_STANDARD));
                searchReq.baseSearchSession.dwTitleID = Constants.XENON_TITLE2;
                XRL2SearchResults	searchResp;
                if(searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out searchResp))
                {	
                    if(CheckNumResults(searchResp, 4))
                    {
                    // check the returned session order
                        if((Constants.sessionIDConvert(searchResp.results[0].SessionID) == Constants.sessionIDConvert(sameCountryLangInfo.SessionID))
                           && (Constants.sessionIDConvert(searchResp.results[1].SessionID) == Constants.sessionIDConvert(sameLangInfo.SessionID))
                           && (Constants.sessionIDConvert(searchResp.results[2].SessionID) == Constants.sessionIDConvert(sameCountryInfo.SessionID))
                           && (Constants.sessionIDConvert(searchResp.results[3].SessionID) == Constants.sessionIDConvert(diffCountryLangInfo.SessionID)))
                            ResultCode=TEST_RESULTS.PASSED;	
                        else
                            Global.RO.Warn("returned session order is not correct");
                    }
                }
                new XRL2DeleteSession(sameCountryLangInfo.SessionID,Constants.XENON_TITLE2).Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                new XRL2DeleteSession(sameLangInfo.SessionID,Constants.XENON_TITLE2).Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                new XRL2DeleteSession(sameCountryInfo.SessionID,Constants.XENON_TITLE2).Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                new XRL2DeleteSession(diffCountryLangInfo.SessionID,Constants.XENON_TITLE2).Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
            }
        }

        [TestCase, Description("Ensure XBox360 users who have managed not to select a zone(via migration) appear as if they were in their own (little) gamerzone...")]
        class PNoGamerZoneSearch : PositiveSocialMatchTestBase {

            public XRLXeAttribParam [] GenerateZoneAttrib (int zone) {
                XRLXeAttribParam	[] attribs = new XRLXeAttribParam[1];
                attribs[0] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_ZONE,
                                                  new XRLXeIntValue(zone));  //the one differentiator...
                return attribs;
            }

            public XRLXeAttribParam [] GenerateAttribSetForZone(int zone) {
                XRLXeAttribParam	[] attribs = new XRLXeAttribParam[9];
                attribs[0] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_TYPE,
                                                  new XRLXeIntValue(Constants.X_ATTRIBUTE_GAME_TYPE_STANDARD));
                attribs[1] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE, 
                                                  new XRLXeIntValue(Constants.CONTEXT_GAME_MODE_MODEA));
                attribs[2] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_ZONE,
                                                  new XRLXeIntValue(zone));  //the one differentiator...
                attribs[3] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_COUNTRY, 
                                                  new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_COUNTRY));
                attribs[4] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_LANGUAGE,
                                                  new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_LANG));
                attribs[5] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_RATING, 
                                                  new XRLXeFloatValue(Constants.XENON_TEST_DEFAULT_GAMER_RATING));
                attribs[6] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_MU,
                                                  new XRLXeDoubleValue(Constants.XENON_TEST_DEFAULT_GAMER_MU));
                attribs[7] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_SIGMA, 
                                                  new XRLXeDoubleValue(Constants.XENON_TEST_DEFAULT_GAMER_SIGMA));
                attribs[8] = new XRLXeAttribParam(Constants.PROPERTY_MYFLOAT32PROP1, 
                                                  new XRLXeFloatValue((float)0.100000));
                return attribs;
            }

            public XRL2SearchResults SearchForSessionByZone(int zone) {
                XRLXeAttribParam[]		searchParams = new XRLXeAttribParam[8];
                searchParams[0] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_TYPE,
                                                       new XRLXeIntValue(Constants.X_ATTRIBUTE_GAME_TYPE_STANDARD));
                searchParams[1] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE, 
                                                       new XRLXeIntValue(Constants.CONTEXT_GAME_MODE_MODEA));
                searchParams[2] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_ZONE,
                                                       new XRLXeIntValue(zone)); //our one variable
                searchParams[3] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_COUNTRY, 
                                                       new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_COUNTRY));
                searchParams[4] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_LANGUAGE,
                                                       new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_LANG));
                searchParams[5] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_RATING, 
                                                       new XRLXeFloatValue(Constants.XENON_TEST_DEFAULT_GAMER_RATING));
                searchParams[6] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_MU,
                                                       new XRLXeDoubleValue(Constants.XENON_TEST_DEFAULT_GAMER_MU));
                searchParams[7] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_SIGMA, 
                                                       new XRLXeDoubleValue(Constants.XENON_TEST_DEFAULT_GAMER_SIGMA));
                XRL2SearchSession	searchReq = new XRL2SearchSession(searchParams,Constants.SESSION_MATCH_QUERY_SOCIALMATCHQUERY1);
                searchReq.baseSearchSession.dwTitleID = Constants.XENON_TITLE;
                    
                XRL2SearchResults    Resp;
                if(searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out Resp)) {
                    return Resp;
                } else {
                    throw new Exception("Search query failed!");
                }
            }

            public bool IsInArrayList(long num, ArrayList list) {
                foreach(long listNum in list) {
                    if (num == listNum) return true;
                }
                return false;
            }


            override protected void Execute() {
                int NUM_EXTRA_SESSIONS = 50;
                uint titleID = Constants.XENON_TITLE;

                XRLSessionInfo noZoneSession = new XRLSessionInfo();  //just one of these
                XRLSessionInfo[] extraSessions = new XRLSessionInfo[NUM_EXTRA_SESSIONS];

                const int NO_GAMER_ZONE = 0;
                XRLXeAttribParam	[] noZoneAttribs = GenerateAttribSetForZone(NO_GAMER_ZONE);
                XRL2CreateUpdateSession createReq = new XRL2CreateUpdateSession(noZoneAttribs);  //just one pointer

                createReq.baseCreateUpdate.baseSession.dwTitleID = titleID;
                if(!(createReq.Execute(Global.XEnv.GetInterface(Interface.xmatchfd)[0], out noZoneSession)))
                    throw new Exception("Error creating session of type " + NO_GAMER_ZONE);

                for (int i=0; i<NUM_EXTRA_SESSIONS; i++) {
                    XRLXeAttribParam [] tempAttribs = GenerateAttribSetForZone(((i % 4) + 1)); //cycle
                    //through all
                    //other zones
                    createReq.baseCreateUpdate.baseSession.dwTitleID = titleID;
                    createReq = new XRL2CreateUpdateSession(tempAttribs);
                    if(!(createReq.Execute(Global.XEnv.GetInterface(Interface.xmatchfd)[0], out extraSessions[i] )))
                        throw new Exception("Error creating extra session!");
                }
                //search for the session...

                // search so that 1 session will be returned
                XRL2SearchResults resp = SearchForSessionByZone(NO_GAMER_ZONE);

                // check searchResults
                Global.RO.Info("Results returned == " + resp.resultsLen);
                Global.RO.Info("Checking first result...");
                Global.RO.Info("this result's sessionID is... " + Constants.sessionIDConvert(resp.results[0].SessionID));
                if ((Constants.sessionIDConvert(resp.results[0].SessionID) == 
                     Constants.sessionIDConvert(noZoneSession.SessionID))) {
                    Global.RO.Success("This is the session exepected.");
                    ResultCode=TEST_RESULTS.PASSED;
                } else {
                    Global.RO.Error("This isn't the expected session!");
                    Global.RO.Error("Expected" + Constants.sessionIDConvert(noZoneSession.SessionID));
                }

//////Now let's add a hundred more zone 0s.  We're going to make sure it's not in this set of created
//////sessions.
                const int NUM_EXTRA_ZERO_SESSIONS = 100;
                XRLSessionInfo [] otherNoZoneSessions = new XRLSessionInfo[NUM_EXTRA_ZERO_SESSIONS];
                for (int i=0; i<NUM_EXTRA_ZERO_SESSIONS; i++) {
                    XRLXeAttribParam [] tempAttribs = GenerateAttribSetForZone(NO_GAMER_ZONE);
                    createReq.baseCreateUpdate.baseSession.dwTitleID = titleID;
                    createReq = new XRL2CreateUpdateSession(tempAttribs);
                    if(!(createReq.Execute(Global.XEnv.GetInterface(Interface.xmatchfd)[0], out otherNoZoneSessions[i] )))
                        throw new Exception("Error creating extra session!");
                }

                ArrayList sessionIDs = new ArrayList();
                for(int i=0; i<100; i++) {
                    sessionIDs.Add(Constants.sessionIDConvert(otherNoZoneSessions[i].SessionID));
                }
                sessionIDs.Add(Constants.sessionIDConvert(noZoneSession.SessionID)); //don't
                //forget
                //the first one.
//////search for these with the zones 1-4.  They shouldn't be in the first ten sessions.(at least 10
//////in the right zone)
                for (int i=1; i<5; i++) {
                    resp = SearchForSessionByZone(i);
                    Global.RO.Info("Results returned == " + resp.resultsLen);
                    for (int j=0; j<10; j++) { //for the first ten results...
                        //
                        if (IsInArrayList(Constants.sessionIDConvert(resp.results[j].SessionID),
                                          sessionIDs)) {
                            Global.RO.Error("We found a zero session in the top ten!  It was place #" + j);
                            Global.RO.Error("It had sessionID " + Constants.sessionIDConvert(resp.results[j].SessionID));
                        }
                    }
                }

                foreach (long session in sessionIDs) {
                    MatchUtil.DeleteSession(Constants.sessionIDConvert(session),titleID);
                }
                    
                Global.RO.Success("If we got out here and found no errors, we're good");
            }
        }

        /*******************************************************************************************
         * Negative Test Case
         *******************************************************************************************/
        [TestCase, Description("searchUser rating is -0.0001, range is 0.016")]
        class NSearchUserBadRating1 : PositiveSocialMatchTestBase
        {
            override protected void Execute()
            {
                // results should be the same as searchUserRating is 0.0f
                float	searchUserRating = -0.0001f, ratingRange = 0.016f;
                bool	diffZone = true;	
                if(VerifyRatings(diffZone,ratingRange,searchUserRating))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("searchUser rating is 100.0001, range is 10")]
        class NSearchUserBadRating2 : PositiveSocialMatchTestBase
        {
            override protected void Execute()
            {
                // results should be the same as searchUserRating is 100.0f
                float	searchUserRating = 100.0001f, ratingRange = 10.0f;
                bool	diffZone = true;
                if(VerifyRatings(diffZone,ratingRange,searchUserRating))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }

        [TestCase, Description("do not pass gameMode in search request")]
        class NSearchUserNoGameMode : TestBase
        {
            override protected void Execute()
            {
                // create a session with gameMode set to 1
                XRL2CreateUpdateSession		createReq;
                XRLXeAttribParam	[]		Attribs = new XRLXeAttribParam[9];
                Attribs[0] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_TYPE,new XRLXeIntValue(Constants.X_ATTRIBUTE_GAME_TYPE_STANDARD));
                Attribs[1] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE, new XRLXeIntValue(Constants.CONTEXT_GAME_MODE_MODEA));
                Attribs[2] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_ZONE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_ZONE));
                Attribs[3] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_COUNTRY, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_COUNTRY));
                Attribs[4] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_LANGUAGE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_LANG));
                Attribs[5] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_RATING, new XRLXeFloatValue(Constants.XENON_TEST_DEFAULT_GAMER_RATING));
                Attribs[6] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_MU,new XRLXeDoubleValue(Constants.XENON_TEST_DEFAULT_GAMER_MU));
                Attribs[7] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_SIGMA, new XRLXeDoubleValue(Constants.XENON_TEST_DEFAULT_GAMER_SIGMA));
                Attribs[8] = new XRLXeAttribParam(Constants.PROPERTY_MYFLOAT32PROP1_XENON_TITLE2, new XRLXeFloatValue(0.1f));
				
                createReq = new XRL2CreateUpdateSession(Attribs);
                createReq.baseCreateUpdate.baseSession.dwTitleID = Constants.XENON_TITLE2;
                XRLSessionInfo	createResp;
                if(createReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out createResp))
                {

                    XRLXeAttribParam	[]		searchParams = new XRLXeAttribParam[8];
                    searchParams[0] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_TYPE,new XRLXeIntValue(Constants.X_ATTRIBUTE_GAME_TYPE_STANDARD));
                    searchParams[2] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_ZONE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_ZONE));
                    searchParams[3] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_COUNTRY, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_COUNTRY));
                    searchParams[4] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_LANGUAGE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_LANG));
                    searchParams[5] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_RATING, new XRLXeFloatValue(Constants.XENON_TEST_DEFAULT_GAMER_RATING));
                    searchParams[6] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_MU,new XRLXeDoubleValue(Constants.XENON_TEST_DEFAULT_GAMER_MU));
                    searchParams[7] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_SIGMA, new XRLXeDoubleValue(Constants.XENON_TEST_DEFAULT_GAMER_SIGMA));
                    searchParams[1] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_PUID, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_PUID));

                    XRL2SearchSession	searchReq = new XRL2SearchSession(searchParams,Constants.SESSION_MATCH_QUERY_SOCIALMATCHQUERYFORTITLEONSINGLEDB);
                    searchReq.baseSearchSession.dwTitleID = Constants.XENON_TITLE2;
                    XRL2SearchResults	searchResp;
                    if(!searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out searchResp))
                    {
                        //Change 158444 made it so that this missing value is replaced with an known
                        //bad value, which changed the error from XONLINE_E_MATCH_PARAM_MISSING to 
                        if (searchReq.XErr == HResult.XONLINE_E_MATCH_INVALID_PARAM)
                            ResultCode=TEST_RESULTS.PASSED;
                        else Global.RO.Error("Received Xerr " + Global.XErrToString(searchReq.XErr) + 
                                             " but expected " + Global.XErrToString(HResult.XONLINE_E_MATCH_PARAM_MISSING));
                    }
                    new XRL2DeleteSession(createResp.SessionID,Constants.XENON_TITLE2).Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                }
            }
        }

        [TestCase, Description("do not pass game type in search request")]
        class NSearchUserNoGameType : TestBase
        {
            override protected void Execute()
            {
                // create a session with gameType set to 1
                XRL2CreateUpdateSession		createReq;
                XRLXeAttribParam	[]		Attribs = new XRLXeAttribParam[9];
                Attribs[0] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_TYPE,new XRLXeIntValue(Constants.X_ATTRIBUTE_GAME_TYPE_STANDARD));
                Attribs[1] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE, new XRLXeIntValue(Constants.CONTEXT_GAME_MODE_MODEA));
                Attribs[2] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_ZONE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_ZONE));
                Attribs[3] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_COUNTRY, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_COUNTRY));
                Attribs[4] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_LANGUAGE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_LANG));
                Attribs[5] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_RATING, new XRLXeFloatValue(Constants.XENON_TEST_DEFAULT_GAMER_RATING));
                Attribs[6] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_MU,new XRLXeDoubleValue(Constants.XENON_TEST_DEFAULT_GAMER_MU));
                Attribs[7] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_SIGMA, new XRLXeDoubleValue(Constants.XENON_TEST_DEFAULT_GAMER_SIGMA));
                Attribs[8] = new XRLXeAttribParam(Constants.PROPERTY_MYFLOAT32PROP1_XENON_TITLE2, new XRLXeFloatValue(0.1f));

                createReq = new XRL2CreateUpdateSession(Attribs);
                createReq.baseCreateUpdate.baseSession.dwTitleID = Constants.XENON_TITLE2;
                XRLSessionInfo	createResp;
                if(createReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out createResp))
                {
                    XRLXeAttribParam	[]		searchParams = new XRLXeAttribParam[8];
                    searchParams[0] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE,new XRLXeIntValue(Constants.CONTEXT_GAME_MODE_MODEA));
                    searchParams[2] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_ZONE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_ZONE));
                    searchParams[3] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_COUNTRY, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_COUNTRY));
                    searchParams[4] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_LANGUAGE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_LANG));
                    searchParams[5] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_RATING, new XRLXeFloatValue(Constants.XENON_TEST_DEFAULT_GAMER_RATING));
                    searchParams[6] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_MU,new XRLXeDoubleValue(Constants.XENON_TEST_DEFAULT_GAMER_MU));
                    searchParams[7] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_SIGMA, new XRLXeDoubleValue(Constants.XENON_TEST_DEFAULT_GAMER_SIGMA));
                    searchParams[1] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_PUID, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_PUID));

                    XRL2SearchSession	searchReq = new XRL2SearchSession(searchParams,Constants.SESSION_MATCH_QUERY_SOCIALMATCHQUERYFORTITLEONSINGLEDB);
                    searchReq.baseSearchSession.dwTitleID = Constants.XENON_TITLE2;
                    XRL2SearchResults	searchResp;
                    if(!searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out searchResp))
                    {
                        //Change 158444 made it so that this missing value is replaced with an known
                        //bad value, which changed the error from XONLINE_E_MATCH_PARAM_MISSING to 
                        if (searchReq.XErr == HResult.XONLINE_E_MATCH_INVALID_PARAM)
                            ResultCode = TEST_RESULTS.PASSED;
                        else Global.RO.Error("Received Xerr " + Global.XErrToString(searchReq.XErr) + 
                                             " but expected " + Global.XErrToString(HResult.XONLINE_E_MATCH_PARAM_MISSING));
                    }
                    new XRL2DeleteSession(createResp.SessionID,Constants.XENON_TITLE2).Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                }			
            }
        }
        [TestCase, Description("Bug 29993:do not pass game zone in search request")]
        class NSearchUserNoGamerZone : NegativeSocialRankedMatchTestBase
        {
            override protected void Execute()
            {
                // create a session with gamerZone set to 1;another one with gamerZone set to 0.
                XRL2CreateUpdateSession		createReq1,createReq2;
                XRLXeAttribParam	[]		Attribs = new XRLXeAttribParam[9];
                Attribs[0] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_TYPE,new XRLXeIntValue(Constants.X_ATTRIBUTE_GAME_TYPE_STANDARD));
                Attribs[1] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE, new XRLXeIntValue(Constants.CONTEXT_GAME_MODE_MODEA));
                Attribs[2] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_ZONE,new XRLXeIntValue(0));
                Attribs[3] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_COUNTRY, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_COUNTRY));
                Attribs[4] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_LANGUAGE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_LANG));
                Attribs[5] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_RATING, new XRLXeFloatValue(Constants.XENON_TEST_DEFAULT_GAMER_RATING));
                Attribs[6] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_MU,new XRLXeDoubleValue(Constants.XENON_TEST_DEFAULT_GAMER_MU));
                Attribs[7] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_SIGMA, new XRLXeDoubleValue(Constants.XENON_TEST_DEFAULT_GAMER_SIGMA));
                Attribs[8] = new XRLXeAttribParam(Constants.PROPERTY_MYFLOAT32PROP1_XENON_TITLE2, new XRLXeFloatValue(0.1f));

                createReq1 = new XRL2CreateUpdateSession(Attribs);
                createReq1.baseCreateUpdate.baseSession.dwTitleID = Constants.XENON_TITLE2;
                XRLSessionInfo	createResp1,createResp2;
                if(createReq1.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out createResp1))
                {
                    // create 2nd session with gamerzone set to 0
                    Attribs[2] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_ZONE,new XRLXeIntValue(1));
                    createReq2 = new XRL2CreateUpdateSession(Attribs);
                    createReq2.baseCreateUpdate.baseSession.dwTitleID = Constants.XENON_TITLE2;
                    if(createReq2.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out createResp2))
                    {
					
                        XRLXeAttribParam	[]		searchParams = new XRLXeAttribParam[8];
                        searchParams[0] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE,new XRLXeIntValue(Constants.CONTEXT_GAME_MODE_MODEA));
                        searchParams[2] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_TYPE,new XRLXeIntValue(Constants.X_ATTRIBUTE_GAME_TYPE_STANDARD));
                        searchParams[3] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_COUNTRY, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_COUNTRY));
                        searchParams[4] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_LANGUAGE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_LANG));
                        searchParams[5] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_RATING, new XRLXeFloatValue(Constants.XENON_TEST_DEFAULT_GAMER_RATING));
                        searchParams[6] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_MU,new XRLXeDoubleValue(Constants.XENON_TEST_DEFAULT_GAMER_MU));
                        searchParams[7] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_SIGMA, new XRLXeDoubleValue(Constants.XENON_TEST_DEFAULT_GAMER_SIGMA));
                        searchParams[1] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_PUID, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_PUID));

                        XRL2SearchSession	searchReq = new XRL2SearchSession(searchParams,Constants.SESSION_MATCH_QUERY_SOCIALMATCHQUERYFORTITLEONSINGLEDB);
                        searchReq.baseSearchSession.dwTitleID = Constants.XENON_TITLE2;
                        XRL2SearchResults	searchResp;
                        if(searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out searchResp))
                        {
                            if(!(CheckNumResults(searchResp,2)))
                            {
                                goto exit;
                            }
                            // check the session with gamerZone 1 is returned before gamerZone=0
                            long	retSessID = Constants.sessionIDConvert(searchResp.results[0].SessionID);
                            if(retSessID == Constants.sessionIDConvert(createResp2.SessionID))
                                ResultCode=TEST_RESULTS.PASSED;
                            else
                                Global.RO.Warn("gamerZone=0 is not returned 1st");
                        }
                        exit:
                        new XRL2DeleteSession(createResp1.SessionID,Constants.XENON_TITLE2).Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                        new XRL2DeleteSession(createResp2.SessionID,Constants.XENON_TITLE2).Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                    }
                }						
            }
        }
        [TestCase, Description("do not pass gamer puid in search request")]
        class NSearchUserNoPUID : TestBase
        {
            override protected void Execute()
            {
                XRLXeAttribParam	[]		searchParams = new XRLXeAttribParam[8];
                searchParams[0] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_TYPE,new XRLXeIntValue(Constants.X_ATTRIBUTE_GAME_TYPE_RANKED));
                searchParams[1] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE, new XRLXeIntValue(Constants.CONTEXT_GAME_MODE_MODEA));
                searchParams[2] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_ZONE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_ZONE));
                searchParams[3] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_COUNTRY, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_COUNTRY));
                searchParams[4] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_LANGUAGE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_LANG));
                searchParams[5] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_RATING, new XRLXeFloatValue(Constants.XENON_TEST_DEFAULT_GAMER_RATING));
                searchParams[6] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_MU,new XRLXeDoubleValue(Constants.XENON_TEST_DEFAULT_GAMER_MU));
                searchParams[7] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_SIGMA, new XRLXeDoubleValue(Constants.XENON_TEST_DEFAULT_GAMER_SIGMA));

                XRL2SearchSession	searchReq = new XRL2SearchSession(searchParams,Constants.SESSION_MATCH_QUERY_NOPARAMQUERY);						
                XRL2SearchResults		resp;
                if(searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out resp))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("do not pass rating in search request")]
        class NSearchUserNoRating : PositiveSocialMatchTestBase
        {
            override protected void Execute()
            {
                // create 100 session with rating set to 58.72
                XRL2CreateUpdateSession	[]	createReq = new XRL2CreateUpdateSession[100];
                XRLSessionInfo	[]			createResp = new XRLSessionInfo[100];
                XRLXeAttribParam	[]		Attribs = new XRLXeAttribParam[9];
                Attribs[0] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_TYPE,new XRLXeIntValue(Constants.X_ATTRIBUTE_GAME_TYPE_STANDARD));
                Attribs[1] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE, new XRLXeIntValue(Constants.CONTEXT_GAME_MODE_MODEA));
                Attribs[2] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_ZONE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_ZONE));
                Attribs[3] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_COUNTRY, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_COUNTRY));
                Attribs[4] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_LANGUAGE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_LANG));
                Attribs[5] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_RATING, new XRLXeFloatValue(58.72f));
                Attribs[6] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_MU,new XRLXeDoubleValue(Constants.XENON_TEST_DEFAULT_GAMER_MU));
                Attribs[7] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_SIGMA, new XRLXeDoubleValue(Constants.XENON_TEST_DEFAULT_GAMER_SIGMA));
                Attribs[8] = new XRLXeAttribParam(Constants.PROPERTY_MYFLOAT32PROP1_XENON_TITLE2, new XRLXeFloatValue(0.1f));
                for(int i = 0; i < 100; i++)
                {
                    createReq[i] = new XRL2CreateUpdateSession(Attribs);
                    createReq[i].baseCreateUpdate.baseSession.dwTitleID = Constants.XENON_TITLE2;
                    if(!createReq[i].Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out createResp[i]))
                        return;
                }
                // create another session with rating 58.72+0.017
                Attribs[5] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_RATING, new XRLXeFloatValue(58.737f));
                XRLSessionInfo	badSessionInfo;
                XRL2CreateUpdateSession	badCreate = new XRL2CreateUpdateSession(Attribs);
                badCreate.baseCreateUpdate.baseSession.dwTitleID = Constants.XENON_TITLE2;
                if(!badCreate.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out badSessionInfo))
                    return;

                XRLXeAttribParam	[]		searchParams = new XRLXeAttribParam[8];
                searchParams[0] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_TYPE,new XRLXeIntValue(Constants.X_ATTRIBUTE_GAME_TYPE_STANDARD));
                searchParams[1] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE, new XRLXeIntValue(Constants.CONTEXT_GAME_MODE_MODEA));
                searchParams[2] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_ZONE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_ZONE));
                searchParams[4] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_LANGUAGE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_LANG));
                searchParams[5] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_COUNTRY, new XRLXeFloatValue(Constants.XENON_TEST_DEFAULT_GAMER_COUNTRY));
                searchParams[6] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_MU,new XRLXeDoubleValue(Constants.XENON_TEST_DEFAULT_GAMER_MU));
                searchParams[7] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_SIGMA, new XRLXeDoubleValue(Constants.XENON_TEST_DEFAULT_GAMER_SIGMA));
                searchParams[3] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_PUID, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_PUID));

                XRL2SearchSession	searchReq = new XRL2SearchSession(searchParams,Constants.SESSION_MATCH_QUERY_SOCIALMATCHQUERYFORTITLEONSINGLEDB);	
                searchReq.baseSearchSession.dwTitleID = Constants.XENON_TITLE2;
                XRL2SearchResults	searchResp;
                if(searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out searchResp))
                {
                    if(CheckNumResults(searchResp, 25))
                    {// check the one with rating 58.737 is not being returned.
                        bool found = false;
                        long	retSessionID = 0, badSessionID = Constants.sessionIDConvert(badSessionInfo.SessionID);
                        for(int i = 0; i < 25; i++)
                        {	
                            retSessionID = Constants.sessionIDConvert(searchResp.results[i].SessionID);
                            if(retSessionID == badSessionID)
                            {	found = true;
                                break;
                            }
                        }
                        if(found == false)
                            ResultCode=TEST_RESULTS.PASSED;
                    }
                }
                this.DeleteTestSessions(Constants.XENON_TITLE2,createResp);
                new XRL2DeleteSession(badSessionInfo.SessionID,Constants.XENON_TITLE2).Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
            }
        }
        [TestCase, Description("Bug 29998:do not pass lang and country in search request")]
        class NSearchUserNoLangCountry : PositiveSocialMatchTestBase
        {
            override protected void Execute()
            {
                // create 100 session with country and lang set to 103 and 1, rating with in 0.08
                XRL2CreateUpdateSession	[]	createReq = new XRL2CreateUpdateSession[100];
                XRLSessionInfo	[]			createResp = new XRLSessionInfo[100];
                XRLXeAttribParam	[]		Attribs = new XRLXeAttribParam[9];
                Attribs[0] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_TYPE,new XRLXeIntValue(Constants.X_ATTRIBUTE_GAME_TYPE_STANDARD));
                Attribs[1] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE, new XRLXeIntValue(Constants.CONTEXT_GAME_MODE_MODEA));
                Attribs[2] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_ZONE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_ZONE));
                Attribs[3] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_COUNTRY, new XRLXeIntValue(103));
                Attribs[4] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_LANGUAGE,new XRLXeIntValue(1));
                Attribs[5] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_RATING, new XRLXeFloatValue(0.08f));
                Attribs[6] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_MU,new XRLXeDoubleValue(Constants.XENON_TEST_DEFAULT_GAMER_MU));
                Attribs[7] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_SIGMA, new XRLXeDoubleValue(Constants.XENON_TEST_DEFAULT_GAMER_SIGMA));
                Attribs[8] = new XRLXeAttribParam(Constants.PROPERTY_MYFLOAT32PROP1_XENON_TITLE2, new XRLXeFloatValue(0.1f));
                for(int i = 0; i < 100; i++)
                {
                    createReq[i] = new XRL2CreateUpdateSession(Attribs);
                    createReq[i].baseCreateUpdate.baseSession.dwTitleID = Constants.XENON_TITLE2;
                    if(!createReq[i].Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out createResp[i]))
                        return;
                }
                // create another session with country and lang set to 102 and 2, but rating within 0.016
                Attribs[3] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_COUNTRY, new XRLXeIntValue(102));
                Attribs[4] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_LANGUAGE,new XRLXeIntValue(2));
                Attribs[5] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_RATING, new XRLXeFloatValue(0.016f));
                XRLSessionInfo	badSessionInfo;
                XRL2CreateUpdateSession	badCreate = new XRL2CreateUpdateSession(Attribs);
                badCreate.baseCreateUpdate.baseSession.dwTitleID = Constants.XENON_TITLE2;
                if(!badCreate.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out badSessionInfo))
                    return;
				
				
                XRLXeAttribParam	[]		searchParams = new XRLXeAttribParam[7];
                searchParams[0] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_TYPE,new XRLXeIntValue(Constants.X_ATTRIBUTE_GAME_TYPE_STANDARD));
                searchParams[1] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE, new XRLXeIntValue(Constants.CONTEXT_GAME_MODE_MODEA));
                searchParams[2] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_ZONE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_ZONE));
                searchParams[5] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_RATING, new XRLXeFloatValue(Constants.XENON_TEST_DEFAULT_GAMER_RATING));
                searchParams[6] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_MU,new XRLXeDoubleValue(Constants.XENON_TEST_DEFAULT_GAMER_MU));
                searchParams[3] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_SIGMA, new XRLXeDoubleValue(Constants.XENON_TEST_DEFAULT_GAMER_SIGMA));
                searchParams[4] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_PUID, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_PUID));

                XRL2SearchSession	searchReq = new XRL2SearchSession(searchParams,Constants.SESSION_MATCH_QUERY_SOCIALMATCHQUERYFORTITLEONSINGLEDB);						
                searchReq.baseSearchSession.dwTitleID = Constants.XENON_TITLE2;
                XRL2SearchResults	searchResp;
                if(searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out searchResp))
                {
                    if(CheckNumResults(searchResp, 25))
                    {// check the one with countryand lang 1 is not being returned.
                        bool found = false;
                        long	retSessionID = 0, badSessionID = Constants.sessionIDConvert(badSessionInfo.SessionID);
                        for(int i = 0; i < 25; i++)
                        {	
                            retSessionID = Constants.sessionIDConvert(searchResp.results[i].SessionID);
                            if(retSessionID == badSessionID)
                            {
                                Global.RO.Warn("Unexpected session returned");
                                found = true;
                                break;
                            }
                        }
                        if(found == false)
                            ResultCode=TEST_RESULTS.PASSED;
                    }
                }
                this.DeleteTestSessions(Constants.XENON_TITLE2,createResp);
                new XRL2DeleteSession(badSessionInfo.SessionID,Constants.XENON_TITLE2).Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
            }
        }
        [TestCase, Description("Bug 29998:do not pass mu and sigma in search request")]
        class NSearchUserNoMuSigma : PositiveSocialMatchTestBase
        {
            override protected void Execute()
            {
                // create 100 session with mu=3,sigma=1, rating with in 3.125
                XRL2CreateUpdateSession	[]	createReq = new XRL2CreateUpdateSession[100];
                XRLSessionInfo	[]			createResp = new XRLSessionInfo[100];
                XRLXeAttribParam	[]		Attribs = new XRLXeAttribParam[9];
                Attribs[0] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_TYPE,new XRLXeIntValue(Constants.X_ATTRIBUTE_GAME_TYPE_STANDARD));
                Attribs[1] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE, new XRLXeIntValue(Constants.CONTEXT_GAME_MODE_MODEA));
                Attribs[2] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_ZONE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_ZONE));
                Attribs[3] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_COUNTRY, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_COUNTRY));
                Attribs[4] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_LANGUAGE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_LANG));
                Attribs[5] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_RATING, new XRLXeFloatValue(3.125f));
                Attribs[6] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_MU,new XRLXeDoubleValue(3));
                Attribs[7] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_SIGMA, new XRLXeDoubleValue(1));
                Attribs[8] = new XRLXeAttribParam(Constants.PROPERTY_MYFLOAT32PROP1_XENON_TITLE2, new XRLXeFloatValue(0.1f));
                for(int i = 0; i < 100; i++)
                {
                    createReq[i] = new XRL2CreateUpdateSession(Attribs);
                    createReq[i].baseCreateUpdate.baseSession.dwTitleID = Constants.XENON_TITLE2;
                    if(!createReq[i].Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out createResp[i]))
                        return;
                }
                // create another session with mu=2 sigma=0, but rating within 0.78125
                Attribs[6] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_MU,new XRLXeDoubleValue(2));
                Attribs[7] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_SIGMA, new XRLXeDoubleValue(1));
                Attribs[5] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_RATING, new XRLXeFloatValue(0.78125f));
                XRLSessionInfo	badSessionInfo;
                XRL2CreateUpdateSession	badCreate = new XRL2CreateUpdateSession(Attribs);
                badCreate.baseCreateUpdate.baseSession.dwTitleID = Constants.XENON_TITLE2;
                if(!badCreate.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out badSessionInfo))
                    return;
				
				
                XRLXeAttribParam	[]		searchParams = new XRLXeAttribParam[7];
                searchParams[0] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_TYPE,new XRLXeIntValue(Constants.X_ATTRIBUTE_GAME_TYPE_STANDARD));
                searchParams[1] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE, new XRLXeIntValue(Constants.CONTEXT_GAME_MODE_MODEA));
                searchParams[2] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_ZONE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_ZONE));
                searchParams[3] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_COUNTRY, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_COUNTRY));
                searchParams[5] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_RATING, new XRLXeFloatValue(Constants.XENON_TEST_DEFAULT_GAMER_RATING));
                searchParams[6] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_LANGUAGE,new XRLXeDoubleValue(Constants.XENON_TEST_DEFAULT_GAMER_LANG));
                searchParams[4] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_PUID, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_PUID));

                XRL2SearchSession	searchReq = new XRL2SearchSession(searchParams,Constants.SESSION_MATCH_QUERY_SOCIALMATCHQUERYFORTITLEONSINGLEDB);						
                searchReq.baseSearchSession.dwTitleID = Constants.XENON_TITLE2;
                XRL2SearchResults	searchResp;
                if(searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out searchResp))
                {
                    if(CheckNumResults(searchResp, 25))
                    {// check the one with MU AND sigma 2 is not being returned.
                        bool found = false;
                        long	retSessionID = 0, badSessionID = Constants.sessionIDConvert(badSessionInfo.SessionID);
                        for(int i = 0; i < 25; i++)
                        {	
                            retSessionID = Constants.sessionIDConvert(searchResp.results[i].SessionID);
                            if(retSessionID == badSessionID)
                            {
                                found = true;
                                break;
                            }
                        }
                        if(found == false)
                            ResultCode=TEST_RESULTS.PASSED;
                    }
                }
                this.DeleteTestSessions(Constants.XENON_TITLE2,createResp);
                new XRL2DeleteSession(badSessionInfo.SessionID,Constants.XENON_TITLE2).Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
            }
        }
        [TestCase, Description("searchUser's Mu and Sigma is out of range and the user is not in presence.")]
        class NsearchUserBadMuSigma1AndNotFound : PositiveSocialMatchTestBase
        {
            override protected void Execute()
            {
                // create 100 session with mu=6,sigma=0, rating with in 0.08
                XRL2CreateUpdateSession	[]	createReq = new XRL2CreateUpdateSession[100];
                XRLSessionInfo	[]			createResp = new XRLSessionInfo[100];
                XRLXeAttribParam	[]		Attribs = new XRLXeAttribParam[9];
                Attribs[0] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_TYPE,new XRLXeIntValue(Constants.X_ATTRIBUTE_GAME_TYPE_STANDARD));
                Attribs[1] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE, new XRLXeIntValue(Constants.CONTEXT_GAME_MODE_MODEA));
                Attribs[2] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_ZONE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_ZONE));
                Attribs[3] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_COUNTRY, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_COUNTRY));
                Attribs[4] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_LANGUAGE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_LANG));
                Attribs[5] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_RATING, new XRLXeFloatValue(0.08f));
                Attribs[6] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_MU,new XRLXeDoubleValue(6));
                Attribs[7] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_SIGMA, new XRLXeDoubleValue(0));
                Attribs[8] = new XRLXeAttribParam(Constants.PROPERTY_MYFLOAT32PROP1_XENON_TITLE2, new XRLXeFloatValue(0.1f));
                for(int i = 0; i < 100; i++)
                {
                    createReq[i] = new XRL2CreateUpdateSession(Attribs);
                    createReq[i].baseCreateUpdate.baseSession.dwTitleID = Constants.XENON_TITLE2;
                    if(!createReq[i].Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out createResp[i]))
                        return;
                }
                // create another session with mu=2 sigma=0, but rating within 0.016
                Attribs[6] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_MU,new XRLXeDoubleValue(2));
                Attribs[7] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_SIGMA, new XRLXeDoubleValue(0));
                Attribs[5] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_RATING, new XRLXeFloatValue(0.016f));
                XRLSessionInfo	badSessionInfo;
                XRL2CreateUpdateSession	badCreate = new XRL2CreateUpdateSession(Attribs);
                badCreate.baseCreateUpdate.baseSession.dwTitleID = Constants.XENON_TITLE2;
                if(!badCreate.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out badSessionInfo))
                    return;			
				
                XRLXeAttribParam	[]		searchParams = new XRLXeAttribParam[9];
                searchParams[0] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_TYPE,new XRLXeIntValue(Constants.X_ATTRIBUTE_GAME_TYPE_STANDARD));
                searchParams[1] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE, new XRLXeIntValue(Constants.CONTEXT_GAME_MODE_MODEA));
                searchParams[2] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_ZONE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_ZONE));
                searchParams[3] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_COUNTRY, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_COUNTRY));
                searchParams[5] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_RATING, new XRLXeFloatValue(Constants.XENON_TEST_DEFAULT_GAMER_RATING));
                searchParams[6] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_LANGUAGE,new XRLXeDoubleValue(Constants.XENON_TEST_DEFAULT_GAMER_LANG));
                searchParams[4] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_PUID, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_PUID));
                searchParams[7] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_MU,new XRLXeDoubleValue(6.0001));
                searchParams[8] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_SIGMA, new XRLXeDoubleValue(-0.0001));

                XRL2SearchSession	searchReq = new XRL2SearchSession(searchParams,Constants.SESSION_MATCH_QUERY_SOCIALMATCHQUERYFORTITLEONSINGLEDB);						
                searchReq.baseSearchSession.dwTitleID = Constants.XENON_TITLE2;
                XRL2SearchResults	searchResp;
                if(searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out searchResp))
                {
                    if(CheckNumResults(searchResp, 25))
                    {// check the one with MU AND sigma 2 is not being returned.
                        bool found = false;
                        long	retSessionID = 0, badSessionID = Constants.sessionIDConvert(badSessionInfo.SessionID);
                        for(int i = 0; i < 25; i++)
                        {	
                            retSessionID = Constants.sessionIDConvert(searchResp.results[i].SessionID);
                            if(retSessionID == badSessionID)
                            {
                                found = true;
                                break;
                            }
                        }
                        if(found == false)
                            ResultCode=TEST_RESULTS.PASSED;
                    }
                }
                this.DeleteTestSessions(Constants.XENON_TITLE2,createResp);
                new XRL2DeleteSession(badSessionInfo.SessionID,Constants.XENON_TITLE2).Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
            }
        }
        [TestCase, Description("pass no gamer mu/sigma/rating")]
        class NCreateNoMuSigmaRating: NegativeSocialRankedMatchTestBase
        {
            override protected void Execute()
            {
                XRLXeAttribParam	[]		Attribs = new XRLXeAttribParam[5];
                Attribs[0] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_TYPE,new XRLXeIntValue(Constants.X_ATTRIBUTE_GAME_TYPE_STANDARD));
                Attribs[1] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE, new XRLXeIntValue(Constants.CONTEXT_GAME_MODE_MODEA));
                Attribs[2] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_ZONE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_ZONE));
                Attribs[3] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_COUNTRY, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_COUNTRY));
                Attribs[4] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_LANGUAGE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_LANG));

                XRL2CreateUpdateSession	createReq = new XRL2CreateUpdateSession(Attribs);
                createReq.baseCreateUpdate.baseSession.dwTitleID = Constants.XENON_TITLE2;
                XRLSessionInfo			createResp;
                if((createReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out createResp)))
                {
                    long sessionID = Constants.sessionIDConvert(createResp.SessionID);
                    // check database mu=3,sigma=1 and rating=58.72
                    if(VerifyDB(false,sessionID,3,1,58.72f))
                        ResultCode=TEST_RESULTS.PASSED;
                }
                new XRL2DeleteSession(createResp.SessionID,Constants.XENON_TITLE2).Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
            }
        }
        [TestCase, Description("Bug 28190:create a standard match with mu set to -0.0001,sigma set to -0.0001,rating set to -0.0001")]
        class NCreateBadMuSigmaRating1 : NegativeSocialRankedMatchTestBase
        {
            override protected void Execute()
            {
                XRLXeAttribParam	[]		Attribs = new XRLXeAttribParam[8];
                Attribs[0] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_TYPE,new XRLXeIntValue(Constants.X_ATTRIBUTE_GAME_TYPE_STANDARD));
                Attribs[1] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE, new XRLXeIntValue(Constants.CONTEXT_GAME_MODE_MODEA));
                Attribs[2] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_ZONE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_ZONE));
                Attribs[3] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_COUNTRY, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_COUNTRY));
                Attribs[4] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_LANGUAGE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_LANG));
                Attribs[5] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_RATING, new XRLXeFloatValue(-0.0001f));
                Attribs[6] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_MU,new XRLXeDoubleValue(-0.0001));
                Attribs[7] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_SIGMA, new XRLXeDoubleValue(-0.0001));

                XRL2CreateUpdateSession	createReq = new XRL2CreateUpdateSession(Attribs);
                createReq.baseCreateUpdate.baseSession.dwTitleID = Constants.XENON_TITLE2;
                XRLSessionInfo			createResp;
                if((createReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out createResp)))
                {
                    long sessionID = Constants.sessionIDConvert(createResp.SessionID);
                    // check database mu=0,sigma=0 and rating=0
                    if(VerifyDB(false,sessionID,0,0,0))
                        ResultCode=TEST_RESULTS.PASSED;
                }
                new XRL2DeleteSession(createResp.SessionID,Constants.XENON_TITLE2).Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
            }
        }
        [TestCase, Description("create a session without passing host_name attribute")]
        class NCreateMissingHostName : NegativeSocialRankedMatchTestBase
        {
            override protected void Execute()
            {
                XRLXeAttribParam	[]		Attribs = new XRLXeAttribParam[9];
                Attribs[0] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_TYPE,new XRLXeIntValue(Constants.X_ATTRIBUTE_GAME_TYPE_STANDARD));
                Attribs[1] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE, new XRLXeIntValue(Constants.CONTEXT_GAME_MODE_MODEA));
                Attribs[2] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_ZONE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_ZONE));
                Attribs[3] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_COUNTRY, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_COUNTRY));
                Attribs[4] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_LANGUAGE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_LANG));
                Attribs[5] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_RATING, new XRLXeFloatValue(Constants.XENON_TEST_DEFAULT_GAMER_RATING));
                Attribs[6] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_MU,new XRLXeDoubleValue(Constants.XENON_TEST_DEFAULT_GAMER_MU));
                Attribs[7] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_SIGMA, new XRLXeDoubleValue(Constants.XENON_TEST_DEFAULT_GAMER_SIGMA));
                Attribs[8] = new XRLXeAttribParam(Constants.PROPERTY_MYFLOAT32PROP1_XENON_TITLE2, new XRLXeFloatValue(0.1f));

                XRL2CreateUpdateSession	createReq = new XRL2CreateUpdateSession(Attribs);
                createReq.baseCreateUpdate.baseSession.dwTitleID = Constants.XENON_TITLE2;
                XRLSessionInfo			createResp;
                if((createReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out createResp)))
                {
                    XRLXeAttribParam	[]		searchParams = new XRLXeAttribParam[9];
                    searchParams[0] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_TYPE,new XRLXeIntValue(Constants.X_ATTRIBUTE_GAME_TYPE_STANDARD));
                    searchParams[1] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE, new XRLXeIntValue(Constants.CONTEXT_GAME_MODE_MODEA));
                    searchParams[2] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_ZONE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_ZONE));
                    searchParams[3] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_COUNTRY, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_COUNTRY));
                    searchParams[4] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_LANGUAGE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_LANG));
                    searchParams[5] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_RATING, new XRLXeFloatValue(Constants.XENON_TEST_DEFAULT_GAMER_RATING));
                    searchParams[6] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_MU,new XRLXeDoubleValue(Constants.XENON_TEST_DEFAULT_GAMER_MU));
                    searchParams[7] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_SIGMA, new XRLXeDoubleValue(Constants.XENON_TEST_DEFAULT_GAMER_SIGMA));
                    searchParams[8] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_PUID, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_PUID));

                    XRL2SearchSession	searchReq = new XRL2SearchSession(searchParams,Constants.SESSION_MATCH_QUERY_SOCIALMATCHQUERYFORTITLEONSINGLEDB);						
                    searchReq.baseSearchSession.dwTitleID = Constants.XENON_TITLE2;
                    XRL2SearchResults	searchResp;
                    if(searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out searchResp))
                    {
                        // check empty string is being returned as host_name
                        if(!CheckNumResults(searchResp, 1))
                            return;
                        uint	numAttribs = searchResp.results[0].AttribOffsetsLen;
                        for(uint i = 0; i < numAttribs; i++)
                        {
                            if(searchResp.results[0].Attribs[i].attribParamID == Constants.X_ATTRIBUTE_HOST_NAME)
                            {
                                if((searchResp.results[0].Attribs[i].aValue as XRLXeStringValue).strValue.CompareTo(""+'\0') ==0)
                                {
                                    ResultCode=TEST_RESULTS.PASSED;
                                    break;
                                }
                                else
                                    Global.RO.Warn("Returned host_name is not empty");
                            }
                        }
                    }
                }
                new XRL2DeleteSession(createResp.SessionID,Constants.XENON_TITLE2).Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
            }
        }
        [TestCase, Description("create a session with an non empty host_name attribute")]
        class NCreateNonEmptyHostName : NegativeSocialRankedMatchTestBase
        {
            override protected void Execute()
            {
                XRLXeAttribParam	[]		Attribs = new XRLXeAttribParam[10];
                Attribs[0] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_TYPE,new XRLXeIntValue(Constants.X_ATTRIBUTE_GAME_TYPE_STANDARD));
                Attribs[1] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE, new XRLXeIntValue(Constants.CONTEXT_GAME_MODE_MODEA));
                Attribs[2] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_ZONE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_ZONE));
                Attribs[3] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_COUNTRY, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_COUNTRY));
                Attribs[4] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_LANGUAGE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_LANG));
                Attribs[5] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_RATING, new XRLXeFloatValue(Constants.XENON_TEST_DEFAULT_GAMER_RATING));
                Attribs[6] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_MU,new XRLXeDoubleValue(Constants.XENON_TEST_DEFAULT_GAMER_MU));
                Attribs[7] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_SIGMA, new XRLXeDoubleValue(Constants.XENON_TEST_DEFAULT_GAMER_SIGMA));
                Attribs[8] = new XRLXeAttribParam(Constants.PROPERTY_MYFLOAT32PROP1_XENON_TITLE2, new XRLXeFloatValue(0.1f));
                Attribs[9] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_HOST_NAME, new XRLXeStringValue("newmom\0"));

                XRL2CreateUpdateSession	createReq = new XRL2CreateUpdateSession(Attribs);
                createReq.baseCreateUpdate.baseSession.dwTitleID = Constants.XENON_TITLE2;
                XRLSessionInfo			createResp;
                if((createReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out createResp)))
                {
                    XRLXeAttribParam	[]		searchParams = new XRLXeAttribParam[9];
                    searchParams[0] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_TYPE,new XRLXeIntValue(Constants.X_ATTRIBUTE_GAME_TYPE_STANDARD));
                    searchParams[1] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE, new XRLXeIntValue(Constants.CONTEXT_GAME_MODE_MODEA));
                    searchParams[2] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_ZONE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_ZONE));
                    searchParams[3] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_COUNTRY, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_COUNTRY));
                    searchParams[4] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_LANGUAGE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_LANG));
                    searchParams[5] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_RATING, new XRLXeFloatValue(Constants.XENON_TEST_DEFAULT_GAMER_RATING));
                    searchParams[6] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_MU,new XRLXeDoubleValue(Constants.XENON_TEST_DEFAULT_GAMER_MU));
                    searchParams[7] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_SIGMA, new XRLXeDoubleValue(Constants.XENON_TEST_DEFAULT_GAMER_SIGMA));
                    searchParams[8] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_PUID, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_PUID));
                    XRL2SearchSession	searchReq = new XRL2SearchSession(searchParams,Constants.SESSION_MATCH_QUERY_SOCIALMATCHQUERYFORTITLEONSINGLEDB);						
                    searchReq.baseSearchSession.dwTitleID = Constants.XENON_TITLE2;
                    XRL2SearchResults	searchResp;
                    if(searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out searchResp))
                    {
                        // check empty string is being returned as host_name
                        if(!(CheckNumResults(searchResp, 1)))
                            return;
                        uint	numAttribs = searchResp.results[0].AttribOffsetsLen;
                        for(uint i = 0; i < numAttribs; i++)
                        {
                            if(searchResp.results[0].Attribs[i].attribParamID == Constants.X_ATTRIBUTE_HOST_NAME)
                            {
                                if((searchResp.results[0].Attribs[i].aValue as XRLXeStringValue).strValue.CompareTo("newmom\0")==0)
                                {
                                    ResultCode=TEST_RESULTS.PASSED;
                                    break;
                                }
                                else
                                    Global.RO.Warn("Returned host_name is not newmom.");
                            }
                        }
                    }
                }
                new XRL2DeleteSession(createResp.SessionID,Constants.XENON_TITLE2).Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
            }
        }
        [TestCase, Description("Bug 28190:create a standard match with mu set to 6.0001,sigma set to 1.0001,rating set to 100.0001")]
        class NCreateBadMuSigmaRating2 : NegativeSocialRankedMatchTestBase
        {
            override protected void Execute()
            {
                XRLXeAttribParam	[]		Attribs = new XRLXeAttribParam[8];
                Attribs[0] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_TYPE,new XRLXeIntValue(Constants.X_ATTRIBUTE_GAME_TYPE_STANDARD));
                Attribs[1] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE, new XRLXeIntValue(Constants.CONTEXT_GAME_MODE_MODEA));
                Attribs[2] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_ZONE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_ZONE));
                Attribs[3] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_COUNTRY, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_COUNTRY));
                Attribs[4] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_LANGUAGE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_LANG));
                Attribs[5] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_RATING, new XRLXeFloatValue(100.0001f));
                Attribs[6] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_MU,new XRLXeDoubleValue(6.0001));
                Attribs[7] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_SIGMA, new XRLXeDoubleValue(1.0001));

                XRL2CreateUpdateSession	createReq = new XRL2CreateUpdateSession(Attribs);
                createReq.baseCreateUpdate.baseSession.dwTitleID = Constants.XENON_TITLE2;
                XRLSessionInfo			createResp;
                if((createReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out createResp)))
                {
                    long sessionID = Constants.sessionIDConvert(createResp.SessionID);
                    // check database mu=6,sigma=1 and rating=100
                    if(VerifyDB(false,sessionID,6,1,100))
                        ResultCode=TEST_RESULTS.PASSED;
                }
                new XRL2DeleteSession(createResp.SessionID,Constants.XENON_TITLE2).Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
            }
        }
        [TestCase, Description("Bug 28190:update a standard match with mu set to -0.0001,sigma set to -0.0001,rating set to -0.0001")]
        class NUpdateBadMuSigmaRating1 : NegativeSocialRankedMatchTestBase
        {
            override protected void Execute()
            {
                XRLXeAttribParam	[]		Attribs = new XRLXeAttribParam[9];
                Attribs[0] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_TYPE,new XRLXeIntValue(Constants.X_ATTRIBUTE_GAME_TYPE_STANDARD));
                Attribs[1] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE, new XRLXeIntValue(Constants.CONTEXT_GAME_MODE_MODEA));
                Attribs[2] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_ZONE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_ZONE));
                Attribs[3] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_COUNTRY, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_COUNTRY));
                Attribs[4] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_LANGUAGE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_LANG));
                Attribs[5] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_RATING, new XRLXeFloatValue(Constants.XENON_TEST_DEFAULT_GAMER_RATING));
                Attribs[6] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_MU,new XRLXeDoubleValue(Constants.XENON_TEST_DEFAULT_GAMER_MU));
                Attribs[7] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_SIGMA, new XRLXeDoubleValue(Constants.XENON_TEST_DEFAULT_GAMER_SIGMA));
                Attribs[8] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_HOST_NAME, new XRLXeStringValue("newmom\0"));

                XRL2CreateUpdateSession	createReq = new XRL2CreateUpdateSession(Attribs);
                createReq.baseCreateUpdate.baseSession.dwTitleID = Constants.XENON_TITLE2;
                XRLSessionInfo			createResp;
                if((createReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out createResp)))
                {
                    XRLXeAttribParam	[]		attribs = new XRLXeAttribParam[3];
                    attribs[0] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_RATING, new XRLXeFloatValue(-0.0001f));
                    attribs[1] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_MU,new XRLXeDoubleValue(-0.0001));
                    attribs[2] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_SIGMA, new XRLXeDoubleValue(-0.0001));

                    long					sessionID = Constants.sessionIDConvert(createResp.SessionID);
                    XRL2CreateUpdateSession	updateReq = new XRL2CreateUpdateSession(createResp.SessionID);
                    updateReq.baseCreateUpdate.baseSession.dwTitleID = Constants.XENON_TITLE2;
                    updateReq.AddAttribs(attribs);
                    if(updateReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd)))
                    {
                        // check database mu=0,sigma=0 and rating=0
                        if(VerifyDB(false,sessionID,0,0,0))
                            ResultCode=TEST_RESULTS.PASSED;
                    }
                }
                new XRL2DeleteSession(createResp.SessionID,Constants.XENON_TITLE2).Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
            }
        }
        [TestCase, Description("Bug 28190:update a standard match with mu set to 6.0001,sigma set to 1.0001,rating set to 100.0001")]
        class NUpdateBadMuSigmaRating2 : NegativeSocialRankedMatchTestBase
        {
            override protected void Execute()
            {
                XRLXeAttribParam	[]		Attribs = new XRLXeAttribParam[9];
                Attribs[0] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_TYPE,new XRLXeIntValue(Constants.X_ATTRIBUTE_GAME_TYPE_STANDARD));
                Attribs[1] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE, new XRLXeIntValue(Constants.CONTEXT_GAME_MODE_MODEA));
                Attribs[2] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_ZONE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_ZONE));
                Attribs[3] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_COUNTRY, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_COUNTRY));
                Attribs[4] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_LANGUAGE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_LANG));
                Attribs[5] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_RATING, new XRLXeFloatValue(Constants.XENON_TEST_DEFAULT_GAMER_RATING));
                Attribs[6] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_MU,new XRLXeDoubleValue(Constants.XENON_TEST_DEFAULT_GAMER_MU));
                Attribs[7] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_SIGMA, new XRLXeDoubleValue(Constants.XENON_TEST_DEFAULT_GAMER_SIGMA));
                Attribs[8] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_HOST_NAME, new XRLXeStringValue("newmom\0"));

                XRL2CreateUpdateSession	createReq = new XRL2CreateUpdateSession(Attribs);
                createReq.baseCreateUpdate.baseSession.dwTitleID = Constants.XENON_TITLE2;
                XRLSessionInfo			createResp;
                if((createReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out createResp)))
                {
                    XRLXeAttribParam	[]		attribs = new XRLXeAttribParam[3];
                    attribs[0] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_RATING, new XRLXeFloatValue(100.0001f));
                    attribs[1] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_MU,new XRLXeDoubleValue(6.0001));
                    attribs[2] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_SIGMA, new XRLXeDoubleValue(1.0001));

                    long					sessionID = Constants.sessionIDConvert(createResp.SessionID);
                    XRL2CreateUpdateSession	updateReq = new XRL2CreateUpdateSession(createResp.SessionID);
                    updateReq.baseCreateUpdate.baseSession.dwTitleID = Constants.XENON_TITLE2;
                    updateReq.AddAttribs(attribs);

                    if(updateReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd)))
                    {
                        // check database mu=6,sigma=1 and rating=100
                        if(VerifyDB(false,sessionID,6,1,100))
                            ResultCode=TEST_RESULTS.PASSED;
                    }
                }
                new XRL2DeleteSession(createResp.SessionID,Constants.XENON_TITLE2).Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
            }
        }
        //create sessions of certain zone/lang/country.  Create a structure that contains
        //zone/lang/country alongside?  Print this out afterwards?
        protected static bool CreateZoneLangCountrySession (uint titleID, uint zone, uint lang, uint country, 
                                                     uint numSessions,out XRLSessionInfo[] SessionInfos)
        {
            SessionInfos = new XRLSessionInfo[numSessions];
            XRL2CreateUpdateSession[]	createReqs = new XRL2CreateUpdateSession[numSessions];

            XRLXeAttribParam	[]		Attribs = new XRLXeAttribParam[8];
            Attribs[0] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_TYPE,new XRLXeIntValue(Constants.X_ATTRIBUTE_GAME_TYPE_STANDARD));
            Attribs[1] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE, new XRLXeIntValue(Constants.CONTEXT_GAME_MODE_MODEA));
            Attribs[2] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_ZONE,new XRLXeIntValue(zone));
            Attribs[3] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_COUNTRY, new XRLXeIntValue(country));
            Attribs[4] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_LANGUAGE,new XRLXeIntValue(lang));
            Attribs[5] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_RATING, new XRLXeFloatValue(Constants.XENON_TEST_DEFAULT_GAMER_RATING));
            Attribs[6] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_MU,new XRLXeDoubleValue(Constants.XENON_TEST_DEFAULT_GAMER_MU));
            Attribs[7] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_SIGMA, new XRLXeDoubleValue(Constants.XENON_TEST_DEFAULT_GAMER_SIGMA));

            for(int i = 0; i < numSessions; i++)
            {
                System.Threading.Thread.Sleep(100);  //slow it down.  hopefully we get
                //better
                //randomization...

                createReqs[i] = new XRL2CreateUpdateSession(Attribs);
                createReqs[i].baseCreateUpdate.baseSession.dwTitleID = titleID;
                if(!(createReqs[i].Execute(Global.XEnv.GetInterface(Interface.xmatchfd)[0],out SessionInfos[i]))) {
                    Global.RO.Error("Create request failed!");
                    return false;
                }
            }
            return true;
        }	

        //search for sessions with zone/lang/country
        protected static bool SearchZoneLangCountry(uint titleID, uint spIndex, uint zone, uint lang, uint country,
                                             out XRL2SearchResults searchResp)
        {
            XRLXeAttribParam[]		searchParams = new XRLXeAttribParam[9];
            searchParams[0] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_TYPE,new XRLXeIntValue(Constants.X_ATTRIBUTE_GAME_TYPE_STANDARD));
            searchParams[1] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE, new XRLXeIntValue(Constants.CONTEXT_GAME_MODE_MODEA));
            searchParams[2] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_ZONE,new XRLXeIntValue(zone));
            searchParams[3] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_COUNTRY, new XRLXeIntValue(country));
            searchParams[4] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_LANGUAGE,new XRLXeIntValue(lang));
            searchParams[5] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_RATING, new XRLXeFloatValue(Constants.XENON_TEST_DEFAULT_GAMER_RATING));
            searchParams[6] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_MU,new XRLXeDoubleValue(Constants.XENON_TEST_DEFAULT_GAMER_MU));
            searchParams[7] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_SIGMA, new XRLXeDoubleValue(Constants.XENON_TEST_DEFAULT_GAMER_SIGMA));
            searchParams[8] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_PUID,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_PUID));

            XRL2SearchSession	searchReq = new XRL2SearchSession(searchParams,spIndex);
            searchReq.baseSearchSession.dwTitleID = titleID;
            if (!searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out searchResp))
            {
                Global.RO.Warn("socialMatchSearch request failed:"+ Global.XErrToString(searchReq.XErr));
                return false;
            }
            Global.RO.Info("Number of search results:" + searchResp.results.Length);
            return true;
        }
        //internal verify

        //The following is specifically for the MW2 hack, wherein country is ordered above language,
        //which is above zone, rather than the reverse.
        public class SessionInfoHash {
            private uint titleID;
            private Hashtable sessions;

            public class SessionInfo {
                public XRLSessionInfo sessionInfo;
                public uint country;
                public uint lang;
                public uint zone;

                public SessionInfo(XRLSessionInfo sessionInfo, uint country, uint lang, uint zone) {
                    this.sessionInfo = sessionInfo;
                    this.country = country;
                    this.lang = lang;
                    this.zone = zone;
                }
            }

            public SessionInfoHash(uint titleID) {
                sessions = new Hashtable();
                this.titleID = titleID;
            }

            public void Add(XRLSessionInfo sessionInfo, uint country, uint lang, uint zone) {
                long sessID = Constants.sessionIDConvert(sessionInfo.SessionID);
                sessions[sessID] = new SessionInfo(sessionInfo, country, lang, zone);
            }
            //Give a score to a session based on how they match the
            //country/lang/zone that's passed in.
            public uint GetScore(XRLSessionInfo sessionInfo, uint country, uint lang, uint zone) {
                return GetScore(Constants.sessionIDConvert(sessionInfo.SessionID), country, lang, zone);
            }

            public uint GetScore(long sessionID, uint country, uint lang, uint zone) {
                uint score = 0;
                SessionInfo thisSession = (SessionInfo) (sessions[sessionID]);
                if (thisSession.country == country) score += 4;
                if (thisSession.lang == lang) score += 2;
                if (thisSession.zone == zone) score += 1;
/*
                if (thisSession.country == country) score += 1;
                if (thisSession.lang == lang) score += 2;
                if (thisSession.zone == zone) score += 4;
*/
                return score;
            }
                
            public bool IsPresent(long sessionID) {
                return (null != sessions[sessionID]);
            }

            //call this to clean up all sessions in this hash
            public void DeleteAllSessions() {
                foreach (DictionaryEntry de in sessions) {
                    XRLSessionInfo sessionInfo = ((SessionInfo) (de.Value)).sessionInfo;
                    XRL2DeleteSession delReq = new XRL2DeleteSession(sessionInfo.SessionID, titleID);
                    if(!delReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd)))
                    {
                        Global.RO.Warn("Session Delete failed:" + Global.XErrToString(delReq.XErr));
                    }
                }
            }
            //call this to clean up all sessions in this hash
            public void PrintAllSessions() {
                foreach (DictionaryEntry de in sessions) {
                    XRLSessionInfo sessionInfo = ((SessionInfo) (de.Value)).sessionInfo;
                    PrintSession(Constants.sessionIDConvert(sessionInfo.SessionID));
                }
            }

            public void PrintSession(long sessionID) {
                SessionInfo thisSession = (SessionInfo) (sessions[sessionID]);
                Global.RO.Info("SessionID:" + sessionID + 
                               "  country:" + thisSession.country +
                               "  lang:" + thisSession.lang +
                               "  zone:" + thisSession.zone);
            }

            //return all sessionIDs that match a certain score.  Linear.
            public Hashtable GetAllSessionsIDsOfScore(uint targetScore, uint targetCountry, uint targetLang, uint targetZone) {
                Hashtable sessionsThatMatch = new Hashtable();
                foreach (DictionaryEntry de in sessions) {
                    XRLSessionInfo sessionInfo = ((SessionInfo) (de.Value)).sessionInfo;
                    long sessID = Constants.sessionIDConvert(sessionInfo.SessionID);
                    if (targetScore == GetScore(sessID, targetCountry, targetLang, targetZone)) {
                        sessionsThatMatch[sessID] = 1;
                    }
                }
                return sessionsThatMatch;
            }
        }


        public static bool ExecuteAndVerifySearch(uint titleID, uint testCountry, uint testLang, uint testZone, 
                                            SessionInfoHash sessionData) {
            uint spIndex = 5;  //our custom name
            XRL2SearchResults searchResults;
            //search with a user.
            Global.RO.Info("Searching with parameters:");
            Global.RO.Info("country:" + testCountry + "  lang:" + testLang + "  zone:" + testZone);
            SearchZoneLangCountry(titleID, spIndex, testZone, testLang, testCountry, 
                                  out searchResults);

            //output for manual verify
            for(int i=0; i< searchResults.results.Length; i++) {
                long sessID = Constants.sessionIDConvert(searchResults.results[i].SessionID);
                Global.RO.Info("Session " + i + " is " + sessID);
                if (sessionData.IsPresent(sessID)) {
                    sessionData.PrintSession(sessID);
                    Global.RO.Info(" with score " + sessionData.GetScore(sessID, testCountry, testLang, testZone));
                }
            }


            //for verify, create a system of points.  four points for country match, two for lang
            //match, one for zone match.  points must be in descending order.
            //go down all the possible scores.  For each score, go through the searchResults
            //and remove entries until the hashtable is empty.  Once it is, get scores of
            //the next type.
            bool success = true;
            int currentResult = 0;
            int maxResult = searchResults.results.Length;
            for (uint score=7; score>= 0; score--) {
                Hashtable expectedSessions = sessionData.GetAllSessionsIDsOfScore(score, testCountry, testLang, testZone);
                while ((currentResult < maxResult) && 
                       (expectedSessions.Count > 0)) {
                    long sessID = Constants.sessionIDConvert(searchResults.results[currentResult].SessionID);
                    if (expectedSessions.Contains(sessID)) {
                        Global.RO.Success("Session " + sessID + " found when looking for score " + score);
                        sessionData.PrintSession(sessID);
                        expectedSessions.Remove(sessID);
                    } else {
                        success = false;
                        Global.RO.Error("Search returned " + sessID + " unexpectedly.  Score of sessions should be " + score);
                        foreach (DictionaryEntry de in expectedSessions) {
                            long missingSessID = (long) de.Key;
                            Global.RO.Info("Session missing:" + missingSessID);
                        }
                        Global.RO.Info("Clearing these sessions.");
                        expectedSessions.Clear();
                    }
                    currentResult++;
                }
                if (currentResult == maxResult) {
                    //we got our maximum results.  We could validate that there's as many of
                    //them as sessions, but for now let's just always make > 50 of them.
                    return success;
                }
            }
            //if we get here...we're out of expectedSessions.  Make sure currentResult ==
            //maxResult--otherwise we have more sessions than we expect.
            if (currentResult != maxResult) {
                Global.RO.Error("We have more results than we expect.  Clear the table beforehand!");
                return false;
            }
            return success;

        }
        //This test case does not pass 100% of the time.  Hashing in some of the larger sets will
        //remove an even swath of results, meaning you may find a worse match earlier than you
        //thought.
        //
        //Only the top ten will matter, however, as QOS won't get to the other 40.
        [TestCase, Description("MW2 QFE Testing:For title 41560817, gamerzone and country sorts are reversed.")]
        class P_MW2_Country_Goes_First : PositiveSocialMatchTestBase
        {
            override protected void Execute()
            {
                uint mw2TitleId = 0x41560817;
                if (!ServerTestFramework.STFTools.LiveTitle.CheckIfTitleIsPropped(mw2TitleId))
                {
                    Global.RO.Info("Modern Warfare 2 is not propped in this environment; skipping test.");
                    ResultCode = TEST_RESULTS.NOT_EXECUTED;
                    return;
                }

                MatchUtil.TruncateSessionsForTitle(mw2TitleId, SessionType.Social);
                uint titleID = mw2TitleId;
                //create some sessions of different countries, zones, langs.  If the total number
                //here exceeds 100, then hashing will drop some of the sessions, making it hard to verify.
                uint [] countries = new uint[8] {6, 8, 24, 36, 45, 82, 84, 103};
                uint [] langs = new uint[3] {1, 3, 5};
                uint [] zones = new uint[4] {1,2,3,4};
                SessionInfoHash sessionData = new SessionInfoHash(titleID);
                XRLSessionInfo[] sessionInfos;

                uint numSessions;
                for(int countryIndex=0; countryIndex < countries.Length; countryIndex++) {
                    for (int langIndex = 0; langIndex < langs.Length; langIndex++) {
                        for (int zoneIndex = 0; zoneIndex < zones.Length; zoneIndex++) {
                            //use case:we have lots more US folks(103) than Austrailians(6).
                            if (countries[countryIndex] == 103){
                                numSessions = 5;
                            } else {
                                numSessions = 1;
                            }
                            //create
                            CreateZoneLangCountrySession(titleID, zones[zoneIndex], langs[langIndex], countries[countryIndex], 
                                                         numSessions/*  ?  */  , out sessionInfos);
                            //add to the set of sessions
                            for(int i=0; i< sessionInfos.Length; i++) {
                                sessionData.Add(sessionInfos[i], countries[countryIndex], langs[langIndex], zones[zoneIndex]);
                            }
                        }
                    }
                }
                sessionData.PrintAllSessions();
                bool success = true;
                success = ExecuteAndVerifySearch(titleID, 6, 3, 1, sessionData) && success;  //australians
                success = ExecuteAndVerifySearch(titleID, 103, 3, 1, sessionData) && success; //US                
                sessionData.DeleteAllSessions();
                if (success) {
                    ResultCode=TEST_RESULTS.PASSED;
                }
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XMatchTest\Func2HostMigScenarios.cs ===
using System;
using System.Collections.Generic;
using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Matchmaking;
using xonline.common.config;

namespace XMatchTest
{
    /// <summary>
	/// Summary description for Func2HostMigScenarios.
	/// </summary>
    [TestGroup]
    public class Func2HostMigScenarios : TestNode
    {
        [TestGroupSetup]
        public void Setup()
        {
            NpdbUtility npdb = new NpdbUtility();
            npdb.ConnectToServer();
            npdb.SetMatchTitleDeleteDelay(Constants.XENON_TITLE, 30);
            npdb.Close();
            Global.XEnv.ExecuteXmgmtCommand(Interface.xmatchfd, "e :xmatchfd reloadtitleinfo");
        }

        [TestGroupTearDown]
        public void TearDown()
        {
            NpdbUtility npdb = new NpdbUtility();
            npdb.ConnectToServer();
            npdb.SetMatchTitleDeleteDelay(Constants.XENON_TITLE, 0);
            npdb.Close();
            Global.XEnv.ExecuteXmgmtCommand(Interface.xmatchfd, "e :xmatchfd reloadtitleinfo");
        }

        private static MultiCommand PlaySessionCmds()
        {
            MultiCommand cmds = new MultiCommand(
                new JoinCmd(8, 8),
                new VerifySessionCmd()
                );
            return(cmds);
        }

        /// <summary>
        /// Uses PlaySessionCmds() and adds a DeleteCmd to the end to remove the session
        /// </summary>
        /// <returns></returns>
        private static MultiCommand PlayAndDeleteSessionCmds()
        {
            MultiCommand cmds = PlaySessionCmds();
            cmds.Add(new DeleteCmd());
            return(cmds);
        }

        public abstract class PElectiveMigration : TestBase
        {
            protected void Execute(SessionType sessionType, bool changeHost)
            {
                MatchState state = new MatchState();
                CommandEngine.Execute(
                    state,
                    new CreateCmd(sessionType),
                    new JoinCmd(8, 8),
                    new ElectiveSplitCmd(PlayAndDeleteSessionCmds(), changeHost)
                    // new VerifySessionCmd()
                    // new DeleteCmd()
                    );
            }
        }
        [BVT]
        [TestCase]
        public class PElectiveMigration_NewHost_Ranked : PElectiveMigration
        {
            override protected void Execute()
            {
                Execute(SessionType.Ranked, true);
                ResultCode = TEST_RESULTS.PASSED;
            }
        }
        [BVT]
        [TestCase]
        public class PElectiveMigration_SameHost_Ranked : PElectiveMigration
        {
            override protected void Execute()
            {
                Execute(SessionType.Ranked, false);
                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [BVT]
        [TestCase]
        public class PElectiveMigration_NewHost_Social : PElectiveMigration
        {
            override protected void Execute()
            {
                Execute(SessionType.Social, true);
                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [BVT]
        [TestCase]
        public class PElectiveMigration_SameHost_Social : PElectiveMigration
        {
            override protected void Execute()
            {
                Execute(SessionType.Social, false);
                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        public abstract class PSingleSplit_Network : TestBase
        {
            protected void Execute(SessionType sessionType)
            {
                MultiCommand continueSessionCmds = new MultiCommand(
                    new JoinCmd(4, 4),
                    PlayAndDeleteSessionCmds()
                    );

                MatchState state = new MatchState();
                CommandEngine.Execute(
                    state,
                    new CreateCmd(sessionType),
                    new JoinCmd(8, 8),
                    new NetworkSplitCmd(continueSessionCmds),
                    continueSessionCmds
                    );
            }
        }

        [TestCase]
        public class PSingleSplit_Network_Ranked : PSingleSplit_Network
        {
            override protected void Execute()
            {
                Execute(SessionType.Ranked);
                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase]
        public class PSingleSplit_Network_Social : PSingleSplit_Network
        {
            override protected void Execute()
            {
                Execute(SessionType.Social);
                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        public abstract class PSingleSplit_HostDisconnect : TestBase
        {
            protected void Execute(SessionType sessionType)
            {
                MatchState state = new MatchState();
                CommandEngine.Execute(
                    state,
                    new CreateCmd(sessionType),
                    new JoinCmd(8, 8),
                    new HostDCSplitCmd(PlayAndDeleteSessionCmds())
                    );

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase]
        public class PSingleSplit_HostDisconnect_Ranked : PSingleSplit_HostDisconnect
        {
            override protected void Execute()
            {
                Execute(SessionType.Ranked);
                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase]
        public class PSingleSplit_HostDisconnect_Social : PSingleSplit_HostDisconnect
        {
            override protected void Execute()
            {
                Execute(SessionType.Social);
                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        public abstract class PNWaySplits_WithCleanup : TestBase
        {
            protected void Execute(SessionType sessionType, MultiSplitCmd splits)
            {
                MatchState state = new MatchState();
                CommandEngine.Execute(
                    state,
                    new CreateCmd(sessionType),
                    new JoinCmd(8, 8),
                    splits,
                    PlayAndDeleteSessionCmds()
                    );

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// 2 Network (continue original session) splits
        /// </summary>
        [TestCase]
        public class PNWaySplits_2x_Network_Ranked : PNWaySplits_WithCleanup
        {
            protected override void Execute()
            {
                MultiSplitCmd splits = new MultiSplitCmd(
                    new NetworkSplitCmd(PlayAndDeleteSessionCmds()),
                    new NetworkSplitCmd(PlayAndDeleteSessionCmds())
                    );
                Execute(SessionType.Ranked, splits);
            }
        }

        /// <summary>
        /// 2 Network (continue original session) splits
        /// </summary>
        [TestCase]
        public class PNWaySplits_2x_Network_Social : PNWaySplits_WithCleanup
        {
            protected override void Execute()
            {
                MultiSplitCmd splits = new MultiSplitCmd(
                    new NetworkSplitCmd(PlayAndDeleteSessionCmds()),
                    new NetworkSplitCmd(PlayAndDeleteSessionCmds())
                    );
                Execute(SessionType.Social, splits);
            }
        }

        /// <summary>
        /// HostDC (DeadXbox original session) and Network (continue original session) splits
        /// </summary>
        [TestCase]
        public class PNWaySplits_8x_Network_Ranked : PNWaySplits_WithCleanup
        {
            protected override void Execute()
            {
                MultiSplitCmd splits = new MultiSplitCmd(
                    new NetworkSplitCmd(PlayAndDeleteSessionCmds()),
                    new NetworkSplitCmd(PlayAndDeleteSessionCmds()),
                    new NetworkSplitCmd(PlayAndDeleteSessionCmds()),
                    new NetworkSplitCmd(PlayAndDeleteSessionCmds()),
                    new NetworkSplitCmd(PlayAndDeleteSessionCmds()),
                    new NetworkSplitCmd(PlayAndDeleteSessionCmds()),
                    new NetworkSplitCmd(PlayAndDeleteSessionCmds()),
                    new NetworkSplitCmd(PlayAndDeleteSessionCmds())
                    );
                Execute(SessionType.Ranked, splits);
            }
        }

        /// <summary>
        /// HostDC (DeadXbox original session) and Network (continue original session) splits
        /// </summary>
        [TestCase]
        public class PNWaySplits_8x_Network_Social : PNWaySplits_WithCleanup
        {
            protected override void Execute()
            {
                MultiSplitCmd splits = new MultiSplitCmd(
                    new NetworkSplitCmd(PlayAndDeleteSessionCmds()),
                    new NetworkSplitCmd(PlayAndDeleteSessionCmds()),
                    new NetworkSplitCmd(PlayAndDeleteSessionCmds()),
                    new NetworkSplitCmd(PlayAndDeleteSessionCmds()),
                    new NetworkSplitCmd(PlayAndDeleteSessionCmds()),
                    new NetworkSplitCmd(PlayAndDeleteSessionCmds()),
                    new NetworkSplitCmd(PlayAndDeleteSessionCmds()),
                    new NetworkSplitCmd(PlayAndDeleteSessionCmds())
                    );
                Execute(SessionType.Social, splits);
            }
        }

        public abstract class PNWaySplits_NoCleanup : TestBase
        {
            protected void Execute(SessionType sessionType, MultiSplitCmd splits)
            {
                MatchState state = new MatchState();
                CommandEngine.Execute(
                    state,
                    new CreateCmd(sessionType),
                    new JoinCmd(8, 8),
                    splits
                    );

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// HostDC (DeadXbox original session) and Elective (delete original session) splits
        /// </summary>
        [TestCase]
        public class PNWaySplits_HostDC_Elective_Ranked : PNWaySplits_NoCleanup
        {
            protected override void Execute()
            {
                MultiSplitCmd splits = new MultiSplitCmd(
                    new HostDCSplitCmd(PlayAndDeleteSessionCmds()),
                    new NetworkSplitCmd(PlayAndDeleteSessionCmds()),
                    new NetworkSplitCmd(PlayAndDeleteSessionCmds()),
                    new NetworkSplitCmd(PlayAndDeleteSessionCmds()),
                    new NetworkSplitCmd(PlayAndDeleteSessionCmds()),
                    new NetworkSplitCmd(PlayAndDeleteSessionCmds()),
                    new NetworkSplitCmd(PlayAndDeleteSessionCmds())
                    );
                Execute(SessionType.Ranked, splits);
            }
        }

        /// <summary>
        /// HostDC (DeadXbox original session) and Elective (delete original session) splits
        /// </summary>
        [TestCase]
        public class PNWaySplits_HostDC_Elective_Social : PNWaySplits_NoCleanup
        {
            protected override void Execute()
            {
                MultiSplitCmd splits = new MultiSplitCmd(
                    new HostDCSplitCmd(PlayAndDeleteSessionCmds()),
                    new NetworkSplitCmd(PlayAndDeleteSessionCmds()),
                    new NetworkSplitCmd(PlayAndDeleteSessionCmds()),
                    new NetworkSplitCmd(PlayAndDeleteSessionCmds()),
                    new NetworkSplitCmd(PlayAndDeleteSessionCmds()),
                    new NetworkSplitCmd(PlayAndDeleteSessionCmds()),
                    new NetworkSplitCmd(PlayAndDeleteSessionCmds())
                    );
                Execute(SessionType.Social, splits);
            }
        }

        /// <summary>
        /// HostDC (DeadXbox original session) and Network (continue original session) splits
        /// </summary>
        [TestCase]
        public class PNWaySplits_HostDC_Network_Ranked : PNWaySplits_NoCleanup
        {
            protected override void Execute()
            {
                MultiSplitCmd splits = new MultiSplitCmd(
                    new HostDCSplitCmd(PlayAndDeleteSessionCmds()),
                    new NetworkSplitCmd(PlayAndDeleteSessionCmds())
                    );
                Execute(SessionType.Ranked, splits);
            }
        }

        /// <summary>
        /// HostDC (DeadXbox original session) and Network (continue original session) splits
        /// </summary>
        [TestCase]
        public class PNWaySplits_HostDC_Network_Social : PNWaySplits_NoCleanup
        {
            protected override void Execute()
            {
                MultiSplitCmd splits = new MultiSplitCmd(
                    new HostDCSplitCmd(PlayAndDeleteSessionCmds()),
                    new NetworkSplitCmd(PlayAndDeleteSessionCmds())
                    );
                Execute(SessionType.Social, splits);
            }
        }

        /// <summary>
        /// HostDC (DeadXbox original session) and Network (continue original session) splits
        /// </summary>
        [TestCase]
        public class PNWaySplits_HostDC_7x_Network_Ranked : PNWaySplits_NoCleanup
        {
            protected override void Execute()
            {
                MultiSplitCmd splits = new MultiSplitCmd(
                    new HostDCSplitCmd(PlayAndDeleteSessionCmds()),
                    new NetworkSplitCmd(PlayAndDeleteSessionCmds()),
                    new NetworkSplitCmd(PlayAndDeleteSessionCmds()),
                    new NetworkSplitCmd(PlayAndDeleteSessionCmds()),
                    new NetworkSplitCmd(PlayAndDeleteSessionCmds()),
                    new NetworkSplitCmd(PlayAndDeleteSessionCmds()),
                    new NetworkSplitCmd(PlayAndDeleteSessionCmds()),
                    new NetworkSplitCmd(PlayAndDeleteSessionCmds())
                    );
                Execute(SessionType.Ranked, splits);
            }
        }

        /// <summary>
        /// HostDC (DeadXbox original session) and Network (continue original session) splits
        /// </summary>
        [TestCase]
        public class PNWaySplits_HostDC_7x_Network_Social : PNWaySplits_NoCleanup
        {
            protected override void Execute()
            {
                MultiSplitCmd splits = new MultiSplitCmd(
                    new HostDCSplitCmd(PlayAndDeleteSessionCmds()),
                    new NetworkSplitCmd(PlayAndDeleteSessionCmds()),
                    new NetworkSplitCmd(PlayAndDeleteSessionCmds()),
                    new NetworkSplitCmd(PlayAndDeleteSessionCmds()),
                    new NetworkSplitCmd(PlayAndDeleteSessionCmds()),
                    new NetworkSplitCmd(PlayAndDeleteSessionCmds()),
                    new NetworkSplitCmd(PlayAndDeleteSessionCmds()),
                    new NetworkSplitCmd(PlayAndDeleteSessionCmds())
                    );
                Execute(SessionType.Social, splits);
            }
        }

        /// <summary>
        /// HostDC (DeadXbox original session), Elective (delete original session), and 
        /// Network (continue original session) splits
        /// </summary>
        [TestCase]
        public class PNWaySplits_HostDC_Elective_Network_Ranked : PNWaySplits_NoCleanup
        {
            protected override void Execute()
            {
                MultiSplitCmd splits = new MultiSplitCmd(
                    new HostDCSplitCmd(PlayAndDeleteSessionCmds()),
                    new ElectiveSplitCmd(PlayAndDeleteSessionCmds(), true),
                    new NetworkSplitCmd(PlayAndDeleteSessionCmds())
                    );
                Execute(SessionType.Ranked, splits);
            }
        }

        /// <summary>
        /// HostDC (DeadXbox original session), Elective (delete original session), and 
        /// Network (continue original session) splits
        /// </summary>
        [TestCase]
        public class PNWaySplits_HostDC_Elective_Network_Social : PNWaySplits_NoCleanup
        {
            protected override void Execute()
            {
                MultiSplitCmd splits = new MultiSplitCmd(
                    new HostDCSplitCmd(PlayAndDeleteSessionCmds()),
                    new ElectiveSplitCmd(PlayAndDeleteSessionCmds(), true),
                    new NetworkSplitCmd(PlayAndDeleteSessionCmds())
                    );
                Execute(SessionType.Social, splits);
            }
        }

        /// <summary>
        /// Elective (delete original session) and Network (continue original session) splits
        /// </summary>
        [TestCase]
        public class PNWaySplits_Elective_Network_Ranked : PNWaySplits_NoCleanup
        {
            protected override void Execute()
            {
                MultiSplitCmd splits = new MultiSplitCmd(
                    new ElectiveSplitCmd(PlayAndDeleteSessionCmds(), true),
                    new NetworkSplitCmd(PlayAndDeleteSessionCmds())
                    );
                Execute(SessionType.Ranked, splits);
            }
        }

        /// <summary>
        /// Elective (delete original session) and Network (continue original session) splits
        /// </summary>
        [TestCase]
        public class PNWaySplits_Elective_Network_Social : PNWaySplits_NoCleanup
        {
            protected override void Execute()
            {
                MultiSplitCmd splits = new MultiSplitCmd(
                    new ElectiveSplitCmd(PlayAndDeleteSessionCmds(), true),
                    new NetworkSplitCmd(PlayAndDeleteSessionCmds())
                    );
                Execute(SessionType.Social, splits);
            }
        }

        [TestCase]
        public class PNWaySplits_To_3_Tiers_Ranked : TestBase
        {
            override protected void Execute()
            {
                // There are now 4 sessions in tier 3, spawned from the 2 tier 2 sessions
                MultiCommand tier3Cmds = PlayAndDeleteSessionCmds();

                // These are the splits that will operate on the tier 2 sessions
                MultiSplitCmd tier2Splits = new MultiSplitCmd(
                    new NetworkSplitCmd(tier3Cmds),
                    new NetworkSplitCmd(tier3Cmds)
                    );

                // There are now 2 sessions in tier 2, spawned from the base session
                MultiCommand tier2Cmds = new MultiCommand(
                    new JoinCmd(8, 8),
                    tier2Splits,
                    new VerifySessionCmd(),
                    new DeleteCmd()
                    );

                // These are the splits that will operate on the original, base session
                MultiSplitCmd tier1Splits = new MultiSplitCmd(
                    new HostDCSplitCmd(tier2Cmds),
                    new NetworkSplitCmd(tier2Cmds)
                    );

                // This is the original, base session
                MultiCommand tier1Cmds = new MultiCommand(
                    new CreateCmd(SessionType.Ranked),
                    new JoinCmd(8, 8),
                    tier1Splits,
                    new VerifySessionCmd()
                    );

                MatchState state = new MatchState();
                CommandEngine.Execute(
                    state,
                    tier1Cmds
                    );
                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase]
        public class PNWaySplits_To_3_Tiers_Social : TestBase
        {
            override protected void Execute()
            {
                // There are now 4 sessions in tier 3, spawned from the 2 tier 2 sessions
                MultiCommand tier3Cmds = PlayAndDeleteSessionCmds();

                // These are the splits that will operate on the tier 2 sessions
                MultiSplitCmd tier2Splits = new MultiSplitCmd(
                    new NetworkSplitCmd(tier3Cmds),
                    new NetworkSplitCmd(tier3Cmds)
                    );

                // There are now 2 sessions in tier 2, spawned from the base session
                MultiCommand tier2Cmds = new MultiCommand(
                    new JoinCmd(8, 8),
                    tier2Splits,
                    new VerifySessionCmd(),
                    new DeleteCmd()
                    );

                // These are the splits that will operate on the original, base session
                MultiSplitCmd tier1Splits = new MultiSplitCmd(
                    new HostDCSplitCmd(tier2Cmds),
                    new NetworkSplitCmd(tier2Cmds)
                    );

                // This is the original, base session
                MultiCommand tier1Cmds = new MultiCommand(
                    new CreateCmd(SessionType.Social),
                    new JoinCmd(8, 8),
                    tier1Splits,
                    new VerifySessionCmd()
                    );

                MatchState state = new MatchState();
                CommandEngine.Execute(
                    state,
                    tier1Cmds
                    );
                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// Verify all sessions were cleaned up by deferred deletion correctly
        /// </summary>
        [TestCase]
        public class PVerifySessionsCleanedUp : TestBase
        {
            protected override void Execute()
            {
                if (MatchSession.MatchSessionMgr.RegisteredSessionsCount == 0)
                {
                    ResultCode = TEST_RESULTS.NOT_EXECUTED;
                    return;
                }
                Global.RO.Info("Executing PVerifySessionsCleanedUp (this is expected to take a little time...)");
                if (!MatchSession.MatchSessionMgr.VerifyAllSessionsDeleted())
                {
                    throw new UnexpectedTestResultException("Not all sessions were cleaned up in time.");
                }
                ResultCode = TEST_RESULTS.PASSED;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XMatchTest\Func2SearchSessionByIds.cs ===
using System;
using System.Threading;
using System.Collections;
using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.LiveService.Matchmaking;
using ServerTestFramework.Utilities;
using xonline.common.config;

namespace XMatchTest
{
    [TestGroup, Owner("jeffng"), TestFrequency("Regression")]
    public class Func2SearchSessionByIds : TestNode
    {

        [TestGroupSetup]
        public void Setup()
        {
            //make sure table is cleaned out before we begin.
            Global.RO.Info("Cleaning tables before run for title " + Constants.XENON_TITLE.ToString("X"));
            MatchUtil.TruncateSessionsForTitle(Constants.XENON_TITLE, SessionType.Social);
        }

        /////////////////Some helpers for the FindSessionByIDs cases./////////////////////

        //default titleid to be Constants.XENON_TITLE.
        public static bool FindExistingSessionByIDs(byte[] sessionIDs, out XRL2SearchResults searchResults) {
            return FindExistingSessionByIDs(sessionIDs, Constants.XENON_TITLE, 0, out searchResults);
        }

        //default expectedErr to be 0.
        public static bool FindExistingSessionByIDs(byte[] sessionIDs, uint titleID, out XRL2SearchResults searchResults) {
            return FindExistingSessionByIDs(sessionIDs, 0, 0, out searchResults);
        }

        public static bool FindExistingSessionByIDs(byte[] sessionIDs, uint titleID, uint expectedErr, out XRL2SearchResults searchResults) {
            XRL2SearchSession searchReq = new XRL2SearchSession(false, Constants.X_SSINDEX_GET_SESSION_LIST);
            searchReq.baseSearchSession.dwTitleID = titleID;
            XRLXeAttribParam[] Params = new XRLXeAttribParam[1] {
                new XRLXeAttribParam(Constants.X_ATTRIBUTE_SESSION_ID_LIST,
                                     sessionIDs) };
            searchReq.AddParams(Params);
            if (!searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out searchResults))
            {
                if (expectedErr == searchReq.XErr) {
                    Global.RO.Success("Received " + expectedErr.ToString("X") + " as expected.");
                    return true;
                } else {
                    Global.RO.Warn("FindSessionByIds failed with the following error:" + Global.XErrToString(searchReq.XErr));
                    return false;
                }
            }
            return false;
        }

        //take an ArrayList of sessionIDs and convert them one by one to fill a byte array.
        public static byte[] CreateByteArrayOfSessionIDs(ArrayList sessionIDs) {
            byte [] retval = new byte[sessionIDs.Count * 8];
            for (int i=0; i< sessionIDs.Count; i++) {
                SessionID sID = (SessionID) sessionIDs[i];
                Array.Copy((byte[])sID, 0, retval, i*8, 8);
            }
            return retval;
        }

        //sets a sessionID in a byte array to be invalid.  The sessionIdIndex is how many
        //eight-byte units we need to shift over before we start making garbage.  Modifies in place.
        public static void InvalidateSessionId(byte [] byteArrayOfSessIDs, int sessionIdIndex) {
            SessionID invalidId = new SessionID((long) 0x0EADBEEFDEADBEEF);
            
            //overwrite the one we want to invalidate.
            for (int i=sessionIdIndex; i< sessionIdIndex+1; i++) {
                Array.Copy((byte[])invalidId, 0, byteArrayOfSessIDs, i*8, 8);
            }
        }


        public static void PrintSessIDs(ArrayList sessionIDs) {
            Global.RO.Info("SessionIDs are as follows:");
            foreach(SessionID sID in sessionIDs) {
                Global.RO.Info(sID.ToString());
            }
        }
        public static void PrintSessIDs(byte [] sessionIDs) {
            Global.RO.Info("SessionIDs are as follows:");
            for (int i=0; i<sessionIDs.Length/8; i++ ) {
                Global.RO.Info(getNthSessionId(sessionIDs, i).ToString());
            }
        }
        
        //return the nth SessionID in this blob.
        public static SessionID getNthSessionId(byte [] byteArrayOfIds, int index) {
            byte [] thisID = new byte[8];
            Array.Copy(byteArrayOfIds, index*8, thisID, 0, 8);
            return new SessionID(thisID);
        }

        public static bool VerifyVsSessionIDList(byte [] repeatIDs, XRL2SearchResults searchResults) {
            if ((repeatIDs.Length/8) != searchResults.results.Length) {
                Global.RO.Error("Different number of IDs when verifying vs sessionIDList.");
                return false;
            }
            for (int i=0; i<searchResults.results.Length; i++) {
                XRL2SingleSearchResult oneResult = searchResults.results[i];
                SessionID id = new SessionID(oneResult.SessionID);
                if ((id.ToString()) != getNthSessionId(repeatIDs, i).ToString()) {
                    return false;
                }
            }
            return true;
        }

        //verify all sessions exist.  Deletes sessions out of the session set that is passed in.
        public static bool VerifyAndRemoveAllSessions(MatchSessionSet sessions, XRL2SearchResults searchResults) {
            bool foundExtra = false;
            foreach (XRL2SingleSearchResult oneResult in searchResults.results) {
                SessionID id = new SessionID(oneResult.SessionID);
                Global.RO.Info("Found sessionID:" + id);
                if (!sessions.DeleteSession(id)) {
                    foundExtra = true;
                }
            }
            if (sessions.IsEmpty()) {
                Global.RO.Success("All sessions were found in the search.");                    
                if (!foundExtra) { 
                    return true;
                } else {
                    Global.RO.Error("Extra unexpected sessions were found!");
                }
            } else {
                Global.RO.Error("Some sessions were not found in the search.");
            }
            return false;
        }

        [TestCase, Description("Mainline call of FindSessionByIDs.  Create five sessions and attempt to find them.")]
        class PFindSessionByIds_Mainline : TestBase
        {
            override protected void Execute()
            {    
                MatchSessionSet sessions = new MatchSessionSet();
                for (int i=0; i<5; i++) {
                    sessions.AddSession(new MatchSession());
                }
                PrintSessIDs(sessions.GetSessionIDs());
                byte [] byteArrayOfSessIDs = CreateByteArrayOfSessionIDs(sessions.GetSessionIDs());
                    
                XRL2SearchResults searchResults;
                FindExistingSessionByIDs(byteArrayOfSessIDs, out searchResults);

                if (VerifyAndRemoveAllSessions(sessions, searchResults)) {
                    ResultCode=TEST_RESULTS.PASSED;
                }
            }
        }

        [TestCase, Description("Create just one session and attempt to find it.")]
        class PFindSessionByIds_One : TestBase
        {
            override protected void Execute()
            {    
                MatchSessionSet sessions = new MatchSessionSet();
                for (int i=0; i<1; i++) {
                    sessions.AddSession(new MatchSession());
                }
                PrintSessIDs(sessions.GetSessionIDs());
                byte [] byteArrayOfSessIDs = CreateByteArrayOfSessionIDs(sessions.GetSessionIDs());
                    
                XRL2SearchResults searchResults;
                FindExistingSessionByIDs(byteArrayOfSessIDs, out searchResults);

                if (VerifyAndRemoveAllSessions(sessions, searchResults)) {
                    ResultCode=TEST_RESULTS.PASSED;
                }
            }
        }

        [TestCase, Description("Create fifty sessions and attempt to find them.")]
        class PFindSessionByIds_Fifty : TestBase
        {
            override protected void Execute()
            {    
                MatchSessionSet sessions = new MatchSessionSet();
                for (int i=0; i<50; i++) {
                    sessions.AddSession(new MatchSession());
                }
                byte [] byteArrayOfSessIDs = CreateByteArrayOfSessionIDs(sessions.GetSessionIDs());
                    
                XRL2SearchResults searchResults;
                FindExistingSessionByIDs(byteArrayOfSessIDs, out searchResults);

                if (VerifyAndRemoveAllSessions(sessions, searchResults)) {
                    ResultCode=TEST_RESULTS.PASSED;
                }
            }
        }

        [TestCase, Description("Create one hundred sessions and attempt to find them.")]
        class PFindSessionByIds_Hundred : TestBase
        {
            override protected void Execute()
            {    
                MatchSessionSet sessions = new MatchSessionSet();
                for (int i=0; i<100; i++) {
                    sessions.AddSession(new MatchSession());
                }
                byte [] byteArrayOfSessIDs = CreateByteArrayOfSessionIDs(sessions.GetSessionIDs());
                    
                XRL2SearchResults searchResults;
                FindExistingSessionByIDs(byteArrayOfSessIDs, out searchResults);

                if (VerifyAndRemoveAllSessions(sessions, searchResults)) {
                    ResultCode=TEST_RESULTS.PASSED;
                }
            }
        }

        [TestCase, Description("Add a session ID that is valid, but isn't present in the database.")]
        class PFindSessionByIds_SessionMissing : TestBase
        {
            override protected void Execute()
            {    
                MatchSessionSet sessions = new MatchSessionSet();
                SessionID missingSessionID = null;
                for (int i=0; i<5; i++) {
                    if (i == 3) {
                        //we create the session so we know the id is valid, but then straightaway
                        //delete it from the DB.
                        MatchSession tempSession = new MatchSession();
                        sessions.AddSession(tempSession);
                        missingSessionID = tempSession.GetSessionID();
                        MatchUtil.DeleteSession((byte []) tempSession.GetSessionID(), tempSession.TitleID);
                    } else {
                        sessions.AddSession(new MatchSession());
                    }
                }
                PrintSessIDs(sessions.GetSessionIDs());
                byte [] byteArrayOfSessIDs = CreateByteArrayOfSessionIDs(sessions.GetSessionIDs());
                //now that we have the byte array we request, we remove the session from the hash as
                //well, expecting it not to be returned.
                sessions.DeleteSession(missingSessionID);
                    
                //otherwise we now expect an exact match.
                XRL2SearchResults searchResults;
                FindExistingSessionByIDs(byteArrayOfSessIDs, out searchResults);

                if (VerifyAndRemoveAllSessions(sessions, searchResults)) {
                    ResultCode=TEST_RESULTS.PASSED;
                }
            }
        }

        [TestCase, Description("Add a session ID that is valid, but isn't present in the database.")]
        class PFindSessionByIds_OneSessionMissing : TestBase
        {
            override protected void Execute()
            {    
                MatchSessionSet sessions = new MatchSessionSet();
                SessionID missingSessionID = null;
                for (int i=0; i<5; i++) {
                    if (i == 3) {
                        //we create the session so we know the id is valid, but then straightaway
                        //delete it from the DB.
                        MatchSession tempSession = new MatchSession();
                        sessions.AddSession(tempSession);
                        missingSessionID = tempSession.GetSessionID();
                        MatchUtil.DeleteSession((byte []) tempSession.GetSessionID(), tempSession.TitleID);
                    } else {
                        sessions.AddSession(new MatchSession());
                    }
                }
                PrintSessIDs(sessions.GetSessionIDs());
                byte [] byteArrayOfSessIDs = CreateByteArrayOfSessionIDs(sessions.GetSessionIDs());
                //now that we have the byte array we request, we remove the session from the hash as
                //well, expecting it not to be returned.
                sessions.DeleteSession(missingSessionID);
                    
                //otherwise we now expect an exact match.
                XRL2SearchResults searchResults;
                FindExistingSessionByIDs(byteArrayOfSessIDs, out searchResults);

                if (VerifyAndRemoveAllSessions(sessions, searchResults)) {
                    ResultCode=TEST_RESULTS.PASSED;
                }
            }
        }

        [TestCase, Description("Add many sessionIDs that are valid but aren't present in the database.")]
        class PFindSessionByIds_ManySessionsMissing : TestBase
        {
            override protected void Execute()
            {    
                MatchSessionSet sessions = new MatchSessionSet();
                MatchSessionSet missingSessions = new MatchSessionSet();

                for (int i=0; i<50; i++) {
                    if (i % 2 == 1) {
                        //we create the session so we know the id is valid, but then straightaway
                        //delete it from the DB.
                        MatchSession tempSession = new MatchSession();
                        sessions.AddSession(tempSession);
                        missingSessions.AddSession(tempSession);
                        MatchUtil.DeleteSession((byte []) tempSession.GetSessionID(), tempSession.TitleID);
                    } else {
                        sessions.AddSession(new MatchSession());
                    }
                }
                PrintSessIDs(sessions.GetSessionIDs());
                byte [] byteArrayOfSessIDs = CreateByteArrayOfSessionIDs(sessions.GetSessionIDs());
                //now that we have the byte array we request, we remove the sessions from the hash as
                //well, expecting it not to be returned.
                foreach (SessionID id in missingSessions.GetSessionIDs()) {
                    sessions.DeleteSession(id);
                }
                    
                //otherwise we now expect an exact match.
                XRL2SearchResults searchResults;
                FindExistingSessionByIDs(byteArrayOfSessIDs, out searchResults);

                if (VerifyAndRemoveAllSessions(sessions, searchResults)) {
                    ResultCode=TEST_RESULTS.PASSED;
                }
            }
        }

        [TestCase, Description("Add sessions for two different modes on the same server and attempt to find them..")]
        class PFindSessionByIds_DifferentModesOnSameServer : TestBase
        {
            override protected void Execute()
            {    
                MatchSessionSet sessions = new MatchSessionSet();

                for (int i=0; i<6; i++) {
                    MatchSession session = new MatchSession(false);
                    //set titleid to the partitioned one

                    session.TitleID = Constants.XENON_TITLE;
                    //every other session goes into a different server.

                    if (i % 2 == 0) {
                        session.UpdateAttrib(new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE, 
                                                                  new XRLXeIntValue(Constants.CONTEXT_GAME_MODE_MODEA)), false);
                    } else {
                        session.UpdateAttrib(new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE, 
                                                                  new XRLXeIntValue(Constants.CONTEXT_GAME_MODE_MODEB)), false);
                    }
                    session.Create();
                    sessions.AddSession(session);
                }
                PrintSessIDs(sessions.GetSessionIDs());
                byte [] byteArrayOfSessIDs = CreateByteArrayOfSessionIDs(sessions.GetSessionIDs());
                    
                XRL2SearchResults searchResults;
                FindExistingSessionByIDs(byteArrayOfSessIDs, Constants.XENON_TITLE, 0, out searchResults);

                if (VerifyAndRemoveAllSessions(sessions, searchResults)) {
                    ResultCode=TEST_RESULTS.PASSED;
                }
            }
        }


        [TestCase, Description("Add sessions for two different partitions and attempt to find them..")]
        class PFindSessionByIds_DifferentPartitions : TestBase
        {
            override protected void Execute()
            {    
                MatchSessionSet sessions = new MatchSessionSet();

                for (int i=0; i<6; i++) {
                    MatchSession session = new MatchSession(false);
                    //set titleid to the partitioned one

                    session.TitleID = Constants.XENON_PARTITIONED_TITLE;
                    //every other session goes into a different server.

                    if (i % 2 == 0) {
                        session.UpdateAttrib(new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE, 
                                                                  new XRLXeIntValue(Constants.CONTEXT_GAME_MODE_MODEA)), false);
                    } else {
                        session.UpdateAttrib(new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE, 
                                                                  new XRLXeIntValue(Constants.CONTEXT_GAME_MODE_MODEB)), false);
                    }
                    session.Create();
                    sessions.AddSession(session);
                }
                PrintSessIDs(sessions.GetSessionIDs());
                byte [] byteArrayOfSessIDs = CreateByteArrayOfSessionIDs(sessions.GetSessionIDs());
                    
                XRL2SearchResults searchResults;
                FindExistingSessionByIDs(byteArrayOfSessIDs, Constants.XENON_PARTITIONED_TITLE, 0, out searchResults);

                if (VerifyAndRemoveAllSessions(sessions, searchResults)) {
                    ResultCode=TEST_RESULTS.PASSED;
                }
            }
        }


        [TestCase, Description("Add many sessionIDs that are valid and partitioned but are not in the right title.")]
        class PFindSessionByIds_DifferentPartitionsAndWrongTitle : TestBase
        {
            override protected void Execute()
            {    
                MatchSessionSet sessions = new MatchSessionSet();

                for (int i=0; i<6; i++) {
                    MatchSession session = new MatchSession(false);
                    //set titleid to the partitioned one

                    session.TitleID = Constants.XENON_PARTITIONED_TITLE;
                    //every other session goes into a different server.

                    if (i % 2 == 0) {
                        session.UpdateAttrib(new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE, 
                                                                  new XRLXeIntValue(Constants.CONTEXT_GAME_MODE_MODEA)), false);
                    } else {
                        session.UpdateAttrib(new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE, 
                                                                  new XRLXeIntValue(Constants.CONTEXT_GAME_MODE_MODEB)), false);
                    }
                    session.Create();
                    sessions.AddSession(session);
                }
                PrintSessIDs(sessions.GetSessionIDs());
                byte [] byteArrayOfSessIDs = CreateByteArrayOfSessionIDs(sessions.GetSessionIDs());
                    
                XRL2SearchResults searchResults;
                FindExistingSessionByIDs(byteArrayOfSessIDs, Constants.XENON_TITLE, 0, out searchResults);

                //we should see nothing.
                if (searchResults == null) {
                    ResultCode=TEST_RESULTS.PASSED;
                }
            }
        }


        [TestCase, Description("Make an empty find call.")]
        class NFindSessionByIds_Zero : TestBase
        {
            override protected void Execute()
            {    
                XRL2SearchResults searchResults;
                if (FindExistingSessionByIDs(new byte[0], Constants.XENON_TITLE, 0x80155119, out searchResults)) {
                    ResultCode=TEST_RESULTS.PASSED;
                }
            }
        }


        [TestCase, Description("Create 101 sessions and find.  Should fail.")]
        class NFindSessionByIds_HundredOne : TestBase
        {
            override protected void Execute()
            {    
                MatchSessionSet sessions = new MatchSessionSet();
                for (int i=0; i<101; i++) {
                    sessions.AddSession(new MatchSession());
                }
                PrintSessIDs(sessions.GetSessionIDs());
                byte [] byteArrayOfSessIDs = CreateByteArrayOfSessionIDs(sessions.GetSessionIDs());
                    
                XRL2SearchResults searchResults;
                if (FindExistingSessionByIDs(byteArrayOfSessIDs, Constants.XENON_TITLE, 0x8015510D, out searchResults)) {
                    ResultCode=TEST_RESULTS.PASSED;                    
                }

            }
        }

        [TestCase, Description("Create an invalid ID in the middle of the list.")]
        class NFindSessionByIds_InvalidIdInMiddle : TestBase
        {
            override protected void Execute()
            {    
                const int SESS_TO_REPLACE = 2;
                MatchSessionSet sessions = new MatchSessionSet();
                SessionID sessionToReplace = null;
                for (int i=0; i<5; i++) {
                    MatchSession session = new MatchSession();
                    sessions.AddSession(session);
                    if (i == SESS_TO_REPLACE) {
                        sessionToReplace = session.GetSessionID();
                    } 
                }
                byte [] byteArrayOfSessIDs = CreateByteArrayOfSessionIDs(sessions.GetSessionIDs());
                InvalidateSessionId(byteArrayOfSessIDs, SESS_TO_REPLACE);
                PrintSessIDs(byteArrayOfSessIDs);

                XRL2SearchResults searchResults;
                //I changed this to expect XONLINE_E_MATCH_SERVER_ERROR, because we're passing in a garbage
                //session ID, and that now returns an error, which is reasonable.
                if(FindExistingSessionByIDs(byteArrayOfSessIDs, Constants.XENON_TITLE, 
                    HResult.XONLINE_E_MATCH_SERVER_ERROR, out searchResults))
                {
                    ResultCode = TEST_RESULTS.PASSED;
                }
            }
        }

        [TestCase, Description("Repeat IDs in the list.")]
        class NFindSessionByIds_RepeatIds : TestBase
        {
            override protected void Execute()
            {    
                MatchSessionSet sessions = new MatchSessionSet();
                for (int i=0; i<6; i++) {
                    sessions.AddSession(new MatchSession());
                }
                byte [] byteArrayOfSessIDs = CreateByteArrayOfSessionIDs(sessions.GetSessionIDs());
                byte [] repeatIDs = new byte[byteArrayOfSessIDs.Length * 2];
                //let's duplicate the arraycopystf copy %INETROOT%\private\test\StfTests\libd\i386\*.* \\xeclisxxx010\e$\jeffng\stftests\

                Array.Copy(byteArrayOfSessIDs, 0, repeatIDs, 0, byteArrayOfSessIDs.Length);
                Array.Copy(byteArrayOfSessIDs, 0, repeatIDs, byteArrayOfSessIDs.Length, byteArrayOfSessIDs.Length);
                PrintSessIDs(repeatIDs);

                XRL2SearchResults searchResults;
                FindExistingSessionByIDs(repeatIDs, out searchResults);

                //Repeats should occur in the search results exactly.
                if (VerifyVsSessionIDList(repeatIDs, searchResults)) {
                    ResultCode=TEST_RESULTS.PASSED;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XMatchTest\Func2UpdateSession_Partitioning.cs ===
using System;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.LiveService.Matchmaking;
using xonline.common.config;

namespace XMatchTest
{
    //This test group covers the state transitions of breadcrumbs, or every way an update can
    //affect(or not affect) a breadcrumb.  This is focused solely on updates.

    //To make this effective in a breadcrumbing world, we'd need to create a new title with game
    //mode A, B, and C set to different servers.
    //To make case 4 work we will temporarily modify the environment (testnet, stressnet) to use the
    //other environment's title sql server as a temporary third server.  Then we will have to point
    //C to this third server.  This won't be done for now, because it's very environment specific.
    [TestGroup]
    public class Func2UpdateSession_Partitioning : TestNode
    {
        
        //1.
        [TestCase, Description("Create a session, and change the game mode such that it moves to a new server.")]
        class PUpdateModeOnce : Update2TestBase
        {
            override protected void Execute()
            {
                bool success = true;
                const string HOSTNAME = "PartitioningTest1\0";
                MatchSession testSession = MatchPartUtil.CreateGenericSession(HOSTNAME);

                //Let's change the mode and hop to the new DB
                testSession.UpdateAttrib(new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE, 
                                                              new XRLXeIntValue(Constants.CONTEXT_GAME_MODE_MODEB)));

                success = MatchPartUtil.PositiveVerify(testSession) && success;
                testSession.Delete();
                success = MatchPartUtil.NegativeVerify(testSession) && success;
                if (success) ResultCode=TEST_RESULTS.PASSED;
            }
        }
        
        //2.1
        [TestCase, Description("Create a session, and change a variable besides mode.  Expect no breadcrumbing to occur.")]
        class PUpdateNonModeAttribute : Update2TestBase
        {
            override protected void Execute()
            {
                bool success = true;
                
                const string HOSTNAME1 = "PartitioningTest2_1BeforeChange\0";
                MatchSession testSession = MatchPartUtil.CreateGenericSession(HOSTNAME1);

                const string HOSTNAME2 = "PartitioningTest2_1AfterChange\0";
                
                //Let's change something small and unrelated...
                testSession.UpdateAttrib(new XRLXeAttribParam(Constants.X_ATTRIBUTE_HOST_NAME, 
                                                              new XRLXeStringValue(HOSTNAME2)));
                success = MatchPartUtil.PositiveVerify(testSession) && success;
                testSession.Delete();
                success = MatchPartUtil.NegativeVerify(testSession) && success;
                if (success) ResultCode=TEST_RESULTS.PASSED;
            }
        }

        //2.2
        //!For now this changes the settings to the same settings as before.  In the future we need
        //to craft a title.
        [TestCase, Description("Create a session, and change mode, but have the mode point to the same server.")]
        class PUpdateModeToSameServer : Update2TestBase
        {
            override protected void Execute()
            {
                bool success = true;
                
                const string HOSTNAME1 = "PartitioningTest2_2BeforeChange\0";
                MatchSession testSession = MatchPartUtil.CreateGenericSession(HOSTNAME1);

                const string HOSTNAME2 = "PartitioningTest2_2AfterChange\0";
                
                //Let's change something small and unrelated...
                testSession.UpdateAttrib(new XRLXeAttribParam(Constants.X_ATTRIBUTE_HOST_NAME, 
                                                              new XRLXeStringValue(HOSTNAME2)), 
                                         false);
                //in addition to changing the mode to the old one.
                testSession.UpdateAttrib(new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE,
                                                              new XRLXeIntValue(Constants.CONTEXT_GAME_MODE_MODEA)));

                success = MatchPartUtil.PositiveVerify(testSession) && success;
                testSession.Delete();
                success = MatchPartUtil.NegativeVerify(testSession) && success;
                if (success) ResultCode=TEST_RESULTS.PASSED;
            }
        }

        //3.
        //Create a breadcrumbed session.  Change it back to the original mode.
        [TestCase, Description("Create a breadcrumbed session, and then change mode back to where the session started.")]
        class PUpdateBreadrcrumbedSessionToFirstServer : Update2TestBase
        {
            override protected void Execute()
            {
                bool success = true;
                
                const string HOSTNAME = "PartitioningTest3\0";
                MatchSession testSession = MatchPartUtil.CreateBreadcrumbedSession(HOSTNAME);

                //Change back to the old mode.
                testSession.UpdateAttrib(new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE,
                                                              new XRLXeIntValue(Constants.CONTEXT_GAME_MODE_MODEA)));

                success = MatchPartUtil.PositiveVerify(testSession) && success;
                testSession.Delete();
                success = MatchPartUtil.NegativeVerify(testSession) && success;
                if (success) ResultCode=TEST_RESULTS.PASSED;
            }
        }

        //4.
        //Create a breadcrumbed session.  Change the mode so it hops to a third server.
        [Ignore]
        [TestCase, Description("Create a breadcrumbed session.  Change the mode so it hops to a third server.")]
        class PUpdateBreadrcrumbedSessionToNewServer : Update2TestBase
        {
            override protected void Execute()
            {
                bool success = true;
                
                const string HOSTNAME = "PartitioningTest4\0";
                MatchSession testSession = MatchPartUtil.CreateBreadcrumbedSession(HOSTNAME);
                //store up the two servers present
                string origServer = MatchUtil.FindServerForSession(testSession, true);
                string secondServer = MatchUtil.FindServerForSession(testSession, false);

                //change to a third server.
                testSession.UpdateAttrib(new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE,
                                                              new XRLXeIntValue(Constants.CONTEXT_GAME_MODE_MODEC)));
                string thirdServer = MatchUtil.FindServerForSession(testSession, false);
                if ((origServer == secondServer) || (secondServer == thirdServer) || (origServer == thirdServer)) {
                    Global.RO.Warn("Test results will not be conclusive, as it requires three distinct title sql servers.");
                    Global.RO.Warn("Used servers are:" + origServer + "  " + secondServer + "  " + thirdServer);
                }

                success = MatchPartUtil.PositiveVerify(testSession) && success;
                MatchUtil.SessionDBData dbData = MatchUtil.QueryDBForSessionData(secondServer, testSession);
                if ((dbData != null) && (!dbData.isDeleted)){
                    Global.RO.Error("Not-deleted data for this session was found on the second server, " + secondServer + "!");
                    success = false;
                }

                testSession.Delete();
                success = MatchPartUtil.NegativeVerify(testSession) && success;
                if (success) ResultCode=TEST_RESULTS.PASSED;
            }
        }

        //5.1
        //Create a breadcrumbed session.  Then change a non-mode attribute.
        [TestCase, Description("Create a breadcrumbed session, and then change a non-mode attrib.")]
        class PUpdateBreadrcrumbedSessionNonMode : Update2TestBase
        {
            override protected void Execute()
            {
                bool success = true;
                
                const string HOSTNAME1 = "PartitioningTest5_1BeforeChange\0";
                MatchSession testSession = MatchPartUtil.CreateBreadcrumbedSession(HOSTNAME1);

                //change just the name
                const string HOSTNAME2 = "PartitioningTest5_1AfterChange\0";
                testSession.UpdateAttrib(new XRLXeAttribParam(Constants.X_ATTRIBUTE_HOST_NAME, 
                                                              new XRLXeStringValue(HOSTNAME2)));

                success = MatchPartUtil.PositiveVerify(testSession) && success;
                testSession.Delete();
                success = MatchPartUtil.NegativeVerify(testSession) && success;
                if (success) ResultCode=TEST_RESULTS.PASSED;
            }
        }

        //5.2
        //Create a breadcrumbed session, and then change the mode to something that points to the
        //same server.
        [TestCase, Description("Create a breadcrumbed session, and then change mode to the same server.")]
        class PUpdateBreadrcrumbedSessionMode : Update2TestBase
        {
            override protected void Execute()
            {
                bool success = true;
                
                const string HOSTNAME = "PartitioningTest5_2\0";
                MatchSession testSession = MatchPartUtil.CreateBreadcrumbedSession(HOSTNAME);

                //Change the mode to where it currently is.
                testSession.UpdateAttrib(new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE,
                                                              new XRLXeIntValue(Constants.CONTEXT_GAME_MODE_MODEB)));

                success = MatchPartUtil.PositiveVerify(testSession) && success;
                testSession.Delete();
                success = MatchPartUtil.NegativeVerify(testSession) && success;
                if (success) ResultCode=TEST_RESULTS.PASSED;
            }
        }
                
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XMatchTest\FuncCreateSession.cs ===
using System;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Matchmaking;
using xonline.common.config;

namespace XMatchTest
{
    internal abstract class CreateTestBase : TestBase
    {
        protected bool CreateAndVerify(XRLCreateUpdateSession Req)
        {
            XRLSessionInfo        resp;
            bool                ret = true;
            if (!Req.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out resp))
            {
                Global.RO.Warn("CreateSession request failed:" + Global.XErrToString(Req.XErr));
                return false;
            }
            // search for session based on sessionID
            // spindex=5 returns no additional attributes
            XRLSearchResults    searchResults;
            XRLSearchSession    searchReq = new XRLSearchSession(Constants.X_SSINDEX_GET_SESSION);
            // convert byte[8] to long; integer is little endian on the wire:
            // 01020304 on the wire is actually interpreted as int=0x04030201 internally
            // little endian locally
            long    lSessID = Constants.sessionIDConvert(resp.SessionID);
            XRLAttribParam[]            Params = new XRLAttribParam[1]{new XRLAttribParam(Constants.X_ATTRIBUTE_DATATYPE_INTEGER,new XRLIntParam(lSessID))};
            searchReq.AddParams(Params);

            if(!searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out searchResults))
            {
                Global.RO.Warn("search for the newly created session failed:"+Global.XErrToString(searchReq.XErr));
                ret = false;
                goto Exit;
            }
            if(searchResults == null)
            {
                Global.RO.Warn("The newly created session couldn't be found");
                ret = false;
                goto Exit;
            }
            // check if session created correctly in the t_match_sessions_<title>
            if(!Req.Verify(searchResults))
            {
                Global.RO.Warn("The session is not setup correctly in the db");
                ret = false;
                goto Exit;
            }
            // delete the session
            Exit:
            XRLDeleteSession    delReq = new XRLDeleteSession(resp.SessionID);
            if(!delReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd)))
            {
                Global.RO.Warn("Session deletion failed");
                ret = false;
            }
            return ret;
        }
    }
    internal abstract class NegativeCreateTestBase : TestBase
    {
        protected bool CreateTestNegative(XRLCreateUpdateSession Req, uint XErr)
        {
            XRLSessionInfo        resp;
            if (Req.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out resp))
            {
                Global.RO.Warn("Negative CreateSession request succeed unexpectedly");
                XRLDeleteSession    delReq = new XRLDeleteSession(resp.SessionID);
                delReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                return false;
            }
            if((Req.XErr != XErr) || (resp != null))
            {
                Global.RO.Warn("Wrong error code (" + Global.XErrToString(Req.XErr) + " != " + Global.XErrToString(XErr) + ") returned or response is not null");
                return false;
            }
            return true;
        }
    }
    // there are lots of createSession test cases that were covered in the
    // searchSession cases: session with multiple attributes, etc
    //
    // These tests are deprecated, as Xbox1 support is removed.  These will be deleted in the next release.
    [TestGroup, Ignore]
    public class FuncCreateSession : TestNode
    {
        /***********************************************************************
         * The followings are positive cases
         ***********************************************************************/
        [BVT]
        [TestCase, Description("Create a session with no attributes")]
			class PNormalCase : CreateTestBase
        {
            override protected void Execute()
            {
                XRLCreateUpdateSession    req = new XRLCreateUpdateSession();
                if(CreateAndVerify(req))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("Create a session with a title-specific int attribute")]
			class PIntAttrib : CreateTestBase
        {
            override protected void Execute()
            {
                XRLCreateUpdateSession    req = new XRLCreateUpdateSession();
                WireData[]    atts = new WireData[1]{new XRLIntAttribute(Constants.SAMPLE_INT_ATTRIB,0x8989)};
                req.AddAttribs(atts);

                // verification of int attributes will be done in the searchSession test cases.
                if(CreateAndVerify(req))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("Create a session with a title-specific session 400 char string attribute")]
			class PMaxStringAttrib : CreateTestBase
        {
            override protected void Execute()
            {
                XRLCreateUpdateSession    req = new XRLCreateUpdateSession();
                string strValue = new string('a',(int)Constants.X_MAX_STRING_ATTRIBUTE_LEN);
                strValue += '\0';
                WireData[]    atts = new WireData[1]{new XRLStringAttribute(Constants.SAMPLE_STRING_ATTRIB,strValue)};
                req.AddAttribs(atts);

                // verification of string attributes will be done in the searchSession test cases.
                if(CreateAndVerify(req))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("Create a session with a title-specific session 800-byte blob attribute")]
			class PMaxBlobAttrib : CreateTestBase
        {
            override protected void Execute()
            {
                XRLCreateUpdateSession    req = new XRLCreateUpdateSession();
                byte[] blobAttrib = new byte[Constants.X_MAX_BLOB_ATTRIBUTE_LEN];
                new Random().NextBytes(blobAttrib);
                WireData[]    atts = new WireData[1]{new XRLBlobAttribute(Constants.SAMPLE_BLOB_ATTRIB,blobAttrib)};
                req.AddAttribs(atts);

                // verification of blob attributes will be done in the searchSession test cases.
                if(CreateAndVerify(req))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("Create a session with a title-specific session zero-len blob attribute")]
			class PZeroLenBlobAttrib : CreateTestBase
        {
            override protected void Execute()
            {
                XRLCreateUpdateSession    req = new XRLCreateUpdateSession();
                byte[] blobAttrib = new byte[0];
                WireData[]    atts = new WireData[1]{new XRLBlobAttribute(Constants.SAMPLE_BLOB_ATTRIB,blobAttrib)};
                req.AddAttribs(atts);

                // verification of blob attributes will be done in the searchSession test cases.
                if(CreateAndVerify(req))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("Create a session with an empty title session string(only have '\\0')attribute")]
			class PEmptyStringAttrib : CreateTestBase
        {
            override protected void Execute()
            {
                XRLCreateUpdateSession    req = new XRLCreateUpdateSession();
                // actually string length is 1, on the wire is shows "00"
                String    strValue = "\0";
                WireData[]    atts = new WireData[1]{new XRLStringAttribute(Constants.SAMPLE_STRING_ATTRIB,strValue)};
                req.AddAttribs(atts);

                // verification of string attributes will be done in the searchSession test cases.
                if(CreateAndVerify(req))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("Create a session with 16 byte(including '\\0')title session string attribute")]
			class PSmallStringAttrib : CreateTestBase
        {
            override protected void Execute()
            {
                XRLCreateUpdateSession    req = new XRLCreateUpdateSession();
                String    strValue = new string('a',15);
                strValue += '\0';
                WireData[]    atts = new WireData[1]{new XRLStringAttribute(Constants.SAMPLE_STRING_ATTRIB,strValue)};
                req.AddAttribs(atts);

                // verification of string attributes will be done in the searchSession test cases.
                if(CreateAndVerify(req))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("Create a session with public/private available slots set to 0")]
			class PNoAvailableSlots : CreateTestBase
        {
            override protected void Execute()
            {
                XRLCreateUpdateSession    req = new XRLCreateUpdateSession();
                req.baseSession.dwPublicFilled = req.baseSession.dwPublicOpen = 0;
                req.baseSession.dwPrivateOpen = req.baseSession.dwPrivateOpen = 0;
                if(CreateAndVerify(req))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("Create a systemLink xbox session")]
			class PSystemLinkXBoxSession : CreateTestBase
        {
            override protected void Execute()
            {    // system link and open NAT: 0001
                XRLCreateUpdateSession    req = new XRLCreateUpdateSession();
                req.baseSession.SessionID = new byte[]{0x10,0,0,0,0,0,0,0};
                if(CreateAndVerify(req))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("Create a online xbox hosted session")]
			class POnlineXBoxSession : CreateTestBase
        {
            override protected void Execute()
            {    // online xbox hosted and moderate NAT: 1010
                XRLCreateUpdateSession    req = new XRLCreateUpdateSession();
                req.baseSession.SessionID = new byte[]{0xA0,0,0,0,0,0,0,0};
                if(CreateAndVerify(req))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("Create a PC hosted session")]
			class PPcServerSession : CreateTestBase
        {
            override protected void Execute()
            {    // online PC hosted and strict NAT: 1011
                XRLCreateUpdateSession    req = new XRLCreateUpdateSession();
                req.baseSession.SessionID = new byte[]{0xB0,0,0,0,0,0,0,0};
                if(CreateAndVerify(req))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        /***********************************************************************
         * The followings are negative cases
         ***********************************************************************/
        [TestCase, Description("Message Length shorter than the sizeof(XMATCH_SESSION)")]
			class NSmallMsgLen : NegativeCreateTestBase
        {
            override protected void Execute()
            {
                XRLCreateUpdateSession    req = new XRLCreateUpdateSession();
                req.baseSession.dwMessageLength = 1;
                if(CreateTestNegative(req,HResult.XONLINE_E_MATCH_REQUEST_TOO_SMALL))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("Message Length longer than available bytes")]
			class NOverflowMsgLen : NegativeCreateTestBase
        {
            override protected void Execute()
            {
                XRLCreateUpdateSession    req = new XRLCreateUpdateSession();
                req.baseSession.dwMessageLength += 1;
                if(CreateTestNegative(req,HResult.XONLINE_E_MATCH_REQUEST_TRUNCATED))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("create a session with unknown titleID")]
			class NUnknowTitleID : NegativeCreateTestBase
        {
            override protected void Execute()
            {
                XRLCreateUpdateSession    req = new XRLCreateUpdateSession();
                req.baseSession.dwTitleID = Constants.TITLE_ID + 1;
                if(CreateTestNegative(req,HResult.XONLINE_E_MATCH_INVALID_TITLE_ID))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("use a titleID that only exists in t_match_titles, but no matching session table")]
			class NMissingTableTitleID : NegativeCreateTestBase
        {
            override protected void Execute()
            {
                XRLCreateUpdateSession    req = new XRLCreateUpdateSession();
                req.baseSession.dwTitleID = 0x00001111;
                if(CreateTestNegative(req,HResult.XONLINE_E_MATCH_INVALID_TITLE_ID))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("create a session with a non-existent attribute ID")]
			class NNonExistentAttrib : NegativeCreateTestBase
        {
            override protected void Execute()
            {
                XRLCreateUpdateSession    req = new XRLCreateUpdateSession();
                req.baseSession.dwMessageLength += 4+4+8;
                req.AttribOffsetsLen = 1;
                req.AttribOffsets = new uint[1]{Constants.SIZEBASESESSION+4};
                // the title doesn't have 0x8 as attribute
                req.Attribs = new XrlAttributeBase[1];
                req.Attribs[0] = (XrlAttributeBase)(new XRLIntAttribute(0x00000008, 0x12345678));
                if(CreateTestNegative(req,HResult.XONLINE_E_MATCH_INVALID_ATTRIBUTE_ID))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("create a session with 1 attribute, but attrib offset is inside session header")]
			class NWrongAttribOffset1 : NegativeCreateTestBase
        {
            override protected void Execute()
            {
                XRLCreateUpdateSession    req = new XRLCreateUpdateSession();
                req.baseSession.dwMessageLength += 4+4+8;
                req.AttribOffsetsLen = 1;
                req.AttribOffsets = new uint[1]{Constants.SIZEBASESESSION-4};
                // the title doesn't have 0x8 as attribute
                req.Attribs = new XrlAttributeBase[1];
                req.Attribs[0] = (XrlAttributeBase)(new XRLIntAttribute(0x00000001, 0x12345678));
                if(CreateTestNegative(req,HResult.XONLINE_E_MATCH_INVALID_OFFSET))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("create a session with 1 attribute, but attribOffset beyong available")]
			class NWrongAttribOffset2 : NegativeCreateTestBase
        {
            override protected void Execute()
            {
                XRLCreateUpdateSession    req = new XRLCreateUpdateSession();
                req.baseSession.dwMessageLength += 4+4+8;
                req.AttribOffsetsLen = 1;
                req.AttribOffsets = new uint[1]{1000};
                // the title doesn't have 0x8 as attribute
                req.Attribs = new XrlAttributeBase[1];
                req.Attribs[0] = (XrlAttributeBase)(new XRLIntAttribute(0x00000001, 0x12345678));
                if(CreateTestNegative(req,HResult.XONLINE_E_MATCH_INVALID_OFFSET))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("create a session with 1 attribute, but attribOffset equal to current offset")]
			class NWrongAttribOffset3 : NegativeCreateTestBase
        {
            override protected void Execute()
            {
                XRLCreateUpdateSession    req = new XRLCreateUpdateSession();
                req.baseSession.dwMessageLength += 4+4+8;
                req.AttribOffsetsLen = 1;
                req.AttribOffsets = new uint[1]{Constants.SIZEBASESESSION};
                // the title doesn't have 0x8 as attribute
                req.Attribs = new XrlAttributeBase[1];
                req.Attribs[0] = (XrlAttributeBase)(new XRLIntAttribute(0x00000001, 0x12345678));
                if(CreateTestNegative(req,HResult.XONLINE_E_MATCH_INVALID_OFFSET))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("indicate more attributes than available")]
			class NOverflowAttrib : NegativeCreateTestBase
        {
            override protected void Execute()
            {
                XRLCreateUpdateSession    req = new XRLCreateUpdateSession();
                //req.ManualArraySize = true;
                req.AttribOffsetsLen = 1;
                req.AttribOffsets = new uint[0];
                if(CreateTestNegative(req,HResult.XONLINE_E_END_OF_STREAM))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("create session with zero-length title session string attribute")]
			class NZeroLenStringAttrib : NegativeCreateTestBase
        {
            override protected void Execute()
            {
                XRLCreateUpdateSession    req = new XRLCreateUpdateSession();
                // string length is 0
                String    strValue = "";
                WireData[]    atts = new WireData[1]{new XRLStringAttribute(Constants.SAMPLE_STRING_ATTRIB,strValue)};
                req.AddAttribs(atts);

                if(CreateTestNegative(req,HResult.XONLINE_E_MATCH_INVALID_STRING))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("create session with a string attrib whose length goes beyong the number of bytes available")]
			class NOverflowStringAttrib : NegativeCreateTestBase
        {
            override protected void Execute()
            {
                XRLCreateUpdateSession    req = new XRLCreateUpdateSession();
                String    strValue = "abc\0";
                WireData[]    atts = new WireData[1]{new XRLStringAttribute(Constants.SAMPLE_STRING_ATTRIB,strValue)};
                req.AddAttribs(atts);
                req.baseSession.dwMessageLength -= 1;

                if(CreateTestNegative(req,HResult.XONLINE_E_MATCH_REQUEST_TOO_SMALL))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("create session with a string attrib of MAXLEN + 1 bytes(null not included)")]
			class NOverflowStringAttrib2 : NegativeCreateTestBase
        {
            override protected void Execute()
            {
                XRLCreateUpdateSession    req = new XRLCreateUpdateSession();
                String    strValue = new string('b',(int)(Constants.X_MAX_STRING_ATTRIBUTE_LEN+1));
                strValue += '\0';
                WireData[]    atts = new WireData[1]{new XRLStringAttribute(Constants.SAMPLE_STRING_ATTRIB,strValue)};
                req.AddAttribs(atts);

                if(CreateTestNegative(req,HResult.XONLINE_E_MATCH_STRING_TOO_LONG))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("create session with a string attrib longer than that specified in xms file")]
			class NOverflowStringAttrib3 : NegativeCreateTestBase
        {
            override protected void Execute()
            {
                XRLCreateUpdateSession    req = new XRLCreateUpdateSession();
                // the max length of SAMPLE_STRING_ATTRIB2 is 20 in xms
                String    strValue = new string('c',21);
                strValue += '\0';
                WireData[]    atts = new WireData[1]{new XRLStringAttribute(Constants.SAMPLE_STRING_ATTRIB2,strValue)};
                req.AddAttribs(atts);

                if(CreateTestNegative(req,HResult.XONLINE_E_MATCH_OVERFLOW))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("create session with a blob attrib whose length goes beyong the number of bytes available")]
			class NOverflowBlobAttrib : NegativeCreateTestBase
        {
            override protected void Execute()
            {
                XRLCreateUpdateSession    req = new XRLCreateUpdateSession();
                byte [] blobValue = new byte[1]{0x08};
                WireData[]    atts = new WireData[1]{new XRLBlobAttribute(Constants.SAMPLE_BLOB_ATTRIB,blobValue)};
                req.AddAttribs(atts);
                req.baseSession.dwMessageLength -= (uint)blobValue.Length;

                if(CreateTestNegative(req,HResult.XONLINE_E_MATCH_REQUEST_TOO_SMALL))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("create session with a blob attrib of MAXLEN+1")]
			class NOverflowBlobAttrib2 : NegativeCreateTestBase
        {
            override protected void Execute()
            {
                XRLCreateUpdateSession    req = new XRLCreateUpdateSession();
                byte [] blobValue = new byte[Constants.X_MAX_BLOB_ATTRIBUTE_LEN+1];
                new Random().NextBytes(blobValue);
                WireData[]    atts = new WireData[1]{new XRLBlobAttribute(Constants.SAMPLE_BLOB_ATTRIB,blobValue)};
                req.AddAttribs(atts);

                if(CreateTestNegative(req,HResult.XONLINE_E_MATCH_BLOB_TOO_LONG))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("create session with a blob attrib length longer than that specified in xms file")]
			class NOverflowBlobAttrib3 : NegativeCreateTestBase
        {
            override protected void Execute()
            {
                XRLCreateUpdateSession    req = new XRLCreateUpdateSession();
                // the max length for SAMPLE_BLOB_ATTRIB2 is 40
                byte [] blobValue = new byte[41];
                new Random().NextBytes(blobValue);
                WireData[]    atts = new WireData[1]{new XRLBlobAttribute(Constants.SAMPLE_BLOB_ATTRIB2,blobValue)};
                req.AddAttribs(atts);

                if(CreateTestNegative(req,HResult.XONLINE_E_MATCH_OVERFLOW))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
		[TestCase, Description("Bug 38468:send a request with useragent 6/1.0 that is allowed in Tsunami")]
			class PUserAgent : TestBase
		{
			override protected void Execute()
			{
				XRLCreateUpdateSession		req = new XRLCreateUpdateSession();
				XRLSessionInfo				resp;
				req.CustomHeader = @"User-Agent: 6/1.0" + "\r\n";
				if (req.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out resp))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("Bug Xonline 40574:send a request with useragent 6/1.0.4567.1 that is allowed in Tsunami")]
			class PUserAgent2 : TestBase
		{
			override protected void Execute()
			{
				XRLCreateUpdateSession		req = new XRLCreateUpdateSession();
				XRLSessionInfo				resp;
				req.CustomHeader = @"User-Agent: 6/1.0.4567.1" + "\r\n";
				if (req.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out resp))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XMatchTest\Func2UpdateSession.cs ===
using System;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Matchmaking;
using xonline.common.config;

namespace XMatchTest
{
    internal abstract class NegativeUpdate2TestBase : TestBase
    {
        protected bool UpdateTestNegative(XRL2CreateUpdateSession Req, uint XErr)
        {
            if (Req.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd)))
            {
                Global.RO.Warn("Negative UpdateSession request succeed unexpectedly");
                return false;
            }
            if (Req.XErr != XErr)
            {
                Global.RO.Warn("Wrong error code (" + Global.XErrToString(Req.XErr) + " != " + Global.XErrToString(XErr) + ") returned");
                return false;
            }
            return true;
        }
    }
    internal abstract class Update2TestBase : TestBase
    {
        private bool compareBaseSession(XRL2CreateUpdateSession updateReq, XRL2SingleSearchResult searchResult)
        {
            bool ret = false, sameValue = true;
            if ((updateReq.baseCreateUpdate.baseSession.dwPrivateFilled == searchResult.dwPrivateFilled)
                && (updateReq.baseCreateUpdate.baseSession.dwPrivateOpen == searchResult.dwPrivateOpen)
                && (updateReq.baseCreateUpdate.baseSession.dwPublicOpen == searchResult.dwPublicOpen)
                && (updateReq.baseCreateUpdate.baseSession.dwPublicFilled == searchResult.dwPublicFilled))
            {
                XRLxnaddr expectedHostAddr = updateReq.baseCreateUpdate.baseSession.HostAddress;
                XRLxnaddr resultHostAddr = searchResult.HostAddress;
                if (expectedHostAddr.wPortOnline == resultHostAddr.wPortOnline)
                {
                    for (int i = 0; i < expectedHostAddr.ina.Length; i++)
                        if (expectedHostAddr.ina[i] != resultHostAddr.ina[i])
                        {
                            Global.RO.Warn("BaseSession and Result ina do not match");
                            sameValue = false;
                            break;
                        }
                    for (int i = 0; i < expectedHostAddr.inaOnline.Length; i++)
                        if (expectedHostAddr.inaOnline[i] != resultHostAddr.inaOnline[i])
                        {
                            Global.RO.Warn("BaseSession and Result inaOnline do not match");
                            sameValue = false;
                            break;
                        }
                    for (int i = 0; i < expectedHostAddr.abEnet.Length; i++)
                        if (expectedHostAddr.abEnet[i] != resultHostAddr.abEnet[i])
                        {
                            Global.RO.Warn("BaseSession and Result abEnet do not match");
                            sameValue = false;
                            break;
                        }
                    for (int i = 0; i < expectedHostAddr.abOnline.Length; i++)
                        if (expectedHostAddr.abOnline[i] != resultHostAddr.abOnline[i])
                        {
                            Global.RO.Warn("BaseSession and Result abOnline do not match");
                            sameValue = false;
                            break;
                        }
                    if (sameValue)
                        ret = true;
                }
            }
            return ret;
        }

        protected bool UpdateAndVerify(bool defaultSearchParams, XRL2CreateUpdateSession[] Req, 
            XRLXeAttribParam[] searchParams, XRLXeAttribParam checkAttrib, uint spIndex)
        {
            return UpdateAndVerify(defaultSearchParams, Req, searchParams, checkAttrib, spIndex, 1);
        }

        /// <summary>
        /// Since Xenon does not support custom SearchByID query, we have to use following approach to
        /// check whether session is updated correctly or not:
        /// 1. create a session with a specific attribute value
        /// 2. search based on that specific value
        /// 3. if there is session returned, it means that session attribute was updated correctly
        /// </summary>
        /// <param name="Req">update Session request</param>
        /// <param name="searchParams">parameter passed to search session request</param>
        /// <param name="checkAttrib">string session attribute that you would like to check in the search result.
        /// </param>
        /// <param name="spIndex">stored procedure index</param>
        /// <returns></returns>
        protected bool UpdateAndVerify(bool defaultSearchParams, XRL2CreateUpdateSession[] Req, 
            XRLXeAttribParam[] searchParams, XRLXeAttribParam checkAttrib, uint spIndex, uint numSessions)
        {
            bool ret = false;
            try
            {
                for (int i = 0; i < Req.Length; i++)
                {
                    if (!Req[i].Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd)))
                    {
                        Global.RO.Warn("Update session failed:" + Global.XErrToString(Req[i].XErr));
                        return false;
                    }
                }
                XRL2SearchSession searchReq = new XRL2SearchSession(defaultSearchParams, spIndex);
                searchReq.AddParams(searchParams);
                XRL2SearchResults srchResp;

                if (searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out srchResp))
                {
                    if (srchResp != null && (srchResp.resultsLen == numSessions))
                    {
                        // verify baseSessionInfo
                        if (compareBaseSession(Req[0], srchResp.results[0]))
                        {
                            // check additional attributes in the search results
                            if (checkAttrib == null)
                                return true;
                            uint numAttrib = srchResp.results[0].AttribOffsetsLen;
                            string expected = (checkAttrib.aValue as XRLXeStringValue).strValue;
                            XRLXeStringValue returned;
                            uint i = 0;
                            for (i = 0; i < numAttrib; i++)
                            {
                                if ((returned = (srchResp.results[0].Attribs[i].aValue as XRLXeStringValue)) != null)
                                {
                                    if (srchResp.results[0].Attribs[i].attribParamID == checkAttrib.attribParamID)
                                    {
                                        if (String.Compare(expected, returned.strValue) != 0)
                                        {
                                            Global.RO.Warn("string attrib is not setup correctly in the db");
                                            return false;
                                        }
                                        else
                                            return true;
                                    }
                                }
                            }
                            if (i == (numAttrib - 1))
                            {
                                Global.RO.Warn("Cannot find the expected string attribute in the search result");
                                return false;
                            }
                        }
                        else
                            Global.RO.Warn("baseSessionInfo can't be verified");
                    }
                    else
                        Global.RO.Warn("either srchResp is null or number of session returned is not 1.");
                }
                else
                {
                    Global.RO.Warn("search for the session failed" + Global.XErrToString(searchReq.XErr));
                }
            }
            catch (Exception)
            {
                Global.RO.Warn("Unexpected exception thrown");
            }
            return ret;
        }
    }
    [TestGroup]
    public class Func2UpdateSession : TestNode
    {
        [TestGroupSetup]
        public void Setup()
        {
            //make sure table is cleaned out before we begin.
            Global.RO.Info("Cleaning tables before run for title " + Constants.XENON_TITLE.ToString("X"));
            MatchUtil.TruncateSessionsForTitle(Constants.XENON_TITLE, SessionType.Ranked);
        }


        /*****************************************************************************
         * The following cases are positive cases
         *****************************************************************************/
        [BVT]
        [TestCase, Description("modify gameMode/gamerZone/country/lang/rating/mu/sigma")]
        class PUpdateDefaultAttribs : Update2TestBase
        {
            override protected void Execute()
            {
                // create a session with no custom attributes first
                uint numDB = Constants.getNumDBForTitle(Constants.XENON_TITLE);
                uint numSessions = numDB;
                XRL2CreateUpdateSession[] createReq = new XRL2CreateUpdateSession[numSessions];
                XRL2CreateUpdateSession[] updateReq = new XRL2CreateUpdateSession[numSessions];
                XRL2DeleteSession[] delReq = new XRL2DeleteSession[numSessions];
                XRLSessionInfo[] createResp = new XRLSessionInfo[numSessions];
                for (int i = 0; i < numSessions; i++)
                {
                    createReq[i] = new XRL2CreateUpdateSession();
                    if (i > 0)
                    {
                        createReq[i].CopySGInfoFrom(createReq[0]);
                    }
                    // let each request hit the same front door, so i can gurantee each sql box get one session created
                    if (!createReq[i].Execute(Global.XEnv.GetInterface(Interface.xmatchfd)[0], out createResp[i]))
                        return;
                }
                XRLXeAttribParam[] Attribs = new XRLXeAttribParam[7];
                Attribs[1] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE, new XRLXeIntValue(Constants.CONTEXT_GAME_MODE_MODEB));
                Attribs[2] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_ZONE, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_ZONE + 1));
                Attribs[3] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_COUNTRY, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_COUNTRY + 1));
                Attribs[4] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_LANGUAGE, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_LANG + 1));
                Attribs[5] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_RATING, new XRLXeFloatValue(Constants.XENON_TEST_DEFAULT_GAMER_RATING + 1));
                Attribs[6] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_MU, new XRLXeDoubleValue(Constants.XENON_TEST_DEFAULT_GAMER_MU + 1));
                Attribs[0] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_SIGMA, new XRLXeDoubleValue(Constants.XENON_TEST_DEFAULT_GAMER_SIGMA + 1));

                for (int i = 0; i < numSessions; i++)
                {
                    updateReq[i] = new XRL2CreateUpdateSession(createResp[i].SessionID);
                    updateReq[i].AddAttribs(Attribs);
                    updateReq[i].baseCreateUpdate.baseSession.HostAddress.abOnline =
                        createReq[i].baseCreateUpdate.baseSession.HostAddress.abOnline;
                }
                XRLXeAttribParam[] searchParams = new XRLXeAttribParam[9];
                for (int i = 0; i < 7; i++)
                    searchParams[i] = Attribs[i];
                searchParams[7] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_TYPE, new XRLXeIntValue(Constants.X_ATTRIBUTE_GAME_TYPE_RANKED));
                searchParams[8] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_PUID, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_PUID));
                if (UpdateAndVerify(false, updateReq, searchParams, null, Constants.SESSION_MATCH_QUERY_QUERY1, numSessions))
                    ResultCode = TEST_RESULTS.PASSED;
                //delete the sessions
                for (int i = 0; i < numSessions; i++)
                {
                    delReq[i] = new XRL2DeleteSession(createResp[i].SessionID, createReq[i].baseCreateUpdate.baseSession.dwTitleID);
                    delReq[i].Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                }
            }
        }
        [TestCase, Description("send an update request with attributeID set to X_ATTRIBUTE_DATATYPE_NULL")]
        class PNullAttribID : Update2TestBase
        {
            override protected void Execute()
            {
                // create a session with no custom attributes first
                uint numSessions, numDB = Constants.getNumDBForTitle(Constants.XENON_TITLE);
                numSessions = numDB;
                XRL2CreateUpdateSession[] createReq = new XRL2CreateUpdateSession[numSessions];
                XRL2CreateUpdateSession[] updateReq = new XRL2CreateUpdateSession[numSessions];
                XRL2DeleteSession[] delReq = new XRL2DeleteSession[numSessions];
                XRLSessionInfo[] createResp = new XRLSessionInfo[numSessions];
                for (int i = 0; i < numSessions; i++)
                {
                    createReq[i] = new XRL2CreateUpdateSession();
                    if (i > 0)
                    {
                        createReq[i].CopySGInfoFrom(createReq[0]);
                    }
                    // let each request hit the same front door, so i can gurantee each sql box get one session created
                    if (!createReq[i].Execute(Global.XEnv.GetInterface(Interface.xmatchfd)[0], out createResp[i]))
                        return;
                }
                XRLXeAttribParam[] Attribs = new XRLXeAttribParam[1]{new XRLXeAttribParam(Constants.X_ATTRIBUTE_DATATYPE_NULL,
																		 new XRLXeNullValue())};
                for (int i = 0; i < numSessions; i++)
                {
                    updateReq[i] = new XRL2CreateUpdateSession(createResp[i].SessionID);
                    updateReq[i].AddAttribs(Attribs);
                    updateReq[i].CopySGInfoFrom(createReq[i]);
                }
                if (UpdateAndVerify(true, updateReq, null, null, Constants.SESSION_MATCH_QUERY_QUERY1, numSessions))
                    ResultCode = TEST_RESULTS.PASSED;
                //delete the sessions
                for (int i = 0; i < numSessions; i++)
                {
                    delReq[i] = new XRL2DeleteSession(createResp[i].SessionID, createReq[i].baseCreateUpdate.baseSession.dwTitleID);
                    delReq[i].Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                }
            }
        }
        [TestCase, Description("modify public/private open/filled slots")]
        class PNormalCase : Update2TestBase
        {
            override protected void Execute()
            {
                // create a session with no custom attributes first
                XRL2CreateUpdateSession createReq = new XRL2CreateUpdateSession();
                XRLSessionInfo Resp;
                if (createReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out Resp))
                {
                    XRL2CreateUpdateSession[] updateReq = new XRL2CreateUpdateSession[1] {
                        new XRL2CreateUpdateSession(Resp.SessionID)};
                    updateReq[0].baseCreateUpdate.baseSession.dwPrivateOpen -= 1;
                    updateReq[0].baseCreateUpdate.baseSession.dwPublicOpen -= 1;
                    updateReq[0].baseCreateUpdate.baseSession.dwPrivateFilled += 1;
                    updateReq[0].baseCreateUpdate.baseSession.dwPublicFilled += 1;
                    updateReq[0].baseCreateUpdate.baseSession.HostAddress.abOnline =
                        createReq.baseCreateUpdate.baseSession.HostAddress.abOnline;
                    long sessID = Constants.sessionIDConvert(Resp.SessionID);
                    XRLXeAttribParam[] searchParams = new XRLXeAttribParam[1]{
                        new XRLXeAttribParam(Constants.X_ATTRIBUTE_SESSION_ID,
                        new XRLXeIntValue(sessID))};
                    if (UpdateAndVerify(false, updateReq, searchParams, null, Constants.X_SSINDEX_GET_SESSION))
                        ResultCode = TEST_RESULTS.PASSED;
                    //delete the session
                    XRL2DeleteSession delReq = new XRL2DeleteSession(Resp.SessionID, createReq.baseCreateUpdate.baseSession.dwTitleID);
                    delReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                }
            }
        }
        [TestCase, Description("decrement private/public open slots to zero")]
        class PZeroOpenSlots : Update2TestBase
        {
            override protected void Execute()
            {
                // create a session with no custom attributes first
                XRL2CreateUpdateSession createReq = new XRL2CreateUpdateSession();
                XRLSessionInfo Resp;
                if (createReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out Resp))
                {
                    XRL2CreateUpdateSession[] updateReq = new XRL2CreateUpdateSession[1] {
                        new XRL2CreateUpdateSession(Resp.SessionID)};
                    updateReq[0].baseCreateUpdate.baseSession.dwPrivateOpen = 0;
                    updateReq[0].baseCreateUpdate.baseSession.dwPublicOpen = 0;
                    updateReq[0].baseCreateUpdate.baseSession.HostAddress.abOnline =
                        createReq.baseCreateUpdate.baseSession.HostAddress.abOnline;
                    long sessID = Constants.sessionIDConvert(Resp.SessionID);
                    XRLXeAttribParam[] searchParams = new XRLXeAttribParam[1] {
                        new XRLXeAttribParam(Constants.X_ATTRIBUTE_SESSION_ID,
                        new XRLXeIntValue(sessID))};
                    if (UpdateAndVerify(false, updateReq, searchParams, null, Constants.X_SSINDEX_GET_SESSION))
                        ResultCode = TEST_RESULTS.PASSED;
                    //delete the session
                    XRL2DeleteSession delReq = new XRL2DeleteSession(Resp.SessionID, createReq.baseCreateUpdate.baseSession.dwTitleID);
                    delReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                }
            }
        }
        [TestCase, Description("update gameType with same value")]
        class PUpdateGameTypeWithSameValue : TestBase
        {
            override protected void Execute()
            {
                // create a session with no custom attributes first
                uint numSessions, numDB = Constants.getNumDBForTitle(Constants.XENON_TITLE);
                numSessions = numDB;
                XRL2CreateUpdateSession createReq = new XRL2CreateUpdateSession();
                XRL2CreateUpdateSession updateReq = null;
                XRL2DeleteSession delReq;
                XRLSessionInfo createResp;

                if (!createReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out createResp))
                    return;

                XRLXeAttribParam[] Attribs = new XRLXeAttribParam[1]{new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_TYPE,
																		 new XRLXeIntValue(Constants.X_ATTRIBUTE_GAME_TYPE_RANKED))};
                if (createResp != null)
                {
                    updateReq = new XRL2CreateUpdateSession(createResp.SessionID);
                    updateReq.AddAttribs(Attribs);
                }
                if (updateReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd)))
                    ResultCode = TEST_RESULTS.PASSED;
                //delete the sessions
                delReq = new XRL2DeleteSession(createResp.SessionID, createReq.baseCreateUpdate.baseSession.dwTitleID);
                delReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
            }
        }
        [TestCase, Description("add new int32 attribute to a session")]
        class PAddInt32Attrib : Update2TestBase
        {
            override protected void Execute()
            {
                // create a session with no custom attributes first
                uint numSessions, numDB = Constants.getNumDBForTitle(Constants.XENON_TITLE);
                numSessions = numDB;
                XRL2CreateUpdateSession[] createReq = new XRL2CreateUpdateSession[numSessions];
                XRL2CreateUpdateSession[] updateReq = new XRL2CreateUpdateSession[numSessions];
                XRL2DeleteSession[] delReq = new XRL2DeleteSession[numSessions];
                XRLSessionInfo[] createResp = new XRLSessionInfo[numSessions];
                for (int i = 0; i < numSessions; i++)
                {
                    createReq[i] = new XRL2CreateUpdateSession();
                    if (i > 0)
                    {
                        createReq[i].CopySGInfoFrom(createReq[0]);
                    }
                    // let each request hit the same front door, so i can gurantee each sql box get one session created
                    if (!createReq[i].Execute(Global.XEnv.GetInterface(Interface.xmatchfd)[0], out createResp[i]))
                        return;
                }
                XRLXeAttribParam[] Attribs = new XRLXeAttribParam[1]{new XRLXeAttribParam(Constants.PROPERTY_MYINT32PROP1,
																			 new XRLXeIntValue(Int32.MaxValue))};
                for (int i = 0; i < numSessions; i++)
                {
                    updateReq[i] = new XRL2CreateUpdateSession(createResp[i].SessionID);
                    updateReq[i].AddAttribs(Attribs);
                    updateReq[i].CopySGInfoFrom(createReq[i]);
                }
                XRLXeAttribParam[] searchParams = Attribs;
                if (UpdateAndVerify(true, updateReq, searchParams, null, Constants.SESSION_MATCH_QUERY_QUERY1, numSessions))
                    ResultCode = TEST_RESULTS.PASSED;
                //delete the sessions
                for (int i = 0; i < numSessions; i++)
                {
                    delReq[i] = new XRL2DeleteSession(createResp[i].SessionID, createReq[i].baseCreateUpdate.baseSession.dwTitleID);
                    delReq[i].Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                }

            }
        }
        [TestCase, Description("add new int64 attribute to a session")]
        class PAddInt64Attrib : Update2TestBase
        {
            override protected void Execute()
            {
                // create a session with no custom attributes first
                uint numSessions, numDB = Constants.getNumDBForTitle(Constants.XENON_TITLE);
                numSessions = numDB;
                XRL2CreateUpdateSession[] createReq = new XRL2CreateUpdateSession[numSessions];
                XRL2CreateUpdateSession[] updateReq = new XRL2CreateUpdateSession[numSessions];
                XRL2DeleteSession[] delReq = new XRL2DeleteSession[numSessions];
                XRLSessionInfo[] createResp = new XRLSessionInfo[numSessions];
                for (int i = 0; i < numSessions; i++)
                {
                    createReq[i] = new XRL2CreateUpdateSession();
                    if (i > 0)
                    {
                        createReq[i].CopySGInfoFrom(createReq[0]);
                    }
                    if (!createReq[i].Execute(Global.XEnv.GetInterface(Interface.xmatchfd)[0], out createResp[i]))
                        return;
                }
                XRLXeAttribParam[] Attribs = new XRLXeAttribParam[1]{new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP1,
																		 new XRLXeIntValue(Int64.MaxValue))};
                for (int i = 0; i < numSessions; i++)
                {
                    updateReq[i] = new XRL2CreateUpdateSession(createResp[i].SessionID);
                    updateReq[i].AddAttribs(Attribs);
                    updateReq[i].CopySGInfoFrom(createReq[i]);
                }
                XRLXeAttribParam[] searchParams = Attribs;
                if (UpdateAndVerify(true, updateReq, searchParams, null, Constants.SESSION_MATCH_QUERY_QUERY1, numSessions))
                    ResultCode = TEST_RESULTS.PASSED;
                //delete the sessions
                for (int i = 0; i < numSessions; i++)
                {
                    delReq[i] = new XRL2DeleteSession(createResp[i].SessionID, createReq[i].baseCreateUpdate.baseSession.dwTitleID);
                    delReq[i].Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                }
            }
        }
        [TestCase, Description("add new flaot32 attribute to a session")]
        class PAddfloat32Attrib : Update2TestBase
        {
            override protected void Execute()
            {
                // create a session with no custom attributes first
                uint numSessions, numDB = Constants.getNumDBForTitle(Constants.XENON_TITLE);
                numSessions = numDB;
                XRL2CreateUpdateSession[] createReq = new XRL2CreateUpdateSession[numSessions];
                XRL2CreateUpdateSession[] updateReq = new XRL2CreateUpdateSession[numSessions];
                XRL2DeleteSession[] delReq = new XRL2DeleteSession[numSessions];
                XRLSessionInfo[] createResp = new XRLSessionInfo[numSessions];
                for (int i = 0; i < numSessions; i++)
                {
                    createReq[i] = new XRL2CreateUpdateSession();
                    if (i > 0)
                    {
                        createReq[i].CopySGInfoFrom(createReq[0]);
                    }
                    if (!createReq[i].Execute(Global.XEnv.GetInterface(Interface.xmatchfd)[0], out createResp[i]))
                        return;
                }
                XRLXeAttribParam[] Attribs = new XRLXeAttribParam[1]{new XRLXeAttribParam(Constants.PROPERTY_MYFLOAT32PROP1,
																		 new XRLXeFloatValue(float.MaxValue))};
                for (int i = 0; i < numSessions; i++)
                {
                    updateReq[i] = new XRL2CreateUpdateSession(createResp[i].SessionID);
                    updateReq[i].AddAttribs(Attribs);
                    updateReq[i].CopySGInfoFrom(createReq[i]);
                }
                XRLXeAttribParam[] searchParams = Attribs;
                if (UpdateAndVerify(true, updateReq, searchParams, null, Constants.SESSION_MATCH_QUERY_QUERY1, numSessions))
                    ResultCode = TEST_RESULTS.PASSED;
                //delete the sessions
                for (int i = 0; i < numSessions; i++)
                {
                    delReq[i] = new XRL2DeleteSession(createResp[i].SessionID, createReq[i].baseCreateUpdate.baseSession.dwTitleID);
                    delReq[i].Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                }
            }
        }
        [TestCase, Description("add new flaot64 attribute to a session")]
        class PAddFloat64Attrib : Update2TestBase
        {
            override protected void Execute()
            {
                // create a session with no custom attributes first
                uint numSessions, numDB = Constants.getNumDBForTitle(Constants.XENON_TITLE);
                numSessions = numDB;
                XRL2CreateUpdateSession[] createReq = new XRL2CreateUpdateSession[numSessions];
                XRL2CreateUpdateSession[] updateReq = new XRL2CreateUpdateSession[numSessions];
                XRL2DeleteSession[] delReq = new XRL2DeleteSession[numSessions];
                XRLSessionInfo[] createResp = new XRLSessionInfo[numSessions];
                for (int i = 0; i < numSessions; i++)
                {
                    createReq[i] = new XRL2CreateUpdateSession();
                    if (i > 0)
                    {
                        createReq[i].CopySGInfoFrom(createReq[0]);
                    }
                    if (!createReq[i].Execute(Global.XEnv.GetInterface(Interface.xmatchfd)[0], out createResp[i]))
                        return;
                }
                XRLXeAttribParam[] Attribs = new XRLXeAttribParam[1]{new XRLXeAttribParam(Constants.PROPERTY_MYFLOAT64PROP1,
																		 new XRLXeDoubleValue(Double.MaxValue))};
                for (int i = 0; i < numSessions; i++)
                {
                    updateReq[i] = new XRL2CreateUpdateSession(createResp[i].SessionID);
                    updateReq[i].AddAttribs(Attribs);
                    updateReq[i].CopySGInfoFrom(createReq[i]);
                }
                XRLXeAttribParam[] searchParams = Attribs;
                if (UpdateAndVerify(true, updateReq, searchParams, null, Constants.SESSION_MATCH_QUERY_QUERY1, numSessions))
                    ResultCode = TEST_RESULTS.PASSED;
                //delete the sessions
                for (int i = 0; i < numSessions; i++)
                {
                    delReq[i] = new XRL2DeleteSession(createResp[i].SessionID, createReq[i].baseCreateUpdate.baseSession.dwTitleID);
                    delReq[i].Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                }
            }
        }
        [TestCase, Description("add new dateTime attribute to a session")]
        class PAddDateTimeAttrib : Update2TestBase
        {
            override protected void Execute()
            {
                // create a session with no custom attributes first
                uint numSessions, numDB = Constants.getNumDBForTitle(Constants.XENON_TITLE);
                numSessions = numDB;
                XRL2CreateUpdateSession[] createReq = new XRL2CreateUpdateSession[numSessions];
                XRL2CreateUpdateSession[] updateReq = new XRL2CreateUpdateSession[numSessions];
                XRL2DeleteSession[] delReq = new XRL2DeleteSession[numSessions];
                XRLSessionInfo[] createResp = new XRLSessionInfo[numSessions];
                for (int i = 0; i < numSessions; i++)
                {
                    createReq[i] = new XRL2CreateUpdateSession();
                    if (i > 0)
                    {
                        createReq[i].CopySGInfoFrom(createReq[0]);
                    }
                    if (!createReq[i].Execute(Global.XEnv.GetInterface(Interface.xmatchfd)[0], out createResp[i]))
                        return;
                }
                XRLXeAttribParam[] Attribs = new XRLXeAttribParam[1]{new XRLXeAttribParam(Constants.PROPERTY_MYDATETIMEPROP1,
																		 new XRLXeDateTimeValue(DateTime.MaxValue.ToFileTimeUtc()))};
                for (int i = 0; i < numSessions; i++)
                {
                    updateReq[i] = new XRL2CreateUpdateSession(createResp[i].SessionID);
                    updateReq[i].AddAttribs(Attribs);
                    updateReq[i].CopySGInfoFrom(createReq[i]);
                }
                XRLXeAttribParam[] searchParams = Attribs;
                if (UpdateAndVerify(true, updateReq, searchParams, null, Constants.SESSION_MATCH_QUERY_QUERY1, numSessions))
                    ResultCode = TEST_RESULTS.PASSED;
                //delete the sessions
                for (int i = 0; i < numSessions; i++)
                {
                    delReq[i] = new XRL2DeleteSession(createResp[i].SessionID, createReq[i].baseCreateUpdate.baseSession.dwTitleID);
                    delReq[i].Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                }
            }
        }
        [TestCase, Description("add context attribute to a session")]
        class PAddContextAttrib : Update2TestBase
        {
            override protected void Execute()
            {
                // create a session with no custom attributes first
                uint numSessions, numDB = Constants.getNumDBForTitle(Constants.XENON_TITLE);
                numSessions = numDB;
                XRL2CreateUpdateSession[] createReq = new XRL2CreateUpdateSession[numSessions];
                XRL2CreateUpdateSession[] updateReq = new XRL2CreateUpdateSession[numSessions];
                XRL2DeleteSession[] delReq = new XRL2DeleteSession[numSessions];
                XRLSessionInfo[] createResp = new XRLSessionInfo[numSessions];
                for (int i = 0; i < numSessions; i++)
                {
                    createReq[i] = new XRL2CreateUpdateSession();
                    if (i > 0)
                    {
                        createReq[i].CopySGInfoFrom(createReq[0]);
                    }
                    if (!createReq[i].Execute(Global.XEnv.GetInterface(Interface.xmatchfd)[0], out createResp[i]))
                        return;
                }
                XRLXeAttribParam[] Attribs = new XRLXeAttribParam[1]{new XRLXeAttribParam(Constants.CONTEXT_MYCONTEXT1,
																		 new XRLXeIntValue(Constants.CONTEXT_MYCONTEXT1_TRACKA))};
                for (int i = 0; i < numSessions; i++)
                {
                    updateReq[i] = new XRL2CreateUpdateSession(createResp[i].SessionID);
                    updateReq[i].AddAttribs(Attribs);
                    updateReq[i].CopySGInfoFrom(createReq[i]);
                }
                XRLXeAttribParam[] searchParams = Attribs;
                if (UpdateAndVerify(true, updateReq, searchParams, null, Constants.SESSION_MATCH_QUERY_QUERY1, numSessions))
                    ResultCode = TEST_RESULTS.PASSED;
                //delete the sessions
                for (int i = 0; i < numSessions; i++)
                {
                    delReq[i] = new XRL2DeleteSession(createResp[i].SessionID, createReq[i].baseCreateUpdate.baseSession.dwTitleID);
                    delReq[i].Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                }
            }
        }
        [TestCase, Description("31596:add new string attribute with max value to a session")]
        class PAddStringAttrib : Update2TestBase
        {
            override protected void Execute()
            {
                // create a session with no custom attributes first
                uint numSessions, numDB = Constants.getNumDBForTitle(Constants.XENON_TITLE);
                numSessions = numDB;
                XRL2CreateUpdateSession[] createReq = new XRL2CreateUpdateSession[numSessions];
                XRL2CreateUpdateSession[] updateReq = new XRL2CreateUpdateSession[numSessions];
                XRL2DeleteSession[] delReq = new XRL2DeleteSession[numSessions];
                XRLSessionInfo[] createResp = new XRLSessionInfo[numSessions];
                for (int i = 0; i < numSessions; i++)
                {
                    createReq[i] = new XRL2CreateUpdateSession();
                    if (i > 0)
                    {
                        createReq[i].CopySGInfoFrom(createReq[0]);
                    }
                    if (!createReq[i].Execute(Global.XEnv.GetInterface(Interface.xmatchfd)[0], out createResp[i]))
                        return;
                }
                string strVal = new string('a', (int)Constants.X_MAX_STRING_ATTRIBUTE_LEN) + '\0';
                XRLXeAttribParam[] Attribs = new XRLXeAttribParam[2];
                Attribs[0] = new XRLXeAttribParam(Constants.PROPERTY_GAMERNAME, new XRLXeStringValue(strVal));
                Attribs[1] = new XRLXeAttribParam(Constants.PROPERTY_MYFLOAT32PROP1, new XRLXeFloatValue(0.1f));

                for (int i = 0; i < numSessions; i++)
                {
                    updateReq[i] = new XRL2CreateUpdateSession(createResp[i].SessionID);
                    updateReq[i].AddAttribs(Attribs);
                    updateReq[i].CopySGInfoFrom(createReq[i]);
                }
                XRLXeAttribParam[] searchParams = new XRLXeAttribParam[1];
                searchParams[0] = Attribs[1];
                if (UpdateAndVerify(true, updateReq, searchParams, null, Constants.SESSION_MATCH_QUERY_QUERY1, numSessions))
                    ResultCode = TEST_RESULTS.PASSED;
                //delete the sessions
                for (int i = 0; i < numSessions; i++)
                {
                    delReq[i] = new XRL2DeleteSession(createResp[i].SessionID, createReq[i].baseCreateUpdate.baseSession.dwTitleID);
                    delReq[i].Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                }
            }
        }
        [TestCase, Description("update existing int32/64/float32/64/datetime/context attribute values")]
        class PUpdateExistingAttribs : Update2TestBase
        {
            override protected void Execute()
            {
                // create a session with no custom attributes first
                uint numSessions, numDB = Constants.getNumDBForTitle(Constants.XENON_TITLE);
                numSessions = numDB;
                XRL2CreateUpdateSession[] createReq = new XRL2CreateUpdateSession[numSessions];
                XRL2CreateUpdateSession[] updateReq = new XRL2CreateUpdateSession[numSessions];
                XRL2DeleteSession[] delReq = new XRL2DeleteSession[numSessions];
                XRLSessionInfo[] createResp = new XRLSessionInfo[numSessions];
                XRLXeAttribParam[] Attribs = new XRLXeAttribParam[6]
				{
					new XRLXeAttribParam(Constants.PROPERTY_MYDATETIMEPROP1,new XRLXeDateTimeValue(DateTime.Now.ToFileTimeUtc())),
					new XRLXeAttribParam(Constants.PROPERTY_MYFLOAT32PROP1, new XRLXeFloatValue(float.MinValue)),
					new XRLXeAttribParam(Constants.PROPERTY_MYFLOAT64PROP1, new XRLXeDoubleValue(double.MinValue)),
					new XRLXeAttribParam(Constants.PROPERTY_MYINT32PROP1, new XRLXeIntValue(Int32.MinValue)),
					new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP1, new XRLXeIntValue(Int64.MinValue)),
					new XRLXeAttribParam(Constants.CONTEXT_MYCONTEXT1, new XRLXeIntValue(Constants.CONTEXT_MYCONTEXT1_TRACKC))
				};
                for (int i = 0; i < numSessions; i++)
                {
                    createReq[i] = new XRL2CreateUpdateSession();
                    createReq[i].AddAttribs(Attribs);
                    if (i > 0)
                    {
                        createReq[i].CopySGInfoFrom(createReq[0]);
                    }
                    if (!createReq[i].Execute(Global.XEnv.GetInterface(Interface.xmatchfd)[0], out createResp[i]))
                        return;
                }
                XRLXeAttribParam[] updateAttribs = new XRLXeAttribParam[6]
				{
						new XRLXeAttribParam(Constants.PROPERTY_MYDATETIMEPROP1,new XRLXeDateTimeValue(DateTime.MaxValue.ToFileTimeUtc())),
					new XRLXeAttribParam(Constants.PROPERTY_MYFLOAT32PROP1, new XRLXeFloatValue(float.MaxValue)),
					new XRLXeAttribParam(Constants.PROPERTY_MYFLOAT64PROP1, new XRLXeDoubleValue(double.MaxValue)),
					new XRLXeAttribParam(Constants.PROPERTY_MYINT32PROP1, new XRLXeIntValue(Int32.MaxValue)),
					new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP1, new XRLXeIntValue(Int64.MaxValue)),
					new XRLXeAttribParam(Constants.CONTEXT_MYCONTEXT1, new XRLXeIntValue(Constants.CONTEXT_MYCONTEXT1_TRACKB))
				};
                for (int i = 0; i < numSessions; i++)
                {
                    updateReq[i] = new XRL2CreateUpdateSession(createResp[i].SessionID);
                    updateReq[i].AddAttribs(updateAttribs);
                    updateReq[i].CopySGInfoFrom(createReq[i]);
                }
                XRLXeAttribParam[] searchParams = updateAttribs;
                if (UpdateAndVerify(true, updateReq, searchParams, null, Constants.SESSION_MATCH_QUERY_QUERY1, numSessions))
                    ResultCode = TEST_RESULTS.PASSED;
                //delete the sessions
                for (int i = 0; i < numSessions; i++)
                {
                    delReq[i] = new XRL2DeleteSession(createResp[i].SessionID, createReq[i].baseCreateUpdate.baseSession.dwTitleID);
                    delReq[i].Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                }
            }
        }
        [TestCase, Description("update an existing string attribute")]
        class PUpdateStrAttrib : TestBase
        {
            override protected void Execute()
            {
                long searchDateTime = DateTime.Now.ToFileTimeUtc();
                // create a session with no custom attributes first
                uint numSessions, numDB = Constants.getNumDBForTitle(Constants.XENON_TITLE);
                numSessions = numDB;
                XRL2CreateUpdateSession[] createReq = new XRL2CreateUpdateSession[numSessions];
                XRL2CreateUpdateSession[] updateReq = new XRL2CreateUpdateSession[numSessions];
                XRL2DeleteSession[] delReq = new XRL2DeleteSession[numSessions];
                XRLSessionInfo[] createResp = new XRLSessionInfo[numSessions];
                XRLXeAttribParam[] Attribs = new XRLXeAttribParam[1] { new XRLXeAttribParam(Constants.PROPERTY_GAMERNAME, new XRLXeStringValue("abc\0")) };
                for (int i = 0; i < numSessions; i++)
                {
                    createReq[i] = new XRL2CreateUpdateSession();
                    createReq[i].AddAttribs(Attribs);
                    if (i > 0)
                    {
                        createReq[i].CopySGInfoFrom(createReq[0]);
                    }
                    if (!createReq[i].Execute(Global.XEnv.GetInterface(Interface.xmatchfd)[0], out createResp[i]))
                    {
                        Global.RO.Error(MatchUtil.ErrMsgFromXRLPayload("Failed to create session.", createReq[i]));
                        return;
                    }
                }
                string strVal = "This is a new string value\0";
                XRLXeAttribParam[] updateAttribs = new XRLXeAttribParam[2]{new XRLXeAttribParam(Constants.PROPERTY_GAMERNAME,new XRLXeStringValue(strVal)),
																		 new XRLXeAttribParam(Constants.PROPERTY_MYDATETIMEPROP1, new XRLXeDateTimeValue(DateTime.Now.ToFileTimeUtc()))};
                for (int i = 0; i < numSessions; i++)
                {
                    updateReq[i] = new XRL2CreateUpdateSession(createResp[i].SessionID);
                    updateReq[i].AddAttribs(updateAttribs);
                    updateReq[i].CopySGInfoFrom(createReq[i]);
                    if (!updateReq[i].Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd)))
                        return;
                }
                XRLXeAttribParam[] searchParams = new XRLXeAttribParam[1] { new XRLXeAttribParam(Constants.PROPERTY_MYDATETIMEPROP1, new XRLXeDateTimeValue(searchDateTime)) };
                XRL2SearchSession searchReq = new XRL2SearchSession(true, Constants.SESSION_MATCH_QUERY_STRINGATTRIBQUERY);
                XRL2SearchResults srchResp;
                XRLXeStringValue retString;
                searchReq.AddParams(searchParams);
                try
                {
                    if (searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out srchResp))
                    {	// check string attribute
                        if ((srchResp != null) && ((retString = (srchResp.results[0].Attribs[0].aValue as XRLXeStringValue)) != null))
                        {
                            if (String.Compare(retString.strValue, strVal) == 0)
                                ResultCode = TEST_RESULTS.PASSED;
                            else
                                Global.RO.Warn("Returned string is not correct:" + retString.strValue);
                        }
                    }
                }
                catch (Exception e)
                {
                    Global.RO.Warn("Unexpected exception caught:" + e.Message);
                }
                //delete the sessions
                for (int i = 0; i < numSessions; i++)
                {
                    delReq[i] = new XRL2DeleteSession(createResp[i].SessionID, createReq[i].baseCreateUpdate.baseSession.dwTitleID);
                    delReq[i].Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                }
            }
        }
        /*****************************************************************************
         * The following cases are negative cases
         *****************************************************************************/
        [TestCase, Description("Bug 26368:try to update GameType attribute with different value")]
        class NUpdateGameType : NegativeUpdate2TestBase
        {
            override protected void Execute()
            {
                XRL2CreateUpdateSession createReq = new XRL2CreateUpdateSession();
                XRLSessionInfo Resp;
                if (createReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out Resp))
                {
                    XRL2CreateUpdateSession updateReq = new XRL2CreateUpdateSession(Resp.SessionID);
                    XRLXeAttribParam[] attribs = new XRLXeAttribParam[1]{new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_TYPE,
																			 new XRLXeIntValue(Constants.X_ATTRIBUTE_GAME_TYPE_STANDARD))};
                    updateReq.AddAttribs(attribs);
                    if (UpdateTestNegative(updateReq, HResult.XONLINE_E_MATCH_INVALID_PARAM))
                        ResultCode = TEST_RESULTS.PASSED;
                    //delete the session
                    XRL2DeleteSession delReq = new XRL2DeleteSession(Resp.SessionID, createReq.baseCreateUpdate.baseSession.dwTitleID);
                    delReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                }
                else
                    Global.RO.Warn("CreateSession failed:" + Global.XErrToString(createReq.XErr));
            }
        }
        [TestCase, Description("try to update a nonexistent session")]
        class NNonExistSession : NegativeUpdate2TestBase
        {
            override protected void Execute()
            {
                byte[] SessionID = new byte[8] { 0, 0, 0, 0, 0, 0, 0, 1 };
                XRL2CreateUpdateSession updateReq = new XRL2CreateUpdateSession(SessionID);
                if (UpdateTestNegative(updateReq, HResult.XONLINE_E_MATCH_INVALID_SESSION_ID))
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("try to update with blob attribute")]
        class NBlobAttrib : NegativeUpdate2TestBase
        {
            override protected void Execute()
            {
                // create a session with no custom attributes first
                XRL2CreateUpdateSession createReq = new XRL2CreateUpdateSession();
                XRLSessionInfo Resp;
                if (createReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out Resp))
                {
                    XRL2CreateUpdateSession updateReq = new XRL2CreateUpdateSession(Resp.SessionID);
                    XRLXeAttribParam[] attribs = new XRLXeAttribParam[1]{new XRLXeAttribParam(Constants.SAMPLE_BLOB_ATTRIB,
																			 new XRLXeIntValue(123))};
                    updateReq.AddAttribs(attribs);
                    if (UpdateTestNegative(updateReq, HResult.XONLINE_E_MATCH_INVALID_DATA_TYPE))
                        ResultCode = TEST_RESULTS.PASSED;
                    //delete the session
                    XRL2DeleteSession delReq = new XRL2DeleteSession(Resp.SessionID, createReq.baseCreateUpdate.baseSession.dwTitleID);
                    delReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                }
                else
                    Global.RO.Warn("CreateSession failed:" + Global.XErrToString(createReq.XErr));
            }
        }
        [TestCase, Description("add non-existent context attribute Id")]
        class NNonExistentContextAttrib : NegativeUpdate2TestBase
        {
            override protected void Execute()
            {
                // create a session with no custom attributes first
                XRL2CreateUpdateSession createReq = new XRL2CreateUpdateSession();
                XRLSessionInfo Resp;
                if (createReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out Resp))
                {
                    XRL2CreateUpdateSession updateReq = new XRL2CreateUpdateSession(Resp.SessionID);
                    uint contextAttrib = 0x7;    // nonexistent
                    XRLXeAttribParam[] attribs = new XRLXeAttribParam[1]{new XRLXeAttribParam(contextAttrib,
																			 new XRLXeIntValue(123))};
                    updateReq.AddAttribs(attribs);
                    if (UpdateTestNegative(updateReq, HResult.XONLINE_E_MATCH_INVALID_ATTRIBUTE_ID))
                        ResultCode = TEST_RESULTS.PASSED;
                    //delete the session
                    XRL2DeleteSession delReq = new XRL2DeleteSession(Resp.SessionID, createReq.baseCreateUpdate.baseSession.dwTitleID);
                    delReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                }
                else
                    Global.RO.Warn("CreateSession failed:" + Global.XErrToString(createReq.XErr));
            }
        }
        [TestCase, Description("add non-existent int32 attribute")]
        class NNonExistentInt32Attrib : NegativeUpdate2TestBase
        {
            override protected void Execute()
            {
                // create a session with no custom attributes first
                XRL2CreateUpdateSession createReq = new XRL2CreateUpdateSession();
                XRLSessionInfo Resp;
                if (createReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out Resp))
                {
                    XRL2CreateUpdateSession updateReq = new XRL2CreateUpdateSession(Resp.SessionID);
                    uint intAttrib = 0x10000111;    // nonexistent
                    XRLXeAttribParam[] attribs = new XRLXeAttribParam[1]{new XRLXeAttribParam(intAttrib,
																			 new XRLXeIntValue(123))};
                    updateReq.AddAttribs(attribs);
                    if (UpdateTestNegative(updateReq, HResult.XONLINE_E_MATCH_INVALID_ATTRIBUTE_ID))
                        ResultCode = TEST_RESULTS.PASSED;
                    //delete the session
                    XRL2DeleteSession delReq = new XRL2DeleteSession(Resp.SessionID, createReq.baseCreateUpdate.baseSession.dwTitleID);
                    delReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                }
                else
                    Global.RO.Warn("CreateSession failed:" + Global.XErrToString(createReq.XErr));
            }
        }
        [TestCase, Description("add non-existent int64 attribute")]
        class NNonExistentInt64Attrib : NegativeUpdate2TestBase
        {
            override protected void Execute()
            {
                // create a session with no custom attributes first
                XRL2CreateUpdateSession createReq = new XRL2CreateUpdateSession();
                XRLSessionInfo Resp;
                if (createReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out Resp))
                {
                    XRL2CreateUpdateSession updateReq = new XRL2CreateUpdateSession(Resp.SessionID);
                    uint intAttrib = 0x20000111;    // nonexistent
                    XRLXeAttribParam[] attribs = new XRLXeAttribParam[1]{new XRLXeAttribParam(intAttrib,
																			 new XRLXeIntValue(123))};
                    updateReq.AddAttribs(attribs);
                    if (UpdateTestNegative(updateReq, HResult.XONLINE_E_MATCH_INVALID_ATTRIBUTE_ID))
                        ResultCode = TEST_RESULTS.PASSED;
                    //delete the session
                    XRL2DeleteSession delReq = new XRL2DeleteSession(Resp.SessionID, createReq.baseCreateUpdate.baseSession.dwTitleID);
                    delReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                }
                else
                    Global.RO.Warn("CreateSession failed:" + Global.XErrToString(createReq.XErr));
            }
        }
        [TestCase, Description("add non-existent Float32 attribute")]
        class NNonExistentFloat32Attrib : NegativeUpdate2TestBase
        {
            override protected void Execute()
            {
                // create a session with no custom attributes first
                XRL2CreateUpdateSession createReq = new XRL2CreateUpdateSession();
                XRLSessionInfo Resp;
                if (createReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out Resp))
                {
                    XRL2CreateUpdateSession updateReq = new XRL2CreateUpdateSession(Resp.SessionID);
                    uint floatAttrib = 0x50000111;    // nonexistent
                    XRLXeAttribParam[] attribs = new XRLXeAttribParam[1]{new XRLXeAttribParam(floatAttrib,
																			 new XRLXeFloatValue(0.33f))};
                    updateReq.AddAttribs(attribs);
                    if (UpdateTestNegative(updateReq, HResult.XONLINE_E_MATCH_INVALID_ATTRIBUTE_ID))
                        ResultCode = TEST_RESULTS.PASSED;
                    //delete the session
                    XRL2DeleteSession delReq = new XRL2DeleteSession(Resp.SessionID, createReq.baseCreateUpdate.baseSession.dwTitleID);
                    delReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                }
                else
                    Global.RO.Warn("CreateSession failed:" + Global.XErrToString(createReq.XErr));
            }
        }
        [TestCase, Description("add non-existent float64 attribute")]
        class NNonExistentFloat64Attrib : NegativeUpdate2TestBase
        {
            override protected void Execute()
            {
                // create a session with no custom attributes first
                XRL2CreateUpdateSession createReq = new XRL2CreateUpdateSession();
                XRLSessionInfo Resp;
                if (createReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out Resp))
                {
                    XRL2CreateUpdateSession updateReq = new XRL2CreateUpdateSession(Resp.SessionID);
                    uint doubleAttrib = 0x30000111;    // nonexistent
                    XRLXeAttribParam[] attribs = new XRLXeAttribParam[1]{new XRLXeAttribParam(doubleAttrib,
																			 new XRLXeDoubleValue(0.11))};
                    updateReq.AddAttribs(attribs);
                    if (UpdateTestNegative(updateReq, HResult.XONLINE_E_MATCH_INVALID_ATTRIBUTE_ID))
                        ResultCode = TEST_RESULTS.PASSED;
                    //delete the session
                    XRL2DeleteSession delReq = new XRL2DeleteSession(Resp.SessionID, createReq.baseCreateUpdate.baseSession.dwTitleID);
                    delReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                }
                else
                    Global.RO.Warn("CreateSession failed:" + Global.XErrToString(createReq.XErr));
            }
        }
        [TestCase, Description("add non-existent datetime attribute")]
        class NNonExistentDateTimeAttrib : NegativeUpdate2TestBase
        {
            override protected void Execute()
            {
                // create a session with no custom attributes first
                XRL2CreateUpdateSession createReq = new XRL2CreateUpdateSession();
                XRLSessionInfo Resp;
                if (createReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out Resp))
                {
                    XRL2CreateUpdateSession updateReq = new XRL2CreateUpdateSession(Resp.SessionID);
                    uint dateAttrib = 0x70000111;    // nonexistent
                    XRLXeAttribParam[] attribs = new XRLXeAttribParam[1]{new XRLXeAttribParam(dateAttrib,
																			 new XRLXeDateTimeValue(DateTime.Now.ToFileTimeUtc()))};
                    updateReq.AddAttribs(attribs);
                    if (UpdateTestNegative(updateReq, HResult.XONLINE_E_MATCH_INVALID_ATTRIBUTE_ID))
                        ResultCode = TEST_RESULTS.PASSED;
                    //delete the session
                    XRL2DeleteSession delReq = new XRL2DeleteSession(Resp.SessionID, createReq.baseCreateUpdate.baseSession.dwTitleID);
                    delReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                }
                else
                    Global.RO.Warn("CreateSession failed:" + Global.XErrToString(createReq.XErr));
            }
        }
        [TestCase, Description("add non-existent string attribute")]
        class NNonExistentStrAttrib : NegativeUpdate2TestBase
        {
            override protected void Execute()
            {
                // create a session with no custom attributes first
                XRL2CreateUpdateSession createReq = new XRL2CreateUpdateSession();
                XRLSessionInfo Resp;
                if (createReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out Resp))
                {
                    XRL2CreateUpdateSession updateReq = new XRL2CreateUpdateSession(Resp.SessionID);
                    uint strAttribID = 0x40108111;    // nonexistent
                    XRLXeAttribParam[] attribs = new XRLXeAttribParam[1]{new XRLXeAttribParam(strAttribID,
																		new XRLXeStringValue("dfd\0"))};
                    updateReq.AddAttribs(attribs);
                    if (UpdateTestNegative(updateReq, HResult.XONLINE_E_MATCH_INVALID_ATTRIBUTE_ID))
                        ResultCode = TEST_RESULTS.PASSED;
                    //delete the session
                    XRL2DeleteSession delReq = new XRL2DeleteSession(Resp.SessionID, createReq.baseCreateUpdate.baseSession.dwTitleID);
                    delReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                }
                else
                    Global.RO.Warn("CreateSession failed:" + Global.XErrToString(createReq.XErr));
            }
        }
        [TestCase, Description("dwMessageLength is shorter than the actual updateSession Request length")]
        class NOverflowMsg : NegativeUpdate2TestBase
        {
            override protected void Execute()
            {
                // create a session with no custom attributes first
                XRL2CreateUpdateSession createReq = new XRL2CreateUpdateSession();
                XRLSessionInfo Resp;
                if (createReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out Resp))
                {
                    XRL2CreateUpdateSession updateReq = new XRL2CreateUpdateSession(Resp.SessionID);
                    XRLXeAttribParam[] attribs = new XRLXeAttribParam[1] { new XRLXeAttribParam(Constants.CONTEXT_MYCONTEXT1, new XRLXeIntValue(111)) };
                    updateReq.AddAttribs(attribs);
                    updateReq.baseCreateUpdate.baseSession.dwMessageLength -= 1;
                    if (UpdateTestNegative(updateReq, HResult.XONLINE_E_MATCH_REQUEST_TOO_SMALL))
                        ResultCode = TEST_RESULTS.PASSED;
                    //delete the session
                    XRL2DeleteSession delReq = new XRL2DeleteSession(Resp.SessionID, createReq.baseCreateUpdate.baseSession.dwTitleID);
                    delReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                }
                else
                    Global.RO.Warn("CreateSession failed:" + Global.XErrToString(createReq.XErr));
            }
        }
        [TestCase, Description("dwMessageLength is larger than the actual updateSession Request length")]
        class NTruncateMsg : NegativeUpdate2TestBase
        {
            override protected void Execute()
            {
                // create a session with no custom attributes first
                XRL2CreateUpdateSession createReq = new XRL2CreateUpdateSession();
                XRLSessionInfo Resp;
                if (createReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out Resp))
                {
                    XRL2CreateUpdateSession updateReq = new XRL2CreateUpdateSession(Resp.SessionID);
                    XRLXeAttribParam[] attribs = new XRLXeAttribParam[1] { new XRLXeAttribParam(Constants.CONTEXT_MYCONTEXT1, new XRLXeIntValue(111)) };
                    updateReq.AddAttribs(attribs);
                    updateReq.baseCreateUpdate.baseSession.dwMessageLength += 1;
                    if (UpdateTestNegative(updateReq, HResult.XONLINE_E_MATCH_REQUEST_TRUNCATED))
                        ResultCode = TEST_RESULTS.PASSED;
                    //delete the session
                    XRL2DeleteSession delReq = new XRL2DeleteSession(Resp.SessionID, createReq.baseCreateUpdate.baseSession.dwTitleID);
                    delReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                }
                else
                    Global.RO.Warn("CreateSession failed:" + Global.XErrToString(createReq.XErr));
            }
        }
        [TestCase, Description("dwNumAttributes is smaller than what's actually passed in")]
        class NWrongNumAttribs1 : NegativeUpdate2TestBase
        {
            override protected void Execute()
            {
                // create a session with no custom attributes first
                XRL2CreateUpdateSession createReq = new XRL2CreateUpdateSession();
                XRLSessionInfo Resp;
                if (createReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out Resp))
                {
                    XRL2CreateUpdateSession updateReq = new XRL2CreateUpdateSession(Resp.SessionID);
                    XRLXeAttribParam[] attribs = new XRLXeAttribParam[2]{
													new XRLXeAttribParam(Constants.PROPERTY_MYINT32PROP1,new XRLXeIntValue(11)),
													 new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP1,new XRLXeIntValue(22))};
                    updateReq.AddAttribs(attribs);
                    updateReq.baseCreateUpdate.ManualArraySize = true;
                    updateReq.baseCreateUpdate.AttribOffsetsLen = 1;
                    if (UpdateTestNegative(updateReq, HResult.XONLINE_E_MATCH_INVALID_OFFSET) ||
                        UpdateTestNegative(updateReq, HResult.XONLINE_E_MATCH_OVERFLOW))
                        ResultCode = TEST_RESULTS.PASSED;
                    //delete the session
                    XRL2DeleteSession delReq = new XRL2DeleteSession(Resp.SessionID, createReq.baseCreateUpdate.baseSession.dwTitleID);
                    delReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                }
                else
                    Global.RO.Warn("CreateSession failed:" + Global.XErrToString(createReq.XErr));
            }
        }
        [TestCase, Description("dwNumAttributes is larger than what's actually passed in")]
        class NWrongNumAttribs2 : NegativeUpdate2TestBase
        {
            override protected void Execute()
            {
                // create a session with no custom attributes first
                XRL2CreateUpdateSession createReq = new XRL2CreateUpdateSession();
                XRLSessionInfo Resp;
                if (createReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out Resp))
                {
                    XRL2CreateUpdateSession updateReq = new XRL2CreateUpdateSession(Resp.SessionID);
                    byte[] blobValue = new byte[100];
                    new Random().NextBytes(blobValue);
                    XRLXeAttribParam[] attribs = new XRLXeAttribParam[1] { new XRLXeAttribParam(Constants.PROPERTY_MYINT32PROP1, new XRLXeIntValue(11)) };
                    updateReq.AddAttribs(attribs);
                    updateReq.baseCreateUpdate.AttribOffsetsLen = 2;
                    updateReq.baseCreateUpdate.ManualArraySize = true;
                    if (UpdateTestNegative(updateReq, HResult.XONLINE_E_END_OF_STREAM))
                        ResultCode = TEST_RESULTS.PASSED;
                    //delete the session
                    XRL2DeleteSession delReq = new XRL2DeleteSession(Resp.SessionID, createReq.baseCreateUpdate.baseSession.dwTitleID);
                    delReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                }
                else
                    Global.RO.Warn("CreateSession failed:" + Global.XErrToString(createReq.XErr));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XMatchTest\Func2TitleChange.cs ===
using System;
using System.Text;
using System.IO;
using System.Net;
using System.Collections;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Matchmaking;
using xonline.common.config;

namespace XMatchTest
{
	[TestGroup]
	public class Func2TitleChange : TestNode
	{
		// this is for batched titlechange requests
		protected static bool    MyOwnExecute(XRLTitleChange[] batchReq, uint dwTotalMsgLen,uint XErr)
		{
			MemoryStream        reqStream = new MemoryStream();
			BinaryWriter        bw = new BinaryWriter(reqStream);
			// get reqStream from the batchReq;
			for(int i = 0; i < batchReq.Length; i++)
			{
				bw.Write(batchReq[i].wType);
				bw.Write(batchReq[i].cbEnt);
				bw.Write(batchReq[i].sgaddr.inaSg);
				bw.Write(batchReq[i].sgaddr.dwSpiSg);
				bw.Write(batchReq[i].sgaddr.qwXboxID);
				bw.Write(batchReq[i].sgaddr.abReserved);
				bw.Write(batchReq[i].dwOldTitleID);
				bw.Write(batchReq[i].dwNewTitleID);
			}
			if(dwTotalMsgLen > (batchReq.Length*(Constants.SIZETITLECHANGE)))
				bw.Write("a");    // this is a negative case that passed in extra data at the end of titlechange requests
			else if(dwTotalMsgLen < (batchReq.Length*(Constants.SIZETITLECHANGE)))
				reqStream.SetLength(dwTotalMsgLen);

			StringBuilder sbURL = new StringBuilder();
			sbURL.Append("http://");
			sbURL.Append(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd).ToString());
			sbURL.Append("/xmatch/titlechange.ashx");

			HttpWebRequest    httpReq;
			HttpWebResponse    httpResp = null;
			HttpStatusCode    statusCode;
			Stream            httpStream;
			httpReq = (HttpWebRequest)WebRequest.Create(sbURL.ToString());
			httpReq.ProtocolVersion = HttpVersion.Version11;
			httpReq.Method = "POST";
			httpReq.UserAgent = ((int)XOService.Matchmaking).ToString("x") + "/1.0.5849";
			httpReq.ContentType = "xon/" + ((int)XOService.Matchmaking).ToString("x");
			httpReq.ContentLength = reqStream.Length;
			try
			{
				httpStream = httpReq.GetRequestStream();
				reqStream.WriteTo(httpStream);
				httpStream.Close();
				httpResp = (HttpWebResponse)httpReq.GetResponse();
			}
			catch (WebException e)
			{
				if(XErr == 0)    // this request is expected to succeed
				{
					Global.RO.Warn("Positive titlechange requests failed");
                                        Global.RO.Error("Exception is as follows:");
                                        Global.RO.Error(e.ToString());
					return false;
				}
				// else this is a negative case
				httpResp = (HttpWebResponse)e.Response;
				if(httpResp != null)
				{
					statusCode = httpResp.StatusCode;
					if(statusCode == HttpStatusCode.InternalServerError)
					{    // check XErr
                        string strErr = httpResp.GetResponseHeader("X-Err");
                        if (strErr.StartsWith("0x") || strErr.StartsWith("0X")) strErr = strErr.Substring(2);

                        if (Convert.ToUInt32(strErr, 16) == XErr)
                            return true;
						else
						{
							Global.RO.Warn("Wrong error code (" + strErr + " != " + XErr.ToString("X") + ") returned");
							return false;
						}
					}
					else // other error returned instead of 500
						return false;
				}
				// httpResp is null
				return false;
			}
			if(XErr == 0)
				return true;
			else
				return false;
		}

            [TestCase, Ignore, Description("call titleChange with SgAddr/TitleRegion/aqwUserID set to max value.  Ignored because FD now checks for valid boxID.")]
			class PMaxSgAddr : TestBase
		{
			override protected void Execute()
			{
				SGADDR        sg = new SGADDR();
				sg.dwSpiSg = 0xffffffff;
				sg.qwXboxID = 0xffffffffffffffff;
				sg.inaSg = new byte[4]{0xff,0xff,0xff,0xff};
				byte[]        sgbytes = sg.toByteArray();

				// create a session with maximum SGADDR
				XRL2CreateUpdateSession        createReq = new XRL2CreateUpdateSession();
				XRLSessionInfo                Resp;
				Array.Copy(sgbytes,createReq.baseCreateUpdate.baseSession.HostAddress.abOnline,(long)Constants.SIZESGADDR);
				if(createReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out Resp))
				{
					XRLTitleChange        req = new XRLTitleChange(Constants.XENON_TITLE);
					req.sgaddr.dwSpiSg = sg.dwSpiSg;
					req.sgaddr.qwXboxID = sg.qwXboxID;
					Array.Copy(sg.inaSg,req.sgaddr.inaSg,4);

					if(req.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd)))
					{
						// the session will be deleted right away
						XRL2DeleteSession    delReq = new XRL2DeleteSession(Resp.SessionID,Constants.XENON_TITLE);
						if(    !delReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd))&&
							(delReq.XErr == HResult.XONLINE_E_MATCH_INVALID_SESSION_ID))
							ResultCode=TEST_RESULTS.PASSED;
					}
				}
			}
		}
            
            [TestCase, Ignore, Description("call titleChange with SgAddr/TitleRegion/aqwUserID set to min value.  Ignored because FD now checks for valid Box ID.")]
			class PMinSgAddr : TestBase
		{
			override protected void Execute()
			{
				SGADDR        sg = new SGADDR();
				sg.dwSpiSg = 0;
				sg.qwXboxID = 0;
				sg.inaSg = new byte[4]{0,0,0,0};
				byte[]        sgbytes = sg.toByteArray();

				// create a session with maximum SGADDR
				XRL2CreateUpdateSession        createReq = new XRL2CreateUpdateSession();
				XRLSessionInfo                Resp;
				Array.Copy(sgbytes,createReq.baseCreateUpdate.baseSession.HostAddress.abOnline,(long)Constants.SIZESGADDR);
				if(createReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out Resp))
				{
					XRLTitleChange        req = new XRLTitleChange(Constants.XENON_TITLE);
					req.sgaddr.dwSpiSg = sg.dwSpiSg;
					req.sgaddr.qwXboxID = sg.qwXboxID;
					Array.Copy(sg.inaSg,req.sgaddr.inaSg,4);

					if(req.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd)))
					{
						// the session will be deleted right away
						XRL2DeleteSession    delReq = new XRL2DeleteSession(Resp.SessionID,Constants.XENON_TITLE);
						if(    !delReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd))&&
							(delReq.XErr == HResult.XONLINE_E_MATCH_INVALID_SESSION_ID))
							ResultCode=TEST_RESULTS.PASSED;
					}
				}
			}
		}
            [BVT]
		[TestCase, Description("call titleChange so that more than 1 sessions are deleted")]
			class PMoreSessions : TestBase
		{
			override protected void Execute()
			{
				SGADDR        sg = new SGADDR();
				byte[]        sgbytes = sg.toByteArray();
				// create two sessions with the same SGAddr set
				XRL2CreateUpdateSession        createReq1, createReq2;
				createReq1 = new XRL2CreateUpdateSession();
				createReq2 = new XRL2CreateUpdateSession();
				XRLSessionInfo                Resp1, Resp2;

				Array.Copy(sgbytes,createReq1.baseCreateUpdate.baseSession.HostAddress.abOnline,(long)Constants.SIZESGADDR);
				Array.Copy(sgbytes,createReq2.baseCreateUpdate.baseSession.HostAddress.abOnline,(long)Constants.SIZESGADDR);
				if(    createReq1.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out Resp1) &&
					createReq2.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out Resp2))
				{
					XRLTitleChange        req = new XRLTitleChange(Constants.XENON_TITLE);
					req.sgaddr.dwSpiSg = sg.dwSpiSg;
					req.sgaddr.qwXboxID = sg.qwXboxID;
					Array.Copy(sg.inaSg,req.sgaddr.inaSg,4);

					if(req.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd)))
					{
						// the two sessions will be deleted right away.
						// Since they're deleted by the title change, verify
						// they're not present by attempting to delete them.
						XRL2DeleteSession    delReq1 = new XRL2DeleteSession(Resp1.SessionID,Constants.XENON_TITLE);
						XRL2DeleteSession    delReq2 = new XRL2DeleteSession(Resp2.SessionID,Constants.XENON_TITLE);
						if((!delReq1.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd))&&
							(delReq1.XErr == HResult.XONLINE_E_MATCH_INVALID_SESSION_ID)) ||
							(!delReq2.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd)) &&
							(delReq2.XErr == HResult.XONLINE_E_MATCH_INVALID_SESSION_ID)))
							ResultCode=TEST_RESULTS.PASSED;
					}
				}
			}
		}
		[TestCase, Description("send six batched titleChange messages in one request")]
			class PBatchedMsg : TestBase
		{
			override protected void Execute()
			{
				SGADDR        sg = new SGADDR();
				byte[]        sgbytes;
				// create six sessions with different SGAddr
				XRL2CreateUpdateSession    []    createReqs = new XRL2CreateUpdateSession[6];
				XRLSessionInfo            []    Resp = new XRLSessionInfo[6];
				for(int i = 0; i < 6; i++)
				{
					createReqs[i] = new XRL2CreateUpdateSession();

					sg.dwSpiSg = (uint)(0x12345678 + i);
					sgbytes = sg.toByteArray();
					Array.Copy(sgbytes,createReqs[i].baseCreateUpdate.baseSession.HostAddress.abOnline,(long)Constants.SIZESGADDR);
					if(!createReqs[i].Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out Resp[i]))
					{
						Global.RO.Warn("create session failed");
						return;
					}
				}
				// create a request that has 6 batched deadxbox message
				XRLTitleChange    []    reqs = new XRLTitleChange[6];
				for(int i = 0; i < 6; i++)
				{
					reqs[i] = new XRLTitleChange(Constants.XENON_TITLE);
					reqs[i].sgaddr.dwSpiSg = (uint)(0x12345678+i);
					reqs[i].sgaddr.qwXboxID = sg.qwXboxID;
					Array.Copy(sg.inaSg,reqs[i].sgaddr.inaSg,4);
				}
				if( MyOwnExecute(reqs, Constants.SIZETITLECHANGE*6,0))
				{
					XRL2DeleteSession[]    delReqs = new XRL2DeleteSession[6];
					for(int i = 0; i < 6; i++)
					{
						delReqs[i] = new XRL2DeleteSession(Resp[i].SessionID,Constants.XENON_TITLE);
						if((delReqs[i].Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd))) ||
							(delReqs[i].XErr != HResult.XONLINE_E_MATCH_INVALID_SESSION_ID))
							return;
					}
					ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}

		[TestCase, Description("send six batched titleChange messages, but invalidate the titleid of the first one")]
			class PBatchedMsg_OneInvalid : TestBase
		{
			override protected void Execute()
			{
				SGADDR        sg = new SGADDR();
				byte[]        sgbytes;
				// create six sessions with different SGAddr
				XRL2CreateUpdateSession    []    createReqs = new XRL2CreateUpdateSession[6];
				XRLSessionInfo            []    Resp = new XRLSessionInfo[6];
				for(int i = 0; i < 6; i++)
				{
                                    createReqs[i] = new XRL2CreateUpdateSession();

                                    sg.dwSpiSg = (uint)(0x12345678 + i);
                                    sgbytes = sg.toByteArray();
                                    Array.Copy(sgbytes,createReqs[i].baseCreateUpdate.baseSession.HostAddress.abOnline,(long)Constants.SIZESGADDR);
                                    if(!createReqs[i].Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out Resp[i]))
                                    {
                                        Global.RO.Warn("create session failed");
                                        return;
                                    }
				}
				// create a request that has 6 batched deadxbox message
				XRLTitleChange    []    reqs = new XRLTitleChange[6];
				for(int i = 0; i < 6; i++)
				{
                                    if (i == 0) {
					reqs[i] = new XRLTitleChange(0xDEADBEEF);  //invalidate the
                                                                                   //titleid of the first.
                                    } else {
					reqs[i] = new XRLTitleChange(Constants.XENON_TITLE);
                                    }
                                    reqs[i].sgaddr.dwSpiSg = (uint)(0x12345678+i);
                                    reqs[i].sgaddr.qwXboxID = sg.qwXboxID;
                                    Array.Copy(sg.inaSg,reqs[i].sgaddr.inaSg,4);
				}
				if( MyOwnExecute(reqs, Constants.SIZETITLECHANGE*6,0))
				{
                                    bool deletedOkay = true;
                                    XRL2DeleteSession[]    delReqs = new XRL2DeleteSession[6];
                                    for(int i = 0; i < 6; i++)
                                    {
                                        delReqs[i] = new XRL2DeleteSession(Resp[i].SessionID,Constants.XENON_TITLE);
                                        if((delReqs[i].Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd))) ||
                                           (delReqs[i].XErr != HResult.XONLINE_E_MATCH_INVALID_SESSION_ID)) {
                                            if (i != 0) {
                                                deletedOkay = false;
                                            }
                                        }
                                    }
                                    if (deletedOkay) {
                                        ResultCode=TEST_RESULTS.PASSED;
                                    } else {
                                        Global.RO.Error("Sessions found that were not deleted by the TitleChange!");
                                    }
				}
			}
		}

		[TestCase, Description("send mixed batched titleChange messages")]
			class PMixedBatchedMsg : TestBase
		{
			override protected void Execute()
			{
				SGADDR        sg = new SGADDR();
				byte[]        sgbytes;
				// create 50 sessions with different SGAddr
				XRL2CreateUpdateSession    []    createReqs = new XRL2CreateUpdateSession[50];
				XRLSessionInfo            []    Resp = new XRLSessionInfo[50];
				for(int i = 0, j=0; i < 100; i++, j++)
				{
					createReqs[j] = new XRL2CreateUpdateSession();

					sg.dwSpiSg = (uint)(0x12345678 + i);
					sgbytes = sg.toByteArray();
					Array.Copy(sgbytes,createReqs[j].baseCreateUpdate.baseSession.HostAddress.abOnline,(long)Constants.SIZESGADDR);
					if(!createReqs[j].Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out Resp[j]))
					{
						Global.RO.Warn("create session failed");
						return;
					}
					i++;
				}
				// create a request that has 100 batched titleChange message
				XRLTitleChange    []    reqs = new XRLTitleChange[100];
				for(int i = 0; i < 100; i++)
				{
					reqs[i] = new XRLTitleChange(Constants.XENON_TITLE);
					if(i%2 == 0)
						reqs[i].dwOldTitleID = Constants.XENON_TITLE;
					else
						reqs[i].dwOldTitleID = 4019;    // nonexistent title ID
					reqs[i].sgaddr.dwSpiSg = (uint)(0x12345678+i);
					reqs[i].sgaddr.qwXboxID = sg.qwXboxID;
					Array.Copy(sg.inaSg,reqs[i].sgaddr.inaSg,4);
				}
				if(    MyOwnExecute(reqs, Constants.SIZETITLECHANGE*100,0))
				{
					XRL2DeleteSession[]    delReqs = new XRL2DeleteSession[50];
					for(int i = 0; i < 50; i++)
					{
						delReqs[i] = new XRL2DeleteSession(Resp[i].SessionID,Constants.XENON_TITLE);
						if((delReqs[i].Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd))) ||
							(delReqs[i].XErr != HResult.XONLINE_E_MATCH_INVALID_SESSION_ID))
							return;
					}
					ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}
            [TestCase, Description("Create a batch of requests, but have one of them fail by timeout.  Ensure the others succeed.")]
            class PTimeoutSingleCase : TestBase {
                //um...  rewrite so it actually works for numbers other than 100.  Makes use of a
                //single SG construct so the deadxbox can use it to hit the right sessions back.
                public static XRLSessionInfo [] CreateSessions(int numberToCreate, SGADDR sg) {
                    XRLSessionInfo [] createResponses = new XRLSessionInfo[100];
                    XRL2CreateUpdateSession    []    createReqs = new XRL2CreateUpdateSession[100];

                    for (int i=0; i<numberToCreate; i++) {
                        byte[] sgbytes;
                        createReqs[i] = new XRL2CreateUpdateSession();

                        sg.dwSpiSg = (uint)(0x12345678 + i);
                        sgbytes = sg.toByteArray();
                        Array.Copy(sgbytes,createReqs[i].baseCreateUpdate.baseSession.HostAddress.abOnline,(long)Constants.SIZESGADDR);
                        if(!createReqs[i].Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out createResponses[i]))
                        {
                            Global.RO.Warn("create session failed");
                        }
                    }
                    return createResponses;
                }

                public static void ResetSprocsAfterDelay(object sprocSet) {
                    System.Threading.Thread.Sleep(5000); //wait 5s, enough one request to hit timeout.
                    ((XmatchSprocSet) sprocSet).ResetSprocToOriginal();                    
                }

                override protected void Execute()
                {
                    uint titleID = Constants.XENON_TITLE;
                    ArrayList servers = MatchUtil.GetAllSqlServersForThisTitle(titleID);
                    XmatchSprocSet titleChangeSproc = new XmatchSprocSet("p_match_session_0x" + titleID.ToString("X") + "_deadxbox", 
                                                                         ((string[]) servers.ToArray(typeof(string))));
                    titleChangeSproc.SetSprocToTimeout();
                    SGADDR        sg = new SGADDR();
                    
                    XRLSessionInfo [] createResps = CreateSessions(100, sg);
                    XRLTitleChange    []    reqs = new XRLTitleChange[100];
                    for(int i = 0; i < 100; i++)
                    {
                        reqs[i] = new XRLTitleChange(titleID);
                        reqs[i].dwOldTitleID = titleID;
                        reqs[i].sgaddr.dwSpiSg = (uint)(0x12345678+i);
                        reqs[i].sgaddr.qwXboxID = sg.qwXboxID;
                        Array.Copy(sg.inaSg,reqs[i].sgaddr.inaSg,4);
                    }

                    //Begin a new thread whose job it is to start 30s from now and reset the sproc
                    //to normal
                    Thread resetSprocsThread = new Thread(ResetSprocsAfterDelay);
                    resetSprocsThread.Start(titleChangeSproc);

                    //run the execute, expecting a failure of critical db error when you timeout.
                    if (MyOwnExecute(reqs, Constants.SIZETITLECHANGE*100,0x8015511e)) {

                        //verify the sessions got deleted by trying to delete them, *except* the first
                        //one, which we'll delete.
                        XRL2DeleteSession[]    delReqs = new XRL2DeleteSession[100];
                        bool deletedOkay = true;
                        for(int i = 0; i < 100; i++)
                        {
                            delReqs[i] = new XRL2DeleteSession(createResps[i].SessionID,titleID);
                            if((delReqs[i].Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd))) ||
                               (delReqs[i].XErr != HResult.XONLINE_E_MATCH_INVALID_SESSION_ID)) {
                                //we're here because the delete didn't fail with invalid session ID.
                                //If it's not the first one, we have problems.
                                if (i != 0) {
                                    deletedOkay = false;
                                }
                            }
                        }
                        if (deletedOkay) {
                            ResultCode=TEST_RESULTS.PASSED;
                        } else {
                            Global.RO.Error("Sessions found that were not deleted by the TitleChange!");
                        }
                    }
                }
                
                
            }
            


		/***************************************************************************************
		 * The followings are negative cases
		 ***************************************************************************************/
		[TestCase, Description("malformed titleChange messages")]
			class NMalformedMsg : TestBase
		{
			override protected void Execute()
			{
				XRLTitleChange    []    reqs = new XRLTitleChange[2]{new XRLTitleChange(Constants.XENON_TITLE), new XRLTitleChange(Constants.XENON_TITLE)};
				uint    dwTotalMsgLen = 2 * Constants.SIZETITLECHANGE + 1;
				// same DeadXbox message will be sent twice to the matchmaking front door
				if(    MyOwnExecute(reqs, dwTotalMsgLen,HResult.XONLINE_E_MATCH_REQUEST_TRUNCATED))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("truncated titleChange messages")]
			class NTruncateMsg : TestBase
		{
			override protected void Execute()
			{
				XRLTitleChange    []    reqs = new XRLTitleChange[2]{new XRLTitleChange(Constants.XENON_TITLE), new XRLTitleChange(Constants.XENON_TITLE)};
				uint    dwTotalMsgLen = 2 * Constants.SIZETITLECHANGE -1;

				if(    MyOwnExecute(reqs, dwTotalMsgLen,HResult.XONLINE_E_MATCH_REQUEST_TRUNCATED))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("call titleChange with nonexistent title ID")]
			class NUnknownTitle : TestBase
		{
			override protected void Execute()
			{
				XRLTitleChange    req = new XRLTitleChange(Constants.XENON_TITLE);
				req.dwOldTitleID = 9;
				// although xmatch will throw these requests, but it still returns S_OK
				if(req.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd)))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XMatchTest\FuncDeadSG.cs ===
using System;
using System.IO;
using System.Text;
using System.Net;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Matchmaking;
using xonline.common.config;

namespace XMatchTest
{
	[TestGroup]
    public class FuncDeadSG : TestNode
    {
        //This is for batched deadsg requests, as ordinary STF DeadSGs are called one at a time.
        //dwTotalMsgLen is the size of the deadSG message(batchReq.Length*(Constants.SIZEDEADSG),
        //XErr is the expected error code returned.
        //This only differs from the FuncDeadXbox version by not adding the titleid into the request.
        protected static bool    MyOwnExecute(XRLDeadXBox[] batchReq, uint dwTotalMsgLen,uint XErr)
        {
            MemoryStream        reqStream = new MemoryStream();
            BinaryWriter        bw = new BinaryWriter(reqStream);
            // get reqStream from the batchReq;
            for(int i = 0; i < batchReq.Length; i++)
            {
                bw.Write(batchReq[i].wType);
                bw.Write(batchReq[i].cbEnt);
                bw.Write(batchReq[i].sgaddr.inaSg);
                bw.Write(batchReq[i].sgaddr.dwSpiSg);
                bw.Write(batchReq[i].sgaddr.qwXboxID);
                bw.Write(batchReq[i].sgaddr.abReserved);
            }
            if(dwTotalMsgLen > (batchReq.Length*(Constants.SIZEDEADSG)))
                bw.Write("a");    // this is a negative case that passed in extra data at the end of deadxbox requests
            else if(dwTotalMsgLen < (batchReq.Length*(Constants.SIZEDEADSG)))
                reqStream.SetLength(dwTotalMsgLen);

            StringBuilder sbURL = new StringBuilder();
            sbURL.Append("http://");
            sbURL.Append(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd).ToString());
            sbURL.Append("/xmatch/deadxbox.ashx");

            HttpWebRequest    httpReq;
            HttpWebResponse    httpResp = null;
            HttpStatusCode    statusCode;
            Stream            httpStream;
            httpReq = (HttpWebRequest)WebRequest.Create(sbURL.ToString());
            httpReq.ProtocolVersion = HttpVersion.Version11;
            httpReq.Method = "POST";
            httpReq.UserAgent = ((int)XOService.Matchmaking).ToString("x") + "/1.0.5849";
            httpReq.ContentType = "xon/" + ((int)XOService.Matchmaking).ToString("x");
            httpReq.ContentLength = reqStream.Length;
            try
            {
                httpStream = httpReq.GetRequestStream();
                reqStream.WriteTo(httpStream);
                httpStream.Close();
                httpResp = (HttpWebResponse)httpReq.GetResponse();
            }
            catch (WebException e)
            {
                if(XErr == 0)    // this request is expected to succeed
                {
                    Global.RO.Warn("Positive deadxbox requests failed");
                    return false;
                }
                // else this is a negative case
                httpResp = (HttpWebResponse)e.Response;
                if(httpResp != null)
                {
                    statusCode = httpResp.StatusCode;
                    if(statusCode == HttpStatusCode.InternalServerError)
                    {    // check XErr
                        string strErr = httpResp.GetResponseHeader("X-Err");
                        if (strErr.StartsWith("0x") || strErr.StartsWith("0X")) strErr = strErr.Substring(2);

                        if (Convert.ToUInt32(strErr, 16) == XErr)
                            return true;
                        else
                        {
                            Global.RO.Warn("Wrong error code (" + strErr + " != " + XErr.ToString("X") + ") returned");
                            return false;
                        }
                    }
                    else // other error returned instead of 500
                        return false;
                }
                // httpResp is null
                return false;
            }
            if(XErr == 0)
                return true;
            else
                return false;
        }
        [Ignore] //can no longer call with max value, because boxID is validated.
        [TestCase, Description("Call deadsg with SGAddr set to max value")]
			class PMaxSGAddr : TestBase
        {
            override protected void Execute()
            {
                // create a session with SGIP portion of HostAddress set to max value
                SGADDR        sg = new SGADDR();
                sg.dwSpiSg = 0;
                sg.qwXboxID = 0;
                sg.inaSg = new byte[4]{0xff,0xff,0xff,0xff};
                byte[]        sgbytes = sg.toByteArray();

                XRLCreateUpdateSession        createReq = new XRLCreateUpdateSession();
                XRLSessionInfo                Resp;
                Array.Copy(sgbytes,createReq.baseSession.HostAddress.abOnline,(long)Constants.SIZESGADDR);
                if(createReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out Resp))
                {
                    XRLDeadXBox        req = new XRLDeadXBox();
                    req.sgaddr.dwSpiSg = sg.dwSpiSg;
                    req.sgaddr.qwXboxID = sg.qwXboxID;
                    Array.Copy(sg.inaSg, req.sgaddr.inaSg, 4);
                    if(req.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd)))
                    {
                        // the session will be deleted right away
                        XRLDeleteSession    delReq = new XRLDeleteSession(Resp.SessionID);
                        if(    !delReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd))&&
                            (delReq.XErr == HResult.XONLINE_E_MATCH_INVALID_SESSION_ID))
                            ResultCode=TEST_RESULTS.PASSED;
                    }
                }
            }
        }

        [Ignore] //can no longer call with min value, because boxID is validated.
        [TestCase, Description("call deadSG with SgAddr/TitleRegion/aqwUserID set to min value")]
			class PMinSgAddr : TestBase
        {
            override protected void Execute()
            {
                SGADDR        sg = new SGADDR();
                sg.dwSpiSg = 0;
                sg.qwXboxID = 0;
                sg.inaSg = new byte[4]{0,0,0,0};
                byte[]        sgbytes = sg.toByteArray();

                // create a session with minimum SGADDR
                XRLCreateUpdateSession        createReq = new XRLCreateUpdateSession();
                XRLSessionInfo                Resp;
                Array.Copy(sgbytes,createReq.baseSession.HostAddress.abOnline,(long)Constants.SIZESGADDR);
                if(createReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out Resp))
                {
                    XRLDeadXBox        req = new XRLDeadXBox();
                    req.sgaddr.dwSpiSg = sg.dwSpiSg;
                    req.sgaddr.qwXboxID = sg.qwXboxID;
                    Array.Copy(sg.inaSg,req.sgaddr.inaSg,4);
                    if(req.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd)))
                    {
                        // the session will be deleted right away
                        XRLDeleteSession    delReq = new XRLDeleteSession(Resp.SessionID);
                        if(    !delReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd))&&
                            (delReq.XErr == HResult.XONLINE_E_MATCH_INVALID_SESSION_ID))
                            ResultCode=TEST_RESULTS.PASSED;
                    }
                }
            }
        }
        [BVT]
        [TestCase, Description("call deadsg so that more than 1 sessions are deleted")]
			class PMoreSessions : TestBase
        {
            override protected void Execute()
            {
                SGADDR        sg = new SGADDR();
                byte[]        sgbytes = sg.toByteArray();
                // create two sessions with the same SGAddr set
                XRLCreateUpdateSession        createReq1, createReq2;
                createReq1 = new XRLCreateUpdateSession();
                createReq2 = new XRLCreateUpdateSession();
                XRLSessionInfo                Resp1, Resp2;

                Array.Copy(sgbytes,createReq1.baseSession.HostAddress.abOnline,(long)Constants.SIZESGADDR);
                Array.Copy(sgbytes,createReq2.baseSession.HostAddress.abOnline,(long)Constants.SIZESGADDR);
                if(    createReq1.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out Resp1) &&
                    createReq2.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out Resp2))
                {
                    XRLDeadXBox        req = new XRLDeadXBox();
                    req.sgaddr.dwSpiSg = 0;
                    req.sgaddr.qwXboxID = 0;
                    Array.Copy(sg.inaSg,req.sgaddr.inaSg,4);
                    if(req.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd)))
                    {
                        // the two sessions will be deleted right away
                        XRLDeleteSession    delReq1 = new XRLDeleteSession(Resp1.SessionID);
                        XRLDeleteSession    delReq2 = new XRLDeleteSession(Resp2.SessionID);
                        if((!delReq1.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd))&&
                            (delReq1.XErr == HResult.XONLINE_E_MATCH_INVALID_SESSION_ID)) ||
                            (!delReq2.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd)) &&
                            (delReq2.XErr == HResult.XONLINE_E_MATCH_INVALID_SESSION_ID)))
                            ResultCode=TEST_RESULTS.PASSED;
                    }
                }
            }
        }
        /***************************************************************************************
         * The followings are negative cases
         ***************************************************************************************/
        [TestCase, Description("malformed deadSG messages")]
			class NMalformedMsg : TestBase
        {
            override protected void Execute()
            {
                XRLDeadXBox    []    reqs = new XRLDeadXBox[2]{new XRLDeadXBox(), new XRLDeadXBox()};
                reqs[0].sgaddr.dwSpiSg = 0;
                reqs[0].sgaddr.qwXboxID = 0;
                reqs[1].sgaddr.dwSpiSg = 0;
                reqs[1].sgaddr.qwXboxID = 0;
                uint    dwTotalMsgLen = 2 * Constants.SIZEDEADSG + 1;
                if(    MyOwnExecute(reqs, dwTotalMsgLen,HResult.XONLINE_E_MATCH_REQUEST_TRUNCATED))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("truncated deadSG messages")]
			class NTruncateMsg : TestBase
        {
            override protected void Execute()
            {
                XRLDeadXBox    []    reqs = new XRLDeadXBox[2]{new XRLDeadXBox(), new XRLDeadXBox()};
                reqs[0].sgaddr.dwSpiSg = 0;
                reqs[0].sgaddr.qwXboxID = 0;
                reqs[1].sgaddr.dwSpiSg = 0;
                reqs[1].sgaddr.qwXboxID = 0;
                uint    dwTotalMsgLen = 2 * Constants.SIZEDEADSG -1;
                if(    MyOwnExecute(reqs, dwTotalMsgLen,HResult.XONLINE_E_MATCH_REQUEST_TRUNCATED))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("call deadSG with invalid SGIP(i.e. no sessions has such SGIP)")]
			class NInvalidSGIP : TestBase
        {
            override protected void Execute()
            {
                XRLDeadXBox        req = new XRLDeadXBox();
                req.sgaddr.dwSpiSg = 0;
                req.sgaddr.qwXboxID = 0;
                req.sgaddr.inaSg = new byte[4]{0x88,0x88,0x88,0x88};
                if(req.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd)))
                        ResultCode=TEST_RESULTS.PASSED;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XMatchTest\FuncSearchSession.cs ===
using System;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Matchmaking;
using xonline.common.config;

namespace XMatchTest
{
    internal abstract class NegativeSearchTestBase : TestBase
    {
        protected bool SearchTestNegative(XRLSearchSession Req, uint XErr)
        {
            XRLSearchResults        resp;
            if (Req.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out resp))
            {
                Global.RO.Warn("Negative CreateSession request succeed unexpectedly");
                return false;
            }
            if((Req.XErr != XErr) || (resp != null))
            {
                Global.RO.Warn("Wrong error code (" + Global.XErrToString(Req.XErr) + " != " + Global.XErrToString(XErr) + ") returned or response is not null");
                return false;
            }
            return true;
        }
    }

    internal abstract class SpecialSearchTestBase : TestBase
    {
        // this assumes only one search result returned
        protected bool createAndSearchVerify(XRLCreateUpdateSession createReq, WireData[] expectedAttribs, uint dwExpectedLen, uint spIndex)
        {
            bool            ret = false;
            XRLSessionInfo    createResp;
            if(createReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out createResp))
            {
                XRLSearchSession    searchReq = new XRLSearchSession(spIndex);
                searchReq.baseSearchSession.dwTitleID = createReq.baseSession.dwTitleID;
                XRLSearchResults    Resp;
                if(searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), 1, expectedAttribs, out Resp))
                {    // check if result had addtional columns
                    if(Resp.results[0].dwResultLength == dwExpectedLen)
                    {
                        // check the returned attributes values
                        XRLStringParam strTemp, strExpected;
                        XRLBlobParam blobTemp, blobExpected;
                        XRLIntParam    intTemp, intExpected;
                        for(int k = 0; k < expectedAttribs.Length; k++)
                        {
                            if((intTemp = (Resp.results[0].Attribs[k].aValue) as XRLIntParam) != null)
                            {
                                if((intExpected = expectedAttribs[k] as XRLIntParam) == null)
                                {
                                    Global.RO.Warn("Expect an intAttribute returned");
                                    return false;
                                }
                                if(intTemp.intValue != intExpected.intValue)
                                {
                                    Global.RO.Warn("Expect "+intExpected.intValue);
                                    return false;
                                }
                            }
                            if((strTemp = Resp.results[0].Attribs[k].aValue as XRLStringParam) != null)
                            {
                                if((strExpected = expectedAttribs[k] as XRLStringParam) == null)
                                {
                                    Global.RO.Warn("Expect an stringAttribute returned");
                                    return false;
                                }
                                if(string.Compare(strTemp.strValue,strExpected.strValue) !=0)
                                {
                                    Global.RO.Warn("Expect "+strExpected.strValue);
                                    return false;
                                }
                            }
                            if((blobTemp = Resp.results[0].Attribs[k].aValue as XRLBlobParam) != null)
                            {
                                if((blobExpected = expectedAttribs[k] as XRLBlobParam) == null)
                                {
                                    Global.RO.Warn("Expect an blobAttribute returned");
                                    return false;
                                }
                                for(int j = 0; j < blobExpected.blobLen; j++)
                                {
                                    if(blobTemp.blob[j] != blobExpected.blob[j])
                                    {
                                        Global.RO.Warn("blob attrib value is not correct");
                                        return false;
                                    }
                                }
                            }
                        }
                    }
                    ret = true;
                }
                XRLDeleteSession    delReq = new XRLDeleteSession(createResp.SessionID);
                delReq.dwTitleID = 9090;
                delReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                return ret;
            }
            return ret;
        }
    }
    // These tests are deprecated, as Xbox1 support is removed.  These will be deleted in the next release.
    [TestGroup, Ignore]
    public class FuncSearchSession : TestNode
    {
        /************************************************************************
         * The followings are positive cases
         ************************************************************************/
        [BVT]
        [TestCase, Description("Search so that 0 results returned")]
			class PNormalCase : TestBase
        {
            override protected void Execute()
            {
                // search based on sessionID
                XRLSearchSession    searchReq = new XRLSearchSession(5);
                // sp=5 takes sessionID as parameter
                XRLAttribParam[] Params = new XRLAttribParam[1]{new XRLAttribParam(Constants.X_ATTRIBUTE_DATATYPE_INTEGER,new XRLIntParam(1))};
                searchReq.AddParams(Params);
                XRLSearchResults    Resp;
                if(searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out Resp))
                {
                    if(Resp == null)
                        ResultCode=TEST_RESULTS.PASSED;
                }
            }
        }
        [BVT]
        [TestCase, Description("Search so that more than 1 sessions(with no attributes) returned")]
			class PMoreResults : TestBase
        {
            override protected void Execute()
            {
                // create numDBs * 2 sessions, each with one title-session-int attribute:0x00001234,
                // so we can gurantee there are two sessions on each db.
                long    intValue = 8888;
				uint    numDB = Constants.getNumDBForTitle(Constants.TITLE_ID);
				uint	numSessions = numDB * 2;
				XRLCreateUpdateSession    [] createReq = new XRLCreateUpdateSession[numSessions];
                XRLSessionInfo            [] createResp = new XRLSessionInfo[numSessions];
                WireData[]    Attribs = new WireData[1]{new XRLIntAttribute(0x1234,intValue)};
                bool    ret = true;
                for(int i = 0; i < numSessions; i++)
                {
                    createReq[i] = new XRLCreateUpdateSession();
                    createReq[i].AddAttribs(Attribs);
                    if(!createReq[i].Execute(Global.XEnv.GetInterface(Interface.xmatchfd)[0], out createResp[i]))
                    {
                        ret = false;
                        break;
                    }
                }
                if(ret)
                {
                    // search so that 2 sessions will be returned
                    // sp=31:sessions with int attribute=8888 will be returned
                    XRLSearchSession    searchReq = new XRLSearchSession(31);
                    XRLAttribParam[] Params = new XRLAttribParam[1]{new XRLAttribParam(Constants.X_ATTRIBUTE_DATATYPE_INTEGER,new XRLIntParam(intValue))};
                    searchReq.AddParams(Params);
                    XRLSearchResults    Resp;
                    if(searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out Resp))
                    {
                        // check searchResults
                        if(    (Resp.resultsLen == 2) &&
                            (Resp.dwMessageLength == Constants.SIZESEARCHHEADER+Constants.SIZEBASESEARCHRESULT*2))
                        {
                            if(    (Resp.results[0].dwResultLength == Constants.SIZEBASESEARCHRESULT)&&
                                (Resp.results[1].dwResultLength == Constants.SIZEBASESEARCHRESULT))
                                ResultCode=TEST_RESULTS.PASSED;
                        }
                    }
                    //clean up each session.
                    XRLDeleteSession   [] delReq = new XRLDeleteSession[numSessions];
                    for(int i = 0; i < numSessions; i++)
                    {
                        delReq[i] = new XRLDeleteSession(createResp[i].SessionID);
                        delReq[i].Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                    }
                }
            }
        }
        [TestCase, Description("bug8594:pass three NULL parameters to a sp that takes int/string/blob params")]
			class PNullParameters1 : TestBase
        {
            override protected void Execute()
            {    // create one session on each db so we can gurantee there will be 1 session returned
				uint    numDB = Constants.getNumDBForTitle(Constants.TITLE_ID);
				uint	numSessions = numDB;
				XRLCreateUpdateSession      []  createReq = new XRLCreateUpdateSession[numSessions];
				XRLSessionInfo              []  createResp = new XRLSessionInfo[numSessions];

				for(int i = 0; i < numSessions; i++)
				{
					createReq[i] = new XRLCreateUpdateSession();
					createResp[i] = new XRLSessionInfo();
					if(!createReq[i].Execute(Global.XEnv.GetInterface(Interface.xmatchfd)[0],out createResp[i]))
						Global.RO.Warn("Failed to create sessions");
				}
                // sp=4 takes 3 parameters: int, string, blob
                XRLSearchSession    searchReq = new XRLSearchSession(4);
                searchReq.baseSearchSession.wFlags = Constants.XONLINE_MATCH_SEARCH_FLAG_NO_CACHE;
                XRLAttribParam[] Params = new XRLAttribParam[3]{new XRLAttribParam(Constants.X_ATTRIBUTE_DATATYPE_NULL,new XRLNullParam()),
                                                                new XRLAttribParam(Constants.X_ATTRIBUTE_DATATYPE_NULL,new XRLNullParam()),
                                                                new XRLAttribParam(Constants.X_ATTRIBUTE_DATATYPE_NULL,new XRLNullParam())};
                searchReq.AddParams(Params);
                XRLSearchResults    Resp;
                if(searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out Resp))
                {
                    if( (Resp.resultsLen == 1) &&
                        (Resp.dwMessageLength == Constants.SIZESEARCHHEADER+Constants.SIZEBASESEARCHRESULT))
                        ResultCode=TEST_RESULTS.PASSED;
                }
                XRLDeleteSession   [] delReq = new XRLDeleteSession[numSessions];
				for(int i = 0; i < numSessions; i++)
				{
					delReq[i]=new XRLDeleteSession(createResp[i].SessionID);
					delReq[i].Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
				}
            }
        }
       // [TestCase, Description("bug8594:pass a NULL parameter to a sp that takes int parameter")]
		//Test PNullParameters1 and PNullParameters2 are identical.
		//If you have a filter which maps to a parameter with null allowed, its as good as not having a filter when null is passed as parameter value
		class PNullParameters2 : TestBase
        {
            override protected void Execute()
            {
				uint    numDB = Constants.getNumDBForTitle(Constants.TITLE_ID);
				uint	numSessions = numDB;
				XRLCreateUpdateSession      []  createReq = new XRLCreateUpdateSession[numSessions];
				XRLSessionInfo              []  createResp = new XRLSessionInfo[numSessions];

				for(int i = 0; i < numSessions; i++)
				{
					createReq[i] = new XRLCreateUpdateSession();
					createResp[i] = new XRLSessionInfo();
					if(!createReq[i].Execute(Global.XEnv.GetInterface(Interface.xmatchfd)[0],out createResp[i]))
						Global.RO.Warn("Failed to create sessions");
				}
                // sp=5 takes one int param(sessID); no results should be returned
                XRLSearchSession    searchReq = new XRLSearchSession(5);
                XRLAttribParam[] Params = new XRLAttribParam[1]{new XRLAttribParam(Constants.X_ATTRIBUTE_DATATYPE_NULL,new XRLNullParam())};
                searchReq.AddParams(Params);
                XRLSearchResults    Resp;
                if(searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out Resp))
                {
                    if(Resp == null)
                        ResultCode=TEST_RESULTS.PASSED;
                }
				XRLDeleteSession   [] delReq = new XRLDeleteSession[numSessions];
				for(int i = 0; i < numSessions; i++)
				{
					delReq[i]=new XRLDeleteSession(createResp[i].SessionID);
					delReq[i].Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
				}
			}
        }
        [TestCase, Description("Bug 17764: truncation of strings")] class PTruncationString : TestBase
        {
                //1. in the xms file: the column size for 0x100004 must be 16(# of widechar)
                //2. in the returned results, must be another attribute following the string attrib
            override protected void Execute()
            {
                long    intValue = 8888;
                string    strValue = new string('b',16);
                strValue += '\0';
                // create a session with one string-title-session attrib and one int title-session attrib
                XRLCreateUpdateSession    createReq = new XRLCreateUpdateSession();
                createReq.baseSession.dwTitleID = 999;
                WireData[]    Attribs = new WireData[2];
                Attribs[0] = new XRLIntAttribute(0x00000005,intValue);
                Attribs[1] = new XRLStringAttribute(0x100004,strValue);
                createReq.AddAttribs(Attribs);
                XRLSessionInfo            createResp;
                if(createReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out createResp))
                {
                    // sp=1: two addtional attributes returned
                    XRLSearchSession    searchReq = new XRLSearchSession(1);
                    searchReq.baseSearchSession.dwTitleID = 999;
                    XRLSearchResults    Resp;

                    WireData [] expectedAttribs = new WireData[2];
                    expectedAttribs[0] = new XRLStringParam();
                    expectedAttribs[1] = new XRLIntParam();
                    if(searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), 1, expectedAttribs, out Resp))
                    {    // check if result had two addtional columns
                        uint dwExpectedLen = Constants.SIZEBASESEARCHRESULT+(2*4+8)+(2*4+2+17);
                        dwExpectedLen = (dwExpectedLen+(4-1))/4 * 4;    //padding
                        if(Resp.results[0].dwResultLength == dwExpectedLen)
                        {
                            // check the returned attributes values
                            XRLStringParam strTemp; XRLIntParam intTemp;
                            if((strTemp = Resp.results[0].Attribs[0].aValue as XRLStringParam) != null)
                            {
                                if(String.Compare(strTemp.strValue,strValue) == 0)
                                {
                                    if((intTemp = Resp.results[0].Attribs[1].aValue as XRLIntParam)!=null)
                                    {
                                        if(intTemp.intValue == intValue)
                                            ResultCode=TEST_RESULTS.PASSED;
                                    }
                                }
                            }
                        }
                    }
                    XRLDeleteSession    delReq = new XRLDeleteSession(createResp.SessionID);
                    delReq.dwTitleID = 999;
                    delReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                }
            }
        }
        [TestCase, Description("Search with X_SSINDEX_GET_SESSION stored procedure with a valid session ID")]
			class PSpecialSP1 : TestBase
        {
            override protected void Execute()
            {
                XRLCreateUpdateSession        createReq = new XRLCreateUpdateSession();
                XRLSessionInfo                createResp;
                if(createReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out createResp))
                {
                    long    lSessID = Constants.sessionIDConvert(createResp.SessionID);
                    // search based on sessionID
                    XRLSearchSession    searchReq = new XRLSearchSession(Constants.X_SSINDEX_GET_SESSION);
                    XRLAttribParam[] Params = new XRLAttribParam[1]{new XRLAttribParam(Constants.X_ATTRIBUTE_DATATYPE_INTEGER,new XRLIntParam(lSessID))};
                    searchReq.AddParams(Params);
                    XRLSearchResults    Resp;
                    if(searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out Resp))
                    {
                        if(Resp != null)    // detailed checking was done by FuncCreateSession verification
                            ResultCode=TEST_RESULTS.PASSED;
                    }
                    XRLDeleteSession    delReq = new XRLDeleteSession(createResp.SessionID);
                    delReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                }
            }
        }
        [TestCase, Description("Search with a sp that takes no parameter and return no attributes")]
			class PNoParamsSp : TestBase
        {
            override protected void Execute()
            {
				uint numSessions, numDB;
				numSessions = numDB = Constants.getNumDBForTitle(Constants.TITLE_ID);
				XRLCreateUpdateSession [] createReq = new XRLCreateUpdateSession[numSessions];
				XRLSessionInfo			[] createResp = new XRLSessionInfo[numSessions];
                // create one session on each db so we can ensure there will be 1 session returned
				for(int i = 0; i < numSessions; i++)
				{
					createReq[i] = new XRLCreateUpdateSession();
					createResp[i] = new XRLSessionInfo();
					if(!createReq[i].Execute(Global.XEnv.GetInterface(Interface.xmatchfd)[0],out createResp[i]))
						Global.RO.Warn("Failed to create sessions");
				}
				// search sessions
                XRLSearchSession    searchReq = new XRLSearchSession(0);
				searchReq.baseSearchSession.wFlags = Constants.XONLINE_MATCH_SEARCH_FLAG_NO_CACHE;
				XRLSearchResults    Resp;
                if(searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out Resp))
                {
                    if (Resp.resultsLen > 1) {
                        Global.RO.Warn("More than one session found.  Ensure the table is cleared before running this test.");
                    }
                    if((Resp.resultsLen == 1)&&
                        (Resp.dwMessageLength == Constants.SIZESEARCHHEADER+Constants.SIZEBASESEARCHRESULT))
                        ResultCode=TEST_RESULTS.PASSED;
                }
				XRLDeleteSession   [] delReq = new XRLDeleteSession[numSessions];
				for(int i = 0; i < numSessions; i++)
				{
					delReq[i]=new XRLDeleteSession(createResp[i].SessionID);
					delReq[i].Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
				}
            }
        }
        [TestCase, Description("Search with a sp that takes 1 int parameter and return no attributes")]
			class POneIntParamsSp : TestBase
        {
            override protected void Execute()
            {
				uint numSessions, numDB;
				numSessions = numDB = Constants.getNumDBForTitle(Constants.TITLE_ID);
				XRLCreateUpdateSession [] createReq = new XRLCreateUpdateSession[numSessions];
				XRLSessionInfo			[] createResp = new XRLSessionInfo[numSessions];
				// create one session on each db so we can ensure there will be 1 session returned
				for(int i = 0; i < numSessions; i++)
				{
					createReq[i] = new XRLCreateUpdateSession();
					createResp[i] = new XRLSessionInfo();
					if(!createReq[i].Execute(Global.XEnv.GetInterface(Interface.xmatchfd)[0],out createResp[i]))
						Global.RO.Warn("Failed to create sessions");
				}
                    // search sessions
                    XRLSearchSession    searchReq = new XRLSearchSession(1);
                    XRLAttribParam[]    Params = new XRLAttribParam[1]{new XRLAttribParam(Constants.X_ATTRIBUTE_DATATYPE_INTEGER,new XRLIntParam(12345))};
					searchReq.baseSearchSession.wFlags = Constants.XONLINE_MATCH_SEARCH_FLAG_NO_CACHE;
					searchReq.AddParams(Params);
                    XRLSearchResults    Resp;
                    if(searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out Resp))
                    {
                        if(    (Resp.resultsLen == 1)&&
                            (Resp.dwMessageLength == Constants.SIZESEARCHHEADER+Constants.SIZEBASESEARCHRESULT))
                            ResultCode=TEST_RESULTS.PASSED;
                    }
                XRLDeleteSession []   delReq = new XRLDeleteSession[numSessions];
				for(int i = 0; i < numSessions; i++)
				{
					delReq[i]=new XRLDeleteSession(createResp[i].SessionID);
					delReq[i].Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
				}
            }
        }
        [TestCase, Description("Search with a 400-char string parameter and return no attributes")]
			class PMaxStrParamSp : TestBase
        {
            override protected void Execute()
            {
				uint numSessions, numDB;
				numSessions = numDB = Constants.getNumDBForTitle(Constants.TITLE_ID);
				XRLCreateUpdateSession [] createReq = new XRLCreateUpdateSession[numSessions];
				XRLSessionInfo			[] createResp = new XRLSessionInfo[numSessions];
				// create one session on each db so we can ensure there will be 1 session returned
				for(int i = 0; i < numSessions; i++)
				{
					createReq[i] = new XRLCreateUpdateSession();
					createResp[i] = new XRLSessionInfo();
					if(!createReq[i].Execute(Global.XEnv.GetInterface(Interface.xmatchfd)[0],out createResp[i]))
						Global.RO.Warn("Failed to create sessions");
				}
				// search sessions
                    XRLSearchSession    searchReq = new XRLSearchSession(2);
                    string    strVal = new string('a',(int)(Constants.X_MAX_STRING_ATTRIBUTE_LEN-1));
                    strVal += '\0';
                    XRLAttribParam[]    Params = new XRLAttribParam[1]{new XRLAttribParam(Constants.X_ATTRIBUTE_DATATYPE_STRING,new XRLStringParam(strVal))};
					searchReq.baseSearchSession.wFlags = Constants.XONLINE_MATCH_SEARCH_FLAG_NO_CACHE;
					searchReq.AddParams(Params);
                    XRLSearchResults    Resp;
                    if(searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out Resp))
                    {
                        if(    (Resp.resultsLen == 1)&&
                            (Resp.dwMessageLength == Constants.SIZESEARCHHEADER+Constants.SIZEBASESEARCHRESULT))
                            ResultCode=TEST_RESULTS.PASSED;
                    }
				XRLDeleteSession []   delReq = new XRLDeleteSession[numSessions];
				for(int i = 0; i < numSessions; i++)
				{
					delReq[i]=new XRLDeleteSession(createResp[i].SessionID);
					delReq[i].Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
				}
            }
        }
        [TestCase, Description("Search with a 800byte blob parameter and return no attributes")]
			class PMaxBlobParamSp : TestBase
        {
            override protected void Execute()
            {
				uint numSessions, numDB;
				numSessions = numDB = Constants.getNumDBForTitle(Constants.TITLE_ID);
				XRLCreateUpdateSession [] createReq = new XRLCreateUpdateSession[numSessions];
				XRLSessionInfo			[] createResp = new XRLSessionInfo[numSessions];
				// create one session on each db so we can ensure there will be 1 session returned
				for(int i = 0; i < numSessions; i++)
				{
					createReq[i] = new XRLCreateUpdateSession();
					createResp[i] = new XRLSessionInfo();
					if(!createReq[i].Execute(Global.XEnv.GetInterface(Interface.xmatchfd)[0],out createResp[i]))
						Global.RO.Warn("Failed to create sessions");
				}
				// search sessions
                    XRLSearchSession    searchReq = new XRLSearchSession(3);
					searchReq.baseSearchSession.wFlags = Constants.XONLINE_MATCH_SEARCH_FLAG_NO_CACHE;
					byte [] blobParam = new byte[Constants.X_MAX_BLOB_ATTRIBUTE_LEN];
                    new Random().NextBytes(blobParam);
                    XRLAttribParam[]    Params = new XRLAttribParam[1]{new XRLAttribParam(Constants.X_ATTRIBUTE_DATATYPE_BLOB,new XRLBlobParam(blobParam))};
                    searchReq.AddParams(Params);
                    XRLSearchResults    Resp;
                    if(searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out Resp))
                    {
                        if( (Resp.resultsLen == 1)&&
                            (Resp.dwMessageLength == Constants.SIZESEARCHHEADER+Constants.SIZEBASESEARCHRESULT))
                            ResultCode=TEST_RESULTS.PASSED;
                    }
					XRLDeleteSession []   delReq = new XRLDeleteSession[numSessions];
					for(int i = 0; i < numSessions; i++)
					{
						delReq[i]=new XRLDeleteSession(createResp[i].SessionID);
						delReq[i].Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
					}
				}
        }
        [TestCase, Description("Search that returned session has one X_MAX_STRING_ATTRIBUTE_LEN(same as DB columnsize) string attrib followed by an int attrib")]
			class PSpecialSearch1 : SpecialSearchTestBase
        {
            override protected void Execute()
            {
                // create a session with one string and one int attributes
                XRLCreateUpdateSession        createReq = new XRLCreateUpdateSession();
                createReq.baseSession.dwTitleID = 9090;
                WireData    []                Attribs = new WireData[2];
                string    strVal = new string('a',(int)Constants.X_MAX_STRING_ATTRIBUTE_LEN);
                strVal += '\0';
                long    intVal = 6868;
                Attribs[0] = new XRLStringAttribute(0x0100002,strVal);
                Attribs[1] = new XRLIntAttribute(0x00000001,intVal);
                createReq.AddAttribs(Attribs);

                WireData [] expectedAttribs = new WireData[2];
                expectedAttribs[0] = new XRLStringParam(strVal);
                expectedAttribs[1] = new XRLIntParam(intVal);

                uint dwExpectedLen = Constants.SIZEBASESEARCHRESULT+(2*4+8)+
                                    (2*4+2+Constants.X_MAX_STRING_ATTRIBUTE_LEN+1);
                dwExpectedLen = (dwExpectedLen+(4-1))/4 * 4;    //padding
                if(this.createAndSearchVerify(createReq,expectedAttribs,dwExpectedLen,1))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }

        [TestCase, Description("returned string attrib is X_MAX_STRING_ATTRIBUTE_LEN-1(max DB columnsize-1)followed by an int attrib")]
			class PSpecialSearch2 : SpecialSearchTestBase
        {
            override protected void Execute()
            {
                // create a session with one string and one int attributes
                XRLCreateUpdateSession        createReq = new XRLCreateUpdateSession();
                createReq.baseSession.dwTitleID = 9090;
                WireData    []                Attribs = new WireData[2];
                string    strVal = new string('a',(int)Constants.X_MAX_STRING_ATTRIBUTE_LEN-1);
                strVal += '\0';
                long    intVal = 6868;
                Attribs[0] = new XRLStringAttribute(0x0100002,strVal);
                Attribs[1] = new XRLIntAttribute(0x00000001,intVal);
                createReq.AddAttribs(Attribs);

                WireData [] expectedAttribs = new WireData[2];
                expectedAttribs[0] = new XRLStringParam(strVal);
                expectedAttribs[1] = new XRLIntParam(intVal);
                uint dwExpectedLen = Constants.SIZEBASESEARCHRESULT+(2*4+8)+
                                    (2*4+2+Constants.X_MAX_STRING_ATTRIBUTE_LEN);
                dwExpectedLen = (dwExpectedLen+(4-1))/4 * 4;    //padding
                if(this.createAndSearchVerify(createReq,expectedAttribs,dwExpectedLen,1))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("returned string attrib is X_MAX_STRING_ATTRIBUTE_LEN(max DB columnsize)followed by a X_MAX_BLOB_ATTRIBUTE_LEN(same as max DB column)blob attrib")]
			class PSpecialSearch3 : SpecialSearchTestBase
        {
            override protected void Execute()
            {
                // create a session with one string and one blob attributes
                XRLCreateUpdateSession        createReq = new XRLCreateUpdateSession();
                createReq.baseSession.dwTitleID = 9090;
                WireData    []                Attribs = new WireData[2];
                string    strVal = new string('a',(int)Constants.X_MAX_STRING_ATTRIBUTE_LEN);
                strVal += '\0';
                byte [] blobVal = new byte[Constants.X_MAX_BLOB_ATTRIBUTE_LEN];
                for(int i = 0; i < Constants.X_MAX_BLOB_ATTRIBUTE_LEN; i++)
                    blobVal[i] = 8;
                Attribs[0] = new XRLStringAttribute(0x0100002,strVal);
                Attribs[1] = new XRLBlobAttribute(0x0200003,blobVal);
                createReq.AddAttribs(Attribs);

                WireData [] expectedAttribs = new WireData[2];
                expectedAttribs[0] = new XRLStringParam(strVal);
                expectedAttribs[1] = new XRLBlobParam(blobVal);
                uint dwExpectedLen = Constants.SIZEBASESEARCHRESULT+
                                    (2*4+2+Constants.X_MAX_STRING_ATTRIBUTE_LEN+1)+
                                    (2*4+2+Constants.X_MAX_BLOB_ATTRIBUTE_LEN);
                dwExpectedLen = (dwExpectedLen+(4-1))/4 * 4;    //padding
                if(this.createAndSearchVerify(createReq,expectedAttribs,dwExpectedLen,2))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("returned string attrib is X_MAX_STRING_ATTRIBUTE_LEN(max DB columnsize)followed by a X_MAX_BLOB_ATTRIBUTE_LEN-1(same as max DB column-1)blob attrib")]
			class PSpecialSearch4 : SpecialSearchTestBase
        {
            override protected void Execute()
            {
                // create a session with one string and one blob attributes
                XRLCreateUpdateSession        createReq = new XRLCreateUpdateSession();
                createReq.baseSession.dwTitleID = 9090;
                WireData    []                Attribs = new WireData[2];
                string    strVal = new string('a',(int)Constants.X_MAX_STRING_ATTRIBUTE_LEN);
                strVal += '\0';
                byte [] blobVal = new byte[Constants.X_MAX_BLOB_ATTRIBUTE_LEN-1];
                for(int i = 0; i < Constants.X_MAX_BLOB_ATTRIBUTE_LEN-1; i++)
                    blobVal[i] = 8;
                Attribs[0] = new XRLStringAttribute(0x0100002,strVal);
                Attribs[1] = new XRLBlobAttribute(0x0200003,blobVal);
                createReq.AddAttribs(Attribs);

                WireData [] expectedAttribs = new WireData[2];
                expectedAttribs[0] = new XRLStringParam(strVal);
                expectedAttribs[1] = new XRLBlobParam(blobVal);
                uint dwExpectedLen = Constants.SIZEBASESEARCHRESULT+
                    (2*4+2+Constants.X_MAX_STRING_ATTRIBUTE_LEN+1)+
                    (2*4+2+Constants.X_MAX_BLOB_ATTRIBUTE_LEN-1);
                dwExpectedLen = (dwExpectedLen+(4-1))/4 * 4;    //padding
                if(this.createAndSearchVerify(createReq,expectedAttribs,dwExpectedLen,2))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("returned string attrib is X_MAX_STRING_ATTRIBUTE_LEN(max DB columnsize)followed by a smaller size(much less than maxDB column)blob attrib")]
			class PSpecialSearch5 : SpecialSearchTestBase
        {
            override protected void Execute()
            {
                // create a session with one string and one blob attributes
                XRLCreateUpdateSession        createReq = new XRLCreateUpdateSession();
                createReq.baseSession.dwTitleID = 9090;
                WireData    []                Attribs = new WireData[2];
                string    strVal = new string('a',(int)Constants.X_MAX_STRING_ATTRIBUTE_LEN);
                strVal += '\0';
                byte [] blobVal = new byte[27];
                for(int i = 0; i <= 26; i++)
                    blobVal[i] = 8;
                Attribs[0] = new XRLStringAttribute(0x0100002,strVal);
                Attribs[1] = new XRLBlobAttribute(0x0200003,blobVal);
                createReq.AddAttribs(Attribs);

                WireData [] expectedAttribs = new WireData[2];
                expectedAttribs[0] = new XRLStringParam(strVal);
                expectedAttribs[1] = new XRLBlobParam(blobVal);
                uint dwExpectedLen = Constants.SIZEBASESEARCHRESULT+
                                    (2*4+2+Constants.X_MAX_STRING_ATTRIBUTE_LEN+1)+
                                    (2*4+2+(uint)blobVal.Length);
                dwExpectedLen = (dwExpectedLen+(4-1))/4 * 4;    //padding
                if(this.createAndSearchVerify(createReq,expectedAttribs,dwExpectedLen,2))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("returned X_MAX_BLOB_ATTRIBUTE_LEN blob followed by X_MAX_STRING_ATTRIBUTE_LEN-1 string attrib")]
			class PSpecialSearch6 : SpecialSearchTestBase
        {
            override protected void Execute()
            {
                // create a session with one string and one blob attributes
                XRLCreateUpdateSession        createReq = new XRLCreateUpdateSession();
                createReq.baseSession.dwTitleID = 9090;
                WireData    []                Attribs = new WireData[2];
                string    strVal = new string('a',(int)Constants.X_MAX_STRING_ATTRIBUTE_LEN-1);
                strVal += '\0';
                byte [] blobVal = new byte[Constants.X_MAX_BLOB_ATTRIBUTE_LEN];
                for(int i = 0; i < Constants.X_MAX_BLOB_ATTRIBUTE_LEN; i++)
                    blobVal[i] = 8;
                Attribs[1] = new XRLStringAttribute(0x0100002,strVal);
                Attribs[0] = new XRLBlobAttribute(0x0200003,blobVal);
                createReq.AddAttribs(Attribs);

                WireData [] expectedAttribs = new WireData[2];
                expectedAttribs[1] = new XRLStringParam(strVal);
                expectedAttribs[0] = new XRLBlobParam(blobVal);
                uint dwExpectedLen = Constants.SIZEBASESEARCHRESULT+
                                    (2*4+2+Constants.X_MAX_STRING_ATTRIBUTE_LEN)+
                                    (2*4+2+(uint)blobVal.Length);
                dwExpectedLen = (dwExpectedLen+(4-1))/4 * 4;    //padding
                if(this.createAndSearchVerify(createReq,expectedAttribs,dwExpectedLen,3))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("returned X_MAX_BLOB_ATTRIBUTE_LEN-1 blob followed by X_MAX_STRING_ATTRIBUTE_LEN string attrib")]
			class PSpecialSearch7 : SpecialSearchTestBase
        {
            override protected void Execute()
            {
                // create a session with one string and one blob attributes
                XRLCreateUpdateSession        createReq = new XRLCreateUpdateSession();
                createReq.baseSession.dwTitleID = 9090;
                WireData    []                Attribs = new WireData[2];
                string    strVal = new string('a',(int)Constants.X_MAX_STRING_ATTRIBUTE_LEN);
                strVal += '\0';
                byte [] blobVal = new byte[Constants.X_MAX_BLOB_ATTRIBUTE_LEN-1];
                for(int i = 0; i < Constants.X_MAX_BLOB_ATTRIBUTE_LEN-1; i++)
                    blobVal[i] = 8;
                Attribs[1] = new XRLStringAttribute(0x0100002,strVal);
                Attribs[0] = new XRLBlobAttribute(0x0200003,blobVal);
                createReq.AddAttribs(Attribs);

                WireData [] expectedAttribs = new WireData[2];
                expectedAttribs[0] = new XRLBlobParam(blobVal);
                expectedAttribs[1] = new XRLStringParam(strVal);
                uint dwExpectedLen = Constants.SIZEBASESEARCHRESULT+
                                    (2*4+2+(uint)strVal.Length)+
                                    (2*4+2+(uint)blobVal.Length);
                dwExpectedLen = (dwExpectedLen+(4-1))/4 * 4;    //padding
                if(this.createAndSearchVerify(createReq,expectedAttribs,dwExpectedLen,3))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("returned smaller blob(much smaller than DB columnsize) followed by one smaller string attrib")]
			class PSpecialSearch8 : SpecialSearchTestBase
        {
            override protected void Execute()
            {
                // create a session with one string and one blob attributes
                XRLCreateUpdateSession        createReq = new XRLCreateUpdateSession();
                createReq.baseSession.dwTitleID = 9090;
                WireData    []                Attribs = new WireData[2];
                string    strVal = new string('a',10);
                strVal += '\0';
                byte [] blobVal = new byte[21];
                for(int i = 0; i < 21; i++)
                    blobVal[i] = 8;
                Attribs[1] = new XRLStringAttribute(0x0100002,strVal);
                Attribs[0] = new XRLBlobAttribute(0x0200003,blobVal);
                createReq.AddAttribs(Attribs);

                WireData [] expectedAttribs = new WireData[2];
                expectedAttribs[0] = new XRLBlobParam(blobVal);
                expectedAttribs[1] = new XRLStringParam(strVal);
                uint dwExpectedLen = Constants.SIZEBASESEARCHRESULT+
                                    (2*4+2+(uint)strVal.Length)+
                                    (2*4+2+(uint)blobVal.Length);
                dwExpectedLen = (dwExpectedLen+(4-1))/4 * 4;    //padding
                if(this.createAndSearchVerify(createReq,expectedAttribs,dwExpectedLen,3))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("returned session has one int followed by one max string followed by one max blob")]
			class PSpecialSearch9 : SpecialSearchTestBase
        {
            override protected void Execute()
            {
                // create a session with one string and one blob attributes and one int attrib
                XRLCreateUpdateSession        createReq = new XRLCreateUpdateSession();
                createReq.baseSession.dwTitleID = 9090;
                WireData    []                Attribs = new WireData[3];
                ulong    intVal = 0xffffffffffffffff;
                string    strVal = new string('a',(int)Constants.X_MAX_STRING_ATTRIBUTE_LEN);
                strVal += '\0';
                byte [] blobVal = new byte[Constants.X_MAX_BLOB_ATTRIBUTE_LEN];
                for(int i = 0; i < blobVal.Length; i++)
                    blobVal[i] = 8;
                Attribs[0] = new XRLBlobAttribute(0x0200003,blobVal);
                Attribs[1] = new XRLStringAttribute(0x0100002,strVal);
                Attribs[2] = new XRLIntAttribute(0x00000001,(long)intVal);
                createReq.AddAttribs(Attribs);

                WireData [] expectedAttribs = new WireData[3];
                expectedAttribs[0] = new XRLIntParam((long)intVal);
                expectedAttribs[1] = new XRLStringParam(strVal);
                expectedAttribs[2] = new XRLBlobParam(blobVal);
                uint dwExpectedLen = Constants.SIZEBASESEARCHRESULT+
                                    (2*4+8)+
                                    (2*4+2+(uint)strVal.Length)+
                                    (2*4+2+(uint)blobVal.Length);
                dwExpectedLen = (dwExpectedLen+(4-1))/4 * 4;    //padding
                if(this.createAndSearchVerify(createReq,expectedAttribs,dwExpectedLen,4))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("Search so that more than 1 sessions returned(each session has int,string,blob)")]
			class PMoreResultsWithAttribs : TestBase
        {
            override protected void Execute()
            {
                // create two sessions with one int,one string and one blob attribs
                ulong    intVal = 0xffffffffffffffff;
                string    strVal = new string('a',15);
                strVal += '\0';
                byte[]    blobVal = new byte[8]{8,8,8,8,8,8,8,8};
                XRLCreateUpdateSession    createReq1, createReq2;
                XRLSessionInfo            createResp1,createResp2;
                createReq1 = new XRLCreateUpdateSession();
                createReq2 = new XRLCreateUpdateSession();
                createReq1.baseSession.dwTitleID = 9090;
                createReq2.baseSession.dwTitleID = 9090;
                WireData[]    Attribs = new WireData[3]{    new XRLIntAttribute(0x00000004,(long)intVal),
                                                        new XRLStringAttribute(0x0100005,strVal),
                                                        new XRLBlobAttribute(0x0200006,blobVal)};

                createReq1.AddAttribs(Attribs);
                createReq2.AddAttribs(Attribs);

                XRLIntParam        intTemp;
                XRLStringParam    strTemp;
                XRLBlobParam    blobTemp;
                bool                sameValue,ret = false;
                if(createReq1.Execute(Global.XEnv.GetInterface(Interface.xmatchfd)[0], out createResp1) &&
                    createReq2.Execute(Global.XEnv.GetInterface(Interface.xmatchfd)[0], out createResp2))
                {
                    // search so that 2 sessions will be returned
                    // sp = 5: int followed by string followed by blob
                    XRLSearchSession    searchReq = new XRLSearchSession(5);
                    searchReq.baseSearchSession.dwTitleID = 9090;
                    XRLSearchResults    Resp;
                    uint dwExpectedLen = Constants.SIZESEARCHHEADER+
                                        (Constants.SIZEBASESEARCHRESULT + 2*4+8+2*4+2+(uint)strVal.Length+2*4+2+(uint)blobVal.Length)*2;
                    WireData []        expectedAttribs = new WireData[3];
                    expectedAttribs[0] = new XRLIntParam();
                    expectedAttribs[1] = new XRLStringParam();
                    expectedAttribs[2] = new XRLBlobParam();
                    if(searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),2,expectedAttribs,out Resp))
                    {
                        // check searchResults
                        if(    (Resp.resultsLen == 2) &&
                            (Resp.dwMessageLength == dwExpectedLen))
                        {    // check the results detail
                            for(int j = 0; j < 2; j++)
                            {
                                sameValue = true;
                                ret = false;
                                if(((intTemp = Resp.results[j].Attribs[0].aValue as XRLIntParam) != null)
                                    && (intTemp.intValue == (long)intVal))
                                {
                                    if(((strTemp = Resp.results[j].Attribs[1].aValue as XRLStringParam) != null)
                                        && (string.Compare(strTemp.strValue, strVal) == 0))
                                        if(((blobTemp = Resp.results[j].Attribs[2].aValue as XRLBlobParam) != null)
                                            && (blobTemp.blobLen == blobVal.Length))
                                        {
                                            for(int i = 0; i < blobTemp.blobLen; i++)
                                                if(blobTemp.blob[i] != blobVal[i])
                                                {
                                                    sameValue = false;
                                                    break;
                                                }
                                            if(sameValue)
                                                ret = true;
                                        }
                                        else break;
                                    else break;
                                }
                                else break;
                                if(ret != true)
                                    break;
                            }
                            if(ret)
                                ResultCode=TEST_RESULTS.PASSED;
                        }
                    }
                    XRLDeleteSession    delReq1,delReq2;
                    delReq1 = new XRLDeleteSession(createResp1.SessionID);
                    delReq2 = new XRLDeleteSession(createResp2.SessionID);
                    delReq1.dwTitleID = delReq2.dwTitleID = 9090;
                    delReq1.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                    delReq2.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                }
            }
        }
        [TestCase, Description("pass int/string/blob paramters to a sp that takes 3 parameters and use them in filter")]
			class PThreeParams1 : TestBase
        {
            override protected void Execute()
            {
                long    intVal = 5454;
                string    strVal = "jklmn\0";
                byte []    blobVal = new byte[16];
                new Random().NextBytes(blobVal);
                WireData []        Attribs = new WireData[3]{
                                                        new XRLIntAttribute(43690,intVal),
                                                        new XRLStringAttribute(1092266,strVal),
                                                        new XRLBlobAttribute(2140842,blobVal)};
                // since 0xffed0001 resides on two dbs, we need to create 1 session on each db to ensure
                // we can get search result back
				uint numSessions, numDB;
				numSessions = numDB = Constants.getNumDBForTitle(Constants.TITLE_ID);
				XRLCreateUpdateSession [] createReq = new XRLCreateUpdateSession[numSessions];
				XRLSessionInfo			[] createResp = new XRLSessionInfo[numSessions];
				// create one session on each db so we can ensure there will be 1 session returned
				for(int i = 0; i < numSessions; i++)
				{
					createReq[i] = new XRLCreateUpdateSession();
					createReq[i].AddAttribs(Attribs);
					createResp[i] = new XRLSessionInfo();
					if(!createReq[i].Execute(Global.XEnv.GetInterface(Interface.xmatchfd)[0],out createResp[i]))
						Global.RO.Warn("Failed to create sessions");
				}
				// sp=33 search based on paramters passed in
                    XRLSearchSession    searchReq = new XRLSearchSession(33);
                    XRLAttribParam[] Params = new XRLAttribParam[3]{new XRLAttribParam(Constants.X_ATTRIBUTE_DATATYPE_INTEGER,new XRLIntParam(intVal)),
                                                        new XRLAttribParam(Constants.X_ATTRIBUTE_DATATYPE_STRING,new XRLStringParam(strVal)),
                                                        new XRLAttribParam(Constants.X_ATTRIBUTE_DATATYPE_BLOB,new XRLBlobParam(blobVal))};
                    searchReq.AddParams(Params);
                    XRLSearchResults    Resp;
                    if(searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out Resp))
                    {
                        bool sameSession = false;
                        if(Resp!=null && (Resp.resultsLen == 1))
                        {
							for(int j = 0; j < numSessions; j++)
							{
								for(int i = 0; i < 8; i++)
								{
									if(Resp.results[0].SessionID[i] != createResp[j].SessionID[i])
										break;
									else if(i==7)
										sameSession = true;
								}
							}
                            if(sameSession)
                             ResultCode=TEST_RESULTS.PASSED;
                        }
                    }

				XRLDeleteSession []   delReq = new XRLDeleteSession[numSessions];
				for(int i = 0; i < numSessions; i++)
				{
					delReq[i]=new XRLDeleteSession(createResp[i].SessionID);
					delReq[i].Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
				}
			}
        }
        [TestCase, Description("pass string/int/blob paramters to a sp that takes 3 parameter and use them in filter")]
			class PThreeParams2 : TestBase
        {
            override protected void Execute()
            {
                long    intVal = 5454;
                string    strVal = "jklmn\0";
                byte []    blobVal = new byte[16];
                new Random().NextBytes(blobVal);
                WireData []        Attribs = new WireData[3]{
                                                             new XRLStringAttribute(1092266,strVal),
                                                             new XRLIntAttribute(43690,intVal),
                                                             new XRLBlobAttribute(2140842,blobVal)};
				uint numSessions, numDB;
				numSessions = numDB = Constants.getNumDBForTitle(Constants.TITLE_ID);
				XRLCreateUpdateSession [] createReq = new XRLCreateUpdateSession[numSessions];
				XRLSessionInfo			[] createResp = new XRLSessionInfo[numSessions];
				// create one session on each db so we can ensure there will be 1 session returned
				for(int i = 0; i < numSessions; i++)
				{
					createReq[i] = new XRLCreateUpdateSession();
					createReq[i].AddAttribs(Attribs);
					createResp[i] = new XRLSessionInfo();
					if(!createReq[i].Execute(Global.XEnv.GetInterface(Interface.xmatchfd)[0],out createResp[i]))
						Global.RO.Warn("Failed to create sessions");
				}
                    // sp=33 search based on paramters passed in
                    XRLSearchSession    searchReq = new XRLSearchSession(39);
                    XRLAttribParam[] Params = new XRLAttribParam[3]{
                                                           new XRLAttribParam(Constants.X_ATTRIBUTE_DATATYPE_STRING,new XRLStringParam(strVal)),
                                                           new XRLAttribParam(Constants.X_ATTRIBUTE_DATATYPE_INTEGER,new XRLIntParam(intVal)),
                                                           new XRLAttribParam(Constants.X_ATTRIBUTE_DATATYPE_BLOB,new XRLBlobParam(blobVal))};
                    searchReq.AddParams(Params);
                    XRLSearchResults    Resp;
                    if(searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out Resp))
                    {
                        bool sameSession = false;
                        if(Resp!= null && (Resp.resultsLen == 1))
                        {
							for(int j = 0; j < numSessions; j++)
							{
								for(int i = 0; i < 8; i++)
								{
									if(Resp.results[0].SessionID[i] != createResp[j].SessionID[i])
										break;
									else if(i==7)
										sameSession = true;
								}
							}
							if(sameSession)
                                ResultCode=TEST_RESULTS.PASSED;
                        }
                    }

				XRLDeleteSession []   delReq = new XRLDeleteSession[numSessions];
				for(int i = 0; i < numSessions; i++)
				{
					delReq[i]=new XRLDeleteSession(createResp[i].SessionID);
					delReq[i].Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
				}
			}
        }
        [TestCase, Description("pass blob/string/int paramters to a sp that takes 3 parameter and use them in filter")]
			class PThreeParams3 : TestBase
        {
            override protected void Execute()
            {
                long    intVal = 5454;
                string    strVal = "jklmn\0";
                byte []    blobVal = new byte[16];
                new Random().NextBytes(blobVal);
                WireData []        Attribs = new WireData[3]{    new XRLBlobAttribute(2140842,blobVal),
                                                             new XRLStringAttribute(1092266,strVal),
                                                             new XRLIntAttribute(43690,intVal)};
				uint numSessions, numDB;
				numSessions = numDB = Constants.getNumDBForTitle(Constants.TITLE_ID);
				XRLCreateUpdateSession [] createReq = new XRLCreateUpdateSession[numSessions];
				XRLSessionInfo			[] createResp = new XRLSessionInfo[numSessions];
				// create one session on each db so we can ensure there will be 1 session returned
				for(int i = 0; i < numSessions; i++)
				{
					createReq[i] = new XRLCreateUpdateSession();
					createReq[i].AddAttribs(Attribs);
					createResp[i] = new XRLSessionInfo();
					if(!createReq[i].Execute(Global.XEnv.GetInterface(Interface.xmatchfd)[0],out createResp[i]))
						Global.RO.Warn("Failed to create sessions");
				}
				// sp=33 search based on paramters passed in
                    XRLSearchSession    searchReq = new XRLSearchSession(40);
                    XRLAttribParam[] Params = new XRLAttribParam[3]{new XRLAttribParam(Constants.X_ATTRIBUTE_DATATYPE_BLOB,new XRLBlobParam(blobVal)),
                                                        new XRLAttribParam(Constants.X_ATTRIBUTE_DATATYPE_STRING,new XRLStringParam(strVal)),
                                                        new XRLAttribParam(Constants.X_ATTRIBUTE_DATATYPE_INTEGER,new XRLIntParam(intVal))
                                                        };
                    searchReq.AddParams(Params);
                    XRLSearchResults    Resp;
                    if(searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out Resp))
                    {
                        bool sameSession = false;
                        if(Resp!=null && (Resp.resultsLen == 1))
                        {
							for(int j = 0; j < numSessions; j++)
							{
								for(int i = 0; i < 8; i++)
								{
									if(Resp.results[0].SessionID[i] != createResp[j].SessionID[i])
										break;
									else if(i==7)
										sameSession = true;
								}
							}
							if(sameSession)
                                ResultCode=TEST_RESULTS.PASSED;
                        }
                    }

					XRLDeleteSession []   delReq = new XRLDeleteSession[numSessions];
					for(int i = 0; i < numSessions; i++)
					{
						delReq[i]=new XRLDeleteSession(createResp[i].SessionID);
						delReq[i].Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
					}
				}
        }
        [TestCase, Description("31552:pass int/blob/string paramters to a sp that takes 3 parameter and use them in filter")]
			class PThreeParams4 : TestBase
        {
            override protected void Execute()
            {
                long    intVal = 5454;
                string    strVal = "jklmn\0";
                byte []    blobVal = new byte[16];
                new Random().NextBytes(blobVal);
                WireData []        Attribs = new WireData[3]{    new XRLBlobAttribute(2140842,blobVal),
                                                            new XRLStringAttribute(1092266,strVal),
                                                            new XRLIntAttribute(43690,intVal)};
				uint numSessions, numDB;
				numSessions = numDB = Constants.getNumDBForTitle(Constants.TITLE_ID);
				XRLCreateUpdateSession [] createReq = new XRLCreateUpdateSession[numSessions];
				XRLSessionInfo			[] createResp = new XRLSessionInfo[numSessions];
				// create one session on each db so we can ensure there will be 1 session returned
				for(int i = 0; i < numSessions; i++)
				{
					createReq[i] = new XRLCreateUpdateSession();
					createReq[i].AddAttribs(Attribs);
					createResp[i] = new XRLSessionInfo();
					if(!createReq[i].Execute(Global.XEnv.GetInterface(Interface.xmatchfd)[0],out createResp[i]))
						Global.RO.Warn("Failed to create sessions");
				}
				// sp=33 search based on paramters passed in
                    XRLSearchSession    searchReq = new XRLSearchSession(41);
                    XRLAttribParam[] Params = new XRLAttribParam[3]{new XRLAttribParam(Constants.X_ATTRIBUTE_DATATYPE_INTEGER,new XRLIntParam(intVal)),
                                                            new XRLAttribParam(Constants.X_ATTRIBUTE_DATATYPE_BLOB,new XRLBlobParam(blobVal)),
                                                            new XRLAttribParam(Constants.X_ATTRIBUTE_DATATYPE_STRING,new XRLStringParam(strVal))
                    };
                    searchReq.AddParams(Params);
                    XRLSearchResults    Resp;
                    if(searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out Resp))
                    {
                        bool sameSession = false;
                        if(Resp!=null && (Resp.resultsLen == 1))
                        {
							for(int j = 0; j < numSessions; j++)
							{
								for(int i = 0; i < 8; i++)
								{
									if(Resp.results[0].SessionID[i] != createResp[j].SessionID[i])
										break;
									else if(i==7)
										sameSession = true;
								}
							}
							if(sameSession)
                                ResultCode=TEST_RESULTS.PASSED;
                        }
                    }

				XRLDeleteSession []   delReq = new XRLDeleteSession[numSessions];
				for(int i = 0; i < numSessions; i++)
				{
					delReq[i]=new XRLDeleteSession(createResp[i].SessionID);
					delReq[i].Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
				}
			}
        }
        [TestCase, Description("pass string/blob/int paramters to a sp that takes 3 parameter and use them in filter")]
			class PThreeParams5 : TestBase
        {
            override protected void Execute()
            {
                long    intVal = 5454;
                string    strVal = "jklmn\0";
                byte []    blobVal = new byte[16];
                new Random().NextBytes(blobVal);
                WireData []        Attribs = new WireData[3]{    new XRLBlobAttribute(2140842,blobVal),
                                                            new XRLStringAttribute(1092266,strVal),
                                                            new XRLIntAttribute(43690,intVal)};
				uint numSessions, numDB;
				numSessions = numDB = Constants.getNumDBForTitle(Constants.TITLE_ID);
				XRLCreateUpdateSession [] createReq = new XRLCreateUpdateSession[numSessions];
				XRLSessionInfo			[] createResp = new XRLSessionInfo[numSessions];
				// create one session on each db so we can ensure there will be 1 session returned
				for(int i = 0; i < numSessions; i++)
				{
					createReq[i] = new XRLCreateUpdateSession();
					createReq[i].AddAttribs(Attribs);
					createResp[i] = new XRLSessionInfo();
					if(!createReq[i].Execute(Global.XEnv.GetInterface(Interface.xmatchfd)[0],out createResp[i]))
						Global.RO.Warn("Failed to create sessions");
				}
				// sp=33 search based on paramters passed in
                    XRLSearchSession    searchReq = new XRLSearchSession(42);
                    XRLAttribParam[] Params = new XRLAttribParam[3]{new XRLAttribParam(Constants.X_ATTRIBUTE_DATATYPE_STRING,new XRLStringParam(strVal)),
                                                        new XRLAttribParam(Constants.X_ATTRIBUTE_DATATYPE_BLOB,new XRLBlobParam(blobVal)),
                                                        new XRLAttribParam(Constants.X_ATTRIBUTE_DATATYPE_INTEGER,new XRLIntParam(intVal))
                                                       };
                    searchReq.AddParams(Params);
                    XRLSearchResults    Resp;
                    if(searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out Resp))
                    {
                        bool sameSession = false;
                        if(Resp!= null &&(Resp.resultsLen == 1))
                        {
							for(int j = 0; j < numSessions; j++)
							{
								for(int i = 0; i < 8; i++)
								{
									if(Resp.results[0].SessionID[i] != createResp[j].SessionID[i])
										break;
									else if(i==7)
										sameSession = true;
								}
							}
							if(sameSession)
                                ResultCode=TEST_RESULTS.PASSED;
                        }
                    }

				XRLDeleteSession []   delReq = new XRLDeleteSession[numSessions];
				for(int i = 0; i < numSessions; i++)
				{
					delReq[i]=new XRLDeleteSession(createResp[i].SessionID);
					delReq[i].Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
				}
			}
        }
        [TestCase, Description("31552:pass blob/int/string paramters to a sp that takes 3 parameter and use them in filter")]
			class PThreeParams6 : TestBase
        {
            override protected void Execute()
            {
                long    intVal = 5454;
                string    strVal = "jklmn\0";
                byte []    blobVal = new byte[16];
                new Random().NextBytes(blobVal);
                WireData []        Attribs = new WireData[3]{    new XRLBlobAttribute(2140842,blobVal),
                                                            new XRLStringAttribute(1092266,strVal),
                                                            new XRLIntAttribute(43690,intVal)};
				uint numSessions, numDB;
				numSessions = numDB = Constants.getNumDBForTitle(Constants.TITLE_ID);
				XRLCreateUpdateSession [] createReq = new XRLCreateUpdateSession[numSessions];
				XRLSessionInfo			[] createResp = new XRLSessionInfo[numSessions];
				// create one session on each db so we can ensure there will be 1 session returned
				for(int i = 0; i < numSessions; i++)
				{
					createReq[i] = new XRLCreateUpdateSession();
					createReq[i].AddAttribs(Attribs);
					createResp[i] = new XRLSessionInfo();
					if(!createReq[i].Execute(Global.XEnv.GetInterface(Interface.xmatchfd)[0],out createResp[i]))
						Global.RO.Warn("Failed to create sessions");
				}
				// sp=33 search based on paramters passed in
                    XRLSearchSession    searchReq = new XRLSearchSession(43);
                    XRLAttribParam[] Params = new XRLAttribParam[3]{
                                                        new XRLAttribParam(Constants.X_ATTRIBUTE_DATATYPE_BLOB,new XRLBlobParam(blobVal)),
                                                        new XRLAttribParam(Constants.X_ATTRIBUTE_DATATYPE_INTEGER,new XRLIntParam(intVal)),
                                                        new XRLAttribParam(Constants.X_ATTRIBUTE_DATATYPE_STRING,new XRLStringParam(strVal))
                                                       };
                    searchReq.AddParams(Params);
                    XRLSearchResults    Resp;
                    if(searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out Resp))
                    {
                        bool sameSession = false;
                        if(Resp!=null && (Resp.resultsLen == 1))
                        {
							for(int j = 0; j < numSessions; j++)
							{
								for(int i = 0; i < 8; i++)
								{
									if(Resp.results[0].SessionID[i] != createResp[j].SessionID[i])
										break;
									else if(i==7)
										sameSession = true;
								}
							}
							if(sameSession)
                                ResultCode=TEST_RESULTS.PASSED;
                        }
                    }

					XRLDeleteSession []   delReq = new XRLDeleteSession[numSessions];
					for(int i = 0; i < numSessions; i++)
					{
						delReq[i]=new XRLDeleteSession(createResp[i].SessionID);
						delReq[i].Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
					}
				}
        }
		[TestCase, Description("pass NULL parameter to a sp that takes blob/int/string and use the null in filter")]
			class PNullParamInFilter : TestBase
		{
			override protected void Execute()
			{
				long    intVal = 5454;
				string    strVal = "jklmn\0";
				byte []    blobVal = new byte[16];
				new Random().NextBytes(blobVal);
				WireData []        Attribs = new WireData[3]{    new XRLBlobAttribute(2140842,blobVal),
																new XRLStringAttribute(1092266,strVal),
																new XRLIntAttribute(43690,intVal)};
				uint numSessions, numDB;
				numSessions = numDB = Constants.getNumDBForTitle(Constants.TITLE_ID);
				XRLCreateUpdateSession [] createReq = new XRLCreateUpdateSession[numSessions];
				XRLSessionInfo			[] createResp = new XRLSessionInfo[numSessions];
				// create one session on each db so we can ensure there will be 1 session returned
				for(int i = 0; i < numSessions; i++)
				{
					createReq[i] = new XRLCreateUpdateSession();
					createReq[i].AddAttribs(Attribs);
					createResp[i] = new XRLSessionInfo();
					if(!createReq[i].Execute(Global.XEnv.GetInterface(Interface.xmatchfd)[0],out createResp[i]))
						Global.RO.Warn("Failed to create sessions");
				}
				// sp=43 search based on paramters passed in
				// pass NULL instead of int as the 2nd parameter
				XRLSearchSession    searchReq = new XRLSearchSession(43);
				XRLAttribParam[] Params = new XRLAttribParam[3]{
													   new XRLAttribParam(Constants.X_ATTRIBUTE_DATATYPE_BLOB,new XRLBlobParam(blobVal)),
													   new XRLAttribParam(Constants.X_ATTRIBUTE_DATATYPE_NULL,new XRLNullParam()),
													   new XRLAttribParam(Constants.X_ATTRIBUTE_DATATYPE_STRING,new XRLStringParam(strVal))
												   };
				searchReq.AddParams(Params);
				XRLSearchResults    Resp;
				if(searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out Resp))
				{
					bool sameSession = false;
					if(Resp!=null && (Resp.resultsLen == 1))
					{
						for(int j = 0; j < numSessions; j++)
						{
							for(int i = 0; i < 8; i++)
							{
								if(Resp.results[0].SessionID[i] != createResp[j].SessionID[i])
									break;
								else if(i==7)
									sameSession = true;
							}
						}
						if(sameSession)
							ResultCode=TEST_RESULTS.PASSED;
					}
				}

				XRLDeleteSession []   delReq = new XRLDeleteSession[numSessions];
				for(int i = 0; i < numSessions; i++)
				{
					delReq[i]=new XRLDeleteSession(createResp[i].SessionID);
					delReq[i].Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
				}
			}
		}
        [TestCase, Description("returned session has int/max blob/string attributes in that order")]
			class PThreeAttribs1 : TestBase
        {
            override protected void Execute()
            {
                long    intVal = 5454;
                string    strVal = "jklmn\0";
                byte []    blobVal = new byte[Constants.X_MAX_BLOB_ATTRIBUTE_LEN];
                new Random().NextBytes(blobVal);
                XRLCreateUpdateSession        createReq = new XRLCreateUpdateSession();
                createReq.baseSession.dwTitleID = 0x3e7;
                WireData []        Attribs = new WireData[3]{    new XRLBlobAttribute(0x200008,blobVal),
                                                             new XRLStringAttribute(0x100007,strVal),
                                                             new XRLIntAttribute(0x6,intVal)};
                createReq.AddAttribs(Attribs);
                XRLSessionInfo                createResp;
                if(createReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out createResp))
                {
                    long    SessID = Constants.sessionIDConvert(createResp.SessionID);
                    // sp=10 search based on sessionID
                    XRLSearchSession    searchReq = new XRLSearchSession(10);
                    searchReq.baseSearchSession.dwTitleID = 0x3e7;
                    XRLAttribParam[] Params = new XRLAttribParam[1]{new XRLAttribParam(Constants.X_ATTRIBUTE_DATATYPE_INTEGER,new XRLIntParam(SessID))};
                    searchReq.AddParams(Params);
                    XRLSearchResults    Resp;
                    WireData [] expectedAttribs = new WireData[3]{    new XRLIntParam(),
                                                                     new XRLBlobParam(),
                                                                     new XRLStringParam()};
                    if(searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),1,expectedAttribs,out Resp))
                    {
                        XRLIntParam        intTemp;
                        XRLStringParam    strTemp;
                        XRLBlobParam    blobTemp;
                        bool                sameVal = true;
                        if(Resp!=null && (Resp.resultsLen == 1))
                        {    // check returned attribs
                            if(((intTemp=Resp.results[0].Attribs[0].aValue as XRLIntParam)!=null) &&
                                ((blobTemp=Resp.results[0].Attribs[1].aValue as XRLBlobParam)!= null) &&
                                ((strTemp=Resp.results[0].Attribs[2].aValue as XRLStringParam) != null))
                            {
                                if((intTemp.intValue==intVal) &&((string.Compare(strTemp.strValue,strVal) == 0)))
                                {
                                     if(blobTemp.blobLen == blobVal.Length)
                                         for(int i = 0; i < blobVal.Length; i++)
                                             if(blobTemp.blob[i]!=blobVal[i])
                                             {
                                                 sameVal=false; break;
                                             }
                                     if(sameVal)
                                         ResultCode=TEST_RESULTS.PASSED;
                                }
                            }
                        }
                    }
                    XRLDeleteSession    delReq = new XRLDeleteSession(createResp.SessionID);
                    delReq.dwTitleID = 0x3e7;
                    delReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));                }
            }
        }
        [TestCase, Description("returned session has empty string/int/blob attributes in that order")]
			class PThreeAttribs2 : TestBase
        {
            override protected void Execute()
            {
                long    intVal = 5454;
                string    strVal = "\0";
                byte []    blobVal = new byte[16];
                new Random().NextBytes(blobVal);
                XRLCreateUpdateSession        createReq = new XRLCreateUpdateSession();
                createReq.baseSession.dwTitleID = 0x3e7;
                WireData []        Attribs = new WireData[3]{    new XRLBlobAttribute(0x200008,blobVal),
                                                             new XRLStringAttribute(0x100007,strVal),
                                                             new XRLIntAttribute(0x6,intVal)};
                createReq.AddAttribs(Attribs);
                XRLSessionInfo                createResp;
                if(createReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out createResp))
                {
                    long    SessID = Constants.sessionIDConvert(createResp.SessionID);
                    // sp=6 search based on sessionID
                    XRLSearchSession    searchReq = new XRLSearchSession(6);
                    searchReq.baseSearchSession.dwTitleID = 0x3e7;
					XRLAttribParam[] Params = new XRLAttribParam[1]{new XRLAttribParam(Constants.X_ATTRIBUTE_DATATYPE_INTEGER,new XRLIntParam(SessID))};
					searchReq.AddParams(Params);
                    XRLSearchResults    Resp;
                    WireData [] expectedAttribs = new WireData[3]{    new XRLStringParam(),
                                                                     new XRLIntParam(),
                                                                     new XRLBlobParam()
                                                                };
                    if(searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),1,expectedAttribs,out Resp))
                    {
                        XRLIntParam        intTemp;
                        XRLStringParam    strTemp;
                        XRLBlobParam    blobTemp;
                        bool                sameVal = true;
                        if(Resp!=null && (Resp.resultsLen == 1))
                        {    // check returned attribs
                            if(((intTemp=Resp.results[0].Attribs[1].aValue as XRLIntParam)!=null) &&
                                ((blobTemp=Resp.results[0].Attribs[2].aValue as XRLBlobParam)!= null) &&
                                ((strTemp=Resp.results[0].Attribs[0].aValue as XRLStringParam) != null))
                            {
                                if((intTemp.intValue==intVal) &&((string.Compare(strTemp.strValue,strVal) == 0)))
                                {
                                    if(blobTemp.blobLen == blobVal.Length)
                                        for(int i = 0; i < blobVal.Length; i++)
                                            if(blobTemp.blob[i]!=blobVal[i])
                                            {
                                                sameVal=false; break;
                                            }
                                    if(sameVal)
                                        ResultCode=TEST_RESULTS.PASSED;
                                }
                            }
                        }
                    }
                    XRLDeleteSession    delReq = new XRLDeleteSession(createResp.SessionID);
                    delReq.dwTitleID = 0x3e7;
                    delReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                }
            }
        }
        [TestCase, Description("returned session has max string/blob/int attributes in that order")]
			class PThreeAttribs3 : TestBase
        {
            override protected void Execute()
            {
                long    intVal = 5454;
                string    strVal = new string('a',(int)Constants.X_MAX_STRING_ATTRIBUTE_LEN)+'\0';
                byte []    blobVal = new byte[16];
                new Random().NextBytes(blobVal);
                XRLCreateUpdateSession        createReq = new XRLCreateUpdateSession();
                createReq.baseSession.dwTitleID = 0x3e7;
                WireData []        Attribs = new WireData[3]{    new XRLBlobAttribute(0x200008,blobVal),
                                                             new XRLStringAttribute(0x100007,strVal),
                                                             new XRLIntAttribute(0x6,intVal)};
                createReq.AddAttribs(Attribs);
                XRLSessionInfo                createResp;
                if(createReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out createResp))
                {
                    long    SessID = Constants.sessionIDConvert(createResp.SessionID);
                    // sp=7 search based on sessionID
                    XRLSearchSession    searchReq = new XRLSearchSession(7);
                    searchReq.baseSearchSession.dwTitleID = 0x3e7;
					XRLAttribParam[] Params = new XRLAttribParam[1]{new XRLAttribParam(Constants.X_ATTRIBUTE_DATATYPE_INTEGER,new XRLIntParam(SessID))};
					searchReq.AddParams(Params);
                    XRLSearchResults    Resp;
                    WireData [] expectedAttribs = new WireData[3]{    new XRLStringParam(),
                                                                     new XRLBlobParam(),
                                                                     new XRLIntParam()
                                                                 };
                    if(searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),1,expectedAttribs,out Resp))
                    {
                        XRLIntParam        intTemp;
                        XRLStringParam    strTemp;
                        XRLBlobParam    blobTemp;
                        bool                sameVal = true;
                        if(Resp!=null && (Resp.resultsLen == 1))
                        {    // check returned attribs
                            if(((intTemp=Resp.results[0].Attribs[2].aValue as XRLIntParam)!=null) &&
                                ((blobTemp=Resp.results[0].Attribs[1].aValue as XRLBlobParam)!= null) &&
                                ((strTemp=Resp.results[0].Attribs[0].aValue as XRLStringParam) != null))
                            {
                                if((intTemp.intValue==intVal) &&((string.Compare(strTemp.strValue,strVal) == 0)))
                                {
                                    if(blobTemp.blobLen == blobVal.Length)
                                        for(int i = 0; i < blobVal.Length; i++)
                                            if(blobTemp.blob[i]!=blobVal[i])
                                            {
                                                sameVal=false; break;
                                            }
                                    if(sameVal)
                                        ResultCode=TEST_RESULTS.PASSED;
                                }
                            }
                        }
                    }
                    XRLDeleteSession    delReq = new XRLDeleteSession(createResp.SessionID);
                    delReq.dwTitleID = 0x3e7;
                    delReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                }
            }
        }
        [TestCase, Description("returned session has blob/int/string attributes in that order")]
			class PThreeAttribs4 : TestBase
        {
            override protected void Execute()
            {
                long    intVal = 5454;
                string    strVal = "jklmn\0";
                byte []    blobVal = new byte[16];
                new Random().NextBytes(blobVal);
                XRLCreateUpdateSession        createReq = new XRLCreateUpdateSession();
                createReq.baseSession.dwTitleID = 0x3e7;
                WireData []        Attribs = new WireData[3]{    new XRLBlobAttribute(0x200008,blobVal),
                                                             new XRLStringAttribute(0x100007,strVal),
                                                             new XRLIntAttribute(0x6,intVal)};
                createReq.AddAttribs(Attribs);
                XRLSessionInfo                createResp;
                if(createReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out createResp))
                {
                    long    SessID = Constants.sessionIDConvert(createResp.SessionID);
                    // sp=8 search based on sessionID
                    XRLSearchSession    searchReq = new XRLSearchSession(8);
                    searchReq.baseSearchSession.dwTitleID = 0x3e7;
					XRLAttribParam[] Params = new XRLAttribParam[1]{new XRLAttribParam(Constants.X_ATTRIBUTE_DATATYPE_INTEGER,new XRLIntParam(SessID))};
					searchReq.AddParams(Params);
                    XRLSearchResults    Resp;
                    WireData [] expectedAttribs = new WireData[3]{
                                                                    new XRLBlobParam(),
                                                                    new XRLIntParam(),
                                                                    new XRLStringParam()
                                                                 };
                    if(searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),1,expectedAttribs,out Resp))
                    {
                        XRLIntParam        intTemp;
                        XRLStringParam    strTemp;
                        XRLBlobParam    blobTemp;
                        bool                sameVal = true;
                        if(Resp!=null && (Resp.resultsLen == 1))
                        {    // check returned attribs
                            if(((intTemp=Resp.results[0].Attribs[1].aValue as XRLIntParam)!=null) &&
                                ((blobTemp=Resp.results[0].Attribs[0].aValue as XRLBlobParam)!= null) &&
                                ((strTemp=Resp.results[0].Attribs[2].aValue as XRLStringParam) != null))
                            {
                                if((intTemp.intValue==intVal) &&(string.Compare(strTemp.strValue,strVal) == 0))
                                {
                                    if(blobTemp.blobLen == blobVal.Length)
                                        for(int i = 0; i < blobVal.Length; i++)
                                            if(blobTemp.blob[i]!=blobVal[i])
                                            {
                                                sameVal=false; break;
                                            }
                                    if(sameVal)
                                        ResultCode=TEST_RESULTS.PASSED;
                                }
                            }
                        }
                    }
                    XRLDeleteSession    delReq = new XRLDeleteSession(createResp.SessionID);
                    delReq.dwTitleID = 0x3e7;
                    delReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                }
            }
        }
        [TestCase, Description("returned session has blob/string/int attributes in that order")]
			class PThreeAttribs5 : TestBase
        {
            override protected void Execute()
            {
                long    intVal = 5454;
                string    strVal = "jklmn\0";
                byte []    blobVal = new byte[16];
                new Random().NextBytes(blobVal);
                XRLCreateUpdateSession        createReq = new XRLCreateUpdateSession();
                createReq.baseSession.dwTitleID = 0x3e7;
                WireData []        Attribs = new WireData[3]{    new XRLBlobAttribute(0x200008,blobVal),
                                                             new XRLStringAttribute(0x100007,strVal),
                                                             new XRLIntAttribute(0x6,intVal)};
                createReq.AddAttribs(Attribs);
                XRLSessionInfo                createResp;
                if(createReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out createResp))
                {
                    long    SessID = Constants.sessionIDConvert(createResp.SessionID);
                    // sp=9 search based on sessionID
                    XRLSearchSession    searchReq = new XRLSearchSession(9);
                    searchReq.baseSearchSession.dwTitleID = 0x3e7;
					XRLAttribParam[] Params = new XRLAttribParam[1]{new XRLAttribParam(Constants.X_ATTRIBUTE_DATATYPE_INTEGER,new XRLIntParam(SessID))};
					searchReq.AddParams(Params);
                    XRLSearchResults    Resp;
                    WireData [] expectedAttribs = new WireData[3]{    new XRLBlobParam(),
                                                                     new XRLStringParam(),
                                                                     new XRLIntParam()
                                                                 };
                    if(searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),1,expectedAttribs,out Resp))
                    {
                        XRLIntParam        intTemp;
                        XRLStringParam    strTemp;
                        XRLBlobParam    blobTemp;
                        bool                sameVal = true;
                        if(Resp!=null && (Resp.resultsLen == 1))
                        {    // check returned attribs
                            if(((intTemp=Resp.results[0].Attribs[2].aValue as XRLIntParam)!=null) &&
                                ((blobTemp=Resp.results[0].Attribs[0].aValue as XRLBlobParam)!= null) &&
                                ((strTemp=Resp.results[0].Attribs[1].aValue as XRLStringParam) != null))
                            {
                                if((intTemp.intValue==intVal) &&((string.Compare(strTemp.strValue,strVal) == 0)))
                                {
                                    if(blobTemp.blobLen == blobVal.Length)
                                        for(int i = 0; i < blobVal.Length; i++)
                                            if(blobTemp.blob[i]!=blobVal[i])
                                            {
                                                sameVal=false; break;
                                            }
                                    if(sameVal)
                                        ResultCode=TEST_RESULTS.PASSED;
                                }
                            }
                        }
                    }
                    XRLDeleteSession    delReq = new XRLDeleteSession(createResp.SessionID);
                    delReq.dwTitleID = 0x3e7;
                    delReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                }
            }
        }
        [TestCase, Description("returned session has three null attributes")]
			class PReturnNullAttrib1 : TestBase
        {
            override protected void Execute()
            {
                XRLCreateUpdateSession        createReq = new XRLCreateUpdateSession();
                createReq.baseSession.dwTitleID = 0x3e7;
                XRLSessionInfo                createResp;
                // create a session with no attributes
                if(createReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out createResp))
                {
                    long    SessID = Constants.sessionIDConvert(createResp.SessionID);
                    // sp=9 search based on sessionID; return three attributes
                    XRLSearchSession    searchReq = new XRLSearchSession(9);
                    searchReq.baseSearchSession.dwTitleID = 0x3e7;
					XRLAttribParam[] Params = new XRLAttribParam[1]{new XRLAttribParam(Constants.X_ATTRIBUTE_DATATYPE_INTEGER,new XRLIntParam(SessID))};
					searchReq.AddParams(Params);
                    XRLSearchResults    Resp;
                    WireData [] expectedAttribs = new WireData[3]{    new XRLNullParam(),
                                                                     new XRLNullParam(),
                                                                     new XRLNullParam()
                                                                 };
                    if(searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),1,expectedAttribs,out Resp))
                    {
                        if(Resp!=null && (Resp.resultsLen == 1))
                        {    // check returned attribs
                            if((Resp.results[0].Attribs[2].aValue as XRLNullParam!=null) &&
                                (Resp.results[0].Attribs[0].aValue as XRLNullParam!= null) &&
                                (Resp.results[0].Attribs[1].aValue as XRLNullParam != null))
                                        ResultCode=TEST_RESULTS.PASSED;
                        }
                    }
                    XRLDeleteSession    delReq = new XRLDeleteSession(createResp.SessionID);
                    delReq.dwTitleID = 0x3e7;
                    delReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                }
            }
        }
        [TestCase, Description("returned session has one null attributes")]
			class PReturnNullAttrib2 : TestBase
        {
            override protected void Execute()
            {
                XRLCreateUpdateSession        createReq = new XRLCreateUpdateSession();
                createReq.baseSession.dwTitleID = 0x3e7;
                XRLSessionInfo                createResp;
                // create a session with no attributes
                if(createReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out createResp))
                {
                    long    SessID = Constants.sessionIDConvert(createResp.SessionID);
                    // sp=2 search based on sessionID; return ont int attributes
                    XRLSearchSession    searchReq = new XRLSearchSession(2);
                    searchReq.baseSearchSession.dwTitleID = 0x3e7;
					XRLAttribParam[] Params = new XRLAttribParam[1]{new XRLAttribParam(Constants.X_ATTRIBUTE_DATATYPE_INTEGER,new XRLIntParam(SessID))};
					searchReq.AddParams(Params);
                    XRLSearchResults    Resp;
                    WireData [] expectedAttribs = new WireData[1]{    new XRLNullParam()};

                    if(searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),1,expectedAttribs,out Resp))
                    {
                        if(Resp!=null && (Resp.resultsLen == 1))
                        {    // check returned attribs
                            if(Resp.results[0].Attribs[0].aValue as XRLNullParam!=null)
                                ResultCode=TEST_RESULTS.PASSED;
                        }
                    }
                    XRLDeleteSession    delReq = new XRLDeleteSession(createResp.SessionID);
                    delReq.dwTitleID = 0x3e7;
                    delReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                }
            }
        }
        [TestCase, Description("returned session has int/null/string attributes in that order")]
			class PReturnNullAttrib3 : TestBase
        {
            override protected void Execute()
            {
                XRLCreateUpdateSession        createReq = new XRLCreateUpdateSession();
                createReq.baseSession.dwTitleID = 0x3e7;
                XRLSessionInfo                createResp;
                // create a session with two attributes
                WireData [] Attribs = new WireData[2]{    new XRLIntAttribute(0x00000006,123),
                                                        new XRLStringAttribute(0x00100007,"abcd\0")};
                createReq.AddAttribs(Attribs);
                if(createReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out createResp))
                {
                    long    SessID = Constants.sessionIDConvert(createResp.SessionID);
                    // sp=10 search based on sessionID; return three attributes
                    XRLSearchSession    searchReq = new XRLSearchSession(10);
                    searchReq.baseSearchSession.dwTitleID = 0x3e7;
					XRLAttribParam[] Params = new XRLAttribParam[1]{new XRLAttribParam(Constants.X_ATTRIBUTE_DATATYPE_INTEGER,new XRLIntParam(SessID))};
					searchReq.AddParams(Params);
                    XRLSearchResults    Resp;
                    WireData [] expectedAttribs = new WireData[3]{    new XRLIntParam(),
                                                                     new XRLNullParam(),
                                                                     new XRLStringParam()
                                                                 };
                    if(searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),1,expectedAttribs,out Resp))
                    {
                        if(Resp!=null && (Resp.resultsLen == 1))
                        {    // check returned attribs
                            XRLIntParam        intTemp;
                            XRLStringParam    strTemp;
                            if(((intTemp =Resp.results[0].Attribs[0].aValue as XRLIntParam)!=null) &&
                                (Resp.results[0].Attribs[1].aValue as XRLNullParam!= null) &&
                                ((strTemp=Resp.results[0].Attribs[2].aValue as XRLStringParam) != null))
                            {
                                if((intTemp.intValue ==123)&&(string.Compare(strTemp.strValue,"abcd")==0))
                                    ResultCode=TEST_RESULTS.PASSED;
                            }
                        }
                    }
                    XRLDeleteSession    delReq = new XRLDeleteSession(createResp.SessionID);
                    delReq.dwTitleID = 0x3e7;
                    delReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                }
            }
        }
        [TestCase, Description("returned session has string/null/int attributes in that order")]
			class PReturnNullAttrib4 : TestBase
        {
            override protected void Execute()
            {
                XRLCreateUpdateSession        createReq = new XRLCreateUpdateSession();
                createReq.baseSession.dwTitleID = 0x3e7;
                XRLSessionInfo                createResp;
                // create a session with two attributes
                string strVal = "abcd\0";
                WireData [] Attribs = new WireData[2]{    new XRLIntAttribute(0x6,123),
                                                         new XRLStringAttribute(0x00100007,strVal)};
                createReq.AddAttribs(Attribs);
                if(createReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out createResp))
                {
                    long    SessID = Constants.sessionIDConvert(createResp.SessionID);
                    // sp=7 search based on sessionID; return three attributes
                    XRLSearchSession    searchReq = new XRLSearchSession(7);
                    searchReq.baseSearchSession.dwTitleID = 0x3e7;
					XRLAttribParam[] Params = new XRLAttribParam[1]{new XRLAttribParam(Constants.X_ATTRIBUTE_DATATYPE_INTEGER,new XRLIntParam(SessID))};
					searchReq.AddParams(Params);
                    XRLSearchResults    Resp;
                    WireData [] expectedAttribs = new WireData[3]{    new XRLStringParam(),
                                                                     new XRLNullParam(),
                                                                     new XRLIntParam()
                                                                 };
                    if(searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),1,expectedAttribs,out Resp))
                    {
                        if(Resp!=null && (Resp.resultsLen == 1))
                        {    // check returned attribs
                            XRLIntParam        intTemp;
                            XRLStringParam    strTemp;
                            if(((intTemp =Resp.results[0].Attribs[2].aValue as XRLIntParam)!=null) &&
                                (Resp.results[0].Attribs[1].aValue as XRLNullParam!= null) &&
                                ((strTemp=Resp.results[0].Attribs[0].aValue as XRLStringParam) != null))
                            {
                                if((intTemp.intValue ==123)&&(string.Compare(strTemp.strValue,strVal)==0))
                                    ResultCode=TEST_RESULTS.PASSED;
                            }
                        }
                    }
                    XRLDeleteSession    delReq = new XRLDeleteSession(createResp.SessionID);
                    delReq.dwTitleID = 0x3e7;
                    delReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                }
            }
        }
        [TestCase, Description("31583:returned session has blob/null/string attributes in that order")]
			class PReturnNullAttrib5 : TestBase
        {
            override protected void Execute()
            {
                XRLCreateUpdateSession        createReq = new XRLCreateUpdateSession();
                createReq.baseSession.dwTitleID = 0x3e7;
                XRLSessionInfo                createResp;
                // create a session with two attributes
                byte[] blobVal = new byte[10]{1,2,3,4,5,6,7,8,9,0xa};
                string    strVal = "fddfdfd\0";
                WireData [] Attribs = new WireData[2]{    new XRLBlobAttribute(0x200008,blobVal),
                                                         new XRLStringAttribute(0x100007,strVal)};
                createReq.AddAttribs(Attribs);
                if(createReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out createResp))
                {
                    long    SessID = Constants.sessionIDConvert(createResp.SessionID);
                    // sp=8 search based on sessionID; return three attributes
                    XRLSearchSession    searchReq = new XRLSearchSession(8);
                    searchReq.baseSearchSession.dwTitleID = 0x3e7;
					XRLAttribParam[] Params = new XRLAttribParam[1]{new XRLAttribParam(Constants.X_ATTRIBUTE_DATATYPE_INTEGER,new XRLIntParam(SessID))};
					searchReq.AddParams(Params);
                    XRLSearchResults    Resp;
                    WireData [] expectedAttribs = new WireData[3]{    new XRLBlobParam(),
                                                                     new XRLNullParam(),
                                                                     new XRLStringParam()
                                                                 };
                    if(searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),1,expectedAttribs,out Resp))
                    {
                        if(Resp!=null && (Resp.resultsLen == 1))
                        {    // check returned attribs
                            XRLBlobParam        blobTemp;
                            XRLStringParam    strTemp;
                            bool    sameValue = true;
                            if(((blobTemp =Resp.results[0].Attribs[0].aValue as XRLBlobParam)!=null) &&
                                (Resp.results[0].Attribs[1].aValue as XRLNullParam!= null) &&
                                ((strTemp=Resp.results[0].Attribs[2].aValue as XRLStringParam) != null))
                            {
                                if((blobTemp.blobLen==blobVal.Length)&&(string.Compare(strTemp.strValue,strVal)==0))
                                {
                                    for(int j = 0; j < blobTemp.blobLen; j++)
                                        if(blobTemp.blob[j] != blobVal[j])
                                            sameValue = false;
                                    if(sameValue)
                                        ResultCode=TEST_RESULTS.PASSED;
                                }
                            }
                        }
                    }
                    XRLDeleteSession    delReq = new XRLDeleteSession(createResp.SessionID);
                    delReq.dwTitleID = 0x3e7;
                    delReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                }
            }
        }
        [TestCase, Description("31583:returned session has string/null/blob attributes in that order")]
			class PReturnNullAttrib6 : TestBase
        {
            override protected void Execute()
            {
                XRLCreateUpdateSession        createReq = new XRLCreateUpdateSession();
                createReq.baseSession.dwTitleID = 0x3e7;
                XRLSessionInfo                createResp;
                // create a session with two attributes
                byte[] blobVal = new byte[10]{1,2,3,4,5,6,7,8,9,0xa};
                string    strVal = "abcdefg\0";
                WireData [] Attribs = new WireData[2]{    new XRLBlobAttribute(0x00200008,blobVal),
                                                         new XRLStringAttribute(0x00100007,strVal)};
                createReq.AddAttribs(Attribs);
                if(createReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out createResp))
                {
                    long    SessID = Constants.sessionIDConvert(createResp.SessionID);
                    // sp=6 search based on sessionID; return three attributes
                    XRLSearchSession    searchReq = new XRLSearchSession(6);
                    searchReq.baseSearchSession.dwTitleID = 0x3e7;
					XRLAttribParam[] Params = new XRLAttribParam[1]{new XRLAttribParam(Constants.X_ATTRIBUTE_DATATYPE_INTEGER,new XRLIntParam(SessID))};
					searchReq.AddParams(Params);
                    XRLSearchResults    Resp;
                    WireData [] expectedAttribs = new WireData[3]{    new XRLStringParam(),
                                                                     new XRLNullParam(),
                                                                     new XRLBlobParam()
                                                                 };
                    if(searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),1,expectedAttribs,out Resp))
                    {
                        if(Resp!=null && (Resp.resultsLen == 1))
                        {    // check returned attribs
                            XRLBlobParam        blobTemp;
                            XRLStringParam    strTemp;
                            bool    sameValue = true;
                            if(((strTemp =Resp.results[0].Attribs[0].aValue as XRLStringParam)!=null) &&
                                (Resp.results[0].Attribs[1].aValue as XRLNullParam!= null) &&
                                ((blobTemp=Resp.results[0].Attribs[2].aValue as XRLBlobParam) != null))
                            {
                                if((blobTemp.blobLen==blobVal.Length)&&(string.Compare(strTemp.strValue,strVal)==0))
                                {
                                    for(int j = 0; j < blobTemp.blobLen; j++)
                                        if(blobTemp.blob[j] != blobVal[j])
                                            sameValue = false;
                                    if(sameValue)
                                        ResultCode=TEST_RESULTS.PASSED;
                                }
                            }
                        }
                    }
                    XRLDeleteSession    delReq = new XRLDeleteSession(createResp.SessionID);
                    delReq.dwTitleID = 0x3e7;
                    delReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                }
            }
        }
        /*********************************************************************************
         * The followings are for Tsunami feature testing Wave 1
         * since Wave2 adds multiDB feature, these tests need to be modified
         * For Count/Sum: query will multiply result it gets by the number of dbs
         * for avg/min/max: they will be the results from one
         ********************************************************************************/
        // For PCountAgg1, PCountAgg2, PCountAgg3 tests, need to set sessionCache to 1ms to
        // make them work.
        [TestCase, Description("Count aggregate stored procedure:each group only has one member")]
			class PCountAgg1 : TestBase
        {
            override protected void Execute()
            {
                // create 24 sessions with different attribute's values
                // so that each db will have 12 sessions
                uint    numSessions, numDB = Constants.getNumDBForTitle(Constants.TITLE_ID);
				numSessions = numDB * 12;
                uint    attribID = 0x0000AAAA;
                XRLCreateUpdateSession    [] createReq = new XRLCreateUpdateSession[numSessions];
                XRLSessionInfo            [] createResp = new XRLSessionInfo[numSessions];
                for(int i = 0; i < numSessions; i++)
                {
                    createReq[i] = new XRLCreateUpdateSession();
                    WireData [] Attribs = new WireData[1]{new XRLIntAttribute(attribID,i)};
                    createReq[i].AddAttribs(Attribs);
                    if(!createReq[i].Execute(Global.XEnv.GetInterface(Interface.xmatchfd)[0],out createResp[i]))
                        return;
                }
                // sp=0x8000002c is a session summary query for count
                XRLSearchSession    searchReq = new XRLSearchSession(0x8000002c);
				searchReq.baseSearchSession.wFlags = Constants.XONLINE_MATCH_SEARCH_FLAG_NO_CACHE;
                XRLSearchResults    Resp;
                WireData [] expectedAttribs = new WireData[1]{new XRLIntParam()};
                if(searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),numSessions/numDB,expectedAttribs,out Resp))
                {        // check search results
                    if((Resp.resultsLen != numSessions/numDB))
                        Global.RO.Warn("nNumSearchResults is wrong:"+Resp.resultsLen);
                    // check count aggregrate value
                    else
                    {
                        bool    ret = true;
                        for(int j = 0; j < numSessions/numDB; j++)
                        {
                            XRLIntParam        intParam;
                            if(Resp.results[j].AttribOffsetsLen !=1)
                            {
                                Global.RO.Warn("number of attributes in the session is not 1");
                                ret = false;
                                break;
                            }
                            else if(((intParam = Resp.results[j].Attribs[0].aValue as XRLIntParam) == null)
                                || (intParam.intValue != (1*numDB)))
                            {
                                Global.RO.Warn("the "+ j + "th Returned count Aggregrate is either not int type or not 2");
                                ret = false;
                                break;
                            }
                        }
                        if(ret)
                            ResultCode=TEST_RESULTS.PASSED;
                    }
                }
                for(int i = 0; i < numSessions; i++)
                    new XRLDeleteSession(createResp[i].SessionID).Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
            }
        }
        [TestCase, Description("Count aggregate stored procedure:only 1 group")]
			class PCountAgg2 : TestBase
        {
            override protected void Execute()
            {
                // create 24 sessions with same attribute's values; 12 session on each db
				uint    numSessions, numDB = Constants.getNumDBForTitle(Constants.TITLE_ID);
				numSessions = numDB * 12;
				uint    attribID = 0x0000AAAA;
                XRLCreateUpdateSession    [] createReq = new XRLCreateUpdateSession[numSessions];
                XRLSessionInfo            [] createResp = new XRLSessionInfo[numSessions];
                for(int i = 0; i < numSessions; i++)
                {
                    createReq[i] = new XRLCreateUpdateSession();
                    WireData [] Attribs = new WireData[1]{new XRLIntAttribute(attribID,29)};
                    createReq[i].AddAttribs(Attribs);
                    if(!createReq[i].Execute(Global.XEnv.GetInterface(Interface.xmatchfd)[0],out createResp[i]))
                        return;
                }
                // sp=0x8000002c is a session summary query for count
                // since the 24 sessions has the same attribID value,
                // the search will return only one session with count=12
                XRLSearchSession    searchReq = new XRLSearchSession(0x8000002c);
				searchReq.baseSearchSession.wFlags = Constants.XONLINE_MATCH_SEARCH_FLAG_NO_CACHE;
                XRLSearchResults    Resp;
                WireData [] expectedAttribs = new WireData[1]{new XRLIntParam()};
                if(searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),1,expectedAttribs,out Resp))
                {        // check search results
                    if((Resp.resultsLen != 1))
                        Global.RO.Warn("nNumSearchResults is wrong:"+Resp.resultsLen);
                        // check count aggregrate value
                    else
                    {
                        bool    ret = true;
                        XRLIntParam        intParam;
                        if(Resp.results[0].AttribOffsetsLen !=1)
                        {
                            Global.RO.Warn("number of attributes in the session is not 1");
                            ret = false;
                        }
                        else if(((intParam = Resp.results[0].Attribs[0].aValue as XRLIntParam) == null)
                            || (intParam.intValue != (12*numDB)))
                        {
                            Global.RO.Warn("the Returned count Aggregrate is either not int type or not 24");
                            ret = false;
                        }
                        if(ret)
                            ResultCode=TEST_RESULTS.PASSED;
                    }
                }
                for(int i = 0; i < numSessions; i++)
                    new XRLDeleteSession(createResp[i].SessionID).Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
            }
        }
        [TestCase, Description("Count aggregate stored procedure:3 groups")]
			class PCountAgg3 : TestBase
        {
            override protected void Execute()
            {
                // each db has 12 sessions
				uint    numSessions, numDB = Constants.getNumDBForTitle(Constants.TITLE_ID);
				numSessions = numDB * 12;
				uint    attribID = 0x0000AAAA;
                XRLCreateUpdateSession    [] createReq = new XRLCreateUpdateSession[numSessions];
                XRLSessionInfo            [] createResp = new XRLSessionInfo[numSessions];
                for(int i = 0; i < numSessions; i++)
                {
                    createReq[i] = new XRLCreateUpdateSession();
                    long        intValue = 29;
                    if(i < (numDB*4))
                        intValue = 27;
                    else if (i < (numDB*8))
                        intValue = 28;
                    WireData [] Attribs = new WireData[1]{new XRLIntAttribute(attribID,intValue)};
                    createReq[i].AddAttribs(Attribs);
                    if(!createReq[i].Execute(Global.XEnv.GetInterface(Interface.xmatchfd)[0],out createResp[i]))
                        return;
                }
                // sp=0x2c is a session summary query for count
                // 3 sessions will be returned
                XRLSearchSession    searchReq = new XRLSearchSession(0x8000002c);
				searchReq.baseSearchSession.wFlags = Constants.XONLINE_MATCH_SEARCH_FLAG_NO_CACHE;
                XRLSearchResults    Resp;
                WireData [] expectedAttribs = new WireData[1]{new XRLIntParam()};
                if(searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),3,expectedAttribs,out Resp))
                {        // check search results: count is 8,8,8
                    if((Resp.resultsLen != 3))
                        Global.RO.Warn("nNumSearchResults is wrong:"+Resp.resultsLen);
                        // check count aggregrate value
                    else
                    {
                        bool    ret = true;
                        for(int j = 0; j < 3; j++)
                        {
                            XRLIntParam        intParam;
                            if(Resp.results[j].AttribOffsetsLen !=1)
                            {
                                Global.RO.Warn("number of attributes in the session is not 1");
                                ret = false;
                                break;
                            }
                            else if(((intParam = Resp.results[j].Attribs[0].aValue as XRLIntParam) == null)
                                || (intParam.intValue != 4*numDB))
                            {
                                Global.RO.Warn("the "+ j + "th Returned count Aggregrate is either not int type or not right value");
                                ret = false;
                                break;
                            }
                        }
                        if(ret)
                            ResultCode=TEST_RESULTS.PASSED;
                    }
                }
                for(int i = 0; i < numSessions; i++)
                    new XRLDeleteSession(createResp[i].SessionID).Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
            }
        }
        [TestCase, Description("Count aggregate stored procedure: no session returned")]
			class PCountAggNoSession : TestBase
        {
            override protected void Execute()
            {
                // sp=0x2c is a session summary query for count
                XRLSearchSession    searchReq = new XRLSearchSession(0x8000002c);
                XRLSearchResults    Resp;
                WireData [] expectedAttribs = new WireData[1]{new XRLIntParam()};
                if(searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),0,expectedAttribs,out Resp))
                    // check search results: no session returned
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("Average aggregate stored procedure")]
			class PAvgAgg : TestBase
        {
            override protected void Execute()
            {
                // each DB has 10 sessions; 6/6/8 sessions has same 0xAAAA value;
                // but each session has different 0x00001234 value
				uint    numSessions, numDB = Constants.getNumDBForTitle(Constants.TITLE_ID);
				numSessions = numDB * 10;
                uint    groupByAttribID = 0x0000AAAA;    // group by 0xAAAA
                uint    avgAttribID = 0x00001234;
                XRLCreateUpdateSession    [] createReq = new XRLCreateUpdateSession[numSessions];
                XRLSessionInfo            [] createResp = new XRLSessionInfo[numSessions];
                for(int i = 0; i < numSessions; i++)
                {
                    createReq[i] = new XRLCreateUpdateSession();
                    long        intValue = 8, avgIntValue = 3;
					if(i < (numDB*3))
					{
						intValue = 9;
						avgIntValue = 1;
					}
					else if (i < (numDB*6))
					{
						intValue = 6;
						avgIntValue = 2;
					}
                    WireData [] Attribs = new WireData[2]{    new XRLIntAttribute(groupByAttribID,intValue),
                                                            new XRLIntAttribute(avgAttribID,avgIntValue)};
                    createReq[i].AddAttribs(Attribs);
                    if(!createReq[i].Execute(Global.XEnv.GetInterface(Interface.xmatchfd)[0],out createResp[i]))
                        return;
                }
                // sp=0x2d is a session summary query for Average
                // 3 groups will be returned
                XRLSearchSession    searchReq = new XRLSearchSession(0x8000002d);
                XRLSearchResults    Resp;
                WireData [] expectedAttribs = new WireData[1]{new XRLIntParam()};
                if(searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),3,expectedAttribs,out Resp))
                {
                    bool    ret = true;
                    for(int j = 0; j < 3; j++)
                    {
                        XRLIntParam        intParam;
                        if(Resp.results[j].AttribOffsetsLen !=1)
                        {
                            Global.RO.Warn("number of attributes in the session is not 1");
                            ret = false;
                            break;
                        }
                        else if((intParam = Resp.results[j].Attribs[0].aValue as XRLIntParam) == null)
                        {
                            Global.RO.Warn("the "+ j + "th Returned avg Aggregrate is either not int type");
                            ret = false;
                            break;
                        }
                        else if((intParam.intValue!=1)&&(intParam.intValue!=2)&&(intParam.intValue!=3))
                        {
                            Global.RO.Warn("the "+ j + "th Returned avg Aggregrate is not the right value");
                            ret = false;
                            break;
                        }
                    }
                    if(ret)
                        ResultCode=TEST_RESULTS.PASSED;
                }
                for(int i = 0; i < numSessions; i++)
                    new XRLDeleteSession(createResp[i].SessionID).Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
            }
        }
        [TestCase, Description("Average aggregate stored procedure: no session returned")]
			class PAvgAggNoSession : TestBase
        {
            override protected void Execute()
            {
                // sp=0x2d is a session summary query for Average
                XRLSearchSession    searchReq = new XRLSearchSession(0x8000002d);
                XRLSearchResults    Resp;
                WireData [] expectedAttribs = new WireData[1]{new XRLIntParam()};
                if(searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),0,expectedAttribs,out Resp))
                        // check search results: no session returned
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("Minimum aggregate stored procedure:")]
			class PMinAgg : TestBase
        {
            override protected void Execute()
            {
                // create 10 sessions per db; 6/6/8 sessions has same 0xAAAA value;
                // 3 session has same 0x1234 value, 3 session has different 0x1234 value, 4 session has different 0x1234 value
				uint    numSessions, numDB = Constants.getNumDBForTitle(Constants.TITLE_ID);
				numSessions = numDB * 10;
				uint    groupByAttribID = 0x0000AAAA;    // group by 0xAAAA
                uint    minAttribID = 0x00001234;
                XRLCreateUpdateSession    [] createReq = new XRLCreateUpdateSession[numSessions];
                XRLSessionInfo            [] createResp = new XRLSessionInfo[numSessions];
                for(int i = 0; i < numSessions; i++)
                {
                    createReq[i] = new XRLCreateUpdateSession();
                    long        groupByintValue = 8, aggIntValue = i;
                    if(i < (numDB*3))
                    {
                        groupByintValue = 9;
                        aggIntValue = 0;
                    }
                    else if (i < (numDB*6))
                        groupByintValue = 6;
                    WireData [] Attribs = new WireData[2]{    new XRLIntAttribute(groupByAttribID,groupByintValue),
                                                             new XRLIntAttribute(minAttribID,aggIntValue)};
                    createReq[i].AddAttribs(Attribs);
                    if(!createReq[i].Execute(Global.XEnv.GetInterface(Interface.xmatchfd)[0],out createResp[i]))
                        return;
                }
                // sp=0x2e is a session summary query for Average
                // 3 groups will be returned
                XRLSearchSession    searchReq = new XRLSearchSession(0x8000002e);
                XRLSearchResults    Resp;
                WireData [] expectedAttribs = new WireData[1]{new XRLIntParam()};
                if(searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),3,expectedAttribs,out Resp))
                {    // check search results: 3 sessions has min=0,3 sessions has min=6,4 sessions has min=12
                    // another db: 1,7,13
                    bool    ret = true;
                    for(int j = 0; j < 3; j++)
                    {
                        XRLIntParam        intParam;
                        if(Resp.results[j].AttribOffsetsLen !=1)
                        {
                            Global.RO.Warn("number of attributes in the session is not 1");
                            ret = false;
                            break;
                        }
                        else if(((intParam = Resp.results[j].Attribs[0].aValue as XRLIntParam) == null)||
                             (((intParam.intValue!=0)&&(intParam.intValue!=(numDB*3))&&(intParam.intValue!=(numDB*6)))&&
							((intParam.intValue!=1)&&(intParam.intValue!=(numDB*3+1))&&(intParam.intValue!=(numDB*6+1)))))
                        {
                            Global.RO.Warn("the "+ j + "th Returned avg Aggregrate is either not int type or not the right value");
                            ret = false;
                            break;
                        }
                    }
                    if(ret)
                        ResultCode=TEST_RESULTS.PASSED;
                }
                for(int i = 0; i < numSessions; i++)
                    new XRLDeleteSession(createResp[i].SessionID).Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
            }
        }
        [TestCase, Description("Minimum aggregate stored procedure: no session returned")]
			class PMinAggNoSession : TestBase
        {
            override protected void Execute()
            {
                // sp=0x2e is a session summary query for Average
                XRLSearchSession    searchReq = new XRLSearchSession(0x8000002e);
                XRLSearchResults    Resp;
                WireData [] expectedAttribs = new WireData[1]{new XRLIntParam()};
                if(searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),0,expectedAttribs,out Resp))
                    // check search results: no session returned
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("Maximum aggregate stored procedure")]
			class PMaxAgg : TestBase
        {
            override protected void Execute()
            {
                // create 10 sessions perdb; 6/6/8 sessions has same 0xAAAA value;
                // 3 session has same 0x1234 value, 3 session has different 0x1234 value, 4 session has different 0x1234 value
				uint    numSessions, numDB = Constants.getNumDBForTitle(Constants.TITLE_ID);
				numSessions = numDB * 10;
				uint    groupByAttribID = 0x0000AAAA;    // group by 0xAAAA
                uint    maxAttribID = 0x00001234;
                XRLCreateUpdateSession    [] createReq = new XRLCreateUpdateSession[numSessions];
                XRLSessionInfo            [] createResp = new XRLSessionInfo[numSessions];
                for(int i = 0; i < numSessions; i++)
                {
                    createReq[i] = new XRLCreateUpdateSession();
                    long        groupByintValue = 8, aggIntValue = 40;
					if(i < (numDB*3))
					{
						groupByintValue = 9;
						aggIntValue = 1;
					}
					else if (i < (numDB*6))
					{
						groupByintValue = 6;
						aggIntValue = 30;
					}
                    WireData [] Attribs = new WireData[2]{    new XRLIntAttribute(groupByAttribID,groupByintValue),
                                                             new XRLIntAttribute(maxAttribID,aggIntValue)};
                    createReq[i].AddAttribs(Attribs);
                    if(!createReq[i].Execute(Global.XEnv.GetInterface(Interface.xmatchfd)[0],out createResp[i]))
                        return;
                }
                // sp=0x2f is a session summary query for max
                // 3 groups will be returned
                XRLSearchSession    searchReq = new XRLSearchSession(0x8000002f);
                XRLSearchResults    Resp;
                WireData [] expectedAttribs = new WireData[1]{new XRLIntParam()};
                if(searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),3,expectedAttribs,out Resp))
                {
                    bool    ret = true;
                    for(int j = 0; j < 3; j++)
                    {
                        XRLIntParam        intParam;
                        if(Resp.results[j].AttribOffsetsLen !=1)
                        {
                            Global.RO.Warn("number of attributes in the session is not 1");
                            ret = false;
                            break;
                        }
                        else if(((intParam = Resp.results[j].Attribs[0].aValue as XRLIntParam) == null)||
                            ((intParam.intValue!=1)&&(intParam.intValue!=30)&&(intParam.intValue!=40)))
                        {
                            Global.RO.Warn("the "+ j + "th Returned avg Aggregrate is either not int type or not the right value");
                            ret = false;
                            break;
                        }
                    }
                    if(ret)
                        ResultCode=TEST_RESULTS.PASSED;
                }
                for(int i = 0; i < numSessions; i++)
                    new XRLDeleteSession(createResp[i].SessionID).Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
            }
        }
        [TestCase, Description("Maximum aggregate stored procedure: no session returned")]
			class PMaxAggNoSession : TestBase
        {
            override protected void Execute()
            {
                // sp=0x2f is a session summary query for Average
                XRLSearchSession    searchReq = new XRLSearchSession(0x8000002f);
                XRLSearchResults    Resp;
                WireData [] expectedAttribs = new WireData[1]{new XRLIntParam()};
                if(searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),0,expectedAttribs,out Resp))
                    // check search results: no session returned
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("Total aggregate stored procedure")]
			class PSumAgg : TestBase
        {
            override protected void Execute()
            {
                // create 20 sessions; 6/6/8 sessions has same 0xAAAA value;
                // each session has different 0x1234 values
				uint    numSessions, numDB = Constants.getNumDBForTitle(Constants.TITLE_ID);
				numSessions = numDB * 10;
				uint    groupByAttribID = 0x0000AAAA;    // group by 0xAAAA
                uint    sumAttribID = 0x00001234;
                XRLCreateUpdateSession    [] createReq = new XRLCreateUpdateSession[numSessions];
                XRLSessionInfo            [] createResp = new XRLSessionInfo[numSessions];
                for(int i = 0; i < numSessions; i++)
                {
                    createReq[i] = new XRLCreateUpdateSession();
                    long        groupByintValue = 8, sumIntValue = 3;
					if(i < (numDB*3))
					{
						sumIntValue = 1;
						groupByintValue = 9;
					}
					else if (i < (numDB*6))
					{
						sumIntValue = 2;
						groupByintValue = 6;
					}
                    WireData [] Attribs = new WireData[2]{    new XRLIntAttribute(groupByAttribID,groupByintValue),
                                                             new XRLIntAttribute(sumAttribID,sumIntValue)};
                    createReq[i].AddAttribs(Attribs);
                    if(!createReq[i].Execute(Global.XEnv.GetInterface(Interface.xmatchfd)[0],out createResp[i]))
                        return;
                }
                // sp=0x30 is a session summary query for Sum
                // 3 groups will be returned
                XRLSearchSession    searchReq = new XRLSearchSession(0x80000030);
				searchReq.baseSearchSession.wFlags = Constants.XONLINE_MATCH_SEARCH_FLAG_NO_CACHE;
                XRLSearchResults    Resp;
                WireData [] expectedAttribs = new WireData[1]{new XRLIntParam()};
                if(searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),3,expectedAttribs,out Resp))
                {
                    bool    ret = true;
                    for(int j = 0; j < 3; j++)
                    {
                        XRLIntParam        intParam;
                        if(Resp.results[j].AttribOffsetsLen !=1)
                        {
                            Global.RO.Warn("number of attributes in the session is not 1");
                            ret = false;
                            break;
                        }
                        else if(((intParam = Resp.results[j].Attribs[0].aValue as XRLIntParam) == null)||
                             ((intParam.intValue!=(3*numDB))&&(intParam.intValue!=(6*numDB))&&(intParam.intValue!=(numDB*12))))
                        {
                            Global.RO.Warn("the "+ j + "th Returned avg Aggregrate is either not int type or not the right value");
                            ret = false;
                            break;
                        }
                    }
                    if(ret)
                        ResultCode=TEST_RESULTS.PASSED;
                }
                for(int i = 0; i < numSessions; i++)
                    new XRLDeleteSession(createResp[i].SessionID).Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
            }
        }
        [TestCase, Description("Sum aggregate stored procedure: no session returned")]
			class PSumAggNoSession : TestBase
        {
            override protected void Execute()
            {
                // sp=0x30 is a session summary query for Sum
                XRLSearchSession    searchReq = new XRLSearchSession(0x80000030);
                XRLSearchResults    Resp;
                WireData [] expectedAttribs = new WireData[1]{new XRLIntParam()};
                if(searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),0,expectedAttribs,out Resp))
                    // check search results: no session returned
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("(one group returned)Total aggregate sp: use parameters,filters,sort operators")]
			class PExtendedAgg : TestBase
        {
            override protected void Execute()
            {
                // create 20 sessions; 6/6/8 sessions has same 0xAAAA value;
                // each session has different 0x1234 values
				uint    numSessions, numDB = Constants.getNumDBForTitle(Constants.TITLE_ID);
				numSessions = numDB * 10;
				uint    groupByAttribID = 0x0000AAAA;    // group by 0xAAAA
                uint    sumAttribID = 0x00001234;
                XRLCreateUpdateSession    [] createReq = new XRLCreateUpdateSession[numSessions];
                XRLSessionInfo            [] createResp = new XRLSessionInfo[numSessions];
                long        groupByintValue = 0, sumAttribValue = 0;
                for(int i = 0; i < numSessions; i++)
                {
                    createReq[i] = new XRLCreateUpdateSession();
                    if(i < (numDB*3))
                    {
                        groupByintValue = 9;
                        sumAttribValue = 20;
                    }
                    else if (i < (numDB*6))
                    {
                        groupByintValue = 6;
                        sumAttribValue = 30;
                    }
                    else
                    {
                        groupByintValue = 8;
                        sumAttribValue = 40;
                    }
                    WireData [] Attribs = new WireData[2]{    new XRLIntAttribute(groupByAttribID,groupByintValue),
                                                             new XRLIntAttribute(sumAttribID,sumAttribValue)};
                    createReq[i].AddAttribs(Attribs);
                    if(!createReq[i].Execute(Global.XEnv.GetInterface(Interface.xmatchfd)[0],out createResp[i]))
                        return;
                }
                // sp=0x31 is a session summary query for Sum
                XRLSearchSession    searchReq = new XRLSearchSession(0x80000031);
                // 4 sessions meets the search criterior; 1 group will be returned
                XRLAttribParam[] Params = new XRLAttribParam[1]{new XRLAttribParam(Constants.X_ATTRIBUTE_DATATYPE_INTEGER,new XRLIntParam(8))};
                searchReq.AddParams(Params);

                XRLSearchResults    Resp;
                WireData [] expectedAttribs = new WireData[2]{new XRLIntParam(), new XRLIntParam()};
                if(searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),1,expectedAttribs,out Resp))
                {
                    bool    ret = true;
                    XRLIntParam        intParam1, intParam2;
                    if(Resp.results[0].AttribOffsetsLen !=2)
                    {
                        Global.RO.Warn("number of attributes in the session is not 2");
                        ret = false;
                    }
                    else if(((intParam1 = Resp.results[0].Attribs[0].aValue as XRLIntParam) == null)
                        || ((intParam2 = Resp.results[0].Attribs[1].aValue as XRLIntParam) == null))
                    {
                        Global.RO.Warn("The Returned sum Aggregrate is not Int");
                        ret = false;
                    }
                    else if((((intParam1.intValue !=8)||(intParam2.intValue != (160*numDB))) &&
                            ((intParam1.intValue !=(160*numDB))||(intParam2.intValue != 8))))
                    {
                        Global.RO.Warn("The Returned sum Aggregrate or groupBy attrib Value is not Int");
                        ret = false;
                    }
                    if(ret)
                        ResultCode=TEST_RESULTS.PASSED;
                }
                for(int i = 0; i < numSessions; i++)
                    new XRLDeleteSession(createResp[i].SessionID).Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
            }
        }
        [TestCase, Description("(Two groups returned)Count aggregate sp: use parameters,filters,sort operators")]
			class PExtendedAgg2 : TestBase
        {
            override protected void Execute()
            {
                // create 20 sessions; 6/6/8 sessions has same 0xAAAA value;
                // each session has different 0x1234 values
				uint    numSessions, numDB = Constants.getNumDBForTitle(Constants.TITLE_ID);
				numSessions = numDB * 10;
				uint    groupByAttribID = 0x0000AAAA;    // group by 0xAAAA
                uint    sumAttribID = 0x00001234;
                XRLCreateUpdateSession    [] createReq = new XRLCreateUpdateSession[numSessions];
                XRLSessionInfo            [] createResp = new XRLSessionInfo[numSessions];
                long        groupByintValue = 0, sumAttribValue = 0;
                for(int i = 0; i < numSessions; i++)
                {
                    createReq[i] = new XRLCreateUpdateSession();
                    if(i < (numDB*3))
                    {
                        groupByintValue = 9;
                        sumAttribValue = 20;
                    }
                    else if (i < (numDB*6))
                    {
                        groupByintValue = 6;
                        sumAttribValue = 30;
                    }
                    else
                    {
                        groupByintValue = 8;
                        sumAttribValue = i;
                    }
                    WireData [] Attribs = new WireData[2]{    new XRLIntAttribute(groupByAttribID,groupByintValue),
                                                             new XRLIntAttribute(sumAttribID,sumAttribValue)};
                    createReq[i].AddAttribs(Attribs);
                    if(!createReq[i].Execute(Global.XEnv.GetInterface(Interface.xmatchfd)[0],out createResp[i]))
                        return;
                }
                // sp=0x32 is a session summary query for count
                XRLSearchSession    searchReq = new XRLSearchSession(0x80000032);
                // 4 sessions meets the search criterior; 2 groups will be returned
				XRLAttribParam[] Params = new XRLAttribParam[1]{new XRLAttribParam(Constants.X_ATTRIBUTE_DATATYPE_INTEGER,new XRLIntParam(8))};
				searchReq.AddParams(Params);

                XRLSearchResults    Resp;
                WireData [] expectedAttribs = new WireData[2]{new XRLIntParam(), new XRLIntParam()};
                if(searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),2,expectedAttribs,out Resp))
                {    // check search results: 2 groups will be returned
                    // 1. 0xaaaa = 8 and Count(0x1234)=4
                    // 2. 0xaaaa = 9 and Count(0x1234)=3
                    bool    ret = true;
                    for(int i = 0; i < 2; i++)
                    {
                        XRLIntParam        intParam1, intParam2;
                        if(Resp.results[i].AttribOffsetsLen !=2)
                        {
                            Global.RO.Warn("number of attributes in the session is not 2");
                            ret = false;
                            break;
                        }
                        else if(((intParam1 = Resp.results[i].Attribs[0].aValue as XRLIntParam) == null)
                            || ((intParam2 = Resp.results[i].Attribs[1].aValue as XRLIntParam) == null))
                        {
                            Global.RO.Warn("The Returned Count Aggregrate or Attribute is not Int");
                            ret = false;
                            break;
                        }
                        else if(((intParam1.intValue !=8)||(intParam2.intValue != (numDB*4))) &&
                            ((intParam1.intValue !=9)||(intParam2.intValue != (numDB*3))))
                        {
                            Global.RO.Warn("The Returned count Aggregrate or groupBy attrib Value is not Int");
                            ret = false;
                            break;
                        }
                    }
                    if(ret)
                        ResultCode=TEST_RESULTS.PASSED;
                }
                for(int i = 0; i < numSessions; i++)
                    new XRLDeleteSession(createResp[i].SessionID).Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
            }
        }
        // fuzzy match1: create 10 sessions with the same 0xaaaa attribute value
        // pass a center parameter with the same value
        // check 6 sessions are returned and distanceAttribute for each session is 0
        [TestCase, Description("Fuzzy matching with all sessions has the same value as the centerValue")]
			class PfuzzyMatch1 : TestBase
        {
            override protected void Execute()
            {
                uint    numSessions = 10;
                uint    fuzzyAttribID = 0x00000001;
                long    centerValue = 8989;
                XRLCreateUpdateSession    [] createReq = new XRLCreateUpdateSession[numSessions];
                XRLSessionInfo            [] createResp = new XRLSessionInfo[numSessions];
                for(int i = 0; i < numSessions; i++)
                {
                    createReq[i] = new XRLCreateUpdateSession();
                    createReq[i].baseSession.dwTitleID = 0x2382; // 9090

                    WireData [] Attribs = new WireData[1]{    new XRLIntAttribute(fuzzyAttribID,centerValue)};
                    createReq[i].AddAttribs(Attribs);
                    if(!createReq[i].Execute(Global.XEnv.GetInterface(Interface.xmatchfd)[0],out createResp[i]))
                        return;
                }
                XRLSearchSession    searchReq = new XRLSearchSession(6);
                searchReq.baseSearchSession.dwTitleID = 9090;
                // maximum returned session is 6
				XRLAttribParam[] Params = new XRLAttribParam[1]{new XRLAttribParam(Constants.X_ATTRIBUTE_DATATYPE_INTEGER,new XRLIntParam(centerValue))};
				searchReq.AddParams(Params);

                XRLSearchResults    Resp;
                WireData [] expectedAttribs = new WireData[1]{new XRLIntParam()};
                if(searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),6,expectedAttribs,out Resp))
                {    bool    ret = true;
                    if(Resp.resultsLen != 6)
                    {
                        Global.RO.Warn("Number of sessions returned is not 6");
                        ret = false;
                    }
                    else
                    {
                        for(int i = 0; i < 6; i++)
                        {
                         XRLIntParam        intParam;
                         if(Resp.results[i].AttribOffsetsLen !=1)
                         {
                             Global.RO.Warn("number of attributes in the session is not 1");
                             ret = false;
                             break;
                         }
                         else if((intParam = Resp.results[i].Attribs[0].aValue as XRLIntParam) == null)
                         {
                             Global.RO.Warn("The Returned attribute is not Int");
                             ret = false;
                             break;
                         }
                         else if(intParam.intValue !=centerValue)
                         {
                             Global.RO.Warn("The Returned attribute value is not right");
                             ret = false;
                             break;
                         }
                     }
                    }
                    if(ret)
                        ResultCode=TEST_RESULTS.PASSED;
                }
                for(int i = 0; i < numSessions; i++)
                {
                    XRLDeleteSession    delReq = new XRLDeleteSession(createResp[i].SessionID);
                    delReq.dwTitleID = 9090;
                    delReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                }
            }
        }
        // fuzzy match2: create 10 sessions with the different 0xaaaa attribute value(0-9)
        // pass a parameter with a center value (5)
        // check 6 sessions are returned and distanceAttribute for each session is different
        [TestCase, Description("Fuzzy matching with all sessions has the different value than the centerValue")]
			class PfuzzyMatch2 : TestBase
        {
            override protected void Execute()
            {
                uint    numSessions = 10;
                uint    fuzzyAttribID = 0x00000001;
                uint    smallIntAttribID = 0x00000004;
                long    centerValue = 5;
                XRLCreateUpdateSession    [] createReq = new XRLCreateUpdateSession[numSessions];
                XRLSessionInfo            [] createResp = new XRLSessionInfo[numSessions];
                for(int i = 0; i < numSessions; i++)
                {
                    createReq[i] = new XRLCreateUpdateSession();
                    createReq[i].baseSession.dwTitleID = 0x2382; // 9090

                    WireData [] Attribs = new WireData[2]{    new XRLIntAttribute(fuzzyAttribID,i),
                                                            new XRLIntAttribute(smallIntAttribID,i)};
                    createReq[i].AddAttribs(Attribs);
                    if(!createReq[i].Execute(Global.XEnv.GetInterface(Interface.xmatchfd)[0],out createResp[i]))
                        return;
                }
                XRLSearchSession    searchReq = new XRLSearchSession(7);
                searchReq.baseSearchSession.dwTitleID = 9090;
                // maximum returned session is 6
				XRLAttribParam[] Params = new XRLAttribParam[1]{new XRLAttribParam(Constants.X_ATTRIBUTE_DATATYPE_INTEGER,new XRLIntParam(centerValue))};
				searchReq.AddParams(Params);

                XRLSearchResults    Resp;
                WireData [] expectedAttribs = new WireData[2]{new XRLIntParam(),new XRLIntParam()};
                if(searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),6,expectedAttribs,out Resp))
                {
                    bool    ret = true;
                    if(Resp.resultsLen != 6)
                    {
                        Global.RO.Warn("Number of sessions returned is not 6");
                        ret = false;
                    }
                    else
                    {
                        for(int i = 0; i < 6; i++)
                        {
                            XRLIntParam        intParam1, intParam2;
                            if(Resp.results[i].AttribOffsetsLen !=2)
                            {
                                Global.RO.Warn("number of attributes in the session is not 2");
                                ret = false;
                                break;
                            }
                            else if(((intParam1 = Resp.results[i].Attribs[0].aValue as XRLIntParam) == null)||
                                (intParam2 = Resp.results[i].Attribs[1].aValue as XRLIntParam) == null)
                            {
                                Global.RO.Warn("The Returned two addtional attributes is not Int");
                                ret = false;
                                break;
                            }
                            else // check the distance Attribute value
                            {    //1st session either twoattributesValue=2 or 8
                                // 2nd session either two attributesValue=3 or 7, next is 4 or 6
                                // last is 5
                                switch(i)
                                {
                                    case 0:
                                        if(intParam1.intValue != 0)
                                        {
                                            ret = false;
                                            goto exit;
                                        }
                                        else break;
                                    case 1:
                                    case 2:
                                        if((intParam1.intValue != 1) && (intParam1.intValue != 9))
                                        {
                                            ret = false;
                                            goto exit;
                                        }
                                        else break;
                                    case 3:
                                    case 4:
                                        if((intParam1.intValue != 2) && (intParam1.intValue != 8))
                                        {
                                            ret = false;
                                            goto exit;
                                        }
                                        else break;
                                    case 5:
                                        if((intParam1.intValue !=3) &&(intParam1.intValue != 7))
                                        {
                                            ret = false;
                                            goto exit;
                                        }
                                        else break;
                                }
                            }
                        }
                    }
                exit:
                    if(ret)
                        ResultCode=TEST_RESULTS.PASSED;
                }
                for(int i = 0; i < numSessions; i++)
                {
                    XRLDeleteSession    delReq = new XRLDeleteSession(createResp[i].SessionID);
                    delReq.dwTitleID = 9090;
                    delReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                }
            }
        }
        /*********************************************************************************
         * The followings are for Tsunami feature testing Wave 2
         ********************************************************************************/
        [TestCase, Description("do a same query twice in a row against one fd and check results are different")]
			class PTitleCrossMultiDB1 : TestBase
        {
            override protected void Execute()
            {
                // one session per db
                // do a same query twice in a row and check the results are different
				uint    numSessions, numDB = Constants.getNumDBForTitle(Constants.TITLE_ID);
				numSessions = numDB;
				XRLCreateUpdateSession    [] createReq = new XRLCreateUpdateSession[numSessions];
                XRLSessionInfo            [] createResp = new XRLSessionInfo[numSessions];
                for(int i = 0; i < numSessions; i++)
                {
                    createReq[i] = new XRLCreateUpdateSession();
                    if(!createReq[i].Execute(Global.XEnv.GetInterface(Interface.xmatchfd)[0],out createResp[i]))
                        return;
                }
                // sp=0 returned all sessions for an existing title
                XRLSearchSession    searchReq1 = new XRLSearchSession(0), searchReq2=new XRLSearchSession(0);
				searchReq1.baseSearchSession.wFlags = Constants.XONLINE_MATCH_SEARCH_FLAG_NO_CACHE;
				searchReq2.baseSearchSession.wFlags = Constants.XONLINE_MATCH_SEARCH_FLAG_NO_CACHE;
                XRLSearchResults    Resp1, Resp2;
                if(    searchReq1.Execute(Global.XEnv.GetInterface(Interface.xmatchfd)[0], out Resp1) &&
                    searchReq2.Execute(Global.XEnv.GetInterface(Interface.xmatchfd)[0], out Resp2))
                {
                    // check the results are different
                    if((Resp1.resultsLen == Resp2.resultsLen) && (Resp1.resultsLen == 1))
                    {
                        for(int i = 0; i < 8; i++)
                            if(Resp1.results[0].SessionID[i] != Resp2.results[0].SessionID[i])
                            {
                                ResultCode=TEST_RESULTS.PASSED;
                                break;
                            }
                    }
                }
                for(int i = 0; i < numSessions; i++)
                    new XRLDeleteSession(createResp[i].SessionID).Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
            }
        }
        // 33297: PInvalidDB1, DB2, DB3- won't fix
		// create a dumb Title ID in the dbs: 7897
       // [TestCase, Description("1st IP in Title 7897's db list is invalid, 2nd is valid")]
			class PInvalidDB1 : TestBase
        {
            override protected void Execute()
            {    // create two sessions for the title and they should be created successfully
                // check there should be a warning/error event log for 1st request
                uint    numSessions = 2;
                XRLCreateUpdateSession    [] createReq = new XRLCreateUpdateSession[numSessions];
                XRLSessionInfo            [] createResp = new XRLSessionInfo[numSessions];
                for(int i = 0; i < numSessions; i++)
                {
                    createReq[i] = new XRLCreateUpdateSession();
                    createReq[i].baseSession.dwTitleID = 7897;
                    if(!createReq[i].Execute(Global.XEnv.GetInterface(Interface.xmatchfd)[0],out createResp[i]))
                        return;
                }
                ResultCode=TEST_RESULTS.PASSED;
                for(int i = 0; i < numSessions; i++)
                {
                    XRLDeleteSession delReq = new XRLDeleteSession(createResp[i].SessionID);
                    delReq.dwTitleID = 7897;
                    delReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                }
            }
        }
        // create a dumb Title ID in the dbs: 78978
       // [TestCase, Description("1st IP in Title 78978's db list is valid, 2nd is invalid")]
			class PInvalidDB2 : TestBase
        {
            override protected void Execute()
            {    // create two sessions for the title and they should be created successfully
                // check there should be a warning/error event log for 2nd request
                uint    numSessions = 2;
                XRLCreateUpdateSession    [] createReq = new XRLCreateUpdateSession[numSessions];
                XRLSessionInfo            [] createResp = new XRLSessionInfo[numSessions];
                for(int i = 0; i < numSessions; i++)
                {
                    createReq[i] = new XRLCreateUpdateSession();
                    createReq[i].baseSession.dwTitleID = 78978;
                    if(!createReq[i].Execute(Global.XEnv.GetInterface(Interface.xmatchfd)[0],out createResp[i]))
                        return;
                }
                for(int i = 0; i < numSessions; i++)
                {
                    XRLDeleteSession delReq = new XRLDeleteSession(createResp[i].SessionID);
                    delReq.dwTitleID = 78978;
                    delReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                }
            }
        }
        // create a dumb Title ID in the dbs: 789789
      //  [TestCase, Description("3rd IP in Title 789789's db list is invalid")]
			class PInvalidDB3 : TestBase
        {
            override protected void Execute()
            {    // create three sessions for the title and they should be created successfully
                // check there should be a warning/error event log for 3rd request
                uint    numSessions = 3;
                XRLCreateUpdateSession    [] createReq = new XRLCreateUpdateSession[numSessions];
                XRLSessionInfo            [] createResp = new XRLSessionInfo[numSessions];
                for(int i = 0; i < numSessions; i++)
                {
                    createReq[i] = new XRLCreateUpdateSession();
                    createReq[i].baseSession.dwTitleID = 789789;
                    if(!createReq[i].Execute(Global.XEnv.GetInterface(Interface.xmatchfd)[0],out createResp[i]))
                        return;
                }
                ResultCode=TEST_RESULTS.PASSED;
                for(int i = 0; i < numSessions; i++)
                {
                    XRLDeleteSession delReq = new XRLDeleteSession(createResp[i].SessionID);
                    delReq.dwTitleID = 789789;
                    delReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                }
            }
        }
        [TestCase, Description("Bug 35145:host session and client are both strictNAT, but having same inaOnline")]
			class PSameRouterNAT : TestBase
        {
            override protected void Execute()
            {
				uint    numDB = Constants.getNumDBForTitle(Constants.TITLE_ID);
				uint numSessions = numDB;
				XRLCreateUpdateSession [] createReq = new XRLCreateUpdateSession[numSessions];
				XRLSessionInfo			[] createResp = new XRLSessionInfo[numSessions];
				// create numSessions so we can gurantee there are one on each db
				for(int i = 0; i < numSessions; i++)
				{
					createReq[i] = new XRLCreateUpdateSession();
					createResp[i] = new XRLSessionInfo();
					createReq[i].baseSession.HostAddress.inaOnline = new byte[4]{0x01,0x02,0x03,0x04};
	                createReq[i].baseSession.SessionID = new byte[8]{0x30,0,0,0,0,0,0,0};
					if(!createReq[i].Execute(Global.XEnv.GetInterface(Interface.xmatchfd)[0],out createResp[i]))
						return;
				}

                XRLSearchSession    searchReq = new XRLSearchSession(0);
                searchReq.baseSearchSession.ClientAddress.inaOnline = new byte[4]{0x01,0x02,0x03,0x04};
                searchReq.baseSearchSession.wFlags = 3;
                XRLSearchResults    searchResp;
                if(searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out searchResp))
                {
                    if(searchResp != null)
                        ResultCode=TEST_RESULTS.PASSED;
                }
                XRLDeleteSession [] delReq = new XRLDeleteSession[numSessions];
				for(int i = 0; i < numSessions; i++)
				{
					delReq[i] = new XRLDeleteSession(createResp[i].SessionID);
					delReq[i].Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
				}
            }
        }
        [TestCase, Description("host session is strictNAT, client is strict and send FindFromID query")]
			class PFindFromIDNAT : TestBase
        {
            override protected void Execute()
            {
                XRLCreateUpdateSession    createReq = new XRLCreateUpdateSession();
                XRLSessionInfo            createResp = new XRLSessionInfo();
                createReq.baseSession.dwTitleID = 0x3e7;
                createReq.baseSession.SessionID = new byte[8]{0x30,0,0,0,0,0,0,0};
                if(!createReq.Execute(Global.XEnv.GetInterface(Interface.xmatchfd)[0],out createResp))
                        return;
                long    lSessID = Constants.sessionIDConvert(createResp.SessionID);
                XRLSearchSession    searchReq = new XRLSearchSession(Constants.X_SSINDEX_GET_SESSION);
				XRLAttribParam[] Params = new XRLAttribParam[1]{new XRLAttribParam(Constants.X_ATTRIBUTE_DATATYPE_INTEGER,new XRLIntParam(lSessID))};
				searchReq.AddParams(Params);
                searchReq.baseSearchSession.wFlags = 3;
                searchReq.baseSearchSession.dwTitleID = 0x3e7;
                XRLSearchResults    searchResp;
                if(searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out searchResp))
                {
                    if(searchResp != null)
                        ResultCode=TEST_RESULTS.PASSED;
                }
                XRLDeleteSession delReq = new XRLDeleteSession(createResp.SessionID);
                delReq.dwTitleID = 0x3e7;
                delReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
            }
        }
        [TestCase, Description("host session is NAT type is 0, client is OpenNAT/moderate/strict")]
			class PZeroNAT : TestBase
        {
            override protected void Execute()
            {    // create two sessions so we can gurantee there are one on each db
				uint    numDB = Constants.getNumDBForTitle(Constants.TITLE_ID);
				uint numSessions = numDB;
				XRLCreateUpdateSession    [] createReq = new XRLCreateUpdateSession[numSessions];
                XRLSessionInfo            [] createResp = new XRLSessionInfo[numSessions];
                for(int i = 0; i < numSessions; i++)
                {
                    createReq[i] = new XRLCreateUpdateSession();
                    createReq[i].baseSession.SessionID=new byte[]{0x0,0,0,0,0,0,0,0};
                    if(!createReq[i].Execute(Global.XEnv.GetInterface(Interface.xmatchfd)[0],out createResp[i]))
                        return;
                }
                // search for the session with open NAT/moderate/strict
                XRLSearchSession    searchReq1 = new XRLSearchSession(0), searchReq2=new XRLSearchSession(0),searchReq3=new XRLSearchSession(0);
                XRLSearchResults    searchResp1, searchResp2, searchResp3;
                searchReq1.baseSearchSession.wFlags = 1;
                searchReq2.baseSearchSession.wFlags = 2;
                searchReq3.baseSearchSession.wFlags = 3;
                if(searchReq1.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out searchResp1)&&
                    searchReq2.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out searchResp2)&&
                    searchReq3.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out searchResp3))
                {
                    if((searchResp1.resultsLen != 0)&&(searchResp2.resultsLen!= 0)&&
                        (searchResp3.resultsLen != 0))
                        ResultCode=TEST_RESULTS.PASSED;
                }
                for(int i = 0; i < numSessions; i++)
                {
                    XRLDeleteSession delReq = new XRLDeleteSession(createResp[i].SessionID);
                    delReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                }
            }
        }
        [TestCase, Description("host session is OpenNAT, client is OpenNAT/moderate/strict")]
			class POpenNAT : TestBase
        {
            override protected void Execute()
            {    // create two sessions so we can gurantee there are one on each db
				uint    numDB = Constants.getNumDBForTitle(Constants.TITLE_ID);
				uint numSessions = numDB;
				XRLCreateUpdateSession    [] createReq = new XRLCreateUpdateSession[numSessions];
                XRLSessionInfo            [] createResp = new XRLSessionInfo[numSessions];
                for(int i = 0; i < numSessions; i++)
                {
                    createReq[i] = new XRLCreateUpdateSession();
                    if(!createReq[i].Execute(Global.XEnv.GetInterface(Interface.xmatchfd)[0],out createResp[i]))
                        return;
                }
                // search for the session with open NAT/moderate/strict
                XRLSearchSession    searchReq1 = new XRLSearchSession(0), searchReq2=new XRLSearchSession(0),searchReq3=new XRLSearchSession(0);
                XRLSearchResults    searchResp1, searchResp2, searchResp3;
                searchReq1.baseSearchSession.wFlags = 1;
                searchReq2.baseSearchSession.wFlags = 2;
                searchReq3.baseSearchSession.wFlags = 3;
                if(searchReq1.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out searchResp1)&&
                    searchReq2.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out searchResp2)&&
                    searchReq3.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out searchResp3))
                {
                    if((searchResp1.resultsLen != 0)&&(searchResp2.resultsLen!= 0)&&
                        (searchResp3.resultsLen != 0))
                        ResultCode=TEST_RESULTS.PASSED;
                }
                for(int i = 0; i < numSessions; i++)
                {
                    XRLDeleteSession delReq = new XRLDeleteSession(createResp[i].SessionID);
                    delReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                }
            }
        }
        [TestCase, Description("host session is Moderate NAT, client is Moderate/open/strict NAT")]
			class PModerateNAT : TestBase
        {
            override protected void Execute()
            {    // create two sessions so we can gurantee there are one on each db
				uint    numDB = Constants.getNumDBForTitle(Constants.TITLE_ID);
				uint numSessions = numDB;
				XRLCreateUpdateSession    [] createReq = new XRLCreateUpdateSession[numSessions];
                XRLSessionInfo            [] createResp = new XRLSessionInfo[numSessions];
                for(int i = 0; i < numSessions; i++)
                {
                    createReq[i] = new XRLCreateUpdateSession();
                    createReq[i].baseSession.SessionID=new byte[]{0x20,0,0,0,0,0,0,0};
                    if(!createReq[i].Execute(Global.XEnv.GetInterface(Interface.xmatchfd)[0],out createResp[i]))
                        return;
                }
                // search for the session with open NAT/moderate/strict
                XRLSearchSession    searchReq1 = new XRLSearchSession(0), searchReq2=new XRLSearchSession(0),searchReq3=new XRLSearchSession(0);
                XRLSearchResults    searchResp1, searchResp2, searchResp3;
                searchReq1.baseSearchSession.wFlags = 1;
                searchReq2.baseSearchSession.wFlags = 2;
                searchReq3.baseSearchSession.wFlags = 3;
                if(searchReq1.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out searchResp1)&&
                    searchReq2.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out searchResp2)&&
                    searchReq3.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out searchResp3))
                {
                    if((searchResp1.resultsLen != 0)&&(searchResp2.resultsLen!= 0)&&
                        (searchResp3 == null))
                        ResultCode=TEST_RESULTS.PASSED;
                }
                for(int i = 0; i < numSessions; i++)
                {
                    XRLDeleteSession delReq = new XRLDeleteSession(createResp[i].SessionID);
                    delReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                }
            }
        }
        [TestCase, Description("host session is Strict NAT, client is Moderate/open/strict NAT")]
			class PStrictNAT : TestBase
        {
            override protected void Execute()
            {    // create two sessions so we can gurantee there are one on each db
				uint    numDB = Constants.getNumDBForTitle(Constants.TITLE_ID);
				uint numSessions = numDB;
				XRLCreateUpdateSession    [] createReq = new XRLCreateUpdateSession[numSessions];
                XRLSessionInfo            [] createResp = new XRLSessionInfo[numSessions];
                for(int i = 0; i < numSessions; i++)
                {
                    createReq[i] = new XRLCreateUpdateSession();
                    createReq[i].baseSession.SessionID=new byte[]{0x30,0,0,0,0,0,0,0};
                    if(!createReq[i].Execute(Global.XEnv.GetInterface(Interface.xmatchfd)[0],out createResp[i]))
                        return;
                }
                // search for the session with open NAT/moderate/strict
                XRLSearchSession    searchReq1 = new XRLSearchSession(0), searchReq2=new XRLSearchSession(0),searchReq3=new XRLSearchSession(0);
                XRLSearchResults    searchResp1, searchResp2, searchResp3;
                searchReq1.baseSearchSession.wFlags = 1;
                searchReq2.baseSearchSession.wFlags = 2;
                searchReq3.baseSearchSession.wFlags = 3;
                if(searchReq1.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out searchResp1)&&
                    searchReq2.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out searchResp2)&&
                    searchReq3.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out searchResp3))
                {
                    if((searchResp1.resultsLen != 0)&&(searchResp2 == null)&& (searchResp3 == null))
                        ResultCode=TEST_RESULTS.PASSED;
                }
                for(int i = 0; i < numSessions; i++)
                {
                    XRLDeleteSession delReq = new XRLDeleteSession(createResp[i].SessionID);
                    delReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                }
            }
        }
        [TestCase, Description("do the same query against different sessions, check if results are the same")]
			class PSummaryCache1 : TestBase
        {
            override protected void Execute()
            {    // create 20 sessions do a session summary query; 10 session on each db
                // delete 2 sessions; do the same query again;
				uint    numDB = Constants.getNumDBForTitle(Constants.TITLE_ID);
				uint	numSessions = numDB * 10;
				uint    groupByAttribID = 0x0000AAAA;    // group by 0xAAAA
                uint    sumAttribID = 0x00001234;
                XRLCreateUpdateSession    [] createReq = new XRLCreateUpdateSession[numSessions];
                XRLSessionInfo            [] createResp = new XRLSessionInfo[numSessions];
                for(int i = 0; i < numSessions; i++)
                {
                    createReq[i] = new XRLCreateUpdateSession();
                    long        groupByintValue = 8, sumValue = 3;
					if(i < (numDB*3))
					{
						sumValue = 1;
						groupByintValue = 9;
					}
					else if (i < (numDB*6))
					{
						sumValue = 2;
						groupByintValue = 6;
					}
                    WireData [] Attribs = new WireData[2]{    new XRLIntAttribute(groupByAttribID,groupByintValue),
                                                             new XRLIntAttribute(sumAttribID,sumValue)};
                    createReq[i].AddAttribs(Attribs);
                    if(!createReq[i].Execute(Global.XEnv.GetInterface(Interface.xmatchfd)[0],out createResp[i]))
                        return;
                }
                // sp=0x30 is a session summary query for Sum
                // 3 groups will be returned
                XRLSearchSession    searchReq = new XRLSearchSession(0x80000030);
				searchReq.baseSearchSession.wFlags = Constants.XONLINE_MATCH_SEARCH_FLAG_NO_CACHE;
                XRLSearchResults    Resp;
                WireData [] expectedAttribs = new WireData[1]{new XRLIntParam()};
                if(searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),3,expectedAttribs,out Resp))
                {
                    bool    ret = true;
                    for(int j = 0; j < 3; j++)
                    {
                        XRLIntParam        intParam;
                        if(Resp.results[j].AttribOffsetsLen !=1)
                        {
                            Global.RO.Warn("number of attributes in the session is not 1");
                            ret = false;
                            break;
                        }
                        else if(((intParam = Resp.results[j].Attribs[0].aValue as XRLIntParam) == null)||
                            ((intParam.intValue!=(3*numDB))&&(intParam.intValue!=(6*numDB))&&(intParam.intValue!=(numDB*12))))
                        {
                            Global.RO.Warn("the "+ j + "th Returned avg Aggregrate is either not int type or not the right value");
                            ret = false;
                            break;
                        }
                    }
                    if(ret)
                    {
                        // delete 2 sessions
                        new XRLDeleteSession(createResp[numSessions-1].SessionID).Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
						new XRLDeleteSession(createResp[numSessions-2].SessionID).Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                        // do the same query again; the results should be the same as 1st query due to cache
                        XRLSearchSession    searchReq2 = new XRLSearchSession(0x80000030);
                        XRLSearchResults    Resp2;
                        WireData [] expectedAttribs2 = new WireData[1]{new XRLIntParam()};
                        if(searchReq2.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),3,expectedAttribs2,out Resp2))
                        {
                            bool    ret2 = true;
                            for(int j = 0; j < 3; j++)
                            {
                                XRLIntParam        intParam;
                                if(Resp.results[j].AttribOffsetsLen !=1)
                                {
                                    Global.RO.Warn("number of attributes in the session is not 1");
                                    ret2 = false;
                                    break;
                                }
                                else if(((intParam = Resp.results[j].Attribs[0].aValue as XRLIntParam) == null)||
                                    ((intParam.intValue!=(3*numDB))&&(intParam.intValue!=(6*numDB))&&(intParam.intValue!=(numDB*12))))
                                {
                                    Global.RO.Warn("the "+ j + "th ret2urned avg Aggregrate is either not int type or not the right value");
                                    ret2 = false;
                                    break;
                                }
                            }
                            if(ret2)
                                ResultCode=TEST_RESULTS.PASSED;
                        }
                    }
                }
                for(int i = 0; i < (numSessions-2); i++)
                    new XRLDeleteSession(createResp[i].SessionID).Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
            }
        }
        [TestCase, Description("do same query against different sessions;wait until cache expires;check if results are the different")]
			class PSummaryCache2 : TestBase
        {
            override protected void Execute()
            {    // create 20 sessions do a session summary query; 10 session on each db
                // delete 2 sessions; do the same query again;
				uint    numDB = Constants.getNumDBForTitle(Constants.TITLE_ID);
				uint	numSessions = numDB * 10;
				uint    groupByAttribID = 0x0000AAAA;    // group by 0xAAAA
                uint    sumAttribID = 0x00001234;
                XRLCreateUpdateSession    [] createReq = new XRLCreateUpdateSession[numSessions];
                XRLSessionInfo            [] createResp = new XRLSessionInfo[numSessions];
                for(int i = 0; i < numSessions; i++)
                {
                    createReq[i] = new XRLCreateUpdateSession();
                    long        groupByintValue = 8;
					long		sumValue = 3;
					if(i < (numDB*3))
					{
						groupByintValue = 9;
						sumValue = 1;
					}
					else if (i < (numDB*6))
					{
						groupByintValue = 6;
						sumValue = 2;
					}
                    WireData [] Attribs = new WireData[2]{    new XRLIntAttribute(groupByAttribID,groupByintValue),
                                                             new XRLIntAttribute(sumAttribID,sumValue)};
                    createReq[i].AddAttribs(Attribs);
                    if(!createReq[i].Execute(Global.XEnv.GetInterface(Interface.xmatchfd)[0],out createResp[i]))
                        return;
                }
                // sp=0x80000030 is a session summary query for Sum
                // 3 groups will be returned
                XRLSearchSession    searchReq = new XRLSearchSession(0x80000030);
				searchReq.baseSearchSession.wFlags = Constants.XONLINE_MATCH_SEARCH_FLAG_NO_CACHE;
                XRLSearchResults    Resp;
                WireData [] expectedAttribs = new WireData[1]{new XRLIntParam()};
                if(searchReq.Execute(Global.XEnv.GetInterface(Interface.xmatchfd)[0],3,expectedAttribs,out Resp))
                {
                    bool    ret = true;
                    for(int j = 0; j < 3; j++)
                    {
                        XRLIntParam        intParam;
                        if(Resp.results[j].AttribOffsetsLen !=1)
                        {
                            Global.RO.Warn("number of attributes in the session is not 1");
                            ret = false;
                            break;
                        }
                        else if(((intParam = Resp.results[j].Attribs[0].aValue as XRLIntParam) == null)||
                            ((intParam.intValue!=(3*numDB))&&(intParam.intValue!=(6*numDB))&&(intParam.intValue!=(numDB*12))))
                        {
                            Global.RO.Warn("the "+ j + "th Returned sum Aggregrate is either not int type or not the right value");
                            ret = false;
                            break;
                        }
                    }
                    if(ret)
                    {
                        // delete 2 sessions
                        new XRLDeleteSession(createResp[numSessions-1].SessionID).Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
						new XRLDeleteSession(createResp[numSessions-2].SessionID).Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                        // don't use session cache for this search
                        // do the same query again; the results should be different
                        XRLSearchSession    searchReq2 = new XRLSearchSession(0x80000030);
						searchReq2.baseSearchSession.wFlags = Constants.XONLINE_MATCH_SEARCH_FLAG_NO_CACHE;
                        XRLSearchResults    Resp2;
                        WireData [] expectedAttribs2 = new WireData[1]{new XRLIntParam()};
                        if(searchReq2.Execute(Global.XEnv.GetInterface(Interface.xmatchfd)[0],3,expectedAttribs2,out Resp2))
                        {
                            bool    ret2 = true;
                            for(int j = 0; j < 3; j++)
                            {
                                XRLIntParam        intParam;
                                if(Resp2.results[j].AttribOffsetsLen !=1)
                                {
                                    Global.RO.Warn("number of attributes in the session is not 1");
                                    ret2 = false;
                                    break;
                                }
                                else if(((intParam = Resp2.results[j].Attribs[0].aValue as XRLIntParam) == null)||
                                    ((intParam.intValue!=(3*numDB))&&(intParam.intValue!=(6*numDB))&&(intParam.intValue!=(numDB*9))))
                                {
                                    Global.RO.Warn("the "+ j + "th returned sum Aggregrate is either not int type or not the right value");
                                    ret2 = false;
                                    break;
                                }
                            }
                            if(ret2)
                                ResultCode=TEST_RESULTS.PASSED;
                        }
                    }
                }
                for(int i = 0; i < (numSessions-2); i++)
                    new XRLDeleteSession(createResp[i].SessionID).Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
            }
        }

        // need to have Throttling.ini file in the match fd
        [TestCase, Description("check X-Delay header for title 0xffed0001")]
			class PThrottling : TestBase
        {
            override protected void Execute()
            {
                // create one session on each db so we can ensure there will be 1 session returned
				Global.XEnv.ExecuteXmgmtCommand(Interface.xmatchfd,"e :xmatchfd SetXdelay 0xffed0001 xmatchhost 10000");
				Global.XEnv.ExecuteXmgmtCommand(Interface.xmatchfd,"e :xmatchfd SetXdelay 0xffed0001 xmatchClient 10000");

				uint    numDB = Constants.getNumDBForTitle(Constants.TITLE_ID);
				uint	numSessions = numDB;

                XRLCreateUpdateSession      []  createReq = new XRLCreateUpdateSession[numSessions];
                XRLSessionInfo              []  createResp = new XRLSessionInfo[numSessions];

				for(int i = 0; i < numSessions; i++)
				{
					createReq[i] = new XRLCreateUpdateSession();
					createResp[i] = new XRLSessionInfo();
					if(createReq[i].Execute(Global.XEnv.GetInterface(Interface.xmatchfd)[0],out createResp[i]))
					{
						if(createReq[i].XDelay != 10000 )
						{
							Global.RO.Warn("X-Delay in CreateResponse is not 10000");
							goto Exit;
						}
					}
					else
					{
						Global.RO.Warn("Failed to create sessions");
					}
				}

				// search sessions
				XRLSearchSession    searchReq = new XRLSearchSession(0);
				XRLSearchResults    Resp;
				if(searchReq.Execute(Global.XEnv.GetInterface(Interface.xmatchfd)[0], out Resp))
				{
					if(searchReq.XDelay != 10000)
					{
						Global.RO.Warn("X-Delay in searchResponse is not 10000");
						goto Exit;
					}
					if(Resp == null)
					{
						Global.RO.Warn("no search results returned");
						goto Exit;
					}
					if( (Resp.resultsLen == 1)&&
						(Resp.dwMessageLength == Constants.SIZESEARCHHEADER+Constants.SIZEBASESEARCHRESULT))
					{
						ResultCode=TEST_RESULTS.PASSED;
					}
					else
					{
						Global.RO.Warn("resultsLen != 1 (" + Resp.resultsLen.ToString() + ") or dwMessageLength is wrong (" + Resp.dwMessageLength.ToString() + " != " + (Constants.SIZESEARCHHEADER+Constants.SIZEBASESEARCHRESULT).ToString() + ")");
					}
				}
	            Exit:
                XRLDeleteSession []   delReq = new XRLDeleteSession[numSessions];
				for(int i = 0; i < numSessions; i++)
				{
					delReq[i]=new XRLDeleteSession(createResp[i].SessionID);
					delReq[i].Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
				}
				Global.XEnv.ExecuteXmgmtCommand(Interface.xmatchfd,"exec :xmatchfd ReloadThrottleConfig");
				}
            }
        /***************************************************************************************
         * The followings are negative cases
         ***************************************************************************************/
        [TestCase, Description("Search with X_SSINDEX_GET_SESSION and a valid SessionID but wrong(valid)title")]
			class NSpecialSP1WrongTitle : NegativeSearchTestBase
        {
            override protected void Execute()
            {
                XRLCreateUpdateSession        createReq = new XRLCreateUpdateSession();
				createReq.baseSession.dwTitleID = 0xffedaaa9;//useing this titleID and 9090 since they both lives in the same sql
                XRLSessionInfo                createResp;
                if(createReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out createResp))
                {
                    long    lSessID = Constants.sessionIDConvert(createResp.SessionID);
                    // search based on sessionID
                    XRLSearchSession    searchReq = new XRLSearchSession(Constants.X_SSINDEX_GET_SESSION);
					XRLAttribParam[] Params = new XRLAttribParam[1]{new XRLAttribParam(Constants.X_ATTRIBUTE_DATATYPE_INTEGER,new XRLIntParam(lSessID))};
					searchReq.AddParams(Params);
                    searchReq.baseSearchSession.dwTitleID = 9090;
                    XRLSearchResults    Resp;
                    if(searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out Resp))
                    {
                        if(Resp == null)    // detailed checking was done by FuncCreateSession verification
                            ResultCode=TEST_RESULTS.PASSED;
                    }
                    XRLDeleteSession    delReq = new XRLDeleteSession(createResp.SessionID);
					delReq.dwTitleID = 0xffedaaa9;
                    delReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                }
            }
        }
        [TestCase, Description("Search with X_SSINDEX_GET_SESSION and a valid SessionID but unknown title")]
			class NSpecialSP1UnknownTitle : NegativeSearchTestBase
        {
            override protected void Execute()
            {
                XRLCreateUpdateSession        createReq = new XRLCreateUpdateSession();
                XRLSessionInfo                createResp;
                if(createReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out createResp))
                {
                    long    lSessID = Constants.sessionIDConvert(createResp.SessionID);
                    // search based on sessionID
                    XRLSearchSession    searchReq = new XRLSearchSession(Constants.X_SSINDEX_GET_SESSION);
                    // sp=5 takes sessionID as parameter
					XRLAttribParam[] Params = new XRLAttribParam[1]{new XRLAttribParam(Constants.X_ATTRIBUTE_DATATYPE_INTEGER,new XRLIntParam(lSessID))};
					searchReq.AddParams(Params);
                    searchReq.baseSearchSession.dwTitleID = Constants.UNKNOWN_TITLE;
                    if(SearchTestNegative(searchReq,HResult.XONLINE_E_MATCH_INVALID_TITLE_ID))
                            ResultCode=TEST_RESULTS.PASSED;
                    XRLDeleteSession    delReq = new XRLDeleteSession(createResp.SessionID);
                    delReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                }
            }
        }
        [TestCase, Description("Search with X_SSINDEX_GET_SESSION with an invalid sessionID")]
			class NSpecialSP1InvalidSessID : NegativeSearchTestBase
        {
            override protected void Execute()
            {
                XRLSearchSession    searchReq = new XRLSearchSession(Constants.X_SSINDEX_GET_SESSION);
                // sp=5 takes sessionID as parameter

                // Make sure the invalid session id we choose here maps to db
                // zero, or else the call may be rejected as an invalid session
                // id which is different from one that doesn't exist. Also
                // mark it as an online peer session just for consistency.
                // MatchDefs.XNET_XNKID_DBINDEX_MASK = 0x0F
                // MatchDefs.XNET_XNKID_ONLINE_PEER = 0x80
                // So we pick 0x180
				XRLAttribParam[] Params = new XRLAttribParam[1]{new XRLAttribParam(Constants.X_ATTRIBUTE_DATATYPE_INTEGER,new XRLIntParam(0x180))};
				searchReq.AddParams(Params);
                XRLSearchResults        Resp;
                if(searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out Resp))
                {
                    if(Resp == null)
                        ResultCode=TEST_RESULTS.PASSED;
                }
            }
        }
        [TestCase, Description("search with 0 parameters using a nonexistent stored procedure")]
			class NNonExistentSP : NegativeSearchTestBase
        {
            override protected void Execute()
            {
                XRLSearchSession    searchReq = new XRLSearchSession(1000);
                if(SearchTestNegative(searchReq,HResult.XONLINE_E_MATCH_INVALID_SEARCH_REQ))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("search with 1 int parameter using unknown title")]
			class NUnknownTitle : NegativeSearchTestBase
        {
            override protected void Execute()
            {
                // sp=1 takes one int parameter
                XRLSearchSession    searchReq = new XRLSearchSession(1);
                searchReq.baseSearchSession.dwTitleID = Constants.UNKNOWN_TITLE;
				XRLAttribParam[] Params = new XRLAttribParam[1]{new XRLAttribParam(Constants.X_ATTRIBUTE_DATATYPE_INTEGER,new XRLIntParam(12345))};
				searchReq.AddParams(Params);
                if(SearchTestNegative(searchReq,HResult.XONLINE_E_MATCH_INVALID_TITLE_ID))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("passing string parameter to a sp that takes integer")]
			class NMismatchedSp1 : NegativeSearchTestBase
        {
            override protected void Execute()
            {
                // sp=1 takes one int parameter
                XRLSearchSession    searchReq = new XRLSearchSession(1);
				XRLAttribParam[] Params = new XRLAttribParam[1]{new XRLAttribParam(Constants.X_ATTRIBUTE_DATATYPE_STRING,new XRLStringParam("abc\0"))};
				searchReq.AddParams(Params);
                if(SearchTestNegative(searchReq,HResult.XONLINE_E_MATCH_INVALID_SEARCH_REQ))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("passing blob parameter to a sp that takes integer")]
			class NMismatchedSp2 : NegativeSearchTestBase
        {
            override protected void Execute()
            {
                // sp=1 takes one int parameter
                XRLSearchSession    searchReq = new XRLSearchSession(1);
                byte [] blobVal = new byte[1]{0x09};
                XRLAttribParam []            Params = new XRLAttribParam[1]{new XRLAttribParam(Constants.X_ATTRIBUTE_DATATYPE_BLOB,new XRLBlobParam(blobVal))};
                searchReq.AddParams(Params);
                if(SearchTestNegative(searchReq,HResult.XONLINE_E_MATCH_INVALID_SEARCH_REQ))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("passing int parameter to a sp that takes string")]
			class NMismatchedSp3 : NegativeSearchTestBase
        {
            override protected void Execute()
            {
                // sp=2 takes one string parameter
                XRLSearchSession    searchReq = new XRLSearchSession(2);
                XRLAttribParam []            Params = new XRLAttribParam[1]{new XRLAttribParam(Constants.X_ATTRIBUTE_DATATYPE_INTEGER,new XRLIntParam(123))};
                searchReq.AddParams(Params);
                if(SearchTestNegative(searchReq,HResult.XONLINE_E_MATCH_INVALID_SEARCH_REQ))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("passing blob parameter to a sp that takes string")]
			class NMismatchedSp4 : NegativeSearchTestBase
        {
            override protected void Execute()
            {
                // sp=2 takes one string parameter
                XRLSearchSession    searchReq = new XRLSearchSession(2);
                byte [] blobVal = new byte[1]{0x12};
                XRLAttribParam []            Params = new XRLAttribParam[1]{new XRLAttribParam(Constants.X_ATTRIBUTE_DATATYPE_BLOB,new XRLBlobParam(blobVal))};
                searchReq.AddParams(Params);
                if(SearchTestNegative(searchReq,HResult.XONLINE_E_MATCH_INVALID_SEARCH_REQ))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("passing int parameter to a sp that takes blob")]
			class NMismatchedSp5 : NegativeSearchTestBase
        {
            override protected void Execute()
            {
                // sp=3 takes one blob parameter
                XRLSearchSession    searchReq = new XRLSearchSession(3);
				XRLAttribParam []            Params = new XRLAttribParam[1]{new XRLAttribParam(Constants.X_ATTRIBUTE_DATATYPE_INTEGER,new XRLIntParam(1))};
				searchReq.AddParams(Params);
                if(SearchTestNegative(searchReq,HResult.XONLINE_E_MATCH_INVALID_SEARCH_REQ))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("passing string parameter to a sp that takes blob")]
			class NMismatchedSp6 : NegativeSearchTestBase
        {
            override protected void Execute()
            {
                // sp=3 takes one blob parameter
                XRLSearchSession    searchReq = new XRLSearchSession(3);
                XRLAttribParam []            Params = new XRLAttribParam[1]{new XRLAttribParam(Constants.X_ATTRIBUTE_DATATYPE_STRING,new XRLStringParam("abc\0"))};
                searchReq.AddParams(Params);
                if(SearchTestNegative(searchReq,HResult.XONLINE_E_MATCH_INVALID_SEARCH_REQ))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("passing 2 paramters to a sp that takes 3 int/string/blob")]
			class NWrongNumParams : NegativeSearchTestBase
        {
            override protected void Execute()
            {
                XRLSearchSession    searchReq = new XRLSearchSession(33);
                XRLAttribParam []            Params = new XRLAttribParam[2]{new XRLAttribParam(Constants.X_ATTRIBUTE_DATATYPE_INTEGER,new XRLIntParam(123)),
																			   new XRLAttribParam(Constants.X_ATTRIBUTE_DATATYPE_STRING,new XRLStringParam("abc\0"))};
                searchReq.AddParams(Params);
                if(SearchTestNegative(searchReq,HResult.XONLINE_E_MATCH_INVALID_SEARCH_REQ))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }

		//While it is okay for dwMessageLength to be less than the size specified by Content-Length,
		//it is not okay for dwMessageLength to be less than the required size of the search structure
		//given the specified number of parameters.
        [TestCase, Description("31947:dwMessageLength is shorter than actual request length")]
			class NOverflowMsgLen : NegativeSearchTestBase
        {
            override protected void Execute()
            {
                XRLSearchSession    searchReq = new XRLSearchSession(2);
                XRLAttribParam []            Params = new XRLAttribParam[1]{new XRLAttribParam(Constants.X_ATTRIBUTE_DATATYPE_STRING,new XRLStringParam("abc\0"))};
                searchReq.AddParams(Params);
                searchReq.baseSearchSession.dwMessageLength -=1;
                if(SearchTestNegative(searchReq,HResult.XONLINE_E_MATCH_REQUEST_TOO_SMALL))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("dwMessageLength is larger than actual request length")]
			class NTruncateMsgLen : NegativeSearchTestBase
        {
            override protected void Execute()
            {
                XRLSearchSession    searchReq = new XRLSearchSession(2);
				XRLAttribParam []            Params = new XRLAttribParam[1]{new XRLAttribParam(Constants.X_ATTRIBUTE_DATATYPE_STRING,new XRLStringParam("abc\0"))};
				searchReq.AddParams(Params);
                searchReq.baseSearchSession.dwMessageLength +=1;
                if(SearchTestNegative(searchReq,HResult.XONLINE_E_MATCH_REQUEST_TRUNCATED))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        // bug 31542
        [TestCase, Description("dwNumUsers is larger than max")]
			class NWrongNumUsers : NegativeSearchTestBase
        {
            override protected void Execute()
            {
                XRLCreateUpdateSession    createReq = new XRLCreateUpdateSession();
                XRLSessionInfo            createResp;
                if(createReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out createResp))
                {
                    long    lSessID = Constants.sessionIDConvert(createResp.SessionID);
                    // sp=5 takes one int param(sessID);
                    XRLSearchSession    searchReq = new XRLSearchSession(5);
                    searchReq.baseSearchSession.wNumUsers = Constants.XONLINE_MAX_LOGON_USERS+1;
                    XRLAttribParam[] Params = new XRLAttribParam[1]{new XRLAttribParam(Constants.X_ATTRIBUTE_DATATYPE_INTEGER,new XRLIntParam(lSessID))};
                    searchReq.AddParams(Params);
                    if(SearchTestNegative(searchReq,HResult.XONLINE_E_MATCH_TOO_MANY_USERS))
                        ResultCode=TEST_RESULTS.PASSED;
                    XRLDeleteSession    delReq = new XRLDeleteSession(createResp.SessionID);
                    delReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                }
            }
        }
        [TestCase, Description("client's NAT type is invalid")]
			class NInvalidNATType : NegativeSearchTestBase
        {
            override protected void Execute()
            {
                XRLCreateUpdateSession    createReq = new XRLCreateUpdateSession();
                XRLSessionInfo            createResp;
                if(createReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out createResp))
                {
                    long    lSessID = Constants.sessionIDConvert(createResp.SessionID);
                    // sp=5 takes one int param(sessID);
                    XRLSearchSession    searchReq = new XRLSearchSession(5);
                    searchReq.baseSearchSession.wFlags = 4;
XRLAttribParam[] Params = new XRLAttribParam[1]{new XRLAttribParam(Constants.X_ATTRIBUTE_DATATYPE_INTEGER,new XRLIntParam(lSessID))};                    searchReq.AddParams(Params);
                    if(SearchTestNegative(searchReq,HResult.XONLINE_E_MATCH_INVALID_FLAGS))
                        ResultCode=TEST_RESULTS.PASSED;
                    XRLDeleteSession    delReq = new XRLDeleteSession(createResp.SessionID);
                    delReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                }
            }
        }
		[TestCase, Description("pass a NULL parameter to a sp that takes int parameter which do not allow null")]
			class NNullParameters : NegativeSearchTestBase
		{
			override protected void Execute()
			{
				XRLCreateUpdateSession    createReq1 = new XRLCreateUpdateSession(), createReq2=new XRLCreateUpdateSession();
				XRLSessionInfo            createResp1, createResp2;
				if(createReq1.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out createResp1) &&
					createReq2.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out createResp2))
				{
					// sp=1 takes one int param, but do not allow NULL
					XRLSearchSession    searchReq = new XRLSearchSession(1);
					XRLAttribParam[] Params = new XRLAttribParam[1]{new XRLAttribParam(Constants.X_ATTRIBUTE_DATATYPE_NULL,new XRLNullParam())};
					searchReq.AddParams(Params);
					if(SearchTestNegative(searchReq,HResult.XONLINE_E_MATCH_INVALID_SEARCH_REQ))
						ResultCode=TEST_RESULTS.PASSED;
					XRLDeleteSession    delReq1 = new XRLDeleteSession(createResp1.SessionID), delReq2=new XRLDeleteSession(createResp2.SessionID);
					delReq1.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
					delReq2.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
				}
			}
		}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XMatchTest\FuncDeleteSession.cs ===
using System;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Matchmaking;
using xonline.common.config;

namespace XMatchTest
{
    internal abstract class NegativeDeleteTestBase : TestBase
    {
        protected bool DeleteTestNegative(XRLDeleteSession Req, uint XErr)
        {
            if (Req.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd)))
            {
                Global.RO.Warn("Negative DeleteSession request succeed unexpectedly");
                return false;
            }
            if(Req.XErr != XErr)
            {
                Global.RO.Warn("Wrong error code (" + Global.XErrToString(Req.XErr) + " != " + Global.XErrToString(XErr) + ") returned");
                return false;
            }
            return true;
        }
    }
    // These tests are deprecated, as Xbox1 support is removed.  These will be deleted in the next release.
    [TestGroup, Ignore]
    public class FuncDeleteSession : TestNode
    {
        /*****************************************************************************
         * The following cases are positive cases
         * some of the cases are done through FuncCreateUpdateSession verification
         *****************************************************************************/
        [BVT]
        [TestCase, Description("Delete a newly created Session")]
			class PNormalCase : TestBase
        {
            override protected void Execute()
            {
                XRLCreateUpdateSession    req = new XRLCreateUpdateSession();
                XRLSessionInfo            Resp;
                if(req.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out Resp))
                {
                    XRLDeleteSession    delReq = new XRLDeleteSession(Resp.SessionID);
                    if(delReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd)))
                        ResultCode=TEST_RESULTS.PASSED;
                }
                else
                    Global.RO.Warn("CreateSession failed:"+Global.XErrToString(req.XErr));
            }
        }

        /************************************************************************************
         * The following is for Tsunami Wave2
         ************************************************************************************/
        [TestCase, Description("delete a session for a title that lives on multiple db")]
			class PTitleOnMultiDB : TestBase
        {
                // this is to test if the db that the session is on can be detected correctly
            override protected void Execute()
            {    // create 2 sessions so we can gurantee there is on created on 2nd db
                XRLCreateUpdateSession    req1 = new XRLCreateUpdateSession(), req2 = new XRLCreateUpdateSession();
                XRLSessionInfo            Resp1=null, Resp2 = null;
                if(    req1.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out Resp1) &&
                    req2.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out Resp2))
                {
                    XRLDeleteSession    delReq1 = new XRLDeleteSession(Resp1.SessionID), delReq2;
                    delReq2 = new XRLDeleteSession(Resp2.SessionID);
                    if(delReq1.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd))&& delReq2.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd)))
                        ResultCode=TEST_RESULTS.PASSED;
                }
                else
                    Global.RO.Warn("CreateSession failed:"+Global.XErrToString(req1.XErr)+"Or"+Global.XErrToString(req2.XErr));
            }
        }
        /*****************************************************************************
         * The following cases are negative cases
         *****************************************************************************/
        [TestCase, Description("Try to delete an invalid session")]
			class NInvalidSession : NegativeDeleteTestBase
        {
            override protected void Execute()
            {
                //start by creating a good session
                XRLCreateUpdateSession        createReq = new XRLCreateUpdateSession();
                XRLSessionInfo                Resp;
                if(!createReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out Resp)) {
                    Global.RO.Warn("Could not create a generic session to modify!");
                    ResultCode = TEST_RESULTS.FAILED;
                }

                byte []SessID = new byte[8]{0,0,0,0,0,0,0,1};
                //copy over the bytes of the other session
                for(int i=0; i<8; i++) {
                    SessID[i] = Resp.SessionID[i];
                }

                //muck up the two bytes to get an invalid session.  We'll use xor, even though it
                //takes a million typecasts.  Note these two bytes are in reversed order.
                //i.e. they're serialized in reverse, so we modify bytes 6 and 7 to get the most
                //significant bits.
                SessID[6] = (byte) ((int) SessID[6] ^ (int) 0xFF);
                SessID[7] = (byte) ((int) SessID[7] ^ (int) 0xFF);

                XRLDeleteSession    req = new XRLDeleteSession(SessID);
                if(DeleteTestNegative(req,HResult.XONLINE_E_MATCH_INVALID_SESSION_ID))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("Try to delete an session with invalid Title")]
			class NInvalidTitle : NegativeDeleteTestBase
        {
            override protected void Execute()
            {
                XRLCreateUpdateSession    Createreq = new XRLCreateUpdateSession();
                XRLSessionInfo            Resp;
                if(Createreq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out Resp))
                {
                    XRLDeleteSession    req = new XRLDeleteSession(Resp.SessionID);
                    req.dwTitleID += 1;
                    if(DeleteTestNegative(req,HResult.XONLINE_E_MATCH_INVALID_TITLE_ID))
                        ResultCode=TEST_RESULTS.PASSED;
                    XRLDeleteSession    delReq = new XRLDeleteSession(Resp.SessionID);
                    delReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XMatchTest\Func2SearchWeighted.cs ===
using System;
using System.Collections;
using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Matchmaking;
using ServerTestFramework.Utilities;
using xonline.common.config;

namespace XMatchTest
{

    [TestGroup, TestFrequency("Regression")]
    public class Func2SearchWeighted : TestNode
    {
        //copied out of Func2SearchSession.  Figure out how to reuse without copy.

        public static bool SearchTestNegative(XRL2SearchSession Req, uint XErr)
        {
            XRL2SearchResults resp;
            if (Req.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out resp))
            {
                Global.RO.Warn("Negative CreateSession request succeeded unexpectedly!");
                return false;
            }
            if (Req.XErr != XErr)
            {
                Global.RO.Warn("Wrong error code (got " + Global.XErrToString(Req.XErr) + ", expected " + Global.XErrToString(XErr) + ")");
                return false;
            }
            if (resp != null)
            {
                Global.RO.Warn("response is not null");
                return false;
            }
            Global.RO.Success("Received error code " + Global.XErrToString(Req.XErr) + " as expected");
            return true;
        }



        static ArrayList rankedSessionData = new ArrayList();
        static ArrayList standardSessionData = new ArrayList();


        //Create a random session data.  Given a template of attributes, fill in each attribute with
        //random data up to the value in the attribute.
        public static void FillSessionRandom(XRLXeAttribParam [] template, int numSessions, SessionType type) {
            FillSessionRandom(template, numSessions, type, true);
        }
        //Create a random session data.  Given a template of attributes, fill in each attribute with
        //random data up to the value in the attribute.  If appendToExisting, instead of cleaning
        //the table, append to whatever arraylist already exists.
        public static void FillSessionRandom(XRLXeAttribParam [] template, int numSessions, SessionType type, bool cleanTable) {
            if (cleanTable) {
                MatchUtil.TruncateSessionsForTitle(Constants.XENON_TITLE, type);
            }
            Global.RO.Info("Creating " + numSessions + " randomized sessions");
            ArrayList sessions = new ArrayList();
            XRLXeAttribParam [] randomAtts = new XRLXeAttribParam[template.Length];
            //initialize the randomAtts array to look like the template.
            for (int i=0; i<template.Length; i++) {
                randomAtts[i] = (XRLXeAttribParam) template[i].DeepClone();
            }
            for (int i=0; i<numSessions; i++) {
                MatchSession sess = new MatchSession(false);
                for (int j=0; j<template.Length; j++) {
                    randomAtts[j].aValue.SetNumericValue(RandomEx.GlobalRandGen.NextDouble() * template[j].aValue.GetNumericValue());
                }
                sess.AddAttribs(randomAtts, false);
                sess.UpdateAttrib(new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_MU, RandomEx.GlobalRandGen.NextDouble()*4.0), false);
                sess.Create(type);
                sessions.Add(sess);
            }
            if (cleanTable) {
                if (type == SessionType.Ranked) {
                    rankedSessionData = sessions;
                } else {
                    standardSessionData = sessions;
                }
            } else {
                if (type == SessionType.Ranked) {
                    rankedSessionData.AddRange(sessions);
                } else {
                    standardSessionData.AddRange(sessions);
                }
            }
                
        }

        //Fill the session data with a matrix of data values.  For non-random flags, this will be
        //regularly spaced.
        //As a note, this method is *exponential*.  values^numAttribs will be created, so call this
        //with care!
        //
        //Fill between 0x20000012 to 0x2000002F
        public static void FillSessionMatrix(int numValues, int maxValue, int numAttribs,
                                             bool random, SessionType type) {
            MatchUtil.TruncateSessionsForTitle(Constants.XENON_TITLE, type);

            //how about we make a template for the session.  Pass in an array of attribs, and a
            //number saying the last N are binary.
            XRLXeAttribParam [][] attribMatrix;
            ArrayList sessions = new ArrayList();
            if ((numAttribs > 28) || (numValues > 10)) {
                Global.RO.Error("Arguments too large to create the matrix!  numAttribs should be <=28, and values <= 10");
            }
            attribMatrix = new XRLXeAttribParam[0][]; //start with an empty one.
            for (uint i = Constants.PROPERTY_MYINT64PROP3; i<Constants.PROPERTY_MYINT64PROP3 + numAttribs; i++) {
                AddAttribToMatrix(new XRLXeAttribParam(i,0), random, numValues, maxValue, attribMatrix, out attribMatrix);
            }

            Global.RO.Info("Session Matrix size is " + attribMatrix.Length);
            Global.RO.Info("Beginning create calls.");
            //Run a large number of creates.
            for (int i=0; i< attribMatrix.Length; i++) {
                if ((i % 1000) == 0) Global.RO.Info("Executing create # " + i);
                MatchSession sess = new MatchSession(false);
                sess.AddAttribs(attribMatrix[i], false);
                sess.Create(type);
                sessions.Add(sess);
            }

            //Store the MatchSessions into the appropriate static variable for test use.
            if (type == SessionType.Ranked) {
                rankedSessionData = sessions;
            } else {
                standardSessionData = sessions;
            }

        }

        //return a clone of the template, with values randomized from 0 to the value in the
        //template.  Weights are copied.
        private static XRLXeAttribParamWeighted [] CreateClonedWeightedParams(XRLXeAttribParamWeighted [] template, 
                                                                              RandomEx randGen) {
            XRLXeAttribParamWeighted [] ans = new XRLXeAttribParamWeighted [template.Length];
            for(int i=0; i<template.Length; i++) {
                ans[i] = (XRLXeAttribParamWeighted) template[i].DeepClone();
                ans[i].aValue.SetNumericValue(randGen.NextDouble() * template[i].aValue.GetNumericValue());
            }
            return ans;
        }

        //create a clone of the parameter, with its value filled in.  If random is set, grab a
        //random value between 0 and maxValue.  Otherwise fill with currentValue.
        private static XRLXeAttribParam CreateClonedParam(XRLXeAttribParam param, int maxValue, int currentValue, 
                                                           bool random, RandomEx randGen) {
            XRLXeAttribParam newParamClone = (XRLXeAttribParam) param.DeepClone();
            if (random) {
                if (param.aValue is XRLXeIntValue) {
                    param.SetNumericValue(randGen.Next(0, maxValue));
                } else {
                    //the other choices are double/float, and things that would cause run-time
                    //exceptions anyway, so no extra checking here.
                    param.SetNumericValue(randGen.NextDouble() * maxValue);
                }
            } else {
                param.SetNumericValue(currentValue);
            }
            return newParamClone;
        }

        //This method takes an existing 2D matrix of XRLXeAttribParams and creates N copies, where N
        //is the values.  In each copy, another attribute is created.  In the first set, the value
        //is set to 1.  In the second, 2, up to N.  The result is written to the output 2D matrix.
        public static void AddAttribToMatrix(XRLXeAttribParam newParam, bool random, int numValues, int maxValue,
                                             XRLXeAttribParam [][] input, out XRLXeAttribParam [][] output) {
            RandomEx randGen = new RandomEx();
            int sessionsBefore = input.Length;
            if (sessionsBefore == 0) { //we have to special case the first one.
                output = new XRLXeAttribParam[numValues][];  //base case:create N rows, where N=numValues.
                for (int i=0; i<numValues; i++) {
                    output[i] = new XRLXeAttribParam[1];  //base case:create each row with one attrib.
                    output[i][0] = CreateClonedParam(newParam, maxValue, i, random, randGen);
                }
            } else {  //if this isn't the first time, create (values * existing rows) rows.
                output = new XRLXeAttribParam[sessionsBefore * numValues][];  //create N copies where N = values.
                for (int i=0; i<numValues; i++) {  //for each value, make a copy of the existing parameters.
                    for (int j=0; j<sessionsBefore; j++) {  //go through each copy of the original.
                        //initialize this new row:
                        output[sessionsBefore * i + j] = new XRLXeAttribParam[input[0].Length + 1];

                        //copy all the existing params.  This can be by pointer.
                        for (int k=0; k<input[0].Length; k++) {
                            output[sessionsBefore * i + j][k] = input[j][k];
                        }
                        //add the one param that's new.  This has to be deepcloned, so that we can
                        //change the value.
                        output[sessionsBefore * i + j][input[0].Length] = CreateClonedParam(newParam, maxValue, i, random, randGen);
                    }
                }
            }
        }
            

        private class SessionWithScore : IComparable {
            public MatchSession session;
            public float score;
            public int orderNum;  //for grouping ties together later.  Positive and zero indicates a
                                  //group number.  -1 means unset.
            
            public SessionWithScore(MatchSession session, float score) {
                this.session = session;
                this.score = score;
                orderNum = -1;
            }

            public int CompareTo(object obj) {
                if (obj is SessionWithScore) {
                    //compare in this maner because subtract and convert-to-int could create some
                    //unwated 0 return values.
                    if ((this.score - ((SessionWithScore) obj).score) < 0) { 
                        return -1;
                    } else if (this.score == ((SessionWithScore) obj).score) {
                        return 0;
                    } else {
                        return 1;
                    }
                } else {
                    throw new Exception("Array has items that are not of type SessionWithScores!");
                }
            }

            public string GetScoredAttribs(XRLXeAttribParamWeighted [] weights) {
                string output = "";
                for (int weightNum = 0; weightNum < weights.Length; weightNum++) {
                    foreach (XRLXeAttribParam param in session.GetAttribs()) {
                        if (param.attribParamID == weights[weightNum].attribParamID) {
                            output += "0x" + param.attribParamID.ToString("X") + ":" + param.aValue + "  ";
                        }
                    }
                }
                return output;
            }

            public override string ToString() {
                return "session:" + session.GetSessionID() + " score:" + score;
            }
        }
        
        //A numeric filter class.  ArrayLists of these can be used to pare down a search set.  The
        //filter is only > or <.
        public class FilterAttrib {
            public XRLXeAttribParam attrib;
            public bool greaterThan; //if true, then sessions pass if their attrib is greater than this one.
            public FilterAttrib(XRLXeAttribParam attrib, bool greaterThan) {
                this.attrib = attrib;
                this.greaterThan = greaterThan;
            }

            public bool PassesFilter(MatchSession session) {
                foreach (XRLXeAttribParam param in session.GetAttribs()) {
                    if (param.attribParamID == this.attrib.attribParamID) {
                        if ((greaterThan) && (param.aValue.GetNumericValue() >= this.attrib.aValue.GetNumericValue())) {
                            return true;
                        } else if ((!greaterThan) && (param.aValue.GetNumericValue() <= this.attrib.aValue.GetNumericValue())) {
                            return true;
                        }
                        return false;
                    }
                }
                //what happens if we don't find the target param?  Should never happen in real
                //life.  Let's say return false, but with warning.
                Global.RO.Warn("Warning, attempted to filter on param 0x" + attrib.attribParamID.ToString("X") + 
                               ", but attrib was not in given session!  Returning false.");
                return false;
            }

            public override string ToString() {
                return "Filter on ID:" + attrib.attribParamID.ToString("X") + " pass-if-value " + 
                    (greaterThan ? ">= " : "<= ") + attrib.aValue.GetNumericValue();
                    
            }
        }

        //another N^2 comparaison.  Go through an ArrayList of MatchSessions, and for each one, if
        //it passes all the filters, add it to a new, returned arraylist.
        public static ArrayList ApplyFilters(ArrayList sessions, ArrayList filters) {
            ArrayList ans = new ArrayList();
            foreach (MatchSession session in sessions) {
                bool pass = true;
                foreach (FilterAttrib filter in filters) {
                    if (!(filter.PassesFilter(session))) {
                        pass = false;
                    }
                }
                if (pass) ans.Add(session);
            }
            return ans;
        }

        //Create an array of false values.  Binary items will be set with these arrays.
        public static bool [] InitArrayOfFalses(int num) {
            bool [] ans = new bool[num];
            for (int i=0; i<ans.Length; i++) {
                ans[i] = false;
            }
            return ans;
        }

        //Test-side weighted search
        //Given a set of weighted attributes(the same one being sent to the server), execute a
        //search and order the attributes.  Perform this by running the distance formula on the
        //in-memory table, and then attaching a score to each of them.  Then use a sort.  Let's have
        //.Net do the work with ArrayLists and sorts here.
        public static ArrayList RunInternalWeightedSearch(ArrayList matchSessions, XRLXeAttribParamWeighted [] weights, bool [] isBinary) {
            ArrayList scoredSessions = new ArrayList();
            //get the weight value for each of the sessions.  Attach that via a new type.
            foreach (MatchSession session in matchSessions) {
                scoredSessions.Add(new SessionWithScore(session, GetDistance(session.GetAttribs(), weights, isBinary)));
            }
            //Run a sort on this new type.  Implement an IComparer for this.
            scoredSessions.Sort();
            //Take the top 50, if we need to.  We *could* take the top 50, but because we have to
            //check for dupes, don't clip.
/*
            if (scoredSessions.Count > Constants.X_MATCH_MAX_QUERY_RESULTS) {
                scoredSessions.RemoveRange((int) Constants.X_MATCH_MAX_QUERY_RESULTS, 
                                           (int) (scoredSessions.Count-Constants.X_MATCH_MAX_QUERY_RESULTS));
            }
*/
            return scoredSessions;
        }

        //Helper, to allow you to not specify the isBinary array if there is nothign weighted.
        public static ArrayList RunInternalWeightedSearch(ArrayList matchSessions, XRLXeAttribParamWeighted [] weights) {
            return RunInternalWeightedSearch(matchSessions,weights, InitArrayOfFalses(weights.Length));
        }


        //Overloading.  If there are no binary attributes, this lets you not specify any.
        public static ArrayList RunBoundingBoxWeightedSearch(ArrayList matchSessions, XRLXeAttribParamWeighted [] weights) {
            return RunBoundingBoxWeightedSearch(matchSessions, weights, InitArrayOfFalses(weights.Length));
        }

        //Overloading.  If there are binary attributes, but no additional filters, this puts those
        //in for you.
        public static ArrayList RunBoundingBoxWeightedSearch(ArrayList matchSessions, XRLXeAttribParamWeighted [] weights,
                                                             bool [] isBinary) {
            return RunBoundingBoxWeightedSearch(matchSessions, weights, isBinary, null);
        }

        //Given a set of weighted attributes and an ArrayList of all match sessions in the table,
        //grab the ones that the more optimized search will return.  Optimized searches create
        //filters of increasing size, until a satisfactory number(50) falls in the box.  An ordinary
        //weighted search is then run on the results and returned.
        public static ArrayList RunBoundingBoxWeightedSearch(ArrayList matchSessions, XRLXeAttribParamWeighted [] weights, 
                                                             bool [] isBinary, ArrayList addedFilters) {
            //extra debug info if this is true.
            bool DEBUG_BOUNDINGBOX = false;

            //these two constants define how fast we expand the search box.
            const double GROWTH_RATE = 1.4;
            int growthExponent = -10;
            //CHANGE:the starting growthExponent is dependent on the number of rows that pass the filters, and
            //the number of rows we want in the query.  This allows us to reduce iterations.
            int possibleSessions = 0;
            if (addedFilters != null) {
                possibleSessions = ApplyFilters(matchSessions, addedFilters).Count;
            } else {
                possibleSessions = matchSessions.Count;
            }
            if (possibleSessions < (Constants.X_MATCH_MAX_QUERY_RESULTS * 2.0)) {
                growthExponent = 0;
            }

            ArrayList filters = new ArrayList();
            ArrayList filteredSessions = new ArrayList();

            Global.RO.Info("Weights inputted:");
            foreach (XRLXeAttribParamWeighted weight in weights) {
                Global.RO.Info(weight.ToString());
            }
            while ((filteredSessions.Count < (Constants.X_MATCH_MAX_QUERY_RESULTS * 2)) && 
                   (growthExponent < 1)) {
                filters = new ArrayList();

                //add in the extra filters in the mix, if there are any.
                if (addedFilters != null) {
                    foreach (FilterAttrib extraFilter in addedFilters) {
                        filters.Add(extraFilter);
                    }
                }

                //create the target box.
                double multiplier = Math.Pow(GROWTH_RATE, growthExponent);
                Global.RO.Info("Running weighted search bounding box filters.  Current multiplier is " + 
                               GROWTH_RATE + "^" + growthExponent);
                foreach(XRLXeAttribParamWeighted attrib in weights) {
                    filters.Add(new FilterAttrib(new XRLXeAttribParam(attrib.attribParamID,
                                                                      attrib.aValue.GetNumericValue() + 
                                                                      (.5 * (1/attrib.weight) * multiplier)), 
                                                 false));
                    filters.Add(new FilterAttrib(new XRLXeAttribParam(attrib.attribParamID,
                                                                      attrib.aValue.GetNumericValue() - 
                                                                      (.5 * (1/attrib.weight) * multiplier)), 
                                                 true));
                }

                if (DEBUG_BOUNDINGBOX) {
                    foreach (FilterAttrib filter in filters) {
                        Global.RO.Info(filter.ToString());
                    }
                }
                //search for items in this box.  If they are < the max, then search again with the
                //increased growth exponent.
                filteredSessions = ApplyFilters(matchSessions, filters);
                Global.RO.Info("Found " + filteredSessions.Count + " sessions that pass filters.");
                growthExponent ++;
            }
            if (growthExponent >= 1) {
                Global.RO.Info("Note:Growth exponent capped at 100.  May not be a lot of matching results in the table.");
            }

            ArrayList scoredSessions = new ArrayList();
            //get the weight value for each of the sessions.  Attach that via a new type.
            foreach (MatchSession session in matchSessions) {
                scoredSessions.Add(new SessionWithScore(session, GetDistance(session.GetAttribs(), weights, isBinary)));
            }
            //Run a sort on this new type.  Implement an IComparer for this.
            scoredSessions.Sort();

            if (DEBUG_BOUNDINGBOX) {
                int count = 0;
                foreach(SessionWithScore scoredSession in scoredSessions) {
                    if (count > 100) break;
                    MatchSession session = scoredSession.session;
                    foreach (FilterAttrib filter in filters) {
                        if (!filter.PassesFilter(session)) {
                            Global.RO.Info("session" + session.GetSessionID() + " fails filter " + 
                                           filter.attrib.attribParamID.ToString("X") + ".  " + filter.ToString() + " Session value is " + session.GetNumericValueOfAttrib(filter.attrib.attribParamID));
                        }
                    }
                    count ++;
                }
            }
            //Once done, take these filtered results and run the weighting as normal.
            return (RunInternalWeightedSearch(filteredSessions, weights, isBinary));
        }

        public static float GetDistance(XRLXeAttribParam [] session, XRLXeAttribParamWeighted [] weights, 
                                        bool [] isBinary) {
            float distance = 0;
            for (int weightNum = 0; weightNum < weights.Length; weightNum++) {
                //find the corresponding attribute in the session.
                bool found = false;
                for (int i=0; i<session.Length; i++) {
                    if (session[i].attribParamID == weights[weightNum].attribParamID) {
                        if (isBinary[weightNum]) {
                            //for "binary" attributes, add the full distance if it doesn't match.
                            if (weights[weightNum].aValue.GetNumericValue() != session[i].aValue.GetNumericValue()) {
                                distance += weights[weightNum].weight;
                            } else {
                                //if they match, don't add any distance.
                            }
                        } else {
                            //for normal attributes, add the distance component.
                            distance += (float) (weights[weightNum].weight  * 
                                                 (Math.Pow(weights[weightNum].aValue.GetNumericValue() - session[i].aValue.GetNumericValue(), 2)));
                        }
                        found = true;
                    }
                }
                if (!found) {
                    Global.RO.Warn("Warning:A weight was specified(" + weights[weightNum].attribParamID.ToString("X") + 
                                   ") that was not found in the attrib list.");
                }
            }
//            distance = (float) Math.Sqrt(distance);  //don't sqrt--this is client-side.
            return distance;
        }

        //returns true if the two floats are close enough to each other.
        public static bool FloatCompare(float float1, float float2) {
            float diff = float1-float2;
            return (diff < .001f) && (diff > -.001f);
        }

        //make all scores a similar hash?
        //hash by score?  But they're not ints, which sucks.
        //hash by order?  Increment when you get a failed floatcompare.
        //wimp out and make a "get all sessions with this score" to compare with?
        //what about we take our data, and juts make sure each one matches the opposite.  And then
        //sort the actual and if the order changes at all, we complain?

        //Group together sessions by adding the order number.  But then how do we remember the
        //"beginning" of the group, so we can check all items of the group?  Unless we just look
        //through the whole list each time...
        public static void GroupSessions(ArrayList sessions) {
            float currentScore = -1;
            int currentOrderNum = 0;
            for(int i=0; i<sessions.Count; i++) {
                if (!FloatCompare(((SessionWithScore) sessions[i]).score, currentScore)) { //if greater, we
                                                                             //increment the group.
                    currentOrderNum++;
                    ((SessionWithScore)sessions[i]).orderNum = currentOrderNum;
                    currentScore = ((SessionWithScore)sessions[i]).score;
                } else {
                    //otherwise we use the same group.
                    ((SessionWithScore)sessions[i]).orderNum = currentOrderNum;                    
                }
            }
        }

        //compare sessionID for sessionID.  The expecteds are SessionWithScores.  Default to making
        //ties okay.
        public static bool CompareResults(XRL2SearchResults actual, ArrayList expected) {
            return CompareResults(actual, expected, true);
        }
        //compare sessionID for sessionID.  The expecteds are SessionWithScores.  If
        //makeScoreTiesOkay is false, then don't do any fancy subtitute checking.
        public static bool CompareResults(XRL2SearchResults actual, ArrayList expected, bool makeScoreTiesOkay) {
            bool allMatched = true;
            bool allWeightsFound = true;
            bool allWeightsMatched = true;
            if (actual == null) {
                if (expected.Count != 0) {
                    Global.RO.Error("No results returned, but was expecting " + expected.Count + " results!");
                    for (int i=0; i< expected.Count; i++) {
                        Global.RO.Error("Session result " + i + " is incorrect:  Expecting " + 
                                        ((SessionWithScore) expected[i]).session.GetSessionID());
                    }
                    return false;
                } else {
                    Global.RO.Success("No results returned, but none were expected.");
                    return true;
                }
            }
            GroupSessions(expected);
            
            for (int i=0; i< actual.results.Length; i++) {
                //grab expected score, since we'll use that in both.
                float expectedScore = ((SessionWithScore) expected[i]).score;

                //and grab actual score...
                XRLXeAttribParam actualScore = null;
                foreach (XRLXeAttribParam resultParam in actual.results[i].Attribs) {
                    if (resultParam.attribParamID == Constants.X_ATTRIBUTE_SESSION_SCORE) {
                        actualScore = resultParam;
                    }
                }

                if (makeScoreTiesOkay) {
                    //first attempt.  If there are other members of the group that match, we swap those in.
                    if (((SessionWithScore) expected[i]).session.GetSessionID() != 
                        SessionID.sessionIDConvert(actual.results[i].SessionID)) {
                        //check all members of this groupNum.  Skip over -2s in the orderNum.
                        SessionWithScore substitute = null;
                        int subIndex = -1;
                        for(int j=0; j<expected.Count; j++) {
                            SessionWithScore potentialSub = (SessionWithScore) expected[j];
                            if (potentialSub.orderNum == ((SessionWithScore) expected[i]).orderNum) {
                                long subSessionID = potentialSub.session.GetSessionID();
                                long targetSessionID = SessionID.sessionIDConvert(actual.results[i].SessionID);
                                if (subSessionID == targetSessionID) {
                                    substitute = potentialSub;
                                    subIndex = j;
                                }
                            }
                        }
                        if (substitute != null) {  //if the sub was found, trade places with the target,
                            //inside the expected array.
                            expected[subIndex] = expected[i];
                            expected[i] = substitute;
                        }
                    }
                }
                //second attempt to match.  
                if (((SessionWithScore) expected[i]).session.GetSessionID() != 
                    SessionID.sessionIDConvert(actual.results[i].SessionID)) {
                    allMatched = false;
                    string scoreString;
                    if (actualScore == null) {
                        scoreString = "no score returned!";
                    } else {
                        scoreString = ((XRLXeFloatValue) actualScore.aValue).fValue.ToString();
                    }
                    Global.RO.Error("Session result " + i + " is incorrect:  Expecting " + 
                                    ((SessionWithScore) expected[i]).session.GetSessionID() + 
                                    "(score:" + expectedScore + ", groupNum: " + 
                                    ((SessionWithScore) expected[i]).orderNum + ")" +
                                    ", but actually got " + new SessionID(actual.results[i].SessionID) + 
                                    "(score:" + scoreString + ")");
                        

                } else {
                    //we matched sessionID.  now check the score attribute,
                    //look for a match in actual
                    bool weightFound = false;
                    foreach (XRLXeAttribParam resultParam in actual.results[i].Attribs) {
                        if (resultParam.attribParamID == Constants.X_ATTRIBUTE_SESSION_SCORE) {
                            weightFound = true;
                            if (!FloatCompare( ((XRLXeFloatValue) resultParam.aValue).fValue, expectedScore)) {
                                Global.RO.Error("Session result " + i + " has incorrect weight:  Expecting " + 
                                                expectedScore + ", but actually got " +
                                                ((XRLXeFloatValue) resultParam.aValue).fValue);
                                allWeightsMatched = false;
                            } else {
                                Global.RO.Success("Session result " + i + " matches(sessionid:" +
                                                  SessionID.sessionIDConvert(actual.results[i].SessionID).ToString("X") + ",score:" + 
                                                  expectedScore + ")");
                            }
                            
                        }
                    }
                    if (!weightFound) {
                        allWeightsFound = false;
                        Global.RO.Error("Session result " + i + " has no weight attribute!");
                    }
                }
            }
            return allMatched && allWeightsFound && allWeightsMatched;
        }

        //positive
        [BVT]
        [TestCase, Description("Passes in a single weight, creates a basic set of data in the table, and verifies the results expected.")]
        public class P_Mainline : TestBase {
            override protected void Execute()
            {
                float maxValue = 20.0f;
                float scale = (float) (1.0 / maxValue);
                FillSessionMatrix(3, (int) maxValue, 3, true, SessionType.Ranked);
                XRLXeAttribParamWeighted[] weightedParamArray = new XRLXeAttribParamWeighted [3]{
                    new XRLXeAttribParamWeighted(Constants.PROPERTY_MYINT64PROP3, (float) 0.5 * scale, new XRLXeIntValue(0x1)),
                    new XRLXeAttribParamWeighted(Constants.PROPERTY_MYINT64PROP4, (float) 0.5 * scale, new XRLXeIntValue(0x1)),
                    new XRLXeAttribParamWeighted(Constants.PROPERTY_MYINT64PROP5, (float) 0.5 * scale, new XRLXeIntValue(0x1))
                };

                XRL2SearchSession searchReq = new XRL2SearchSession(true, weightedParamArray, Constants.SESSION_MATCH_QUERY_WEIGHTED_3INT64_WEIGHTS);

                XRL2SearchResults    Resp;
                if(searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out Resp))
                {
                    if (CompareResults(Resp, RunBoundingBoxWeightedSearch(rankedSessionData, weightedParamArray))) {
                        ResultCode=TEST_RESULTS.PASSED;                        
                    }
                }
            }
        }


        [TestCase, Description("Pass in a single weight, with no data in the table, and no results expected. This verifies the API signature reads and understands a request.")]
        public class P_API_Signature_Okay : TestBase {
            override protected void Execute()
            {
                XRLXeAttribParamWeighted[] weightedParamArray = new XRLXeAttribParamWeighted [1]{
                    new XRLXeAttribParamWeighted(Constants.PROPERTY_MYINT32PROP1, (float) 1.0, new XRLXeIntValue(0x1))
                };
                XRL2SearchSession searchReq = new XRL2SearchSession(true, weightedParamArray, Constants.SESSION_MATCH_QUERY_GENERAL_WEIGHTED_QUERY);

                XRL2SearchResults    Resp;
                if(searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out Resp))
                {
                    ResultCode=TEST_RESULTS.PASSED;
                }
            }
        }


        [TestCase, Description("Throw in a weight of zero.  Is that allowed?")]
        public class P_Weight_Of_Zero : TestBase {
            override protected void Execute()
            {
                XRLXeAttribParamWeighted[] weightedParamArray = new XRLXeAttribParamWeighted [2]{
                    new XRLXeAttribParamWeighted(Constants.PROPERTY_MYINT32PROP1, (float) 1.0, new XRLXeIntValue(0x1)),
                    new XRLXeAttribParamWeighted(Constants.PROPERTY_MYINT32PROP2, (float) 0.0, new XRLXeIntValue(0x1))
                };
                XRL2SearchSession searchReq = new XRL2SearchSession(true, weightedParamArray, Constants.SESSION_MATCH_QUERY_GENERAL_WEIGHTED_QUERY);

                XRL2SearchResults    Resp;
                if(searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out Resp))
                {
                    ResultCode=TEST_RESULTS.PASSED;
                }
            }
        }

        [TestCase, Description("Throw in the largest float.")]
        public class P_Max_Float : TestBase {
            override protected void Execute()
            {
                XRLXeAttribParamWeighted[] weightedParamArray = new XRLXeAttribParamWeighted [2]{
                    new XRLXeAttribParamWeighted(Constants.PROPERTY_MYFLOAT32PROP1, System.Single.MaxValue, new XRLXeFloatValue(System.Single.MaxValue)),
                    new XRLXeAttribParamWeighted(Constants.PROPERTY_MYINT32PROP2, (float) 0.0, new XRLXeIntValue(0x1))
                };
                XRL2SearchSession searchReq = new XRL2SearchSession(true, weightedParamArray, Constants.SESSION_MATCH_QUERY_WEIGHTED_FLOATS_INTS_DOUBLES);

                XRL2SearchResults    Resp;
                if(searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out Resp))
                {
                    ResultCode=TEST_RESULTS.PASSED;
                }
            }
        }

        [TestCase, Description("Throw in the smallest float.")]
        public class P_Min_Float : TestBase {
            override protected void Execute()
            {
                XRLXeAttribParamWeighted[] weightedParamArray = new XRLXeAttribParamWeighted [2]{
                    new XRLXeAttribParamWeighted(Constants.PROPERTY_MYFLOAT32PROP1, System.Single.MinValue, new XRLXeFloatValue(System.Single.MinValue)),
                    new XRLXeAttribParamWeighted(Constants.PROPERTY_MYINT32PROP2, (float) 0.0, new XRLXeIntValue(0x1))
                };
                XRL2SearchSession searchReq = new XRL2SearchSession(true, weightedParamArray, Constants.SESSION_MATCH_QUERY_WEIGHTED_FLOATS_INTS_DOUBLES);

                XRL2SearchResults    Resp;
                if(searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out Resp))
                {
                    ResultCode=TEST_RESULTS.PASSED;
                }
            }
        }


        [TestCase, Description("Throw in the smallest float.")]
        public class P_One_Minus_Min_Float : TestBase {
            override protected void Execute()
            {
                XRLXeAttribParamWeighted[] weightedParamArray = new XRLXeAttribParamWeighted [2]{
                    new XRLXeAttribParamWeighted(Constants.PROPERTY_MYFLOAT32PROP1, 1 - System.Single.MinValue, 
                                                 new XRLXeFloatValue(1 - System.Single.MinValue)),
                    new XRLXeAttribParamWeighted(Constants.PROPERTY_MYINT32PROP2, (float) 0.0, new XRLXeIntValue(0x1))
                };
                XRL2SearchSession searchReq = new XRL2SearchSession(true, weightedParamArray, Constants.SESSION_MATCH_QUERY_WEIGHTED_FLOATS_INTS_DOUBLES);

                XRL2SearchResults    Resp;
                if(searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out Resp))
                {
                    ResultCode=TEST_RESULTS.PASSED;
                }
            }
        }


        [TestCase, Description("Check if no weights given works.")]
        public class P_No_Weights : TestBase {
            override protected void Execute()
            {
                XRLXeAttribParamWeighted[] weightedParamArray = new XRLXeAttribParamWeighted [0]{
                };
                XRL2SearchSession searchReq = new XRL2SearchSession(true, weightedParamArray, Constants.SESSION_MATCH_QUERY_GENERAL_WEIGHTED_QUERY);

                XRL2SearchResults    Resp;
                if(searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out Resp))
                {
                    ResultCode=TEST_RESULTS.PASSED;
                }
            }
        }

        [TestCase, Description("Try a weighted search on a query that has no weighted params.")]
        public class P_Query_With_No_Weighted_Params_ie_Omaha_Invalid_Score_Cast : TestBase {

            override protected void Execute()
            {
                XRLXeAttribParamWeighted[] weightedParamArray = new XRLXeAttribParamWeighted [0]{
                };
                for (int i=0; i<10; i++) {
                    MatchSession temp = new MatchSession(false);
                    temp.TitleID = 0xffed94b2;
                    temp.Create();
                }
                
                XRL2SearchSession searchReq = new XRL2SearchSession(true, weightedParamArray, Constants.SESSION_MATCH_QUERY_QUERY1);

                XRL2SearchResults    Resp;
                if(searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out Resp))
                {
                    ResultCode=TEST_RESULTS.PASSED;
                } else {
                    Global.RO.Error("Search returns error:" + Global.XErrToString(searchReq.XErr));
                }
            }
        }

        [TestCase, Description("Try to cause rounding errors by passing in tiny tiny weights.")]
        public class P_Weights_Of_Small_Numbers : TestBase {
            override protected void Execute()
            {
                XRLXeAttribParamWeighted[] weightedParamArray = new XRLXeAttribParamWeighted [10]{
                    new XRLXeAttribParamWeighted(Constants.PROPERTY_MYINT32PROP1, (float) .05, new XRLXeIntValue(0x2)), 
                    new XRLXeAttribParamWeighted(Constants.PROPERTY_MYINT32PROP2, (float) .1, new XRLXeIntValue(0x4)),
                    new XRLXeAttribParamWeighted(Constants.PROPERTY_MYINT64PROP3, (float) .15, new XRLXeIntValue(0x6)),
                    new XRLXeAttribParamWeighted(Constants.PROPERTY_MYINT64PROP4, (float) .01, new XRLXeIntValue(0x8)),
                    new XRLXeAttribParamWeighted(Constants.PROPERTY_MYINT64PROP5, (float) .1, new XRLXeIntValue(0x1)),
                    new XRLXeAttribParamWeighted(Constants.PROPERTY_MYINT64PROP6, (float) .199999, new XRLXeIntValue(0x3)),
                    new XRLXeAttribParamWeighted(Constants.PROPERTY_MYINT64PROP7, (float) .000001, new XRLXeIntValue(0x5)),
                    new XRLXeAttribParamWeighted(Constants.PROPERTY_MYINT64PROP8, (float) .000000000000001, new XRLXeIntValue(0x9)),
                    new XRLXeAttribParamWeighted(Constants.PROPERTY_MYINT64PROP9, (float) .299999999999998, new XRLXeIntValue(0xB)),
                    new XRLXeAttribParamWeighted(Constants.PROPERTY_MYINT64PROP10, (float).000000000000001, new XRLXeIntValue(0xD)),
                };
                XRL2SearchSession searchReq = new XRL2SearchSession(true, weightedParamArray, Constants.SESSION_MATCH_QUERY_GENERAL_WEIGHTED_QUERY);

                XRL2SearchResults    Resp;
                if(searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out Resp))
                {
                    ResultCode=TEST_RESULTS.PASSED;
                }
            }
        }

        [TestCase, Description("Mainline Weighted Search case, with floats and ints in the weighted array.")]
        public class P_Floats_and_Ints : TestBase {
            override protected void Execute()
            {
                XRLXeAttribParamWeighted[] weightedParamArray = new XRLXeAttribParamWeighted [2]{
                    new XRLXeAttribParamWeighted(Constants.PROPERTY_MYFLOAT64PROP1, (float) 0.2, new XRLXeFloatValue(0x1)),
                    new XRLXeAttribParamWeighted(Constants.PROPERTY_MYINT64PROP3, (float) 0.8, new XRLXeIntValue(0x1))
                };
                XRL2SearchSession searchReq = new XRL2SearchSession(true, weightedParamArray, Constants.SESSION_MATCH_QUERY_WEIGHTED_FLOATS_INTS);

                XRL2SearchResults    Resp;
                if(searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out Resp))
                {
                    ResultCode=TEST_RESULTS.PASSED;
                }
            }
        }

        [TestCase, Description("Run an existing search test using the old schema version.  This is a copy of the ranked search mainline case(no data verification).")]
        public class P_Old_Schema_Version : TestBase {
            override protected void Execute()
            {
                XRL2SearchSession   searchReq = new XRL2SearchSession(false,Constants.SESSION_MATCH_QUERY_NOPARAMQUERY);
                XRLXeAttribParam	[] searchParams = new XRLXeAttribParam[2];
                searchReq.SetSchemaVersion(4,3);  //here's the important part for us.  Also make
                                                  //sure this is called before the addparams,
                                                  //because it affects the size calculation.

                searchParams[0] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_TYPE, new XRLXeIntValue(Constants.X_ATTRIBUTE_GAME_TYPE_STANDARD));
                searchParams[1] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE, new XRLXeIntValue(Constants.CONTEXT_GAME_MODE_MODEA));

                searchReq.AddParams(searchParams);
                XRL2SearchResults	searchResp;
                if(searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out searchResp)) {
                    ResultCode=TEST_RESULTS.PASSED;			
                } else {
                    Global.RO.Error("Search failed--Check event viewer of the match FD for details.");
                }
            }
        }        

        [TestCase, Description("Run an existing search test and add weights, but ensure the flag to use the weighted items is off.  This should fail.")]
        public class N_Old_Test_With_Weights_And_No_Flag : TestBase {
            override protected void Execute()
            {
                XRLXeAttribParamWeighted[] weightedParamArray = new XRLXeAttribParamWeighted [1]{
                    new XRLXeAttribParamWeighted(Constants.PROPERTY_MYINT32PROP1, (float) 1.0, new XRLXeIntValue(0x1))
                };
                XRL2SearchSession searchReq = new XRL2SearchSession(true, weightedParamArray, Constants.SESSION_MATCH_QUERY_GENERAL_WEIGHTED_QUERY);
                searchReq.SetWeightedFlag(false);  //this one's the important part.
                if (SearchTestNegative(searchReq, 0x80155119)) { //XONLINE_E_MATCH_INVALID_PARAM
                    ResultCode=TEST_RESULTS.PASSED;                        
                }
            }
        }        


        //negative        

        //The following three tests are ignored, because validation is done on the client side.  The
        //goal of these tests was to ensure that these situations do not cause a crash, or something similar.
        [TestCase, Ignore, Description("See if you have a number of weights that don't add up to 1.")]
        public class N_Weights_Dont_Sum_To_1 : TestBase {
            override protected void Execute()
            {
                XRLXeAttribParamWeighted[] weightedParamArray = new XRLXeAttribParamWeighted [5]{
                    new XRLXeAttribParamWeighted(Constants.PROPERTY_MYINT32PROP1, (float) 0.1, new XRLXeIntValue(0x1)),
                    new XRLXeAttribParamWeighted(Constants.PROPERTY_MYINT32PROP2, (float) 0.2, new XRLXeIntValue(0x1)),
                    new XRLXeAttribParamWeighted(Constants.PROPERTY_MYINT64PROP3, (float) 0.3, new XRLXeIntValue(0x1)),
                    new XRLXeAttribParamWeighted(Constants.PROPERTY_MYINT64PROP4, (float) 0.4, new XRLXeIntValue(0x1)),
                    new XRLXeAttribParamWeighted(Constants.PROPERTY_MYINT64PROP5, (float) 0.01, new XRLXeIntValue(0x1))
                };
                XRL2SearchSession searchReq = new XRL2SearchSession(true, weightedParamArray, Constants.SESSION_MATCH_QUERY_GENERAL_WEIGHTED_QUERY);

                Global.RO.Info("Need the correct error code for this.  Test will fail until then.");
                if (SearchTestNegative(searchReq, 0x0)) {
                    ResultCode=TEST_RESULTS.PASSED;                        
                }
            }
        }

        [TestCase, Ignore, Description("A weight larger than one in the list.")]
        public class N_Weight_Greater_Than_One : TestBase {
            override protected void Execute()
            {
                XRLXeAttribParamWeighted[] weightedParamArray = new XRLXeAttribParamWeighted [5]{
                    new XRLXeAttribParamWeighted(Constants.PROPERTY_MYINT64PROP3, (float) 0.1, new XRLXeIntValue(0x1)),
                    new XRLXeAttribParamWeighted(Constants.PROPERTY_MYINT64PROP4, (float) 0.2, new XRLXeIntValue(0x1)),
                    new XRLXeAttribParamWeighted(Constants.PROPERTY_MYINT64PROP5, (float) 20.1, new XRLXeIntValue(0x1)),
                    new XRLXeAttribParamWeighted(Constants.PROPERTY_MYINT64PROP6, (float) 0.4, new XRLXeIntValue(0x1)),
                    new XRLXeAttribParamWeighted(Constants.PROPERTY_MYINT64PROP7, (float) 0.01, new XRLXeIntValue(0x1))
                };
                XRL2SearchSession searchReq = new XRL2SearchSession(true, weightedParamArray, Constants.SESSION_MATCH_QUERY_GENERAL_WEIGHTED_QUERY);

                Global.RO.Info("Need the correct error code for this.  Test will fail until then.");
                if (SearchTestNegative(searchReq, 0x0)) {
                    ResultCode=TEST_RESULTS.PASSED;                        
                }
            }
        }

        [TestCase, Ignore, Description("One of the weights is negative")]
        public class N_Weight_Is_Negative : TestBase {
            override protected void Execute()
            {
                XRLXeAttribParamWeighted[] weightedParamArray = new XRLXeAttribParamWeighted [1]{
                    new XRLXeAttribParamWeighted(Constants.PROPERTY_MYINT64PROP4, (float) -0.4, new XRLXeIntValue(0x1))
                };
                XRL2SearchSession searchReq = new XRL2SearchSession(true, weightedParamArray, Constants.SESSION_MATCH_QUERY_GENERAL_WEIGHTED_QUERY);

                Global.RO.Info("Need the correct error code for this.  Test will fail until then.");
                if (SearchTestNegative(searchReq, 0x0)) {
                    ResultCode=TEST_RESULTS.PASSED;                        
                }
            }
        }

        [TestCase, Description("Attempt to use a datetime property for weight.  A legal query of this type can't be propped," + 
                               " so this is more like trying to search with a weighted attribute that isn't part of the query.")]
        public class N_Weight_On_Attribute_Missing_From_Query : TestBase {
            override protected void Execute()
            {
                XRLXeAttribParamWeighted[] weightedParamArray = new XRLXeAttribParamWeighted [1]{
                    new XRLXeAttribParamWeighted(Constants.PROPERTY_MYDATETIMEPROP1, (float) 1.0, new XRLXeDateTimeValue(12341234))//dummy value
                };
                XRL2SearchSession searchReq = new XRL2SearchSession(true, weightedParamArray, Constants.SESSION_MATCH_QUERY_FUZZYMATCHDATETIME);

                Global.RO.Info("Need the correct error code for this.  Test will fail until then.");
                if (SearchTestNegative(searchReq, 0x80155119)) {//XONLINE_E_MATCH_INVALID_PARAM
                    ResultCode=TEST_RESULTS.PASSED;                        
                }
            }
        }


        [TestCase, Description("Weights in the array is greater than the maximum allowed.")]
        public class N_Exceed_Weighted_Attrib_Limit : TestBase {
            override protected void Execute()
            {
                XRLXeAttribParamWeighted[] weightedParamArray = new XRLXeAttribParamWeighted [21];
                for (int i=0; i<21; i++) {
                    weightedParamArray[i] = new XRLXeAttribParamWeighted((uint) (Constants.PROPERTY_MYINT64PROP3 + i), 
                                                                         (float) 0.05, new XRLXeFloatValue(0x1));
                }
                XRL2SearchSession searchReq = new XRL2SearchSession(true, weightedParamArray, Constants.SESSION_MATCH_QUERY_GENERAL_WEIGHTED_QUERY);

                if (SearchTestNegative(searchReq, 0x80155124)) { //XONLINE_E_MATCH_TOO_MANY_PARAM
                    ResultCode=TEST_RESULTS.PASSED;                        
                }
            }
        }

        [TestCase, Description("Weights in the array combined with non-weighted params is greater than the maximum. This limit exceeds what" +
                                       "is defined by the query")]
        public class N_Exceed_Combined_Attrib_Limit : TestBase {
            override protected void Execute()
            {
                XRLXeAttribParamWeighted[] weightedParamArray = new XRLXeAttribParamWeighted [20];
                for (int i=0; i<20; i++) {
                    weightedParamArray[i] = new XRLXeAttribParamWeighted((uint) (Constants.PROPERTY_MYINT64PROP3 + i), 
                                                                         (float) 0.05, new XRLXeIntValue(0x1));
                }

                //exceed the 62 total. 20+33+10 = 63.
                XRLXeAttribParam[] additionalParamArray = new XRLXeAttribParam [33];
                for (int i=0; i<33; i++) {
                    additionalParamArray[i] = new XRLXeAttribParam((uint) (Constants.PROPERTY_MYINT64PROP24 + i), 
                                                                   new XRLXeIntValue(0x1));
                }
                XRL2SearchSession searchReq = new XRL2SearchSession(true, weightedParamArray, Constants.SESSION_MATCH_QUERY_GENERAL_WEIGHTED_QUERY);
                searchReq.AddParams(additionalParamArray);
                searchReq.RecalculateOffsets();

                if (SearchTestNegative(searchReq, 0x80155124)) { //XONLINE_E_MATCH_TOO_MANY_PARAM
                    ResultCode=TEST_RESULTS.PASSED;                        
                }
            }
        }


        [TestCase, Description("Duplicates in the weighted array.")]
        public class N_Dupe : TestBase {
            override protected void Execute()
            {
                XRLXeAttribParamWeighted[] weightedParamArray = new XRLXeAttribParamWeighted [2]{
                    new XRLXeAttribParamWeighted(Constants.PROPERTY_MYFLOAT64PROP1, (float) 0.2, new XRLXeFloatValue(0x1)),
                    new XRLXeAttribParamWeighted(Constants.PROPERTY_MYFLOAT64PROP1, (float) 0.8, new XRLXeFloatValue(0x1))
                };
                XRL2SearchSession searchReq = new XRL2SearchSession(true, weightedParamArray, Constants.SESSION_MATCH_QUERY_WEIGHTED_FLOATS_INTS);

                if (SearchTestNegative(searchReq, 0x80155125)) { //XONLINE_E_MATCH_DUPLICATE_PARAM
                    ResultCode=TEST_RESULTS.PASSED;                        
                }
            }
        }

        [TestCase, Description("Something passed as a parameter in botht the weighted array and the non-weighted array.")]
        public class N_Dupe_Across_Lists : TestBase {
            override protected void Execute()
            {
                XRLXeAttribParamWeighted[] weightedParamArray = new XRLXeAttribParamWeighted [1]{
                    new XRLXeAttribParamWeighted(Constants.PROPERTY_MYFLOAT64PROP1, (float) 1.0, new XRLXeFloatValue(0x1)),
                };
                XRL2SearchSession searchReq = new XRL2SearchSession(true, weightedParamArray, Constants.SESSION_MATCH_QUERY_WEIGHTED_FLOATS_INTS);
                XRLXeAttribParam [] normalArray = new XRLXeAttribParam[1] {
                    new XRLXeAttribParam(Constants.PROPERTY_MYFLOAT64PROP1, new XRLXeFloatValue(0x1))
                };
                searchReq.AddParams(normalArray);
                searchReq.RecalculateOffsets();
                
                if (SearchTestNegative(searchReq, 0x80155125)) { //XONLINE_E_MATCH_DUPLICATE_PARAM
                    ResultCode=TEST_RESULTS.PASSED;                        
                } 
            }
        }

        [TestCase, Description("Send a request on the new schema, which contains weights, but send the old X-Schema-Ver number(4.3). This should fail with an IIS error(the server will not respond with a 200.).")]
        public class P_Invalid_Schema_Version : TestBase {
            override protected void Execute()
            {
                XRLXeAttribParamWeighted[] weightedParamArray = new XRLXeAttribParamWeighted [1]{
                    new XRLXeAttribParamWeighted(Constants.PROPERTY_MYINT32PROP1, (float) 1.0, new XRLXeIntValue(0x1))
                };
                XRL2SearchSession searchReq = new XRL2SearchSession(true, weightedParamArray, Constants.SESSION_MATCH_QUERY_GENERAL_WEIGHTED_QUERY);
                searchReq.spoofSchemaVersionNumber = WireData.MakeSchemaVersion(4,3);
                XRL2SearchResults    Resp;
                if(searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out Resp))
                {
                    ResultCode=TEST_RESULTS.PASSED;
                } else {
//                    Global.RO.Error("Expected request to fail completely, but got success with XErr = " + Global.XErrToString(searchReq.XErr));
                }
            }
        }        

        [TestCase, Description("Send a request on the old schema, but send the new X-Scema-Ver(5.1). This should also fail with an IIS error.")]
        public class N_Old_Schema_With_New_Version : TestBase {
            override protected void Execute()
            {
                XRL2SearchSession   searchReq = new XRL2SearchSession(false,Constants.SESSION_MATCH_QUERY_NOPARAMQUERY);
                XRLXeAttribParam	[] searchParams = new XRLXeAttribParam[2];
                searchParams[0] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_TYPE, new XRLXeIntValue(Constants.X_ATTRIBUTE_GAME_TYPE_STANDARD));
                searchParams[1] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE, new XRLXeIntValue(Constants.CONTEXT_GAME_MODE_MODEA));
                searchReq.AddParams(searchParams);

                searchReq.SetSchemaVersion(4,3);  //here's the important part for us.
                searchReq.spoofSchemaVersionNumber = WireData.MakeSchemaVersion(5,3); //let's say we're 5.1
                                                                             //but act like 4.3
                XRL2SearchResults	searchResp;
                if(!searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out searchResp)) {
                    ResultCode=TEST_RESULTS.PASSED;			
                } else {
                    Global.RO.Error("Expected request to fail completely, but got success with XErr = " + Global.XErrToString(searchReq.XErr));
                }

            }
        }        

        [TestCase, Description("Cycle through each of the system attributes. For each of these, create a search with a single weight. Searches with the attributes of Type(0x0000800A), Mode(0x0000800B), and Gamertag(0x40108109) should be disallowed.")]
        public class N_System_Attributes : TestBase {
            private uint[] systemAttribList = new uint [10]{
                Constants.X_ATTRIBUTE_GAME_TYPE,
                Constants.X_ATTRIBUTE_GAME_MODE,
                Constants.X_ATTRIBUTE_GAMER_ZONE,
                Constants.X_ATTRIBUTE_GAMER_COUNTRY,
                Constants.X_ATTRIBUTE_GAMER_LANGUAGE,
                Constants.X_ATTRIBUTE_GAMER_RATING,
                Constants.X_ATTRIBUTE_GAMER_MU,
                Constants.X_ATTRIBUTE_GAMER_SIGMA,
                Constants.X_ATTRIBUTE_GAMER_PUID,
                Constants.X_ATTRIBUTE_HOST_NAME
            };
            
            private uint[] disallowedAttribList = new uint [4]{
                Constants.X_ATTRIBUTE_GAME_TYPE,
                Constants.X_ATTRIBUTE_GAME_MODE,
                Constants.X_ATTRIBUTE_GAMER_PUID,
                Constants.X_ATTRIBUTE_HOST_NAME
            };

            private bool IsContained(uint itemToFind, uint[] toSearchThrough) {
                foreach (uint item in toSearchThrough) {
                    if (itemToFind == item) {
                        return true;
                    }
                }
                return false;
            }

            override protected void Execute()
            {
                bool allPassed = true;
                foreach (uint attribID in systemAttribList) {
                    XRLXeAttribParamWeighted testParam;
                    if (attribID == Constants.X_ATTRIBUTE_HOST_NAME) {
                        testParam = new XRLXeAttribParamWeighted(attribID, (float) 1.0, new XRLXeStringValue("TestGamerTag"));
                    } else if (attribID == Constants.X_ATTRIBUTE_GAMER_RATING) {
                        testParam = new XRLXeAttribParamWeighted(attribID, (float) 1.0, new XRLXeFloatValue(1.0f));
                    } else {
                        testParam = new XRLXeAttribParamWeighted(attribID, (float) 1.0, new XRLXeIntValue(0x1));
                    }

                    XRLXeAttribParamWeighted[] weightedParamArray = new XRLXeAttribParamWeighted [1] {testParam};

                    XRL2SearchSession searchReq = new XRL2SearchSession(true, weightedParamArray, 
                                                                        Constants.SESSION_MATCH_QUERY_GENERAL_WEIGHTED_QUERY);
                    searchReq.RemoveParam(attribID);
                    XRL2SearchResults    Resp;
                    if (IsContained(attribID, disallowedAttribList)) {
                        if(SearchTestNegative(searchReq, 0x80155119)) { //XONLINE_E_MATCH_INVALID_PARAM
                            Global.RO.Success("System Attribute " + attribID.ToString("X") + " was rejected successfully with correct error code.");
                        } else {
                            Global.RO.Error("System Attribute " + attribID.ToString("X") + " was not rejected successfully!");
                            allPassed = false;
                        }
                    } else {
                        if(searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out Resp))
                        {
                            Global.RO.Success("System Attribute " + attribID.ToString("X") + " was accepted successfully.");
                        } else {
                            Global.RO.Error("System Attribute " + attribID.ToString("X") + " was not accepted successfully!  Received " + 
                                            Global.XErrToString(searchReq.XErr));
                            allPassed = false;
                        }
                    }
                }
                if (allPassed) {
                    ResultCode=TEST_RESULTS.PASSED;
                }
            }
        }        


        [TestCase, Description("Modify the XLAST to create a query that does not use weighted attributes. Pass in a weighted attribute when calling"
                               + " this query. ")]
        public class N_Search_With_Weights_But_Not_In_XLAST : TestBase {
            override protected void Execute()
            {
                XRLXeAttribParamWeighted[] weightedParamArray = new XRLXeAttribParamWeighted [1]{
                    new XRLXeAttribParamWeighted(Constants.PROPERTY_MYINT32PROP1, (float) 1.0, new XRLXeIntValue(0x1)),
                };
                XRL2SearchSession searchReq = new XRL2SearchSession(true, weightedParamArray, Constants.SESSION_MATCH_QUERY_QUERY1);

                if (SearchTestNegative(searchReq, 0x80155119)) {//XONLINE_E_MATCH_INVALID_PARAM
                    ResultCode=TEST_RESULTS.PASSED;                        
                } 
            }
        }        

//  Functional/mathematical tests


        [TestCase, Ignore, Description("Test the test code.")]
        public class P_DEBUG_FillMatrix : TestBase {
            override protected void Execute()
            {
                if (rankedSessionData == null) {
                    FillSessionMatrix(3, 200, 4, true, SessionType.Ranked);
                }
                XRLXeAttribParamWeighted[] weightedParamArray = new XRLXeAttribParamWeighted [3]{
                    new XRLXeAttribParamWeighted(Constants.PROPERTY_MYINT64PROP3, (float) 0.5, new XRLXeIntValue(1)),
                    new XRLXeAttribParamWeighted(Constants.PROPERTY_MYINT64PROP4, (float) 0.25, new XRLXeIntValue(0)),
                    new XRLXeAttribParamWeighted(Constants.PROPERTY_MYINT64PROP5, (float) 0.125, new XRLXeIntValue(2)),
                };

                ArrayList sortedResults = RunInternalWeightedSearch(rankedSessionData, weightedParamArray);
                for (int i=0; i<sortedResults.Count; i++) {
                    SessionWithScore scoredSess = (SessionWithScore) sortedResults[i];
                    Global.RO.Info("result " + i + ": ID:" + scoredSess.session.GetSessionID() + " atts:" + scoredSess.GetScoredAttribs(weightedParamArray) + 
                                   " score:" + scoredSess.score);
                }

                sortedResults = RunBoundingBoxWeightedSearch(rankedSessionData, weightedParamArray);
                for (int i=0; i<sortedResults.Count; i++) {
                    SessionWithScore scoredSess = (SessionWithScore) sortedResults[i];
                    Global.RO.Info("result " + i + ": ID:" + scoredSess.session.GetSessionID() + " atts:" + scoredSess.GetScoredAttribs(weightedParamArray) + 
                                   " score:" + scoredSess.score);
                }


            }
        }


        [TestCase, Description("Create a regular distribution of sessions, with three possible values and four attributes. Create a search that weights the four attributes in descending order(0.4, 0.3, 0.2, 0.1). Verify the sessions returned are expected and in the right order.")]
        public class P_Functional_Mainline : TestBase {
            override protected void Execute()
            {
                FillSessionMatrix(8, 200, 4, true, SessionType.Ranked);
                XRLXeAttribParamWeighted[] weightedParamArray = new XRLXeAttribParamWeighted [4]{
                    new XRLXeAttribParamWeighted(Constants.PROPERTY_MYINT64PROP3, (float) (0.4 / 200.0), 
                                                 new XRLXeIntValue(20)),
                    new XRLXeAttribParamWeighted(Constants.PROPERTY_MYINT64PROP4, (float) (0.3 / 200.0),
                                                 new XRLXeIntValue(72)),
                    new XRLXeAttribParamWeighted(Constants.PROPERTY_MYINT64PROP5, (float) (0.2 / 200.0), 
                                                 new XRLXeIntValue(41)),
                    new XRLXeAttribParamWeighted(Constants.PROPERTY_MYINT64PROP6, (float) (0.1 / 200.0), 
                                                 new XRLXeIntValue(152)),
                };
                bool [] isBinary = InitArrayOfFalses(weightedParamArray.Length);

                ArrayList sortedResults = RunBoundingBoxWeightedSearch(rankedSessionData, weightedParamArray);

                XRL2SearchSession searchReq = new XRL2SearchSession(true, weightedParamArray, Constants.SESSION_MATCH_QUERY_GENERAL_WEIGHTED_QUERY);
                XRL2SearchResults    Resp;
                if(searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out Resp))
                {
                    if (CompareResults(Resp, sortedResults)) {
                        ResultCode=TEST_RESULTS.PASSED;                        
                    }
                }

            }
        }

        [TestCase, Description("Modify the xlast to create a search, which contains two doubles, two floats, and two ints. Create a search that weights the attributes. Verify the sessions returned are expected, and in the right order.(this verifies that floats are not rounded)")]
        public class P_Functional_Doubles_Floats_And_Ints : TestBase {
                XRLXeAttribParam[] sessionTemplate = new XRLXeAttribParam [6]{
                    new XRLXeAttribParam(Constants.PROPERTY_MYFLOAT64PROP1, new XRLXeDoubleValue(7.2341)),
                    new XRLXeAttribParam(Constants.PROPERTY_MYFLOAT64PROP2, new XRLXeDoubleValue(18.502)),
                    new XRLXeAttribParam(Constants.PROPERTY_MYFLOAT32PROP1, new XRLXeFloatValue((float) 2.1)),
                    new XRLXeAttribParam(Constants.PROPERTY_MYFLOAT32PROP2, new XRLXeFloatValue((float) 10.001)),
                    new XRLXeAttribParam(Constants.PROPERTY_MYINT32PROP1, new XRLXeIntValue(50)),
                    new XRLXeAttribParam(Constants.PROPERTY_MYINT32PROP2, new XRLXeIntValue(100)),
                };
            override protected void Execute()
            {
//                FillSessionMatrix(10, 20, 4, true, SessionType.Ranked); //oops.  This doesn't do floats.
                FillSessionRandom(sessionTemplate, 5000, SessionType.Ranked);
                XRLXeAttribParamWeighted[] weightedParamArray = new XRLXeAttribParamWeighted [6]{
                    new XRLXeAttribParamWeighted(Constants.PROPERTY_MYFLOAT64PROP1, (float) (0.3 / 7.2341), 
                                                 new XRLXeDoubleValue(7.2341)),
                    new XRLXeAttribParamWeighted(Constants.PROPERTY_MYFLOAT64PROP2, (float) (0.2 / 18.502), 
                                                 new XRLXeDoubleValue(18.502)),
                    new XRLXeAttribParamWeighted(Constants.PROPERTY_MYFLOAT32PROP1, (float) (0.1 / 2.1), 
                                                 new XRLXeFloatValue((float) 2.1)),
                    new XRLXeAttribParamWeighted(Constants.PROPERTY_MYFLOAT32PROP2, (float) (0.2 / 10.001), 
                                                 new XRLXeFloatValue((float) 10.001)),
                    new XRLXeAttribParamWeighted(Constants.PROPERTY_MYINT32PROP1, (float) (0.2 / 50.0), 
                                                 new XRLXeIntValue(50)),
                    new XRLXeAttribParamWeighted(Constants.PROPERTY_MYINT32PROP2, (float) (0.1 / 100), 
                                                 new XRLXeIntValue(100)),
                };
                bool [] isBinary = InitArrayOfFalses(weightedParamArray.Length);

                ArrayList sortedResults = RunBoundingBoxWeightedSearch(rankedSessionData, weightedParamArray);

                XRL2SearchSession searchReq = new XRL2SearchSession(true, weightedParamArray, Constants.SESSION_MATCH_QUERY_WEIGHTED_FLOATS_INTS_DOUBLES);
                XRL2SearchResults    Resp;
                if(searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out Resp))
                {
                    if (CompareResults(Resp, sortedResults)) {
                        ResultCode=TEST_RESULTS.PASSED;                        
                    }
                } else {
                    Global.RO.Error("Search request fails!  Error code " + Global.XErrToString(searchReq.XErr));
                }
                
            }
        }

        [TestCase, Description("Modify the xlast to create a search, which contains two binary attributes and two non-binary attributes. Binary attributes give their full weight if the parameter does not match the attribute, and is intended for attributes like language/country. Verify the scores and sorting are as expected.")]
        public class P_Binary_Attributes : TestBase {
            override protected void Execute()
            {
                FillSessionMatrix(4, 8, 4, true, SessionType.Ranked);
                XRLXeAttribParamWeighted[] weightedParamArray = new XRLXeAttribParamWeighted [4]{
                    new XRLXeAttribParamWeighted(Constants.PROPERTY_MYINT64PROP3, (float) (0.4 / 8.0), new XRLXeIntValue(2)),
                    new XRLXeAttribParamWeighted(Constants.PROPERTY_MYINT64PROP4, (float) (0.39 / 8.0), new XRLXeIntValue(4)),
                    new XRLXeAttribParamWeighted(Constants.PROPERTY_MYINT64PROP5, (float) 0.005, new XRLXeIntValue(6)),
                    new XRLXeAttribParamWeighted(Constants.PROPERTY_MYINT64PROP6, (float) 0.005, new XRLXeIntValue(7)),
                };
                bool [] isBinary = InitArrayOfFalses(weightedParamArray.Length);
                isBinary[2] = true;  //set the last two to true.
                isBinary[3] = true;

                ArrayList sortedResults = RunBoundingBoxWeightedSearch(rankedSessionData, weightedParamArray, isBinary);

                XRL2SearchSession searchReq = new XRL2SearchSession(true, weightedParamArray, Constants.SESSION_MATCH_QUERY_WEIGHTED_INTS_BINARY);
                XRL2SearchResults    Resp;
                if(searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out Resp))
                {
                    if (CompareResults(Resp, sortedResults)) {
                        ResultCode=TEST_RESULTS.PASSED;                        
                    }
                } else {
                    Global.RO.Error("Search request fails!  Error code " + Global.XErrToString(searchReq.XErr));
                }
            }
        }

        //Binary Search Use Case.
        [TestCase, Description("Powers of two weighting.")]
        public class P_Powers_Of_Two_Use_Case : TestBase {
            //what should be put into the sessions
            XRLXeAttribParam[] sessionTemplate= new XRLXeAttribParam [8]{
                new XRLXeAttribParam(Constants.PROPERTY_MYINT32PROP1, new XRLXeIntValue(0x2)),
                new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP3, new XRLXeIntValue(0x2)),
                new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP4, new XRLXeIntValue(0x2)),
                new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP5, new XRLXeIntValue(0x2)),
                new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP6, new XRLXeIntValue(0x2)),
                new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP7, new XRLXeIntValue(0x2)),
                new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP8, new XRLXeIntValue(0x2)),
                new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP9, new XRLXeIntValue(0x2)),
                //solve the MU is in twice problem on create by just auto-generating mus of up to
                //4.0.  It's a hack for now.
//                new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_MU, new XRLXeFloatValue((float) 4.0)) //this
                                                                                                       //is
                                                                                                       //in twice!
            };


            //a clone of the existing ones, without MU, so we can pass that in the weighted side instead.
            XRLXeAttribParam []	defaultSearchParams = new XRLXeAttribParam[9] {
                new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_TYPE,new XRLXeIntValue(Constants.X_ATTRIBUTE_GAME_TYPE_RANKED)),
                new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE, new XRLXeIntValue(Constants.CONTEXT_GAME_MODE_MODEA)),
                new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_ZONE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_ZONE)),
                new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_COUNTRY, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_COUNTRY)),
                new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_LANGUAGE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_LANG)),
                new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_RATING, new XRLXeFloatValue(Constants.XENON_TEST_DEFAULT_GAMER_RATING)),
                new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_SIGMA, new XRLXeDoubleValue(Constants.XENON_TEST_DEFAULT_GAMER_SIGMA)),
                new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_PUID, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_PUID)),
                new XRLXeAttribParam(Constants.X_ATTRIBUTE_HOST_NAME, new XRLXeStringValue("newmom\0"))
            };

            override protected void Execute()
            {
                RandomEx randGen = new RandomEx();
                FillSessionRandom(sessionTemplate, 1000, SessionType.Ranked);
                XRLXeAttribParamWeighted[] weightedParamArray = new XRLXeAttribParamWeighted [9]{
                    new XRLXeAttribParamWeighted(Constants.PROPERTY_MYINT32PROP1, (float) 0.5, new XRLXeIntValue(0x1)),
                    new XRLXeAttribParamWeighted(Constants.PROPERTY_MYINT64PROP3, (float) 0.25, new XRLXeIntValue(0x1)),
                    new XRLXeAttribParamWeighted(Constants.PROPERTY_MYINT64PROP4, (float) 0.125, new XRLXeIntValue(0x1)),
                    new XRLXeAttribParamWeighted(Constants.PROPERTY_MYINT64PROP5, (float) 0.0625, new XRLXeIntValue(0x1)),
                    new XRLXeAttribParamWeighted(Constants.PROPERTY_MYINT64PROP6, (float) 0.03125, new XRLXeIntValue(0x1)),
                    new XRLXeAttribParamWeighted(Constants.PROPERTY_MYINT64PROP7, (float) 0.015625, new XRLXeIntValue(0x1)),
                    new XRLXeAttribParamWeighted(Constants.PROPERTY_MYINT64PROP8, (float) 0.0078125, new XRLXeIntValue(0x1)),
                    new XRLXeAttribParamWeighted(Constants.PROPERTY_MYINT64PROP9, (float) 0.00390625, new XRLXeIntValue(0x1)),
                    new XRLXeAttribParamWeighted(Constants.X_ATTRIBUTE_GAMER_MU, (float) 0.00390625, new XRLXeDoubleValue(2.0))
                };
                ArrayList sortedResults = RunBoundingBoxWeightedSearch(rankedSessionData, weightedParamArray);

                XRL2SearchSession searchReq = new XRL2SearchSession(defaultSearchParams, weightedParamArray, 
                                                                    Constants.SESSION_MATCH_QUERY_GENERAL_WEIGHTED_QUERY);
                XRL2SearchResults    Resp;
                if(searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out Resp))
                {
                    if (CompareResults(Resp, sortedResults)) {
                        ResultCode=TEST_RESULTS.PASSED;
                    }
                } else {
                    Global.RO.Error("Search request fails!  Error code " + Global.XErrToString(searchReq.XErr));
                }

            }
        }

        [TestCase, Description("Modify the xlast to create a query that best mimics what we expect the Omaha query to look like. In this case it would be 50 attributes, of which forty would have filters as usual, and ten will have weigths.")]
        public class P_Omaha_Use_Case : TestBase {
            //The following is the mapping of attribs:
/*
                //system defined
                new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_TYPE,new XRLXeIntValue(Constants.X_ATTRIBUTE_GAME_TYPE_RANKED)),
                new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE, new XRLXeIntValue(Constants.CONTEXT_GAME_MODE_MODEA)), //hopper-id
                new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_ZONE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_ZONE)),
                new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_COUNTRY, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_COUNTRY)), //locality
                new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_LANGUAGE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_LANG)), //language
                new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_RATING, new XRLXeFloatValue(Constants.XENON_TEST_DEFAULT_GAMER_RATING)),
                new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_SIGMA, new XRLXeDoubleValue(Constants.XENON_TEST_DEFAULT_GAMER_SIGMA)),
                new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_PUID, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_PUID)),
                new XRLXeAttribParam(Constants.X_ATTRIBUTE_HOST_NAME, new XRLXeStringValue("newmom\0")),
*/

            XRLXeAttribParam[] sessionTemplate= new XRLXeAttribParam [47]{
                //we use IntValue 2 because the randomizer range floors things.
                new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP1, new XRLXeIntValue(2)),//spartan-party-size1
                new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP2, new XRLXeIntValue(2)),//spartan-party-size2
                new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP3, new XRLXeIntValue(2)),//spartan-party-size3
                new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP4, new XRLXeIntValue(2)),//spartan-party-size4
                new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP5, new XRLXeIntValue(2)),//spartan-party-size5
                new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP6, new XRLXeIntValue(2)),//spartan-party-size6
                new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP7, new XRLXeIntValue(2)),//spartan-party-size7
                new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP8, new XRLXeIntValue(2)),//spartan-party-size8
                new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP9, new XRLXeIntValue(2)),//spartan-party-size9
                new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP10, new XRLXeIntValue(2)),//spartan-party-size10
                new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP11, new XRLXeIntValue(2)),//spartan-party-size11
                new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP12, new XRLXeIntValue(2)),//spartan-party-size12
                new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP13, new XRLXeIntValue(2)),//spartan-party-size13
                new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP14, new XRLXeIntValue(2)),//elite-party-size1
                new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP15, new XRLXeIntValue(2)),//elite-party-size2
                new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP16, new XRLXeIntValue(2)),//elite-party-size3
                new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP17, new XRLXeIntValue(2)),//elite-party-size4
                new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP18, new XRLXeIntValue(2)),//elite-party-size5
                new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP19, new XRLXeIntValue(2)),//elite-party-size6
                new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP20, new XRLXeIntValue(2)),//elite-party-size7
                new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP21, new XRLXeIntValue(2)),//elite-party-size8
                new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP22, new XRLXeIntValue(2)),//elite-party-size9
                new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP23, new XRLXeIntValue(2)),//elite-party-size10
                new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP24, new XRLXeIntValue(2)),//elite-party-size11
                new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP25, new XRLXeIntValue(2)),//elite-party-size12
                new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP26, new XRLXeIntValue(2)),//elite-party-size13
                new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP27, new XRLXeIntValue(4)),//nat type
                new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP28, new XRLXeIntValue(2)),//mixed-skill
                new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP29, new XRLXeIntValue(2)),//big-party
                new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP30, new XRLXeIntValue(2)),//team-matching
                new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP31, new XRLXeIntValue(2)),//game-in-progress
                new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP32, new XRLXeIntValue(20)),//min-skill-bounds
                new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP33, new XRLXeIntValue(20)),//max-skill-bounds
                new XRLXeAttribParam(Constants.PROPERTY_MYINT32PROP1, new XRLXeIntValue(20)),//min-average-skill-bounds
                new XRLXeAttribParam(Constants.PROPERTY_MYINT32PROP2, new XRLXeIntValue(20)),//max-average-skill-bounds

/*                new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP36, new XRLXeIntValue(1)),//min-social-1-bounds
                new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP37, new XRLXeIntValue(1)),//max-social-1-bounds
                new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP38, new XRLXeIntValue(1)),//min-social-2-bounds
                new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP39, new XRLXeIntValue(1)),//max-social-2-bounds
                new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP40, new XRLXeIntValue(1)),//min-social-3-bounds
                new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP41, new XRLXeIntValue(1)),//max-social-3-bounds
                new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP42, new XRLXeIntValue(1)),//min-social-4-bounds
                new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP43, new XRLXeIntValue(1)),//max-social-4-bounds */
//weighted
                new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP34, new XRLXeIntValue(2)),//has-dlc-1
                new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP35, new XRLXeIntValue(2)),//has-dlc-2
                new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP36, new XRLXeIntValue(2)),//has-dlc-3
                new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP37, new XRLXeIntValue(2)),//has-dlc-4
                new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP38, new XRLXeIntValue(2)),//min-party-skill
                new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP39, new XRLXeIntValue(2)),//max-party-skill
                new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP40, new XRLXeIntValue(2)),//party-average-skill
                new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP41, new XRLXeIntValue(2)),//party-average-mu
                new XRLXeAttribParam(Constants.PROPERTY_MYFLOAT64PROP1, new XRLXeDoubleValue(1)),//average-party-social-1
                new XRLXeAttribParam(Constants.PROPERTY_MYFLOAT64PROP2, new XRLXeDoubleValue(1)),//average-party-social-2
                new XRLXeAttribParam(Constants.PROPERTY_MYFLOAT32PROP1, new XRLXeFloatValue(1)),//average-party-social-3
                new XRLXeAttribParam(Constants.PROPERTY_MYFLOAT32PROP2, new XRLXeFloatValue(1))//average-party-social-4
            };

            XRLXeAttribParam[] nonWeightedParams = new XRLXeAttribParam [35]{

                //Could avoid passing up the zero values in the bitfilter.
                new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP1, new XRLXeIntValue(0)),//spartan-party-size1
                new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP2, new XRLXeIntValue(0)),//spartan-party-size2
                new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP3, new XRLXeIntValue(1)),//spartan-party-size3
                new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP4, new XRLXeIntValue(0)),//spartan-party-size4
                new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP5, new XRLXeIntValue(0)),//spartan-party-size5

                new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP6, new XRLXeIntValue(0)),//spartan-party-size6
                new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP7, new XRLXeIntValue(0)),//spartan-party-size7
                new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP8, new XRLXeIntValue(0)),//spartan-party-size8
                new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP9, new XRLXeIntValue(0)),//spartan-party-size9
                new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP10, new XRLXeIntValue(0)),//spartan-party-size10

                new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP11, new XRLXeIntValue(0)),//spartan-party-size11
                new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP12, new XRLXeIntValue(0)),//spartan-party-size12
                new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP13, new XRLXeIntValue(0)),//spartan-party-size13
                new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP14, new XRLXeIntValue(0)),//elite-party-size1
                new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP15, new XRLXeIntValue(0)),//elite-party-size2

                new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP16, new XRLXeIntValue(0)),//elite-party-size3
                new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP17, new XRLXeIntValue(0)),//elite-party-size4
                new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP18, new XRLXeIntValue(0)),//elite-party-size5
                new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP19, new XRLXeIntValue(0)),//elite-party-size6
                new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP20, new XRLXeIntValue(0)),//elite-party-size7

                new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP21, new XRLXeIntValue(1)),//elite-party-size8
                new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP22, new XRLXeIntValue(0)),//elite-party-size9
                new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP23, new XRLXeIntValue(0)),//elite-party-size10
                new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP24, new XRLXeIntValue(0)),//elite-party-size11
                new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP25, new XRLXeIntValue(0)),//elite-party-size12

                new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP26, new XRLXeIntValue(0)),//elite-party-size13

                new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP27, new XRLXeIntValue(2)),//nat type
                new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP28, new XRLXeIntValue(1)),//mixed-skill
                new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP29, new XRLXeIntValue(1)),//big-party
                new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP30, new XRLXeIntValue(1)),//team-matching
                new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP31, new XRLXeIntValue(1)),//game-in-progress
                new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP32, new XRLXeIntValue(5)),//min-skill-bounds
                new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP33, new XRLXeIntValue(15)),//max-skill-bounds
                new XRLXeAttribParam(Constants.PROPERTY_MYINT32PROP1, new XRLXeIntValue(5)),//min-average-skill-bounds
                new XRLXeAttribParam(Constants.PROPERTY_MYINT32PROP2, new XRLXeIntValue(15))//max-average-skill-bounds
            };

            override protected void Execute()
            {
                RandomEx randGen = new RandomEx();
                FillSessionRandom(sessionTemplate, 5000, SessionType.Ranked);
                XRLXeAttribParamWeighted[] weightedParamArray = new XRLXeAttribParamWeighted [12]{
                    new XRLXeAttribParamWeighted(Constants.PROPERTY_MYINT64PROP34, (float) .05, new XRLXeIntValue(1)),//has-dlc-1
                    new XRLXeAttribParamWeighted(Constants.PROPERTY_MYINT64PROP35, (float) .05, new XRLXeIntValue(0)),//has-dlc-2
                    new XRLXeAttribParamWeighted(Constants.PROPERTY_MYINT64PROP36, (float) .05, new XRLXeIntValue(0)),//has-dlc-3
                    new XRLXeAttribParamWeighted(Constants.PROPERTY_MYINT64PROP37, (float) .05, new XRLXeIntValue(0)),//has-dlc-4
                    new XRLXeAttribParamWeighted(Constants.PROPERTY_MYINT64PROP38, (float) .05, new XRLXeIntValue(1)),//min-party-skill
                    new XRLXeAttribParamWeighted(Constants.PROPERTY_MYINT64PROP39, (float) .05, new XRLXeIntValue(1)),//max-party-skill
                    new XRLXeAttribParamWeighted(Constants.PROPERTY_MYINT64PROP40, (float) .05, new XRLXeIntValue(1)),//party-average-skill
                    new XRLXeAttribParamWeighted(Constants.PROPERTY_MYINT64PROP41, (float) .05, new XRLXeIntValue(1)),//party-average-mu
                    new XRLXeAttribParamWeighted(Constants.PROPERTY_MYFLOAT64PROP1, (float) (.05), new XRLXeDoubleValue(1)),//average-party-social-1
                    new XRLXeAttribParamWeighted(Constants.PROPERTY_MYFLOAT64PROP2, (float) (.05), new XRLXeDoubleValue(1)),//average-party-social-2
                    new XRLXeAttribParamWeighted(Constants.PROPERTY_MYFLOAT32PROP1, (float) (.05), new XRLXeFloatValue(1)),//average-party-social-3
                    new XRLXeAttribParamWeighted(Constants.PROPERTY_MYFLOAT32PROP2, (float) (.05), new XRLXeFloatValue(1))//average-party-social-4
                };

                XRL2SearchSession searchReq = new XRL2SearchSession(true, weightedParamArray, Constants.SESSION_MATCH_QUERY_OMAHA_USE_CASE);
                searchReq.AddParams(nonWeightedParams);
                searchReq.RecalculateOffsets();
                XRL2SearchResults    Resp;

                ArrayList extraFilters = new ArrayList();
                for(int i=0; i<26; i++) {
                    extraFilters.Add(new FilterAttrib(nonWeightedParams[i], true));
                }
                for (int i=26; i<31; i++) {
                    //layman's way of getting an equal out of the filters.
                    extraFilters.Add(new FilterAttrib(nonWeightedParams[i], true));
                    extraFilters.Add(new FilterAttrib(nonWeightedParams[i], false));                    
                }
                for (int i=31; i<35; i++) {
                    //the odd ones are >=, the even ones <=.
                    if (i%2 == 1) {
                        extraFilters.Add(new FilterAttrib(nonWeightedParams[i], true));
                    } else {
                        extraFilters.Add(new FilterAttrib(nonWeightedParams[i], false));
                    }
                }
                
                ArrayList sortedResults = RunBoundingBoxWeightedSearch(rankedSessionData, weightedParamArray, 
                                                                       InitArrayOfFalses(weightedParamArray.Length), extraFilters);

                if(searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out Resp))
                {
                    Global.RO.Info("Currently not checking the output of this, as it requires adding more filter support.");
                    Global.RO.Info("Session output is as follows:");

                    if (CompareResults(Resp, sortedResults)) {
                        ResultCode=TEST_RESULTS.PASSED;                        
                    }
/*
                    if (Resp.results == null) {
                        Global.RO.Info("No session results this time.");
                    } else {
                        foreach (XRL2SingleSearchResult result in Resp.results) {
                            Global.RO.Info((new SessionID(result.SessionID)).ToString());
                        }
                    }
                    ResultCode=TEST_RESULTS.PASSED;                                            
*/
                } else {
                    Global.RO.Error("Search request fails!  Error code " + Global.XErrToString(searchReq.XErr));
                }
                

            }
        }


//somehow add something here so that we filter items less than myint64prop3
        [TestCase, Description("Use a filter and weight on the same parameter.")]
        public class P_Filter_and_Weight_On_Filter : TestBase {
            XRLXeAttribParamWeighted[] weightedParamArray = new XRLXeAttribParamWeighted [2]{
                new XRLXeAttribParamWeighted(Constants.PROPERTY_MYINT64PROP3, (float) (0.5 / 10), new XRLXeIntValue(0x5)),
                new XRLXeAttribParamWeighted(Constants.PROPERTY_MYINT64PROP4, (float) (0.5 / 10), new XRLXeIntValue(0x5))
            };
            override protected void Execute()
            {
                FillSessionMatrix(10, 10, 2, false, SessionType.Ranked);

                ArrayList extraFilters = new ArrayList();
                extraFilters.Add(new FilterAttrib(new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP3, 5), false)); //<= 5
                ArrayList sortedResults = RunBoundingBoxWeightedSearch(rankedSessionData, weightedParamArray, 
                                                                       InitArrayOfFalses(weightedParamArray.Length), extraFilters);

                XRL2SearchSession searchReq = new XRL2SearchSession(true, weightedParamArray, Constants.SESSION_MATCH_QUERY_WEIGHTED_FILTER_AND_PARAM);
                XRL2SearchResults    Resp;
                if(searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out Resp))
                {
                    if (CompareResults(Resp, sortedResults)) {
                        ResultCode=TEST_RESULTS.PASSED;                        
                    }
                } else {
                    Global.RO.Error("Search request fails!  Error code " + Global.XErrToString(searchReq.XErr));
                }
            }
        }


        [TestCase, Description("Add a normal sort onto a weighted sort.")]
        public class P_Normal_Sort_On_Weighted_Sort : TestBase {
            XRLXeAttribParamWeighted[] weightedParamArray = new XRLXeAttribParamWeighted [1]{
                new XRLXeAttribParamWeighted(Constants.PROPERTY_MYINT64PROP3, (float) (1.0 / 1000), new XRLXeIntValue(500)),
            };

            XRLXeAttribParam[] sessionTemplate= new XRLXeAttribParam [2]{
                new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP3, new XRLXeIntValue(1000)),
                new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP4, new XRLXeIntValue(1000))
            };
            public class CustomComparer : IComparer {
                //works only on SessionWithScores.
                int IComparer.Compare(Object x, Object y) {
                    SessionWithScore sess1 = (SessionWithScore) x;
                    SessionWithScore sess2 = (SessionWithScore) y;
                    //find attribs for the session, because we want to sort by the attrib
                    //int64prop4 first, and the score second.
                    XRLXeAttribParam sess1PresortAttrib = new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP4, new XRLXeIntValue(0));
                    sess1.session.GetAttrib(sess1PresortAttrib);
                    XRLXeAttribParam sess2PresortAttrib = new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP4, new XRLXeIntValue(0));
                    sess2.session.GetAttrib(sess2PresortAttrib);

                    if (sess1PresortAttrib.aValue.GetNumericValue() < sess2PresortAttrib.aValue.GetNumericValue()) {
                        return -1;
                    } else if (sess1PresortAttrib.aValue.GetNumericValue() > sess2PresortAttrib.aValue.GetNumericValue()) {
                        return 1;
                    } else {
                        return sess1.CompareTo(sess2);
                    }
                    
                }
            }
            override protected void Execute()
            {
                FillSessionRandom(sessionTemplate, 1000, SessionType.Ranked);

                ArrayList sortedResults = RunBoundingBoxWeightedSearch(rankedSessionData, weightedParamArray);
                sortedResults.Sort(new CustomComparer());
                XRL2SearchSession searchReq = new XRL2SearchSession(true, weightedParamArray, Constants.SESSION_MATCH_QUERY_WEIGHTED_WITH_NORMAL_SORT);

                //add the param that will turn out to be used by sorting, but nothing else.  The
                //value doesn't really matter here.
                XRLXeAttribParam[] additionalParams = new XRLXeAttribParam [1] {
                    new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP4, new XRLXeIntValue(5))
                };
                searchReq.AddParams(additionalParams);
                searchReq.RecalculateOffsets();

                XRL2SearchResults    Resp;
                if(searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out Resp))
                {
                    if (CompareResults(Resp, sortedResults, false)) {
                        ResultCode=TEST_RESULTS.PASSED;                        
                    }
                } else {
                    Global.RO.Error("Search request fails!  Error code " + Global.XErrToString(searchReq.XErr));
                }
            }
        }


        //This test requires a hand-picked set of servers, plus statements for inserting the server
        //into the NPDB.  This was written with theom-lkgwithsg as the first server and jeffngxblob1
        //as the second.
        [TestCase, Ignore, Description("Migration case.  Create some sessions, turn on migration, create some more sessions, and then run the search.")]
        public class P_MANUAL_Migration_Case : TestBase {

            //weights to use in the query
            XRLXeAttribParamWeighted[] weightedParamTemplate = new XRLXeAttribParamWeighted [6]{
                new XRLXeAttribParamWeighted(Constants.PROPERTY_MYFLOAT64PROP1, (float) (0.2 / 5.0), 
                                             new XRLXeDoubleValue(1)),
                new XRLXeAttribParamWeighted(Constants.PROPERTY_MYFLOAT64PROP2, (float) (0.3 / 100.0), 
                                             new XRLXeDoubleValue(18.502)),
                new XRLXeAttribParamWeighted(Constants.PROPERTY_MYFLOAT32PROP1, (float) (0.1 / 1.5), 
                                             new XRLXeFloatValue((float) 1.0)),
                new XRLXeAttribParamWeighted(Constants.PROPERTY_MYFLOAT32PROP2, (float) (0.2 / 5.5), 
                                             new XRLXeFloatValue((float) 3.0)),
                new XRLXeAttribParamWeighted(Constants.PROPERTY_MYINT32PROP1, (float) (0.05 / 100.0), 
                                             new XRLXeIntValue(50)),
                new XRLXeAttribParamWeighted(Constants.PROPERTY_MYINT32PROP2, (float) (0.15 / 2.0), 
                                             new XRLXeIntValue(1)),
            };
            //what should be put into the sessions
            XRLXeAttribParam[] sessionTemplate= new XRLXeAttribParam [6]{
                new XRLXeAttribParam(Constants.PROPERTY_MYFLOAT64PROP1, new XRLXeDoubleValue(5.0)),
                new XRLXeAttribParam(Constants.PROPERTY_MYFLOAT64PROP2, new XRLXeDoubleValue(100.0)),
                new XRLXeAttribParam(Constants.PROPERTY_MYFLOAT32PROP1, new XRLXeFloatValue((float) 1.5)),
                new XRLXeAttribParam(Constants.PROPERTY_MYFLOAT32PROP2, new XRLXeFloatValue((float) 5.5)),
                new XRLXeAttribParam(Constants.PROPERTY_MYINT32PROP1,  new XRLXeIntValue(100)),
                new XRLXeAttribParam(Constants.PROPERTY_MYINT32PROP2, new XRLXeIntValue(2)),
            };

            //tell all buckets for this title to act as if migrating to this server.
            private void SetAllBucketsToMigrate(Npdb npdbHandle, string dest, uint titleID) {
                Global.RO.Info("update t_interface_buckets set vc_next_server=\'" + dest + "\' where i_title_id = 0x" + 
                               titleID.ToString("X") + " and vc_interface = \'xmatch\'");
                npdbHandle.IssueCommand("update t_interface_buckets set vc_next_server=\'" + dest + "\' where i_title_id = 0x" + 
                                        titleID.ToString("X") + " and vc_interface = \'xmatch\'");
                Global.XEnv.ExecuteXmgmtCommand("xmatchfd", "e :xmatchfd reloadtitleinfo", 3);
            }

            override protected void Execute()
            {
                FillSessionRandom(sessionTemplate, 25, SessionType.Ranked, true);
                Npdb npdbHandle = new Npdb();
                npdbHandle.ConnectToServer("theom-lkgwithsg", "xblnpdb");
                ServerNames matchDBs = npdbHandle.GetServerListByInterface("xblob", "xmatch");
                foreach (string s in matchDBs) {
                    Global.RO.Info(s);
                }
                string firstServer = "theom-lkgwithsg";
                string secondServer = "jeffngvhdxblob1";

                //Going manual for now.
                SetAllBucketsToMigrate(npdbHandle, secondServer, Constants.XENON_TITLE);
                //add another 200 sessions on second server.
                FillSessionRandom(sessionTemplate, 25, SessionType.Ranked, false);

                ArrayList sortedResults = RunBoundingBoxWeightedSearch(rankedSessionData, weightedParamTemplate);

                XRL2SearchSession searchReq = new XRL2SearchSession(true, weightedParamTemplate, Constants.SESSION_MATCH_QUERY_WEIGHTED_FLOATS_INTS_DOUBLES);
                XRL2SearchResults    Resp;
                if(searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out Resp))
                {
                    if (CompareResults(Resp, sortedResults, false)) {
                        ResultCode=TEST_RESULTS.PASSED;                        
                    }
                } else {
                    Global.RO.Error("Search request fails!  Error code " + Global.XErrToString(searchReq.XErr));
                }
                //clean up after yourself
                MatchUtil.TruncateSessionsForTitle(Constants.XENON_TITLE, SessionType.Ranked);
                //reset back to original server.
                SetAllBucketsToMigrate(npdbHandle, firstServer, Constants.XENON_TITLE);
                npdbHandle.Close();
            }
        }


        [TestCase, Ignore, Description("RoundRobin case.  Turn on round robing, create some sessions, and then run the search.  Only useful" +
                                       "for manual testing, to ensure we hit only one server if we get enough sessions.")]
        public class P_MANUAL_RoundRobin_Case : TestBase {

            //weights to use in the query
            XRLXeAttribParamWeighted[] weightedParamTemplate = new XRLXeAttribParamWeighted [6]{
                new XRLXeAttribParamWeighted(Constants.PROPERTY_MYFLOAT64PROP1, (float) (0.2 / 5.0), 
                                             new XRLXeDoubleValue(1)),
                new XRLXeAttribParamWeighted(Constants.PROPERTY_MYFLOAT64PROP2, (float) (0.3 / 100.0), 
                                             new XRLXeDoubleValue(18.502)),
                new XRLXeAttribParamWeighted(Constants.PROPERTY_MYFLOAT32PROP1, (float) (0.1 / 1.5), 
                                             new XRLXeFloatValue((float) 1.0)),
                new XRLXeAttribParamWeighted(Constants.PROPERTY_MYFLOAT32PROP2, (float) (0.2 / 5.5), 
                                             new XRLXeFloatValue((float) 3.0)),
                new XRLXeAttribParamWeighted(Constants.PROPERTY_MYINT32PROP1, (float) (0.05 / 100.0), 
                                             new XRLXeIntValue(50)),
                new XRLXeAttribParamWeighted(Constants.PROPERTY_MYINT32PROP2, (float) (0.15 / 2.0), 
                                             new XRLXeIntValue(1)),
            };
            //what should be put into the sessions
            XRLXeAttribParam[] sessionTemplate= new XRLXeAttribParam [6]{
                new XRLXeAttribParam(Constants.PROPERTY_MYFLOAT64PROP1, new XRLXeDoubleValue(5.0)),
                new XRLXeAttribParam(Constants.PROPERTY_MYFLOAT64PROP2, new XRLXeDoubleValue(100.0)),
                new XRLXeAttribParam(Constants.PROPERTY_MYFLOAT32PROP1, new XRLXeFloatValue((float) 1.5)),
                new XRLXeAttribParam(Constants.PROPERTY_MYFLOAT32PROP2, new XRLXeFloatValue((float) 5.5)),
                new XRLXeAttribParam(Constants.PROPERTY_MYINT32PROP1,  new XRLXeIntValue(100)),
                new XRLXeAttribParam(Constants.PROPERTY_MYINT32PROP2, new XRLXeIntValue(2)),
            };


            //Create a round robin server.
            private void CreateRoundRobinServer(Npdb npdbHandle) {
                string sql = "insert into t_interface_buckets " +
                    "(vc_environment, vc_interface, i_title_id, i_bucket, vc_server, vc_next_server, dt_migration_start, " +
                    "vc_info1, vc_info2, vc_info3, vc_info4) " +
                    " values ('xblob', 'xmatch', 0xffed94b2, 1, 'jeffngvhdxblob1', " +
                    " 'jeffngvhdxblob1', '1900-01-01', '', '', '', '')";
                Global.RO.Info(sql);
                npdbHandle.IssueCommand(sql);
                Global.XEnv.ExecuteXmgmtCommand("xmatchfd", "e :xmatchfd reloadtitleinfo", 3);
            }

            private void DeleteRoundRobinServer(Npdb npdbHandle) {
                string sql = "delete from t_interface_buckets " +
                    "where i_title_id = 0xffed94b2 and vc_interface = 'xmatch' and i_bucket = 1";
                Global.RO.Info(sql);
                npdbHandle.IssueCommand(sql);
                Global.XEnv.ExecuteXmgmtCommand("xmatchfd", "e :xmatchfd reloadtitleinfo", 3);
            }



            override protected void Execute()
            {
                Npdb npdbHandle = new Npdb();
                npdbHandle.ConnectToServer("theom-lkgwithsg", "xblnpdb");
                ServerNames matchDBs = npdbHandle.GetServerListByInterface("xblob", "xmatch");
                CreateRoundRobinServer(npdbHandle);
                FillSessionRandom(sessionTemplate, 20, SessionType.Ranked, true);

                ArrayList sortedResults = RunBoundingBoxWeightedSearch(rankedSessionData, weightedParamTemplate);

                XRL2SearchSession searchReq = new XRL2SearchSession(true, weightedParamTemplate, Constants.SESSION_MATCH_QUERY_WEIGHTED_FLOATS_INTS_DOUBLES);
                XRL2SearchResults    Resp;
                if(searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out Resp))
                {
                    if (CompareResults(Resp, sortedResults, false)) {
                        ResultCode=TEST_RESULTS.PASSED;                        
                    }
                } else {
                    Global.RO.Error("Search request fails!  Error code " + Global.XErrToString(searchReq.XErr));
                }
                //clean up after yourself
                MatchUtil.TruncateSessionsForTitle(Constants.XENON_TITLE, SessionType.Ranked);
                DeleteRoundRobinServer(npdbHandle);
                npdbHandle.Close();
            }
        }

         [TestCase, Description("Run 100 searches of random weights sequentially, creating random data in each case with float values. Verify that the returned sessions are in order and that their scores match.")]
        public class P_Randomized : TestBase {
            override protected void Execute()
            {
                //weights to use in the query
                XRLXeAttribParamWeighted[] weightedParamTemplate = new XRLXeAttribParamWeighted [6]{
                    new XRLXeAttribParamWeighted(Constants.PROPERTY_MYFLOAT64PROP1, (float) (0.2 / 5.0), 
                                                 new XRLXeDoubleValue(1)),
                    new XRLXeAttribParamWeighted(Constants.PROPERTY_MYFLOAT64PROP2, (float) (0.3 / 100.0), 
                                                 new XRLXeDoubleValue(18.502)),
                    new XRLXeAttribParamWeighted(Constants.PROPERTY_MYFLOAT32PROP1, (float) (0.1 / 1.5), 
                                                 new XRLXeFloatValue((float) 1.0)),
                    new XRLXeAttribParamWeighted(Constants.PROPERTY_MYFLOAT32PROP2, (float) (0.2 / 5.5), 
                                                 new XRLXeFloatValue((float) 3.0)),
                    new XRLXeAttribParamWeighted(Constants.PROPERTY_MYINT32PROP1, (float) (0.05 / 100.0), 
                                                 new XRLXeIntValue(50)),
                    new XRLXeAttribParamWeighted(Constants.PROPERTY_MYINT32PROP2, (float) (0.15 / 2.0), 
                                                 new XRLXeIntValue(1)),
                };
                //what should be put into the sessions
                XRLXeAttribParam[] sessionTemplate= new XRLXeAttribParam [6]{
                    new XRLXeAttribParam(Constants.PROPERTY_MYFLOAT64PROP1, new XRLXeDoubleValue(5.0)),
                    new XRLXeAttribParam(Constants.PROPERTY_MYFLOAT64PROP2, new XRLXeDoubleValue(100.0)),
                    new XRLXeAttribParam(Constants.PROPERTY_MYFLOAT32PROP1, new XRLXeFloatValue((float) 1.5)),
                    new XRLXeAttribParam(Constants.PROPERTY_MYFLOAT32PROP2, new XRLXeFloatValue((float) 5.5)),
                    new XRLXeAttribParam(Constants.PROPERTY_MYINT32PROP1,  new XRLXeIntValue(100)),
                    new XRLXeAttribParam(Constants.PROPERTY_MYINT32PROP2, new XRLXeIntValue(2)),
                };

                RandomEx randGen = new RandomEx();
                bool pass = true;
                //run 20 ranked
                for (int i=0; i<20; i++) {
                    FillSessionRandom(sessionTemplate, 1000, SessionType.Ranked);
                    //clone the weights.
                    XRLXeAttribParamWeighted [] weights = CreateClonedWeightedParams(weightedParamTemplate, randGen);

                    ArrayList sortedResults = RunBoundingBoxWeightedSearch(rankedSessionData, weights);

                    XRL2SearchSession searchReq = new XRL2SearchSession(true, weights, 
                                                                        Constants.SESSION_MATCH_QUERY_WEIGHTED_FLOATS_INTS_DOUBLES);
                    XRL2SearchResults    Resp;
                    if(searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out Resp))
                    {
                        if (!(CompareResults(Resp, sortedResults))) {
                            pass = false;
                            return;
                        }
                    }
                }

                XRLXeAttribParam socialParam = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_TYPE,new XRLXeIntValue(Constants.X_ATTRIBUTE_GAME_TYPE_STANDARD));
                //run 20 standard
                for (int i=0; i<20; i++) {
                    FillSessionRandom(sessionTemplate, 1000, SessionType.Social);
                    //clone the weights.
                    XRLXeAttribParamWeighted [] weights = CreateClonedWeightedParams(weightedParamTemplate, randGen);

                    ArrayList sortedResults = RunBoundingBoxWeightedSearch(standardSessionData, weights);

                    XRL2SearchSession searchReq = new XRL2SearchSession(true, weights, 
                                                                        Constants.SESSION_MATCH_QUERY_WEIGHTED_FLOATS_INTS_DOUBLES);
                    
                    searchReq.UpdateAttrib(socialParam);
                    XRL2SearchResults    Resp;
                    if(searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out Resp))
                    {
                        if (!(CompareResults(Resp, sortedResults))) {
                            pass = false;
                            return;
                        }
                    }
                }

                if (pass) {
                    ResultCode=TEST_RESULTS.PASSED; 
                }
            }

        }


        [TestCase, Ignore, Description("Awesome demo.")]
        public class P_Demo : TestBase {

            public MatchSession CustomCreateSession(double mu, double sigma, int zone, int country, int lang, float exp, int fun) {
                MatchSession sess = new MatchSession(false);
                XRLXeAttribParam[] systemAtts= new XRLXeAttribParam [5]{
                    new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_MU, new XRLXeDoubleValue(mu)),
                    new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_SIGMA, new XRLXeDoubleValue(sigma)),
                    new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_ZONE, new XRLXeIntValue(zone)),
                    new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_COUNTRY, new XRLXeIntValue(country)),
                    new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_LANGUAGE,  new XRLXeIntValue(lang)),
                };

                XRLXeAttribParam[] titleAtts= new XRLXeAttribParam [2]{
                    new XRLXeAttribParam(Constants.PROPERTY_MYFLOAT32PROP1, new XRLXeFloatValue(exp)),
                    new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP1, new XRLXeIntValue(fun))
                };

                foreach (XRLXeAttribParam attrib in systemAtts) {
                    sess.UpdateAttrib(attrib, false);
                }
                foreach (XRLXeAttribParam attrib in titleAtts) {
                    sess.AddAttrib(attrib, false);
                }
                sess.Create(SessionType.Social);
                return sess;

            }

            public XRLXeAttribParamWeighted[] CreateWeightedArray(double mu, double sigma, int zone, int country, int lang, float exp) {
                XRLXeAttribParamWeighted[] weightArray = new XRLXeAttribParamWeighted [6]{
                    new XRLXeAttribParamWeighted(Constants.X_ATTRIBUTE_GAMER_MU, (float) (0.2 / 5.0), 
                                                 new XRLXeDoubleValue(mu)),
                    new XRLXeAttribParamWeighted(Constants.X_ATTRIBUTE_GAMER_SIGMA, (float) (0.3 / 100.0), 
                                                 new XRLXeDoubleValue(sigma)),
                    new XRLXeAttribParamWeighted(Constants.X_ATTRIBUTE_GAMER_ZONE, (float) (0.1 / 1.5), 
                                                 new XRLXeIntValue( zone )),
                    new XRLXeAttribParamWeighted(Constants.X_ATTRIBUTE_GAMER_COUNTRY, (float) (0.2 / 5.5), 
                                                 new XRLXeIntValue( country )),
                    new XRLXeAttribParamWeighted(Constants.X_ATTRIBUTE_GAMER_LANGUAGE, (float) (0.05 / 100.0), 
                                                 new XRLXeIntValue( lang )),
                    new XRLXeAttribParamWeighted(Constants.PROPERTY_MYFLOAT32PROP1, (float) (0.15 / 2.0), 
                                                 new XRLXeFloatValue( exp )),
                };
                return weightArray;
            }
            override protected void Execute()
            {
                MatchUtil.TruncateSessionsForTitle(Constants.XENON_TITLE, SessionType.Social);

                //weights to use in the query


                CustomCreateSession(1,2,3,4,5,6,7);
                CustomCreateSession(1,1,5,5,9,9,1000);
                CustomCreateSession(10000,1,1,1,1,1,1);

                XRLXeAttribParam []	searchParams = new XRLXeAttribParam[8];
                searchParams[0] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_TYPE,new XRLXeIntValue(Constants.X_ATTRIBUTE_GAME_TYPE_STANDARD));
                searchParams[1] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE, new XRLXeIntValue(Constants.CONTEXT_GAME_MODE_MODEA));
                searchParams[2] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_ZONE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_ZONE));
                searchParams[3] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_COUNTRY, new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_COUNTRY));
                searchParams[4] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_LANGUAGE,new XRLXeIntValue(Constants.XENON_TEST_DEFAULT_GAMER_LANG));
                searchParams[5] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_MU,new XRLXeDoubleValue(Constants.XENON_TEST_DEFAULT_GAMER_MU));
                searchParams[6] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_SIGMA, new XRLXeDoubleValue(Constants.XENON_TEST_DEFAULT_GAMER_SIGMA));
                searchParams[7] = new XRLXeAttribParam(Constants.PROPERTY_MYFLOAT32PROP1, 
                                                       new XRLXeFloatValue(/*awesome exp*/(float) 0.5));


                //run social
                XRL2SearchSession searchReqSocial = new XRL2SearchSession(searchParams, Constants.SESSION_MATCH_QUERY_DEMO);
                XRL2SearchResults    RespSocial;
                searchReqSocial.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out RespSocial);
                foreach (XRL2SingleSearchResult result in RespSocial.results) {
                    Global.RO.Info((new SessionID(result.SessionID)).ToString());
                }

                Global.RO.Info("Weighted search");
                XRLXeAttribParam [] typeModeParams = new XRLXeAttribParam[2];
                typeModeParams[0] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_TYPE,new XRLXeIntValue(Constants.X_ATTRIBUTE_GAME_TYPE_STANDARD));
                typeModeParams[1] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE, new XRLXeIntValue(Constants.CONTEXT_GAME_MODE_MODEA));

                XRLXeAttribParamWeighted [] weights = CreateWeightedArray(1,2,3,4,5,6);
                //run weighted
                XRL2SearchSession searchReq = new XRL2SearchSession(typeModeParams, weights, Constants.SESSION_MATCH_QUERY_DEMO);
                XRL2SearchResults    Resp;
                if(searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out Resp))
                {
                    foreach (XRL2SingleSearchResult result in Resp.results) {
                        Global.RO.Info((new SessionID(result.SessionID)).ToString());
                    }

                    
                }

            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XMatchTest\Func2SearchSession.cs ===
using System;
using System.Threading;
using System.Collections;
using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.LiveService.Matchmaking;
using ServerTestFramework.Utilities;
using xonline.common.config;

namespace XMatchTest
{
    public class Func2SearchPlatformProperty : TestNode
    {
        const uint TitleId = Constants.XENON_TITLE;

        public Func2SearchPlatformProperty()
        {
            CreateSearchLockTests();
        }

        public string GetSingleServerFromDbList(string dbList)
        {
            string singleServer = dbList;
            if (dbList.Contains(";"))
            {
                singleServer = dbList.Split(';')[0];
            }
            return singleServer;
        }

        [TestGroupSetup]
        public void Setup()
        {
            MatchTitle matchTitle = MatchTitleMgr.SnapshotMatchTitle(TitleId);
            if (matchTitle.DbList != "")
            {
                matchTitle.DbList = GetSingleServerFromDbList(matchTitle.DbList);
            }
            MatchTitleMgr.UpdateMatchTitle(matchTitle);
            MatchFDs.ReloadTitleInfo();
        }

        [TestGroupTearDown]
        public void TearDown()
        {
            MatchTitleMgr.RestoreMatchTitleFromSnapshot(TitleId);
            MatchFDs.ReloadTitleInfo();
        }

        internal enum LockType
        {
            None,
            Create,
            NPDB
        }

        internal enum ExpectedResults
        {
            Locked,
            Unlocked,
            Both,
            Neither
        }

        internal struct SLTestData
        {
            public CSGInfo.ClientType createdBy;
            public LockType lockedBy;
            public CSGInfo.ClientType searchWith;
            public bool lockedSearch;
            public ExpectedResults expectedSessions;

            public SLTestData(CSGInfo.ClientType CreatedBy, LockType LockedBy,
                              CSGInfo.ClientType SearchWith, bool LockedSearch, ExpectedResults ExpectedSessions)
            {
                createdBy = CreatedBy;
                lockedBy = LockedBy;
                searchWith = SearchWith;
                lockedSearch = LockedSearch;
                expectedSessions = ExpectedSessions;
            }
        }

        internal SLTestData[] SearchLockTests = new SLTestData[]
        {
            new SLTestData(CSGInfo.ClientType.Xenon, LockType.None, CSGInfo.ClientType.Xenon, false, ExpectedResults.Both),
            new SLTestData(CSGInfo.ClientType.Xenon, LockType.None, CSGInfo.ClientType.PC, false, ExpectedResults.Both),
            new SLTestData(CSGInfo.ClientType.Xenon, LockType.None, CSGInfo.ClientType.Xenon, true, ExpectedResults.Neither),
            new SLTestData(CSGInfo.ClientType.Xenon, LockType.None, CSGInfo.ClientType.PC, true, ExpectedResults.Neither),

            new SLTestData(CSGInfo.ClientType.Xenon, LockType.Create, CSGInfo.ClientType.Xenon, false, ExpectedResults.Both),
            new SLTestData(CSGInfo.ClientType.Xenon, LockType.Create, CSGInfo.ClientType.PC, false, ExpectedResults.Unlocked),
            new SLTestData(CSGInfo.ClientType.Xenon, LockType.Create, CSGInfo.ClientType.Xenon, true, ExpectedResults.Locked),
            new SLTestData(CSGInfo.ClientType.Xenon, LockType.Create, CSGInfo.ClientType.PC, true, ExpectedResults.Neither),

            // #67652 - "Revoking cross-platform matchmaking via NPDB invalidates the existing sessions"
            new SLTestData(CSGInfo.ClientType.Xenon, LockType.NPDB, CSGInfo.ClientType.Xenon, false, ExpectedResults.Locked),
            new SLTestData(CSGInfo.ClientType.Xenon, LockType.NPDB, CSGInfo.ClientType.PC, false, ExpectedResults.Neither),
            new SLTestData(CSGInfo.ClientType.Xenon, LockType.NPDB, CSGInfo.ClientType.Xenon, true, ExpectedResults.Locked),
            new SLTestData(CSGInfo.ClientType.Xenon, LockType.NPDB, CSGInfo.ClientType.PC, true, ExpectedResults.Neither),

            new SLTestData(CSGInfo.ClientType.PC, LockType.None, CSGInfo.ClientType.Xenon, false, ExpectedResults.Both),
            new SLTestData(CSGInfo.ClientType.PC, LockType.None, CSGInfo.ClientType.PC, false, ExpectedResults.Both),
            new SLTestData(CSGInfo.ClientType.PC, LockType.None, CSGInfo.ClientType.Xenon, true, ExpectedResults.Neither),
            new SLTestData(CSGInfo.ClientType.PC, LockType.None, CSGInfo.ClientType.PC, true, ExpectedResults.Neither),

            new SLTestData(CSGInfo.ClientType.PC, LockType.Create, CSGInfo.ClientType.Xenon, false, ExpectedResults.Unlocked),
            new SLTestData(CSGInfo.ClientType.PC, LockType.Create, CSGInfo.ClientType.PC, false, ExpectedResults.Both),
            new SLTestData(CSGInfo.ClientType.PC, LockType.Create, CSGInfo.ClientType.Xenon, true, ExpectedResults.Neither),
            new SLTestData(CSGInfo.ClientType.PC, LockType.Create, CSGInfo.ClientType.PC, true, ExpectedResults.Locked),

            // #67652 - "Revoking cross-platform matchmaking via NPDB invalidates the existing sessions"
            new SLTestData(CSGInfo.ClientType.PC, LockType.NPDB, CSGInfo.ClientType.Xenon, false, ExpectedResults.Neither),
            new SLTestData(CSGInfo.ClientType.PC, LockType.NPDB, CSGInfo.ClientType.PC, false, ExpectedResults.Locked),
            new SLTestData(CSGInfo.ClientType.PC, LockType.NPDB, CSGInfo.ClientType.Xenon, true, ExpectedResults.Neither),
            new SLTestData(CSGInfo.ClientType.PC, LockType.NPDB, CSGInfo.ClientType.PC, true, ExpectedResults.Locked)
        };

        internal void CreateSearchLockTests()
        {
            foreach (SLTestData testData in SearchLockTests)
            {
                AddChild(new DynamicSearchLockTest(testData));
            }
        }

        [TestGroup]
        internal class DynamicSearchLockTest : SearchMatrixTestBase
        {
            const string BASE_TEST_NAME = "PSearchLock";

            private SLTestData TestData;

            public DynamicSearchLockTest(SLTestData test)
            {
                TestData = test;
                Name = GenerateTestName();
            }

            private string GenerateTestName()
            {
                string name = BASE_TEST_NAME;
                name += "_" + TestData.createdBy.ToString();
                name += "_" + TestData.lockedBy.ToString();
                name += "_" + TestData.searchWith.ToString();
                name += "_" + (TestData.lockedSearch == true ? "Locked" : "Unlocked");
                return name;
            }

            override protected void Execute()
            {
                Execute(
                    TitleId,
                    TestData.createdBy,
                    TestData.lockedBy,
                    TestData.searchWith,
                    TestData.lockedSearch,
                    TestData.expectedSessions
                    );
            }
        }

        internal abstract class SearchMatrixTestBase : TestBase
        {
            private XRL2SearchResults SearchWithCrossPlatformPrivilege(uint titleID, CSGInfo.ClientType clientType, 
                                                            XRLXeAttribParam[] searchParams, uint spIndex) {
                XRL2SearchSession searchRequest = MatchUtil.CreateSearchRequest(titleID, clientType, searchParams, 
                                                                                Constants.SESSION_MATCH_QUERY_QUERY1);
                //add the FakeSG privilege--without it all ability to search cross-platform
                //is blocked.
                searchRequest.Slot.SetPrivilege(XOn.XPRIVILEGE_CROSS_PLATFORM_MULTIPLAYER); 
                return(MatchUtil.CustomSearch(searchRequest));
            }

            private bool FindSessionIdInSearchResults(XRL2SearchResults searchResults, byte[] expectedSessionId)
            {
                if (searchResults == null)
                {
                    return false;
                }
                Global.RO.Debug("FindSessionIdInSearchResults: looking for session ID {0}",
                                Constants.sessionIDConvert(expectedSessionId).ToString("X"));
                ArrayComparer<byte> arrayComparer = new ArrayComparer<byte>(ArrayEx.ByteComparison);
                foreach (XRL2SingleSearchResult result in searchResults.results)
                {
                    Global.RO.Debug("FindSessionIdInSearchResults: comparing against session ID {0}",
                                    Constants.sessionIDConvert(result.SessionID).ToString("X"));
                    int matching = arrayComparer.Compare(result.SessionID, expectedSessionId);
                    if (matching == 0)
                    {
                        Global.RO.Debug("FindSessionIdInSearchResults: match found.");
                        return true;
                    }
                }
                Global.RO.Debug("FindSessionIdInSearchResults: match NOT found.");
                return false;
            }

            protected void VerifySearchResultsEx(
                MatchSession lockedSession, XRL2SearchResults lockedSearchResults, 
                MatchSession unlockedSession, XRL2SearchResults unlockedSearchResults,
                ExpectedResults expectedResults)
            {
                Global.RO.Debug("VerifySearchResults: expectedResults == {0}", expectedResults.ToString());
                if (lockedSearchResults == null && unlockedSearchResults == null)
                {
                    // No results found; verify 0 results is the expected result
                    if (expectedResults != ExpectedResults.Neither)
                    {
                        throw new UnexpectedTestResultException("Failed to find session(s): searchResp == null");
                    }
                }
                else
                {
                    // Got at least some results; verify they match expectations
                    if (lockedSearchResults != null)
                    {
                        Global.RO.Debug("VerifySearchResults: searchResults.results.Length == {0}",
                                        lockedSearchResults.results.Length);
                    }
                    if (expectedResults == ExpectedResults.Locked || expectedResults == ExpectedResults.Both)
                    {
                        if (!FindSessionIdInSearchResults(lockedSearchResults, (byte[]) lockedSession.GetSessionID()))
                        {
                            throw new UnexpectedTestResultException("Failed to find locked session");
                        }
                    }
                    if (unlockedSearchResults != null)
                    {
                        Global.RO.Debug("VerifySearchResults: searchResults.results.Length == {0}",
                                        unlockedSearchResults.results.Length);
                    }
                    if (expectedResults == ExpectedResults.Unlocked || expectedResults == ExpectedResults.Both)
                    {
                        if (!FindSessionIdInSearchResults(unlockedSearchResults, (byte[]) unlockedSession.GetSessionID()))
                        {
                            throw new UnexpectedTestResultException("Failed to find unlocked session");
                        }
                    }
                }
            }

            protected void VerifySearchResults(XRL2SearchResults searchResults, ExpectedResults expectedResults,
                                               MatchSession lockedSession, MatchSession unlockedSession)
            {
                Global.RO.Debug("VerifySearchResults: expectedResults == {0}", expectedResults.ToString());
                if (searchResults == null)
                {
                    // No results found; verify 0 results is the expected result
                    if (expectedResults != ExpectedResults.Neither)
                    {
                        throw new UnexpectedTestResultException("Failed to find session(s): searchResp == null");
                    }
                }
                else
                {
                    // Got results; verify they match expectations
                    Global.RO.Debug("VerifySearchResults: searchResults.results.Length == {0}", searchResults.results.Length);
                    if (expectedResults == ExpectedResults.Locked || expectedResults == ExpectedResults.Both)
                    {
                        if (!FindSessionIdInSearchResults(searchResults, (byte[]) lockedSession.GetSessionID()))
                        {
                            throw new UnexpectedTestResultException("Failed to find locked session");
                        }
                    }
                    if (expectedResults == ExpectedResults.Unlocked || expectedResults == ExpectedResults.Both)
                    {
                        if (!FindSessionIdInSearchResults(searchResults, (byte[]) unlockedSession.GetSessionID()))
                        {
                            throw new UnexpectedTestResultException("Failed to find unlocked session");
                        }
                    }
                }
            }

            protected void Execute(uint titleId, CSGInfo.ClientType createdBy, LockType lockedBy,
                                   CSGInfo.ClientType searchWith, bool lockedSearch, ExpectedResults expectedSessions)
            {
                ResultCode = TEST_RESULTS.FAILED;

                // Create unlocked (control) session
                MatchSession unlockedSession = new MatchSession(false);
                unlockedSession.TitleID = titleId;
                unlockedSession.SetClientType(createdBy);
                unlockedSession.SetCrossPlatformPrivilege();
                unlockedSession.Create(SessionType.Ranked);
                Global.RO.Debug("Xbox ID == {0}", new SGADDR(unlockedSession.HostAddress.abOnline).qwXboxID.ToString("X"));

                TitleCrossPlatformRevoker titleRevoker = new TitleCrossPlatformRevoker();
                try
                {
                    if (lockedBy == LockType.NPDB)
                    {
                        titleRevoker.Revoke(titleId);
                    }

                    // Create locked (test) session
                    MatchSession lockedSession = new MatchSession(false);
                    lockedSession.TitleID = titleId;
                    lockedSession.SetClientType(createdBy);
                    if (lockedBy == LockType.Create)
                    {
                        lockedSession.AddAttrib(new XRLXeAttribParam(Constants.X_ATTRIBUTE_PLATFORM_LOCK, (uint)1), false);
                    }
                    lockedSession.SetCrossPlatformPrivilege();
                    lockedSession.Create(SessionType.Ranked);
                    Global.RO.Debug("Xbox ID == {0}", new SGADDR(lockedSession.HostAddress.abOnline).qwXboxID.ToString("X"));

                    try
                    {
                        // Search for sessions
                        XRLXeAttribParam[] searchLockAttr = null;
                        if (lockedSearch)
                        {
                            searchLockAttr = new XRLXeAttribParam[] { 
                                new XRLXeAttribParam(Constants.X_ATTRIBUTE_PLATFORM_LOCK, (uint)1) };
                        }

                        XRL2SearchResults searchResults = SearchWithCrossPlatformPrivilege(lockedSession.TitleID, searchWith, searchLockAttr, 
                                                                                           Constants.SESSION_MATCH_QUERY_QUERY1);
                        VerifySearchResults(searchResults, expectedSessions, lockedSession, unlockedSession);

                        // Split the locked session
                        MatchSession splitSession = lockedSession.Split(true, createdBy);
                        try
                        {
                            searchResults = SearchWithCrossPlatformPrivilege(splitSession.TitleID, searchWith, searchLockAttr, 
                                                                                           Constants.SESSION_MATCH_QUERY_QUERY1);
                            if (expectedSessions == ExpectedResults.Locked || expectedSessions == ExpectedResults.Both)
                            {
                                expectedSessions = ExpectedResults.Both;
                            }
                            else
                            {
                                expectedSessions = ExpectedResults.Neither;
                            }
                            VerifySearchResults(searchResults, expectedSessions, lockedSession, splitSession);
                        }
                        finally
                        {
                            try
                            {
                                splitSession.Delete();
                            }
                            catch
                            {
                                Global.RO.Error("Failed to delete split session.");
                                Global.RO.Error("Subsequent testing will likely be unreliable until this is manually fixed.");
                            }
                        }
                    }
                    finally
                    {
                        try
                        {
                            lockedSession.Delete();
                        }
                        catch
                        {
                            Global.RO.Error("Failed to delete locked session.");
                            Global.RO.Error("Subsequent testing will likely be unreliable until this is manually fixed.");
                        }
                    }
                }
                finally
                {
                    try
                    {
                        titleRevoker.Restore();
                    }
                    catch
                    {
                        Global.RO.Error("Failed to restore title to previous revocation setting.");
                        Global.RO.Error("Subsequent testing will likely be unreliable until this is manually fixed.");
                        throw;
                    }
                    try
                    {
                        unlockedSession.Delete();
                    }
                    catch
                    {
                        Global.RO.Error("Failed to delete unlocked session.");
                        Global.RO.Error("Subsequent testing will likely be unreliable until this is manually fixed.");
                    }
                }
                ResultCode = TEST_RESULTS.PASSED;
            }
        }

    }

    internal abstract class NegativeSearch2TestBase : TestBase
    {
        protected bool SearchTestNegative(XRL2SearchSession Req, uint XErr)
        {
            XRL2SearchResults resp;
            if (Req.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out resp))
            {
                Global.RO.Warn("Negative CreateSession request succeed unexpectedly");
                return false;
            }
            if (Req.XErr != XErr)
            {
                Global.RO.Warn("Wrong error code (" + Global.XErrToString(Req.XErr) + " != " + Global.XErrToString(XErr) + ")");
                return false;
            }
            if (resp != null)
            {
                Global.RO.Warn("response is not null");
                return false;
            }
            return true;
        }
    }

    internal abstract class CheckReturnAttribsTestBase : TestBase
    {
        /// <summary>
        /// 
        /// </summary>
        /// <param name="numSessions"></param>
        /// <param name="attribParams">attribs when creating session; query parameters when searching for session</param>
        /// <param name="spIndex"></param>
        /// <returns></returns>
        protected bool createAndVerifyResults(uint numSessions, uint expectedNumResult, XRLXeAttribParam[] attribs,
                                              XRLXeAttribParam[] searchParams, uint spIndex)
        {
            bool    ret = true;
            // create numSessions with Attribs first
            XRL2CreateUpdateSession   [] createReqs = new XRL2CreateUpdateSession[numSessions];
            XRLSessionInfo            [] createResp = new XRLSessionInfo[numSessions];
            try
            {
                for(uint i = 0; i < numSessions; i++)
                {
                    createReqs[i] = new XRL2CreateUpdateSession();
                    if(attribs != null)
                        createReqs[i].AddAttribs(attribs);
                    // we have to hit one front door in order to make sure session will be created on all sql box
                    if(!createReqs[i].Execute(Global.XEnv.GetInterface(Interface.xmatchfd)[0], out createResp[i]))
                    {
                        ret = false;
                        break;
                    }
                }
                if(ret)
                {
                    // pass search parameters and use that in the filter
                    XRL2SearchSession	searchReq = new XRL2SearchSession(true,spIndex);
                    if(searchParams != null)
                        searchReq.AddParams(searchParams);
                    XRL2SearchResults    Resp;
                    if(searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out Resp))
                    {
                        // check searchResults
                        if(Resp.resultsLen == expectedNumResult)
                        {	// check attributes returned in the search result
                            int k = 0;
                            bool found = false;
                            uint tempID;
                            while(k < expectedNumResult) // check each session returned in the searchResults
                            {
                                uint numAttribReturned = Resp.results[k].AttribOffsetsLen;
                                for(uint j = 0; j < attribs.Length; j++)
                                {
                                    found = false;
                                    // loop through returned attribute to find the one expected
                                    for(uint i = 0; i < numAttribReturned; i++)
                                    {
                                        if(attribs[j].attribParamID == Resp.results[k].Attribs[i].attribParamID)
                                        {
                                            found = true;
                                            if((attribs[j].attribParamID & Constants.X_ATTRIBUTE_DATATYPE_MASK)
                                               == Constants.X_ATTRIBUTE_DATATYPE_STRING)
                                            {
                                                string expectedString = (attribs[j].aValue as XRLXeStringValue).strValue;
                                                string returnedString = (Resp.results[k].Attribs[i].aValue as XRLXeStringValue).strValue;
                                                if(string.Compare(expectedString,returnedString) != 0)
                                                {
                                                    ret = false;
                                                    Global.RO.Warn("String values in the returned session is not correct:Expected-Actual:"+expectedString+"-"+returnedString);
                                                    break;
                                                }
                                            }
                                            else if(((tempID=attribs[j].attribParamID) & Constants.X_ATTRIBUTE_DATATYPE_MASK)
                                                    ==Constants.X_ATTRIBUTE_DATATYPE_INTEGER)
                                            {
                                                if((tempID & Constants.X_ATTRIBUTE_XE_SUBTYPE_MASK) == Constants.X_ATTRIBUTE_XE_SUBTYPE_FLOAT32)
                                                {
                                                    float expected = (attribs[j].aValue as XRLXeFloatValue).fValue;
                                                    float returned = (Resp.results[k].Attribs[i].aValue as XRLXeFloatValue).fValue;
                                                    if( expected!= returned)
                                                    {
                                                        ret = false;
                                                        Global.RO.Warn("Float value in the returned session is not correct:Expected-Actual:"+expected+"-"+returned);
                                                        break;
                                                    }
                                                }
                                                else if((tempID & Constants.X_ATTRIBUTE_XE_SUBTYPE_MASK) == Constants.X_ATTRIBUTE_XE_SUBTYPE_FLOAT64)
                                                {
                                                    double expected = (attribs[j].aValue as XRLXeDoubleValue).dValue;
                                                    double returned = (Resp.results[k].Attribs[i].aValue as XRLXeDoubleValue).dValue;
                                                    if( expected!= returned)
                                                    {
                                                        ret = false;
                                                        Global.RO.Warn("Double value in the returned session is not correct:Expected-Actual:"+expected+"-"+returned);
                                                        break;
                                                    }
                                                }
                                                else if(((tempID & Constants.X_ATTRIBUTE_XE_SUBTYPE_MASK) == Constants.X_ATTRIBUTE_XE_SUBTYPE_UINT32) ||
                                                        ((tempID & Constants.X_ATTRIBUTE_XE_SUBTYPE_MASK) == Constants.X_ATTRIBUTE_XE_SUBTYPE_UINT64))
                                                {
                                                    long expected = (attribs[j].aValue as XRLXeIntValue).intValue;
                                                    long returned = (Resp.results[k].Attribs[i].aValue as XRLXeIntValue).intValue;
                                                    if( expected!= returned)
                                                    {
                                                        ret = false;
                                                        Global.RO.Warn("Int value in the returned session is not correct:Expected-Actual:"+expected+"-"+returned);
                                                        break;
                                                    }
                                                }
                                                else if((tempID & Constants.X_ATTRIBUTE_XE_SUBTYPE_MASK) == Constants.X_ATTRIBUTE_XE_SUBTYPE_DATETIME)
                                                {
                                                    long expected = (attribs[j].aValue as XRLXeDateTimeValue).dateValue;
                                                    long returned = (Resp.results[k].Attribs[i].aValue as XRLXeDateTimeValue).dateValue;
                                                    if( expected!=returned )
                                                    {
                                                        ret = false;
                                                        Global.RO.Warn("DateTime value in the returned session is not correct:Expected-Actual:"+expected+"-"+returned);
                                                        break;
                                                    }
                                                }
                                                else if((tempID & Constants.X_ATTRIBUTE_XE_SUBTYPE_MASK) == Constants.X_ATTRIBUTE_XE_SUBTYPE_CONTEXT)
                                                {
                                                    long expected = (attribs[j].aValue as XRLXeIntValue).intValue;
                                                    long returned = (Resp.results[k].Attribs[i].aValue as XRLXeIntValue).intValue;
                                                    if( expected!=returned )
                                                    {
                                                        ret = false;
                                                        Global.RO.Warn("Context value in the returned session is not correct:Expected-Actual:"+expected+"-"+returned);
                                                        break;
                                                    }
                                                }
                                            }
                                        }
                                        if(found)
                                            break;
                                    }
                                    if(found ==false || (ret ==false))
                                    {
                                        Global.RO.Error("Couldn't find the expected attribute 0x" + 
                                                        attribs[j].attribParamID.ToString("X").PadLeft(8,'0') + 
                                                        " in the search results or the value returned is wrong");
                                        ret = false;
                                        break;
                                    }
                                }
                                k++;
                            }
                        }
                    }
                    else
                    {
                        Global.RO.Warn("Search requests failed:" + Global.XErrToString(searchReq.XErr));
                        ret = false;
                    }
                }
            }
            catch(Exception e)
            {
                Global.RO.Warn("Unexpected exception caught:" + e.Message);
                ret = false;
            }
            XRL2DeleteSession    [] delReq = new XRL2DeleteSession[numSessions];
            for(int i = 0; i < numSessions; i++)
            {
                if(createResp[i] != null)
                {
                    delReq[i] = new XRL2DeleteSession(createResp[i].SessionID, createReqs[i].baseCreateUpdate.baseSession.dwTitleID);
                    delReq[i].Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                }
            }
            return ret;
        }
    }

    [TestGroup]
    public class Func2SearchSession : TestNode
    {

        [TestGroupSetup]
        public void Setup()
        {
            //make sure table is cleaned out before we begin.
            Global.RO.Info("Cleaning tables before run for title " + Constants.XENON_TITLE.ToString("X"));
            MatchUtil.TruncateSessionsForTitle(Constants.XENON_TITLE, SessionType.Social);
        }



        /************************************************************************
         * The following are positive cases
         ************************************************************************/
        [BVT]
        [TestCase, Description("Search so that 0 results returned")]
        class PNormalCase : TestBase
        {
            override protected void Execute()
            {
                // search based on sessionID
                XRL2SearchSession    searchReq = new XRL2SearchSession(true,Constants.X_SSINDEX_GET_SESSION);
                XRLXeAttribParam[] Params = new XRLXeAttribParam[1]{new XRLXeAttribParam(Constants.X_ATTRIBUTE_SESSION_ID,
                                                                                         new XRLXeIntValue(0x180))};
                searchReq.AddParams(Params);
                XRL2SearchResults    Resp;
                if(searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out Resp))
                {
                    if(Resp == null)
                        ResultCode=TEST_RESULTS.PASSED;
                }
            }
        }
        [BVT]
        [TestCase, Ignore, Description("Verify X_ATTRIBUTE_GAMER_PUID is returned if passed up")]
        class PAttribGamerPuid : TestBase
        {
            private XRLXeAttribParam GetXeAttributeById(WireData[] attribs, uint attribId)
            {
                foreach (WireData param in attribs)
                {
                    XRLXeAttribParam xeParam = param as XRLXeAttribParam;
                    if (xeParam != null && xeParam.attribParamID == attribId)
                    {
                        return xeParam;
                    }
                }
                return null;
            }

            override protected void Execute()
            {
                uint numDB = Constants.getNumDBForTitle(Constants.XENON_TITLE);
                uint numSessions = numDB;

                // Create a session
                XRL2CreateUpdateSession[] createReq = new XRL2CreateUpdateSession[numSessions];
                XRLSessionInfo[] createResp = new XRLSessionInfo[numSessions];
                XRLXeAttribParam[] Attribs = new XRLXeAttribParam[1] {
                    new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_PUID, RandomEx.GlobalRandGen.GenerateRandomPuid()) };
                bool ret = true;
                for (int i = 0; i > numDB; i++)
                {
                    createReq[i] = new XRL2CreateUpdateSession();
                    createReq[i].AddAttribs(Attribs);
                    if (!createReq[i].Execute(Global.XEnv.GetInterface(Interface.xmatchfd)[0], out createResp[i]))
                    {
                        ret = false;
                        Global.RO.Error("CreateSession failed");
                        break;
                    }
                }
                if (ret)
                {
                    // search so that 1 session will be returned
                    XRL2SearchSession searchReq = new XRL2SearchSession(true, Constants.SESSION_MATCH_QUERY_QUERY1WITHGAMERPUID);
                    long lSessID = Constants.sessionIDConvert(createResp[0].SessionID);
                    XRLXeAttribParam[] Params = new XRLXeAttribParam[1] {
                        new XRLXeAttribParam(Constants.X_ATTRIBUTE_SESSION_ID, new XRLXeIntValue(lSessID)) };
                    searchReq.AddParams(Params);
                    XRL2SearchResults Resp;
                    if (searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out Resp))
                    {
                        // check searchResults
                        if ((Resp.resultsLen == 1))
                        {
                            XRLXeAttribParam createPuid = (XRLXeAttribParam)GetXeAttributeById(
                                createReq[0].baseCreateUpdate.Attribs, Constants.X_ATTRIBUTE_GAMER_PUID);
                            XRLXeAttribParam searchPuid = (XRLXeAttribParam)GetXeAttributeById(
                                Resp.results[0].Attribs, Constants.X_ATTRIBUTE_GAMER_PUID);
                            if (createPuid != null && searchPuid != null)
                            {
                                if (((XRLXeIntValue)createPuid.aValue).intValue == ((XRLXeIntValue)searchPuid.aValue).intValue)
                                {
                                    ResultCode = TEST_RESULTS.PASSED;
                                }
                                else
                                {
                                    Global.RO.Error("Gamer PUID in search results is not the one the session was created with");
                                }
                            }
                            else
                            {
                                Global.RO.Error("Gamer PUID not found in either create attribs or search results");
                            }
                        }
                        else
                        {
                            Global.RO.Error("SearchResults length is not 1");
                        }
                    }
                    else
                    {
                        Global.RO.Error("Search execution failed: " + Global.XErrToString(searchReq.XErr));
                    }
                    XRL2DeleteSession[] delReq = new XRL2DeleteSession[numDB];
                    for (int i = 0; i < numSessions; i++)
                    {
                        delReq[i] = new XRL2DeleteSession(createResp[i].SessionID, searchReq.baseSearchSession.dwTitleID);
                        delReq[i].Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                    }
                }
            }
        }
        
        [TestCase, Description("Search so that 1 session without custom attributes returned (only gamemode/gametype/gamerZone/hostname/sessionValue returned)")]
        class PNoCustReturn : MatchTestBase
        {
            override protected void Execute()
            {
                // use sp=SESSION_MATCH_QUERY_NOCUSTRETURN
                // which takes myContext1 as parameter and use it in the filter
                long intValue = Constants.CONTEXT_MYCONTEXT1_TRACKA;
                uint numDB = Constants.getNumDBForTitle(Constants.XENON_TITLE);
                uint numSessions = numDB;
                XRL2CreateUpdateSession[] createReq = new XRL2CreateUpdateSession[numSessions];
                XRLSessionInfo[] createResp = new XRLSessionInfo[numSessions];
                XRLXeAttribParam[] Attribs = new XRLXeAttribParam[1] { new XRLXeAttribParam(
                                                                           Constants.CONTEXT_MYCONTEXT1, new XRLXeIntValue(intValue)) };
                bool ret = true;
                for (int i = 0; i < numSessions; i++)
                {
                    createReq[i] = new XRL2CreateUpdateSession();
                    createReq[i].AddAttribs(Attribs);
                    if (!createReq[i].Execute(Global.XEnv.GetInterface(Interface.xmatchfd)[0], out createResp[i]))
                    {
                        ret = false;
                        Global.RO.Warn("CreateSession failed");
                        break;
                    }
                }
                try
                {
                    if (ret)
                    {
                        // search so that both sessions will be returned
                        XRL2SearchSession searchReq = new XRL2SearchSession(true, Constants.SESSION_MATCH_QUERY_NOCUSTRETURN);
                        XRLXeAttribParam[] Params = Attribs;
                        searchReq.AddParams(Params);
                        XRL2SearchResults Resp;
                        if (searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out Resp))
                        {
                            // check searchResults
                            if (VerifySessions(createResp, Resp, Verify.Exclusive))
                            {
                                ResultCode = TEST_RESULTS.PASSED;
                            }
                        }
                    }
                }
                finally
                {
                    DeleteSessions(Constants.XENON_TITLE, createResp);
                }
            }
        }

        [TestCase, Description("Search so that more than 1 sessions with custom attributes returned")]
        class PMoreResults2 : CheckReturnAttribsTestBase
        {
            override protected void Execute()
            {
                long    intValue = 8888;
                uint    numDB = Constants.getNumDBForTitle(Constants.XENON_TITLE);
                uint	numSessions = numDB * 2;
                XRLXeAttribParam[]    Attribs = new XRLXeAttribParam[1]
                    {new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP1,new XRLXeIntValue(intValue))};
				
                if(this.createAndVerifyResults(numSessions,2,Attribs,Attribs,Constants.SESSION_MATCH_QUERY_QUERY1))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("pass non-null datetime parameter and non-null datetime attribute returned.")]
        class PNonNullDateTimeParamsAttribs : CheckReturnAttribsTestBase
        {
            override protected void Execute()
            {
                uint    numDB = Constants.getNumDBForTitle(Constants.XENON_TITLE);
                uint	numSessions = numDB;
                XRLXeAttribParam	[] Attribs = new XRLXeAttribParam[1]
                    {
                        new XRLXeAttribParam(Constants.PROPERTY_MYDATETIMEPROP1,new XRLXeDateTimeValue(DateTime.Now.ToFileTimeUtc())),
                    };
                if(this.createAndVerifyResults(numSessions,1,Attribs,Attribs,Constants.SESSION_MATCH_QUERY_QUERY1))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("pass non-null max datetime parameter and non-null datetime attribute returned.")]
        class PNonNullMaxDateTimeParamsAttribs : CheckReturnAttribsTestBase
        {
            override protected void Execute()
            {
                uint    numDB = Constants.getNumDBForTitle(Constants.XENON_TITLE);
                uint	numSessions = numDB;
                XRLXeAttribParam	[] Attribs = new XRLXeAttribParam[1]
                    {
                        new XRLXeAttribParam(Constants.PROPERTY_MYDATETIMEPROP1,new XRLXeDateTimeValue(DateTime.MaxValue.ToFileTimeUtc())),
                    };
                if(this.createAndVerifyResults(numSessions,1,Attribs,Attribs,Constants.SESSION_MATCH_QUERY_QUERY1))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("pass non-null dateTime and non-null datetime attribute returned.")]
        class PNonNullNowDateTimeParamsAttribs : CheckReturnAttribsTestBase
        {
            override protected void Execute()
            {
                uint    numDB = Constants.getNumDBForTitle(Constants.XENON_TITLE);
                uint	numSessions = numDB;
                XRLXeAttribParam	[] Attribs = new XRLXeAttribParam[1]
                    {
                        new XRLXeAttribParam(Constants.PROPERTY_MYDATETIMEPROP1,new XRLXeDateTimeValue(DateTime.UtcNow.ToFileTimeUtc())),
                    };
                if(this.createAndVerifyResults(numSessions,1,Attribs,Attribs,Constants.SESSION_MATCH_QUERY_QUERY1))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("pass non-null max float32 parameter and non-null float32 attribute returned.")]
        class PNonNullMaxFloat32ParamsAttribs : CheckReturnAttribsTestBase
        {
            override protected void Execute()
            {
                uint    numDB = Constants.getNumDBForTitle(Constants.XENON_TITLE);
                uint	numSessions = numDB;
                XRLXeAttribParam	[] Attribs = new XRLXeAttribParam[1]
                    {
                        new XRLXeAttribParam(Constants.PROPERTY_MYFLOAT32PROP1,new XRLXeFloatValue(float.MaxValue))
                    };
                if(this.createAndVerifyResults(numSessions,1,Attribs,Attribs,Constants.SESSION_MATCH_QUERY_QUERY1))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("pass non-null min float32 parameter and non-null float32 attribute returned.")]
        class PNonNullMinFloat32ParamsAttribs : CheckReturnAttribsTestBase
        {
            override protected void Execute()
            {
                uint    numDB = Constants.getNumDBForTitle(Constants.XENON_TITLE);
                uint	numSessions = numDB;
                XRLXeAttribParam	[] Attribs = new XRLXeAttribParam[1]
                    {
                        new XRLXeAttribParam(Constants.PROPERTY_MYFLOAT32PROP1,new XRLXeFloatValue(float.MinValue))
                    };
                if(this.createAndVerifyResults(numSessions,1,Attribs,Attribs,Constants.SESSION_MATCH_QUERY_QUERY1))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("pass non-null normal float32 parameter and non-null float32 attribute returned.")]
        class PNonNullFloat32ParamsAttribs : CheckReturnAttribsTestBase
        {
            override protected void Execute()
            {
                uint    numDB = Constants.getNumDBForTitle(Constants.XENON_TITLE);
                uint	numSessions = numDB;
                XRLXeAttribParam	[] Attribs = new XRLXeAttribParam[1]
                    {
                        new XRLXeAttribParam(Constants.PROPERTY_MYFLOAT32PROP1,new XRLXeFloatValue(1))
                    };
                if(this.createAndVerifyResults(numSessions,1,Attribs,Attribs,Constants.SESSION_MATCH_QUERY_QUERY1))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("pass non-null float64 parameter and non-null float64 attribute returned.")]
        class PNonNullMaxFloat64ParamsAttribs : CheckReturnAttribsTestBase
        {
            override protected void Execute()
            {
                uint    numDB = Constants.getNumDBForTitle(Constants.XENON_TITLE);
                uint	numSessions = numDB;
                XRLXeAttribParam	[] Attribs = new XRLXeAttribParam[1]
                    {
                        new XRLXeAttribParam(Constants.PROPERTY_MYFLOAT64PROP1,new XRLXeDoubleValue(double.MaxValue))
                    };
                if(this.createAndVerifyResults(numSessions,1,Attribs,Attribs,Constants.SESSION_MATCH_QUERY_QUERY1))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("pass non-null min float64 parameter and non-null float64 attribute returned.")]
        class PNonNullMinFloat64ParamsAttribs : CheckReturnAttribsTestBase
        {
            override protected void Execute()
            {
                uint    numDB = Constants.getNumDBForTitle(Constants.XENON_TITLE);
                uint	numSessions = numDB;
                XRLXeAttribParam	[] Attribs = new XRLXeAttribParam[1]
                    {
                        new XRLXeAttribParam(Constants.PROPERTY_MYFLOAT64PROP1,new XRLXeDoubleValue(double.MinValue))
                    };
                if(this.createAndVerifyResults(numSessions,1,Attribs,Attribs,Constants.SESSION_MATCH_QUERY_QUERY1))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("pass non-null normal float64 parameter and non-null float64 attribute returned.")]
        class PNonNullFloat64ParamsAttribs : CheckReturnAttribsTestBase
        {
            override protected void Execute()
            {
                uint    numDB = Constants.getNumDBForTitle(Constants.XENON_TITLE);
                uint	numSessions = numDB;
                XRLXeAttribParam	[] Attribs = new XRLXeAttribParam[1]
                    {
                        new XRLXeAttribParam(Constants.PROPERTY_MYFLOAT64PROP1,new XRLXeDoubleValue(1))
                    };
                if(this.createAndVerifyResults(numSessions,1,Attribs,Attribs,Constants.SESSION_MATCH_QUERY_QUERY1))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("pass non-null max int32 parameter and non-null int32 attribute returned.")]
        class PNonNullMaxInt32ParamsAttribs : CheckReturnAttribsTestBase
        {
            override protected void Execute()
            {
                uint    numDB = Constants.getNumDBForTitle(Constants.XENON_TITLE);
                uint	numSessions = numDB;
                XRLXeAttribParam	[] Attribs = new XRLXeAttribParam[1]
                    {
                        new XRLXeAttribParam(Constants.PROPERTY_MYINT32PROP1,new XRLXeIntValue(Int32.MaxValue))
                    };
                if(this.createAndVerifyResults(numSessions,1,Attribs,Attribs,Constants.SESSION_MATCH_QUERY_QUERY1))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("pass non-null min int32 parameter and non-null int32 attribute returned.")]
        class PNonNullMinInt32ParamsAttribs : CheckReturnAttribsTestBase
        {
            override protected void Execute()
            {
                uint    numDB = Constants.getNumDBForTitle(Constants.XENON_TITLE);
                uint	numSessions = numDB;
                XRLXeAttribParam	[] Attribs = new XRLXeAttribParam[1]
                    {
                        new XRLXeAttribParam(Constants.PROPERTY_MYINT32PROP1,new XRLXeIntValue(Int32.MinValue))
                    };
                if(this.createAndVerifyResults(numSessions,1,Attribs,Attribs,Constants.SESSION_MATCH_QUERY_QUERY1))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("pass non-null int32 parameter and non-null int32 attribute returned.")]
        class PNonNullInt32ParamsAttribs : CheckReturnAttribsTestBase
        {
            override protected void Execute()
            {
                uint    numDB = Constants.getNumDBForTitle(Constants.XENON_TITLE);
                uint	numSessions = numDB;
                XRLXeAttribParam	[] Attribs = new XRLXeAttribParam[1]
                    {
                        new XRLXeAttribParam(Constants.PROPERTY_MYINT32PROP1,new XRLXeIntValue(1234))
                    };
                if(this.createAndVerifyResults(numSessions,1,Attribs,Attribs,Constants.SESSION_MATCH_QUERY_QUERY1))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("pass non-null max int64 parameter and non-null int64 attribute returned.")]
        class PNonNullMaxInt64ParamsAttribs : CheckReturnAttribsTestBase
        {
            override protected void Execute()
            {
                uint    numDB = Constants.getNumDBForTitle(Constants.XENON_TITLE);
                uint	numSessions = numDB;
                XRLXeAttribParam	[] Attribs = new XRLXeAttribParam[1]
                    {
                        new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP1,new XRLXeIntValue(Int64.MaxValue))
                    };
                if(this.createAndVerifyResults(numSessions,1,Attribs,Attribs,Constants.SESSION_MATCH_QUERY_QUERY1))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("pass non-null min int64 parameter and non-null int64 attribute returned.")]
        class PNonNullMinInt64ParamsAttribs : CheckReturnAttribsTestBase
        {
            override protected void Execute()
            {
                uint    numDB = Constants.getNumDBForTitle(Constants.XENON_TITLE);
                uint	numSessions = numDB;
                XRLXeAttribParam	[] Attribs = new XRLXeAttribParam[1]
                    {
                        new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP1,new XRLXeIntValue(Int64.MinValue))
                    };
                if(this.createAndVerifyResults(numSessions,1,Attribs,Attribs,Constants.SESSION_MATCH_QUERY_QUERY1))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("pass non-null int64 parameter and non-null int64 attribute returned.")]
        class PNonNullInt64ParamsAttribs : CheckReturnAttribsTestBase
        {
            override protected void Execute()
            {
                uint    numDB = Constants.getNumDBForTitle(Constants.XENON_TITLE);
                uint	numSessions = numDB;
                XRLXeAttribParam	[] Attribs = new XRLXeAttribParam[1]
                    {
                        new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP1,new XRLXeIntValue(0x1234567812345678))
                    };
                if(this.createAndVerifyResults(numSessions,1,Attribs,Attribs,Constants.SESSION_MATCH_QUERY_QUERY1))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("pass non-null context parameter and non-null context attribute returned.")]
        class PNonNullContextParamsAttribs : CheckReturnAttribsTestBase
        {
            override protected void Execute()
            {
                uint    numDB = Constants.getNumDBForTitle(Constants.XENON_TITLE);
                uint	numSessions = numDB;
                XRLXeAttribParam	[] Attribs = new XRLXeAttribParam[1]
                    {
                        new XRLXeAttribParam(Constants.CONTEXT_MYCONTEXT1,new XRLXeIntValue(Int64.MaxValue))
                    };
                if(this.createAndVerifyResults(numSessions,1,Attribs,Attribs,Constants.SESSION_MATCH_QUERY_QUERY1))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("search so that 1 session with empty string attribute is returned in the middle of attrib list")]
        class POneSessionEmptyStringAttribMiddle : CheckReturnAttribsTestBase
        {
            override protected void Execute()
            {
                uint    numDB = Constants.getNumDBForTitle(Constants.XENON_TITLE);
                uint	numSessions = numDB * 1;
                string	strVal = ""+'\0';
                XRLXeAttribParam	[] Attribs = new XRLXeAttribParam[2]
                    {
                        new XRLXeAttribParam(Constants.PROPERTY_GAMERNAME,new XRLXeStringValue(strVal)),
                        new XRLXeAttribParam(Constants.PROPERTY_MYFLOAT32PROP1, new XRLXeFloatValue(2.00f))
                    };
                XRLXeAttribParam	[] Params = new XRLXeAttribParam[1];
                Params[0] = Attribs[1];

                if(this.createAndVerifyResults(numSessions,1,Attribs,Params,Constants.SESSION_MATCH_QUERY_QUERY1))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("search so that 1 session with empty string attribute is returned first in the attribute list")]
        class POneSessionEmptyStringAttribFirst : CheckReturnAttribsTestBase
        {
            override protected void Execute()
            {
                uint    numDB = Constants.getNumDBForTitle(Constants.XENON_TITLE);
                uint	numSessions = numDB * 1;
                string	strVal =""+'\0';
                XRLXeAttribParam	[] Attribs = new XRLXeAttribParam[2]
                    {
                        new XRLXeAttribParam(Constants.PROPERTY_GAMERNAME,new XRLXeStringValue(strVal)),
                        new XRLXeAttribParam(Constants.PROPERTY_MYFLOAT64PROP1, new XRLXeDoubleValue(2.00))
                    };
                XRLXeAttribParam	[] Params = new XRLXeAttribParam[1];
                Params[0] = Attribs[1];

                if(this.createAndVerifyResults(numSessions,1,Attribs,Params,Constants.SESSION_MATCH_QUERY_RETURNSTRINGFIRST))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("search so that OneSession with empty string attribute is returned last in the attribute list")]
        class POneSessionEmptyStringAttribLast : CheckReturnAttribsTestBase
        {
            override protected void Execute()
            {
                uint    numDB = Constants.getNumDBForTitle(Constants.XENON_TITLE);
                uint	numSessions = numDB * 1;
                string	strVal = ""+'\0';
                XRLXeAttribParam	[] Attribs = new XRLXeAttribParam[2]
                    {
                        new XRLXeAttribParam(Constants.PROPERTY_GAMERNAME,new XRLXeStringValue(strVal)),
                        new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP1, new XRLXeIntValue(343))
                    };
                XRLXeAttribParam	[] Params = new XRLXeAttribParam[1];
                Params[0] = Attribs[1];

                if(this.createAndVerifyResults(numSessions,1,Attribs,Params,Constants.SESSION_MATCH_QUERY_RETURNSTRINGLAST))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("search so that 1 session with max-1 length string attribute is returned in the middle of attrib list")]
        class POneSessionStringAttribMiddle : CheckReturnAttribsTestBase
        {
            override protected void Execute()
            {
                uint    numDB = Constants.getNumDBForTitle(Constants.XENON_TITLE);
                uint	numSessions = numDB * 1;
                string	strVal = new string('a',(int)Constants.X_MAX_STRING_ATTRIBUTE_LEN-1)+'\0';
                XRLXeAttribParam	[] Attribs = new XRLXeAttribParam[2]
                    {
                        new XRLXeAttribParam(Constants.PROPERTY_GAMERNAME,new XRLXeStringValue(strVal)),
                        new XRLXeAttribParam(Constants.PROPERTY_MYFLOAT32PROP1, new XRLXeFloatValue(2.00f))
                    };
                XRLXeAttribParam	[] Params = new XRLXeAttribParam[1];
                Params[0] = Attribs[1];

                if(this.createAndVerifyResults(numSessions,1,Attribs,Params,Constants.SESSION_MATCH_QUERY_QUERY1))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("search so that 1 session with max-1 length string attribute is returned first in the attribute list")]
        class POneSessionStringAttribFirst : CheckReturnAttribsTestBase
        {
            override protected void Execute()
            {
                uint    numDB = Constants.getNumDBForTitle(Constants.XENON_TITLE);
                uint	numSessions = numDB * 1;
                string	strVal = new string('a',(int)Constants.X_MAX_STRING_ATTRIBUTE_LEN-1)+'\0';
                XRLXeAttribParam	[] Attribs = new XRLXeAttribParam[2]
                    {
                        new XRLXeAttribParam(Constants.PROPERTY_GAMERNAME,new XRLXeStringValue(strVal)),
                        new XRLXeAttribParam(Constants.PROPERTY_MYFLOAT64PROP1, new XRLXeDoubleValue(2.00))
                    };
                XRLXeAttribParam	[] Params = new XRLXeAttribParam[1];
                Params[0] = Attribs[1];

                if(this.createAndVerifyResults(numSessions,1,Attribs,Params,Constants.SESSION_MATCH_QUERY_RETURNSTRINGFIRST))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("search so that OneSession with max-1 length string attribute is returned last in the attribute list")]
        class POneSessionStringAttribLast : CheckReturnAttribsTestBase
        {
            override protected void Execute()
            {
                uint    numDB = Constants.getNumDBForTitle(Constants.XENON_TITLE);
                uint	numSessions = numDB * 1;
                string	strVal = new string('a',(int)Constants.X_MAX_STRING_ATTRIBUTE_LEN-1)+'\0';
                XRLXeAttribParam	[] Attribs = new XRLXeAttribParam[2]
                    {
                        new XRLXeAttribParam(Constants.PROPERTY_GAMERNAME,new XRLXeStringValue(strVal)),
                        new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP1, new XRLXeIntValue(343))
                    };
                XRLXeAttribParam	[] Params = new XRLXeAttribParam[1];
                Params[0] = Attribs[1];

                if(this.createAndVerifyResults(numSessions,1,Attribs,Params,Constants.SESSION_MATCH_QUERY_RETURNSTRINGLAST))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("search so that 2 sessions with max length string attribute is returned in the middle of attrib list")]
        class P2SessionsMaxStringAttribMiddle : CheckReturnAttribsTestBase
        {
            override protected void Execute()
            {
                uint    numDB = Constants.getNumDBForTitle(Constants.XENON_TITLE);
                uint	numSessions = numDB * 2;
                string	strVal = new string('a',(int)Constants.X_MAX_STRING_ATTRIBUTE_LEN)+'\0';
                XRLXeAttribParam	[] Attribs = new XRLXeAttribParam[2]
                    {
                        new XRLXeAttribParam(Constants.PROPERTY_GAMERNAME,new XRLXeStringValue(strVal)),
                        new XRLXeAttribParam(Constants.PROPERTY_MYFLOAT32PROP1, new XRLXeFloatValue(2.00f))
                    };
                XRLXeAttribParam	[] Params = new XRLXeAttribParam[1];
                Params[0] = Attribs[1];

                if(this.createAndVerifyResults(numSessions,2,Attribs,Params,Constants.SESSION_MATCH_QUERY_QUERY1))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("search so that 2Sessions with max length string attribute is returned first in the attribute list")]
        class P2SessionsMaxStringAttribFirst : CheckReturnAttribsTestBase
        {
            override protected void Execute()
            {
                uint    numDB = Constants.getNumDBForTitle(Constants.XENON_TITLE);
                uint	numSessions = numDB * 2;
                string	strVal = new string('a',(int)Constants.X_MAX_STRING_ATTRIBUTE_LEN)+'\0';
                XRLXeAttribParam	[] Attribs = new XRLXeAttribParam[2]
                    {
                        new XRLXeAttribParam(Constants.PROPERTY_GAMERNAME,new XRLXeStringValue(strVal)),
                        new XRLXeAttribParam(Constants.PROPERTY_MYFLOAT64PROP1, new XRLXeDoubleValue(2.00))
                    };
                XRLXeAttribParam	[] Params = new XRLXeAttribParam[1];
                Params[0] = Attribs[1];

                if(this.createAndVerifyResults(numSessions,2,Attribs,Params,Constants.SESSION_MATCH_QUERY_RETURNSTRINGFIRST))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("search so that 2Sessions with max length string attribute is returned last in the attribute list")]
        class P2SessionsMaxStringAttribLast : CheckReturnAttribsTestBase
        {
            override protected void Execute()
            {
                uint    numDB = Constants.getNumDBForTitle(Constants.XENON_TITLE);
                uint	numSessions = numDB * 2;
                string	strVal = new string('a',(int)Constants.X_MAX_STRING_ATTRIBUTE_LEN)+'\0';
                XRLXeAttribParam	[] Attribs = new XRLXeAttribParam[2]
                    {
                        new XRLXeAttribParam(Constants.PROPERTY_GAMERNAME,new XRLXeStringValue(strVal)),
                        new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP1, new XRLXeIntValue(343))
                    };
                XRLXeAttribParam	[] Params = new XRLXeAttribParam[1];
                Params[0] = Attribs[1];

                if(this.createAndVerifyResults(numSessions,2,Attribs,Params,Constants.SESSION_MATCH_QUERY_RETURNSTRINGLAST))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("pass all non-null search paramters and all non-null int32/64/float32/64/datetime/context attributes returned.")]
        class PAllNonNullParamsAttribs : CheckReturnAttribsTestBase
        {
            override protected void Execute()
            {
                uint    numDB = Constants.getNumDBForTitle(Constants.XENON_TITLE);
                uint	numSessions = numDB * 2;
                XRLXeAttribParam	[] Attribs = new XRLXeAttribParam[6]
                    {
                        new XRLXeAttribParam(Constants.PROPERTY_MYDATETIMEPROP1,new XRLXeDateTimeValue(DateTime.Now.ToFileTimeUtc())),
                        new XRLXeAttribParam(Constants.PROPERTY_MYFLOAT32PROP1, new XRLXeFloatValue(1)),
                        new XRLXeAttribParam(Constants.PROPERTY_MYFLOAT64PROP1, new XRLXeDoubleValue(1)),
                        new XRLXeAttribParam(Constants.PROPERTY_MYINT32PROP1, new XRLXeIntValue(Int32.MinValue)),
                        new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP1, new XRLXeIntValue(Int64.MinValue)),
                        new XRLXeAttribParam(Constants.CONTEXT_MYCONTEXT1, new XRLXeIntValue(Constants.CONTEXT_MYCONTEXT1_TRACKC))
                    };
                if(this.createAndVerifyResults(numSessions,2,Attribs,Attribs,Constants.SESSION_MATCH_QUERY_QUERY1))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("pass all non-null search paramters and additionalX_ATTRIBUTE_DATATYPE_NULL param.")]
        class PNullAttribIDParam : CheckReturnAttribsTestBase
        {
            override protected void Execute()
            {
                uint    numDB = Constants.getNumDBForTitle(Constants.XENON_TITLE);
                uint	numSessions = numDB * 2;
                XRLXeAttribParam	[] Attribs = new XRLXeAttribParam[7]
                    {
                        new XRLXeAttribParam(Constants.PROPERTY_MYDATETIMEPROP1,new XRLXeDateTimeValue(DateTime.Now.ToFileTimeUtc())),
                        new XRLXeAttribParam(Constants.PROPERTY_MYFLOAT32PROP1, new XRLXeFloatValue(1)),
                        new XRLXeAttribParam(Constants.PROPERTY_MYFLOAT64PROP1, new XRLXeDoubleValue(1)),
                        new XRLXeAttribParam(Constants.PROPERTY_MYINT32PROP1, new XRLXeIntValue(Int32.MinValue)),
                        new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP1, new XRLXeIntValue(Int64.MinValue)),
                        new XRLXeAttribParam(Constants.CONTEXT_MYCONTEXT1, new XRLXeIntValue(Constants.CONTEXT_MYCONTEXT1_TRACKC)),
                        new XRLXeAttribParam(Constants.X_ATTRIBUTE_DATATYPE_NULL, new XRLXeNullValue())
                    };
                if(this.createAndVerifyResults(numSessions,2,Attribs,Attribs,Constants.SESSION_MATCH_QUERY_QUERY1))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("pass all X_ATTRIBUTE_DATATYPE_NULL IDs as search parameter.")]
        class PAllNullAttribIDs : CheckReturnAttribsTestBase
        {
            override protected void Execute()
            {
                uint    numDB = Constants.getNumDBForTitle(Constants.XENON_TITLE);
                uint	numSessions = numDB * 2;
                XRLXeAttribParam	[] Attribs = new XRLXeAttribParam[7]
                    {
                        new XRLXeAttribParam(Constants.X_ATTRIBUTE_DATATYPE_NULL, new XRLXeNullValue()),
                        new XRLXeAttribParam(Constants.X_ATTRIBUTE_DATATYPE_NULL, new XRLXeNullValue()),
                        new XRLXeAttribParam(Constants.X_ATTRIBUTE_DATATYPE_NULL, new XRLXeNullValue()),
                        new XRLXeAttribParam(Constants.X_ATTRIBUTE_DATATYPE_NULL, new XRLXeNullValue()),
                        new XRLXeAttribParam(Constants.X_ATTRIBUTE_DATATYPE_NULL, new XRLXeNullValue()),
                        new XRLXeAttribParam(Constants.X_ATTRIBUTE_DATATYPE_NULL, new XRLXeNullValue()),
                        new XRLXeAttribParam(Constants.X_ATTRIBUTE_DATATYPE_NULL, new XRLXeNullValue())
                    };
                if(this.createAndVerifyResults(numSessions,2,Attribs,Attribs,Constants.SESSION_MATCH_QUERY_QUERY1))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("search with a query that use contextValue in the filter")]
        class PContextValueInFilter : CheckReturnAttribsTestBase
        {
            override protected void Execute()
            {
                uint    numDB = Constants.getNumDBForTitle(Constants.XENON_TITLE);
                uint	numSessions = numDB * 2;
                XRLXeAttribParam	[] Attribs = new XRLXeAttribParam[1]
                    {
                        new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP1, new XRLXeIntValue(222))
                    };

                if(this.createAndVerifyResults(numSessions,2,Attribs,null,Constants.SESSION_MATCH_QUERY_CONTEXTVALUEINFILTER))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("use cross type comparsion in query filter")]
        class PCrossTypeFilter : CheckReturnAttribsTestBase
        {
            override protected void Execute()
            {
                uint    numDB = Constants.getNumDBForTitle(Constants.XENON_TITLE);
                uint	numSessions = numDB * 1;
                XRLXeAttribParam	[] Attribs = new XRLXeAttribParam[4]
                    {
                        new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP1, new XRLXeIntValue(222)),
                        new XRLXeAttribParam(Constants.PROPERTY_MYINT32PROP1, new XRLXeIntValue(33)),
                        new XRLXeAttribParam(Constants.PROPERTY_MYFLOAT32PROP1, new XRLXeFloatValue(11f)),
                        new XRLXeAttribParam(Constants.PROPERTY_MYFLOAT64PROP1,new XRLXeDoubleValue(898))
                    };
                XRLXeAttribParam	[] Params = new XRLXeAttribParam[4]
                    {
                        new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP1, new XRLXeIntValue(897)),
                        new XRLXeAttribParam(Constants.PROPERTY_MYINT32PROP1, new XRLXeIntValue(11)),
                        new XRLXeAttribParam(Constants.PROPERTY_MYFLOAT32PROP1, new XRLXeFloatValue(222f)),
                        new XRLXeAttribParam(Constants.PROPERTY_MYFLOAT64PROP1,new XRLXeDoubleValue(34))
                    };

                if(this.createAndVerifyResults(numSessions,1,Attribs,Params,Constants.SESSION_MATCH_QUERY_CROSSTYPEFILTER))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }

        [TestCase, Description("pass no parameters to query1 such that NULL value retunred for all title defined attribs.")]
        class PAllNullParamsAttribs : MatchTestBase
        {
            override protected void Execute()
            {
                MatchUtil.TruncateSessionsForTitle(Constants.XENON_TITLE, SessionType.Ranked);

                //create one session per DB
                uint numDBs = Constants.getNumDBForTitle(Constants.XENON_TITLE);
                uint numSessions = numDBs;

                // create a session without any title defined attributes
                XRL2CreateUpdateSession[] createReq = new XRL2CreateUpdateSession[numSessions];
                XRLSessionInfo[] createResp = new XRLSessionInfo[numSessions];
                for (int i = 0; i < numSessions; i++)
                {
                    createReq[i] = new XRL2CreateUpdateSession();
                    createResp[i] = new XRLSessionInfo();
                    if (!createReq[i].Execute(Global.XEnv.GetInterface(Interface.xmatchfd)[0], out createResp[i]))
                    {
                        Global.RO.Warn("Failed to create sessions");
                        return;
                    }
                }
                XRL2SearchSession searchReq = new XRL2SearchSession(true, Constants.SESSION_MATCH_QUERY_QUERY1);
                XRL2SearchResults Resp;
                bool ret = true;
                uint numAttrib = 7;	// there are 7 title defined schema attributes returned as NULL for this query

                if (searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out Resp))
                {
                    if (VerifySessions(createResp, Resp, Verify.Exclusive))
                    {
                        if (Resp.dwMessageLength != Constants.SIZESEARCHHEADER + 
                            (Constants.SIZEBASESEARCHRESULT +
                             // additional session_value attribute, game_type and game_mode,hostname "newmom\0'
                             numAttrib * (4 + 4) + 4 * (4 + 4 + 8) + (4 + 4 + 2 + 7 + 3)) * numSessions)
                        {
                            Global.RO.Error("dwMessageLength is not correct");
                        }
                        else
                        {
                            for (int j = 2; j < numAttrib; j++)
                                if ((Resp.results[0].Attribs[j].aValue as XRLXeNullValue) == null)
                                {
                                    ret = false;
                                    break;
                                }
                            if (ret)
                                ResultCode = TEST_RESULTS.PASSED;
                        }
                    }
                }
                DeleteSessions(Constants.XENON_TITLE, createResp);
            }
        }

        [TestCase, Description("create sessions with different attribute values, pass no search parameter to query1; check all sessions are returned.")]
        class PAllNullParams : MatchTestBase
        {
            override protected void Execute()
            {
                MatchUtil.TruncateSessionsForTitle(Constants.XENON_TITLE, SessionType.Ranked);

                uint numDB = Constants.getNumDBForTitle(Constants.XENON_TITLE);
                uint numSessions = numDB * 5;

                // create 5 sessions on each db with different attribute values.
                XRL2CreateUpdateSession[] createReq = new XRL2CreateUpdateSession[numSessions];
                XRLSessionInfo[] createResp = new XRLSessionInfo[numSessions];
                XRLXeAttribParam[] attribs = new XRLXeAttribParam[6];
                float fValue = 1.0f;
                double dValue = 100.0;

                for (int i = 0; i < numSessions; i++)
                {
                    createReq[i] = new XRL2CreateUpdateSession();
                    attribs[0] = new XRLXeAttribParam(Constants.PROPERTY_MYFLOAT32PROP1, new XRLXeFloatValue(fValue + i));
                    attribs[1] = new XRLXeAttribParam(Constants.PROPERTY_MYFLOAT64PROP1, new XRLXeDoubleValue(dValue + i));
                    attribs[2] = new XRLXeAttribParam(Constants.PROPERTY_MYINT32PROP1, new XRLXeIntValue(i));
                    attribs[3] = new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP1, new XRLXeIntValue(i));
                    attribs[4] = new XRLXeAttribParam(Constants.PROPERTY_MYDATETIMEPROP1, new XRLXeDateTimeValue(DateTime.Now.ToFileTimeUtc()));
                    attribs[5] = new XRLXeAttribParam(Constants.CONTEXT_MYCONTEXT1, new XRLXeIntValue(Constants.CONTEXT_MYCONTEXT1_TRACKC));
                    createReq[i].AddAttribs(attribs);
                    createResp[i] = new XRLSessionInfo();
                    if (!createReq[i].Execute(Global.XEnv.GetInterface(Interface.xmatchfd)[0], out createResp[i]))
                    {
                        Global.RO.Warn("Failed to create sessions");
                        return;
                    }
                }
                XRL2SearchSession searchReq = new XRL2SearchSession(true, Constants.SESSION_MATCH_QUERY_QUERY1);
                XRL2SearchResults Resp;

                if (searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out Resp))
                {
                    if (VerifySessions(createResp, Resp, Verify.Exclusive))
                    {
                        ResultCode = TEST_RESULTS.PASSED;
                    }
                }
                DeleteSessions(Constants.XENON_TITLE, createResp);
            }
        }

        [TestCase, Description("search with a sp that takes no title defined parameters and return only system attributes")]
        class PNoParamsSearch : MatchTestBase
        {
            override protected void Execute()
            {
                MatchUtil.TruncateSessionsForTitle(Constants.XENON_TITLE, SessionType.Ranked);

                uint numDB = Constants.getNumDBForTitle(Constants.XENON_TITLE);
                uint numSessions = numDB;

                uint numAttrib = 4;	// session_value+gamerZone+gamerType+gameMode

                XRL2CreateUpdateSession[] createReq = new XRL2CreateUpdateSession[numSessions];
                XRLSessionInfo[] createResp = new XRLSessionInfo[numSessions];
                for (int i = 0; i < numSessions; i++)
                {
                    createReq[i] = new XRL2CreateUpdateSession();
                    createResp[i] = new XRLSessionInfo();
                    if (!createReq[i].Execute(Global.XEnv.GetInterface(Interface.xmatchfd)[0], out createResp[i]))
                    {
                        Global.RO.Warn("Failed to create sessions");
                    }
                }
                XRL2SearchSession searchReq = new XRL2SearchSession(true, Constants.SESSION_MATCH_QUERY_NOPARAMQUERY);
                XRL2SearchResults Resp;
                if (searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out Resp))
                {
                    if (VerifySessions(createResp, Resp, Verify.Exclusive))
                    {
                        if (Resp.dwMessageLength == Constants.SIZESEARCHHEADER +
                            (Constants.SIZEBASESEARCHRESULT + numAttrib * (4 + 4 + 8) + (4 + 4 + 2 + 7 + 3)) * numSessions)
                        {
                            ResultCode = TEST_RESULTS.PASSED;
                        }
                        else
                        {
                            Global.RO.Error("Resp.dwMessageLength was not except to be {0}", Resp.dwMessageLength);
                        }
                    }
                }
                DeleteSessions(Constants.XENON_TITLE, createResp);
            }
        }

        [TestCase, Description("search with a sp that takes the maximum allowed number of title defined parameters")]
        class PMaxParamsSearch : MatchTestBase
        {
            override protected void Execute()
            {
                MatchUtil.TruncateSessionsForTitle(Constants.XENON_TITLE, SessionType.Ranked);

                uint numDB = Constants.getNumDBForTitle(Constants.XENON_TITLE);
                uint numSessions = numDB;

                uint numAttrib = 4;	// session_value+gamerZone+gamerType+gameMode

                XRL2CreateUpdateSession[] createReq = new XRL2CreateUpdateSession[numSessions];
                XRLSessionInfo[] createResp = new XRLSessionInfo[numSessions];
                for (int i = 0; i < numSessions; i++)
                {
                    createReq[i] = new XRL2CreateUpdateSession();
                    createResp[i] = new XRLSessionInfo();
                    if (!createReq[i].Execute(Global.XEnv.GetInterface(Interface.xmatchfd)[0], out createResp[i]))
                        Global.RO.Warn("Failed to create sessions");
                }

                XRL2SearchSession searchReq = new XRL2SearchSession(true, Constants.SESSION_MATCH_QUERY_MAXPARAMS);

                // there are 10 parameters added automatically for the profile items
                XRLXeAttribParam[] Params = new XRLXeAttribParam[20];
                Params[0] = new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP1, new XRLXeIntValue(0));
                Params[1] = new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP2, new XRLXeIntValue(0));
                Params[2] = new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP3, new XRLXeIntValue(0));
                Params[3] = new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP4, new XRLXeIntValue(0));
                Params[4] = new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP5, new XRLXeIntValue(0));
                Params[5] = new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP6, new XRLXeIntValue(0));
                Params[6] = new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP7, new XRLXeIntValue(0));
                Params[7] = new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP8, new XRLXeIntValue(0));
                Params[8] = new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP9, new XRLXeIntValue(0));
                Params[9] = new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP10, new XRLXeIntValue(0));
                Params[10] = new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP11, new XRLXeIntValue(0));
                Params[11] = new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP12, new XRLXeIntValue(0));
                Params[12] = new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP13, new XRLXeIntValue(0));
                Params[13] = new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP14, new XRLXeIntValue(0));
                Params[14] = new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP15, new XRLXeIntValue(0));
                Params[15] = new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP16, new XRLXeIntValue(0));
                Params[16] = new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP17, new XRLXeIntValue(0));
                Params[17] = new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP18, new XRLXeIntValue(0));
                Params[18] = new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP19, new XRLXeIntValue(0));
                Params[19] = new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP20, new XRLXeIntValue(0));
                searchReq.AddParams(Params);

                XRL2SearchResults Resp;
                if (searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out Resp))
                {
                    if (VerifySessions(createResp, Resp, Verify.Exclusive))
                    {
                        if (Resp.dwMessageLength == Constants.SIZESEARCHHEADER +
                            (Constants.SIZEBASESEARCHRESULT + numAttrib * (4 + 4 + 8) + (4 + 4 + 2 + 7 + 3)) * numSessions)
                        {
                            ResultCode = TEST_RESULTS.PASSED;
                        }
                        else
                        {
                            Global.RO.Error("Resp.dwMessageLength was not except to be {0}", Resp.dwMessageLength);
                        }
                    }
                }
                DeleteSessions(Constants.XENON_TITLE, createResp);
            }
        }

        // fuzzy match1: create 10 sessions with the same int32 attribute value
        // pass a center parameter with the same value
        // check 6 sessions are returned and distanceAttribute for each session is 0
        [TestCase, Description("Fuzzy matching with all sessions has the same int32 value as the centerValue")]
        class PSameTypeFuzzyMatch : TestBase
        {
            override protected void Execute()
            {
                uint    numDB = Constants.getNumDBForTitle(Constants.XENON_TITLE);
                uint	numSessions = numDB * 10;//create 10 sessions on each db

                uint    fuzzyAttribID = Constants.PROPERTY_MYINT32PROP1;
                long    centerValue = 8989;
                XRL2CreateUpdateSession    [] createReq = new XRL2CreateUpdateSession[numSessions];
                XRLSessionInfo            [] createResp = new XRLSessionInfo[numSessions];
                XRLXeAttribParam [] Attribs = new XRLXeAttribParam[1]{new XRLXeAttribParam(fuzzyAttribID,new XRLXeIntValue(centerValue))};

                for(int i = 0; i < numSessions; i++)
                {
                    createReq[i] = new XRL2CreateUpdateSession();
					
                    createReq[i].AddAttribs(Attribs);
                    if(!createReq[i].Execute(Global.XEnv.GetInterface(Interface.xmatchfd)[0],out createResp[i]))
                        return;
                }
                XRL2SearchSession    searchReq = new XRL2SearchSession(true,Constants.SESSION_MATCH_QUERY_FUZZYMATCHSAMETYPE);

                // maximum returned session is 6
                XRLXeAttribParam[] Params = Attribs;
                searchReq.AddParams(Params);
                XRL2SearchResults    Resp;
                if(searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out Resp))
                {
                    bool    ret = true;
                    if(Resp.resultsLen != 6)
                    {
                        Global.RO.Warn("Number of sessions returned is not 6");
                        ret = false;
                    }
                    else
                    {
                        for(int i = 0; i < 6; i++)
                        {
                            XRLXeIntValue        intParam;
                            if(Resp.results[i].AttribOffsetsLen !=6)
                            {
                                Global.RO.Warn("number of attributes in the session is not 6");
                                ret = false;
                                break;
                            }
                            else if((intParam = Resp.results[i].Attribs[1].aValue as XRLXeIntValue) == null)
                            {
                                Global.RO.Warn("The Returned attribute is not Int");
                                ret = false;
                                break;
                            }
                            else if(intParam.intValue !=centerValue)
                            {
                                Global.RO.Warn("The Returned attribute value is not right");
                                ret = false;
                                break;
                            }
                        }
                    }
                    if(ret)
                        ResultCode=TEST_RESULTS.PASSED;
                }
                for(int i = 0; i < numSessions; i++)
                {
                    XRL2DeleteSession    delReq = new XRL2DeleteSession(createResp[i].SessionID,searchReq.baseSearchSession.dwTitleID);
                    delReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                }
            }
        }
        //no xlast support yet
        [TestCase, Description("Fuzzy matching with all sessions has the same int32 value as the centerValue")]
        class PFuzzyMatchConstantInSort : TestBase
        {
            override protected void Execute()
            {
                ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("Fuzzy matching with int32 attribute with float32 center value")]
        class PCrossTypeFuzzyMatch : TestBase
        {
            override protected void Execute()
            {
                MatchUtil.TruncateSessionsForTitle(Constants.XENON_TITLE, SessionType.Ranked);

                uint    numDB = Constants.getNumDBForTitle(Constants.XENON_TITLE);
                uint	numSessions = numDB * 10;//create 10 sessions on each db
                uint    fuzzyAttribID = Constants.PROPERTY_MYFLOAT32PROP1;
                float   centerValue = 8989.11f;
                int		temp=8989;
                XRL2CreateUpdateSession    [] createReq = new XRL2CreateUpdateSession[numSessions];
                XRLSessionInfo            [] createResp = new XRLSessionInfo[numSessions];

                // create sessions with different intValue
                for(int i = 0; i < numSessions; i++)
                {
                    if((i!=0) && (i%numDB ==0))
                        temp++;
                    XRLXeAttribParam [] Attribs = new XRLXeAttribParam[1]{new XRLXeAttribParam(Constants.PROPERTY_MYINT32PROP1,
                                                                                               new XRLXeIntValue(temp))};
                    createReq[i] = new XRL2CreateUpdateSession();
					
                    createReq[i].AddAttribs(Attribs);
                    if(!createReq[i].Execute(Global.XEnv.GetInterface(Interface.xmatchfd)[0],out createResp[i]))
                        return;
                }
                XRL2SearchSession    searchReq = new XRL2SearchSession(true,Constants.SESSION_MATCH_QUERY_FUZZYMATCHCROSSTYPE);

                // maximum returned session is 6
                XRLXeAttribParam[] Params = new XRLXeAttribParam[1]{new XRLXeAttribParam(fuzzyAttribID,new XRLXeFloatValue(centerValue))};
                searchReq.AddParams(Params);
                XRL2SearchResults    Resp;
                if(searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out Resp))
                {
                    bool    ret = true;
                    if(Resp.resultsLen != 6)
                    {
                        Global.RO.Warn("Number of sessions returned is not 6");
                        ret = false;
                    }
                    else
                    {
                        for(int i = 0; i < 6; i++)
                        {
                            XRLXeIntValue        intParam;
                            if(Resp.results[i].AttribOffsetsLen !=6)
                            {
                                Global.RO.Warn("number of attributes in the session is not 6");
                                ret = false;
                                break;
                            }
                            else if((intParam = Resp.results[i].Attribs[0].aValue as XRLXeIntValue) == null)
                            {
                                Global.RO.Warn("The Returned attribute is not Int");
                                ret = false;
                                break;
                            }
                            else 
                            { //check returned session in order
                                switch(i)
                                {
                                    case 0:
                                        if(intParam.intValue != 8998)
                                        {
                                            ret = false;
                                            goto exit;
                                        }
                                        else break;
                                    case 1:
                                        if(intParam.intValue != 8997)
                                        {
                                            ret = false;
                                            goto exit;
                                        }
                                        else break;
                                    case 2:
                                        if(intParam.intValue != 8996)
                                        {
                                            ret = false;
                                            goto exit;
                                        }
                                        else break;
                                    case 3:
                                        if(intParam.intValue != 8995)
                                        {
                                            ret = false;
                                            goto exit;
                                        }
                                        else break;
                                    case 4:
                                        if(intParam.intValue != 8994)
                                        {
                                            ret = false;
                                            goto exit;
                                        }
                                        else break;
                                    case 5:
                                        if(intParam.intValue != 8993)
                                        {
                                            ret = false;
                                            goto exit;
                                        }
                                        else break;
                                }
                            }
                        }
                    }
                    exit:
                    if(ret)
                        ResultCode=TEST_RESULTS.PASSED;
                }
                for(int i = 0; i < numSessions; i++)
                {
                    XRL2DeleteSession    delReq = new XRL2DeleteSession(createResp[i].SessionID,searchReq.baseSearchSession.dwTitleID);
                    delReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                }
            }
        }
        [TestCase, Description("Fuzzy matching with all sessions has different dateTime values as centerValue")]
        class PDateTimeFuzzyMatch : TestBase
        {
            override protected void Execute()
            {
                uint    numDB = Constants.getNumDBForTitle(Constants.XENON_TITLE);
                uint	numSessions = numDB * 10;//create 10 sessions on each db
                uint    fuzzyAttribID = Constants.PROPERTY_MYDATETIMEPROP1;
                long    centerValue = DateTime.Now.ToFileTimeUtc(),dateValue=centerValue;

                XRL2CreateUpdateSession    [] createReq = new XRL2CreateUpdateSession[numSessions];
                XRLSessionInfo            [] createResp = new XRLSessionInfo[numSessions];
                for(int i = 0; i < numSessions; i++)
                {
                    if((i!=0) && (i%numDB ==0))
                        dateValue--;
                    createReq[i] = new XRL2CreateUpdateSession();
                    XRLXeAttribParam [] Attribs = new XRLXeAttribParam[2]{new XRLXeAttribParam(Constants.CONTEXT_MYCONTEXT1,new XRLXeIntValue(Constants.CONTEXT_MYCONTEXT1_TRACKB)),
                                                                          new XRLXeAttribParam(fuzzyAttribID,new XRLXeDateTimeValue(dateValue))};

                    createReq[i].AddAttribs(Attribs);
                    if(!createReq[i].Execute(Global.XEnv.GetInterface(Interface.xmatchfd)[0],out createResp[i]))
                        return;
                }
                XRL2SearchSession    searchReq = new XRL2SearchSession(true,Constants.SESSION_MATCH_QUERY_FUZZYMATCHDATETIME);
                // maximum returned session is 4
                XRLXeAttribParam[] Params = new XRLXeAttribParam[1]{new XRLXeAttribParam(fuzzyAttribID,new XRLXeIntValue(centerValue))};
                searchReq.AddParams(Params);
                XRL2SearchResults    Resp;

                if(searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out Resp))
                {
                    bool    ret = true;
                    if(Resp.resultsLen != 4)
                    {
                        Global.RO.Warn("Number of sessions returned is not 4");
                        ret = false;
                    }
                    else
                    {
                        for(int i = 0; i < 4; i++)
                        {
                            XRLXeDateTimeValue        dateParam;
                            if(Resp.results[i].AttribOffsetsLen !=6)
                            {
                                Global.RO.Warn("number of attributes in the session is not 6");
                                ret = false;
                                break;
                            }
                            else if((dateParam = Resp.results[i].Attribs[0].aValue as XRLXeDateTimeValue) == null)
                            {
                                Global.RO.Warn("The Returned 1st attribute is not dateTime");
                                ret = false;
                                break;
                            }
                            else // check the distance Attribute value
                            {    
                                switch(i)
                                {
                                    case 0:
                                        if(dateParam.dateValue != centerValue)
                                        {
                                            ret = false;
                                            goto exit;
                                        }
                                        else break;
                                    case 1:
                                        if(dateParam.dateValue != (centerValue-1))
                                        {
                                            ret = false;
                                            goto exit;
                                        }
                                        else break;
                                    case 2:
                                        if(dateParam.dateValue != (centerValue-2))
                                        {
                                            ret = false;
                                            goto exit;
                                        }
                                        else break;
                                    case 3:
                                        if(dateParam.dateValue != (centerValue-3))
                                        {
                                            ret = false;
                                            goto exit;
                                        }
                                        else break;
                                }
                            }
                        }
                    }
                    exit:
                    if(ret)
                        ResultCode=TEST_RESULTS.PASSED;
                }
                for(int i = 0; i < numSessions; i++)
                {
                    XRL2DeleteSession    delReq = new XRL2DeleteSession(createResp[i].SessionID,searchReq.baseSearchSession.dwTitleID);
                    delReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                }
            }
        }
        [TestCase, Description("Fuzzy matching with two sort statements")]
        class PFuzzyMatchMultiSort : TestBase
        {
            override protected void Execute()
            {
                MatchUtil.TruncateSessionsForTitle(Constants.XENON_TITLE, SessionType.Ranked);

                uint    numDB = Constants.getNumDBForTitle(Constants.XENON_TITLE);
                uint	numSessions = numDB * 10;//create 10 sessions on each db
                uint    fuzzyAttribID1 = Constants.PROPERTY_MYFLOAT64PROP1,fuzzyAttribID2 = Constants.PROPERTY_MYINT64PROP1;
                long    intCenterValue = 1234;
                double	dCenterValue = 5678.88,ddValue=dCenterValue;

                XRL2CreateUpdateSession    [] createReq = new XRL2CreateUpdateSession[numSessions];
                XRLSessionInfo            [] createResp = new XRLSessionInfo[numSessions];
                for(int i = 0; i < numSessions; i++)
                {
                    if((i!=0) && (i%numDB ==0))
                        ddValue--;
                    createReq[i] = new XRL2CreateUpdateSession();
                    XRLXeAttribParam [] Attribs = new XRLXeAttribParam[2]{new XRLXeAttribParam(fuzzyAttribID2,new XRLXeIntValue(intCenterValue)),
                                                                          new XRLXeAttribParam(fuzzyAttribID1,new XRLXeDoubleValue(ddValue))};

                    createReq[i].AddAttribs(Attribs);
                    if(!createReq[i].Execute(Global.XEnv.GetInterface(Interface.xmatchfd)[0],out createResp[i]))
                        return;
                }
                XRL2SearchSession    searchReq = new XRL2SearchSession(true,Constants.SESSION_MATCH_QUERY_FUZZYMATCHMULTISORT);
                // maximum returned session is 3
                XRLXeAttribParam[] Params = new XRLXeAttribParam[2]{new XRLXeAttribParam(fuzzyAttribID2,new XRLXeIntValue(intCenterValue)),
                                                                    new XRLXeAttribParam(fuzzyAttribID1,new XRLXeDoubleValue(dCenterValue))};
                searchReq.AddParams(Params);
                XRL2SearchResults    Resp;
			
                try
                {
                    if(searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out Resp))
                    {
                        bool    ret = true;
                        if((Resp == null)||(Resp.resultsLen != 3))
                        {
                            Global.RO.Warn("Number of sessions returned is not 3");
                            ret = false;
                        }
                        else
                        {
                            for(int i = 0; i < 3; i++)
                            {
                                XRLXeDoubleValue        dParam;
                                if(Resp.results[i].AttribOffsetsLen !=7)
                                {
                                    Global.RO.Warn("number of attributes in the session is not 7");
                                    ret = false;
                                    break;
                                }
                                else if((dParam = Resp.results[i].Attribs[1].aValue as XRLXeDoubleValue) == null)
                                {
                                    Global.RO.Warn("The Returned 2nd attribute is not double");
                                    ret = false;
                                    break;
                                }
                                else // check the distance Attribute value
                                {    
                                    switch(i)
                                    {
                                        case 0:
                                            if(dParam.dValue != (dCenterValue-9))
                                            {
                                                ret = false;
                                                goto exit;
                                            }
                                            else break;
                                        case 1:
                                            if(dParam.dValue != (dCenterValue-8))
                                            {
                                                ret = false;
                                                goto exit;
                                            }
                                            else break;
                                        case 2:
                                            if(dParam.dValue != (dCenterValue-7))
                                            {
                                                ret = false;
                                                goto exit;
                                            }
                                            else break;
                                    }
                                }
                            }
                        }
                        exit:
                        if(ret)
                            ResultCode=TEST_RESULTS.PASSED;
                    }
                }
                catch(Exception e)
                {
                    Global.RO.Warn("Unexpected exception thrown:" + e.Message);
                }
                for(int i = 0; i < numSessions; i++)
                {
                    XRL2DeleteSession    delReq = new XRL2DeleteSession(createResp[i].SessionID,searchReq.baseSearchSession.dwTitleID);
                    delReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                }
            }
        }

        [TestCase, Description("schema attribute in the sort criteria, but not in the return list.")]
        class PSortNotIntReturn : MatchTestBase
        {
            override protected void Execute()
            {
                uint numDB = Constants.getNumDBForTitle(Constants.XENON_TITLE);
                uint numSessions = numDB * 3;//create 3 sessions on each db
                long dateValue = DateTime.Now.ToFileTimeUtc();

                XRL2CreateUpdateSession[] createReq = new XRL2CreateUpdateSession[numSessions];
                XRLSessionInfo[] createResp = new XRLSessionInfo[numSessions];

                for (int i = 0; i < numSessions; i++)
                {
                    createReq[i] = new XRL2CreateUpdateSession();
                    XRLXeAttribParam[] Attribs = new XRLXeAttribParam[3]
                        {
                            new XRLXeAttribParam(Constants.PROPERTY_MYDATETIMEPROP1,new XRLXeDateTimeValue(dateValue)),
                            new XRLXeAttribParam(Constants.PROPERTY_MYINT32PROP1,new XRLXeIntValue(i%3)),
                            new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP1,new XRLXeIntValue(i%3))
                        };

                    createReq[i].AddAttribs(Attribs);
                    if (!createReq[i].Execute(Global.XEnv.GetInterface(Interface.xmatchfd)[0], out createResp[i]))
                    {
                        return;
                    }
                }

                XRL2SearchSession searchReq = new XRL2SearchSession(true, Constants.SESSION_MATCH_QUERY_QUERYSORTNOTINRETURN);
                XRLXeAttribParam[] Params = new XRLXeAttribParam[1] { new XRLXeAttribParam(Constants.PROPERTY_MYDATETIMEPROP1, new XRLXeDateTimeValue(dateValue)) };
                searchReq.AddParams(Params);
                XRL2SearchResults Resp;
                try
                {
                    if (searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out Resp))
                    {
                        bool ret = true;
                        if (!VerifySessions(createResp, Resp, Verify.Exclusive))
                        {
                            ret = false;
                        }
                        else
                        {
                            for (int i = 0; i < numSessions; i++)
                            {
                                XRLXeIntValue iParam;
                                if ((iParam = Resp.results[i].Attribs[0].aValue as XRLXeIntValue) == null)
                                {
                                    Global.RO.Warn("The Returned 1st attribute is not int");
                                    ret = false;
                                    break;
                                }
                                else
                                {
                                    if (iParam.intValue != i % 3)
                                    {
                                        ret = false;
                                        Global.RO.Warn("The sessions returned is not in right order");
                                        goto exit;
                                    }
                                }
                            }
                        }
                        exit:
                        if (ret)
                        {
                            ResultCode = TEST_RESULTS.PASSED;
                        }
                    }
                }
                catch (Exception e)
                {
                    Global.RO.Warn("Unexpected exception thrown:" + e.Message);
                }
                finally
                {
                    DeleteSessions(Constants.XENON_TITLE, createResp);
                }
            }
        }

        [TestCase, Description("Bug 26527:use constant in filter")]
        class PConstantInFilter : MatchTestBase
        {
            override protected void Execute()
            {
                uint numDB = Constants.getNumDBForTitle(Constants.XENON_TITLE);
                uint numSessions = numDB * 1;//create 1 sessions on each db

                XRL2CreateUpdateSession[] createReq = new XRL2CreateUpdateSession[numSessions];
                XRLSessionInfo[] createResp = new XRLSessionInfo[numSessions];

                int int32Const = 8;	//constant value defined in xlast
                long int64Const = 123456789;
                float float32Const = 0.1f;
                double doubleConst = 0.123456;
                long dateTimeConst = new DateTime(2005, 5, 6).ToFileTimeUtc();
                XRLXeAttribParam[] Attribs = new XRLXeAttribParam[5]
                    {
                        new XRLXeAttribParam(Constants.PROPERTY_MYDATETIMEPROP1,new XRLXeDateTimeValue(dateTimeConst)),
                        new XRLXeAttribParam(Constants.PROPERTY_MYINT32PROP1,new XRLXeIntValue(int32Const)),
                        new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP1,new XRLXeIntValue(int64Const)),
                        new XRLXeAttribParam(Constants.PROPERTY_MYFLOAT32PROP1,new XRLXeFloatValue(float32Const)),
                        new XRLXeAttribParam(Constants.PROPERTY_MYFLOAT64PROP1,new XRLXeDoubleValue(doubleConst))
                    };

                for (int i = 0; i < numSessions; i++)
                {
                    createReq[i] = new XRL2CreateUpdateSession();
                    createReq[i].AddAttribs(Attribs);
                    if (!createReq[i].Execute(Global.XEnv.GetInterface(Interface.xmatchfd)[0], out createResp[i]))
                    {
                        return;
                    }
                }

                XRL2SearchSession searchReq = new XRL2SearchSession(true, Constants.SESSION_MATCH_QUERY_CONSTANTVALUEINFILTER);
                XRL2SearchResults Resp;
                try
                {
                    if (searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out Resp))
                    {
                        if (VerifySessions(createResp, Resp, Verify.Exclusive))
                        {
                            ResultCode = TEST_RESULTS.PASSED;
                        }
                    }
                }
                catch (Exception e)
                {
                    Global.RO.Warn("Unexpected exception thrown:" + e.Message);
                }
                finally
                {
                    DeleteSessions(Constants.XENON_TITLE, createResp);
                }
            }
        }

        [TestCase, Description("Do the same query twice in a row and verify results are the same")]
        class PTitleCrossMultiDB1 : MatchTestBase
        {
            override protected void Execute()
            {
                MatchUtil.TruncateSessionsForTitle(Constants.XENON_TITLE, SessionType.Ranked);

                // one session per db
                // do a same query twice in a row and check the results are different
                uint numDB = Constants.getNumDBForTitle(Constants.XENON_TITLE);
                uint numSessions = numDB;
                XRL2CreateUpdateSession[] createReq = new XRL2CreateUpdateSession[numSessions];
                XRLSessionInfo[] createResp = new XRLSessionInfo[numSessions];
                for (int i = 0; i < numSessions; i++)
                {
                    createReq[i] = new XRL2CreateUpdateSession();
                    if (!createReq[i].Execute(Global.XEnv.GetInterface(Interface.xmatchfd)[0], out createResp[i]))
                    {
                        return;
                    }
                }
                XRL2SearchSession searchReq1 = new XRL2SearchSession(true, Constants.SESSION_MATCH_QUERY_QUERY1);
                XRL2SearchSession searchReq2 = new XRL2SearchSession(true, Constants.SESSION_MATCH_QUERY_QUERY1);
                searchReq1.baseSearchSession.wFlags = Constants.XONLINE_MATCH_SEARCH_FLAG_NO_CACHE;
                searchReq2.baseSearchSession.wFlags = Constants.XONLINE_MATCH_SEARCH_FLAG_NO_CACHE;
                XRL2SearchResults Resp1, Resp2;
                if (searchReq1.Execute(Global.XEnv.GetInterface(Interface.xmatchfd)[0], out Resp1) &&
                    searchReq2.Execute(Global.XEnv.GetInterface(Interface.xmatchfd)[0], out Resp2))
                {
                    // check the results are different
                    if (VerifySessions(createResp, Resp1, Verify.Exclusive) &&
                        VerifySessions(createResp, Resp2, Verify.Exclusive))
                    {
                        ResultCode = TEST_RESULTS.PASSED;
                    }
                }
                DeleteSessions(Constants.XENON_TITLE, createResp);
            }
        }

        [TestCase, Description("host session and client are both strictNAT, but having same inaOnline")]
        class PSameRouterNAT : TestBase
        {
            override protected void Execute()
            {
                uint    numDB = Constants.getNumDBForTitle(Constants.XENON_TITLE);
                uint	numSessions = numDB * 1;
                XRL2CreateUpdateSession [] createReq = new XRL2CreateUpdateSession[numSessions];
                XRLSessionInfo			[] createResp = new XRLSessionInfo[numSessions];
                for(int i = 0; i < numSessions; i++)
                {
                    createReq[i] = new XRL2CreateUpdateSession();
                    createResp[i] = new XRLSessionInfo();
                    createReq[i].baseCreateUpdate.baseSession.HostAddress.inaOnline = new byte[4]{0x01,0x02,0x03,0x04};
                    createReq[i].baseCreateUpdate.baseSession.SessionID = new byte[8]{0xB0,0,0,0,0,0,0,0};
                    if(!createReq[i].Execute(Global.XEnv.GetInterface(Interface.xmatchfd)[0],out createResp[i]))
                        return;
                }

                XRL2SearchSession    searchReq = new XRL2SearchSession(true,Constants.SESSION_MATCH_QUERY_QUERY1);
                searchReq.baseSearchSession.ClientAddress.inaOnline = new byte[4]{0x01,0x02,0x03,0x04};
                searchReq.baseSearchSession.wFlags = 3;
                XRL2SearchResults    searchResp;
                if(searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out searchResp))
                {
                    if(searchResp != null)
                        ResultCode=TEST_RESULTS.PASSED;
                }
                XRL2DeleteSession [] delReq = new XRL2DeleteSession[numSessions];
                for(int i = 0; i < numSessions; i++)
                {
                    delReq[i] = new XRL2DeleteSession(createResp[i].SessionID,searchReq.baseSearchSession.dwTitleID);
                    delReq[i].Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                }
            }
        }
        [TestCase, Description("host session is strictNAT, client is strict and send FindFromID query")]
        class PFindFromIDNAT : CheckReturnAttribsTestBase
        {
            override protected void Execute()
            {
                XRL2CreateUpdateSession    createReq = new XRL2CreateUpdateSession();
                XRLSessionInfo            createResp = new XRLSessionInfo();
                createReq.baseCreateUpdate.baseSession.SessionID = new byte[8]{0xB0,0,0,0,0,0,0,0};
                if(!createReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out createResp))
                    return;
                long    lSessID = Constants.sessionIDConvert(createResp.SessionID);
                XRL2SearchSession    searchReq = new XRL2SearchSession(true,Constants.X_SSINDEX_GET_SESSION);
                XRLXeAttribParam[] Params = new XRLXeAttribParam[1]{new XRLXeAttribParam(Constants.X_ATTRIBUTE_SESSION_ID,new XRLXeIntValue(lSessID))};
                searchReq.AddParams(Params);
                searchReq.baseSearchSession.wFlags = 3;
                XRL2SearchResults    searchResp;
                if(searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out searchResp))
                {
                    if(searchResp != null)
                        ResultCode=TEST_RESULTS.PASSED;
                }
                XRL2DeleteSession delReq = new XRL2DeleteSession(createResp.SessionID,createReq.baseCreateUpdate.baseSession.dwTitleID);
                delReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
            }
        }
        [TestCase, Description("host session is NAT type is 0, client is OpenNAT/moderate/strict")]
        class PZeroNAT : TestBase
        {
            override protected void Execute()
            {
                MatchUtil.TruncateSessionsForTitle(Constants.XENON_TITLE, SessionType.Ranked);

                // create two sessions so we can gurantee there are one on each db
                uint    numDB = Constants.getNumDBForTitle(Constants.XENON_TITLE);
                uint numSessions = numDB;
                XRL2CreateUpdateSession    [] createReq = new XRL2CreateUpdateSession[numSessions];
                XRLSessionInfo            [] createResp = new XRLSessionInfo[numSessions];
                for(int i = 0; i < numSessions; i++)
                {
                    createReq[i] = new XRL2CreateUpdateSession();
                    createReq[i].baseCreateUpdate.baseSession.SessionID=new byte[]{0x80,0,0,0,0,0,0,0};
                    if(!createReq[i].Execute(Global.XEnv.GetInterface(Interface.xmatchfd)[0],out createResp[i]))
                        return;
                }
                // search for the session with open NAT/moderate/strict
                XRL2SearchSession    searchReq1 = new XRL2SearchSession(true,Constants.SESSION_MATCH_QUERY_QUERY1), searchReq2=new XRL2SearchSession(true,Constants.SESSION_MATCH_QUERY_QUERY1),searchReq3=new XRL2SearchSession(true,Constants.SESSION_MATCH_QUERY_QUERY1);
                XRL2SearchResults    searchResp1, searchResp2, searchResp3;
                searchReq1.baseSearchSession.wFlags = 1;
                searchReq2.baseSearchSession.wFlags = 2;
                searchReq3.baseSearchSession.wFlags = 3;
                if(searchReq1.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out searchResp1)&&
                   searchReq2.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out searchResp2)&&
                   searchReq3.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out searchResp3))
                {
                    if((searchResp1.resultsLen != 0)&&(searchResp2.resultsLen!= 0)&&
                       (searchResp3.resultsLen != 0))
                        ResultCode=TEST_RESULTS.PASSED;
                }
                for(int i = 0; i < numSessions; i++)
                {
                    XRL2DeleteSession delReq = new XRL2DeleteSession(createResp[i].SessionID,searchReq1.baseSearchSession.dwTitleID);
                    delReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                }
            }
        }
        [TestCase, Description("host session is OpenNAT, client is OpenNAT/moderate/strict")]
        class POpenNAT : TestBase
        {
            override protected void Execute()
            {    // create two sessions so we can gurantee there are one on each db
                uint    numDB = Constants.getNumDBForTitle(Constants.XENON_TITLE);
                uint numSessions = numDB;
                XRL2CreateUpdateSession    [] createReq = new XRL2CreateUpdateSession[numSessions];
                XRLSessionInfo            [] createResp = new XRLSessionInfo[numSessions];
                for(int i = 0; i < numSessions; i++)
                {
                    createReq[i] = new XRL2CreateUpdateSession();
                    if(!createReq[i].Execute(Global.XEnv.GetInterface(Interface.xmatchfd)[0],out createResp[i]))
                        return;
                }
                // search for the session with open NAT/moderate/strict
                XRL2SearchSession    searchReq1 = new XRL2SearchSession(true,Constants.SESSION_MATCH_QUERY_QUERY1), searchReq2=new XRL2SearchSession(true,Constants.SESSION_MATCH_QUERY_QUERY1),searchReq3=new XRL2SearchSession(true,Constants.SESSION_MATCH_QUERY_QUERY1);
                XRL2SearchResults    searchResp1, searchResp2, searchResp3;
                searchReq1.baseSearchSession.wFlags = 1;
                searchReq2.baseSearchSession.wFlags = 2;
                searchReq3.baseSearchSession.wFlags = 3;
                if(searchReq1.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out searchResp1)&&
                   searchReq2.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out searchResp2)&&
                   searchReq3.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out searchResp3))
                {
                    if((searchResp1.resultsLen != 0)&&(searchResp2.resultsLen!= 0)&&
                       (searchResp3.resultsLen != 0))
                        ResultCode=TEST_RESULTS.PASSED;
                }
                for(int i = 0; i < numSessions; i++)
                {
                    XRL2DeleteSession delReq = new XRL2DeleteSession(createResp[i].SessionID,searchReq1.baseSearchSession.dwTitleID);
                    delReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                }
            }
        }
        [TestCase, Description("host session is Moderate NAT, client is Moderate/open/strict NAT")]
        class PModerateNAT : TestBase
        {
            override protected void Execute()
            {    // create two sessions so we can gurantee there are one on each db
                uint    numDB = Constants.getNumDBForTitle(Constants.XENON_TITLE);
                uint numSessions = numDB;
                XRL2CreateUpdateSession    [] createReq = new XRL2CreateUpdateSession[numSessions];
                XRLSessionInfo            [] createResp = new XRLSessionInfo[numSessions];
                for(int i = 0; i < numSessions; i++)
                {
                    createReq[i] = new XRL2CreateUpdateSession();
                    createReq[i].baseCreateUpdate.baseSession.SessionID=new byte[]{0xA0,0,0,0,0,0,0,0};
                    if(!createReq[i].Execute(Global.XEnv.GetInterface(Interface.xmatchfd)[0],out createResp[i]))
                        return;
                }
                // search for the session with open NAT/moderate/strict
                XRL2SearchSession    searchReq1 = new XRL2SearchSession(true,Constants.SESSION_MATCH_QUERY_QUERY1), searchReq2=new XRL2SearchSession(true,Constants.SESSION_MATCH_QUERY_QUERY1),searchReq3=new XRL2SearchSession(true,Constants.SESSION_MATCH_QUERY_QUERY1);
                XRL2SearchResults    searchResp1, searchResp2, searchResp3;
                searchReq1.baseSearchSession.wFlags = 1;
                searchReq2.baseSearchSession.wFlags = 2;
                searchReq3.baseSearchSession.wFlags = 3;
                if(searchReq1.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out searchResp1)&&
                   searchReq2.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out searchResp2)&&
                   searchReq3.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out searchResp3))
                {
                    if((searchResp1.resultsLen != 0)&&(searchResp2.resultsLen!= 0)&&
                       (searchResp3 == null))
                        ResultCode=TEST_RESULTS.PASSED;
                }
                for(int i = 0; i < numSessions; i++)
                {
                    XRL2DeleteSession delReq = new XRL2DeleteSession(createResp[i].SessionID,searchReq1.baseSearchSession.dwTitleID);
                    delReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                }
            }
        }
        [TestCase, Description("host session is Strict NAT, client is Moderate/open/strict NAT")]
        class PStrictNAT : TestBase
        {
            override protected void Execute()
            {   
                MatchUtil.TruncateSessionsForTitle(Constants.XENON_TITLE, SessionType.Ranked);
 
                // create two sessions so we can gurantee there are one on each db
                uint    numDB = Constants.getNumDBForTitle(Constants.XENON_TITLE);
                uint numSessions = numDB;
                XRL2CreateUpdateSession    [] createReq = new XRL2CreateUpdateSession[numSessions];
                XRLSessionInfo            [] createResp = new XRLSessionInfo[numSessions];
                for(int i = 0; i < numSessions; i++)
                {
                    createReq[i] = new XRL2CreateUpdateSession();
                    createReq[i].baseCreateUpdate.baseSession.SessionID=new byte[]{0xB0,0,0,0,0,0,0,0};
                    if(!createReq[i].Execute(Global.XEnv.GetInterface(Interface.xmatchfd)[0],out createResp[i]))
                        return;
                }
                // search for the session with open NAT/moderate/strict
                XRL2SearchSession    searchReq1 = new XRL2SearchSession(true,Constants.SESSION_MATCH_QUERY_QUERY1), searchReq2=new XRL2SearchSession(true,Constants.SESSION_MATCH_QUERY_QUERY1),searchReq3=new XRL2SearchSession(true,Constants.SESSION_MATCH_QUERY_QUERY1);
                XRL2SearchResults    searchResp1, searchResp2, searchResp3;
                searchReq1.baseSearchSession.wFlags = 1;
                searchReq2.baseSearchSession.wFlags = 2;
                searchReq3.baseSearchSession.wFlags = 3;
                if(searchReq1.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out searchResp1)&&
                   searchReq2.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out searchResp2)&&
                   searchReq3.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out searchResp3))
                {
                    if((searchResp1.resultsLen != 0)&&(searchResp2 == null)&& (searchResp3 == null))
                        ResultCode=TEST_RESULTS.PASSED;
                }
                for(int i = 0; i < numSessions; i++)
                {
                    XRL2DeleteSession delReq = new XRL2DeleteSession(createResp[i].SessionID,searchReq1.baseSearchSession.dwTitleID);
                    delReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                }
            }
        }

        // need to have Throttling.ini file in the match fd
        [TestCase, Description("check X-Delay header for xenon title")]
        class PThrottling : TestBase
        {
            override protected void Execute()
            {
                Global.XEnv.ExecuteXmgmtCommand(Interface.xmatchfd, "e :xmatchfd SetXdelay 0xffed94b2 xmatchhost2 10000");
                Global.XEnv.ExecuteXmgmtCommand(Interface.xmatchfd, "e :xmatchfd SetXdelay 0xffed94b2 xmatchClient2 10000");

                XRL2CreateUpdateSession createReq = new XRL2CreateUpdateSession();
                XRLSessionInfo createResp = new XRLSessionInfo();

                if (createReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out createResp))
                {
                    if (createReq.XDelay != 10000)
                    {
                        Global.RO.Warn("CreateSession:X-Delay in CreateResponse is not 10000");
                        goto Exit;
                    }
                }
                else
                {
                    Global.RO.Warn("Failed to create sessions");
                }

                // search sessions
                XRL2SearchSession searchReq = new XRL2SearchSession(true, Constants.SESSION_MATCH_QUERY_QUERY1);
                XRL2SearchResults Resp;
                if (searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out Resp))
                {
                    if (searchReq.XDelay == 10000)
                        ResultCode = TEST_RESULTS.PASSED;
                }
                Exit:
                XRL2DeleteSession delReq = new XRL2DeleteSession(createResp.SessionID, 0xffed94b2);
                delReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                Global.XEnv.ExecuteXmgmtCommand(Interface.xmatchfd, "exec :xmatchfd ReloadThrottleConfig");
            }
        }

        [TestCase, Description("dwNumUsers can be any value")]
        class PAnyNumUsers : TestBase
        {
            override protected void Execute()
            {
                XRL2CreateUpdateSession createReq = new XRL2CreateUpdateSession();
                XRLSessionInfo createResp;
                if (createReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out createResp))
                {
                    XRL2SearchSession searchReq = new XRL2SearchSession(true, Constants.SESSION_MATCH_QUERY_QUERY1);
                    searchReq.baseSearchSession.wNumUsers = Constants.XONLINE_MAX_LOGON_USERS + 1;
                    XRLXeAttribParam[] Params = new XRLXeAttribParam[1] { new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP1, new XRLXeIntValue(123)) };
                    searchReq.AddParams(Params);

                    XRL2SearchResults resp;
                    if (searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out resp))
                    {
                        // TODO: This validation could be beefed up to actually create some sessions and verify that they are returned successfully.
                        ResultCode = TEST_RESULTS.PASSED;
                    }
                    XRL2DeleteSession delReq = new XRL2DeleteSession(createResp.SessionID, searchReq.baseSearchSession.dwTitleID);
                    delReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                }
            }
        }


        /***************************************************************************************
         * The followings are negative cases
         ***************************************************************************************/

        [TestCase, Description("passing a string type as search parameter")]
        class NStringSearchParam : NegativeSearch2TestBase
        {
            override protected void Execute()
            {
                XRL2SearchSession searchReq = new XRL2SearchSession(true, Constants.SESSION_MATCH_QUERY_RETURNSTRINGLAST);
                XRLXeAttribParam[] Params = new XRLXeAttribParam[1] { new XRLXeAttribParam(Constants.PROPERTY_GAMERNAME, new XRLXeStringValue("abc\0")) };
                searchReq.AddParams(Params);
                if (SearchTestNegative(searchReq, HResult.XONLINE_E_MATCH_INVALID_PARAM))
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("passing a blob type as search parameter")]
        class NBlobSearchParam : NegativeSearch2TestBase
        {
            override protected void Execute()
            {
                XRL2SearchSession searchReq = new XRL2SearchSession(true, Constants.SESSION_MATCH_QUERY_QUERY1);
                XRLXeAttribParam[] Params = new XRLXeAttribParam[1] { new XRLXeAttribParam(Constants.SAMPLE_BLOB_ATTRIB, 
                                                                                           new XRLXeBlobValue(BitConverter.GetBytes(12))) };
                searchReq.AddParams(Params);
                if (SearchTestNegative(searchReq, HResult.XONLINE_E_MATCH_INVALID_DATA_TYPE))
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("passing duplicate search parameters")]
        class NDuplicateSearchParams : NegativeSearch2TestBase
        {
            override protected void Execute()
            {
                XRL2SearchSession searchReq = new XRL2SearchSession(true, Constants.SESSION_MATCH_QUERY_QUERY1);
                XRLXeAttribParam[] Params = new XRLXeAttribParam[2]{new XRLXeAttribParam(Constants.PROPERTY_MYINT32PROP1,new XRLXeIntValue(12)),
                                                                    new XRLXeAttribParam(Constants.PROPERTY_MYINT32PROP1,new XRLXeIntValue(34))};
                searchReq.AddParams(Params);
                if (SearchTestNegative(searchReq, HResult.XONLINE_E_MATCH_DUPLICATE_PARAM))
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("try to search using aggregated stored procedure")]
        class NAggQuery : NegativeSearch2TestBase
        {
            override protected void Execute()
            {
                XRL2SearchSession searchReq = new XRL2SearchSession(true, 0x8000002c);
                if (SearchTestNegative(searchReq, HResult.XONLINE_E_MATCH_INVALID_SEARCH_REQ))
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("Bug 22774:send int32 parameter2 to a sp that takes int32 parameter1 as search parameter")]
        class NInt32SameTypeWrongID : NegativeSearch2TestBase
        {
            override protected void Execute()
            {
                XRL2SearchSession searchReq = new XRL2SearchSession(true, Constants.SESSION_MATCH_QUERY_QUERY1);
                XRLXeAttribParam[] Params = new XRLXeAttribParam[1] { new XRLXeAttribParam(Constants.PROPERTY_MYINT32PROP2, new XRLXeIntValue(2345)) };
                searchReq.AddParams(Params);
                if (SearchTestNegative(searchReq, HResult.XONLINE_E_MATCH_INVALID_PARAM))
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("Bug 22774:send int64 parameter2 to a sp that takes int64 parameter1 as search parameter")]
        class NInt64SameTypeWrongID : NegativeSearch2TestBase
        {
            override protected void Execute()
            {
                XRL2SearchSession searchReq = new XRL2SearchSession(true, Constants.SESSION_MATCH_QUERY_QUERY1);
                XRLXeAttribParam[] Params = new XRLXeAttribParam[1] { new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP2, new XRLXeIntValue(2345)) };
                searchReq.AddParams(Params);
                if (SearchTestNegative(searchReq, HResult.XONLINE_E_MATCH_INVALID_PARAM))
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("Bug 22774:send float32 parameter2 to a sp that takes float32 parameter1 as search parameter")]
        class NFloat32SameTypeWrongID : NegativeSearch2TestBase
        {
            override protected void Execute()
            {
                XRL2SearchSession searchReq = new XRL2SearchSession(true, Constants.SESSION_MATCH_QUERY_QUERY1);
                XRLXeAttribParam[] Params = new XRLXeAttribParam[1] { new XRLXeAttribParam(Constants.PROPERTY_MYFLOAT32PROP2, new XRLXeFloatValue(2345f)) };
                searchReq.AddParams(Params);
                if (SearchTestNegative(searchReq, HResult.XONLINE_E_MATCH_INVALID_PARAM))
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("Bug 22774:send float64 parameter2 to a sp that takes float64 parameter1 as search parameter")]
        class NFloat64SameTypeWrongID : NegativeSearch2TestBase
        {
            override protected void Execute()
            {
                XRL2SearchSession searchReq = new XRL2SearchSession(true, Constants.SESSION_MATCH_QUERY_QUERY1);
                XRLXeAttribParam[] Params = new XRLXeAttribParam[1] { new XRLXeAttribParam(Constants.PROPERTY_MYFLOAT64PROP2, new XRLXeDoubleValue(2345)) };
                searchReq.AddParams(Params);
                if (SearchTestNegative(searchReq, HResult.XONLINE_E_MATCH_INVALID_PARAM))
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("Bug 22774:send dateTime parameter2 to a sp that takes dateTime parameter1 as search parameter")]
        class NDateTimeSameTypeWrongID : NegativeSearch2TestBase
        {
            override protected void Execute()
            {
                XRL2SearchSession searchReq = new XRL2SearchSession(true, Constants.SESSION_MATCH_QUERY_QUERY1);
                XRLXeAttribParam[] Params = new XRLXeAttribParam[1] { new XRLXeAttribParam(Constants.CONTEXT_MYCONTEXT2, new XRLXeIntValue(Constants.CONTEXT_MYCONTEXT2_ROUNDA)) };
                searchReq.AddParams(Params);
                if (SearchTestNegative(searchReq, HResult.XONLINE_E_MATCH_INVALID_PARAM))
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("Bug 22774:send context parameter2 to a sp that takes context parameter1 as search parameter")]
        class NContextWrongID : NegativeSearch2TestBase
        {
            override protected void Execute()
            {
                XRL2SearchSession searchReq = new XRL2SearchSession(true, Constants.SESSION_MATCH_QUERY_QUERY1);
                XRLXeAttribParam[] Params = new XRLXeAttribParam[1] { new XRLXeAttribParam(Constants.PROPERTY_MYDATETIMEPROP2, new XRLXeDateTimeValue(DateTime.UtcNow.ToFileTime())) };
                searchReq.AddParams(Params);
                if (SearchTestNegative(searchReq, HResult.XONLINE_E_MATCH_INVALID_PARAM))
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase, Description("Bug 26539:passing a parametr to a sp that takes no search parameters")]
        class NNoSearchParam : NegativeSearch2TestBase
        {
            override protected void Execute()
            {
                XRL2SearchSession searchReq = new XRL2SearchSession(true, Constants.SESSION_MATCH_QUERY_NOPARAMQUERY);
                XRLXeAttribParam[] Params = new XRLXeAttribParam[1] { new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP1, new XRLXeIntValue(2345)) };
                searchReq.AddParams(Params);
                if (SearchTestNegative(searchReq, HResult.XONLINE_E_MATCH_INVALID_PARAM))
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase, Description("Search with X_SSINDEX_GET_SESSION and a valid SessionID but wrong(valid)title")]
        class NSpecialSP1WrongTitle : NegativeSearch2TestBase
        {
            override protected void Execute()
            {
                XRL2CreateUpdateSession createReq = new XRL2CreateUpdateSession();
                createReq.baseCreateUpdate.baseSession.dwTitleID = Constants.XENON_TITLE2;
                XRLSessionInfo createResp;
                if (createReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out createResp))
                {
                    long lSessID = Constants.sessionIDConvert(createResp.SessionID);
                    // search based on sessionID
                    XRL2SearchSession searchReq = new XRL2SearchSession(true, Constants.X_SSINDEX_GET_SESSION);

                    XRLXeAttribParam[] Params = new XRLXeAttribParam[1] { new XRLXeAttribParam(Constants.X_ATTRIBUTE_SESSION_ID, new XRLXeIntValue(lSessID)) };
                    searchReq.AddParams(Params);
                    searchReq.baseSearchSession.dwTitleID = Constants.XENON_TITLE;
                    XRL2SearchResults Resp;
                    if (searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out Resp))
                    {
                        if (Resp == null)    // detailed checking was done by FuncCreateSession verification
                            ResultCode = TEST_RESULTS.PASSED;
                        else
                            Global.RO.Warn("There is session returned:" + Resp.resultsLen);
                    }
                    XRL2DeleteSession delReq = new XRL2DeleteSession(createResp.SessionID, createReq.baseCreateUpdate.baseSession.dwTitleID);
                    delReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                }
            }
        }
        [TestCase, Description("Search with X_SSINDEX_GET_SESSION and a valid SessionID but unknown title")]
        class NSpecialSP1UnknownTitle : NegativeSearch2TestBase
        {
            override protected void Execute()
            {
                XRL2CreateUpdateSession createReq = new XRL2CreateUpdateSession();
                XRLSessionInfo createResp;
                if (createReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out createResp))
                {
                    long lSessID = Constants.sessionIDConvert(createResp.SessionID);
                    // search based on sessionID
                    XRL2SearchSession searchReq = new XRL2SearchSession(true, Constants.X_SSINDEX_GET_SESSION);
                    // sp=5 takes sessionID as parameter
                    XRLXeAttribParam[] Params = new XRLXeAttribParam[1] { new XRLXeAttribParam(Constants.X_ATTRIBUTE_SESSION_ID, new XRLXeIntValue(lSessID)) };
                    searchReq.AddParams(Params);
                    searchReq.baseSearchSession.dwTitleID = Constants.UNKNOWN_TITLE;
                    if (SearchTestNegative(searchReq, HResult.XONLINE_E_MATCH_INVALID_TITLE_ID))
                        ResultCode = TEST_RESULTS.PASSED;
                    XRL2DeleteSession delReq = new XRL2DeleteSession(createResp.SessionID, createReq.baseCreateUpdate.baseSession.dwTitleID);
                    delReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                }
            }
        }
        [TestCase, Description("Search with X_SSINDEX_GET_SESSION with an invalid sessionID")]
        class NSpecialSP1InvalidSessID : NegativeSearch2TestBase
        {
            override protected void Execute()
            {
                XRL2SearchSession searchReq = new XRL2SearchSession(true, Constants.X_SSINDEX_GET_SESSION);
                // Make sure the invalid session id we choose here maps to db
                // zero, or else the call may be rejected as an invalid session
                // id which is different from one that doesn't exist. Also
                // mark it as an online peer session just for consistency.
                // MatchDefs.XNET_XNKID_DBINDEX_MASK = 0x0F
                // MatchDefs.XNET_XNKID_ONLINE_PEER = 0x80
                // So we pick 0x180
                XRLXeAttribParam[] Params = new XRLXeAttribParam[1] { new XRLXeAttribParam(Constants.X_ATTRIBUTE_SESSION_ID, new XRLXeIntValue(0x180)) };
                searchReq.AddParams(Params);
                XRL2SearchResults Resp;
                if (searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out Resp))
                {
                    if (Resp == null)
                        ResultCode = TEST_RESULTS.PASSED;
                }
            }
        }
        [TestCase, Description("search using a nonexistent stored procedure")]
        class NNonExistentSP : NegativeSearch2TestBase
        {
            override protected void Execute()
            {
                XRL2SearchSession searchReq = new XRL2SearchSession(true, 1000);
                if (SearchTestNegative(searchReq, HResult.XONLINE_E_MATCH_INVALID_SEARCH_REQ))
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("search with 1 int parameter using unknown title")]
        class NUnknownTitle : NegativeSearch2TestBase
        {
            override protected void Execute()
            {
                // sp=1 takes one int parameter
                XRL2SearchSession searchReq = new XRL2SearchSession(true, Constants.SESSION_MATCH_QUERY_QUERY1);
                searchReq.baseSearchSession.dwTitleID = Constants.UNKNOWN_TITLE;
                XRLXeAttribParam[] Params = new XRLXeAttribParam[1] { new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP1, new XRLXeIntValue(12345)) };
                searchReq.AddParams(Params);
                if (SearchTestNegative(searchReq, HResult.XONLINE_E_MATCH_INVALID_TITLE_ID))
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }
        //While it is okay for dwMessageLength to be less than the size specified by Content-Length,
        //it is not okay for dwMessageLength to be less than the required size of the search structure
        //given the specified number of parameters.
        [TestCase, Description("dwMessageLength is shorter than actual request length")]
        class NOverflowMsgLen : NegativeSearch2TestBase
        {
            override protected void Execute()
            {
                XRL2SearchSession searchReq = new XRL2SearchSession(true, Constants.SESSION_MATCH_QUERY_QUERY1);
                XRLXeAttribParam[] Params = new XRLXeAttribParam[1] { new XRLXeAttribParam(Constants.PROPERTY_MYFLOAT32PROP1, new XRLXeFloatValue(1f)) };
                searchReq.AddParams(Params);
                searchReq.baseSearchSession.dwMessageLength -= 1;
                if (SearchTestNegative(searchReq, HResult.XONLINE_E_MATCH_REQUEST_TOO_SMALL))
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("dwMessageLength is larger than actual request length")]
        class NTruncateMsgLen : NegativeSearch2TestBase
        {
            override protected void Execute()
            {
                XRL2SearchSession searchReq = new XRL2SearchSession(true, Constants.SESSION_MATCH_QUERY_QUERY1);
                XRLXeAttribParam[] Params = new XRLXeAttribParam[1] { new XRLXeAttribParam(Constants.PROPERTY_MYFLOAT32PROP1, new XRLXeFloatValue(1f)) };
                searchReq.AddParams(Params);
                searchReq.baseSearchSession.dwMessageLength += 1;
                if (SearchTestNegative(searchReq, HResult.XONLINE_E_MATCH_REQUEST_TRUNCATED))
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("client's NAT type is invalid")]
        class NInvalidNATType : NegativeSearch2TestBase
        {
            override protected void Execute()
            {
                XRL2CreateUpdateSession createReq = new XRL2CreateUpdateSession();
                XRLSessionInfo createResp;
                if (createReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out createResp))
                {
                    XRL2SearchSession searchReq = new XRL2SearchSession(true, Constants.SESSION_MATCH_QUERY_QUERY1);
                    searchReq.baseSearchSession.wFlags = 4;
                    XRLXeAttribParam[] Params = new XRLXeAttribParam[1] { new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP1, new XRLXeIntValue(23)) };
                    searchReq.AddParams(Params);
                    if (SearchTestNegative(searchReq, HResult.XONLINE_E_MATCH_INVALID_FLAGS))
                        ResultCode = TEST_RESULTS.PASSED;
                    XRL2DeleteSession delReq = new XRL2DeleteSession(createResp.SessionID, searchReq.baseSearchSession.dwTitleID);
                    delReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                }
            }
        }
        [TestCase, Description("send no search parameter to FindByID query")]
        class NFindByIDNoSearchParam : NegativeSearch2TestBase
        {
            override protected void Execute()
            {
                XRL2CreateUpdateSession createReq = new XRL2CreateUpdateSession();
                XRLSessionInfo createResp;
                if (createReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out createResp))
                {
                    XRL2SearchSession searchReq = new XRL2SearchSession(false, Constants.X_SSINDEX_GET_SESSION);

                    if (SearchTestNegative(searchReq, HResult.XONLINE_E_MATCH_PARAM_MISSING))
                        ResultCode = TEST_RESULTS.PASSED;
                    XRL2DeleteSession delReq = new XRL2DeleteSession(createResp.SessionID, searchReq.baseSearchSession.dwTitleID);
                    delReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                }
            }
        }
        [TestCase, Description("Bug 26534:send wrong search Paramter ID to FindByID query")]
        class NFindByIDWrongParamID : NegativeSearch2TestBase
        {
            override protected void Execute()
            {
                XRL2CreateUpdateSession createReq = new XRL2CreateUpdateSession();
                XRLSessionInfo createResp;
                if (createReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out createResp))
                {
                    XRL2SearchSession searchReq = new XRL2SearchSession(true, Constants.X_SSINDEX_GET_SESSION);
                    XRLXeAttribParam[] Params = new XRLXeAttribParam[1] { new XRLXeAttribParam(Constants.PROPERTY_MYINT64PROP1, new XRLXeIntValue(23)) };
                    searchReq.AddParams(Params);
                    if (SearchTestNegative(searchReq, HResult.XONLINE_E_MATCH_INVALID_ATTRIBUTE_ID))
                        ResultCode = TEST_RESULTS.PASSED;
                    XRL2DeleteSession delReq = new XRL2DeleteSession(createResp.SessionID, searchReq.baseSearchSession.dwTitleID);
                    delReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                }
            }
        }
        [TestCase, Description("pass non-existent parameterID")]
        class NNonExistentParamID : NegativeSearch2TestBase
        {
            override protected void Execute()
            {
                XRL2SearchSession searchReq = new XRL2SearchSession(true, Constants.SESSION_MATCH_QUERY_QUERY1);
                XRLXeAttribParam[] searchParams = new XRLXeAttribParam[1] { 
                    new XRLXeAttribParam(Constants.XENON_TEST_NONEXIST_ATTRIBID, new XRLXeIntValue(10)) };
                searchReq.AddParams(searchParams);
                if (SearchTestNegative(searchReq, HResult.XONLINE_E_MATCH_INVALID_PARAM))
                {
                    ResultCode = TEST_RESULTS.PASSED;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XMatchTest\FuncDeadXBox.cs ===
using System;
using System.Text;
using System.IO;
using System.Net;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Matchmaking;
using xonline.common.config;

namespace XMatchTest
{
    // These tests are deprecated, as Xbox1 support is removed.  These will be deleted in the next release.
    [TestGroup, Ignore]
    public class FuncDeadXBox : TestNode
    {
        // this is for batched deadxbox requests
        protected static bool    MyOwnExecute(XRLDeadXBox[] batchReq, uint dwTotalMsgLen,uint XErr)
        {
            MemoryStream        reqStream = new MemoryStream();
            BinaryWriter        bw = new BinaryWriter(reqStream);
            // get reqStream from the batchReq;
            for(int i = 0; i < batchReq.Length; i++)
            {
                bw.Write(batchReq[i].wType);
                bw.Write(batchReq[i].cbEnt);
                bw.Write(batchReq[i].sgaddr.inaSg);
                bw.Write(batchReq[i].sgaddr.dwSpiSg);
                bw.Write(batchReq[i].sgaddr.qwXboxID);
                bw.Write(batchReq[i].sgaddr.abReserved);
                bw.Write(batchReq[i].dwTitleID);
            }
            if(dwTotalMsgLen > (batchReq.Length*(Constants.SIZEDEADXBOX)))
                bw.Write("a");    // this is a negative case that passed in extra data at the end of deadxbox requests
            else if(dwTotalMsgLen < (batchReq.Length*(Constants.SIZEDEADXBOX)))
                reqStream.SetLength(dwTotalMsgLen);

            StringBuilder sbURL = new StringBuilder();
            sbURL.Append("http://");
            sbURL.Append(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd).ToString());
            sbURL.Append("/xmatch/deadxbox.ashx");

            HttpWebRequest    httpReq;
            HttpWebResponse    httpResp = null;
            HttpStatusCode    statusCode;
            Stream            httpStream;
            httpReq = (HttpWebRequest)WebRequest.Create(sbURL.ToString());
            httpReq.ProtocolVersion = HttpVersion.Version11;
            httpReq.Method = "POST";
            httpReq.UserAgent = ((int)XOService.Matchmaking).ToString("x") + "/1.0.5849";
            httpReq.ContentType = "xon/" + ((int)XOService.Matchmaking).ToString("x");
            httpReq.ContentLength = reqStream.Length;
            try
            {
                httpStream = httpReq.GetRequestStream();
                reqStream.WriteTo(httpStream);
                httpStream.Close();
                httpResp = (HttpWebResponse)httpReq.GetResponse();
            }
            catch (WebException e)
            {
                if(XErr == 0)    // this request is expected to succeed
                {
                    Global.RO.Warn("Positive deadxbox requests failed");
                    return false;
                }
                // else this is a negative case
                httpResp = (HttpWebResponse)e.Response;
                if(httpResp != null)
                {
                    statusCode = httpResp.StatusCode;
                    if(statusCode == HttpStatusCode.InternalServerError)
                    {    // check XErr
                        string strErr = httpResp.GetResponseHeader("X-Err");
                        if (strErr.StartsWith("0x") || strErr.StartsWith("0X")) strErr = strErr.Substring(2);

                        if (Convert.ToUInt32(strErr, 16) == XErr)
                            return true;
                        else
                        {
                            Global.RO.Warn("Wrong error code (" + strErr + " != " + XErr.ToString("X") + ") returned");
                            return false;
                        }
                    }
                    else // other error returned instead of 500
                        return false;
                }
                // httpResp is null
                return false;
            }
            if(XErr == 0)
                return true;
            else
                return false;
        }
        [Ignore] //can no longer call with max value, because boxID is validated.
        [TestCase, Description("call deadxbox with SgAddr/TitleRegion/aqwUserID set to max value")]
			class PMaxSgAddr : TestBase
        {
            override protected void Execute()
            {
                SGADDR        sg = new SGADDR();
                sg.dwSpiSg = 0xffffffff;
                sg.qwXboxID = 0xffffffffffffffff;
                sg.inaSg = new byte[4]{0xff,0xff,0xff,0xff};
                byte[]        sgbytes = sg.toByteArray();

                // create a session with maximum SGADDR
                XRLCreateUpdateSession        createReq = new XRLCreateUpdateSession();
                XRLSessionInfo                Resp;
                Array.Copy(sgbytes,createReq.baseSession.HostAddress.abOnline,(long)Constants.SIZESGADDR);
                if(createReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out Resp))
                {
                    XRLDeadXBox        req = new XRLDeadXBox();
                    req.sgaddr.dwSpiSg = sg.dwSpiSg;
                    req.sgaddr.qwXboxID = sg.qwXboxID;
                    Array.Copy(sg.inaSg,req.sgaddr.inaSg,4);
                    // same DeadXbox message will be sent twice to the matchmaking front door
                    if(req.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd)))
                    {
                        // the session will be deleted right away
                        XRLDeleteSession    delReq = new XRLDeleteSession(Resp.SessionID);
                        if(    !delReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd))&&
                            (delReq.XErr == HResult.XONLINE_E_MATCH_INVALID_SESSION_ID))
                            ResultCode=TEST_RESULTS.PASSED;
                    }
                }
            }
        }
        [Ignore] //can no longer call with min value, because boxID is validated.
        [TestCase, Description("call deadxbox with SgAddr/TitleRegion/aqwUserID set to min value")]
			class PMinSgAddr : TestBase
        {
            override protected void Execute()
            {
                SGADDR        sg = new SGADDR();
                sg.dwSpiSg = 0;
                sg.qwXboxID = 0;
                sg.inaSg = new byte[4]{0,0,0,0};
                byte[]        sgbytes = sg.toByteArray();

                // create a session with maximum SGADDR
                XRLCreateUpdateSession        createReq = new XRLCreateUpdateSession();
                XRLSessionInfo                Resp;
                Array.Copy(sgbytes,createReq.baseSession.HostAddress.abOnline,(long)Constants.SIZESGADDR);
                if(createReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out Resp))
                {
                    XRLDeadXBox        req = new XRLDeadXBox();
                    req.sgaddr.dwSpiSg = sg.dwSpiSg;
                    req.sgaddr.qwXboxID = sg.qwXboxID;
                    Array.Copy(sg.inaSg,req.sgaddr.inaSg,4);
                    // same DeadXbox message will be sent twice to the matchmaking front door
                    if(req.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd)))
                    {
                        // the session will be deleted right away
                        XRLDeleteSession    delReq = new XRLDeleteSession(Resp.SessionID);
                        if(    !delReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd))&&
                            (delReq.XErr == HResult.XONLINE_E_MATCH_INVALID_SESSION_ID))
                            ResultCode=TEST_RESULTS.PASSED;
                    }
                }
            }
        }
        [BVT]
        [TestCase, Description("call deadxbox so that more than 1 sessions are deleted")]
			class PMoreSessions : TestBase
        {
            override protected void Execute()
            {
                SGADDR        sg = new SGADDR();
                byte[]        sgbytes = sg.toByteArray();
                // create two sessions with the same SGAddr set
                XRLCreateUpdateSession        createReq1, createReq2;
                createReq1 = new XRLCreateUpdateSession();
                createReq2 = new XRLCreateUpdateSession();
                XRLSessionInfo                Resp1, Resp2;

                Array.Copy(sgbytes,createReq1.baseSession.HostAddress.abOnline,(long)Constants.SIZESGADDR);
                Array.Copy(sgbytes,createReq2.baseSession.HostAddress.abOnline,(long)Constants.SIZESGADDR);
                if(    createReq1.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out Resp1) &&
                    createReq2.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out Resp2))
                {
                    XRLDeadXBox        req = new XRLDeadXBox();
                    req.sgaddr.dwSpiSg = sg.dwSpiSg;
                    req.sgaddr.qwXboxID = sg.qwXboxID;
                    Array.Copy(sg.inaSg,req.sgaddr.inaSg,4);
                    // same DeadXbox message will be sent twice to the matchmaking front door
                    if(req.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd)))
                    {
                        // the two sessions will be deleted right away
                        XRLDeleteSession    delReq1 = new XRLDeleteSession(Resp1.SessionID);
                        XRLDeleteSession    delReq2 = new XRLDeleteSession(Resp2.SessionID);
                        if((!delReq1.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd))&&
                            (delReq1.XErr == HResult.XONLINE_E_MATCH_INVALID_SESSION_ID)) ||
                            (!delReq2.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd)) &&
                            (delReq2.XErr == HResult.XONLINE_E_MATCH_INVALID_SESSION_ID)))
                            ResultCode=TEST_RESULTS.PASSED;
                    }
                }
            }
        }
        [TestCase, Description("send six batched deadxbox messages in one request")]
			class PBatchedMsg : TestBase
        {
            override protected void Execute()
            {
                SGADDR        sg = new SGADDR();
                byte[]        sgbytes;
                // create six sessions with different SGAddr
                XRLCreateUpdateSession    []    createReqs = new XRLCreateUpdateSession[6];
                XRLSessionInfo            []    Resp = new XRLSessionInfo[6];
                for(int i = 0; i < 6; i++)
                {
                    createReqs[i] = new XRLCreateUpdateSession();

                    sg.dwSpiSg = (uint)(0x12345678 + i);
                    sgbytes = sg.toByteArray();
                    Array.Copy(sgbytes,createReqs[i].baseSession.HostAddress.abOnline,(long)Constants.SIZESGADDR);
                    if(!createReqs[i].Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out Resp[i]))
                    {
                        Global.RO.Warn("create session failed");
                        return;
                    }
                }
                // create a request that has 6 batched deadxbox message
                XRLDeadXBox    []    reqs = new XRLDeadXBox[6];
                for(int i = 0; i < 6; i++)
                {
                    reqs[i] = new XRLDeadXBox();
                    reqs[i].sgaddr.dwSpiSg = (uint)(0x12345678+i);
                    reqs[i].sgaddr.qwXboxID = sg.qwXboxID;
                    Array.Copy(sg.inaSg,reqs[i].sgaddr.inaSg,4);
                }
                if(    MyOwnExecute(reqs, Constants.SIZEDEADXBOX*6,0))
                {
                    XRLDeleteSession[]    delReqs = new XRLDeleteSession[6];
                    for(int i = 0; i < 6; i++)
                    {
                        delReqs[i] = new XRLDeleteSession(Resp[i].SessionID);
                        if((delReqs[i].Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd))) ||
                            (delReqs[i].XErr != HResult.XONLINE_E_MATCH_INVALID_SESSION_ID))
                            return;
                    }
                    ResultCode=TEST_RESULTS.PASSED;
                }
            }
        }
        [TestCase, Description("send mixed batched deadxbox messages")]
			class PMixedBatchedMsg : TestBase
        {
            override protected void Execute()
            {
                SGADDR        sg = new SGADDR();
                byte[]        sgbytes;
                // create 50 sessions with different SGAddr
                XRLCreateUpdateSession    []    createReqs = new XRLCreateUpdateSession[50];
                XRLSessionInfo            []    Resp = new XRLSessionInfo[50];
                for(int i = 0, j=0; i < 100; i++, j++)
                {
                    createReqs[j] = new XRLCreateUpdateSession();

                    sg.dwSpiSg = (uint)(0x12345678 + i);
                    sgbytes = sg.toByteArray();
                    Array.Copy(sgbytes,createReqs[j].baseSession.HostAddress.abOnline,(long)Constants.SIZESGADDR);
                    if(!createReqs[j].Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out Resp[j]))
                    {
                        Global.RO.Warn("create session failed");
                        return;
                    }
                    i++;
                }
                // create a request that has 100 batched deadxbox message
                XRLDeadXBox    []    reqs = new XRLDeadXBox[100];
                for(int i = 0; i < 100; i++)
                {
                    reqs[i] = new XRLDeadXBox();
                    if(i%2 == 0)
                        reqs[i].dwTitleID = Constants.TITLE_ID;
                    else
                        reqs[i].dwTitleID = 4019;    // nonexistent title ID
                    reqs[i].sgaddr.dwSpiSg = (uint)(0x12345678+i);
                    reqs[i].sgaddr.qwXboxID = sg.qwXboxID;
                    Array.Copy(sg.inaSg,reqs[i].sgaddr.inaSg,4);
                }
                if(    MyOwnExecute(reqs, Constants.SIZEDEADXBOX*100,0))
                {
                    XRLDeleteSession[]    delReqs = new XRLDeleteSession[50];
                    for(int i = 0; i < 50; i++)
                    {
                        delReqs[i] = new XRLDeleteSession(Resp[i].SessionID);
                        if((delReqs[i].Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd))) ||
                            (delReqs[i].XErr != HResult.XONLINE_E_MATCH_INVALID_SESSION_ID))
                            return;
                    }
                    ResultCode=TEST_RESULTS.PASSED;
                }
            }
        }
        /***************************************************************************************
         * The followings are negative cases
         ***************************************************************************************/
        [TestCase, Description("malformed deadxbox messages")]
			class NMalformedMsg : TestBase
        {
            override protected void Execute()
            {
                XRLDeadXBox    []    reqs = new XRLDeadXBox[2]{new XRLDeadXBox(), new XRLDeadXBox()};
                uint    dwTotalMsgLen = 2 * Constants.SIZEDEADXBOX + 1;
                // same DeadXbox message will be sent twice to the matchmaking front door
                if(    MyOwnExecute(reqs, dwTotalMsgLen,HResult.XONLINE_E_MATCH_REQUEST_TRUNCATED))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("truncated deadxbox messages")]
			class NTruncateMsg : TestBase
        {
            override protected void Execute()
            {
                XRLDeadXBox    []    reqs = new XRLDeadXBox[2]{new XRLDeadXBox(), new XRLDeadXBox()};
                uint    dwTotalMsgLen = 2 * Constants.SIZEDEADXBOX -1;
                // same DeadXbox message will be sent twice to the matchmaking front door
                if(    MyOwnExecute(reqs, dwTotalMsgLen,HResult.XONLINE_E_MATCH_REQUEST_TRUNCATED))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("call DeadXbox with nonexistent title ID")]
			class NUnknownTitle : TestBase
        {
            override protected void Execute()
            {
                XRLDeadXBox    req = new XRLDeadXBox();
                req.dwTitleID = 9;
                // although XStorage will throw these requests, but it still returns S_OK
                if(req.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd)))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XMatchTest\FuncSplitSession.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Matchmaking;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.FakeSG; // for CSGInfo

using xonline.common.config;
using HResult = xonline.common.service.HResult;

namespace XMatchTest
{
    // Base class for positive and negative functionals
    public class SplitTestBaseGroup : TestNode
    {
        protected class SessionData
        {
            public ulong                HostID;
            public string               HostName;
            public byte[]               SessionID;
            public uint                 dwTitleID;
            public XRLxnaddr            HostAddress;
            public byte[]               KeyExchangeKey;
            public uint                 dwPublicOpen;
            public uint                 dwPrivateOpen;
            public uint                 dwPublicFilled;
            public uint                 dwPrivateFilled;
            public XRLXeAttribParam[]   Attributes;

            public SessionData()
            {
                GenerateRandomSessionData();
            }

            public void Copy(SessionData other)
            {
                HostID          = other.HostID;
                HostName        = other.HostName;
                SessionID       = other.SessionID;
                dwTitleID       = other.dwTitleID;
                HostAddress     = other.HostAddress;
                dwPublicOpen    = other.dwPublicOpen;
                dwPrivateOpen   = other.dwPrivateOpen;
                dwPublicFilled  = other.dwPublicFilled;
                dwPrivateFilled = other.dwPrivateFilled;

                if(null == other.Attributes)
                {
                    Attributes = new XRLXeAttribParam[0];
                }
                else
                {
                    Attributes = new XRLXeAttribParam[other.Attributes.Length];
                    Array.Copy(other.Attributes, Attributes, other.Attributes.Length);
                }
            }

            // Copy the data from returned split
            public SessionData CopySearchResult(XRL2SingleSearchResult res)
            {
                SessionData session = new SessionData();

                session.SessionID       = res.SessionID;
                session.HostAddress     = res.HostAddress;
                session.KeyExchangeKey  = res.KeyExchangeKey;
                session.dwPublicOpen    = res.dwPublicOpen;
                session.dwPrivateOpen   = res.dwPrivateOpen;
                session.dwPublicFilled  = res.dwPublicFilled;
                session.dwPrivateFilled = res.dwPrivateFilled;

                return session;
            }

            public void Advertise()
            {
                XRL2CreateUpdateSession request = new XRL2CreateUpdateSession();
                XRLSessionInfo response = null;

                request.baseCreateUpdate.baseSession.SessionID          = SessionID;
                request.baseCreateUpdate.baseSession.dwTitleID          = dwTitleID;
                request.baseCreateUpdate.baseSession.HostAddress        = HostAddress;
                request.baseCreateUpdate.baseSession.dwPublicOpen       = dwPublicOpen;
                request.baseCreateUpdate.baseSession.dwPublicFilled     = dwPublicFilled;
                request.baseCreateUpdate.baseSession.dwPrivateOpen      = dwPrivateOpen;
                request.baseCreateUpdate.baseSession.dwPrivateFilled    = dwPrivateFilled;

                // Update existing attributes overwriting with new values
                request.UpdateAttribs(Attributes);

                if (!request.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out response))
                {
                    throw new UnexpectedTestResultException("CreateSession request failed:" + Global.XErrToString(request.XErr));
                }

                Global.RO.Debug("[SessionData.Advertise] new session (ID: {0}, KEK: {1})",
                        Hexer.tohex(response.SessionID),
                        Hexer.tohex(response.KeyExchangeKey));

                SessionID = response.SessionID;
                KeyExchangeKey = response.KeyExchangeKey;
            }

            public SessionData GenerateSplitSessionData(uint userIndex)
            {
                SessionData splitData = new SessionData();
                splitData.Copy(this);

                //
                // Update attributes that a new client would vary between sessions
                //
                RandomEx rand = new RandomEx();

                // These values vary and are updated in the new session data
                splitData.UpdateAttribute(Constants.X_ATTRIBUTE_GAMER_PUID,
                        new XRLXeIntValue((long)(HostID + userIndex)));
                splitData.UpdateAttribute(Constants.X_ATTRIBUTE_HOST_NAME,
                        new XRLXeStringValue(rand.GenerateRandomNameString((int)XOn.XONLINE_NAME_MAX_SIZE)));

                // These values vary but will not be reflected in the new session data
                splitData.UpdateAttribute(Constants.X_ATTRIBUTE_GAMER_MU,
                        new XRLXeDoubleValue((double)rand.Next((float)Constants.XENON_TEST_MAX_GAMER_MU)));
                splitData.UpdateAttribute(Constants.X_ATTRIBUTE_GAMER_SIGMA,
                        new XRLXeDoubleValue((double)rand.Next((float)Constants.XENON_TEST_MAX_GAMER_SIGMA)));
                splitData.UpdateAttribute(Constants.X_ATTRIBUTE_GAMER_RATING,
                        new XRLXeFloatValue(rand.Next(Constants.XENON_TEST_MAX_GAMER_RATING)));
                splitData.UpdateAttribute(Constants.X_ATTRIBUTE_GAMER_COUNTRY,
                        new XRLXeIntValue(rand.Next(255)));
                splitData.UpdateAttribute(Constants.X_ATTRIBUTE_GAMER_LANGUAGE,
                        new XRLXeIntValue(rand.Next(9)));
                splitData.UpdateAttribute(Constants.X_ATTRIBUTE_GAMER_ZONE,
                        new XRLXeIntValue(rand.Next(5)));

                // Leave type, mode since they are playing the same game
                return splitData;
            }

            public SessionData Split(uint userIndex)
            {
                SessionData splitData = GenerateSplitSessionData(userIndex);
                return Split(splitData);
            }

            public XRLSplitSession CreateXRLSplitSession(SessionData splitData)
            {
                XRLSplitSession request = new XRLSplitSession();

                request.SplitSessionID = SessionID;
                request.SessionID = new byte[] { 0x80, 0, 0, 0, 0, 0, 0, 0 };
                request.dwTitleID = splitData.dwTitleID;
                request.HostAddress = splitData.HostAddress;
                request.AttribOffsetsLen = (uint)splitData.Attributes.Length;
                request.Attribs = splitData.Attributes;
                MatchUtil.CalculateOffsets(
                        Constants.SIZESPLIT,
                        splitData.Attributes,
                        out request.AttribOffsets,
                        out request.dwMessageLength);

                return request;
            }

            private void VerifySTFException(Exception exception, uint expectedHrResult)
            {
                if (exception.GetType() != (new ServerTestFramework.UnexpectedTestResultException()).GetType())
                {
                    throw new UnexpectedTestResultException("Failed to catch expected exception: exception type " + 
                        exception.GetType().ToString() + " is not UnexpectedTestResultException");
                }
                // ex: ServerTestFramework.UnexpectedTestResultException: SplitSession request failed:80155103: XONLINE_E_MATCH_REQUEST_TOO_SMALL
                if (!exception.Message.Contains(expectedHrResult.ToString("X")))
                {
                    throw new UnexpectedTestResultException("Failed to catch expected exception: hresult " + 
                        expectedHrResult.ToString("x") + " not found." + Environment.NewLine + 
                        "exception.Message: " + exception.Message);
                }
            }


            public XRL2SingleSearchResult SafeExecute(XRLSplitSession request)
            {
                XRL2SingleSearchResult response;
                if (!request.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out response))
                {
                    throw new UnexpectedTestResultException("SplitSession request failed:" + Global.XErrToString(request.XErr));
                }

                //ValidateServerSession(session);

                return response;
            }

            public void SafeExecute(XRLSplitSession request, uint expectedHResult)
            {
                bool caught = false;
                try
                {
                    SafeExecute(request);
                }
                catch(Exception ex)
                {
                    VerifySTFException(ex, expectedHResult);
                    caught = true;
                }
                if (!caught)
                {
                    throw new UnexpectedTestResultException("Failed to catch expected exception: no exception was thrown");
                }
            }

            public SessionData Split(SessionData splitData)
            {
                XRLSplitSession request = CreateXRLSplitSession(splitData);
                SafeExecute(request);

                return splitData;
            }

            public void Delete()
            {
                XRL2DeleteSession request = new XRL2DeleteSession(SessionID, dwTitleID);
                if(!request.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd)))
                {
                    throw new UnexpectedTestResultException("DeleteSession request failed:" + Global.XErrToString(request.XErr));
                }
            }

            protected void ValidateServerSession(XRL2CreateUpdateSession session)
            {
                XRL2SearchResults   searchResults;
                XRL2SearchSession   searchReq       = new XRL2SearchSession(false, Constants.X_SSINDEX_GET_SESSION);
                long                lSessID         = Constants.sessionIDConvert(session.baseCreateUpdate.baseSession.SessionID);
                XRLXeAttribParam[]  Params          = new XRLXeAttribParam[1] {
                                           new XRLXeAttribParam(Constants.X_ATTRIBUTE_SESSION_ID ,new XRLXeIntValue(lSessID))
                };

                searchReq.AddParams(Params);
                if(!searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out searchResults))
                {
                    throw new UnexpectedTestResultException(String.Format("Search for the newly created session failed: {0:x} {1}", 
                            lSessID,
                            Global.XErrToString(searchReq.XErr)));
                }
                if(searchResults == null)
                {
                    throw new UnexpectedTestResultException(String.Format("The newly created session couldn't be found: {0:x}",
                            lSessID));
                }

                // Check if session created correctly in the t_match_sessions_<title>
                if(!session.Verify(searchResults, MatchUtil.IsRankedGameType(searchResults.results[0].Attribs)))
                {
                    throw new UnexpectedTestResultException(String.Format("The session is not setup correctly in the db: {0:x}",
                            lSessID));
                }
            }

            public void GenerateRandomSessionData()
            {
                SessionID = new byte[]{0x80,0,0,0,0,0,0,0};
                dwTitleID = Constants.XENON_TITLE;

                // Generate a random host address.  Note that abOnline must be real for platform
                // checking purposes.
                RandomEx rand = new RandomEx();
                HostAddress = new XRLxnaddr();
                HostAddress.ina         = rand.GenerateRandomBlob(4);
                HostAddress.inaOnline   = rand.GenerateRandomBlob(4);
                HostAddress.wPortOnline = (ushort)rand.Next();
                HostAddress.abEnet      = rand.GenerateRandomBlob(6);
                HostAddress.abOnline    = new SGADDR(CSGInfo.ClientType.Xenon).toByteArray();
                dwPublicOpen            = (uint)rand.Next(8, 16);
                dwPrivateOpen           = (uint)rand.Next(8, 16);
                dwPublicFilled          = (uint)rand.Next(1, 8);
                dwPrivateFilled         = (uint)rand.Next(1, 8);

                HostID                  = rand.NextPuid();
                HostName                = rand.GenerateRandomName();

                // setup some best case attributes
                Attributes = new XRLXeAttribParam[Constants.BaseSessionAttributes.Length];
                int i = 0;
                foreach(uint id in Constants.BaseSessionAttributes)
                {
                    switch(id)
                    {
                    case Constants.X_ATTRIBUTE_GAME_TYPE:
                        Attributes[i++] = new XRLXeAttribParam(id, Constants.X_ATTRIBUTE_GAME_TYPE_STANDARD);
                        break;
                    case Constants.X_ATTRIBUTE_GAME_MODE:
                        Attributes[i++] = new XRLXeAttribParam(id, 0);
                        break;
                    case Constants.X_ATTRIBUTE_GAMER_ZONE:
                        Attributes[i++] = new XRLXeAttribParam(id, 0);
                        break;
                    case Constants.X_ATTRIBUTE_GAMER_COUNTRY:
                        Attributes[i++] = new XRLXeAttribParam(id, 103);
                        break;
                    case Constants.X_ATTRIBUTE_GAMER_LANGUAGE:
                        Attributes[i++] = new XRLXeAttribParam(id, 0);
                        break;
                    case Constants.X_ATTRIBUTE_GAMER_RATING:
                        Attributes[i++] = new XRLXeAttribParam(id, 0.0f);
                        break;
                    case Constants.X_ATTRIBUTE_GAMER_MU:
                        Attributes[i++] = new XRLXeAttribParam(id, 0.0d);
                        break;
                    case Constants.X_ATTRIBUTE_GAMER_SIGMA:
                        Attributes[i++] = new XRLXeAttribParam(id, 0.0d);
                        break;
                    case Constants.X_ATTRIBUTE_GAMER_PUID:
                        Attributes[i++] = new XRLXeAttribParam(id, HostID);
                        break;
                    case Constants.X_ATTRIBUTE_HOST_NAME:
                        Attributes[i++] = new XRLXeAttribParam(id, HostName);
                        break;
                    }
                }
            }


            public void RemoveAttributes()
            {
                Attributes = null;
            }

            public void RemoveAttributesExcept(params object[] ids)
            {
                ArrayList newAttrs = new ArrayList(ids.Length);

                foreach(XRLXeAttribParam attr in Attributes)
                {
                    foreach(UInt32 id in ids)
                    {
                        if((uint)id == attr.attribParamID)
                        {
                            newAttrs.Add(attr);
                        }
                    }
                }

                Attributes = ((XRLXeAttribParam[])newAttrs.ToArray(typeof(XRLXeAttribParam)));
            }

            public void UpdateAttribute(uint attributeId, XRLXeAttribParamValue val)
            {
                foreach(XRLXeAttribParam param in Attributes)
                {
                    if(param.attribParamID == attributeId)
                    {
                        param.aValue = val;
                    }
                }
            }
        }
    }

    [TestGroup]
    public class FuncSplitSession : SplitTestBaseGroup
    {

        protected void SetupSessionForSplit(out SessionData origData, out SessionData splitData, out XRLSplitSession request)
        {
            origData = new SessionData();
            origData.Advertise();
            splitData = origData.GenerateSplitSessionData(1);
            request = origData.CreateXRLSplitSession(splitData);
        }

        #region dwMessageLength
        [BVT]
        [TestCase, Description("Mainline")]
        public void P_dwMessageLength_Valid_Attributes()
        {
            SessionData session = new SessionData();
            session.Advertise();
            session.Split(1);
        }

        [TestCase]
        public void P_dwMessageLength_Valid_No_Attributes()
        {
            SessionData session = new SessionData();
            session.Advertise();
            session.RemoveAttributes();
            session.Split(1);
        }

        [TestCase]
        public void N_dwMessageLength_Invalid_Min__uint_MinValue___0()
        {
            SessionData origData;
            SessionData splitData;
            XRLSplitSession request;
            SetupSessionForSplit(out origData, out splitData, out request);

            request.dwMessageLength = uint.MinValue;
            splitData.SafeExecute(request, HResult.XONLINE_E_MATCH_OVERFLOW);
        }

        [TestCase]
        public void N_dwMessageLength_Invalid_Max__uint_MaxValue()
        {
            SessionData origData;
            SessionData splitData;
            XRLSplitSession request;
            SetupSessionForSplit(out origData, out splitData, out request);

            request.dwMessageLength = uint.MaxValue;
            splitData.SafeExecute(request, HResult.XONLINE_E_MATCH_REQUEST_TRUNCATED);
        }

        [TestCase]
        public void N_dwMessageLength_Invalid_Off_by_one__too_low()
        {
            SessionData origData;
            SessionData splitData;
            XRLSplitSession request;
            SetupSessionForSplit(out origData, out splitData, out request);

            request.dwMessageLength--;
            splitData.SafeExecute(request, HResult.XONLINE_E_MATCH_OVERFLOW);
        }

        [TestCase]
        public void N_dwMessageLength_Invalid_Off_by_one__too_high()
        {
            SessionData origData;
            SessionData splitData;
            XRLSplitSession request;
            SetupSessionForSplit(out origData, out splitData, out request);

            request.dwMessageLength++;
            splitData.SafeExecute(request, HResult.XONLINE_E_MATCH_REQUEST_TRUNCATED);
        }
        #endregion // #region dwMessageLength

        #region SessionID
/*
        [TestCase, Ignore] // Covered by mainline
        public void P_SessionID_Valid_XNKID_flags_only()
        {
        }
*/
        [TestCase]
        public void N_SessionID_Invalid_Min()
        {
            SessionData origData;
            SessionData splitData;
            XRLSplitSession request;
            SetupSessionForSplit(out origData, out splitData, out request);

            // Min values for Session ID + XNKID
            request.SessionID = new byte[] { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
            splitData.SafeExecute(request, HResult.XONLINE_E_MATCH_INVALID_FLAGS);
        }

        [TestCase]
        public void N_SessionID_Invalid_Max()
        {
            SessionData origData;
            SessionData splitData;
            XRLSplitSession request;
            SetupSessionForSplit(out origData, out splitData, out request);

            // Max values for Session ID + XNKID
            request.SessionID = new byte[] { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF };
            splitData.SafeExecute(request, HResult.XONLINE_E_MATCH_INVALID_FLAGS);
        }
/*
        // This is actually valid, covered by the mainline positive case
        [TestCase, Ignore]
        public void N_SessionID_SessionID_Invalid_Min()
        {
            SessionData origData;
            SessionData splitData;
            XRLSplitSession request;
            SetupSessionForSplit(out origData, out splitData, out request);

            // Min value for Session ID (valid XNKID)
            request.SessionID = new byte[] { 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
            splitData.SafeExecute(request, HResult.XONLINE_E_MATCH_INVALID_FLAGS);
        }
*/
        [TestCase]
        public void N_SessionID_SessionID_Invalid_Max()
        {
            SessionData origData;
            SessionData splitData;
            XRLSplitSession request;
            SetupSessionForSplit(out origData, out splitData, out request);

            // Max value for Session ID (valid XNKID)
            request.SessionID = new byte[] { 0x80, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF };
            splitData.SafeExecute(request, HResult.XONLINE_E_MATCH_INVALID_FLAGS);
        }

        [TestCase]
        public void N_SessionID_XNKID_Invalid_Min()
        {
            SessionData origData;
            SessionData splitData;
            XRLSplitSession request;
            SetupSessionForSplit(out origData, out splitData, out request);

            // Min value for XNKID (valid/empty Session ID)
            request.SessionID[0] = 0x00;
            request.SessionID[1] = 0x00;
            splitData.SafeExecute(request, HResult.XONLINE_E_MATCH_INVALID_FLAGS);
        }

        [TestCase]
        public void N_SessionID_XNKID_Invalid_Max()
        {
            SessionData origData;
            SessionData splitData;
            XRLSplitSession request;
            SetupSessionForSplit(out origData, out splitData, out request);

            // Max value for XNKID (valid/empty Session ID)
            request.SessionID[0] = 0xFF;
            request.SessionID[1] = 0xFF;
            splitData.SafeExecute(request, HResult.XONLINE_E_MATCH_INVALID_FLAGS);
        }

        [TestCase]
        public void N_SessionID_Invalid_SessionID_Specified()
        {
            SessionData origData;
            SessionData splitData;
            XRLSplitSession request;
            SetupSessionForSplit(out origData, out splitData, out request);

            // Create a SessionID value with a valid XNKID and random garbage for a session ID
            request.SessionID = new byte[8];
            RandomEx.GlobalRandGen.NextBytes(request.SessionID);
            request.SessionID[0] = 0x80;
            request.SessionID[1] = 0x00;
            splitData.SafeExecute(request, HResult.XONLINE_E_MATCH_INVALID_FLAGS);
        }

        [TestCase]
        public void N_SessionID_Invalid_Missing_XNKID()
        {
            SessionData origData;
            SessionData splitData;
            XRLSplitSession request;
            SetupSessionForSplit(out origData, out splitData, out request);

            // Zero out the XNKID
            request.SessionID = new byte[8];
            RandomEx.GlobalRandGen.NextBytes(request.SessionID);
            request.SessionID[0] = 0x00;
            request.SessionID[1] = 0x00;
            splitData.SafeExecute(request, HResult.XONLINE_E_MATCH_INVALID_FLAGS);
        }

        [TestCase]
        public void N_SessionID_Invalid_Session_ID_Equal_to_Split_Session_ID()
        {
            SessionData origData;
            SessionData splitData;
            XRLSplitSession request;
            SetupSessionForSplit(out origData, out splitData, out request);

            // The SessionID field is set to the same value as the SplitSessionID field
            request.SessionID = request.SplitSessionID;
            splitData.SafeExecute(request, HResult.XONLINE_E_MATCH_INVALID_FLAGS);
        }
        #endregion // #region SessionID

        #region SplitSessionID
/*
        [TestCase, Ignore] // Convered by mainline
        public void P_SplitSessionID_New_Split()
        {
        }
*/
        [TestCase]
        public void P_SplitSessionID_Split_Original_Session_Twice()
        {
            SessionData session = new SessionData();
            session.Advertise();
            session.Split(1);
            session.Split(2);
        }
        [TestCase]
        public void P_SplitSessionID_Split_Already_Split_Session()
        {
            SessionData session = new SessionData();
            session.Advertise();
            SessionData split = session.Split(1);
            split.Split(2);
        }

        [TestCase]
        public void N_SplitSessionID_Invalid_Min()
        {
            SessionData origData;
            SessionData splitData;
            XRLSplitSession request;
            SetupSessionForSplit(out origData, out splitData, out request);

            // Min values for Session ID + XNKID
            request.SplitSessionID = new byte[] { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
            splitData.SafeExecute(request, HResult.XONLINE_E_MATCH_INVALID_SESSION_ID);
        }

        [TestCase]
        public void N_SplitSessionID_Invalid_Max()
        {
            SessionData origData;
            SessionData splitData;
            XRLSplitSession request;
            SetupSessionForSplit(out origData, out splitData, out request);

            // Max values for Session ID + XNKID
            request.SplitSessionID = new byte[] { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF };
            // NOTE: this used to be XONLINE_E_MATCH_INVALID_SESSION_ID, which is more correct,
            // but the front door code changed in Fall07 to return SERVER_ERROR. (see LSG bug 4035)
            splitData.SafeExecute(request, HResult.XONLINE_E_MATCH_SERVER_ERROR);  
        }

        [TestCase]
        public void N_SplitSessionID_SessionID_Invalid_Min()
        {
            SessionData origData;
            SessionData splitData;
            XRLSplitSession request;
            SetupSessionForSplit(out origData, out splitData, out request);

            // Min value for Session ID (valid XNKID)
            request.SplitSessionID = new byte[] { 0x90, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
            splitData.SafeExecute(request, HResult.XONLINE_E_MATCH_INVALID_SESSION_ID);
        }

        [TestCase]
        public void N_SplitSessionID_SessionID_Invalid_Max()
        {
            SessionData origData;
            SessionData splitData;
            XRLSplitSession request;
            SetupSessionForSplit(out origData, out splitData, out request);

            // Max value for Session ID (valid XNKID)
            request.SplitSessionID = new byte[] { 0x80, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF };
            splitData.SafeExecute(request, HResult.XONLINE_E_MATCH_INVALID_SESSION_ID);
        }

        [TestCase]
        public void N_SplitSessionID_XNKID_Invalid_Min()
        {
            SessionData origData;
            SessionData splitData;
            XRLSplitSession request;
            SetupSessionForSplit(out origData, out splitData, out request);

            // Min value for XNKID (valid Session ID)
            request.SplitSessionID[0] = 0x00;
            request.SplitSessionID[1] = 0x00;
            splitData.SafeExecute(request, HResult.XONLINE_E_MATCH_INVALID_SESSION_ID);
        }

        [TestCase]
        public void N_SplitSessionID_XNKID_Invalid_Max()
        {
            SessionData origData;
            SessionData splitData;
            XRLSplitSession request;
            SetupSessionForSplit(out origData, out splitData, out request);

            // Max value for XNKID (valid Session ID)
            request.SplitSessionID[0] = 0xFF;
            request.SplitSessionID[1] = 0xFF;
            // NOTE: this used to be XONLINE_E_MATCH_INVALID_SESSION_ID, which is more correct,
            // but the front door code changed in Fall07 to return SERVER_ERROR. (see LSG bug 4035)
            splitData.SafeExecute(request, HResult.XONLINE_E_MATCH_SERVER_ERROR);
        }

        [TestCase]
        public void N_SplitSessionID_Invalid_Non_Existent_Session_ID()
        {
            SessionData origData;
            SessionData splitData;
            XRLSplitSession request;
            SetupSessionForSplit(out origData, out splitData, out request);

            // Generate random session IDs until we find one that doesn't exist
            long nonExistentSessionId;
            do
            {
                nonExistentSessionId = (long)(RandomEx.GlobalRandGen.NextUlong() & 0xFFFFFFFFFFFF0000);
            } while (MatchUtil.VerifySessionExists(request.dwTitleID, nonExistentSessionId));

            request.SplitSessionID = Constants.sessionIDConvert(nonExistentSessionId);
            request.SplitSessionID[0] = 0x80;
            request.SplitSessionID[1] = 0x00;
            splitData.SafeExecute(request, HResult.XONLINE_E_MATCH_INVALID_SESSION_ID);
        }

        [TestCase, Ignore]
        public void N_SplitSessionID_Incorrect_session__a_session_not_owned_by_the_original_host()
        {
            //TODO: isn't it valid to split any session by any console?
        }
        #endregion // #region SplitSessionID

        #region dwTitleID

/*
        [TestCase, Ignore] // Covered by mainline
        public void P_dwTitleID_Valid_previous_title_ID()
        {
        }
*/
        [TestCase]
        public void N_dwTitleID_Invalid_Min()
        {
            SessionData origData;
            SessionData splitData;
            XRLSplitSession request;
            SetupSessionForSplit(out origData, out splitData, out request);

            request.dwTitleID = uint.MinValue;
            splitData.SafeExecute(request, HResult.XONLINE_E_MATCH_INVALID_TITLE_ID);
        }

        [TestCase]
        public void N_dwTitleID_Invalid_Max()
        {
            SessionData origData;
            SessionData splitData;
            XRLSplitSession request;
            SetupSessionForSplit(out origData, out splitData, out request);

            request.dwTitleID = uint.MaxValue;
            splitData.SafeExecute(request, HResult.XONLINE_E_MATCH_INVALID_TITLE_ID);
        }

        private uint GetInvalidTitleId()
        {
            uint randomUint;
            MatchTitle matchTitle;
            do
            {
                randomUint = (uint)RandomEx.GlobalRandGen.Next();
                matchTitle = MatchTitleMgr.GetMatchTitle(randomUint);
            } while (matchTitle != null);

            return randomUint;
        }

        [TestCase]
        public void N_dwTitleID_Invalid_Non_Existent()
        {
            SessionData origData;
            SessionData splitData;
            XRLSplitSession request;
            SetupSessionForSplit(out origData, out splitData, out request);

            request.dwTitleID = GetInvalidTitleId();
            splitData.SafeExecute(request, HResult.XONLINE_E_MATCH_INVALID_TITLE_ID);
        }

        private uint GetValidTitleId()
        {
            List<MatchTitle> matchTitles = MatchTitleMgr.GetMatchTitles();
            int randIndex = RandomEx.GlobalRandGen.Next(matchTitles.Count);
            return (uint)matchTitles[randIndex].TitleId;
        }

        [TestCase]
        public void N_dwTitleID_Incorrect_Title_ID__doesn_t_match_previous_title_ID()
        {
            SessionData origData;
            SessionData splitData;
            XRLSplitSession request;
            SetupSessionForSplit(out origData, out splitData, out request);

            uint newTitleId = GetValidTitleId();
            while (newTitleId == request.dwTitleID)
            {
                newTitleId = GetValidTitleId();
            }
            request.dwTitleID = newTitleId;
            splitData.SafeExecute(request, HResult.XONLINE_E_MATCH_INVALID_SESSION_ID);
        }

        [TestCase]
        public void N_dwTitleID_Incorrect_Title_ID__doesn_t_match_Auth_ticket()
        {
            SessionData origData;
            SessionData splitData;
            XRLSplitSession request;
            SetupSessionForSplit(out origData, out splitData, out request);

            // Manually populate the slot with the wrong title ID
            request.dwTitleID--;
            request.ManualPopulateSlot();
            request.dwTitleID++;

            Global.XEnv.OverrideSetting("xmatchfd", "ALL", "xmatchfd_enableAuthCheck", "true");
            MatchFDs.ConfigCacheRefresh();
            try
            {
                splitData.SafeExecute(request, HResult.XONLINE_E_INVALID_TITLE_ID);
            }
            finally
            {
                Global.XEnv.DeleteOverrideSetting("xmatchfd", "ALL", "xmatchfd_enableAuthCheck");
                MatchFDs.ConfigCacheRefresh();
            }
        }
        #endregion // dwTitleID

        #region HostAddress
/*
        [TestCase, Ignore] // Handled by Mainline
        public void P_HostAddress_New_Host()
        {
        }
*/
        [TestCase]
        public void P_HostAddress_Old_Host()
        {
            SessionData session = new SessionData();
            session.Advertise();
            session.Split(0);
        }

        [TestCase]
        public void N_HostAddress_Invalid_Random_Values()
        {
            SessionData origData;
            SessionData splitData;
            XRLSplitSession request;

            SetupSessionForSplit(out origData, out splitData, out request);
            request.HostAddress = MatchUtil.CreateRandomXNADDR();

            Global.XEnv.OverrideSetting("xmatchfd", "ALL", "xmatchfd_enableAuthCheck", "true");
            MatchFDs.ConfigCacheRefresh();
            try
            {
                splitData.SafeExecute(request, HResult.XONLINE_E_SERVER_ERROR);
            }
            finally
            {
                Global.XEnv.DeleteOverrideSetting("xmatchfd", "ALL", "xmatchfd_enableAuthCheck");
                MatchFDs.ConfigCacheRefresh();
            }
        }
        #endregion // #region HostAddress

        #region Attributes
/*
        [TestCase, Ignore] // Handled by P_dwMessageLength_Valid_No_Attributes
        public void P_Attributes_0_attributes()
        {
        }
*/
        [TestCase]
        public void P_Attributes_Valid_1_attributes_GamerPuid_only()
        {
            SessionData session = new SessionData();
            session.Advertise();
            session.RemoveAttributesExcept(Constants.X_ATTRIBUTE_GAMER_PUID);
            session.Split(1);
        }
        [TestCase]
        public void P_Attributes_Valid__1_attributes__HostName_only()
        {
            SessionData session = new SessionData();
            session.Advertise();
            session.RemoveAttributesExcept(Constants.X_ATTRIBUTE_HOST_NAME);
            session.Split(1);
        }
        [TestCase]
        public void P_Attributes_Valid_1_attributes_other()
        {
            SessionData session = new SessionData();
            session.Advertise();
            session.RemoveAttributesExcept(Constants.X_ATTRIBUTE_GAME_TYPE);
            session.Split(1);
        }
        [TestCase]
        public void P_Attributes_Valid_2_attributes_GamerPuid_HostName()
        {
            SessionData session = new SessionData();
            session.Advertise();
            session.RemoveAttributesExcept(Constants.X_ATTRIBUTE_GAMER_PUID, Constants.X_ATTRIBUTE_HOST_NAME);
            session.Split(1);
        }
/*
        [TestCase, Ignore] // Handled by mainline
        public void P_Attributes_Valid_10_attributes_GamerPuid_HostName_others()
        {
        }
*/
        // No title config which supports this yet
        [TestCase, Ignore]
        public void P_Attributes_Valid_Max_50_Attributes_GamerPuid_HostName_others()
        {
        }

        [TestCase]
        public void N_Attributes_Invalid_Too_Many__63_attributes__GamerPuid_HostName___others()
        {
            SessionData origData;
            SessionData splitData;
            XRLSplitSession request;
            SetupSessionForSplit(out origData, out splitData, out request);

            request.Attribs = new XRLXeAttribParam[63];
            request.AttribOffsetsLen = 63;
            for (int i = 0; i < request.Attribs.Length; i++)
            {
                request.Attribs[i] = new XRLXeAttribParam((uint)i, i);
            }
            MatchUtil.CalculateOffsets(Constants.SIZESPLIT, request.Attribs, out request.AttribOffsets, out request.dwMessageLength);
            splitData.SafeExecute(request, HResult.XONLINE_E_MATCH_TOO_MANY_ATTR);
        }
        #endregion // #region Attributes

        #region dwNumAttributes

        [TestCase]
        public void N_dwNumAttributes_Invalid_Max()
        {
            SessionData origData;
            SessionData splitData;
            XRLSplitSession request;
            SetupSessionForSplit(out origData, out splitData, out request);

            request.WriteStreamCalculatesOffsetsLen = false;
            request.AttribOffsetsLen = uint.MaxValue;
            splitData.SafeExecute(request, HResult.XONLINE_E_MATCH_TOO_MANY_ATTR);
        }

        [TestCase]
        public void N_dwNumAttributes_Invalid_Off_By_One_Too_Low()
        {
            SessionData origData;
            SessionData splitData;
            XRLSplitSession request;
            SetupSessionForSplit(out origData, out splitData, out request);

            request.WriteStreamCalculatesOffsetsLen = false;
            request.AttribOffsetsLen--;
            splitData.SafeExecute(request, HResult.XONLINE_E_MATCH_INVALID_ATTRIBUTE_ID);
        }

        [TestCase]
        public void N_dwNumAttributes_Invalid_Off_By_One_Too_High()
        {
            SessionData origData;
            SessionData splitData;
            XRLSplitSession request;
            SetupSessionForSplit(out origData, out splitData, out request);

            request.WriteStreamCalculatesOffsetsLen = false;
            request.AttribOffsetsLen++;
            splitData.SafeExecute(request, HResult.XONLINE_E_MATCH_INVALID_ATTRIBUTE_ID);
        }
        #endregion // #region dwNumAttributes

        #region rgdwAttributes

        [TestCase]
        public void N_rgdwAttrOffsets_Invalid_Off_by_one_Offset()
        {
            SessionData origData;
            SessionData splitData;
            XRLSplitSession request;
            SetupSessionForSplit(out origData, out splitData, out request);

            request.WriteStreamCalculatesOffsetsLen = false;
            request.AttribOffsetsLen = (uint)request.AttribOffsets.Length;
            uint[] newAttribOffets = new uint[request.AttribOffsets.Length - 1];
            for (int i = 0; i < newAttribOffets.Length; i++)
            {
                newAttribOffets[i] = request.AttribOffsets[i];
            }
            request.AttribOffsets = newAttribOffets;

            splitData.SafeExecute(request, HResult.XONLINE_E_MATCH_INVALID_ATTRIBUTE_ID);
        }

        [TestCase]
        public void N_rgdwAttrOffsets_Invalid_First_Attribute()
        {
            SessionData origData;
            SessionData splitData;
            XRLSplitSession request;
            SetupSessionForSplit(out origData, out splitData, out request);

            request.AttribOffsets[0] = 0xFF;
            splitData.SafeExecute(request, HResult.XONLINE_E_MATCH_INVALID_OFFSET);
        }

        [TestCase]
        public void N_rgdwAttrOffsets_Invalid_Last_Attribute()
        {
            SessionData origData;
            SessionData splitData;
            XRLSplitSession request;
            SetupSessionForSplit(out origData, out splitData, out request);

            request.AttribOffsets[request.AttribOffsets.Length - 1] = 0xFF;
            splitData.SafeExecute(request, HResult.XONLINE_E_MATCH_INVALID_OFFSET);
        }

        [TestCase]
        public void N_rgdwAttrOffsets_Invalid_Missing_All_Attribute_Offsets()
        {
            SessionData origData;
            SessionData splitData;
            XRLSplitSession request;
            SetupSessionForSplit(out origData, out splitData, out request);

            request.WriteStreamCalculatesOffsetsLen = false;
            request.AttribOffsetsLen = (uint)request.AttribOffsets.Length;
            request.AttribOffsets = null;

            splitData.SafeExecute(request, HResult.XONLINE_E_MATCH_INVALID_ATTRIBUTE_ID);
        }

        [TestCase]
        public void N_rgdwAttrOffsets_Invalid_Off_by_one__too_low()
        {
            SessionData origData;
            SessionData splitData;
            XRLSplitSession request;
            SetupSessionForSplit(out origData, out splitData, out request);

            for (int i = 1; i < request.AttribOffsets.Length; i++)
            {
                request.AttribOffsets[i]--;
            }

            splitData.SafeExecute(request, HResult.XONLINE_E_MATCH_INVALID_OFFSET);
        }

        [TestCase]
        public void N_rgdwAttrOffsets_Invalid_Off_by_one__too_high()
        {
            SessionData origData;
            SessionData splitData;
            XRLSplitSession request;
            SetupSessionForSplit(out origData, out splitData, out request);

            for (int i = 0; i < request.AttribOffsets.Length; i++)
            {
                request.AttribOffsets[i]++;
            }

            splitData.SafeExecute(request, HResult.XONLINE_E_MATCH_INVALID_OFFSET);
        }
        #endregion // #region rgdwAttributes

        #region rgAttributes
/*
        [TestCase, Ignore] // Handled by mainline (mu/sigma)
        public void P_rgAttributes_Valid_Double_Value()
        {
        }

        [TestCase, Ignore] // Handled by mainline (rating)
        public void P_rgAttributes_Valid_Float_Value()
        {
        }
*/
        [TestCase]
        public void P_rgAttributes_Valid_Invalid_Attribute_ID__not_in_schema_or_sproc()
        {
            SessionData origData;
            SessionData splitData;
            XRLSplitSession request;
            SetupSessionForSplit(out origData, out splitData, out request);

            XRLXeAttribParam[] oldAttribs = request.Attribs;
            request.Attribs = new XRLXeAttribParam[oldAttribs.Length + 1];
            Array.Copy(oldAttribs, request.Attribs, oldAttribs.Length);
            request.Attribs[request.Attribs.Length - 1] = new XRLXeAttribParam(0x200000FF, (long)1);
            request.AttribOffsetsLen++;
            MatchUtil.CalculateOffsets(Constants.SIZESPLIT, request.Attribs, out request.AttribOffsets, out request.dwMessageLength);
            splitData.SafeExecute(request);
        }

        [TestCase]
        public void N_rgAttributes_Invalid_Missing_All_Attributes()
        {
            SessionData origData;
            SessionData splitData;
            XRLSplitSession request;
            SetupSessionForSplit(out origData, out splitData, out request);

            request.Attribs = null;
            splitData.SafeExecute(request, HResult.XONLINE_E_END_OF_STREAM);
        }

        [TestCase]
        public void N_rgAttributes_Invalid_Off_by_one__too_low()
        {
            SessionData origData;
            SessionData splitData;
            XRLSplitSession request;
            SetupSessionForSplit(out origData, out splitData, out request);

            // Remove an attrib
            XRLXeAttribParam[] newAttribs = new XRLXeAttribParam[request.Attribs.Length - 1];
            Array.Copy(request.Attribs, newAttribs, request.Attribs.Length - 1);
            request.Attribs = newAttribs;
            splitData.SafeExecute(request, HResult.XONLINE_E_END_OF_STREAM);
        }

        [TestCase]
        public void N_rgAttributes_Invalid_Off_by_one__too_high()
        {
            SessionData origData;
            SessionData splitData;
            XRLSplitSession request;
            SetupSessionForSplit(out origData, out splitData, out request);

            // Add an extra attrib
            XRLXeAttribParam[] oldAttribs = request.Attribs;
            request.Attribs = new XRLXeAttribParam[oldAttribs.Length + 1];
            Array.Copy(oldAttribs, request.Attribs, oldAttribs.Length);
            request.Attribs[request.Attribs.Length - 1] = new XRLXeAttribParam(0x2000001B, (long)1);
            splitData.SafeExecute(request, HResult.XONLINE_E_MATCH_OVERFLOW);
        }
        #endregion // #region rgAttributes

        //create a session.  Delete it, and then split.
        [TestCase]
        public void P_Create_Delete_Split()
        {
            bool success = true;

            MatchSession session = new MatchSession(false);
            session.TitleID = 0x585207D6;
            success = session.Create() && success;
            success = session.Delete() && success;
            MatchSession splitSession = session.Split(true);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XMatchTest\MatchCommands.cs ===
using System;
using System.Collections.Generic;
using ServerTestFramework.LiveService.Matchmaking;
using System.Text;

namespace XMatchTest
{
    #region CommandEngine

    public class CommandState
    {
    }

    public interface ICommand
    {
        void Execute(CommandState state);
    }

    public class CommandList : List<ICommand>
    {
    }

    public class MultiCommand : CommandList, ICommand
    {
        public MultiCommand(ICommand command)
        {
            Add(command);
        }

        public MultiCommand(params ICommand[] commands)
        {
            foreach (ICommand command in commands)
            {
                Add(command);
            }
        }

        public virtual void Execute(CommandState state)
        {
            foreach (ICommand command in this)
            {
                CommandEngine.Execute(state, command);
            }
        }
    }

    public class MTMultiCommand : MultiCommand
    {
        static public int MaxExecutionThreads = 100;
        public int NumExecutionThreads = 10;

        public override void Execute(CommandState state)
        {
            //TODO: Make multi-threaded, 1 thread per command up to NumExecutionThreads for this instance
            // but no more than MaxExecutionThreads threads across all MTMultiCommands
            base.Execute(state);
        }
    }

    static public class CommandEngine
    {
        static public void Execute(CommandState state, ICommand command)
        {
            command.Execute(state);
        }

        static public void Execute(CommandState state, params ICommand[] commands)
        {
            foreach (ICommand command in commands)
            {
                command.Execute(state);
            }
        }
    }
    #endregion // #region CommandEngine

    #region MatchCommands

    public class MatchState : CommandState
    {
        public MatchSession Session;

        public MatchState()
        {
            Session = new MatchSession(false);  //do not create this session immediately
        }

        public MatchState(MatchSession session)
        {
            Session = session;
        }
    }

    public abstract class MatchCommand : ICommand
    {
        public void Execute(CommandState state)
        {
            Execute((MatchState)state);
        }

        public abstract void Execute(MatchState state);
    }

    /// <summary>
    /// Provides a measure of type-safety for split operations
    /// </summary>
    public interface IMatchSplitCommand : ICommand
    {
    }

    public class CreateCmd : MatchCommand
    {
        public SessionType sessionType;

        public CreateCmd(SessionType sessionType)
        {
            this.sessionType = sessionType;
        }

        public override void Execute(MatchState state)
        {
            state.Session.Create(sessionType);
        }
    }

    public class JoinCmd : MatchCommand
    {
        public int NewPublicFilled;
        public int NewPrivateFilled;

        public JoinCmd(int newPublicFilled, int newPrivateFilled)
        {
            NewPublicFilled = newPublicFilled;
            NewPrivateFilled = newPrivateFilled;
        }

        public override void Execute(MatchState state)
        {
            state.Session.Join(NewPublicFilled, NewPrivateFilled);
        }
    }

    public class SplitCmd : MatchCommand, IMatchSplitCommand
    {
        public MultiCommand NewSessionCmds = null;
        public bool ChangeHost = true;

        public SplitCmd(MultiCommand newSessionCmds, bool changeHost)
        {
            NewSessionCmds = newSessionCmds;
            ChangeHost = changeHost;
        }

        public override void Execute(MatchState state)
        {
            MatchSession newSession = state.Session.Split(ChangeHost);
            CommandEngine.Execute(new MatchState(newSession), NewSessionCmds);
        }
    }

    /// <summary>
    /// Simulates a session host disconnection
    /// </summary>
    public class HostDCSplitCmd : MultiCommand, IMatchSplitCommand
    {
        public HostDCSplitCmd(MultiCommand newSessionCmds)
        {
            Add(new DeadXboxCmd());
            Add(new SplitCmd(newSessionCmds, true));
        }
    }

    /// <summary>
    /// Simulates a network issue that prevents one group from communicating with the host
    /// </summary>
    public class NetworkSplitCmd : MultiCommand, IMatchSplitCommand
    {
        public NetworkSplitCmd(MultiCommand newSessionCmds)
        {
            Add(new SplitCmd(newSessionCmds, true));
        }
    }

    /// <summary>
    /// Simulates a voluntary host migration, as when the title determines the current host
    /// is no longer the best host for the match.
    /// </summary>
    public class ElectiveSplitCmd : MultiCommand, IMatchSplitCommand
    {
        public ElectiveSplitCmd(MultiCommand newSessionCmds, bool changeHost)
        {
            Add(new DeleteCmd());
            Add(new SplitCmd(newSessionCmds, changeHost));
        }
    }

    public class MultiSplitCmd : MTMultiCommand, IMatchSplitCommand
    {
        public MultiSplitCmd(params IMatchSplitCommand[] commands)
        {
            foreach (IMatchSplitCommand command in commands)
            {
                Add(command);
            }
        }
    }

    public class DeleteCmd : MatchCommand
    {
        public override void Execute(MatchState state)
        {
            state.Session.Delete();
        }
    }

    public class VerifySessionCmd : MatchCommand
    {
        public override void Execute(MatchState state)
        {
            //TODO: Put in good verification tests for each API method
        }
    }

    public class DeadXboxCmd : MatchCommand
    {
        public override void Execute(MatchState state)
        {
            state.Session.DeadXbox();
        }
    }
    #endregion // #region MatchCommands
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XMatchTest\ICorThreadPool.cs ===
using System;
using System.Runtime.InteropServices;

namespace XMatchTest
{
	[
	// CLSID_CorRuntimeHost from MSCOREE.DLL
	Guid("CB2F6723-AB3A-11D2-9C40-00C04FA30A3E"),
	ComImport
	]
	public class CorRuntimeHost
	{
	}

	public class CLRThreadPool
	{
		public static ICorThreadPool Controller
		{
			get { return(thePool); }
		}

		private static ICorThreadPool thePool = (ICorThreadPool)new CorRuntimeHost();
	}

	// The ICorThreadpool interface is documented (prototypes only) in
	// mscoree.h, but is not made available from mscoree.tlb.  So the
	// following interop stub lets us get our hands on the interface
	// in order to query/control the CLR-managed thread pool.
	//
	// Because I'm only interested in adjusting the thread pool
	// configuration, most of the members are actually invalid and
	// cannot be called in their current form.
	//
	[
	// IID_ICorThreadpool
	Guid("84680D3A-B2C1-46e8-ACC2-DBC0A359159A"),
	InterfaceType(ComInterfaceType.InterfaceIsIUnknown)
	]
	public interface ICorThreadPool
	{
		void RegisterWaitForSingleObject(); // DO NOT CALL - INCORRECT STACK FRAME
		void UnregisterWait(); // DO NOT CALL - INCORRECT STACK FRAME
		void QueueUserWorkItem(); // DO NOT CALL - INCORRECT STACK FRAME
		void CreateTimer(); // DO NOT CALL - INCORRECT STACK FRAME
		void ChangeTimer(); // DO NOT CALL - INCORRECT STACK FRAME
		void DeleteTimer(); // DO NOT CALL - INCORRECT STACK FRAME
		void BindIoCompletionCallback(); // DO NOT CALL - INCORRECT STACK FRAME
		void CallOrQueueUserWorkItem(); // DO NOT CALL - INCORRECT STACK FRAME
		void SetMaxThreads( uint MaxWorkerThreads, uint MaxIOCompletionThreads );
		void GetMaxThreads( out uint MaxWorkerThreads, out uint MaxIOCompletionThreads );
		void GetAvailableThreads( out uint AvailableWorkerThreads, out uint AvailableIOCompletionThreads );
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XMatchTest\MatchReplayFile.cs ===
/**MatchReplayFile.cs
 * Given a matchFD's applog, this class reads it and parses it into a structure of requests.
 * The initial parsing will only pick out the following:
 *     1.Timestamp
 *     2.Request Type
 *     3.Time Elapsed
 *     4.TitleID
 * Each of these is stored in a structure.  Timestamp will be stored relative to the first entry.
 * During playback, get the current time and compare it to the elements in the structure.  Items
 * since the last timestamp will be executed.  Sleep until the next timestamp.
 */

using System;
using System.Collections;
using System.IO;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.Utilities;
using xonline.common.config;

namespace XMatchTest {
    public class ReplayData {
        public TimeSpan timeFromStart;  //time since the first event in the log.  The first ReplayData should
                                 //have a zero here.
        public RequestTypeEnum requestType;
        public int elapsedTime;
        public uint titleID;

        static string [] requestTypes = {"MatchInsertXbox360",
                                  "MatchUpdateXbox360",
                                  "MatchSearchRankedXbox360", 
                                  "MatchSearchStandardXbox360",
                                  "MatchSearchWeightedXbox360",
                                  "MatchSearchByIdXbox360",
                                  "MatchDeleteXbox360",
                                  "MatchSplitSession",
                                  "MatchDeadXbox"};
        public enum RequestTypeEnum {
            INSERT = 0,
            UPDATE,
            SEARCH_RANKED,
            SEARCH_STANDARD,
            SEARCH_WEIGHTED,
            SEARCH_BYID,
            DELETE,
            SPLIT,
            DEADXBOX,
            INVALID_TYPE
        }

        //given a string, populate a ReplyData.  timeFromStart will be the time read minus the startTime.
        public ReplayData(string s, DateTime startTime) {
            try {
                timeFromStart = DateTime.Parse(getNthItem(s, 0)).Subtract(startTime);
                requestType = ConvertRequestToNum(getNthItem(s, 1));
                elapsedTime = Int32.Parse(getNthItem(s, 3));
                if (requestType == RequestTypeEnum.DEADXBOX) {
                    titleID = Convert.ToUInt32(getNthItem(s, 6), 16);
                } else {
                    titleID = Convert.ToUInt32(getNthItem(s, 5), 16);
                }
            } catch (FormatException) {
//                Global.RO.Error("Error!  The following line failed to parse:");
//                Global.RO.Error(s);
            }
        }
        
        //use this to get the first DateTime in the file.
        public static DateTime GetDateTime(string s) {
            return DateTime.Parse(getNthItem(s, 0));
        }
        private static RequestTypeEnum ConvertRequestToNum(string s) {
            for (int i=0; i<requestTypes.Length; i++) {
                if (requestTypes[i].CompareTo(s) == 0) {
                    return (RequestTypeEnum) i;
                }
            }
//            Global.RO.Error("Error!  Attempting to read unrecognized request type, " + s);
            return RequestTypeEnum.INVALID_TYPE;
        }
        
        //grab the nth item.  Delimiter is the '|' character.
        private static string getNthItem(string s, int n) {
            int currentPos = 0;
            int lastPos = 0;
            for (int i=0; i<=n; i++) {
                lastPos = currentPos + 1;
                currentPos = s.IndexOf('|', currentPos + 1);
            }
            return s.Substring(lastPos, currentPos - lastPos);
        }

        public override string ToString() {
            return timeFromStart.ToString() + "|" + requestType + "|" + elapsedTime + "|" + titleID.ToString("X") + "\n";
        }

    }


    public class ReplayFile {
        public ArrayList logData;
        public Hashtable titles;

        public ReplayFile(string filePath) {
            logData = new ArrayList();
            titles = new Hashtable();
            if (!File.Exists(filePath)) {
                Global.RO.Error("Error!  Attempt to load invalid file:" + filePath);
                return;
            }
            Global.RO.Info("Loading " + filePath);
            using (StreamReader sr = File.OpenText(filePath)) {
                DateTime startTimeStamp = DateTime.Now;  //just set it to something for now.
                bool firstLine = true;
                string s = "";
                while ((s = sr.ReadLine()) != null) {
                    if (firstLine) {
                        startTimeStamp = ReplayData.GetDateTime(s);
                        firstLine = false;
                    }
                    ReplayData thisLine = new ReplayData(s, startTimeStamp);
                    logData.Add(thisLine);
                    titles[thisLine.titleID] = 1;
                }
            }
        }

        public static string CreateInterfaceBucketInsertString(uint titleid, string serverName) {
            string env = Global.XEnv.GetEnv().ToLower();
            return "if not exists (select * from t_interface_buckets where i_title_id = 0x" + titleid.ToString("X") + ")\n" +
                "  begin\n" + 
                "insert into t_interface_buckets values ('" + env + "' ,'xmatch', 0x" + titleid.ToString("X") + ", 0 , '" + 
                serverName + "', '" + serverName + "', '1900-01-01 12:00:00.000', 'FASTFAIL_MATCH_TESTING', 'FASTFAIL_MATCH_TESTING', '', '')\n " +
                "insert into t_interface_buckets values ('" + env + "' ,'xmatch', 0x" + titleid.ToString("X") + ", 65536 , '" + 
                serverName + "', '" + serverName + "', '1900-01-01 12:00:00.000', 'FASTFAIL_MATCH_TESTING', 'FASTFAIL_MATCH_TESTING', '', '')\n " +
                "  end\n";
        }

        //create a t_match_titles entry for this title if it doesn't exist already.  The unique
        //identifier for this is the i_session_expiration and the i_delete_delay_seconds, the
        //combination of which is unique enough to be deleted.

        //NOTE:What do we do for titles that already exist, but are on different servers?
        //fix later?
        const int SESSION_EXPIRATION_NUMBER = 97511;
        const int DELETE_DELAY_SECONDS = 411;
        public static string CreateTMatchTitlesInsertString(uint titleid, string serverName) {
            return "if not exists (select * from t_match_titles where i_title_id = 0x" + titleid.ToString("X") + ")\n" +
                " begin\n" +
                "insert into t_match_titles values(0x" + titleid.ToString("X") + ", " + SESSION_EXPIRATION_NUMBER + 
                ", null, '" + serverName + "', " + DELETE_DELAY_SECONDS + ", null)\n" +
                "end\n";
        }

        //clean up all interface buckets created.
        public static string CreateCleanupBucketString() {
            return "delete from t_interface_buckets where vc_info1 = 'FASTFAIL_MATCH_TESTING'" + 
                " and vc_info2 = 'FASTFAIL_MATCH_TESTING'";
        }
        public static string CreateCleanupTMatchTitlesString() {
            return "delete from t_match_titles where i_session_expiration = " + SESSION_EXPIRATION_NUMBER + 
                " and i_delete_delay_seconds = " + DELETE_DELAY_SECONDS;
        }

        
        public override string ToString() {
            string ans = "";
            for(int i=0; i<logData.Count; i++) {
//                Global.RO.Info(((ReplayData) logData[i]).ToString());
                ans += ((ReplayData) logData[i]).ToString();
            }
            ans += "\n\n";
            foreach (uint titleid in titles.Keys) {
                ans += titleid.ToString("X") + "\n";
            }
            return ans;
        }

        public static void Main (string [] args) {
            ReplayFile testFile = new ReplayFile("SampleLog.txt");
            Console.WriteLine(testFile.ToString());
//            Console.WriteLine(testFile.CreateInterfaceBucketInsertString());
        }

    }

    //Given a ReplayFile, execute it against matchFDs.
    public class ReplayFileExecutor {
        DateTime startTime;
        ReplayFile replay;
        Hashtable delayHandles;

        public ReplayFileExecutor(ReplayFile replay) {
            this.replay = replay;
            delayHandles = new Hashtable();
        }


        //for every title in the replay file, prepare the server.
        public void Initialize() {
            string [] servers = Global.XEnv.GetServerListByInterface(Interface.xmatch);
            int i=0; //spread titles over all servers.  Not the best approximation, but it will have
                     //to do.
            foreach(DictionaryEntry de in replay.titles) {
                uint titleid = (uint) de.Key;
                MatchDelayedRequests delayHandle = new MatchDelayedRequests(titleid);
                delayHandle.PrepareServers(servers[i], titleid);
                delayHandles[titleid] = delayHandle;
                i = (i + 1) % servers.Length;
            }
        }

        //a simple scheduler that fires requests based on time from start.  This is too slow for
        //fast titles.  ThreadPool and worker threads are likely needed here.
        public void Execute() {
            int index = 0;
            startTime = DateTime.UtcNow;
            try {
                while (index < replay.logData.Count) {
                    TimeSpan runToTime = DateTime.UtcNow - startTime;
                    //fire all requests that have occurred until we hit runToTime
                    while ( ((ReplayData) replay.logData[index]).timeFromStart < runToTime) {
                        uint title = ((ReplayData) replay.logData[index]).titleID;
                        ((MatchDelayedRequests) delayHandles[title]).ExecuteDelayedRequestAsync(
                            (ReplayData) replay.logData[index]);
                        index++;
                    }
                    //All requests fired.  Give them a chance to start.
                    Thread.Sleep(0);
                }
            } finally {
                //clean up NPDB and the SQL sprocs afterwards.
                foreach(DictionaryEntry de in delayHandles) {
                    MatchDelayedRequests delayHandle = (MatchDelayedRequests) de.Value;
                    delayHandle.Cleanup(false);
                }
                Global.XEnv.ExecuteXmgmtCommand(Interface.xmatchfd, "e :xmatchfd reloadtitleinfo");
            }
        }


    }



}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XMatchTest\FuncUpdateSession.cs ===
using System;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Matchmaking;
using xonline.common.config;

namespace XMatchTest
{
    internal abstract class NegativeUpdateTestBase : TestBase
    {
        protected bool UpdateTestNegative(XRLCreateUpdateSession Req, uint XErr)
        {
            if (Req.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd)))
            {
                Global.RO.Warn("Negative UpdateSession request succeed unexpectedly");
                return false;
            }
            if(Req.XErr != XErr)
            {
                Global.RO.Warn("Wrong error code (" + Global.XErrToString(Req.XErr) + " != " + Global.XErrToString(XErr) + ") returned");
                return false;
            }
            return true;
        }
    }
    internal abstract class UpdateTestBase : TestBase
    {
        private bool compareBaseSession(XRLCreateUpdateSession updateReq,XRLSingleSearchResult    searchResult)
        {
            bool    ret = false, sameValue = true;
            if((updateReq.baseSession.dwPrivateFilled == searchResult.dwPrivateFilled)
                &&(updateReq.baseSession.dwPrivateOpen == searchResult.dwPrivateOpen)
                &&(updateReq.baseSession.dwPublicOpen == searchResult.dwPublicOpen)
                &&(updateReq.baseSession.dwPublicFilled == searchResult.dwPublicFilled))
            {
                XRLxnaddr    expectedHostAddr = updateReq.baseSession.HostAddress;
                XRLxnaddr    resultHostAddr = searchResult.HostAddress;
                if(expectedHostAddr.wPortOnline==resultHostAddr.wPortOnline)
                {
                    for(int i = 0; i < expectedHostAddr.ina.Length;i++)
                        if(expectedHostAddr.ina[i]!=resultHostAddr.ina[i])
                            sameValue = false;
                    for(int i = 0; i < expectedHostAddr.inaOnline.Length;i++)
                        if(expectedHostAddr.inaOnline[i]!=resultHostAddr.inaOnline[i])
                            sameValue = false;
                    for(int i = 0; i < expectedHostAddr.abEnet.Length; i++)
                        if(expectedHostAddr.abEnet[i]!=resultHostAddr.abEnet[i])
                            sameValue = false;
                    for(int i = 0; i < expectedHostAddr.abOnline.Length; i++)
                        if(expectedHostAddr.abOnline[i]!=resultHostAddr.abOnline[i])
                            sameValue = false;
                    if(sameValue)
                        ret = true;
                }
            }
            return ret;
        }
        // expectedAttribs is null means no addtional attributes in the search results are expected
        protected bool UpdateAndVerify(XRLCreateUpdateSession Req,WireData[] expectedAttribs,uint spIndex)
        {
            bool    ret = false;
            long    SessID = Constants.sessionIDConvert(Req.baseSession.SessionID);
            if (Req.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd)))
            {
                // search based on SessionID
                XRLSearchSession    searchReq = new XRLSearchSession(spIndex);
                searchReq.baseSearchSession.dwTitleID = Req.baseSession.dwTitleID;
                XRLAttribParam [] searchParam = new XRLAttribParam[1]{new XRLAttribParam(Constants.X_ATTRIBUTE_DATATYPE_INTEGER,new XRLIntParam(SessID))};
                searchReq.AddParams(searchParam);
                XRLSearchResults    srchResp;

                // no addtional attributes expected to be checked
                if((expectedAttribs == null)&&(searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out srchResp)))
                {
                    if(srchResp == null)
                    {
                        Global.RO.Warn("Although session update succeed, but can't find the session!");
                        return false;
                    }
                    if(compareBaseSession(Req,srchResp.results[0]))
                         return true;
                    else return false;
                }
                else if(searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),1,expectedAttribs,out srchResp))
                {
                    if(srchResp!=null && (srchResp.resultsLen==1))
                    {
                        // verify baseSessionInfo
                        if(compareBaseSession(Req,srchResp.results[0]))
                        {//verify addtional attribs
                            uint    numAttribs;
                            XRLIntParam        intTemp;
                            XRLStringParam    strTemp;
                            XRLBlobParam    blobTemp;
                            XRLNullParam    nullTemp;
                            if((numAttribs=(uint)expectedAttribs.Length) == srchResp.results[0].AttribOffsetsLen)
                            {
                                for(int i = 0; i < numAttribs; i++)
                                {
                                    if((expectedAttribs[i].GetType())==(srchResp.results[0].Attribs[i].aValue.GetType()))
                                    {
                                        if((intTemp=(expectedAttribs[i] as XRLIntParam)) != null)
                                            if(intTemp.intValue != (srchResp.results[0].Attribs[i].aValue as XRLIntParam).intValue)
                                                return false;
                                        if((strTemp=(expectedAttribs[i] as XRLStringParam)) != null)
                                            if(string.Compare(strTemp.strValue,(srchResp.results[0].Attribs[i].aValue as XRLStringParam).strValue)!=0)
                                                return false;
                                        if((blobTemp=(expectedAttribs[i] as XRLBlobParam)) != null)
                                        {
                                            XRLBlobParam blob=srchResp.results[0].Attribs[i].aValue as XRLBlobParam;
                                            if((blob!=null)&&(blob.blobLen==blobTemp.blobLen))
                                            {
                                                for(int j = 0; j < blob.blobLen;j++)
                                                    if(blobTemp.blob[j]!=blob.blob[j])
                                                        return false;
                                            }
                                            else    return false;
                                        }
                                        if((nullTemp=(expectedAttribs[i] as XRLNullParam)) != null)
                                        {
                                            XRLNullParam    np=srchResp.results[0].Attribs[i].aValue as XRLNullParam;
                                            if(np == null)
                                                return false;
                                        }
                                    }
                                    else    return false;
                                }
                                ret = true;
                            }
                        }
                    }
                    else
                    {
                        Global.RO.Warn("Session Update succeed, but couldn't find the session or more than 1 session found");
                        return false;
                    }
                }
                else
                    Global.RO.Warn("search for the session failed"+Global.XErrToString(searchReq.XErr));
            }
            else
                Global.RO.Warn("Positive updateSession failed:"+Global.XErrToString(Req.XErr));
            return ret;
        }
    }

    // These tests are deprecated, as Xbox1 support is removed.  These will be deleted in the next release.
    [TestGroup, Ignore]
    public class FuncUpdateSession : TestNode
    {
        /*****************************************************************************
         * The following cases are positive cases
         *****************************************************************************/
        [BVT]
        [TestCase, Description("modify public/private open/filled slots")]
			class PNormalCase : UpdateTestBase
        {
            override protected void Execute()
            {
                // create a session with no attributes first
                XRLCreateUpdateSession        createReq = new XRLCreateUpdateSession();
                XRLSessionInfo                Resp;
                if(createReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out Resp))
                {
                    XRLCreateUpdateSession        updateReq = new XRLCreateUpdateSession();
                    updateReq.CopySGInfoFrom(createReq);
                    Array.Copy(Resp.SessionID,updateReq.baseSession.SessionID,8);
                    updateReq.baseSession.dwPrivateOpen -= 1;
                    updateReq.baseSession.dwPublicOpen -= 1;
                    updateReq.baseSession.dwPrivateFilled += 1;
                    updateReq.baseSession.dwPublicFilled += 1;
                    if(UpdateAndVerify(updateReq,null,Constants.X_SSINDEX_GET_SESSION))
                        ResultCode=TEST_RESULTS.PASSED;
                    //delete the session
                    XRLDeleteSession    delReq = new XRLDeleteSession(Resp.SessionID);
                    delReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                }
            }
        }
        [TestCase, Description("decrement private/public open slots to zero")]
			class PZeroOpenSlots : UpdateTestBase
        {
            override protected void Execute()
            {
                // create a session with no attributes first
                XRLCreateUpdateSession        createReq = new XRLCreateUpdateSession();
                XRLSessionInfo                Resp;
                if(createReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out Resp))
                {
                    XRLCreateUpdateSession        updateReq = new XRLCreateUpdateSession();
                    updateReq.CopySGInfoFrom(createReq);
                    Array.Copy(Resp.SessionID,updateReq.baseSession.SessionID,8);
                    updateReq.baseSession.dwPrivateOpen = 0;
                    updateReq.baseSession.dwPublicOpen = 0;
                    if(UpdateAndVerify(updateReq,null,Constants.X_SSINDEX_GET_SESSION))
                        ResultCode=TEST_RESULTS.PASSED;
                    //delete the session
                    XRLDeleteSession    delReq = new XRLDeleteSession(Resp.SessionID);
                    delReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                }
            }
        }
        //[TestCase, Description("update HostAddress")]
		// we do not allow to update HostAddress
		class PHostAddrUpdate : UpdateTestBase
        {
            override protected void Execute()
            {
                // create a session with no attributes first
                XRLCreateUpdateSession        createReq = new XRLCreateUpdateSession();
                XRLSessionInfo                Resp;
                if(createReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out Resp))
                {
                    XRLCreateUpdateSession        updateReq = new XRLCreateUpdateSession();
                    updateReq.CopySGInfoFrom(createReq);
                    Array.Copy(Resp.SessionID,updateReq.baseSession.SessionID,8);
                    updateReq.baseSession.HostAddress.wPortOnline = 9;
                    updateReq.baseSession.HostAddress.inaOnline = new byte[4]{0x33,0x99,0x88,0x22};
                    if(UpdateAndVerify(updateReq,null,Constants.X_SSINDEX_GET_SESSION))
                        ResultCode=TEST_RESULTS.PASSED;
                    //delete the session
                    XRLDeleteSession    delReq = new XRLDeleteSession(Resp.SessionID);
                    delReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                }
            }
        }
        [TestCase, Description("add new int attribute to a session")]
        class PAddIntAttrib : UpdateTestBase
        {
            override protected void Execute()
            {
                // create a session with no attributes first
                XRLCreateUpdateSession createReq = new XRLCreateUpdateSession();
                createReq.baseSession.dwTitleID = 0x3e7;
                XRLSessionInfo Resp;
                if (!createReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out Resp))
                {
                    Global.RO.Error("Execute failed: {0}", Global.XErrToString(createReq.XErr));
                    return;
                }
                XRLCreateUpdateSession updateReq = new XRLCreateUpdateSession();
                updateReq.CopySGInfoFrom(createReq);
                updateReq.baseSession.dwTitleID = 0x3e7;
                Array.Copy(Resp.SessionID, updateReq.baseSession.SessionID, 8);
                WireData[] Attribs = new WireData[1] { new XRLIntAttribute(0x6, -1) };
                updateReq.AddAttribs(Attribs);
                // spIndex=7 return intAttribute(43690=0xaaa)'s value
                WireData[] expectedAttribs = new WireData[1] { new XRLIntParam(-1) };
                if (UpdateAndVerify(updateReq, expectedAttribs, 2))
                    ResultCode = TEST_RESULTS.PASSED;
                //delete the session
                XRLDeleteSession delReq = new XRLDeleteSession(Resp.SessionID);
                delReq.dwTitleID = 0x3e7;
                delReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
            }
        }
        [TestCase, Description("31596:add new string attribute with max value to a session")]
			class PAddStringAttrib : UpdateTestBase
        {
            override protected void Execute()
            {
                // create a session with no attributes first
                XRLCreateUpdateSession        createReq = new XRLCreateUpdateSession();
                createReq.baseSession.dwTitleID = 0x3e7;
                XRLSessionInfo                Resp;
                if(createReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out Resp))
                {
                    XRLCreateUpdateSession        updateReq = new XRLCreateUpdateSession();
                    updateReq.CopySGInfoFrom(createReq);
                    updateReq.baseSession.dwTitleID = 0x3e7;
                    Array.Copy(Resp.SessionID,updateReq.baseSession.SessionID,8);
                    string    strVal = new string('a',(int)Constants.X_MAX_STRING_ATTRIBUTE_LEN)+'\0';
                    WireData [] Attribs = new WireData[1]{new XRLStringAttribute(0x100007,strVal)};
                    updateReq.AddAttribs(Attribs);
                    // spIndex=3 return string value
                    WireData [] expectedAttribs = new WireData[1]{new XRLStringParam(strVal)};
                    if(UpdateAndVerify(updateReq,expectedAttribs,3))
                        ResultCode=TEST_RESULTS.PASSED;
                    //delete the session
                    XRLDeleteSession    delReq = new XRLDeleteSession(Resp.SessionID);
                    delReq.dwTitleID = 0x3e7;
                    delReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                }
            }
        }
        [TestCase, Description("add new blob attribute with max value to a session")]
			class PAddBlobAttrib : UpdateTestBase
        {
            override protected void Execute()
            {
                // create a session with no attributes first
                XRLCreateUpdateSession        createReq = new XRLCreateUpdateSession();
                createReq.baseSession.dwTitleID = 0x3e7;
                XRLSessionInfo                Resp;
                if(createReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out Resp))
                {
                    XRLCreateUpdateSession        updateReq = new XRLCreateUpdateSession();
                    updateReq.CopySGInfoFrom(createReq);
                    updateReq.baseSession.dwTitleID = 0x3e7;
                    Array.Copy(Resp.SessionID,updateReq.baseSession.SessionID,8);
                    byte[]    blobVal = new byte[Constants.X_MAX_BLOB_ATTRIBUTE_LEN];
                    new Random().NextBytes(blobVal);
                    WireData [] Attribs = new WireData[1]{new XRLBlobAttribute(0x00200008,blobVal)};
                    updateReq.AddAttribs(Attribs);
                    // spIndex=4 return intAttribute(43690=0xaaa)'s value
                    WireData [] expectedAttribs = new WireData[1]{new XRLBlobParam(blobVal)};
                    if(UpdateAndVerify(updateReq,expectedAttribs,4))
                        ResultCode=TEST_RESULTS.PASSED;
                    //delete the session
                    XRLDeleteSession    delReq = new XRLDeleteSession(Resp.SessionID);
                    delReq.dwTitleID = 0x3e7;
                    delReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                }
            }
        }
        [TestCase, Description("update an existing int attribute")]
			class PUpdateIntAttrib : UpdateTestBase
        {
            override protected void Execute()
            {
                // create a session with one int attributes first
                XRLCreateUpdateSession        createReq = new XRLCreateUpdateSession();
                createReq.baseSession.dwTitleID = 0x3e7;
                long    intVal = 898989;
                uint    intAttribID = 0x6;
                createReq.AddAttribs(new WireData[1]{new XRLIntAttribute(intAttribID,intVal)});
                    XRLSessionInfo                Resp;
                if(createReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out Resp))
                {
                    XRLCreateUpdateSession        updateReq = new XRLCreateUpdateSession();
                    updateReq.CopySGInfoFrom(createReq);
                    updateReq.baseSession.dwTitleID = 0x3e7;
                    Array.Copy(Resp.SessionID,updateReq.baseSession.SessionID,8);
                    long    newIntVal = 90;
                    updateReq.AddAttribs(new WireData[1]{new XRLIntAttribute(intAttribID,newIntVal)});
                    // spIndex=2 return int value
                    WireData [] expectedAttribs = new WireData[1]{new XRLIntParam(newIntVal)};
                    if(UpdateAndVerify(updateReq,expectedAttribs,2))
                        ResultCode=TEST_RESULTS.PASSED;
                    //delete the session
                    XRLDeleteSession    delReq = new XRLDeleteSession(Resp.SessionID);
                    delReq.dwTitleID = 0x3e7;
                    delReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                }
            }
        }
        [TestCase, Description("31593:update an existing string attribute")]
			class PUpdateStrAttrib : UpdateTestBase
        {
            override protected void Execute()
            {
                // create a session with string attributes first
                XRLCreateUpdateSession        createReq = new XRLCreateUpdateSession();
                createReq.baseSession.dwTitleID = 0x3e7;
                uint                        strAttribID = 0x00100007;
                createReq.AddAttribs(new WireData[1]{new XRLStringAttribute(strAttribID,"abc\0")});
                XRLSessionInfo                Resp;
                if(createReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out Resp))
                {
                    XRLCreateUpdateSession        updateReq = new XRLCreateUpdateSession();
                    updateReq.CopySGInfoFrom(createReq);
                    updateReq.baseSession.dwTitleID = 0x3e7;
                    Array.Copy(Resp.SessionID,updateReq.baseSession.SessionID,8);
                    string    strVal = "This is a new string value"+'\0';
                    WireData [] Attribs = new WireData[1]{new XRLStringAttribute(strAttribID,strVal)};
                    updateReq.AddAttribs(Attribs);
                    // spIndex=3 return string value
                    WireData [] expectedAttribs = new WireData[1]{new XRLStringParam(strVal)};
                    if(UpdateAndVerify(updateReq,expectedAttribs,3))
                        ResultCode=TEST_RESULTS.PASSED;
                    //delete the session
                    XRLDeleteSession    delReq = new XRLDeleteSession(Resp.SessionID);
                    delReq.dwTitleID = 0x3e7;
                    delReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                }
            }
        }
        [TestCase, Description("update an existing blob attribute")]
			class PUpdateBlobAttrib : UpdateTestBase
        {
            override protected void Execute()
            {
                // create a session with blob attributes first
                XRLCreateUpdateSession        createReq = new XRLCreateUpdateSession();
                createReq.baseSession.dwTitleID = 0x3e7;
                byte []    blob = new byte[8]{1,2,3,4,5,6,7,8};
                uint    blobAttribID = 0x00200008;
                createReq.AddAttribs(new WireData[1]{new XRLBlobAttribute(blobAttribID,blob)});
                XRLSessionInfo                Resp;
                if(createReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out Resp))
                {
                    XRLCreateUpdateSession        updateReq = new XRLCreateUpdateSession();
                    updateReq.CopySGInfoFrom(createReq);
                    updateReq.baseSession.dwTitleID = 0x3e7;
                    Array.Copy(Resp.SessionID,updateReq.baseSession.SessionID,8);
                    byte[]    blobVal = new byte[100];
                    new Random().NextBytes(blobVal);
                    WireData [] Attribs = new WireData[1]{new XRLBlobAttribute(blobAttribID,blobVal)};
                    updateReq.AddAttribs(Attribs);
                    WireData [] expectedAttribs = new WireData[1]{new XRLBlobParam(blobVal)};
                    if(UpdateAndVerify(updateReq,expectedAttribs,4))
                        ResultCode=TEST_RESULTS.PASSED;
                    //delete the session
                    XRLDeleteSession    delReq = new XRLDeleteSession(Resp.SessionID);
                    delReq.dwTitleID = 0x3e7;
                    delReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                }
            }
        }
        [TestCase, Description("31593:update existing int/blob/string attributes in that order")]
			class PUpdateThreeAttribs1 : UpdateTestBase
        {
            override protected void Execute()
            {
                // create a session with three attributes first
                uint    intAttribID = 0x6,blobAttribID = 0x00200008,strAttribID = 0x00100007;

                XRLCreateUpdateSession        createReq = new XRLCreateUpdateSession();
                createReq.baseSession.dwTitleID = 0x3e7;
                byte []        blob = new byte[5]{1,2,3,4,5};
                WireData    [] Attribs = new WireData[3]{    new XRLIntAttribute(intAttribID,123),
                                                            new XRLStringAttribute(strAttribID,"abc\0"),
                                                            new XRLBlobAttribute(blobAttribID,blob)};
                createReq.AddAttribs(Attribs);
                XRLSessionInfo                Resp;
                if(createReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out Resp))
                {
                    XRLCreateUpdateSession        updateReq = new XRLCreateUpdateSession();
                    updateReq.CopySGInfoFrom(createReq);
                    updateReq.baseSession.dwTitleID = 0x3e7;
                    Array.Copy(Resp.SessionID,updateReq.baseSession.SessionID,8);
                    byte[]    blobVal = new byte[Constants.X_MAX_BLOB_ATTRIBUTE_LEN];
                    new Random().NextBytes(blobVal);
                    long    intVal = new Random().Next();
                    string    strVal = "this is a test string\0";
                    WireData [] attribs = new WireData[3]{new XRLBlobAttribute(blobAttribID,blobVal),
                                                            new XRLIntAttribute(intAttribID,intVal),
                                                            new XRLStringAttribute(strAttribID,strVal)};
                    updateReq.AddAttribs(attribs);
                    // spIndex = 5 return 3 attribs
                    WireData [] expectedAttribs = new WireData[3]{ new XRLIntParam(intVal),
                                                                    new XRLStringParam(strVal),
                                                                    new XRLBlobParam(blobVal)};
                    if(UpdateAndVerify(updateReq,expectedAttribs,5))
                        ResultCode=TEST_RESULTS.PASSED;
                    //delete the session
                    XRLDeleteSession    delReq = new XRLDeleteSession(Resp.SessionID);
                    delReq.dwTitleID = 0x3e7;
                    delReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                }
            }
        }
        [TestCase, Description("31593:update existing int/string/blob attributes in that order")]
			class PUpdateThreeAttribs2 : UpdateTestBase
        {
            override protected void Execute()
            {
                // create a session with three attributes first
                uint    intAttribID = 0x6,blobAttribID = 0x00200008,strAttribID = 0x00100007;

                XRLCreateUpdateSession        createReq = new XRLCreateUpdateSession();
                createReq.baseSession.dwTitleID = 0x3e7;
                byte []        blob = new byte[5]{1,2,3,4,5};
                WireData    [] Attribs = new WireData[3]{    new XRLIntAttribute(intAttribID,123),
                                                            new XRLStringAttribute(strAttribID,"abc\0"),
                                                            new XRLBlobAttribute(blobAttribID,blob)};
                createReq.AddAttribs(Attribs);
                XRLSessionInfo                Resp;
                if(createReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out Resp))
                {
                    XRLCreateUpdateSession        updateReq = new XRLCreateUpdateSession();
                    updateReq.CopySGInfoFrom(createReq);
                    updateReq.baseSession.dwTitleID = 0x3e7;
                    Array.Copy(Resp.SessionID,updateReq.baseSession.SessionID,8);
                    byte[]    blobVal = new byte[100];
                    new Random().NextBytes(blobVal);
                    long    intVal = new Random().Next();
                    string    strVal = "this is a test string\0";
                    WireData [] attribs = new WireData[3]{new XRLIntAttribute(intAttribID,intVal),
                                                          new XRLStringAttribute(strAttribID,strVal),
                                                          new XRLBlobAttribute(blobAttribID,blobVal)
                                                             };
                    updateReq.AddAttribs(attribs);
                    // spIndex = 5 return 3 attribs
                    WireData [] expectedAttribs = new WireData[3]{    new XRLIntParam(intVal),
                                                                    new XRLStringParam(strVal),
                                                                    new XRLBlobParam(blobVal)
                                                                    };
                    if(UpdateAndVerify(updateReq,expectedAttribs,5))
                        ResultCode=TEST_RESULTS.PASSED;
                    //delete the session
                    XRLDeleteSession    delReq = new XRLDeleteSession(Resp.SessionID);
                    delReq.dwTitleID = 0x3e7;
                    delReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                }
            }
        }
        [TestCase, Description("31593:update existing blob/int/string attributes in that order")]
			class PUpdateThreeAttribs3 : UpdateTestBase
        {
            override protected void Execute()
            {
                // create a session with three attributes first
                uint    intAttribID = 0x6,blobAttribID = 0x00200008,strAttribID = 0x00100007;

                XRLCreateUpdateSession        createReq = new XRLCreateUpdateSession();
                createReq.baseSession.dwTitleID = 0x3e7;
                byte []        blob = new byte[5]{1,2,3,4,5};
                WireData    [] Attribs = new WireData[3]{    new XRLIntAttribute(intAttribID,123),
                                                            new XRLStringAttribute(strAttribID,"abc\0"),
                                                            new XRLBlobAttribute(blobAttribID,blob)};
                createReq.AddAttribs(Attribs);
                XRLSessionInfo                Resp;
                if(createReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out Resp))
                {
                    XRLCreateUpdateSession        updateReq = new XRLCreateUpdateSession();
                    updateReq.CopySGInfoFrom(createReq);
                    updateReq.baseSession.dwTitleID = 0x3e7;
                    Array.Copy(Resp.SessionID,updateReq.baseSession.SessionID,8);
                    byte[]    blobVal = new byte[100];
                    new Random().NextBytes(blobVal);
                    long    intVal = new Random().Next();
                    string    strVal = "this is a test string\0";
                    WireData [] attribs = new WireData[3]{new XRLBlobAttribute(blobAttribID,blobVal),
                                                             new XRLIntAttribute(intAttribID,intVal),
                                                             new XRLStringAttribute(strAttribID,strVal)};
                    updateReq.AddAttribs(attribs);
                    // spIndex = 5 return 3 attribs
                    WireData [] expectedAttribs = new WireData[3]{    new XRLIntParam(intVal),
                                                                     new XRLStringParam(strVal),
                                                                     new XRLBlobParam(blobVal)
                                                                 };
                    if(UpdateAndVerify(updateReq,expectedAttribs,5))
                        ResultCode=TEST_RESULTS.PASSED;
                    //delete the session
                    XRLDeleteSession    delReq = new XRLDeleteSession(Resp.SessionID);
                    delReq.dwTitleID = 0x3e7;
                    delReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                }
            }
        }
        [TestCase, Description("update existing blob/string/int attributes in that order")]
			class PUpdateThreeAttribs4 : UpdateTestBase
        {
            override protected void Execute()
            {
                // create a session with three attributes first
                uint    intAttribID = 0x6,blobAttribID = 0x00200008,strAttribID = 0x00100007;

                XRLCreateUpdateSession        createReq = new XRLCreateUpdateSession();
                createReq.baseSession.dwTitleID = 0x3e7;
                byte []        blob = new byte[5]{1,2,3,4,5};
                WireData    [] Attribs = new WireData[3]{    new XRLIntAttribute(intAttribID,123),
                                                            new XRLStringAttribute(strAttribID,"abc\0"),
                                                            new XRLBlobAttribute(blobAttribID,blob)};
                createReq.AddAttribs(Attribs);
                XRLSessionInfo                Resp;
                if(createReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out Resp))
                {
                    XRLCreateUpdateSession        updateReq = new XRLCreateUpdateSession();
                    updateReq.CopySGInfoFrom(createReq);
                    updateReq.baseSession.dwTitleID = 0x3e7;
                    Array.Copy(Resp.SessionID,updateReq.baseSession.SessionID,8);
                    byte[]    blobVal = new byte[100];
                    new Random().NextBytes(blobVal);
                    long    intVal = new Random().Next();
                    string    strVal = "this is a test string\0";
                    WireData [] attribs = new WireData[3]{new XRLBlobAttribute(blobAttribID,blobVal),
                                                        new XRLStringAttribute(strAttribID,strVal),
                                                        new XRLIntAttribute(intAttribID,intVal)
                                                             };
                    updateReq.AddAttribs(attribs);
                    // spIndex = 5 return 3 attribs
                    WireData [] expectedAttribs = new WireData[3]{    new XRLIntParam(intVal),
                                                                     new XRLStringParam(strVal),
                                                                     new XRLBlobParam(blobVal)
                                                                 };
                    if(UpdateAndVerify(updateReq,expectedAttribs,5))
                        ResultCode=TEST_RESULTS.PASSED;
                    //delete the session
                    XRLDeleteSession    delReq = new XRLDeleteSession(Resp.SessionID);
                    delReq.dwTitleID = 0x3e7;
                    delReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                }
            }
        }
        [TestCase, Description("update existing string/int/blob attributes in that order")]
			class PUpdateThreeAttribs5 : UpdateTestBase
        {
            override protected void Execute()
            {
                // create a session with three attributes first
                uint    intAttribID = 0x6,blobAttribID = 0x00200008,strAttribID = 0x00100007;

                XRLCreateUpdateSession        createReq = new XRLCreateUpdateSession();
                createReq.baseSession.dwTitleID = 0x3e7;
                byte []        blob = new byte[5]{1,2,3,4,5};
                WireData    [] Attribs = new WireData[3]{    new XRLIntAttribute(intAttribID,123),
                                                            new XRLStringAttribute(strAttribID,"abc\0"),
                                                            new XRLBlobAttribute(blobAttribID,blob)};
                createReq.AddAttribs(Attribs);
                XRLSessionInfo                Resp;
                if(createReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out Resp))
                {
                    XRLCreateUpdateSession        updateReq = new XRLCreateUpdateSession();
                    updateReq.CopySGInfoFrom(createReq);
                    updateReq.baseSession.dwTitleID = 0x3e7;
                    Array.Copy(Resp.SessionID,updateReq.baseSession.SessionID,8);
                    byte[]    blobVal = new byte[100];
                    new Random().NextBytes(blobVal);
                    long    intVal = new Random().Next();
                    string    strVal = "this is a test string\0";
                    WireData [] attribs = new WireData[3]{
                                                            new XRLStringAttribute(strAttribID,strVal),
                                                            new XRLIntAttribute(intAttribID,intVal),
                                                            new XRLBlobAttribute(blobAttribID,blobVal)
                                                         };
                    updateReq.AddAttribs(attribs);
                    // spIndex = 5 return 3 attribs
                    WireData [] expectedAttribs = new WireData[3]{    new XRLIntParam(intVal),
                                                                     new XRLStringParam(strVal),
                                                                     new XRLBlobParam(blobVal)
                                                                    };
                    if(UpdateAndVerify(updateReq,expectedAttribs,5))
                        ResultCode=TEST_RESULTS.PASSED;
                    //delete the session
                    XRLDeleteSession    delReq = new XRLDeleteSession(Resp.SessionID);
                    delReq.dwTitleID = 0x3e7;
                    delReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                }
            }
        }
        [TestCase, Description("31593:update existing string/blob/int attributes in that order")]
			class PUpdateThreeAttribs6 : UpdateTestBase
        {
            override protected void Execute()
            {
                // create a session with three attributes first
                uint    intAttribID = 0x6,blobAttribID = 0x00200008,strAttribID = 0x00100007;

                XRLCreateUpdateSession        createReq = new XRLCreateUpdateSession();
                createReq.baseSession.dwTitleID = 0x3e7;
                byte []        blob = new byte[5]{1,2,3,4,5};
                WireData    [] Attribs = new WireData[3]{    new XRLIntAttribute(intAttribID,123),
                                                            new XRLStringAttribute(strAttribID,"abc\0"),
                                                            new XRLBlobAttribute(blobAttribID,blob)};
                createReq.AddAttribs(Attribs);
                XRLSessionInfo                Resp;
                if(createReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out Resp))
                {
                    XRLCreateUpdateSession        updateReq = new XRLCreateUpdateSession();
                    updateReq.CopySGInfoFrom(createReq);
                    updateReq.baseSession.dwTitleID = 0x3e7;
                    Array.Copy(Resp.SessionID,updateReq.baseSession.SessionID,8);
                    byte[]    blobVal = new byte[100];
                    new Random().NextBytes(blobVal);
                    long    intVal = new Random().Next();
                    string    strVal = "this is a test string\0";
                    WireData [] attribs = new WireData[3]{    new XRLStringAttribute(strAttribID,strVal),
                                                            new XRLBlobAttribute(blobAttribID,blobVal),
                                                             new XRLIntAttribute(intAttribID,intVal)
                                                         };
                    updateReq.AddAttribs(attribs);
                    // spIndex = 5 return 3 attribs
                    WireData [] expectedAttribs = new WireData[3]{    new XRLIntParam(intVal),
                                                                     new XRLStringParam(strVal),
                                                                     new XRLBlobParam(blobVal)
                    };
                    if(UpdateAndVerify(updateReq,expectedAttribs,5))
                        ResultCode=TEST_RESULTS.PASSED;
                    //delete the session
                    XRLDeleteSession    delReq = new XRLDeleteSession(Resp.SessionID);
                    delReq.dwTitleID = 0x3e7;
                    delReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                }
            }
        }
        /*****************************************************************************
         * The following cases are negative cases
         *****************************************************************************/
        [TestCase, Description("try to update a nonexistent session")]
			class NNonExistSession : NegativeUpdateTestBase
        {
            override protected void Execute()
            {
                //start by creating a good session
                XRLCreateUpdateSession        createGoodReq = new XRLCreateUpdateSession();
                XRLSessionInfo                Resp;
                if(!createGoodReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out Resp)) {
                    Global.RO.Warn("Could not create a generic session to modify!");
                }

                XRLCreateUpdateSession        updateReq = new XRLCreateUpdateSession();
                updateReq.baseSession.SessionID = new byte[8];
                //copy over the bytes of the other session
                for(int i=0; i<8; i++) {
                    updateReq.baseSession.SessionID[i] = Resp.SessionID[i];
                }
                //muck up the two bytes to get an invalid session.  We'll use xor, even though it
                //takes a million typecasts.  Note these two bytes are in reversed order.
                //i.e. they're serialized in reverse, so we modify bytes 6 and 7 to get the most
                //significant bits.
                updateReq.baseSession.SessionID[6] = (byte) ((int)updateReq.baseSession.SessionID[6] ^ (int) 0xFF);
                updateReq.baseSession.SessionID[7] = (byte) ((int)updateReq.baseSession.SessionID[7] ^ (int) 0xFF);
                if(UpdateTestNegative(updateReq,HResult.XONLINE_E_MATCH_INVALID_SESSION_ID))
                    ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("update session with string attributes longer than that specified in xms file")]
			class NOverflowStringAttrib : NegativeUpdateTestBase
        {
            override protected void Execute()
            {
                // create a session with no attributes first
                XRLCreateUpdateSession        createReq = new XRLCreateUpdateSession();
                XRLSessionInfo                Resp;
                if(createReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out Resp))
                {
                    XRLCreateUpdateSession        updateReq = new XRLCreateUpdateSession();
                    updateReq.CopySGInfoFrom(createReq);
                    Array.Copy(Resp.SessionID,updateReq.baseSession.SessionID,8);
                    // max length in xms is 20
                    string strValue = new string('a',21);
                    strValue += '\0';
                    WireData [] attribs = new WireData[1]{new XRLStringAttribute(Constants.SAMPLE_STRING_ATTRIB2,strValue)};
                    updateReq.AddAttribs(attribs);
                    if(UpdateTestNegative(updateReq,HResult.XONLINE_E_MATCH_OVERFLOW))
                        ResultCode=TEST_RESULTS.PASSED;
                    //delete the session
                    XRLDeleteSession    delReq = new XRLDeleteSession(Resp.SessionID);
                    delReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                }
                else
                    Global.RO.Warn("CreateSession failed:"+Global.XErrToString(createReq.XErr));
            }
        }
        [TestCase, Description("update session with blob attribute longer than that specified in xms file")]
			class NOverflowBlobAttrib : NegativeUpdateTestBase
        {
            override protected void Execute()
            {
                // create a session with no attributes first
                XRLCreateUpdateSession        createReq = new XRLCreateUpdateSession();
                XRLSessionInfo                Resp;
                if(createReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out Resp))
                {
                    XRLCreateUpdateSession        updateReq = new XRLCreateUpdateSession();
                    updateReq.CopySGInfoFrom(createReq);
                    Array.Copy(Resp.SessionID,updateReq.baseSession.SessionID,8);
                    // max length in xms is 40
                    byte[] blobValue = new byte[41];
                    new Random().NextBytes(blobValue);
                    WireData [] attribs = new WireData[1]{new XRLBlobAttribute(Constants.SAMPLE_BLOB_ATTRIB2,blobValue)};
                    updateReq.AddAttribs(attribs);
                    if(UpdateTestNegative(updateReq,HResult.XONLINE_E_MATCH_OVERFLOW))
                        ResultCode=TEST_RESULTS.PASSED;
                    //delete the session
                    XRLDeleteSession    delReq = new XRLDeleteSession(Resp.SessionID);
                    delReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                }
                else
                    Global.RO.Warn("CreateSession failed:"+Global.XErrToString(createReq.XErr));
            }
        }
        [TestCase, Description("add non-existent int attribute")]
			class NNonExistentIntAttrib : NegativeUpdateTestBase
        {
            override protected void Execute()
            {
                // create a session with no attributes first
                XRLCreateUpdateSession        createReq = new XRLCreateUpdateSession();
                XRLSessionInfo                Resp;
                if(createReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out Resp))
                {
                    XRLCreateUpdateSession        updateReq = new XRLCreateUpdateSession();
                    updateReq.CopySGInfoFrom(createReq);
                    Array.Copy(Resp.SessionID,updateReq.baseSession.SessionID,8);
                    uint    intAttrib = 0x18a;    // nonexistent
                    WireData [] attribs = new WireData[1]{new XRLIntAttribute(intAttrib,123)};
                    updateReq.AddAttribs(attribs);
                    if(UpdateTestNegative(updateReq,HResult.XONLINE_E_MATCH_INVALID_ATTRIBUTE_ID))
                        ResultCode=TEST_RESULTS.PASSED;
                    //delete the session
                    XRLDeleteSession    delReq = new XRLDeleteSession(Resp.SessionID);
                    delReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                }
                else
                    Global.RO.Warn("CreateSession failed:"+Global.XErrToString(createReq.XErr));
            }
        }
        [TestCase, Description("add non-existent string attribute")]
			class NNonExistentStrAttrib : NegativeUpdateTestBase
        {
            override protected void Execute()
            {
                // create a session with no attributes first
                XRLCreateUpdateSession        createReq = new XRLCreateUpdateSession();
                XRLSessionInfo                Resp;
                if(createReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out Resp))
                {
                    XRLCreateUpdateSession        updateReq = new XRLCreateUpdateSession();
                    updateReq.CopySGInfoFrom(createReq);
                    Array.Copy(Resp.SessionID,updateReq.baseSession.SessionID,8);
                    uint    strAttribID = 0x300|Constants.X_ATTRIBUTE_DATATYPE_STRING;    // nonexistent
                    WireData [] attribs = new WireData[1]{new XRLStringAttribute(strAttribID,"dfd\0")};
                    updateReq.AddAttribs(attribs);
                    if(UpdateTestNegative(updateReq,HResult.XONLINE_E_MATCH_INVALID_ATTRIBUTE_ID))
                        ResultCode=TEST_RESULTS.PASSED;
                    //delete the session
                    XRLDeleteSession    delReq = new XRLDeleteSession(Resp.SessionID);
                    delReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                }
                else
                    Global.RO.Warn("CreateSession failed:"+Global.XErrToString(createReq.XErr));
            }
        }
        [TestCase, Description("add non-existent blob attribute")]
			class NNonExistentBlobAttrib : NegativeUpdateTestBase
        {
            override protected void Execute()
            {
                // create a session with no attributes first
                XRLCreateUpdateSession        createReq = new XRLCreateUpdateSession();
                XRLSessionInfo                Resp;
                if(createReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out Resp))
                {
                    XRLCreateUpdateSession        updateReq = new XRLCreateUpdateSession();
                    updateReq.CopySGInfoFrom(createReq);
                    Array.Copy(Resp.SessionID,updateReq.baseSession.SessionID,8);
                    uint    blobAttribID = 0x300|Constants.X_ATTRIBUTE_DATATYPE_BLOB;    // nonexistent
                    byte [] blobVal = new byte[190];
                    new Random().NextBytes(blobVal);
                    WireData [] attribs = new WireData[1]{new XRLBlobAttribute(blobAttribID,blobVal)};
                    updateReq.AddAttribs(attribs);
                    if(UpdateTestNegative(updateReq,HResult.XONLINE_E_MATCH_INVALID_ATTRIBUTE_ID))
                        ResultCode=TEST_RESULTS.PASSED;
                    //delete the session
                    XRLDeleteSession    delReq = new XRLDeleteSession(Resp.SessionID);
                    delReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                }
                else
                    Global.RO.Warn("CreateSession failed:"+Global.XErrToString(createReq.XErr));
            }
        }
        [TestCase, Description("dwMessageLength is shorter than the actual updateSession Request length")]
			class NOverflowMsg : NegativeUpdateTestBase
        {
            override protected void Execute()
            {
                // create a session with no attributes first
                XRLCreateUpdateSession        createReq = new XRLCreateUpdateSession();
                XRLSessionInfo                Resp;
                if(createReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out Resp))
                {
                    XRLCreateUpdateSession        updateReq = new XRLCreateUpdateSession();
                    updateReq.CopySGInfoFrom(createReq);
                    Array.Copy(Resp.SessionID,updateReq.baseSession.SessionID,8);
                    byte[] blobValue = new byte[100];
                    new Random().NextBytes(blobValue);
                    WireData [] attribs = new WireData[1]{new XRLBlobAttribute(2140842,blobValue)};
                    updateReq.AddAttribs(attribs);
                    updateReq.baseSession.dwMessageLength -= 1;
                    if(UpdateTestNegative(updateReq,HResult.XONLINE_E_MATCH_REQUEST_TOO_SMALL))
                        ResultCode=TEST_RESULTS.PASSED;
                    //delete the session
                    XRLDeleteSession    delReq = new XRLDeleteSession(Resp.SessionID);
                    delReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                }
                else
                    Global.RO.Warn("CreateSession failed:"+Global.XErrToString(createReq.XErr));
            }
        }
        [TestCase, Description("dwMessageLength is larger than the actual updateSession Request length")]
			class NTruncateMsg : NegativeUpdateTestBase
        {
            override protected void Execute()
            {
                // create a session with no attributes first
                XRLCreateUpdateSession        createReq = new XRLCreateUpdateSession();
                XRLSessionInfo                Resp;
                if(createReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out Resp))
                {
                    XRLCreateUpdateSession        updateReq = new XRLCreateUpdateSession();
                    updateReq.CopySGInfoFrom(createReq);
                    Array.Copy(Resp.SessionID,updateReq.baseSession.SessionID,8);
                    byte[] blobValue = new byte[100];
                    new Random().NextBytes(blobValue);
                    WireData [] attribs = new WireData[1]{new XRLBlobAttribute(2140842,blobValue)};
                    updateReq.AddAttribs(attribs);
                    updateReq.baseSession.dwMessageLength += 1;
                    if(UpdateTestNegative(updateReq,HResult.XONLINE_E_MATCH_REQUEST_TRUNCATED))
                        ResultCode=TEST_RESULTS.PASSED;
                    //delete the session
                    XRLDeleteSession    delReq = new XRLDeleteSession(Resp.SessionID);
                    delReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                }
                else
                    Global.RO.Warn("CreateSession failed:"+Global.XErrToString(createReq.XErr));
            }
        }
        [TestCase, Description("31595:dwNumAttributes is smaller than what's actually passed in")]
			class NWrongNumAttribs1 : NegativeUpdateTestBase
        {
            override protected void Execute()
            {
                // create a session with no attributes first
                XRLCreateUpdateSession        createReq = new XRLCreateUpdateSession();
                XRLSessionInfo                Resp;
                if(createReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out Resp))
                {
                    XRLCreateUpdateSession        updateReq = new XRLCreateUpdateSession();
                    updateReq.CopySGInfoFrom(createReq);
                    Array.Copy(Resp.SessionID,updateReq.baseSession.SessionID,8);
                    byte[] blobValue = new byte[100];
                    new Random().NextBytes(blobValue);
                    WireData [] attribs = new WireData[2]{new XRLBlobAttribute(2140842,blobValue),
                                                            new XRLIntAttribute(43690,3434)};
                    updateReq.AddAttribs(attribs);
                    updateReq.ManualArraySize = true;
                    updateReq.AttribOffsetsLen = 1;
                    if(UpdateTestNegative(updateReq,HResult.XONLINE_E_MATCH_INVALID_OFFSET) ||
						UpdateTestNegative(updateReq,HResult.XONLINE_E_MATCH_OVERFLOW))
                        ResultCode=TEST_RESULTS.PASSED;
                    //delete the session
                    XRLDeleteSession    delReq = new XRLDeleteSession(Resp.SessionID);
                    delReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                }
                else
                    Global.RO.Warn("CreateSession failed:"+Global.XErrToString(createReq.XErr));
            }
        }
        [TestCase, Description("dwNumAttributes is larger than what's actually passed in")]
			class NWrongNumAttribs2 : NegativeUpdateTestBase
        {
            override protected void Execute()
            {
                // create a session with no attributes first
                XRLCreateUpdateSession        createReq = new XRLCreateUpdateSession();
                XRLSessionInfo                Resp;
                if(createReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out Resp))
                {
                    XRLCreateUpdateSession        updateReq = new XRLCreateUpdateSession();
                    updateReq.CopySGInfoFrom(createReq);
                    Array.Copy(Resp.SessionID,updateReq.baseSession.SessionID,8);
                    byte[] blobValue = new byte[100];
                    new Random().NextBytes(blobValue);
                    WireData [] attribs = new WireData[1]{new XRLBlobAttribute(2140842,blobValue)};
                    updateReq.AddAttribs(attribs);
                    updateReq.AttribOffsetsLen = 2;
                    updateReq.ManualArraySize = true;
                    if(UpdateTestNegative(updateReq,HResult.XONLINE_E_MATCH_INVALID_ATTRIBUTE_ID))
                        ResultCode=TEST_RESULTS.PASSED;
                    //delete the session
                    XRLDeleteSession    delReq = new XRLDeleteSession(Resp.SessionID);
                    delReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
                }
                else
                    Global.RO.Warn("CreateSession failed:"+Global.XErrToString(createReq.XErr));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XMatchTest\FuncTitleChange.cs ===
using System;
using System.Text;
using System.IO;
using System.Net;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Matchmaking;
using xonline.common.config;

namespace XMatchTest
{
    // These tests are deprecated, as Xbox1 support is removed.  These will be deleted in the next release.
    [TestGroup, Ignore]
	public class FuncTitleChange : TestNode
	{
		// this is for batched titlechange requests
		protected static bool    MyOwnExecute(XRLTitleChange[] batchReq, uint dwTotalMsgLen,uint XErr)
		{
			MemoryStream        reqStream = new MemoryStream();
			BinaryWriter        bw = new BinaryWriter(reqStream);
			// get reqStream from the batchReq;
			for(int i = 0; i < batchReq.Length; i++)
			{
				bw.Write(batchReq[i].wType);
				bw.Write(batchReq[i].cbEnt);
				bw.Write(batchReq[i].sgaddr.inaSg);
				bw.Write(batchReq[i].sgaddr.dwSpiSg);
				bw.Write(batchReq[i].sgaddr.qwXboxID);
				bw.Write(batchReq[i].sgaddr.abReserved);
				bw.Write(batchReq[i].dwOldTitleID);
				bw.Write(batchReq[i].dwNewTitleID);
			}
			if(dwTotalMsgLen > (batchReq.Length*(Constants.SIZETITLECHANGE)))
				bw.Write("a");    // this is a negative case that passed in extra data at the end of titlechange requests
			else if(dwTotalMsgLen < (batchReq.Length*(Constants.SIZETITLECHANGE)))
				reqStream.SetLength(dwTotalMsgLen);

			StringBuilder sbURL = new StringBuilder();
			sbURL.Append("http://");
			sbURL.Append(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd).ToString());
			sbURL.Append("/xmatch/titlechange.ashx");

			HttpWebRequest    httpReq;
			HttpWebResponse    httpResp = null;
			HttpStatusCode    statusCode;
			Stream            httpStream;
			httpReq = (HttpWebRequest)WebRequest.Create(sbURL.ToString());
			httpReq.ProtocolVersion = HttpVersion.Version11;
			httpReq.Method = "POST";
			httpReq.UserAgent = ((int)XOService.Matchmaking).ToString("x") + "/1.0.5849";
			httpReq.ContentType = "xon/" + ((int)XOService.Matchmaking).ToString("x");
			httpReq.ContentLength = reqStream.Length;
			try
			{
				httpStream = httpReq.GetRequestStream();
				reqStream.WriteTo(httpStream);
				httpStream.Close();
				httpResp = (HttpWebResponse)httpReq.GetResponse();
			}
			catch (WebException e)
			{
				if(XErr == 0)    // this request is expected to succeed
				{
					Global.RO.Warn("Positive titlechange requests failed");
					return false;
				}
				// else this is a negative case
				httpResp = (HttpWebResponse)e.Response;
				if(httpResp != null)
				{
					statusCode = httpResp.StatusCode;
					if(statusCode == HttpStatusCode.InternalServerError)
					{    // check XErr
                        string strErr = httpResp.GetResponseHeader("X-Err");
                        if (strErr.StartsWith("0x") || strErr.StartsWith("0X")) strErr = strErr.Substring(2);

                        if (Convert.ToUInt32(strErr, 16) == XErr)
							return true;
						else
						{
							Global.RO.Warn("Wrong error code (" + strErr + " != " + XErr.ToString("X") + ") returned");
							return false;
						}
					}
					else // other error returned instead of 500
						return false;
				}
				// httpResp is null
				return false;
			}
			if(XErr == 0)
				return true;
			else
				return false;
		}
		[TestCase, Description("call titleChange with SgAddr/TitleRegion/aqwUserID set to max value")]
			class PMaxSgAddr : TestBase
		{
			override protected void Execute()
			{
				SGADDR        sg = new SGADDR();
				sg.dwSpiSg = 0xffffffff;
				sg.qwXboxID = 0xffffffffffffffff;
				sg.inaSg = new byte[4]{0xff,0xff,0xff,0xff};
				byte[]        sgbytes = sg.toByteArray();

				// create a session with maximum SGADDR
				XRLCreateUpdateSession        createReq = new XRLCreateUpdateSession();
				XRLSessionInfo                Resp;
				Array.Copy(sgbytes,createReq.baseSession.HostAddress.abOnline,(long)Constants.SIZESGADDR);
				if(createReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out Resp))
				{
					XRLTitleChange        req = new XRLTitleChange();
					req.sgaddr.dwSpiSg = sg.dwSpiSg;
					req.sgaddr.qwXboxID = sg.qwXboxID;
					Array.Copy(sg.inaSg,req.sgaddr.inaSg,4);

					if(req.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd)))
					{
						// the session will be deleted right away
						XRLDeleteSession    delReq = new XRLDeleteSession(Resp.SessionID);
						if(    !delReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd))&&
							(delReq.XErr == HResult.XONLINE_E_MATCH_INVALID_SESSION_ID))
							ResultCode=TEST_RESULTS.PASSED;
					}
				}
			}
		}
		[TestCase, Description("call titleChange with SgAddr/TitleRegion/aqwUserID set to min value")]
			class PMinSgAddr : TestBase
		{
			override protected void Execute()
			{
				SGADDR        sg = new SGADDR();
				sg.dwSpiSg = 0;
				sg.qwXboxID = 0;
				sg.inaSg = new byte[4]{0,0,0,0};
				byte[]        sgbytes = sg.toByteArray();

				// create a session with maximum SGADDR
				XRLCreateUpdateSession        createReq = new XRLCreateUpdateSession();
				XRLSessionInfo                Resp;
				Array.Copy(sgbytes,createReq.baseSession.HostAddress.abOnline,(long)Constants.SIZESGADDR);
				if(createReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out Resp))
				{
					XRLTitleChange        req = new XRLTitleChange();
					req.sgaddr.dwSpiSg = sg.dwSpiSg;
					req.sgaddr.qwXboxID = sg.qwXboxID;
					Array.Copy(sg.inaSg,req.sgaddr.inaSg,4);

					if(req.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd)))
					{
						// the session will be deleted right away
						XRLDeleteSession    delReq = new XRLDeleteSession(Resp.SessionID);
						if(    !delReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd))&&
							(delReq.XErr == HResult.XONLINE_E_MATCH_INVALID_SESSION_ID))
							ResultCode=TEST_RESULTS.PASSED;
					}
				}
			}
		}
            [BVT]
		[TestCase, Description("call titleChange so that more than 1 sessions are deleted")]
			class PMoreSessions : TestBase
		{
			override protected void Execute()
			{
				SGADDR        sg = new SGADDR();
				byte[]        sgbytes = sg.toByteArray();
				// create two sessions with the same SGAddr set
				XRLCreateUpdateSession        createReq1, createReq2;
				createReq1 = new XRLCreateUpdateSession();
				createReq2 = new XRLCreateUpdateSession();
				XRLSessionInfo                Resp1, Resp2;

				Array.Copy(sgbytes,createReq1.baseSession.HostAddress.abOnline,(long)Constants.SIZESGADDR);
				Array.Copy(sgbytes,createReq2.baseSession.HostAddress.abOnline,(long)Constants.SIZESGADDR);
				if(    createReq1.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out Resp1) &&
					createReq2.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out Resp2))
				{
					XRLTitleChange        req = new XRLTitleChange();
					req.sgaddr.dwSpiSg = sg.dwSpiSg;
					req.sgaddr.qwXboxID = sg.qwXboxID;
					Array.Copy(sg.inaSg,req.sgaddr.inaSg,4);

					if(req.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd)))
					{
						// the two sessions will be deleted right away
						XRLDeleteSession    delReq1 = new XRLDeleteSession(Resp1.SessionID);
						XRLDeleteSession    delReq2 = new XRLDeleteSession(Resp2.SessionID);
						if((!delReq1.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd))&&
							(delReq1.XErr == HResult.XONLINE_E_MATCH_INVALID_SESSION_ID)) ||
							(!delReq2.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd)) &&
							(delReq2.XErr == HResult.XONLINE_E_MATCH_INVALID_SESSION_ID)))
							ResultCode=TEST_RESULTS.PASSED;
					}
				}
			}
		}
		[TestCase, Description("send six batched titleChange messages in one request")]
			class PBatchedMsg : TestBase
		{
			override protected void Execute()
			{
				SGADDR        sg = new SGADDR();
				byte[]        sgbytes;
				// create six sessions with different SGAddr
				XRLCreateUpdateSession    []    createReqs = new XRLCreateUpdateSession[6];
				XRLSessionInfo            []    Resp = new XRLSessionInfo[6];
				for(int i = 0; i < 6; i++)
				{
					createReqs[i] = new XRLCreateUpdateSession();

					sg.dwSpiSg = (uint)(0x12345678 + i);
					sgbytes = sg.toByteArray();
					Array.Copy(sgbytes,createReqs[i].baseSession.HostAddress.abOnline,(long)Constants.SIZESGADDR);
					if(!createReqs[i].Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out Resp[i]))
					{
						Global.RO.Warn("create session failed");
						return;
					}
				}
				// create a request that has 6 batched deadxbox message
				XRLTitleChange    []    reqs = new XRLTitleChange[6];
				for(int i = 0; i < 6; i++)
				{
					reqs[i] = new XRLTitleChange();
					reqs[i].sgaddr.dwSpiSg = (uint)(0x12345678+i);
					reqs[i].sgaddr.qwXboxID = sg.qwXboxID;
					Array.Copy(sg.inaSg,reqs[i].sgaddr.inaSg,4);
				}
				if( MyOwnExecute(reqs, Constants.SIZETITLECHANGE*6,0))
				{
					XRLDeleteSession[]    delReqs = new XRLDeleteSession[6];
					for(int i = 0; i < 6; i++)
					{
						delReqs[i] = new XRLDeleteSession(Resp[i].SessionID);
						if((delReqs[i].Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd))) ||
							(delReqs[i].XErr != HResult.XONLINE_E_MATCH_INVALID_SESSION_ID))
							return;
					}
					ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}
		[TestCase, Description("send mixed batched titleChange messages")]
			class PMixedBatchedMsg : TestBase
		{
			override protected void Execute()
			{
				SGADDR        sg = new SGADDR();
				byte[]        sgbytes;
				// create 50 sessions with different SGAddr
				XRLCreateUpdateSession    []    createReqs = new XRLCreateUpdateSession[50];
				XRLSessionInfo            []    Resp = new XRLSessionInfo[50];
				for(int i = 0, j=0; i < 100; i++, j++)
				{
					createReqs[j] = new XRLCreateUpdateSession();

					sg.dwSpiSg = (uint)(0x12345678 + i);
					sgbytes = sg.toByteArray();
					Array.Copy(sgbytes,createReqs[j].baseSession.HostAddress.abOnline,(long)Constants.SIZESGADDR);
					if(!createReqs[j].Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out Resp[j]))
					{
						Global.RO.Warn("create session failed");
						return;
					}
					i++;
				}
				// create a request that has 100 batched titleChange message
				XRLTitleChange    []    reqs = new XRLTitleChange[100];
				for(int i = 0; i < 100; i++)
				{
					reqs[i] = new XRLTitleChange();
					if(i%2 == 0)
						reqs[i].dwOldTitleID = Constants.TITLE_ID;
					else
						reqs[i].dwOldTitleID = 4019;    // nonexistent title ID
					reqs[i].sgaddr.dwSpiSg = (uint)(0x12345678+i);
					reqs[i].sgaddr.qwXboxID = sg.qwXboxID;
					Array.Copy(sg.inaSg,reqs[i].sgaddr.inaSg,4);
				}
				if(    MyOwnExecute(reqs, Constants.SIZETITLECHANGE*100,0))
				{
					XRLDeleteSession[]    delReqs = new XRLDeleteSession[50];
					for(int i = 0; i < 50; i++)
					{
						delReqs[i] = new XRLDeleteSession(Resp[i].SessionID);
						if((delReqs[i].Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd))) ||
							(delReqs[i].XErr != HResult.XONLINE_E_MATCH_INVALID_SESSION_ID))
							return;
					}
					ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}
		/***************************************************************************************
		 * The followings are negative cases
		 ***************************************************************************************/
		[TestCase, Description("malformed titleChange messages")]
			class NMalformedMsg : TestBase
		{
			override protected void Execute()
			{
				XRLTitleChange    []    reqs = new XRLTitleChange[2]{new XRLTitleChange(), new XRLTitleChange()};
				uint    dwTotalMsgLen = 2 * Constants.SIZETITLECHANGE + 1;
				// same DeadXbox message will be sent twice to the matchmaking front door
				if(    MyOwnExecute(reqs, dwTotalMsgLen,HResult.XONLINE_E_MATCH_REQUEST_TRUNCATED))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("truncated titleChange messages")]
			class NTruncateMsg : TestBase
		{
			override protected void Execute()
			{
				XRLTitleChange    []    reqs = new XRLTitleChange[2]{new XRLTitleChange(), new XRLTitleChange()};
				uint    dwTotalMsgLen = 2 * Constants.SIZETITLECHANGE -1;

				if(    MyOwnExecute(reqs, dwTotalMsgLen,HResult.XONLINE_E_MATCH_REQUEST_TRUNCATED))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("call titleChange with nonexistent title ID")]
			class NUnknownTitle : TestBase
		{
			override protected void Execute()
			{
				XRLTitleChange    req = new XRLTitleChange();
				req.dwOldTitleID = 9;
				// although xmatch will throw these requests, but it still returns S_OK
				if(req.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd)))
					ResultCode=TEST_RESULTS.PASSED;
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XMatchTest\MatchStressBase.cs ===
using System;
using System.Collections;
using ServerTestFramework;
using ServerTestFramework.LiveService.Matchmaking;
using ServerTestFramework.Utilities;
using xonline.common.config;

namespace XMatchTest 
{
    public abstract class MatchStressBase : TestNode
    {
        public static void FailTest(String message, UInt32 xErr)
        {
            String msg = String.Format("{0}:{1}:{2}", DateTime.Now, message, Global.XErrToString(xErr));
            StressParams.Safetw.WriteLine(msg);
            throw new UnexpectedTestResultException(msg);
        }

        public static void SkipTest(String message)
        {
            String msg = String.Format("{0}:{1}", DateTime.Now, message);
            StressParams.Safetw.WriteLine(msg);
            throw new DidNotExecuteException(msg);
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XMatchTest\MatchDelayedRequests.cs ===
/* MatchDelayedRequests.cs
 * A class that encapsulates a method of replacing match sprocs with code that delays based on a
 * passed in by the request.  Each request must hide the delay in a parameter that is passed through
 * the FD.
 *
 * To prepare a call, you instantiate a class of that call with a titleid.  The class creates the
 * set of sprocs for that titleid.  It also exposes a setof ExecuteDelayedRequest(RequestTypeEnum type, int
 * msDelay).  The class finally has a cleanup method that undoes the sproc changes and disables the
 * execute calls.
 */
using System;
using System.Collections;
using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Matchmaking;
using ServerTestFramework.LiveService.FakeSG;
using System.Threading;

using xonline.common.config;

namespace XMatchTest {


    //This class represents a particular title, with modified requests.  To use this class,
    //instantiate it and call PrepareServers.  Use ExecuteDelayedRequest or
    //ExecuteDelayedRequestAsync to run a delayed XRL.  Call Cleanup to remove the NPDB entries.
    //it's best to put Cleanup in a finally clause so that we try very hard to clean up the NPDB tables.
    public class MatchDelayedRequests {
        private string [] sprocBases;
        private ArrayList sprocObjects;
        private ArrayList cleanupNpdbCommands;
        private uint titleId;

        public MatchDelayedRequests(uint titleId) {
            this.titleId = titleId;
            sprocObjects = new ArrayList();
            InitializeSprocBases(titleId);
            cleanupNpdbCommands = new ArrayList();
        }

        private void InitializeSprocBases(uint titleId) {
            const string TITLEID_PLACEHOLDER = "***REPLACETITLEID***";
            ArrayList sprocBaseArrayList = new ArrayList();
            sprocBaseArrayList.Add(InsertSproc.Replace(TITLEID_PLACEHOLDER, "0x" + titleId.ToString("X")));
            sprocBaseArrayList.Add(updateSproc.Replace(TITLEID_PLACEHOLDER, "0x" + titleId.ToString("X")));
            sprocBaseArrayList.Add(searchRankedSproc.Replace(TITLEID_PLACEHOLDER, "0x" + titleId.ToString("X")));
            sprocBaseArrayList.Add(searchStandardSproc.Replace(TITLEID_PLACEHOLDER, "0x" + titleId.ToString("X")));
            sprocBaseArrayList.Add(searchAffiliatesSproc.Replace(TITLEID_PLACEHOLDER, "0x" + titleId.ToString("X")));
            sprocBaseArrayList.Add(searchWeightedSproc.Replace(TITLEID_PLACEHOLDER, "0x" + titleId.ToString("X")));
            sprocBaseArrayList.Add(searchFindById.Replace(TITLEID_PLACEHOLDER, "0x" + titleId.ToString("X")));
            sprocBaseArrayList.Add(deleteSproc.Replace(TITLEID_PLACEHOLDER, "0x" + titleId.ToString("X")));
            sprocBaseArrayList.Add(findByIdGetAttributesSproc.Replace(TITLEID_PLACEHOLDER, "0x" + titleId.ToString("X")));
            sprocBaseArrayList.Add(deadxboxSproc.Replace(TITLEID_PLACEHOLDER, "0x" + titleId.ToString("X")));
            sprocBases = (string []) sprocBaseArrayList.ToArray(typeof(string));
            for (int i=0; i< sprocNameArray.Length; i++) {
                sprocNameArray[i] = sprocNameArray[i].Replace(TITLEID_PLACEHOLDER, "0x" + titleId.ToString("X"));
            }
        }

        //an array of the sproc's names per request, initialized on construction.  Split actually uses
        //search_find_byid_get_attributes as well as insert, so there's a dependency there.
        string [] sprocNameArray = {"p_match_session_v2_***REPLACETITLEID***_insert",
                                    "p_match_session_v2_***REPLACETITLEID***_update",
                                    "p_match_session_v2_***REPLACETITLEID***_0x00000001_search_ranked",
                                    "p_match_session_v2_***REPLACETITLEID***_0x00000001_search_standard",
                                    "p_match_session_v2_***REPLACETITLEID***_0x00000001_search_affiliates",
                                    "p_match_session_v2_***REPLACETITLEID***_0x00000001_search_weighted_ranked",
                                    "p_match_session_v2_***REPLACETITLEID***_search_findbyid",
                                    "p_match_session_v2_***REPLACETITLEID***_delete",
                                    "p_match_session_v2_***REPLACETITLEID***_search_findbyid_get_attributes",
                                    "p_match_session_***REPLACETITLEID***_deadxbox"};

        
        //Create data in NPDB's _interface_buckets and t_match_titles so that requests go to the
        //passed in server, without having to prop the title.
        public void PrepareServers(string matchSql, uint titleId) {
            Npdb npdbHandle = new Npdb();
            npdbHandle.ConnectToServer();
            npdbHandle.IssueCommand(ReplayFile.CreateInterfaceBucketInsertString(titleId, matchSql));
            npdbHandle.IssueCommand(ReplayFile.CreateTMatchTitlesInsertString(titleId, matchSql));
            npdbHandle.Close();
            cleanupNpdbCommands.Add(ReplayFile.CreateCleanupBucketString());
            cleanupNpdbCommands.Add(ReplayFile.CreateCleanupTMatchTitlesString());
            Global.XEnv.ExecuteXmgmtCommand(Interface.xmatchfd, "e :xmatchfd reloadtitleinfo");
            
            //make the sproc changes, one per type.
            for(int i=0; i<sprocBases.Length; i++) {
                XmatchSproc modifiedSproc = new XmatchSproc(sprocNameArray[i], matchSql);
                modifiedSproc.SetSprocToCustom(sprocNameArray[i], sprocBases[i]);
                sprocObjects.Add(modifiedSproc);
            }
        }

        public void Cleanup(bool reloadMatchFDs) {
            Npdb npdbHandle = new Npdb();
            npdbHandle.ConnectToServer();
            foreach(string sql in cleanupNpdbCommands) {
                npdbHandle.IssueCommand(sql);
            }
            npdbHandle.Close();
            if (reloadMatchFDs) {
                Global.XEnv.ExecuteXmgmtCommand(Interface.xmatchfd, "e :xmatchfd reloadtitleinfo");
            }
            ResetSprocs();
        }

        private void ResetSprocs() {
            foreach (XmatchSproc sproc in sprocObjects) {
                sproc.ResetSprocToOriginal();
            }
        }

        //creates a request of the appropriate type.  It's expected that multiple threads will
        //use this method at once.
        public uint ExecuteDelayedRequest(ReplayData.RequestTypeEnum type, int msDelay) {
            switch(type) {
                case ReplayData.RequestTypeEnum.INSERT:
                    return ExecuteDelayedInsert(msDelay);
                case ReplayData.RequestTypeEnum.UPDATE:
                    return ExecuteDelayedUpdate(msDelay);
                case ReplayData.RequestTypeEnum.SEARCH_RANKED:
                    return ExecuteDelayedSearchRanked(msDelay);
                case ReplayData.RequestTypeEnum.SEARCH_STANDARD:
                    return ExecuteDelayedSearchStandard(msDelay);
                case ReplayData.RequestTypeEnum.SEARCH_WEIGHTED:
                    return ExecuteDelayedSearchWeighted(msDelay);
                case ReplayData.RequestTypeEnum.SEARCH_BYID:
                    return ExecuteDelayedSearchById(msDelay);
                case ReplayData.RequestTypeEnum.DELETE:
                    return ExecuteDelayedDelete(msDelay);
                case ReplayData.RequestTypeEnum.SPLIT:
                    return ExecuteDelayedSplit(msDelay);
                case ReplayData.RequestTypeEnum.DEADXBOX:
                    return 0;
                    //TODO:
//                    return ExecuteDelayedDeadXbox(msDelay); //This doesn't work yet.  Something to
//                    do with the bits and passing in the arguments.
                default:
                    throw new Exception("Error!  Invalid request type during ExecuteDelayedRequest!");
            }
        }

        //Executes an Async request based on a ReplayData
        public uint ExecuteDelayedRequestAsync(ReplayData data) {
            return ExecuteDelayedRequestAsync(data.requestType, data.elapsedTime);
        }

        //creates a request of the appropriate type.  It's expected that multiple threads will
        //use this method at once.
        public uint ExecuteDelayedRequestAsync(ReplayData.RequestTypeEnum type, int msDelay) {
            switch(type) {
                case ReplayData.RequestTypeEnum.INSERT:
                    ExecuteDelayedInsertAsync(msDelay);
                    return 0;
                case ReplayData.RequestTypeEnum.UPDATE:
                    ExecuteDelayedUpdateAsync(msDelay);
                    return 0;
                case ReplayData.RequestTypeEnum.SEARCH_RANKED:
                    ExecuteDelayedSearchRankedAsync(msDelay);
                    return 0;
                case ReplayData.RequestTypeEnum.SEARCH_STANDARD:
                    ExecuteDelayedSearchStandardAsync(msDelay);
                    return 0;
                case ReplayData.RequestTypeEnum.SEARCH_WEIGHTED:
                    ExecuteDelayedSearchWeightedAsync(msDelay);
                    return 0;
                case ReplayData.RequestTypeEnum.SEARCH_BYID:
                    ExecuteDelayedSearchByIdAsync(msDelay);
                    return 0;
                case ReplayData.RequestTypeEnum.DELETE:
                    ExecuteDelayedDeleteAsync(msDelay);
                    return 0;
                case ReplayData.RequestTypeEnum.SPLIT:
                    ExecuteDelayedSplitAsync(msDelay);
                    return 0;
                case ReplayData.RequestTypeEnum.DEADXBOX:
                    return 0;
                    //TODO:
//                    return ExecuteDelayedDeadXbox(msDelay); //This doesn't work yet.  Something to
//                    do with the bits and passing in the arguments.
                default:
                    throw new Exception("Error!  Invalid request type during ExecuteDelayedRequest!");
            }
        }


        private XRL2CreateUpdateSession CreateDelayedInsertXrl(int msDelay) {
            XRL2CreateUpdateSession xrl = new XRL2CreateUpdateSession();
            xrl.baseCreateUpdate.baseSession.dwTitleID = titleId;
            xrl.baseCreateUpdate.baseSession.HostAddress.inaOnline = ReverseBytes(System.BitConverter.GetBytes(msDelay));
            return xrl;
        }
        //Bytes need to be reversed for the client_ip
        private uint ExecuteDelayedInsert(int msDelay) {
            XRL2CreateUpdateSession xrl = CreateDelayedInsertXrl(msDelay);
            xrl.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
            return xrl.XErr;
        }

        public int currentInserts = 0;
        private void ExecuteDelayedInsertAsync(int msDelay) {
            //Create an XRL2Create for the expected title.
            XRL2CreateUpdateSession xrl = CreateDelayedInsertXrl(msDelay);
            xrl.BeginExecute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), 
                             new AsyncCallback(InsertRequestCallback));
            Interlocked.Increment(ref currentInserts);
        }

        private void InsertRequestCallback(IAsyncResult ar) {
            FDTransaction.RequestState state = (FDTransaction.RequestState) ar.AsyncState;
            XRL2CreateUpdateSession xrl = (XRL2CreateUpdateSession) state.xrl;
            bool success = xrl.EndExecute(ar);
            Interlocked.Decrement(ref currentInserts);
            NotifyIfBad(xrl.XErr, "Create", success);
        }

        private static byte[] ReverseBytes(byte[] source) {
            byte[] target = new byte[source.Length];
            for (int i=0; i< source.Length; i++) {
                target[source.Length - 1 - i]  = source[i];
            }
            return target;
        }
        
        private XRL2CreateUpdateSession CreateDelayedUpdateXrl(int msDelay) {
            const long SESSION_ID = 0x1234000000000000;
            XRL2CreateUpdateSession xrl = new XRL2CreateUpdateSession((byte []) new SessionID(SESSION_ID));
            xrl.baseCreateUpdate.baseSession.dwTitleID = titleId;
            xrl.baseCreateUpdate.baseSession.dwPublicOpen = (uint) msDelay;
            return xrl;
        }

        private uint ExecuteDelayedUpdate(int msDelay) {
            XRL2CreateUpdateSession xrl = CreateDelayedUpdateXrl(msDelay);
            xrl.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
            return xrl.XErr;
        }

        public int currentUpdates = 0;
        private void ExecuteDelayedUpdateAsync(int msDelay) {
            XRL2CreateUpdateSession xrl = CreateDelayedUpdateXrl(msDelay);
            xrl.BeginExecute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), 
                             new AsyncCallback(UpdateRequestCallback));
            Interlocked.Increment(ref currentInserts);
        }

        private void UpdateRequestCallback(IAsyncResult ar) {
            FDTransaction.RequestState state = (FDTransaction.RequestState) ar.AsyncState;
            XRL2CreateUpdateSession xrl = (XRL2CreateUpdateSession) state.xrl;
            bool success = xrl.EndExecute(ar);
            Interlocked.Decrement(ref currentUpdates);
            NotifyIfBad(xrl.XErr, "Update", success);
        }


        //A base for all searches.
        private XRL2SearchSession CreateDelayedSearch(int msDelay, uint spIndex) {
            XRL2SearchSession xrl = new XRL2SearchSession(true, spIndex);            
            xrl.baseSearchSession.dwTitleID = titleId;
            xrl.baseSearchSession.ClientAddress.inaOnline = ReverseBytes(System.BitConverter.GetBytes(msDelay));
            return xrl;
        }

        //All searches have an spIndex of 1.  Here the i_client_ip is used to determine the delay.
        private uint ExecuteDelayedSearchRanked(int msDelay) {
            XRL2SearchSession xrl = CreateDelayedSearch(msDelay, 1);
            xrl.UpdateAttrib(new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_TYPE,new XRLXeIntValue(Constants.X_ATTRIBUTE_GAME_TYPE_RANKED)));
            XRL2SearchResults xrlResponse;
            xrl.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out xrlResponse);
            return xrl.XErr;
        }

        public int currentSearchRanked = 0;
        private void ExecuteDelayedSearchRankedAsync(int msDelay) {
            XRL2SearchSession xrl = CreateDelayedSearch(msDelay, 1);
            xrl.UpdateAttrib(new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_TYPE,new XRLXeIntValue(Constants.X_ATTRIBUTE_GAME_TYPE_RANKED)));
            xrl.BeginExecute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), 
                             new AsyncCallback(SearchRankedRequestCallback));
            Interlocked.Increment(ref currentSearchRanked);
        }

        private void SearchRankedRequestCallback(IAsyncResult ar) {
            FDTransaction.RequestState state = (FDTransaction.RequestState) ar.AsyncState;
            XRL2SearchSession xrl = (XRL2SearchSession) state.xrl;
            XRL2SearchResults xrlResponse;
            bool success = xrl.EndExecute(ar, out xrlResponse);
            Interlocked.Decrement(ref currentSearchRanked);
            NotifyIfBad(xrl.XErr, "SearchRanked", success);
        }
                
        private uint ExecuteDelayedSearchStandard(int msDelay) {
            XRL2SearchSession xrl = CreateDelayedSearch(msDelay, 1);
            xrl.UpdateAttrib(new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_TYPE,new 
                                                  XRLXeIntValue(Constants.X_ATTRIBUTE_GAME_TYPE_STANDARD)));
            XRL2SearchResults xrlResponse;
            xrl.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out xrlResponse);
            return xrl.XErr;
        }

        public int currentSearchStandard = 0;
        private void ExecuteDelayedSearchStandardAsync(int msDelay) {
            XRL2SearchSession xrl = CreateDelayedSearch(msDelay, 1);
            xrl.UpdateAttrib(new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_TYPE,new 
                                                  XRLXeIntValue(Constants.X_ATTRIBUTE_GAME_TYPE_STANDARD)));
            xrl.BeginExecute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), 
                             new AsyncCallback(SearchStandardRequestCallback));
            Interlocked.Increment(ref currentSearchStandard);
        }

        private void SearchStandardRequestCallback(IAsyncResult ar) {
            FDTransaction.RequestState state = (FDTransaction.RequestState) ar.AsyncState;
            XRL2SearchSession xrl = (XRL2SearchSession) state.xrl;
            XRL2SearchResults xrlResponse;
            bool success = xrl.EndExecute(ar, out xrlResponse);
            Interlocked.Decrement(ref currentSearchStandard);
            NotifyIfBad(xrl.XErr, "SearchStandard", success);
        }

        private uint ExecuteDelayedSearchWeighted(int msDelay) {
            XRL2SearchSession xrl = CreateDelayedSearch(msDelay, 1);
            xrl.UpdateAttrib(new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_TYPE,new 
                                                  XRLXeIntValue(Constants.X_ATTRIBUTE_GAME_TYPE_RANKED)));
            xrl.SetWeightedFlag(true);
            XRL2SearchResults xrlResponse;
            xrl.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out xrlResponse);
            return xrl.XErr;
        }

        public int currentSearchWeighted = 0;
        private void ExecuteDelayedSearchWeightedAsync(int msDelay) {
            XRL2SearchSession xrl = CreateDelayedSearch(msDelay, 1);
            xrl.UpdateAttrib(new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_TYPE,new 
                                                  XRLXeIntValue(Constants.X_ATTRIBUTE_GAME_TYPE_RANKED)));
            xrl.SetWeightedFlag(true);
            xrl.BeginExecute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), 
                             new AsyncCallback(SearchWeightedRequestCallback));
            Interlocked.Increment(ref currentSearchWeighted);
        }

        private void SearchWeightedRequestCallback(IAsyncResult ar) {
            FDTransaction.RequestState state = (FDTransaction.RequestState) ar.AsyncState;
            XRL2SearchSession xrl = (XRL2SearchSession) state.xrl;
            XRL2SearchResults xrlResponse;
            bool success = xrl.EndExecute(ar, out xrlResponse);
            Interlocked.Decrement(ref currentSearchWeighted);
            NotifyIfBad(xrl.XErr, "SearchWeighted", success);
        }


        private uint ExecuteDelayedSearchById(int msDelay) {
            XRL2SearchSession xrl = CreateDelayedSearch(msDelay, Constants.X_SSINDEX_GET_SESSION);
            xrl.AddParams(new XRLXeAttribParam[1]{new XRLXeAttribParam(Constants.X_ATTRIBUTE_SESSION_ID,
                                                                       new XRLXeIntValue(0x180))});
            XRL2SearchResults xrlResponse;
            xrl.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out xrlResponse);
            return xrl.XErr;
        }

        public int currentSearchById = 0;
        private void ExecuteDelayedSearchByIdAsync(int msDelay) {
            XRL2SearchSession xrl = CreateDelayedSearch(msDelay, Constants.X_SSINDEX_GET_SESSION);
            xrl.AddParams(new XRLXeAttribParam[1]{new XRLXeAttribParam(Constants.X_ATTRIBUTE_SESSION_ID,
                                                                       new XRLXeIntValue(0x180))});
            xrl.BeginExecute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), 
                             new AsyncCallback(SearchByIdRequestCallback));
            Interlocked.Increment(ref currentSearchById);
        }

        private void SearchByIdRequestCallback(IAsyncResult ar) {
            FDTransaction.RequestState state = (FDTransaction.RequestState) ar.AsyncState;
            XRL2SearchSession xrl = (XRL2SearchSession) state.xrl;
            XRL2SearchResults xrlResponse;
            bool success = xrl.EndExecute(ar, out xrlResponse);
            Interlocked.Decrement(ref currentSearchById);
            NotifyIfBad(xrl.XErr, "SearchByID", success);
        }

        private uint ExecuteDelayedDelete(int msDelay) {
//          Top bits(64-29) of @bi_session_id are the delay.
            ulong delay = ((ulong) msDelay << 29) | (ulong) 0;
            XRL2DeleteSession xrl = new XRL2DeleteSession(ReverseBytes(System.BitConverter.GetBytes(delay)), titleId);
            xrl.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
            return xrl.XErr;
        }

        public int currentDeletes = 0;
        private void ExecuteDelayedDeleteAsync(int msDelay) {
            ulong delay = ((ulong) msDelay << 29) | (ulong) 0;
            XRL2DeleteSession xrl = new XRL2DeleteSession(ReverseBytes(System.BitConverter.GetBytes(delay)), titleId);
            xrl.BeginExecute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), 
                             new AsyncCallback(DeleteRequestCallback));
            Interlocked.Increment(ref currentDeletes);
        }

        private void DeleteRequestCallback(IAsyncResult ar) {
            FDTransaction.RequestState state = (FDTransaction.RequestState) ar.AsyncState;
            XRL2DeleteSession xrl = (XRL2DeleteSession) state.xrl;
            bool success = xrl.EndExecute(ar);
            Interlocked.Decrement(ref currentDeletes);
            NotifyIfBad(xrl.XErr, "Delete", success);
        }

        private XRLSplitSession CreateDelayedSplitSessionRequest(int msDelay) {
            byte [] sessionID = new byte[] { 0x80, 0, 0, 0, 0, 0, 0, 0 };
            //Initialize the HostAddress fields.  inaOnline is where we'll store the delay.  The
            //rest is just to make sure it passes.
            XRLxnaddr hostAddress = new XRLxnaddr();
            hostAddress.ina = new byte[4]{0,0,0,0};
            hostAddress.inaOnline = ReverseBytes(System.BitConverter.GetBytes(msDelay)); 
            hostAddress.wPortOnline = 0x0506;
            hostAddress.abEnet = new byte[6]{0x01,0x02,0x03,0x04,0x05,0x06};
            hostAddress.abOnline = new SGADDR(CSGInfo.ClientType.Xenon).toByteArray();

            WireData[] attribs = new WireData[0];

            return new XRLSplitSession(sessionID, titleId, hostAddress, attribs);            

        }

        //delay via the HostAddress
        private uint ExecuteDelayedSplit(int msDelay) {
            XRLSplitSession xrl = CreateDelayedSplitSessionRequest(msDelay);
            XRL2SingleSearchResult response;
            xrl.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out response);
            return xrl.XErr;
            
        }

        public int currentSplits = 0;
        private void ExecuteDelayedSplitAsync(int msDelay) {
            XRLSplitSession xrl = CreateDelayedSplitSessionRequest(msDelay);
            xrl.BeginExecute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), 
                             new AsyncCallback(SplitRequestCallback));
            Interlocked.Increment(ref currentSplits);
        }

        private void SplitRequestCallback(IAsyncResult ar) {
            FDTransaction.RequestState state = (FDTransaction.RequestState) ar.AsyncState;
            XRLSplitSession xrl = (XRLSplitSession) state.xrl;
            XRL2SingleSearchResult response;
            bool success = xrl.EndExecute(ar, out response);
            Interlocked.Decrement(ref currentSplits);
            NotifyIfBad(xrl.XErr, "Split", success);
        }

/*        
          private uint ExecuteDelayedDeadXbox(int msDelay) {
          XRLDeadXBox xrl = new XRLDeadXBox(titleId);
          //we have to flip the bytes on the msDelay, as it flips when it goes on the wire.
//            byte [] msDelayInReversedBytes = new byte[4];
//            msDelayInReversedBytes = ReverseBytes(System.BitConverter.GetBytes(msDelay));
//            xrl.sgaddr.qwXboxID = (ulong) System.BitConverter.ToInt32(msDelayInReversedBytes, 0);
xrl.sgaddr.qwXboxID = (ulong) msDelay;
xrl.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd));
return xrl.XErr;
}
*/

        private void NotifyIfBad(uint xErr, string prefix, bool success) {
            //figure out some more info about the state here, like delay, xrl call, exception.
            if(!success) {
                Global.RO.Info(prefix + "--Request returns false.");
            }
            if(xErr != 0) {
                Global.RO.Info(prefix + "--Error received:" + xErr.ToString("X"));
            }
        }


        //In this sproc, i_ip_addr is the int which stands for millsecond delay.  All sprocs need to
        //have their titleId replaced.
        const string InsertSproc = 
            "ALTER PROCEDURE [dbo].[p_match_session_v2_***REPLACETITLEID***_insert]\n" +
            "@bi_session_id                 bigint\n" +
            ",@i_ip_addr                     int\n" +
            ",@i_sg_ip                       int\n" +
            ",@b_box_id                      binary(16)\n" +
            ",@b_host_address                binary(36)\n" +
            ",@b_key_exchange_key            binary(16)\n" +
            ",@i_public_available            int\n" +
            ",@i_private_available           int\n" +
            ",@i_public_current              int\n" +
            ",@i_private_current             int\n" +
            ",@dt_session_expire             datetime\n" +
            ",@ti_nat_type                   tinyint\n" +
            ",@i_sw_bucket             int\n" +
            ",@ti_breadcrumb_state           tinyint = 1 -- default to breadcrumb\n" +
            ",@dt_lock_expire             datetime = NULL -- occasionally a caller will want to insert a row in locked state.\n" +
            ",@att_0x0000800A                bigint\n" +
            ",@att_0x0000800B                bigint\n" +
            ",@att_0x10008101                int = 1\n" +
            ",@att_0x10008102                int = 103\n" +
            ",@att_0x10008103                int = 1\n" +
            ",@att_0x50008104                real = 58.72\n" +
            ",@att_0x30008105                float = 3\n" +
            ",@att_0x30008106                float = 1\n" +
            ",@att_0x20008107                bigint = 0\n" +
            ",@att_0x40008109                nvarchar(400) = ''\n" +
            ",@att_0x10008201                int = 0\n" +
            ",@att_0x10008202                int = 0\n" +
            "AS\n" +
            "-- Match Fastfail testing delay sproc, created by Match STF tests.\n" +
            "BEGIN\n" +
            "declare @mydelay varchar(15)\n" +
            "set @mydelay = (SELECT CONVERT(VARCHAR,DATEADD(ms, @i_ip_addr ,0),114))\n" +
            "WAITFOR DELAY @mydelay\n" +
            "RETURN 0\n" +
            "END\n";

        //@i_public_available is the spot to hide the delay here.
        const string updateSproc = 
            "ALTER PROCEDURE [dbo].[p_match_session_v2_***REPLACETITLEID***_update]\n" +
            "@bi_session_id                 bigint\n" +
            ",@i_public_available            int\n" +
            ",@i_private_available           int\n" +
            ",@i_public_current              int\n" +
            ",@i_private_current             int\n" +
            ",@dt_session_expire             datetime\n" +
            ",@ti_target_rowtype             tinyint\n" +
            ",@att_0x0000800A                bigint = NULL\n" +
            ",@att_0x0000800B                bigint = NULL\n" +
            ",@att_0x10008101                int = NULL\n" +
            ",@att_0x10008102                int = NULL\n" +
            ",@att_0x10008103                int = NULL\n" +
            ",@att_0x50008104                real = NULL\n" +
            ",@att_0x30008105                float = NULL\n" +
            ",@att_0x30008106                float = NULL\n" +
            ",@att_0x20008107                bigint = NULL\n" +
            ",@att_0x40008109                nvarchar(400) = NULL\n" +
            ",@att_0x10008201                int = NULL\n" +
            ",@att_0x10008202                int = NULL\n" +
            "AS\n" +
            "-- Match Fastfail testing delay sproc, created by Match STF tests.\n\n" +
            "\n" +
            "BEGIN\n" +
            "declare @mydelay varchar(15)\n" +
            "set @mydelay = (SELECT CONVERT(VARCHAR,DATEADD(ms, @i_public_available,0),114))\n" +
            "WAITFOR DELAY @mydelay\n" +
            "SELECT 0 as i_return_code\n" +
            ",cast(1 as tinyint) as ti_breadcrumb_state\n" +
            "END\n";

        //@i_client_ip is the spot to hide the delay here.
        const string searchRankedSproc =
            "ALTER PROCEDURE [dbo].[p_match_session_v2_***REPLACETITLEID***_0x00000001_search_ranked]\n" +
            "@i_max_results                  BIGINT OUTPUT\n" +
            ",@si_required_slots              smallint\n" +
            ",@i_client_ip                    int\n" +
            ",@ti_nat_type                    tinyint\n" +
            ",@ti_server_count                tinyint\n" +
            ",@param_0x0000800A               bigint\n" +
            ",@param_0x0000800B               bigint\n" +
            ",@param_0x10008101               int = 1\n" +
            ",@param_0x10008102               int = 103\n" +
            ",@param_0x10008103               int = 1\n" +
            ",@param_0x50008104               real = 58.72\n" +
            ",@param_0x30008105               float = 3\n" +
            ",@param_0x30008106               float = 1\n" +
            ",@param_0x20008107               bigint = 0\n" +
            ",@param_0x40008109               nvarchar(400) = ''\n" +
            ",@param_0x10008201               int = 0\n" +
            ",@param_0x10008202               int = 0\n" +
            ",@param_0x50000007               real = NULL\n" +
            ",@param_0x20000003               bigint = NULL\n" +
            "\n" +
            "AS\n" +
            "-- Match Fastfail testing delay sproc, created by Match STF tests.\n\n" +
            "BEGIN\n" +
            "SET @i_max_results = 50\n" +
            "declare @mydelay varchar(15)\n" +
            "set @mydelay = (SELECT CONVERT(VARCHAR,DATEADD(ms, @i_client_ip, 0),114))\n" +
            "WAITFOR DELAY @mydelay\n" +
            "select\n" +
            "-1207118 as i_title_id,\n" +
            "0 as i_query_id,\n" +
            "cast(0 as bigint) as i_game_type,\n" +
            "cast(0 as bigint) as i_game_mode,\n" +
            "cast(0 as float)as f_gamer_mu,\n" +
            "0 as i_iterations,\n" +
            "0 as i_rowcount,\n" +
            "cast(0 as float) as f_mu_range,\n" +
            "cast(0 as float) as f_mu_upper_bound,\n" +
            "cast(0 as float) as f_mu_lower_bound,\n" +
            "0 as i_lower_hash_bound1,\n" +
            "0 as i_upper_hash_bound1,\n" +
            "0 as i_lower_hash_bound2,\n" +
            "0 as i_upper_hash_bound2\n" +
            "select \n" +
            "cast (0 as bigint) as bi_session_id\n" +
            ",cast (0 as binary(36)) as b_host_address\n" +
            ",cast (0 as binary(16)) as b_key_exchange_key\n" +
            ",0 as i_public_available\n" +
            ",0 as private_available\n" +
            ",0 as public_current\n" +
            ",0 as private_current\n" +
            "RETURN 0\n" +
            "END\n";

        //In standard, both this and the affilate sproc are called--therefore the delay is only
        //placed in one of these two to prevent duplication.  The delay is only in the affilate
        //portion of the sproc.
        const string searchStandardSproc =
            "ALTER PROCEDURE [dbo].[p_match_session_v2_***REPLACETITLEID***_0x00000001_search_standard]\n" +
            "@i_max_results                  int OUTPUT\n" +
            ",@i_negative_sessions            int\n" +
            ",@si_required_slots              smallint\n" +
            ",@i_client_ip                    int\n" +
            ",@ti_nat_type                    tinyint\n" +
            ",@ti_server_count                tinyint\n" +
            ",@param_0x0000800A               bigint\n" +
            ",@param_0x0000800B               bigint\n" +
            ",@param_0x10008101               int = 1\n" +
            ",@param_0x10008102               int = 103\n" +
            ",@param_0x10008103               int = 1\n" +
            ",@param_0x50008104               real = 58.72\n" +
            ",@param_0x30008105               float = 3\n" +
            ",@param_0x30008106               float = 1\n" +
            ",@param_0x20008107               bigint = 0\n" +
            ",@param_0x40008109               nvarchar(400) = ''\n" +
            ",@param_0x10008201               int = 0\n" +
            ",@param_0x10008202               int = 0\n" +
            ",@param_0x50000007               real = NULL\n" +
            ",@param_0x20000003               bigint = NULL\n" +
            "\n" +
            "AS\n" +
            "-- Match Fastfail testing delay sproc, created by Match STF tests.\n\n" +
            "BEGIN\n" +
            "SET @i_max_results = 50\n" +
            "select\n" +
            "10 as i_title_id,\n" +
            "0 as i_query_id,\n" +
            "@param_0x0000800A as i_game_type,\n" +
            "@param_0x0000800B as i_game_mode,\n" +
            "@param_0x50008104 as f_gamer_rating,\n" +
            "@param_0x10008101 as f_gamer_zone,\n" +
            "0 as i_iterations,\n" +
            "0 as i_rowcount,\n" +
            "cast(0.0 as float) as f_rating_range,\n" +
            "cast(0.0 as float) as f_rating_upper_bound,\n" +
            "cast(0.0 as float) as f_rating_lower_bound,\n" +
            "0 as i_lower_hash_bound1,\n" +
            "0 as i_upper_hash_bound1,\n" +
            "0 as i_lower_hash_bound2,\n" +
            "0 as i_upper_hash_bound2\n" +
            "\n" +
            "RETURN 0\n" +
            "END\n";

        //@i_client_ip is the spot to hide the delay here.
        const string searchAffiliatesSproc =
            "ALTER PROCEDURE [dbo].[p_match_session_v2_***REPLACETITLEID***_0x00000001_search_affiliates]\n" +
            "@i_max_results                  int OUTPUT\n" +
            ",@si_required_slots              smallint\n" +
            ",@i_client_ip                    int\n" +
            ",@ti_nat_type                    tinyint\n" +
            ",@ti_server_count                tinyint\n" +
            ",@i_session_id_count             int\n" +
            ",@vb_session_ids                 varbinary(8000)\n" +
            ",@param_0x0000800A               bigint\n" +
            ",@param_0x0000800B               bigint\n" +
            ",@param_0x10008101               int = 1\n" +
            ",@param_0x10008102               int = 103\n" +
            ",@param_0x10008103               int = 1\n" +
            ",@param_0x50008104               real = 58.72\n" +
            ",@param_0x30008105               float = 3\n" +
            ",@param_0x30008106               float = 1\n" +
            ",@param_0x20008107               bigint = 0\n" +
            ",@param_0x40008109               nvarchar(400) = ''\n" +
            ",@param_0x10008201               int = 0\n" +
            ",@param_0x10008202               int = 0\n" +
            ",@param_0x50000007               real = NULL\n" +
            ",@param_0x20000003               bigint = NULL\n" +
            "\n" +
            "AS\n" +
            "-- Match Fastfail testing delay sproc, created by Match STF tests.\n\n" +
            "BEGIN\n" +
            "SET @i_max_results = 50\n" +
            "declare @mydelay varchar(15)\n" +
            "set @mydelay = (SELECT CONVERT(VARCHAR,DATEADD(ms, @i_client_ip, 0),114))\n" +
            "WAITFOR DELAY @mydelay\n" +
            "\n" +
            "RETURN 0\n" +
            "END\n";

        //@i_client_ip is the spot to hide the delay here.
        const string searchWeightedSproc = 
            "ALTER PROCEDURE [dbo].[p_match_session_v2_***REPLACETITLEID***_0x00000001_search_weighted_ranked]\n" +
            "-- declared as a BIGINT to prevent SQL from doing a cast when selecting top(max_results)\n" +
            "@i_max_results                  BIGINT OUTPUT\n" +
            ",@si_required_slots              smallint\n" +
            ",@i_client_ip                    int\n" +
            ",@ti_nat_type                    tinyint\n" +
            ",@ti_server_count                tinyint\n" +
            ",@param_0x0000800A               bigint\n" +
            ",@param_0x0000800B               bigint\n" +
            ",@param_0x10008101               int = 1\n" +
            ",@param_0x10008102               int = 103\n" +
            ",@param_0x10008103               int = 1\n" +
            ",@param_0x50008104               real = 58.72\n" +
            ",@param_0x30008105               float = 3\n" +
            ",@param_0x30008106               float = 1\n" +
            ",@param_0x20008107               bigint = 0\n" +
            ",@param_0x40008109               nvarchar(400) = ''\n" +
            ",@param_0x10008201               int = 0\n" +
            ",@param_0x10008202               int = 0\n" +
            "\n" +
            "AS\n" +
            "-- Match Fastfail testing delay sproc, created by Match STF tests.\n\n" +
            "BEGIN\n" +
            "SET @i_max_results = 25\n" +
            "declare @mydelay varchar(15)\n" +
            "set @mydelay = (SELECT CONVERT(VARCHAR,DATEADD(ms, @i_client_ip, 0),114))\n" +
            "WAITFOR DELAY @mydelay\n" +
            "select\n" +
            "-1215745 as i_title_id,\n" +
            "0 as i_query_id,\n" +
            "@param_0x0000800A as i_game_type,\n" +
            "@param_0x0000800B as i_game_mode,\n" +
            "@param_0x30008105 as f_gamer_mu,\n" +
            "0 as i_iterations,\n" +
            "0 as i_rowcount,\n" +
            "cast(0 as float) as f_range_base,\n" +
            "0 as i_lower_hash_bound1,\n" +
            "0 as i_upper_hash_bound1,\n" +
            "0 as i_lower_hash_bound2,\n" +
            "0 as i_upper_hash_bound2\n" +
            "END\n";

        //@i_client_ip is the delay variable
        const string searchFindById =
            "ALTER PROCEDURE [dbo].[p_match_session_v2_***REPLACETITLEID***_search_findbyid]\n" +
            "@si_required_slots              smallint,\n" +
            "@i_client_ip                    int,\n" +
            "@ti_nat_type                    tinyint,\n" +
            "@ti_server_count                tinyint,\n" +
            "@param_0x20008003               bigint\n" +
            ",@param_0x10008201               int = 0\n" +
            ",@param_0x10008202               int = 0\n" +
            "\n" +
            "AS\n" +
            "-- Match Fastfail testing delay sproc, created by Match STF tests.\n\n" +
            "BEGIN\n" +
            "declare @mydelay varchar(15)\n" +
            "set @mydelay = (SELECT CONVERT(VARCHAR,DATEADD(ms, @i_client_ip, 0),114))\n" +
            "WAITFOR DELAY @mydelay\n" +
            "END";

        //Top bits(64-29) of @bi_session_id are the delay.
        const string deleteSproc =
            "ALTER PROCEDURE [dbo].[p_match_session_v2_***REPLACETITLEID***_delete]\n" +
            "@i_sw_bucket                    int OUTPUT,\n" +
            "@bi_session_id                  bigint,\n" +
            "@i_delete_delay_seconds         int = 0,\n" +
            "@ti_target_rowtype             tinyint\n" +
            "AS\n" +
            "-- Match Fastfail testing delay sproc, created by Match STF tests.\n\n" +
            "BEGIN\n" +
            "\n" +
            "declare @mydelay varchar(15)\n" +
            "set @bi_session_id = @bi_session_id / POWER(2,28) --right shift 28\n" +
            "set @mydelay = (SELECT CONVERT(VARCHAR,DATEADD(ms, @bi_session_id, 0),114))\n" +
            "WAITFOR DELAY @mydelay\n" +
            "RETURN 0\n" +
            "END\n";

        //Split calls two spra, the findbyid-get attributes, and the create.  We'll make the
        //findbyid-get attributes sproc do nothing.  Split will be delayed by calling the insert.
        const string findByIdGetAttributesSproc =
            "ALTER PROCEDURE [dbo].[p_match_session_v2_***REPLACETITLEID***_search_findbyid_get_attributes]\n" +
            "@si_required_slots              smallint,\n" +
            "@i_client_ip                    int,\n" +
            "@ti_nat_type                    tinyint,\n" +
            "@ti_server_count                tinyint,\n" +
            "@param_0x20008003               bigint\n" +
            ",@param_0x10008201               int = 0\n" +
            ",@param_0x10008202               int = 0\n" +
            "\n" +
            "AS\n" +
            "-- Match Fastfail testing delay sproc, created by Match STF tests.\n\n" +
            "BEGIN\n" +
            "\n" +
            "if ((@param_0x20008003 & 0x0000000000000300) = 0)\n" +
            "begin\n" +
            "SELECT\n" +
            "cast(0 as bigint) as bi_session_id,\n" +
            "cast(0 as binary(36)) as b_host_address,\n" +
            "cast(0 as binary(16)) as b_key_exchange_key,\n" +
            "0 as i_public_available,\n" +
            "0 as i_private_available,\n" +
            "0 as i_public_current,\n" +
            "0 as i_private_current,\n" +
            "cast(0 as bigint) as att_0x0000800A,\n" +
            "cast(0 as bigint) as att_0x0000800B,\n" +
            "0 as att_0x10008101,\n" +
            "0 as att_0x10008102,\n" +
            "0 as att_0x10008103,\n" +
            "cast(0 as real) as att_0x50008104,\n" +
            "cast(0 as float) as att_0x30008105,\n" +
            "cast(0 as float) as att_0x30008106,\n" +
            "cast(0 as bigint) as att_0x20008107,\n" +
            "cast('hi' as nvarchar(10)) as att_0x40008109,\n" +
            "0 as att_0x10008201,\n" +
            "0 as att_0x10008202\n" +
            "RETURN 0\n" +
            "\n" +
            "END\n" +
            "END\n";

        //the variable here is @b_box_id
        const string deadxboxSproc =
            "ALTER PROCEDURE [dbo].[p_match_session_***REPLACETITLEID***_deadxbox]\n" +
            "@b_box_id                 binary(16),\n" +
            "@i_delete_delay_seconds          int = 0\n" +
            "AS\n" +
            "-- Match Fastfail testing delay sproc, created by Match STF tests.\n\n" +
            "BEGIN\n" +
            "declare @temp int\n" +
            "declare @mydelay varchar(15)\n" +
            "set @temp = cast(@b_box_id as bigint) / power(2, 24) --right shift 4\n" + 
            "set @temp = @temp & (power(2, 5) - 1)\n" +
            "set @mydelay = (SELECT CONVERT(VARCHAR,DATEADD(ms, cast(@b_box_id as int), 0),114))\n" +
            "WAITFOR DELAY @mydelay\n" +

            "END\n";
    }

    //NOT FULLY IMPLEMENTED YET.  TODO.
    //
    //Scheduler spins up threads to handle work via a ThreadPool.  The expected use is that a large
    //amount of work will be queued onto this thread, followed by a "finish" proc.  The threadpool
    //will execute all the work.  The caller will poll the finished flag occasionally to know if
    //it's complete.
    //
    //We need a way to kill off all the threads in the threadpool too, if the test is aborted.  One
    //option might be to pull the queue out into something this object controls.  When a kill signal
    //occurs, we can at least empty the queue, but there's still no control over the threads.
    public class DelayedRequestScheduler {
        public class RequestInfo {
            public MatchDelayedRequests delayHandle;
            public ReplayData.RequestTypeEnum requestType;
            public int msDelay;

            public RequestInfo(MatchDelayedRequests delayHandle, ReplayData.RequestTypeEnum requestType, int msDelay) {
                this.delayHandle = delayHandle; this.requestType = requestType; this.msDelay = msDelay;
            }
        }
        public bool finished;

        public DelayedRequestScheduler() {
            finished = false;
        }

        public void QueueWork(MatchDelayedRequests delayHandle, ReplayData.RequestTypeEnum requestType, int msDelay) {
            
        }

        //Call this to queue a "finish" proc onto the worker queue.  This will set the finished
        //flag, allowing others to know that all work is complete.
        public void QueueFinish() {
        }

        public bool NotFinished() { return !finished; }

        //The method that all workers execute.
        static void DelayedRequestProc(Object state) {
            Thread.Sleep(0);  //give other threads a chance to start
            RequestInfo reqState = (RequestInfo) state;
            try {
                uint hr = reqState.delayHandle.ExecuteDelayedRequest(reqState.requestType, reqState.msDelay);
                if (hr != 0) {
                    Global.RO.Error("Request " + reqState.requestType + " of delay " + reqState.msDelay + " returned error HR:" + hr + "!");
                }
            } catch (Exception e) {
                Global.RO.Error("Request " + reqState.requestType + " of delay " + reqState.msDelay + " threw exception!");
                Global.RO.Error(e.ToString());
            }
        }

        //This proc sets the finished flag.
        static void SetFinishedProc(Object stateInfo) {
            ( (DelayedRequestScheduler) stateInfo).finished = true;
        }

    }


    //This tests the functionality of the delayed requests.
    [TestGroup]
    public class MatchDelayedRequestsTest : TestNode
    {

        [TestCase, Description("Try a delayed insert"), Ignore]
        class DelayedInsert : TestBase
        {
            MatchDelayedRequests delayHandle;
            override protected void Execute()
            {
                string [] servers = Global.XEnv.GetServerListByInterface(Interface.xmatch);
                const uint testTitle = 0xDEADBEEF;
                delayHandle = new MatchDelayedRequests(testTitle);
                delayHandle.PrepareServers(servers[0], testTitle);
                delayHandle.ExecuteDelayedRequest(ReplayData.RequestTypeEnum.INSERT, 15000);
                delayHandle.ExecuteDelayedRequest(ReplayData.RequestTypeEnum.UPDATE, 15000);
                delayHandle.ExecuteDelayedRequest(ReplayData.RequestTypeEnum.SEARCH_RANKED, 15000);
                delayHandle.ExecuteDelayedRequest(ReplayData.RequestTypeEnum.SEARCH_STANDARD, 1000);
                delayHandle.ExecuteDelayedRequest(ReplayData.RequestTypeEnum.SEARCH_WEIGHTED, 5000);
                delayHandle.ExecuteDelayedRequest(ReplayData.RequestTypeEnum.SEARCH_BYID, 5000);
                delayHandle.ExecuteDelayedRequest(ReplayData.RequestTypeEnum.SPLIT, 5000);
                delayHandle.ExecuteDelayedRequest(ReplayData.RequestTypeEnum.DEADXBOX, 4095);
                delayHandle.Cleanup(true);
            }
        }
    }

    //These requests attempt to test fastfail code, but require a scheduler to function.
    [TestGroup, Ignore]
    public class MatchFastFailTest : TestNode
    {

        [TestCase, Description("Increasingly slow inserts")]
        class SlowRampUpOnInserts : TestBase
        {
            MatchDelayedRequests delayHandle;
            override protected void Execute()
            {
                string [] servers = Global.XEnv.GetServerListByInterface(Interface.xmatch);
                const uint testTitle = 0xDEADBEEF;
                delayHandle = new MatchDelayedRequests(testTitle);
                delayHandle.PrepareServers(servers[0], testTitle);
                
                DelayedRequestScheduler scheduler = new DelayedRequestScheduler();
                for (int i=0; i< 20000; i++) {
                    scheduler.QueueWork(delayHandle, ReplayData.RequestTypeEnum.INSERT, 1);
                }
                scheduler.QueueFinish();
                while (scheduler.NotFinished()) {
                    Thread.Sleep(1000);
                }
                delayHandle.Cleanup(true);
            }
        }
        [TestCase, Description("Increasingly slow inserts")]
        class SlowRampUpOnInsertsUsingAsync : TestBase
        {
            MatchDelayedRequests delayHandle;
            override protected void Execute()
            {
                string [] servers = Global.XEnv.GetServerListByInterface(Interface.xmatch);
                const uint testTitle = 0xDEADBEEF;
                delayHandle = new MatchDelayedRequests(testTitle);
                delayHandle.PrepareServers(servers[0], testTitle);
                
                DelayedRequestScheduler scheduler = new DelayedRequestScheduler();
                for (int i=0; i< 200000; i++) {
                    delayHandle.ExecuteDelayedRequestAsync(ReplayData.RequestTypeEnum.INSERT, i);
                    Thread.Sleep(0);
                }
                for (int i=0; i< 1000; i++) {
                    Thread.Sleep(5000);//no join capability right now--just wait it out.
                    Global.RO.Info("Currently " + delayHandle.currentInserts + " requests in progress");
                }

                delayHandle.Cleanup(true);
            }
        }

        [TestCase, Description("Increasingly slow inserts")]
        class SlowInsertsAndFastInsertsUsingAsync : TestBase
        {
            MatchDelayedRequests delayHandle1;
            MatchDelayedRequests delayHandle2;
            override protected void Execute()
            {
                string [] servers = Global.XEnv.GetServerListByInterface(Interface.xmatch);
                try {
                    //prepare two test titles
                    const uint testTitle1 = 0xDEADBEEF;
                    delayHandle1 = new MatchDelayedRequests(testTitle1);
                    delayHandle1.PrepareServers(servers[0], testTitle1);

                    const uint testTitle2 = 0xBEEFDEAD;
                    delayHandle2 = new MatchDelayedRequests(testTitle2);
                    delayHandle2.PrepareServers(servers[1], testTitle2);
                
                    for (int i=0; i< 20000; i++) {
                        delayHandle2.ExecuteDelayedRequestAsync(ReplayData.RequestTypeEnum.INSERT, 5000);
                        delayHandle1.ExecuteDelayedRequestAsync(ReplayData.RequestTypeEnum.INSERT, 100);
                        Thread.Sleep(0);
                    }
                    for (int i=0; i< 50000; i++) {
                        delayHandle1.ExecuteDelayedRequestAsync(ReplayData.RequestTypeEnum.INSERT, 100);
                    }

                    for (int i=0; i< 1000; i++) {
                        Thread.Sleep(5000);//no join capability right now--just wait it out.
                        Global.RO.Info("Currently " + delayHandle1.currentInserts + " requests in progress on title 1");
                        Global.RO.Info("Currently " + delayHandle2.currentInserts + " requests in progress on title 2");
                    }
                } finally {
                    delayHandle1.Cleanup(true);
                    delayHandle2.Cleanup(true);
                }
            }
        }

        [TestCase, Description("Increasingly slow everything")]
        class SlowRampUpOnAllTestsUsincAsync : TestBase
        {
            MatchDelayedRequests delayHandle;
            override protected void Execute()
            {
                string [] servers = Global.XEnv.GetServerListByInterface(Interface.xmatch);
                const uint testTitle = 0xDEADBEEF;
                delayHandle = new MatchDelayedRequests(testTitle);
                try {
                    delayHandle.PrepareServers(servers[0], testTitle);
                
                    DelayedRequestScheduler scheduler = new DelayedRequestScheduler();
                    for (int i=0; i< 200000; i++) {
                        delayHandle.ExecuteDelayedRequestAsync(ReplayData.RequestTypeEnum.INSERT, i);
                        delayHandle.ExecuteDelayedRequestAsync(ReplayData.RequestTypeEnum.UPDATE, i);
                        delayHandle.ExecuteDelayedRequestAsync(ReplayData.RequestTypeEnum.SEARCH_RANKED, i);
                        delayHandle.ExecuteDelayedRequestAsync(ReplayData.RequestTypeEnum.SEARCH_STANDARD, i);
                        delayHandle.ExecuteDelayedRequestAsync(ReplayData.RequestTypeEnum.SEARCH_WEIGHTED, i);
                        delayHandle.ExecuteDelayedRequestAsync(ReplayData.RequestTypeEnum.SEARCH_BYID, i);
                        delayHandle.ExecuteDelayedRequestAsync(ReplayData.RequestTypeEnum.DELETE, i);
                        delayHandle.ExecuteDelayedRequestAsync(ReplayData.RequestTypeEnum.SPLIT, i);
                        Thread.Sleep(0);
                    }
                    for (int i=0; i< 1000; i++) {
                        Thread.Sleep(5000);//no join capability right now--just wait it out.
                        Global.RO.Info("Currently " + delayHandle.currentInserts + " requests in progress");
                    }
                } finally {
                    delayHandle.Cleanup(true);
                }
            }
        }

        [TestCase, Description("Increasingly slow everything")]
        class Match_Replay_4D5307E6 : TestBase
        {
            override protected void Execute()
            {
                ReplayFile log = new ReplayFile("4d5307e6.txt");
                ReplayFileExecutor logExecutor = new ReplayFileExecutor(log);
                logExecutor.Initialize();
                logExecutor.Execute();
            }
        }
    }

    public enum TitleType {
        HANDLE1 = 0,
        HANDLE2
    }

    //This class defines stress cases that use delayed requests.
    public abstract class DelayedInsertsTestBase : MatchStressBase {
        static MatchDelayedRequests delayHandle1;
        static MatchDelayedRequests delayHandle2;
        static bool initialized = false;

        public void Run(int msDelay, TitleType type, bool async) 
        {
            //not synchronized, but this is throwaway stuff.
            if (!initialized) 
            {
                initialized = true;
                const uint testTitle1 = 0xDEADBEEF;
                const uint testTitle2 = 0xBEEFDEAD;
                string [] servers = Global.XEnv.GetServerListByInterface(Interface.xmatch);

                delayHandle1 = new MatchDelayedRequests(testTitle1);
                delayHandle1.PrepareServers(servers[0], testTitle1);
                delayHandle2 = new MatchDelayedRequests(testTitle2);
                delayHandle2.PrepareServers(servers[1], testTitle2);
            }

            switch (type) 
            {
                case TitleType.HANDLE1:
                    if (async) {
                        delayHandle1.ExecuteDelayedRequestAsync(ReplayData.RequestTypeEnum.INSERT, msDelay);
                    } else {
                        delayHandle1.ExecuteDelayedRequest(ReplayData.RequestTypeEnum.INSERT, msDelay);
                    }
                    break;
                case TitleType.HANDLE2:
                    if (async) {
                        delayHandle2.ExecuteDelayedRequestAsync(ReplayData.RequestTypeEnum.INSERT, msDelay);
                    } else {
                        delayHandle2.ExecuteDelayedRequest(ReplayData.RequestTypeEnum.INSERT, msDelay);
                    }
                    break;
            }
        }
    }

    [TestCase]
    [CompoundCase("1_1ms_async", 1, TitleType.HANDLE1, true)]
    [CompoundCase("1_10ms_async", 10, TitleType.HANDLE1, true)]
    [CompoundCase("1_100ms_async", 100, TitleType.HANDLE1, true)]
    [CompoundCase("1_1000ms_async", 1000, TitleType.HANDLE1, true)]
    [CompoundCase("1_10000ms_async", 10000, TitleType.HANDLE1, true)]
    [CompoundCase("2_1ms_async", 1, TitleType.HANDLE2, true)]
    [CompoundCase("2_10ms_async", 10, TitleType.HANDLE2, true)]
    [CompoundCase("2_100ms_async", 100, TitleType.HANDLE2, true)]
    [CompoundCase("2_1000ms_async", 1000, TitleType.HANDLE2, true)]
    [CompoundCase("2_10000ms_async", 10000, TitleType.HANDLE2, true)]
    [CompoundCase("1_1ms_sync", 1, TitleType.HANDLE1, false)]
    [CompoundCase("1_10ms_sync", 10, TitleType.HANDLE1, false)]
    [CompoundCase("1_100ms_sync", 100, TitleType.HANDLE1, false)]
    [CompoundCase("1_1000ms_sync", 1000, TitleType.HANDLE1, false)]
    [CompoundCase("1_10000ms_sync", 10000, TitleType.HANDLE1, false)]
    [CompoundCase("2_1ms_sync", 1, TitleType.HANDLE2, false)]
    [CompoundCase("2_10ms_sync", 10, TitleType.HANDLE2, false)]
    [CompoundCase("2_100ms_sync", 100, TitleType.HANDLE2, false)]
    [CompoundCase("2_1000ms_sync", 1000, TitleType.HANDLE2, false)]
    [CompoundCase("2_10000ms_sync", 10000, TitleType.HANDLE2, false)]
    public class InsertTest : DelayedInsertsTestBase
    {
        public override void Run()
        {
            Int32 msDelay = (Int32)MyValues[0];
            TitleType titleType = (TitleType)MyValues[1];
            Boolean async = (Boolean)MyValues[2];

            Run(msDelay, titleType, async);
        }
    }

    public class Insert1_1_ms_async : DelayedInsertsTestBase
    {
        public override void Run()
        {
            Run(1, TitleType.HANDLE1, true);
        }
    }

    public class Insert1_10_ms_async : DelayedInsertsTestBase
    {
        public override void Run()
        {
            Run(10, TitleType.HANDLE1, true);
        }
    }

    public class Insert1_100_ms_async : DelayedInsertsTestBase
    {
        public override void Run()
        {
            Run(100, TitleType.HANDLE1, true);
        }
    }

    public class Insert1_1000_ms_async : DelayedInsertsTestBase
    {
        public override void Run()
        {
            Run(1000, TitleType.HANDLE1, true);
        }
    }

    public class Insert1_10000_ms_async : DelayedInsertsTestBase
    {
        public override void Run()
        {
            Run(10000, TitleType.HANDLE1, true);
        }
    }
    public class Insert2_1_ms_async : DelayedInsertsTestBase
    {
        public override void Run()
        {
            Run(1, TitleType.HANDLE2, true);
        }
    }

    public class Insert2_10_ms_async : DelayedInsertsTestBase
    {
        public override void Run()
        {
            Run(10, TitleType.HANDLE2, true);
        }
    }

    public class Insert2_100_ms_async : DelayedInsertsTestBase
    {
        public override void Run()
        {
            Run(100, TitleType.HANDLE2, true);
        }
    }

    public class Insert2_1000_ms_async : DelayedInsertsTestBase
    {
        public override void Run()
        {
            Run(1000, TitleType.HANDLE2, true);
        }
    }

    public class Insert2_10000_ms_async : DelayedInsertsTestBase
    {
        public override void Run()
        {
            Run(10000, TitleType.HANDLE2, true);
        }
    }


    public class Insert1_1_ms_sync : DelayedInsertsTestBase
    {
        public override void Run()
        {
            Run(1, TitleType.HANDLE1, false);
        }
    }

    public class Insert1_10_ms_sync : DelayedInsertsTestBase
    {
        public override void Run()
        {
            Run(10, TitleType.HANDLE1, false);
        }
    }

    public class Insert1_100_ms_sync : DelayedInsertsTestBase
    {
        public override void Run()
        {
            Run(100, TitleType.HANDLE1, false);
        }
    }

    public class Insert1_1000_ms_sync : DelayedInsertsTestBase
    {
        public override void Run()
        {
            Run(1000, TitleType.HANDLE1, false);
        }
    }

    public class Insert1_10000_ms_sync : DelayedInsertsTestBase
    {
        public override void Run()
        {
            Run(10000, TitleType.HANDLE1, false);
        }
    }
    public class Insert2_1_ms_sync : DelayedInsertsTestBase
    {
        public override void Run()
        {
            Run(1, TitleType.HANDLE2, false);
        }
    }

    public class Insert2_10_ms_sync : DelayedInsertsTestBase
    {
        public override void Run()
        {
            Run(10, TitleType.HANDLE2, false);
        }
    }

    public class Insert2_100_ms_sync : DelayedInsertsTestBase
    {
        public override void Run()
        {
            Run(100, TitleType.HANDLE2, false);
        }
    }

    public class Insert2_1000_ms_sync : DelayedInsertsTestBase
    {
        public override void Run()
        {
            Run(1000, TitleType.HANDLE2, false);
        }
    }

    public class Insert2_10000_ms_sync : DelayedInsertsTestBase
    {
        public override void Run()
        {
            Run(10000, TitleType.HANDLE2, false);
        }
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XMatchTest\Proximity.cs ===
using System;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Matchmaking;
using xonline.common.config;

namespace XMatchTest
{
	internal abstract class DistanceTestBase : TestBase
	{
		protected bool Verify(XRLCreateUpdateSession Req)
		{
			XRLSessionInfo        resp;
			bool                ret = true;
			if (!Req.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out resp))
			{
				Global.RO.Warn("CreateSession request failed:" + Global.XErrToString(Req.XErr));
				return false;
			}
			// search for session based on sessionID
			// spindex=5 returns no additional attributes
			XRLSearchResults    searchResults;
			XRLSearchSession    searchReq = new XRLSearchSession(Constants.X_SSINDEX_GET_SESSION);
			// convert byte[8] to long; integer is little endian on the wire:
			// 01020304 on the wire is actually interpreted as int=0x04030201 internally
			// little endian locally
			long    lSessID = Constants.sessionIDConvert(resp.SessionID);
			XRLAttribParam[]            Params = new XRLAttribParam[1]{new XRLAttribParam(Constants.X_ATTRIBUTE_DATATYPE_INTEGER,new XRLIntParam(lSessID))};
			searchReq.AddParams(Params);

			if(!searchReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out searchResults))
			{
				Global.RO.Warn("search for the newly created session failed:"+Global.XErrToString(searchReq.XErr));
				ret = false;
				goto Exit;
			}
			if(searchResults == null)
			{
				Global.RO.Warn("The newly created session couldn't be found");
				ret = false;
				goto Exit;
			}
			// check if session created correctly in the t_match_sessions_<title>
			if(!Req.Verify(searchResults))
			{
				Global.RO.Warn("The session is not setup correctly in the db");
				ret = false;
				goto Exit;
			}
			// delete the session
			Exit:
				XRLDeleteSession    delReq = new XRLDeleteSession(resp.SessionID);
			if(!delReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd)))
			{
				Global.RO.Warn("Session deletion failed");
				ret = false;
			}
			return ret;
		}
	}
	[TestGroup]
	public class FuncProximity : TestNode
	{
		/***********************************************************************
		 * These tests are for i_distance testing;
		 * Environment setup before running these test:
		 * 1. TitleID: 6666, whose probability weight set to zero
		 * 2. i_max_results for the title should be set to MAX_SEARCHRESULT
		 ***********************************************************************/

		// ------------------------------------------
		// Test Data set 1: (populateTable.sql)
		// IP range is a single IP address and the IP value will be positive number in SQL;
		// highest byte is 127 (turning point of positive number) 
		// For example, start_ip = end_ip = 127.1.244.255 (0x7F01F4FF) mapped to zone ID 11
		// 1)       IP is 127.1.244.255 that should be mapped to zone 11
		// 2)       IP is 127.1.244.254 and 127.1.245.0 should NOT be mapped to zone 11
		// ------------------------------------------
		[TestCase, Description("Create a session with no attributes")]
		class PDistanceTest1 : DistanceTestBase
		{
			override protected void Execute()
			{
				// create MAX_SEARCHRESULT=20 sessions with HostAddress maps to zone ID 11
				uint	MAX_SEARCHRESULT = 20;
				XRLCreateUpdateSession[]    createReq = new XRLCreateUpdateSession[MAX_SEARCHRESULT];
				XRLSessionInfo[]			createResp = new XRLSessionInfo[MAX_SEARCHRESULT];
				for(uint i = 0; i < MAX_SEARCHRESULT; i++)
				{
					createReq[i] = new XRLCreateUpdateSession();
				//	createReq[i].baseSession.HostAddress = hostAddr;
				}
				ResultCode=TEST_RESULTS.PASSED;
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XMatchTest\MatchTitleSchema.cs ===
using System.Collections;
using System.Collections.Generic;
using ServerTestFramework.LiveService.Matchmaking;
using ServerTestFramework.Utilities;
using ServerTestFramework;


namespace XMatchTest
{
    public abstract class MatchTitleSchema {
        public abstract XRL2CreateUpdateSession GetCreate(bool ranked, uint titleID, 
                                                          Queue sessQ, out SGADDR sgAddr);

        //Think about this.  There are lots of kinds of searches per title.
        public abstract XRL2SearchSession GetSearchBase(bool ranked);

        //Use this if you have specific tests that are related to this schema.
        public abstract void AddTests(System.Collections.Generic.List<System.Type> testList);

        public class AttribStatistics {
            public class Stat {
                public double min;
                public double max;
                public double avg;
                public Stat(double min, double max, double avg) {
                    this.min = min; this.max = max; this.avg = avg;
                }
            }
            private Hashtable attribHash;
            public AttribStatistics() {
                attribHash = new Hashtable();
            }
            //store the statistic for this attribute in the hash
            public void AddStat(uint attrib, double min, double max, double avg) {
                attribHash[attrib] = new Stat(min, max, avg);
            }
            //Ask to see if we have statistics on an attribute.
            public bool isValuePresent(uint attrib) {
                return attribHash.Contains(attrib);
            }
            //use the statistic for this attribute to generate a value.
            public double GetValue(uint attrib) {
                Stat stat = (Stat) (attribHash[attrib]);
                return GenerateValue(stat.min, stat.max, stat.avg);
            }
            
            //for now, we ignore average and just create a uniform distribution over the range.
            //Later we can try to spike the average a bit(if roll 50/50, do something centered on
            //the average.
            private double GenerateValue(double min, double max, double avg) {
                return RandomEx.GlobalRandGen.Next((float) (max - min)) + min;
            }


        }

    }


    public class ReachTitleSchema : MatchTitleSchema {
        const uint REACH_MATCH_QUERY = 0;
        const int NUM_SYSTEM_ATTRIBS = 9;

    //watch out for joinable party size--we need each one to be a value that is party size div session size.
    //Create has two modes--let's say target and non-target.  Target is searchable.  Non-target doesn't
    //even matter, really.
        AttribStatistics attribDistribution;
        public ReachTitleSchema() {
            //Only floats get the statistics treatment here.
            attribDistribution = new AttribStatistics();
            attribDistribution.AddStat(0x50000059, 0.2244336, 0.3316284, 0.29873264);
            attribDistribution.AddStat(0x5000005A, 0, 0.06122449, 0.00255102);
            attribDistribution.AddStat(0x5000005B, 0, 0.4081632, 0.069515301);
            attribDistribution.AddStat(0x5000005C, 0, 0.2857143, 0.016262755);
            attribDistribution.AddStat(0x5000007A, 0.2509882, 1, 0.476485311);
            attribDistribution.AddStat(0x5000007B, 0, 0.6660079, 0.480376119);
            attribDistribution.AddStat(0x5000007C, 0, 0.6660079, 0.505573739);
            attribDistribution.AddStat(0x5000007D, 0.3339921, 0.6660079, 0.521553848);
            attribDistribution.AddStat(0x5000007E, 0.4019436, 0.5506091, 0.46128997);
            attribDistribution.AddStat(0x5000007F, 0.2868363, 0.5, 0.373076343);
            attribDistribution.AddStat(0x50000080, 0.5, 0.6742331, 0.629793098);
            attribDistribution.AddStat(0x50000081, 0, 0, 0);
            attribDistribution.AddStat(0x50000082, 0.05263158, 0.1578947, 0.091282917);
            attribDistribution.AddStat(0x50000083, 0, 0, 0);
            attribDistribution.AddStat(0x50000084, 0, 0, 0);
            attribDistribution.AddStat(0x50000085, 0, 0, 0);
            attribDistribution.AddStat(0x50000071, -1568.902, 809.7449, -619.3605023);
            attribDistribution.AddStat(0x50000072, -3410.619, 0, -2030.778398);
            attribDistribution.AddStat(0x50000073, 0, 2787.731, 2076.689648);
        }

        public override XRL2CreateUpdateSession GetCreate(bool ranked, uint titleID, 
                                                 Queue sessQ, out SGADDR sgAddr) {
            XRLXeAttribParam [] randomAtts = new XRLXeAttribParam[template.Length + NUM_SYSTEM_ATTRIBS];

            //initialize the randomAtts array to look like the template.
            Stress2Helpers.FillSystemAttributes(ranked, randomAtts, 0);

            for (int i=0; i<template.Length; i++) {
                randomAtts[i + NUM_SYSTEM_ATTRIBS] = (XRLXeAttribParam) template[i].DeepClone();
            }

            for (int j=0; j<template.Length; j++) {
                SetRandomizedValueForAttribute(randomAtts[j+ NUM_SYSTEM_ATTRIBS], template[j]);
            }
            //We want to override the mode to follow our custom title.  For now this is in code.

            sgAddr = new SGADDR();
            XRL2CreateUpdateSession createReq = new XRL2CreateUpdateSession(randomAtts);
            createReq.baseCreateUpdate.baseSession.dwTitleID = titleID;
            sgAddr.CopyTo(createReq.baseCreateUpdate.baseSession.HostAddress.abOnline);

            return createReq;        
        }

        //Still ugly.  Refactor later, but maybe we can pipe the two into a single function, as the
        //XeAttribParamValues are the same.
        public void SetRandomizedValueForAttribute(XRLXeAttribParamWeighted attribute, XRLXeAttribParamWeighted attribTemplate) {
            if (attribute.aValue is XRLXeDateTimeValue) {
                int randomIndex = RandomEx.GlobalRandGen.Next(0, 4);
                long dateTimeValue = Stress2Params.dateTimeValueArray[randomIndex];
                attribute.aValue = new XRLXeDateTimeValue(dateTimeValue);
            } else {
                //use a value out of the distribution if there is one.
                if (attribDistribution.isValuePresent(attribute.attribParamID)) {
                    attribute.aValue.SetNumericValue(
                        attribDistribution.GetValue(attribute.attribParamID));
                } else {
                    attribute.aValue.SetNumericValue(RandomEx.GlobalRandGen.NextDouble() * 
                                                     attribTemplate.aValue.GetNumericValue());
                }
            }
        }

        public void SetRandomizedValueForAttribute(XRLXeAttribParam attribute, XRLXeAttribParam attribTemplate) {
            if (attribute.aValue is XRLXeDateTimeValue) {
                int randomIndex = RandomEx.GlobalRandGen.Next(0, 4);
                long dateTimeValue = Stress2Params.dateTimeValueArray[randomIndex];
                attribute.aValue = new XRLXeDateTimeValue(dateTimeValue);
            } else {
                //use a value out of the distribution if there is one.
                if (attribDistribution.isValuePresent(attribute.attribParamID)) {
                    attribute.aValue.SetNumericValue(
                        attribDistribution.GetValue(attribute.attribParamID));
                } else {
                    attribute.aValue.SetNumericValue(RandomEx.GlobalRandGen.NextDouble() * 
                                                     attribTemplate.aValue.GetNumericValue());
                }
            }
        }
        //should this be static?
        public override void AddTests(System.Collections.Generic.List<System.Type> testList) {
            testList.Add(typeof(ReachRankedSearch));
            testList.Add(typeof(ReachStandardSearch));
        }

        //27 attrib search.  We'll just guess which attribs are in.  For now we'll use all the same
        //kind.  Later we can get a base search and add some attribs.

        //We know customTitleSchema exists, because this class must have been used to add the tests
        //in this file.
        public abstract class ReachSearch : Stress2SearchBase 
        {
            public void Run(bool rankedSearch)
            {
                Run(Stress2Params.customTitleSchema.GetSearchBase(rankedSearch));
            }
        }

        public class ReachRankedSearch : ReachSearch 
        {
            public override void Run()
            {
                Run(Stress2Params.customTitleSchema.GetSearchBase(true));
            }
        }
        public class ReachStandardSearch : ReachSearch 
        {
            public override void Run()
            {
                Run(Stress2Params.customTitleSchema.GetSearchBase(false));
            }
        }

        //Create a search based on the schema.
        public override XRL2SearchSession GetSearchBase(bool ranked) { 
            uint titleID; Queue sessQ;
            Stress2Helpers.GetRandomTitleAndQ(out titleID, out sessQ);

            //Begin with the system params
            XRLXeAttribParam [] searchParams = Stress2SearchBase.CreateSystemSearchParams(ranked);
            XRL2SearchSession	searchReq = GetXRL2SearchSessionCloneWeighted(searchParams, REACH_MATCH_QUERY);

            //all searches are weighted.  Fill in some other basic info.
            searchReq.SetWeightedFlag(true);
            XMatchTest.ApplySessionModeOverride(searchReq, XMatchTest.RequestType.SEARCH2);
            searchReq.baseSearchSession.dwTitleID = titleID;
                
            //Add other nonweighted params
            searchParams = new XRLXeAttribParam[nonweightedSearchTemplate.Length];
            //fill in the remaining query data, using some custom choices of which attribs to add.
            for (int i=0; i< nonweightedSearchTemplate.Length; i++) {
                searchParams[i] = CreateClonedParam(nonweightedSearchTemplate[i]);
            }
            searchReq.AddParams(searchParams);

            //weighted params get their own array--fill that in and add as well.
            XRLXeAttribParamWeighted [] weightedSearchParams = new XRLXeAttribParamWeighted[weightedSearchTemplate.Length];
            for (int i=0; i< weightedSearchTemplate.Length; i++) {
                weightedSearchParams[i] = CreateClonedParamWeighted(weightedSearchTemplate[i]);
            }
            searchReq.AddWeightedParams(weightedSearchParams);

            return searchReq;
        }


        //use a clone for client-side efficiency
        private static XRL2SearchSession SrcXRL2SearchSession = new XRL2SearchSession(null, 0);
        private static XRL2SearchSession GetXRL2SearchSessionCloneWeighted(XRLXeAttribParam[] searchParams, uint spIndex)
        {
            XRL2SearchSession clone = (XRL2SearchSession)SrcXRL2SearchSession.DeepClone();
            clone.SetWeightedFlag(true);
            clone.SetSchemaVersion(5,3); //must do this before adding weighted params, or
                                         //RecalcOffsets will give wrong info
            clone.baseSearchSession.dwProcedureIndex = spIndex;
            clone.AddParams(searchParams);
            return(clone);
        }

        //create a clone of the parameter, with its value filled in randomly from 0 to the current
        //value of the parameter.  Throws exception on non-numeric attribs.
        private XRLXeAttribParam CreateClonedParam(XRLXeAttribParam param) {
            XRLXeAttribParam newParamClone = (XRLXeAttribParam) param.DeepClone();
            SetRandomizedValueForAttribute(newParamClone, param);
            return newParamClone;
        }

        //Ugly, because the param and paramWeighted don't inherit or relate in any way.
        //Refactor some day.
        private XRLXeAttribParamWeighted CreateClonedParamWeighted(XRLXeAttribParamWeighted param) {
            XRLXeAttribParamWeighted newParamClone = (XRLXeAttribParamWeighted) param.DeepClone();
            SetRandomizedValueForAttribute(newParamClone, param);
            return newParamClone;
        }

        //these filters are passed to mostly let all sessions through.  Worse-caseish, but allows us
        //to focus on just the weights.
        public static XRLXeAttribParam [] nonweightedSearchTemplate = new XRLXeAttribParam [9] {
            new XRLXeAttribParam(hopper_identifier, new XRLXeIntValue(1)),       //searched
            new XRLXeAttribParam(mixed_skill_restricted, new XRLXeIntValue(1)),  //searched
            new XRLXeAttribParam(min_skill_level, new XRLXeIntValue(1)),
            new XRLXeAttribParam(max_skill_level, new XRLXeIntValue(30)),
            new XRLXeAttribParam(min_average_skill_level, new XRLXeIntValue(1)),
            new XRLXeAttribParam(max_average_skill_level, new XRLXeIntValue(30)),
            new XRLXeAttribParam(nat_type, new XRLXeIntValue(1)),
            new XRLXeAttribParam(min_average_mu, new XRLXeFloatValue(1)),
            new XRLXeAttribParam(max_average_mu, new XRLXeFloatValue(30)),
        };
/*
new XRLXeAttribParam(min_locality_x, new XRLXeFloatValue(1)),
new XRLXeAttribParam(min_locality_y, new XRLXeFloatValue(1)),
new XRLXeAttribParam(min_locality_z, new XRLXeFloatValue(1)),
new XRLXeAttribParam(max_locality_x, new XRLXeFloatValue(1)),
new XRLXeAttribParam(max_locality_y, new XRLXeFloatValue(1)),
new XRLXeAttribParam(max_locality_z, new XRLXeFloatValue(1)),
*/
        public const float ATTRIBUTE_WEIGHT = (float) (1/16.0);
        public static XRLXeAttribParamWeighted[] weightedSearchTemplate = new XRLXeAttribParamWeighted [16] {
            new XRLXeAttribParamWeighted(weight_average_party_mu, ATTRIBUTE_WEIGHT, new XRLXeFloatValue(1)),   //searched
            new XRLXeAttribParamWeighted(weight_min_party_skill, ATTRIBUTE_WEIGHT, new XRLXeFloatValue(1)),    //searched
            new XRLXeAttribParamWeighted(weight_max_party_skill, ATTRIBUTE_WEIGHT, new XRLXeFloatValue(1)),    //searched
            new XRLXeAttribParamWeighted(weight_average_party_skill, ATTRIBUTE_WEIGHT, new XRLXeFloatValue(1)),//searched
            new XRLXeAttribParamWeighted(weight_social_1, ATTRIBUTE_WEIGHT, new XRLXeFloatValue(1)),           //searched
            new XRLXeAttribParamWeighted(weight_social_2, ATTRIBUTE_WEIGHT, new XRLXeFloatValue(1)),           //searched
            new XRLXeAttribParamWeighted(weight_social_3, ATTRIBUTE_WEIGHT, new XRLXeFloatValue(1)),           //searched
            new XRLXeAttribParamWeighted(weight_social_4, ATTRIBUTE_WEIGHT, new XRLXeFloatValue(1)),           //searched
            new XRLXeAttribParamWeighted(weight_locality_x, ATTRIBUTE_WEIGHT, new XRLXeFloatValue(1)),         //searched
            new XRLXeAttribParamWeighted(weight_locality_y, ATTRIBUTE_WEIGHT, new XRLXeFloatValue(1)),         //searched
            new XRLXeAttribParamWeighted(weight_locality_z, ATTRIBUTE_WEIGHT, new XRLXeFloatValue(1)),         //searched
            new XRLXeAttribParamWeighted(weight_language, ATTRIBUTE_WEIGHT, new XRLXeFloatValue(1)),           //searched
            new XRLXeAttribParamWeighted(weight_average_experience, ATTRIBUTE_WEIGHT, new XRLXeFloatValue(1)), //searched
            new XRLXeAttribParamWeighted(weight_dlc_1, ATTRIBUTE_WEIGHT, new XRLXeFloatValue(1)),              //searched
            new XRLXeAttribParamWeighted(weight_dlc_2, ATTRIBUTE_WEIGHT, new XRLXeFloatValue(1)),              //searched
            new XRLXeAttribParamWeighted(weight_dlc_3, ATTRIBUTE_WEIGHT, new XRLXeFloatValue(1))               //searched [16 weighted]
        };

        //This is the schema--or how to create sessions.
        public static XRLXeAttribParam[] template = new XRLXeAttribParam [47]{    
            //These nine are filled in by FillSystemAttributes
/*
  new XRLXeAttribParam(GAMETYPE, new XRLXeValue(1)),
  new XRLXeAttribParam(GAMEMODE, new XRLXeValue(1)),
  new XRLXeAttribParam(GAMERZONE, new XRLXeIntValue(1)),
  new XRLXeAttribParam(GAMERCOUNTRY, new XRLXeIntValue(1)),
  new XRLXeAttribParam(LANGUAGE, new XRLXeIntValue(1)),
  new XRLXeAttribParam(GAMERRATING, new XRLXeFloatValue(1)),
  new XRLXeAttribParam(GAMERMU, new XRLXeDoubleValue(1)),
  new XRLXeAttribParam(GAMERSIGMA, new XRLXeDoubleValue(1)),
//  new XRLXeAttribParam(GAMERNAME, new XRLXeValue(1)),
*/
//These we won't bother passing up.
//        new XRLXeAttribParam(AFFILIATEVALUE, new XRLXeValue(1)),
//        new XRLXeAttribParam(GAMERPUID, new XRLXeValue(1)),
//        new XRLXeAttribParam(PLATFORMTYPE, new XRLXeIntValue(1)),
//        new XRLXeAttribParam(PLATFORMLOCK, new XRLXeIntValue(1)),
            new XRLXeAttribParam(mixed_skill_restricted, new XRLXeIntValue(1)),  //searched
            new XRLXeAttribParam(joinable_party_size_1, new XRLXeIntValue(16)),
            new XRLXeAttribParam(joinable_party_size_2, new XRLXeIntValue(8)),
            new XRLXeAttribParam(joinable_party_size_3, new XRLXeIntValue(6)),
            new XRLXeAttribParam(joinable_party_size_4, new XRLXeIntValue(5)),
            new XRLXeAttribParam(joinable_party_size_5, new XRLXeIntValue(4)),
            new XRLXeAttribParam(joinable_party_size_6, new XRLXeIntValue(4)),
            new XRLXeAttribParam(joinable_party_size_7, new XRLXeIntValue(3)),
            new XRLXeAttribParam(joinable_party_size_8, new XRLXeIntValue(2)),
            new XRLXeAttribParam(joinable_party_size_9, new XRLXeIntValue(2)),
            new XRLXeAttribParam(language_override, new XRLXeIntValue(1)),       //searched
            new XRLXeAttribParam(average_skill_level, new XRLXeIntValue(1)),     //searched
            new XRLXeAttribParam(hopper_identifier, new XRLXeIntValue(1)),       //searched
            new XRLXeAttribParam(average_mu, new XRLXeFloatValue(1)),            //searched
            new XRLXeAttribParam(lowest_skill_level, new XRLXeIntValue(1)),      //searched
            new XRLXeAttribParam(highest_skill_level, new XRLXeIntValue(1)),     //searched
            new XRLXeAttribParam(nat_type, new XRLXeIntValue(1)),                //searched
            new XRLXeAttribParam(joinable_party_size_10, new XRLXeIntValue(2)),
            new XRLXeAttribParam(team_matching, new XRLXeIntValue(1)),           //searched [9 non-weighted]
            new XRLXeAttribParam(joinable_party_size_11, new XRLXeIntValue(2)),
            new XRLXeAttribParam(joinable_party_size_12, new XRLXeIntValue(2)),
            new XRLXeAttribParam(joinable_party_size_13, new XRLXeIntValue(2)),
            new XRLXeAttribParam(joinable_party_size_14, new XRLXeIntValue(2)),
            new XRLXeAttribParam(joinable_party_size_15, new XRLXeIntValue(2)),
            new XRLXeAttribParam(weight_average_party_mu, new XRLXeFloatValue(1)),   //searched
            new XRLXeAttribParam(weight_min_party_skill, new XRLXeFloatValue(1)),    //searched
            new XRLXeAttribParam(weight_max_party_skill, new XRLXeFloatValue(1)),    //searched
            new XRLXeAttribParam(weight_average_party_skill, new XRLXeFloatValue(1)),//searched
            new XRLXeAttribParam(weight_social_1, new XRLXeFloatValue(1)),           //searched
            new XRLXeAttribParam(weight_social_2, new XRLXeFloatValue(1)),           //searched
            new XRLXeAttribParam(weight_social_3, new XRLXeFloatValue(1)),           //searched
            new XRLXeAttribParam(weight_social_4, new XRLXeFloatValue(1)),           //searched
            new XRLXeAttribParam(weight_locality_x, new XRLXeFloatValue(1)),         //searched
            new XRLXeAttribParam(weight_locality_y, new XRLXeFloatValue(1)),         //searched
            new XRLXeAttribParam(weight_locality_z, new XRLXeFloatValue(1)),         //searched
            new XRLXeAttribParam(weight_language, new XRLXeFloatValue(1)),           //searched
            new XRLXeAttribParam(weight_average_experience, new XRLXeFloatValue(1)), //searched
            new XRLXeAttribParam(weight_dlc_1, new XRLXeFloatValue(1)),              //searched
            new XRLXeAttribParam(weight_dlc_2, new XRLXeFloatValue(1)),              //searched
            new XRLXeAttribParam(weight_dlc_3, new XRLXeFloatValue(1)),              //searched [16 weighted]
            new XRLXeAttribParam(locality_x, new XRLXeFloatValue(1)),
            new XRLXeAttribParam(locality_y, new XRLXeFloatValue(1)),
            new XRLXeAttribParam(locality_z, new XRLXeFloatValue(1)),
            new XRLXeAttribParam(weight_xbl_party_chat, new XRLXeFloatValue(1)),
            new XRLXeAttribParam(preference_good_connection, new XRLXeIntValue(1)),
            new XRLXeAttribParam(preference_skill, new XRLXeIntValue(1)),
            new XRLXeAttribParam(preference_language, new XRLXeIntValue(1))
        };
//These are the items in the schema--this translates a friendly-name into a attribute id.
        public const uint GAMETYPE=0x0000800A;
        public const uint GAMEMODE=0x0000800B;
        public const uint GAMERZONE=0x10008101;
        public const uint GAMERCOUNTRY=0x10008102;
        public const uint LANGUAGE=0x10008103;
        public const uint GAMERRATING=0x50008104;
        public const uint GAMERMU=0x30008105;
        public const uint GAMERSIGMA=0x30008106;
        public const uint GAMERPUID=0x20008107;
        public const uint AFFILIATEVALUE=0x20008108;
        public const uint HOSTNAME=0x40008109;
        public const uint PLATFORMTYPE=0x10008201;
        public const uint PLATFORMLOCK=0x10008202;
        public const uint mixed_skill_restricted=0x1000003A;
        public const uint joinable_party_size_1=0x1000003B;
        public const uint joinable_party_size_2=0x1000003C;
        public const uint joinable_party_size_3=0x1000003D;
        public const uint joinable_party_size_4=0x1000003E;
        public const uint joinable_party_size_5=0x1000003F;
        public const uint joinable_party_size_6=0x10000040;
        public const uint joinable_party_size_7=0x10000041;
        public const uint joinable_party_size_8=0x10000042;
        public const uint joinable_party_size_9=0x10000043;
        public const uint min_skill_level=0x10000047;  //these added.
        public const uint max_skill_level=0x10000048;
        public const uint min_average_skill_level=0x10000049;
        public const uint max_average_skill_level=0x1000004A;
        public const uint min_average_mu=0x5000004E;
        public const uint max_average_mu=0x5000004F;  //up to here.
        public const uint language_override=0x10000037;
        public const uint average_skill_level=0x1000002D;
        public const uint hopper_identifier=0x10000015;
        public const uint average_mu=0x5000002A;
        public const uint lowest_skill_level=0x1000002B;
        public const uint highest_skill_level=0x1000002C;
        public const uint nat_type=0x1000004D;
        public const uint joinable_party_size_10=0x10000051;
        public const uint team_matching=0x10000050;
        public const uint joinable_party_size_11=0x10000052;
        public const uint joinable_party_size_12=0x10000053;
        public const uint joinable_party_size_13=0x10000054;
        public const uint joinable_party_size_14=0x10000055;
        public const uint joinable_party_size_15=0x10000056;
        public const uint weight_average_party_mu=0x50000059;
        public const uint weight_min_party_skill=0x5000005A;
        public const uint weight_max_party_skill=0x5000005B;
        public const uint weight_average_party_skill=0x5000005C;
        public const uint weight_social_1=0x5000007A;
        public const uint weight_social_2=0x5000007B;
        public const uint weight_social_3=0x5000007C;
        public const uint weight_social_4=0x5000007D;
        public const uint weight_locality_x=0x5000007E;
        public const uint weight_locality_y=0x5000007F;
        public const uint weight_locality_z=0x50000080;
        public const uint weight_language=0x50000081;
        public const uint weight_average_experience=0x50000082;
        public const uint weight_dlc_1=0x50000083;
        public const uint weight_dlc_2=0x50000084;
        public const uint weight_dlc_3=0x50000085;
        public const uint locality_x=0x50000071;
        public const uint locality_y=0x50000072;
        public const uint locality_z=0x50000073;
        public const uint weight_xbl_party_chat=0x500000AE;
        public const uint preference_good_connection=0x100000AF;
        public const uint preference_skill=0x100000B0;
        public const uint preference_language=0x100000B1;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XMatchTest\MigrationStressTests.cs ===
using System;
using System.Collections;
using ServerTestFramework;
using ServerTestFramework.LiveService.Matchmaking;
using ServerTestFramework.Utilities;
using xonline.common.config;

namespace XMatchTest {

    //a common class for the migration testing
    public abstract class MigrationStressBase : MatchStressBase {
        public static bool IsSessionIDInQueue(Queue sessQ, long sessionID) {
            foreach(MatchSession sess in sessQ) {
                if ((long) sess.GetSessionID() == sessionID) {
                    return true;
                }
            }
            return false;
        }

        public static bool VERIFY_CASES = false;  //if set to true, this will take extra time for
                                                 //verification during the test.  Turn it off if we want
                                                 //the client to be able to generate more TPS.

        public bool Verify(MatchSession session) {
            if (VERIFY_CASES) {
                return MatchUtil.VerifyServerAndPartitionInfo(session);
            } else {
                return true;  //give everyone a free pass if we're not checking
            }
        }
    }

    //create a session for this title
    public abstract class MigrationCreate : MigrationStressBase {
        public TEST_RESULTS Run(bool rankedSession)
        {
            bool success = false;
            uint titleID; Queue sessQ;
            Stress2Helpers.GetSingleTitleAndQ(out titleID, out sessQ);
            SGADDR sgAddr;

            XRL2CreateUpdateSession createReq = Stress2Helpers.GetRandomXRL2Create(rankedSession, titleID, sessQ, out sgAddr);
            XRLSessionInfo createResp;
            if (createReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out createResp))
            {
                MatchSession newSession = new MatchSession(titleID, createReq, createResp);
                //have match session verify here
                if (Verify(newSession)) {
                    success = true;
                }
                //all done, we can start using it now
                Queue.Synchronized(sessQ).Enqueue(newSession);
            }
            if (!success) {
                StressParams.Safetw.WriteLine(DateTime.Now.ToString() + ": CreateSession failed: " + 
                                              Global.XErrToString(createReq.XErr));
                return TEST_RESULTS.FAILED;
            } else {
                return TEST_RESULTS.PASSED;
            }
        }
    }

    //invidual cases, so that you can set them separately.
    public class MigrationCreateRanked : MigrationCreate 
    {
        public override void Run() 
        {
            Run(true);
        }
    }

    public class MigrationCreateStandard : MigrationCreate
    {
        public override void Run()
        {
            Run(false);
        }
    }
////////////////////////
    public class MigrationSplit : MigrationStressBase
    {
        public override void Run()
        {
            uint titleID; Queue sessQ;
            Stress2Helpers.GetSingleTitleAndQ(out titleID, out sessQ);

            if (sessQ.Count == 0)
            {
                //this really shouldn't happen, but if it does, don't execute the split.
                throw new DidNotExecuteException("Session queue is empty.");
            }

            //could use peek here, but delete can kill the session before split finishes.
            MatchSession sessToSplit = (MatchSession)Queue.Synchronized(sessQ).Dequeue();
            MatchSession newSession;
            try
            {
                newSession = sessToSplit.Split(true);
                if (Verify(newSession)/* && Verify(sessToSplit)*/)
                {  //we can't verify the
                    //sessToSplit because it was
                    //peeked on the Q and could be different.
                    Queue.Synchronized(sessQ).Enqueue(newSession);
                    Queue.Synchronized(sessQ).Enqueue(sessToSplit); //since we dequeued earlier, put
                    //sessToSplit back too!
                }
                else
                {
                    throw new UnexpectedTestResultException("MigrationSplit failed to verify session.");
                }
            }
            catch (UnexpectedTestResultException)
            {
                throw;
            }
            catch (Exception e)
            {
                String msg = String.Format("{0}:MigrationSplit failed", DateTime.Now);
                StressParams.Safetw.WriteLine(msg + "\r\n" + e.ToString());
                throw new UnexpectedTestResultException(msg, e);
            }
        }
    }

    /// <summary>
    /// These tests, unlike the stress ones, will only search by id and by a standard query.  
    /// This is because the stress tests are very peculiar about their title.
    /// </summary>
    public class MigrationSearchByID : MigrationStressBase
    {
        public override void Run()
        {
            uint titleID; Queue sessQ;
            Stress2Helpers.GetSingleTitleAndQ(out titleID, out sessQ);

            MatchSession session;
            try
            {
                session = (MatchSession)Queue.Synchronized(sessQ).Dequeue(); //question this--if we peek, all our searches
            }
            catch (InvalidOperationException)
            {
                StressParams.Safetw.WriteLine(DateTime.Now.ToString() + ":MigrationSearchByID: sessQ is empty.");
                throw new DidNotExecuteException("MigrationSearchById: sessQ is empty.");
            }

            try
            {
                //hit the same session...  should dequeue/requeue.
                XRL2SearchResults searchResults;
                MatchUtil.FindExistingSessionByID(session, out searchResults);
            
                if ((searchResults == null) || !(Verify(session)))
                {
                    throw new UnexpectedTestResultException("FindExistingSessionByID failed.");
                }
            }
            finally
            {
                Queue.Synchronized(sessQ).Enqueue(session);  //put it back at the back
            }
        }
    }

    public class MigrationSearchByQuery : MigrationStressBase
    {
        public override void Run()
        {
            uint titleID; Queue sessQ;
            Stress2Helpers.GetSingleTitleAndQ(out titleID, out sessQ);
            MatchSession session;
            try
            {
                session = (MatchSession)Queue.Synchronized(sessQ).Dequeue(); //remove it--this way it can't be updated
                //from under us.
                //if we add it back here, then we allow async issues--which will cause failures on verify, but
                //test them.
            }
            catch (InvalidOperationException)
            {
                StressParams.Safetw.WriteLine(DateTime.Now.ToString() + ":MigrationSearchByQuery: sessQ is empty.");
                throw new UnexpectedTestResultException("MigrationSearchByQuery: sessQ is empty.");
            }

            try
            {
                //special case for round-robining.  Search more than once.  Note this completely messes
                //up perf, so you can't trust the TPS if the round robin search is on.
                bool foundByQuery = false;
                for (int i = 0; i < Stress2Params.RoundRobinSearchRetries; i++)
                {

                    if (MatchUtil.VerifySearchByQuery(session,Stress2Params.RoundRobinSearchRetries > 1))
                    { 
                        //quiet retries for RR
                        foundByQuery = true;
                    }
                }

                if (!foundByQuery || !Verify(session))
                {
                    throw new UnexpectedTestResultException("VerifySearchByQuery failed.");
                }
            }
            finally
            {
                Queue.Synchronized(sessQ).Enqueue(session);  //replace it.
            }
        }
    }

////////////////////////
    public class MigrationUpdate : MigrationStressBase 
    {
        private bool InstanceOfPercentChance(uint percent) 
        {
            if (percent == 100) return true; //just in case caller is silly.
            return (RandomEx.GlobalRandGen.Next(0, 100) < percent) ;
        }

        private bool UpdateThisSession(MatchSession session) 
        {
            bool success = false;

            //some statistics on updates:
            //1)20% of updates close the session by setting dwPublicOpen to 0
            //2)let's say 15% of updates switch the game mode.

            //to be fast, we'll avoid MatchSession's update, which throws every attrib up.  Instead
            //we'll create our own update request, and mirror it on the MatchSession.

            //these two are just random updates
            XRL2CreateUpdateSession updateReq = new XRL2CreateUpdateSession((byte[]) session.GetSessionID());
            updateReq.baseCreateUpdate.baseSession.dwTitleID = session.TitleID;
            XRLXeAttribParam[]	attribs = new XRLXeAttribParam[2];
            int	index = RandomEx.GlobalRandGen.Next(0,4);
            double newValue = Stress2Params.float64ValueArray[index];

            attribs[0] = new XRLXeAttribParam(Stress2Params.PROPERTY_FLOAT64PROP,new XRLXeDoubleValue(newValue));
            attribs[1] = new XRLXeAttribParam(Stress2Params.CONTEXT_MYCONTEXT,
                                              new XRLXeIntValue(Stress2Params.CONTEXT_MYCONTEXT_MYCONTEXTVALUE1));
            updateReq.AddAttribs(attribs);
            session.UpdateAttrib(attribs[0], false); //mirror in the stored create/update
            session.UpdateAttrib(attribs[1], false); //mirror in the stored create/update

            //20% chance of closure
            bool shouldClose = InstanceOfPercentChance(Stress2Params.percentChanceOfChangingMode);
            if (shouldClose) {
                updateReq.baseCreateUpdate.baseSession.dwPublicOpen = 0;
                session.ForceClose(false);
            } else {
                //the update request defaults to 8, so no need to change that.
                session.ForceOpen(false);
            }

            //15% chance of flipping mode.
            bool shouldChangeMode = InstanceOfPercentChance(Stress2Params.percentChanceOfClosingSession);
            if (shouldChangeMode) {
                XRLXeIntValue newMode;
                if (session.GetSessionMode() == Stress2Params.CONTEXT_GAME_MODE_GAMEMODEA) {
                    newMode = new XRLXeIntValue(Stress2Params.CONTEXT_GAME_MODE_GAMEMODEB);
                } else {
                    newMode = new XRLXeIntValue(Stress2Params.CONTEXT_GAME_MODE_GAMEMODEA);
                }

                XRLXeAttribParam modeChangeAttrib = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE, newMode);
                updateReq.AddAttrib(modeChangeAttrib);
                session.UpdateAttrib(modeChangeAttrib, false);
            }

            //send up the request
            if(updateReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd))) {
                session.UpdateServerLocation();  //must be done manually since we're subverting the
                                                 //usual update path
                if (Verify(session)) {
                    success = true;
                }
            } else {
                StressParams.Safetw.WriteLine(DateTime.Now.ToString() + ":Migration Update failed:" + 
                                              Global.XErrToString(updateReq.XErr));
            }
            return success;
        }

        public override void Run() 
        {
            uint titleID; Queue sessQ;
            Stress2Helpers.GetSingleTitleAndQ(out titleID, out sessQ);
            
            MatchSession session;
            try
            {
                session = (MatchSession)Queue.Synchronized(sessQ).Dequeue();
            }
            catch (InvalidOperationException)
            {
                StressParams.Safetw.WriteLine(DateTime.Now.ToString() + ":MigrationUpdate: sessQ is empty.");
                throw new DidNotExecuteException("MigrationUpdate: sessQ is empty.");
            }

            if(UpdateThisSession(session))
            {
                Queue.Synchronized(sessQ).Enqueue(session);	// put the session back for re-use
            }
            else
            {
                throw new UnexpectedTestResultException("UpdateThisSession failed.");
            }
        }
    }

    public class MigrationDelete : MigrationStressBase 
    {
        public override void Run()
        {
            uint titleID; Queue sessQ;
            Stress2Helpers.GetSingleTitleAndQ(out titleID, out sessQ);

            if (sessQ.Count < 100)
            {
                throw new DidNotExecuteException("sessQ does not have enough entries");
            }

            MatchSession session;
            try
            {
                session = (MatchSession)Queue.Synchronized(sessQ).Dequeue();
            }
            catch (InvalidOperationException)
            {
                StressParams.Safetw.WriteLine(DateTime.Now.ToString() + ":MigrationDelete: sessQ is empty.");
                throw new DidNotExecuteException("MigrationDelete: sessQ is empty.");
            }

            if(!session.Delete() || !MatchPartUtil.NegativeVerify(session))
            {
                StressParams.Safetw.WriteLine(DateTime.Now.ToString() + ":MigrationDelete failed:");
                throw new UnexpectedTestResultException("MigrationDelete failed:");
            }
        }
    }

    public class MigrationDeadXbox : MigrationStressBase
    {
        public override void Run()
        {
            uint titleID; Queue sessQ;
            Stress2Helpers.GetSingleTitleAndQ(out titleID, out sessQ);

            if (sessQ.Count < 100)
            {
                throw new DidNotExecuteException("sessQ does not have enough entries");
            }

            MatchSession session;
            bool success = true;
            try
            {
                session = (MatchSession)Queue.Synchronized(sessQ).Dequeue();
                try
                {
                    session.DeadXbox();
                }
                catch (Exception e)
                {
                    StressParams.Safetw.WriteLine(DateTime.Now.ToString() + ":MigrationDeadXbox: Failed with message " + e.Message);
                    success = false;
                }
                success = MatchPartUtil.NegativeVerify(session) && success;

            }
            catch (InvalidOperationException)
            {
                StressParams.Safetw.WriteLine(DateTime.Now.ToString() + ":MigrationDeadXbox: sessQ is empty.");
                throw new DidNotExecuteException("MigrationDeadXbox: sessQ is empty.");
            }


            if (!success)
            {
                StressParams.Safetw.WriteLine(DateTime.Now.ToString() + ":MigrationDeadXbox failed:");
                throw new DidNotExecuteException("MigrationDeadXbox failed:");
            }
        }
    }

    /// <summary>
    /// DeadSG really requires we know keep some storage of which sessions come 
    /// from which SG, so we can iterate and send them a "you should be deleted" 
    /// message on this side.  May be easier in a functional case...  For now, 
    /// if you do this, expect a large number of errors.  
    /// Note... we really only have one SG(fakeSG).  All sessions should be 
    /// deleted *except* those that are split.  (by default, those create a 
    /// separate and randomized SG).
    /// </summary>
    public class MigrationDeadSG : MigrationStressBase
    {
        public override void Run()
        {
            uint titleID; Queue sessQ;
            Stress2Helpers.GetSingleTitleAndQ(out titleID, out sessQ);

            if (sessQ.Count < 100)
            {
                throw new DidNotExecuteException("sessQ does not have enough entries");
            }

            MatchSession session;
            bool success;
            try
            {
                session = (MatchSession)Queue.Synchronized(sessQ).Dequeue();
                success = session.DeadSG();
                success = MatchPartUtil.NegativeVerify(session) && success;

            }
            catch (InvalidOperationException)
            {
                StressParams.Safetw.WriteLine(DateTime.Now.ToString() + ":MigrationDeadSG: sessQ is empty.");
                throw new DidNotExecuteException("MigrationDeadSG: sessQ is empty.");
            }

            if (!success)
            {
                StressParams.Safetw.WriteLine(DateTime.Now.ToString() + ":MigrationDeadSG failed:");
                throw new UnexpectedTestResultException("MigrationDeadSG failed:");
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XMatchTest\STFMatchCounters.cs ===
using System.Diagnostics;
using xonline.common.mgmt;
using ServerTestFramework.LiveService.Matchmaking;

namespace XMatchTest {
/*
    [XomPerformanceCounterCategoryAttr( "STF: Match Stress", "Server Test Framework - Match Stress" )]
*/
    public class STFMatchCounters // : XomPerformanceCounterCategory
    {
/*
        static public STFMatchCounters Counters = new STFMatchCounters();

        public virtual STFMatchCounters this[uint titleId]
        {
            get
            {
                return (STFMatchCounters) GetInstance("0x"+titleId.ToString("X8"));
            }
        }

        // Totals across all requests served by the match front door
        // (except health checks)
        [XomPerformanceCounterAttr("ActiveRankedSessions", "Total number of active ranked sessions", 
                                   PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter ActiveRankedSessions;

        [XomPerformanceCounterAttr("ActiveStandardSessions", "Total number of active standard sessions", 
                                   PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter ActiveStandardSessions;

*/
        //if there's anything about a session to record, it can be done here.
        public static void AddToSessionCount(SessIDAndSgAddr hostInfo) {
            if (hostInfo.ranked) {
                Stress2Params.numActiveRankedSessions++;
            } else {
                Stress2Params.numActiveStandardSessions++;
            }
        }

        //same for deletion of any session.
        public static void RemoveFromSessionCount(SessIDAndSgAddr hostInfo) {
            if (hostInfo.ranked) {
                Stress2Params.numActiveRankedSessions--;
            } else {
                Stress2Params.numActiveStandardSessions--;
            }
        }
        
        public const int ALLOWED_RANGE = 500;  //keep within 500 sessions


        //DISABLE FOR NOW.  These aren't accurate, and I don't quite have time to fix them.
        //one day create a set of these, per-title.  For now we assume just one title.
        public static bool CreateAllowed(bool ranked) {
            return true;
/*
            long distance;
            if (ranked) {
                distance = Stress2Params.numActiveRankedSessions - Stress2Params.numOpenRankedSessionsForHit;
            } else {
                distance = Stress2Params.numActiveStandardSessions - Stress2Params.numOpenSocialSessionsForHit;
            }

            if (distance > ALLOWED_RANGE) return false;
            return true;
*/
            //take a percentage of distance out?
            //for now let's just return true otherwise.
            //return (RandomEx.GlobalRandGen.NextDouble() < (ALLOWED_RANGE - distance) / ALLOWED_RANGE);
        }
        
        public static bool DeleteAllowed(bool ranked) {
            return true;
/*
            long distance;
            if (ranked) {
                distance = Stress2Params.numOpenRankedSessionsForHit - Stress2Params.numActiveRankedSessions;
            } else {
                distance = Stress2Params.numOpenSocialSessionsForHit - Stress2Params.numActiveStandardSessions;
            }

            if (distance > ALLOWED_RANGE) return false;
            return true;
*/
        }
    }



}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XMatchTest\Stress2Create.cs ===
using System;
using System.Collections;
using ServerTestFramework;
using ServerTestFramework.LiveService.Matchmaking;
using ServerTestFramework.Utilities;
using xonline.common.config;

namespace XMatchTest
{
    public abstract class Stress2CreateTestBase : MatchStressBase
    {
        protected void Run(bool rankedSession)
        {
            if (!STFMatchCounters.CreateAllowed(rankedSession)) 
            {
                throw new DidNotExecuteException("Create disallowed.");
            }

            uint titleID; Queue sessQ;
            Stress2Helpers.GetRandomTitleAndQ(out titleID, out sessQ);

/*
            //population control--if the value is already > 1% over the initial queue size, and the
            //StrictQueueSize setting is on, then not-execute this create.  Not completely
            //implemented yet.
            if (XMatchTest.ActionPermittedOnQueue(sessQ, titleID, XmatchTest.RequestType.CREATE2)) {
                return(TEST_RESULTS.NOT_EXECUTED);
            }
*/
            SGADDR sgAddr;
            XRL2CreateUpdateSession createReq = Stress2Helpers.GetRandomXRL2Create(rankedSession, titleID, sessQ, out sgAddr);
            //we default to 50/50 chance of A/B, but let the override settings
            //apply.  Note we'll have to refactor this, because the first check
            //above assumes two modes.
            XMatchTest.ApplySessionModeOverride(createReq, XMatchTest.RequestType.CREATE2);
            XMatchTest.CloseSessionIfSelected(createReq, rankedSession);  //use this to keep closed/open
                                                                          //sessions about constant.

            try
            {
                XRLSessionInfo createResp;
                if (createReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out createResp))
                {
                    SessIDAndSgAddr hostInfo = new SessIDAndSgAddr(createResp.SessionID, sgAddr, rankedSession);
                    sessQ.Enqueue(hostInfo);
                    STFMatchCounters.AddToSessionCount(hostInfo);
                }
                else
                {
                    String msg = String.Format("{0}: CreateSession failed: {1}", DateTime.Now, Global.XErrToString(createReq.XErr));
                    StressParams.Safetw.WriteLine(msg);
                    throw new UnexpectedTestResultException(msg);
                }

                //population control--if the value is 5% too big after a create, then delete the next session
                //immediately afterwards.  NOTE THIS IS NOT CAPTURED IN THE TPS.
            }
            finally
            {
                XMatchTest.LimitSessionQueue(sessQ, titleID);
            }
        }
    }


    public class Stress2CreateRanked : Stress2CreateTestBase
    {
        public override void Run()
        {
            Run(true);
        }
    }

    public class Stress2CreateStandard : Stress2CreateTestBase
    {
        public override void Run()
        {
            Run(false);
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XMatchTest\Stress2Delete.cs ===
using System;
using System.Collections;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.Matchmaking;
using xonline.common.config;

namespace XMatchTest
{
    /// <summary>
    /// This class does Session Delete
    /// </summary>
    public class Stress2tDeleteTitle : MatchStressBase
    {
        public override void Run()
        {
            uint titleID; Queue sessQ;
            Stress2Helpers.GetRandomTitleAndQ(out titleID, out sessQ);


            if (sessQ.Count < 500)  //bare minimum.  Should allow deadxboxes and titlechanges to
            //execute ok.
            {
                throw new DidNotExecuteException("sessQ count does not contain enough entries.");
            }

            byte[] sessID;

            try
            {

                SessIDAndSgAddr hostInfo = (SessIDAndSgAddr)sessQ.Dequeue();
                sessID = (byte[])(hostInfo.SessID);
                if (!STFMatchCounters.DeleteAllowed(hostInfo.ranked))
                {
                    //put the session back.
                    sessQ.Enqueue(hostInfo);
                    throw new DidNotExecuteException("Delete disallowed.");
                }
                STFMatchCounters.RemoveFromSessionCount(hostInfo);
            }
            catch (InvalidOperationException)
            {
                StressParams.Safetw.WriteLine(DateTime.Now.ToString() + ":Stress2tDeleteTitle: sessQ is empty.");
                throw new DidNotExecuteException("Stress2tDeleteTitle: sessQ is empty.");
            }

            XRL2DeleteSession delReq = new XRL2DeleteSession(sessID, titleID);
            delReq.dwTitleID = titleID;

            if (!delReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd)))
            {
                String msg = String.Format("{0}:Stress2DeleteTitle failed:{1}", DateTime.Now, Global.XErrToString(delReq.XErr));
                StressParams.Safetw.WriteLine(msg);
                throw new UnexpectedTestResultException(msg);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XMatchTest\Stress2Search.cs ===
using System;
using System.Collections;
using System.Net;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.Matchmaking;
using xonline.common.config;

namespace XMatchTest
{
    public abstract class Stress2SearchBase : MatchStressBase
    {
        private static XRL2SearchSession SrcXRL2SearchSession = new XRL2SearchSession(null, 0);
        private static XRL2SearchSession GetXRL2SearchSessionClone(XRLXeAttribParam[] searchParams, uint spIndex)
        {
            XRL2SearchSession clone = (XRL2SearchSession)SrcXRL2SearchSession.DeepClone();
            clone.baseSearchSession.dwProcedureIndex = spIndex;
            clone.AddParams(searchParams);
            return(clone);
        }
        
        public static XRLXeAttribParam [] CreateSystemSearchParams(bool rankedSearch) {
            UserTypeInfo userType = Stress2Helpers.GetRandomUserType();
            RatingInfo rating = Stress2Helpers.GetRandomRating();
            double gamerMu = RandomEx.GlobalRandGen.Next(0, 60) * 0.1;
            double gamerSigma = RandomEx.GlobalRandGen.NextDouble();// double between 0 and 1.0
            long gamerPUID = (long)RandomEx.GlobalRandGen.NextPuid();

            XRLXeAttribParam [] searchParams = new XRLXeAttribParam[9];
            
            if (rankedSearch)
            {
                searchParams[0] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_TYPE, new XRLXeIntValue(Constants.X_ATTRIBUTE_GAME_TYPE_RANKED));
            }
            else
            {
                searchParams[0] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_TYPE, new XRLXeIntValue(Constants.X_ATTRIBUTE_GAME_TYPE_STANDARD));
            }
            
            //default to 50/50 chance of searching for A/B.
            if (RandomEx.GlobalRandGen.Next(0, 2) == 0)
            {
                searchParams[1] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE, new XRLXeIntValue(Stress2Params.CONTEXT_GAME_MODE_GAMEMODEA));
            }
            else
            {
                searchParams[1] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE, new XRLXeIntValue(Stress2Params.CONTEXT_GAME_MODE_GAMEMODEB));
            }
            
            searchParams[2] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_ZONE, new XRLXeIntValue(userType.Zone));
            searchParams[3] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_COUNTRY, new XRLXeIntValue(userType.Country));
            searchParams[4] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_LANGUAGE,new XRLXeIntValue(userType.Language));
            searchParams[5] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_RATING, new XRLXeFloatValue(rating.RatingBucket));
            searchParams[6] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_MU, new XRLXeDoubleValue(gamerMu));
            searchParams[7] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_SIGMA, new XRLXeDoubleValue(gamerSigma));
            searchParams[8] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_PUID, new XRLXeIntValue(gamerPUID));
            return searchParams;
        }

        static IPAddress localIp = null;
        static Stress2SearchBase()
        {
            LocalInterface.GetBestMatch(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out localIp);
        }

        //default to non-weighted searches.
        protected void Run(uint spIndex, bool rankedSearch)
        {
            Run(spIndex, rankedSearch, false, false);
        }        

        protected void Run(uint spIndex, bool rankedSearch, bool simpleWeightAttribs, bool weightedSearchFlag)
        {
            uint titleID; Queue sessQ;
            Stress2Helpers.GetRandomTitleAndQ(out titleID, out sessQ);

            XRLXeAttribParam [] searchParams = CreateSystemSearchParams(rankedSearch);
            XRL2SearchSession	searchReq = GetXRL2SearchSessionClone(searchParams, spIndex);
            if (weightedSearchFlag) {
                searchReq.SetWeightedFlag(true);
            }
            XMatchTest.ApplySessionModeOverride(searchReq, XMatchTest.RequestType.SEARCH2);
            searchReq.baseSearchSession.dwTitleID = titleID;

            // every search parameter could be null and it's probability is configurable.
            XRLXeAttribParam[] customSearchParam = new XRLXeAttribParam[1];
            XRLXeAttribParamWeighted[] customSearchParamWeighted = new XRLXeAttribParamWeighted[1];
            int randomIndex = RandomEx.GlobalRandGen.Next(0, 100);
            if(Stress2Params.myContextParamValues[randomIndex] == 1)
            {
                long	contextValue;
                if(randomIndex %2 == 0)
                    contextValue = Stress2Params.CONTEXT_MYCONTEXT_MYCONTEXTVALUE1;
                else
                    contextValue = Stress2Params.CONTEXT_MYCONTEXT_MYCONTEXTVALUE2;
                customSearchParam[0] = new XRLXeAttribParam(Stress2Params.CONTEXT_MYCONTEXT,new XRLXeIntValue(contextValue));
                searchReq.AddParams(customSearchParam);
            }
            int	valueIndex = RandomEx.GlobalRandGen.Next(0,4);

            if(Stress2Params.int32PropParamValues[randomIndex] == 1)
            {
                int	int32Value = Stress2Params.int32ValueArray[valueIndex];
                if (!simpleWeightAttribs) {
                    customSearchParam[0] = new XRLXeAttribParam(Stress2Params.PROPERTY_INT32PROP,new XRLXeIntValue(int32Value));
                    searchReq.AddParams(customSearchParam);
                } else {
                    customSearchParamWeighted[0] = new XRLXeAttribParamWeighted(Stress2Params.PROPERTY_INT32PROP, (float) 0.2, 
                                                                                new XRLXeIntValue(int32Value));
                    searchReq.AddWeightedParams(customSearchParamWeighted);
                }
            }
            if(Stress2Params.int64PropParamValues[randomIndex] == 1)
            {
                long	intValue = Stress2Params.int64ValueArray[valueIndex];
                if (!simpleWeightAttribs) {
                    customSearchParam[0] = new XRLXeAttribParam(Stress2Params.PROPERTY_INT64PROP,new XRLXeIntValue(intValue));
                    searchReq.AddParams(customSearchParam);
                } else {
                    customSearchParamWeighted[0] = new XRLXeAttribParamWeighted(Stress2Params.PROPERTY_INT64PROP, (float) 0.2, 
                                                                                new XRLXeIntValue(intValue));
                    searchReq.AddWeightedParams(customSearchParamWeighted);
                }

            }
            if(Stress2Params.float32PropParamValues[randomIndex] == 1)
            {
                float	fValue =Stress2Params.float32ValueArray[valueIndex];
                if (!simpleWeightAttribs) {
                    customSearchParam[0] = new XRLXeAttribParam(Stress2Params.PROPERTY_FLOAT32PROP,new XRLXeFloatValue(fValue));
                    searchReq.AddParams(customSearchParam);
                } else {
                    customSearchParamWeighted[0] = new XRLXeAttribParamWeighted(Stress2Params.PROPERTY_FLOAT32PROP, (float) 0.2, 
                                                                                new XRLXeFloatValue(fValue));
                    searchReq.AddWeightedParams(customSearchParamWeighted);
                }
            }
            if(Stress2Params.float64PropParamValues[randomIndex] == 1)
            {
                double	dValue =Stress2Params.float64ValueArray[valueIndex];
                if (!simpleWeightAttribs) {
                    customSearchParam[0] = new XRLXeAttribParam(Stress2Params.PROPERTY_FLOAT64PROP,new XRLXeDoubleValue(dValue));
                    searchReq.AddParams(customSearchParam);
                } else {
                    customSearchParamWeighted[0] = new XRLXeAttribParamWeighted(Stress2Params.PROPERTY_FLOAT64PROP, (float) 0.2, 
                                                                                new XRLXeDoubleValue(dValue));
                    searchReq.AddWeightedParams(customSearchParamWeighted);
                }



            }
            if(Stress2Params.dateTimePropParamValues[randomIndex] == 1)
            {
                long	dateTimeValue = Stress2Params.dateTimeValueArray[valueIndex];
                if (!simpleWeightAttribs) {
                    customSearchParam[0] = new XRLXeAttribParam(Stress2Params.PROPERTY_DATETIMEPROP,new XRLXeDateTimeValue(dateTimeValue));
                    searchReq.AddParams(customSearchParam);
                }
            }
            
            Run(searchReq);
        }

        protected void Run(XRL2SearchSession searchReq)
        {
            XRL2SearchResults searchResp;

            // redirect query affiliate request to presence emulator
            searchReq.AlternatePresenceUrl = new IPEndPoint(localIp,Stress2Params.presListenerPort);

            if(!searchReq.Execute(true,Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out searchResp))
            {
                String msg = String.Format("{0}:Stress2SocialMatch_SortByAll_Title1 failed: {1:X}", DateTime.Now, searchReq.XErr);
                StressParams.Safetw.WriteLine(msg);
                throw new UnexpectedTestResultException(msg);
            }
        }

    }

    public class Stress2SocialMatch_SortByInt64 : Stress2SearchBase
    {
        public override void Run()
        {
            Run(Stress2Params.SESSION_MATCH_QUERY_SORTBYINT64QUERY, false);
        }

    }




	public class Stress2SocialMatch_SortByFloat64 : Stress2SearchBase
	{
		public override void Run()
		{
			Run(Stress2Params.SESSION_MATCH_QUERY_SORTBYFLOAT64QUERY, false);
		}
	}

	public class Stress2SocialMatch_SortByDateTime: Stress2SearchBase
	{
		public override void Run()
		{
			Run(Stress2Params.SESSION_MATCH_QUERY_SORTBYDATETIMEQUERY, false);
		}
	}

	public class Stress2SocialMatch_SortByAll : Stress2SearchBase
	{
		public override void Run()
		{
			Run(Stress2Params.SESSION_MATCH_QUERY_SORTBYALLQUERY, false);
		}
	}

	public class Stress2RankedMatch_SortByInt64 : Stress2SearchBase
	{
		public override void Run()
		{
			Run(Stress2Params.SESSION_MATCH_QUERY_SORTBYINT64QUERY, true);
		}
	}

	public class Stress2RankedMatch_SortByFloat64 : Stress2SearchBase
	{
		public override void Run()
		{
			Run(Stress2Params.SESSION_MATCH_QUERY_SORTBYFLOAT64QUERY, true);
		}
	}

	public class Stress2RankedMatch_SortByDateTime : Stress2SearchBase
	{
		public override void Run()
		{
			Run(Stress2Params.SESSION_MATCH_QUERY_SORTBYDATETIMEQUERY, true);
		}
	}

	public class Stress2RankedMatch_SortByAll : Stress2SearchBase
	{
		public override void Run()
		{
			Run(Stress2Params.SESSION_MATCH_QUERY_SORTBYALLQUERY, true);
		}
	}

	public class Stress2RankedMatch_SortByAll_WeightedFlag : Stress2SearchBase
	{
		public override void Run()
		{
                    Run(Stress2Params.SESSION_MATCH_QUERY_SORTBYALLQUERY, true, false, true);
		}
	}

	public class Stress2SocialMatch_SortByAll_WeightedFlag : Stress2SearchBase
	{
		public override void Run()
		{
                    Run(Stress2Params.SESSION_MATCH_QUERY_SORTBYALLQUERY, false, false, true);
		}
	}


	public class Stress2SimpleWeightedRanked : Stress2SearchBase
	{
		public override void Run()
		{
                    Run(Stress2Params.SESSION_MATCH_QUERY_SIMPLE_WEIGHTED_QUERY, true, true, true);
		}
	}

	public class Stress2SimpleWeightedStandard : Stress2SearchBase
	{
		public override void Run()
		{
                    Run(Stress2Params.SESSION_MATCH_QUERY_SIMPLE_WEIGHTED_QUERY, false, true, true);
		}
	}




    public class Stress2ByIDQueryTitle : MatchStressBase
    {
        private static XRL2SearchSession SrcXRL2SearchSession = new XRL2SearchSession(false, Constants.X_SSINDEX_GET_SESSION);
        private static XRL2SearchSession GetXRL2SearchSessionClone(bool defaultSearchParams, uint spIndex)
        {
            if (defaultSearchParams)
            {
                throw new UnexpectedTestResultException("Don't know how to handle defaultSearchParams = true");
            }
            if (spIndex != Constants.X_SSINDEX_GET_SESSION)
            {
                throw new UnexpectedTestResultException("Don't know how to handle spIndex != Constants.X_SSINDEX_GET_SESSION");
            }
            XRL2SearchSession clone = (XRL2SearchSession)SrcXRL2SearchSession.DeepClone();
            return (clone);
        }

        public override void Run()
        {
            uint titleID; Queue sessQ;
            Stress2Helpers.GetRandomTitleAndQ(out titleID, out sessQ);

            byte[] sessID;
            try
            {
                sessID = (byte[])((SessIDAndSgAddr)sessQ.Peek()).SessID;  //TODO:why peek,
                //why not dequeue?
            }
            catch (InvalidOperationException)
            {	// sessQ is empty
                StressParams.Safetw.WriteLine(DateTime.Now.ToString() + ":Stress2ByIDQueryTitle1: sessQ is empty.");
                throw new DidNotExecuteException("Stress2ByIDQueryTitle1: sessQ is empty.");
            }

            XRL2SearchSession searchReq = GetXRL2SearchSessionClone(false, Constants.X_SSINDEX_GET_SESSION);
            XRL2SearchResults searchResp;
            long lSessID = Constants.sessionIDConvert(sessID);

            searchReq.baseSearchSession.dwTitleID = titleID;
            XRLXeAttribParam[] Params = new XRLXeAttribParam[1] { new XRLXeAttribParam(Constants.X_ATTRIBUTE_SESSION_ID, new XRLXeIntValue(lSessID)) };
            searchReq.AddParams(Params);

            if (!searchReq.Execute(true, Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out searchResp))
            {
                String msg = String.Format("{0}::Stress2ByIDQuery failed:{1}", DateTime.Now, Global.XErrToString(searchReq.XErr));
                StressParams.Safetw.WriteLine(msg);
                throw new UnexpectedTestResultException(msg);
            }
        }
    }

	public class Stress2ByIDsQueryTitle : MatchStressBase
	{
		private static XRL2SearchSession SrcXRL2SearchSession = new XRL2SearchSession(false, Constants.X_SSINDEX_GET_SESSION);
		private static XRL2SearchSession GetXRL2SearchSessionClone(bool defaultSearchParams, uint spIndex)
		{
			if (defaultSearchParams)
			{
				throw new UnexpectedTestResultException("Don't know how to handle defaultSearchParams = true");
			}
			if (spIndex != Constants.X_SSINDEX_GET_SESSION)
			{
				throw new UnexpectedTestResultException("Don't know how to handle spIndex != Constants.X_SSINDEX_GET_SESSION");
			}
			XRL2SearchSession clone = (XRL2SearchSession)SrcXRL2SearchSession.DeepClone();
			return (clone);
		}

        /// <summary>
        /// 
        /// </summary>
        /// <param name="numberInBatch">The number in the batch to run, can't be less than 100</param>
        /// <returns></returns>
		public void Run(int numberInBatch)
		{
			uint titleID; Queue sessQ;
			Stress2Helpers.GetRandomTitleAndQ(out titleID, out sessQ);
			int numIds = (numberInBatch <= sessQ.Count ? numberInBatch : sessQ.Count);
			object[] sessObjects = new object[numIds];

			byte[] sessIDs = new byte[numIds * 8];
			
			try
			{
				// take objects of the queue so they can't be modified while the test is run
				for (int i = 0; i < numIds; i++)
				{
					sessObjects[i] = sessQ.Dequeue();
					Array.Copy((byte[])((SessIDAndSgAddr)sessObjects[i]).SessID, 0, sessIDs, i*8, 8);
				}
			}
			catch (InvalidOperationException)
			{	// sessQ is empty
				StressParams.Safetw.WriteLine(DateTime.Now.ToString() + ":Stress2ByIDsQueryTitle: sessQ is empty.");
                throw new DidNotExecuteException("Stress2ByIDsQueryTitle: sessQ is empty.");
			}

			XRL2SearchSession searchReq = new XRL2SearchSession(false, Constants.X_SSINDEX_GET_SESSION_LIST);
            searchReq.baseSearchSession.dwTitleID = titleID;
			
			XRL2SearchResults searchResp;
			//long lSessIDs = Constants.sessionIDConvert(sessIDs);

            XRLXeAttribParam[] Params = new XRLXeAttribParam[1] {new XRLXeAttribParam(Constants.X_ATTRIBUTE_SESSION_ID_LIST, sessIDs)};
            searchReq.AddParams(Params);

            try
            {
                if (!searchReq.Execute(true, Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out searchResp))
                {
                    String msg = String.Format("{0}:Stress2ByIDsQueryTitle failed:{1}", DateTime.Now, Global.XErrToString(searchReq.XErr));
                    StressParams.Safetw.WriteLine(msg);
                    throw new UnexpectedTestResultException(msg);
                }

                StressParams.Safetw.WriteLine("{0}:Stress2ByIDsQueryTitle got result:{1}", DateTime.Now, Global.XErrToString(searchReq.XErr));
            }
            finally
            {
                //re-enqueue all the objects we removed
                for (int i = 0; i < numIds; i++)
                {
                    sessQ.Enqueue(sessObjects[i]);
                }
            }
		}
	}

    public class Stress2ByIDsQueryTitle10 : Stress2ByIDsQueryTitle 
    {
        public override void Run()
        {
            Run(10);
        }
    }

    public class Stress2ByIDsQueryTitle50 : Stress2ByIDsQueryTitle 
    {
        public override void Run()
        {
            Run(50);
        }
    }


    public class Stress2ByIDsQueryTitle100 : Stress2ByIDsQueryTitle 
    {
        public override void Run()
        {
            Run(100);
        }
    }


    public class Stress2SearchWeightedComplex : MatchStressBase
    {
        private const int NUMBER_OF_OPTIONAL_PARAMS = 3;

        private static XRL2SearchSession SrcXRL2SearchSession = new XRL2SearchSession(null, 0);
        private static XRL2SearchSession GetXRL2SearchSessionCloneWeighted(XRLXeAttribParam[] searchParams, uint spIndex)
        {
            XRL2SearchSession clone = (XRL2SearchSession)SrcXRL2SearchSession.DeepClone();
            clone.SetWeightedFlag(true);
            clone.SetSchemaVersion(5,3); //must do this before adding weighted params, or
                                         //RecalcOffsets will give wrong info
            clone.baseSearchSession.dwProcedureIndex = spIndex;
            clone.AddParams(searchParams);
            return(clone);
        }

        //create a clone of the parameter, with its value filled in randomly from 0 to the current
        //value of the parameter.  Throws exception on non-numeric attribs.
        private static XRLXeAttribParam CreateClonedParam(XRLXeAttribParam param) {
            XRLXeAttribParam newParamClone = (XRLXeAttribParam) param.DeepClone();
            if (param.aValue is XRLXeIntValue) {
                newParamClone.SetNumericValue(RandomEx.GlobalRandGen.Next(0, (int) param.aValue.GetNumericValue()));
            } else {
                newParamClone.SetNumericValue(RandomEx.GlobalRandGen.NextDouble() * param.aValue.GetNumericValue());
            }
            return newParamClone;
        }

        //Ugly, because the param and paramWeighted don't inherit or relate in any way.
        //Refactor some day.
        private static XRLXeAttribParamWeighted CreateClonedParamWeighted(XRLXeAttribParamWeighted param) {
            XRLXeAttribParamWeighted newParamClone = (XRLXeAttribParamWeighted) param.DeepClone();
            if (param.aValue is XRLXeIntValue) {
                newParamClone.aValue.SetNumericValue(RandomEx.GlobalRandGen.Next(0, (int) param.aValue.GetNumericValue()));
            } else {
                newParamClone.aValue.SetNumericValue(RandomEx.GlobalRandGen.NextDouble() * param.aValue.GetNumericValue());
            }
            return newParamClone;
        }

        static IPAddress localIp = null;


        protected void Run(bool rankedSearch)
        {
            if (localIp == null) {
                LocalInterface.GetBestMatch(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out localIp);
            }

            uint titleID; Queue sessQ;
            Stress2Helpers.GetRandomTitleAndQ(out titleID, out sessQ);
            UserTypeInfo userType = Stress2Helpers.GetRandomUserType();
            RatingInfo rating = Stress2Helpers.GetRandomRating();

            long gamerPUID = (long)RandomEx.GlobalRandGen.NextPuid();
            //double gamerMu = RandomEx.GlobalRandGen.Next(0, 60) * 0.1;
            double gamerSigma = RandomEx.GlobalRandGen.NextDouble();// double between 0 and 1.0



            const int NUM_SYSTEM_PARAMS_ADDED = 7;
            XRLXeAttribParam	[] searchParams = 
                new XRLXeAttribParam[NUM_SYSTEM_PARAMS_ADDED + Stress2Params.nonWeightedParamsComplex.Length + 
                                     NUMBER_OF_OPTIONAL_PARAMS];
            XRLXeAttribParamWeighted [] weightedSearchParams = new XRLXeAttribParamWeighted[Stress2Params.weightedParamComplex.Length];
            
            if (rankedSearch)
            {
                searchParams[0] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_TYPE, new XRLXeIntValue(Constants.X_ATTRIBUTE_GAME_TYPE_RANKED));
            }
            else
            {
                searchParams[0] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_TYPE, new XRLXeIntValue(Constants.X_ATTRIBUTE_GAME_TYPE_STANDARD));
            }
            
            //default to 50/50 chance of searching for A/B.
            if (RandomEx.GlobalRandGen.Next(0, 2) == 0)
            {
                searchParams[1] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE, new XRLXeIntValue(Stress2Params.CONTEXT_GAME_MODE_GAMEMODEA));
            }
            else
            {
                searchParams[1] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE, new XRLXeIntValue(Stress2Params.CONTEXT_GAME_MODE_GAMEMODEB));
            }
            
            searchParams[2] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_ZONE, new XRLXeIntValue(userType.Zone));
//            searchParams[3] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_COUNTRY, new XRLXeIntValue(userType.Country));
            searchParams[3] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_LANGUAGE,new XRLXeIntValue(userType.Language));
            searchParams[4] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_RATING, new XRLXeFloatValue(rating.RatingBucket));
//            searchParams[6] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_MU, new XRLXeDoubleValue(gamerMu));
            searchParams[5] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_SIGMA, new XRLXeDoubleValue(gamerSigma));
            searchParams[6] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_PUID, new XRLXeIntValue(gamerPUID));

            int offset = NUM_SYSTEM_PARAMS_ADDED;
            //fill in the remaining query data.
            for (int i=0; i< Stress2Params.nonWeightedParamsComplex.Length; i++) {
                searchParams[i+offset] = CreateClonedParam(Stress2Params.nonWeightedParamsComplex[i]);
            }
            offset = NUM_SYSTEM_PARAMS_ADDED + Stress2Params.nonWeightedParamsComplex.Length;
            for (int i=0; i< NUMBER_OF_OPTIONAL_PARAMS; i++) {
                searchParams[i+offset] = CreateClonedParam(Stress2Params.nonWeightedOptionalParams[i]);
            }

            //weighted params get their own array.
            for (int i=0; i< Stress2Params.weightedParamComplex.Length; i++) {
                weightedSearchParams[i] = CreateClonedParamWeighted(Stress2Params.weightedParamComplex[i]);
            }

            XRL2SearchSession	searchReq = GetXRL2SearchSessionCloneWeighted(searchParams, Stress2Params.SESSION_MATCH_QUERY_OMAHA_QUERY);
            searchReq.AddWeightedParams(weightedSearchParams);
            XMatchTest.ApplySessionModeOverride(searchReq, XMatchTest.RequestType.SEARCH2);


            searchReq.baseSearchSession.dwTitleID = titleID;
            XRL2SearchResults	searchResp;
            // redirect query affiliate request to presence emulator
            searchReq.AlternatePresenceUrl = new IPEndPoint(localIp,Stress2Params.presListenerPort);
            searchReq.baseSearchSession.dwTitleID = titleID;

            if(!searchReq.Execute(true,Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out searchResp))
            {
                String msg = String.Format("{0}:Stress2SearchWeightedComplex failed: 0x{1:X}", DateTime.Now, searchReq.XErr);
                StressParams.Safetw.WriteLine(msg);
                throw new UnexpectedTestResultException(msg);
            }
        }   
    } 

    public class Stress2SearchWeightedComplexRanked : Stress2SearchWeightedComplex
    {
        public override void Run()
        {
            Run(true);
        }
    }

    public class Stress2SearchWeightedComplexStandard : Stress2SearchWeightedComplex
    {
        public override void Run()
        {
            Run(false);
        }
    }

////////////////////////////////////////


    public class Stress2RankedSearchComplexQuery : Stress2GenericSearchQuery
    {
        public static XRLXeAttribParamWeighted [] emptyWeightedParam = new XRLXeAttribParamWeighted[0];
        public override void Run()
        {
            Run(true, false, Stress2Params.nonWeightedParamsComplex,
                emptyWeightedParam, 3, Stress2Params.SESSION_MATCH_QUERY_OMAHA_QUERY);
        }
    }

    public class Stress2StandardSearchComplexQuery : Stress2GenericSearchQuery
    {
        public static XRLXeAttribParamWeighted [] emptyWeightedParam = new XRLXeAttribParamWeighted[0];
        public override void Run()
        {
            Run(false, false, Stress2Params.nonWeightedParamsComplex,
                emptyWeightedParam, 3, Stress2Params.SESSION_MATCH_QUERY_OMAHA_QUERY);
        }
    }


    public class Stress2GenericSearchQuery : MatchStressBase
    {

        private static XRL2SearchSession SrcXRL2SearchSession = new XRL2SearchSession(null, 0);
        private static XRL2SearchSession GetXRL2SearchSessionClone(XRLXeAttribParam[] searchParams, uint spIndex, bool weighted)
        {
            XRL2SearchSession clone = (XRL2SearchSession)SrcXRL2SearchSession.DeepClone();
            if (weighted) { 
                clone.SetWeightedFlag(true);
            }
            clone.SetSchemaVersion(5,3); //must do this before adding weighted params, or
                                         //RecalcOffsets will give wrong info
            clone.baseSearchSession.dwProcedureIndex = spIndex;
            clone.AddParams(searchParams);
            return(clone);
        }

        //create a clone of the parameter, with its value filled in randomly from 0 to the current
        //value of the parameter.  Throws exception on non-numeric attribs.
        private static XRLXeAttribParam CreateClonedParam(XRLXeAttribParam param) {
            XRLXeAttribParam newParamClone = (XRLXeAttribParam) param.DeepClone();
            if (param.aValue is XRLXeIntValue) {
                newParamClone.SetNumericValue(RandomEx.GlobalRandGen.Next(0, (int) param.aValue.GetNumericValue()));
            } else {
                newParamClone.SetNumericValue(RandomEx.GlobalRandGen.NextDouble() * param.aValue.GetNumericValue());
            }
            return newParamClone;
        }

        //Ugly, because the param and paramWeighted don't inherit or relate in any way.
        //Refactor some day.
        private static XRLXeAttribParamWeighted CreateClonedParamWeighted(XRLXeAttribParamWeighted param) {
            XRLXeAttribParamWeighted newParamClone = (XRLXeAttribParamWeighted) param.DeepClone();
            if (param.aValue is XRLXeIntValue) {
                newParamClone.aValue.SetNumericValue(RandomEx.GlobalRandGen.Next(0, (int) param.aValue.GetNumericValue()));
            } else {
                newParamClone.aValue.SetNumericValue(RandomEx.GlobalRandGen.NextDouble() * param.aValue.GetNumericValue());
            }
            return newParamClone;
        }


        public static void AddSystemParams(bool rankedSearch, XRLXeAttribParam [] searchParams) {
            UserTypeInfo userType = Stress2Helpers.GetRandomUserType();
            RatingInfo rating = Stress2Helpers.GetRandomRating();
            long gamerPUID = (long)RandomEx.GlobalRandGen.NextPuid();
            double gamerSigma = RandomEx.GlobalRandGen.NextDouble();// double between 0 and 1.0
            if (rankedSearch)
            {
                searchParams[0] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_TYPE, new XRLXeIntValue(Constants.X_ATTRIBUTE_GAME_TYPE_RANKED));
            }
            else
            {
                searchParams[0] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_TYPE, new XRLXeIntValue(Constants.X_ATTRIBUTE_GAME_TYPE_STANDARD));
            }
            
            //default to 50/50 chance of searching for A/B.
            if (RandomEx.GlobalRandGen.Next(0, 2) == 0)
            {
                searchParams[1] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE, new XRLXeIntValue(Stress2Params.CONTEXT_GAME_MODE_GAMEMODEA));
            }
            else
            {
                searchParams[1] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE, new XRLXeIntValue(Stress2Params.CONTEXT_GAME_MODE_GAMEMODEB));
            }
            
            searchParams[2] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_ZONE, new XRLXeIntValue(userType.Zone));
//            searchParams[3] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_COUNTRY, new XRLXeIntValue(userType.Country));
            searchParams[3] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_LANGUAGE,new XRLXeIntValue(userType.Language));
            searchParams[4] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_RATING, new XRLXeFloatValue(rating.RatingBucket));
//            searchParams[6] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_MU, new XRLXeDoubleValue(gamerMu));
            searchParams[5] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_SIGMA, new XRLXeDoubleValue(gamerSigma));
            searchParams[6] = new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAMER_PUID, new XRLXeIntValue(gamerPUID));
        }

        static IPAddress localIp = null;


        protected void Run(bool rankedSearch, bool weightedFlag,
                           XRLXeAttribParam[] nonWeightedParams, 
                           XRLXeAttribParamWeighted[] weightedParams, 
                           int optionalNonWeightedOmahaParams, uint queryNum)
        {
            rankedSearch = true;
            if (localIp == null) {
                LocalInterface.GetBestMatch(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out localIp);
            }

            uint titleID; Queue sessQ;
            Stress2Helpers.GetRandomTitleAndQ(out titleID, out sessQ);

            const int NUM_SYSTEM_PARAMS_ADDED = 7;
            XRLXeAttribParam	[] searchParams = new XRLXeAttribParam[NUM_SYSTEM_PARAMS_ADDED + 
                                                                       nonWeightedParams.Length + 
                                                                       optionalNonWeightedOmahaParams];
            //System params...
            AddSystemParams(rankedSearch, searchParams);

            //Ordinary non-weighted
            int offset = NUM_SYSTEM_PARAMS_ADDED;
            for (int i=0; i< nonWeightedParams.Length; i++) {
                searchParams[i+offset] = CreateClonedParam(nonWeightedParams[i]);
            }
            //Now the optional non-weighted
            offset = NUM_SYSTEM_PARAMS_ADDED + nonWeightedParams.Length;
            for (int i=0; i< optionalNonWeightedOmahaParams; i++) {
                searchParams[i+offset] = CreateClonedParam(Stress2Params.nonWeightedOptionalParams[i]);
            }

            //Finally the weighted params
            XRLXeAttribParamWeighted [] weightedSearchParams = new XRLXeAttribParamWeighted[weightedParams.Length];
            for (int i=0; i< weightedParams.Length; i++) {
                weightedSearchParams[i] = CreateClonedParamWeighted(weightedParams[i]);
            }

            //Make the session and add in the arrays
            XRL2SearchSession	searchReq = GetXRL2SearchSessionClone(searchParams, queryNum, weightedFlag);
            searchReq.AddWeightedParams(weightedSearchParams);
            XMatchTest.ApplySessionModeOverride(searchReq, XMatchTest.RequestType.SEARCH2);

            searchReq.baseSearchSession.dwTitleID = titleID;
            XRL2SearchResults	searchResp;
            // redirect query affiliate request to presence emulator
            searchReq.AlternatePresenceUrl = new IPEndPoint(localIp,Stress2Params.presListenerPort);
            searchReq.baseSearchSession.dwTitleID = titleID;

            if(!searchReq.Execute(true,Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out searchResp))
            {
                String msg = String.Format("{0}:Stress2SearchWeightedComplex failed:{1}", DateTime.Now, Global.XErrToString(searchReq.XErr));
                StressParams.Safetw.WriteLine(msg);
                throw new UnexpectedTestResultException(msg);
            }            
        }   
    } 


    public class Stress2RankedSearchMidQuery : Stress2GenericSearchQuery
    {
        public static XRLXeAttribParamWeighted [] emptyWeightedParam = new XRLXeAttribParamWeighted[0];
        public override void Run()
        {
            Run(true, false, Stress2Params.nonWeightedParamsMidsizeUnweightedSearchTemplate,
                emptyWeightedParam, 0, Stress2Params.SESSION_MATCH_QUERY_MID_SIZE_UNWEIGHTED);
        }
    }

    public class Stress2StandardSearchMidQuery : Stress2GenericSearchQuery
    {
        public static XRLXeAttribParamWeighted [] emptyWeightedParam = new XRLXeAttribParamWeighted[0];
        public override void Run()
        {
            Run(false, false, Stress2Params.nonWeightedParamsMidsizeUnweightedSearchTemplate, 
                emptyWeightedParam, 0, Stress2Params.SESSION_MATCH_QUERY_MID_SIZE_UNWEIGHTED);
        }
    }

    public class Stress2WeightedRankedSearchMidQuery : Stress2GenericSearchQuery
    {
        public override void Run()
        {
            Run(true, true, Stress2Params.nonWeightedParamsMidsizeWeightedSearchTemplate,
                Stress2Params.weightedParamsMidsizeWeightedSearchTemplate, 0, Stress2Params.SESSION_MATCH_QUERY_MID_SIZE_WEIGHTED);
        }
    }

    public class Stress2WeightedStandardSearchMidQuery : Stress2GenericSearchQuery
    {
        public override void Run()
        {
            Run(false, true, Stress2Params.nonWeightedParamsMidsizeWeightedSearchTemplate, 
                Stress2Params.weightedParamsMidsizeWeightedSearchTemplate, 0, Stress2Params.SESSION_MATCH_QUERY_MID_SIZE_WEIGHTED);
        }
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XMatchTest\StressClient.cs ===
using System;
using System.Collections;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.Matchmaking;
using xonline.common.config;

namespace XMatchTest
{
	/// <summary>
	/// These are for normal queries
	/// </summary>
	public abstract class StressClientNormalQueryTitleBase : MatchStressBase
	{
		private static XRLSearchSession SrcXRLSearchSession = new XRLSearchSession(StressParams.COMMON_SP_INDEX);
		
		protected TEST_RESULTS Run(uint TitleID, uint maxIntAttrib)
		{
			TEST_RESULTS		ResultCode = TEST_RESULTS.FAILED;
			bool				fail = false;
			XRLSearchSession	searchReq = (XRLSearchSession)SrcXRLSearchSession.DeepClone();
			XRLSearchResults	searchResp;
			long				[] intValueArray;
			uint				numSearchParam = 0;
			XRLAttribParam		[]searchParams;

			searchReq.baseSearchSession.dwTitleID = TitleID;
			searchReq.baseSearchSession.ClientAddress.inaOnline = new byte[4]{0x81,0xFA,0x70,0x9D};

			// The sp for both titles all take MAX_INT_ATTRIB number of search parameters
			// and a string parameter; but some of them are NULLs
			// (Since Tsunami, we don't allow title to use string in the search parameter)

			// random value: the number of non-null search parameters (i.e.used in sp filter)
			do
			{
                            numSearchParam = (uint)(RandomEx.GlobalRandGen.Next((int)maxIntAttrib));
			}while(numSearchParam == 0);
			searchParams = new XRLAttribParam[maxIntAttrib];
			intValueArray = new long[numSearchParam];

			for(uint i = 0; i < numSearchParam; i++)
			{
				intValueArray[i] = StressParams.intValueArray[i%StressParams.COMB_SIZE];
			}
			searchReq.searchParamsOffsetsLen = numSearchParam;
			for(uint i = 0; i < maxIntAttrib; i++)
			{
				if(i < numSearchParam)
					searchParams[i] = new XRLAttribParam(Constants.X_ATTRIBUTE_DATATYPE_INTEGER,new XRLIntParam(intValueArray[i]));
				else
					searchParams[i] = new XRLAttribParam(Constants.X_ATTRIBUTE_DATATYPE_NULL,new XRLNullParam());
			}
			searchReq.AddParams(searchParams);

			if(!searchReq.Execute(true, Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out searchResp))
			{
				fail = true;
				StressParams.Safetw.WriteLine(DateTime.Now.ToString() + ":StressClientNormalQueryTitle failed:" +
					searchReq.XErr.ToString("x"));
			}
			if(fail == false)
				ResultCode = TEST_RESULTS.PASSED;
			return(ResultCode);
		}
	}

	public class StressClientNormalQueryTitle1 : StressClientNormalQueryTitleBase
	{
		public override void Run()
		{
            Run(StressParams.STRESS_TITLE_ID1, StressParams.MAX_INT_ATTRIB1);
		}
	}

	public class StressClientNormalQueryTitle2 : StressClientNormalQueryTitleBase
	{
		public override void Run()
		{
            Run(StressParams.STRESS_TITLE_ID2, StressParams.MAX_INT_ATTRIB2);
		}
	}

	/// <summary>
	/// These are for summary cache queries (used by Halo)
	/// </summary>
	public abstract class StressClientSummaryQueryTitleBase : MatchStressBase
	{
		private static XRLSearchSession SrcXRLSearchSession = new XRLSearchSession(StressParams.SUMMARY_SP_INDEX);

		protected TEST_RESULTS Run(uint TitleID, uint maxIntAttrib)
		{
			TEST_RESULTS		ResultCode = TEST_RESULTS.FAILED;
			bool				fail = false;
			XRLSearchSession	searchReq = (XRLSearchSession)SrcXRLSearchSession.DeepClone();
			XRLSearchResults	searchResp;

			// no search parameter for this search request
			searchReq.baseSearchSession.dwTitleID = TitleID;
			searchReq.baseSearchSession.ClientAddress.inaOnline = new byte[4]{0x81,0xFA,0x70,0x9D};

			if(!searchReq.Execute(true, Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out searchResp))
			{
				fail = true;
				StressParams.Safetw.WriteLine(DateTime.Now.ToString() + ":StressClientSummaryQueryTitle failed:" +
					searchReq.XErr.ToString("x"));
			}
			if(fail == false)
				ResultCode = TEST_RESULTS.PASSED;
			return(ResultCode);
		}
	}

	public class StressClientSummaryQueryTitle1 : StressClientSummaryQueryTitleBase
	{
		public override void Run()
		{
            Run(StressParams.STRESS_TITLE_ID1, StressParams.MAX_INT_ATTRIB1);
		}
	}

	public class StressClientSummaryQueryTitle2 : StressClientSummaryQueryTitleBase
	{
		public override void Run()
		{
            Run(StressParams.STRESS_TITLE_ID2, StressParams.MAX_INT_ATTRIB2);
		}
	}

	/// <summary>
	/// These are for searchByID queries
	/// </summary>
	public abstract class StressClientByIDQueryTitleBase : MatchStressBase
	{
		private static XRLSearchSession SrcXRLSearchSession = new XRLSearchSession(StressParams.BYID_SP_INDEX);

		protected TEST_RESULTS Run(uint TitleID, uint maxIntAttrib, Queue sessQ)
		{
			TEST_RESULTS		ResultCode = TEST_RESULTS.FAILED;
			bool				fail = false;
			byte []				sessID;

			try
			{
				sessID = (byte [])sessQ.Peek();
			}
			catch(InvalidOperationException)
			{	// sessQ is empty
				StressParams.Safetw.WriteLine(DateTime.Now.ToString() + ":StressClientByIDQueryTitle: sessQ is empty.");
				ResultCode = TEST_RESULTS.NOT_EXECUTED;
				return(ResultCode);
			}

			XRLSearchSession	searchReq = (XRLSearchSession)SrcXRLSearchSession.DeepClone();
			XRLSearchResults	searchResp;
			searchReq.baseSearchSession.dwTitleID = TitleID;
			searchReq.baseSearchSession.ClientAddress.inaOnline = new byte[4]{0x81,0xFA,0x70,0x9D};
			// only take sessionID as parameter
			XRLAttribParam		[]searchParams = new XRLAttribParam[1]{new XRLAttribParam(Constants.X_ATTRIBUTE_DATATYPE_INTEGER,new XRLIntParam(Constants.sessionIDConvert(sessID)))};
			searchReq.AddParams(searchParams);

			if(!searchReq.Execute(true, Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd),out searchResp))
			{
				fail = true;
				StressParams.Safetw.WriteLine(DateTime.Now.ToString() + ":StressClientByIDQueryTitle failed:" +
					searchReq.XErr.ToString("x"));
			}
			if(fail == false)
				ResultCode = TEST_RESULTS.PASSED;
			return(ResultCode);
		}
	}

	public class StressClientByIDQueryTitle1 : StressClientByIDQueryTitleBase
	{
		public override void Run()
		{
            Run(StressParams.STRESS_TITLE_ID1, StressParams.MAX_INT_ATTRIB1, StressParams.sessionQ1);
		}
	}

	public class StressClientByIDQueryTitle2 : StressClientByIDQueryTitleBase
	{
		public override void Run()
		{
            Run(StressParams.STRESS_TITLE_ID2, StressParams.MAX_INT_ATTRIB2, StressParams.sessionQ2);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XMatchTest\Stress2Update.cs ===
using System;
using System.Collections;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Matchmaking;
using xonline.common.config;

namespace XMatchTest
{
	/// <summary>
	/// This class does Session Update
	/// </summary>
    public class Stress2UpdateTitle : MatchStressBase
    {
        public override void Run()
        {
            uint titleID; Queue sessQ;
            Stress2Helpers.GetRandomTitleAndQ(out titleID, out sessQ);

            byte[] sessID = null;
            SessIDAndSgAddr hostInfo = null;

            try
            {
                hostInfo = (SessIDAndSgAddr)sessQ.Dequeue();
                sessID = (byte[])hostInfo.SessID;
                STFMatchCounters.RemoveFromSessionCount(hostInfo);
            }
            catch (InvalidOperationException)
            {
                SkipTest("Stress2UpdateTitle: sessQ is empty.");
            }

            XRL2CreateUpdateSession updateReq = new XRL2CreateUpdateSession(sessID);
            updateReq.baseCreateUpdate.baseSession.dwTitleID = titleID;

            //This section updates some attribs, as long as we don't use a completely
            //custom title schema.
            if (Stress2Params.customTitleSchema == null)
            {

                uint numUpdateAttrib = 2;
                XRLXeAttribParam[] attribs = new XRLXeAttribParam[numUpdateAttrib];
                int index = RandomEx.GlobalRandGen.Next(0, 4);
                double dValue = Stress2Params.float64ValueArray[index];
                attribs[0] = new XRLXeAttribParam(Stress2Params.PROPERTY_FLOAT64PROP, new XRLXeDoubleValue(dValue));
                attribs[1] = new XRLXeAttribParam(Stress2Params.CONTEXT_MYCONTEXT,
                                                  new XRLXeIntValue(Stress2Params.CONTEXT_MYCONTEXT_MYCONTEXTVALUE1));
                updateReq.AddAttribs(attribs);
            }

            // normal is about 20% of update calls are to close the session  DISABLED.
            // # of closed sessions is based on create.
            /*
                        int rollForCloseSession = RandomEx.GlobalRandGen.Next(0,100);
                                    if (rollForCloseSession < Stress2Params.percentChanceOfClosingSession)
                            updateReq.baseCreateUpdate.baseSession.dwPublicOpen = 0;
            */
            //respect the limits of closing given by the params
            XMatchTest.CloseSessionIfSelected(updateReq, hostInfo.ranked);

            // "let's say 15% of the people want to change mode".  But since we don't
            // know the session's mode...  let's make 30% try to switch, and randomize
            // the mode we switch to.
            int rollForUpdateMode = RandomEx.GlobalRandGen.Next(0, 100);
            if (rollForUpdateMode < Stress2Params.percentChanceOfChangingMode * 2)
            {
                if (RandomEx.GlobalRandGen.Next(0, 2) == 0)
                {
                    updateReq.AddAttrib(new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE,
                                                             new XRLXeIntValue(Stress2Params.CONTEXT_GAME_MODE_GAMEMODEA)));
                }
                else
                {
                    updateReq.AddAttrib(new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE,
                                                             new XRLXeIntValue(Stress2Params.CONTEXT_GAME_MODE_GAMEMODEB)));
                }
                //we default to 50/50 chance of A/B, but let the override settings
                //apply.  Note we'll have to refactor this, because the first check
                //above assumes two modes.
                XMatchTest.ApplySessionModeOverride(updateReq, XMatchTest.RequestType.UPDATE2);
            }
            if (!updateReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd)))
            {
                FailTest("Stress2UpdateTitle failed", updateReq.XErr);
            }
            else
            {
                sessQ.Enqueue(hostInfo);	// put the sessionID and sgAddrback until deleteSession is called
                STFMatchCounters.AddToSessionCount(hostInfo);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XMatchTest\StressHostCreate.cs ===
using System;
using System.Collections;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.Matchmaking;
using xonline.common.config;

namespace XMatchTest
{
	/// <summary>
	/// This class does Session Create
	/// </summary>
	public abstract class StressHostCreateTitleBase : TestNode
	{
		protected void Run(uint TitleID, uint maxIntAttrib, Queue sessQ)
		{
			XRLCreateUpdateSession	createReq = new XRLCreateUpdateSession();
			XRLSessionInfo			createResp;
			WireData				[]attribs = new WireData[maxIntAttrib];
			uint					intAttribID = StressParams.INT_ATTRIB_ID;
			long					[] intValueArray = new long[maxIntAttrib];

			for(uint i = 0; i < maxIntAttrib; i++)
				intValueArray[i] = StressParams.intValueArray[i%StressParams.COMB_SIZE];

			createReq.baseSession.dwTitleID = TitleID;
			createReq.baseSession.HostAddress.inaOnline = new byte[4]{0x04,0x00,0x00,0x58};	// real online IP
			createReq.AttribOffsetsLen = maxIntAttrib;

			for(uint i = 0; i < maxIntAttrib; i++)
			{
				attribs[i] = new XRLIntAttribute(intAttribID++, intValueArray[i]);
			}
			createReq.AddAttribs(attribs);

            if (createReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out createResp))
            {
                sessQ.Enqueue(createResp.SessionID);
            }
            else
            {
                MatchStressBase.FailTest("CreaseSession failed", createReq.XErr);
            }
		}
	}

	public class StressHostCreateTitle1 : StressHostCreateTitleBase
	{
		public override void Run()
		{
            Run(StressParams.STRESS_TITLE_ID1, StressParams.MAX_INT_ATTRIB1, StressParams.sessionQ1);
		}
	}


	public class StressHostCreateTitle2 : StressHostCreateTitleBase
	{
		public override void Run()
		{
            Run(StressParams.STRESS_TITLE_ID2, StressParams.MAX_INT_ATTRIB2, StressParams.sessionQ2);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XMatchTest\StressDeadXBoxTitleChange.cs ===
using System;
using System.IO;
using System.Text;
using System.Net;
using ServerTestFramework;
using System.Collections;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.LiveService.Matchmaking;
using xonline.common.config;

namespace XMatchTest
{
    public abstract class StressDeadXBoxTitleChangeBase : MatchStressBase
    {
        protected void Run(bool titleChange)
        {
            FDTransaction fdTrans = new FDTransaction();
            fdTrans.endPoint = Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd);

            uint titleID;  Queue sessQ;
            Stress2Helpers.GetRandomTitleAndQ(out titleID, out sessQ);

            // pick a titleID randomly
            if (sessQ.Count < 100)
            {
                throw new DidNotExecuteException(String.Format("{0}[{1}]: NOT_EXECUTED", 
                    (titleChange ? "StressTitleChange" : "StressDeadXBox"),
                    System.Threading.Thread.CurrentThread.ManagedThreadId));
            }

            // create a request that has 100 batched deadxbox or titleChange message
            XRLDeadXBox    []   dxreqs = new XRLDeadXBox[100];
            XRLTitleChange	[]	tcReqs = new XRLTitleChange[100];
            SessIDAndSgAddr		hostInfo = null;
            int					numRankedSession = 0, numSocialSession = 0;
			
            for(uint i = 0; i < 100; i++)
            {
                // choose sgAddr from available queue
                if(titleChange == false)
                {
                    dxreqs[i] = new XRLDeadXBox();

                    if(i < StressParams.NONMULTIPLAYERDEADXBOX)// non multi player title ID
                    {
                        dxreqs[i].dwTitleID = 4019;
                    }
                    else if (i < (StressParams.NONMULTIPLAYERDEADXBOX + StressParams.NONHOSTVALIDTITLEDEADXBOX))// nonHost valid title id
                    {
                        dxreqs[i].dwTitleID = titleID;
                    }
                    else	// 
                    {
                        try
                        {
                            hostInfo = (SessIDAndSgAddr)sessQ.Dequeue();
                            //make sure we have enough sessions around
                            if (!STFMatchCounters.DeleteAllowed(hostInfo.ranked)) {
                                sessQ.Enqueue(hostInfo);
                                SkipTest("Delete disallowed.");
                            }
                            STFMatchCounters.RemoveFromSessionCount(hostInfo);
                        }
                        catch(InvalidOperationException) // Q is empty
                        {
                            continue;
                        }
                        if(hostInfo.ranked)
                            numRankedSession++;
                        else
                            numSocialSession++;

                        //dxreqs[i].sgaddr.abReserved = new byte[4]{0,0,0,0};
                        dxreqs[i].sgaddr.dwSpiSg = hostInfo.SgAddr.dwSpiSg;
                        dxreqs[i].sgaddr.qwXboxID = hostInfo.SgAddr.qwXboxID;
                        Array.Copy(hostInfo.SgAddr.inaSg,dxreqs[i].sgaddr.inaSg,4);
                        dxreqs[i].dwTitleID = titleID;
                    }
                }
                else	// this is title change request and it is for xbox360 only
                {
                    tcReqs[i] = new XRLTitleChange();
                    if(i < StressParams.NONMULTIPLAYERDEADXBOX)// non multi player title ID
                    {
                        tcReqs[i].dwOldTitleID = 4019;
                    }
                    else if (i < (StressParams.NONMULTIPLAYERDEADXBOX + StressParams.NONHOSTVALIDTITLEDEADXBOX))// nonHost valid title id
                    {
                        tcReqs[i].dwOldTitleID = titleID;
                    }
                    else	// 
                    {
                        try
                        {
                            hostInfo = (SessIDAndSgAddr)sessQ.Dequeue();
                            //make sure we have enough sessions around
                            if (!STFMatchCounters.DeleteAllowed(hostInfo.ranked)) {
                                sessQ.Enqueue(hostInfo);
                                SkipTest("Delete disallowed.");
                            }
                            STFMatchCounters.RemoveFromSessionCount(hostInfo);
                        }
                        catch(InvalidOperationException) // Q is empty
                        {
                            continue;
                        }
                        if(hostInfo.ranked)
                            numRankedSession++;
                        else
                            numSocialSession++;
                        tcReqs[i].dwOldTitleID = titleID;
                        //tcReqs[i].sgaddr.abReserved = new byte[4]{0,0,0,0};
                        tcReqs[i].sgaddr.dwSpiSg = hostInfo.SgAddr.dwSpiSg;
                        tcReqs[i].sgaddr.qwXboxID = hostInfo.SgAddr.qwXboxID;
                        Array.Copy(hostInfo.SgAddr.inaSg,tcReqs[i].sgaddr.inaSg,4);	
                    }
                }
            }
            MemoryStream        reqStream = new MemoryStream();
            BinaryWriter        bw = new BinaryWriter(reqStream);
            if(titleChange == false)
            {
                for(int i = 0; i < dxreqs.Length; i++)
                {
                    bw.Write(dxreqs[i].wType);
                    bw.Write(dxreqs[i].cbEnt);
                    bw.Write(dxreqs[i].sgaddr.inaSg);
                    bw.Write(dxreqs[i].sgaddr.dwSpiSg);
                    bw.Write(dxreqs[i].sgaddr.qwXboxID);
                    bw.Write(dxreqs[i].sgaddr.abReserved);
                    bw.Write(dxreqs[i].dwTitleID);
                }
            }
            else	// this is a title change request
            {
                for(int i = 0; i < tcReqs.Length; i++)
                {
                    bw.Write(tcReqs[i].wType);
                    bw.Write(tcReqs[i].cbEnt);
                    bw.Write(tcReqs[i].sgaddr.inaSg);
                    bw.Write(tcReqs[i].sgaddr.dwSpiSg);
                    bw.Write(tcReqs[i].sgaddr.qwXboxID);
                    bw.Write(tcReqs[i].sgaddr.abReserved);
                    bw.Write(tcReqs[i].dwOldTitleID);
                    bw.Write(tcReqs[i].dwNewTitleID);
                }
            }
            byte[] httpHeader = GenerateHttpHeader(reqStream.Length, titleChange);
            CSGInfo slot = new CSGInfo();	// slot info doesn't matter here
            if (fdTrans.ExecuteTCP(httpHeader, reqStream, ref slot, true) == false)
            {
                FailTest("StressDeadXboxTitleChange failed", fdTrans.XErr);
            }
        }

        /// <summary>
        /// This is for batched deadxbox and titleChange requests
        /// </summary>	
        public byte[] GenerateHttpHeader(long contentLen, bool titleChange)
        {
            byte[] header;
            StringBuilder sbURL = new StringBuilder();
            sbURL.Append("POST ");
            if (titleChange)
                sbURL.Append("/xmatch/titlechange.ashx");
            else
                sbURL.Append("/xmatch/deadxbox.ashx");
            sbURL.Append(" HTTP/1.1\r\n");
            sbURL.Append("Host: " + Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd).ToString() + "\r\n");
            sbURL.Append("Content-Type: xon/" + ((int)XOService.Matchmaking).ToString("x") + "\r\n");
            sbURL.Append("User-Agent: " + ((int)XOService.Matchmaking).ToString("x") + "/1.0.5849\r\n");
            sbURL.Append("Content-Length: " + contentLen + "\r\n\r\n");

            header = new System.Text.ASCIIEncoding().GetBytes(sbURL.ToString());
            return header;
        }
    }

    public class Stress2DeadXBox : StressDeadXBoxTitleChangeBase
    {
        public override void Run()
        {
            Run(false);
        }
    }

    public class Stress2TitleChange : StressDeadXBoxTitleChangeBase
    {
        public override void Run()
        {
            Run(true);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XMatchTest\PartitioningTests.cs ===
using System;
using System.Threading;
using System.Collections;
using System.Data.SqlClient;
using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.LiveService.Matchmaking;
using xonline.common.config;

namespace XMatchTest
{

    //This will run tests on the various basic functions that can be performed.  No breadcrumbs are
    //involved here--this is just to ensure existing functions work on partitioned data.
    //Specifically, create, update, search and delete, which are all exercised in these tests.
    [TestGroup]
    [CompoundCase("Ranked_FirstPartition", Constants.X_ATTRIBUTE_GAME_TYPE_RANKED, Constants.CONTEXT_GAME_MODE_MODEA)]
    [CompoundCase("Ranked_SecondPartition", Constants.X_ATTRIBUTE_GAME_TYPE_RANKED, Constants.CONTEXT_GAME_MODE_MODEB)]
    [CompoundCase("Standard_FirstPartition", Constants.X_ATTRIBUTE_GAME_TYPE_STANDARD, Constants.CONTEXT_GAME_MODE_MODEA)]
    [CompoundCase("Standard_SecondPartition", Constants.X_ATTRIBUTE_GAME_TYPE_STANDARD, Constants.CONTEXT_GAME_MODE_MODEB)]
    public class PartitioningNormal : TestNode
    {
        //Create a normal session
        [TestCase, Description("Create a session on each of the servers in a partition, by giving it different modes." +
                               "Verify the session in question is on the server.")]
        class P_Create : TestBase {
            protected override void Execute() {
                bool success = true;
                MatchSession testSession = MatchPartUtil.CreateGenericSession("PartitionCreate R:" + Parent.MyValues[0] + "M:" + Parent.MyValues[1],
                                                                              (long) Parent.MyValues[0], (long) Parent.MyValues[1]);
                success = success && MatchPartUtil.PositiveVerify(testSession);
                Global.RO.Info("Deleting session " + testSession.GetSessionID());
                testSession.Delete();
                success = success && MatchPartUtil.NegativeVerify(testSession);
                if (success) ResultCode=TEST_RESULTS.PASSED;
            }
        }

        [TestCase, Description("Create a session on each of the servers in a partition, by giving it different modes." +
                               "Update the session with a non-mode attribute.  Verify the session in question is on the server.")]
        class P_Update : TestBase {
            protected override void Execute() {
                bool success = true;
                const int MAGIC_NUMBER = 42;
                MatchSession testSession = MatchPartUtil.CreateGenericSession("PartitionCreate R:" + Parent.MyValues[0] + "M:" + Parent.MyValues[1],
                                                                              (long) Parent.MyValues[0], (long) Parent.MyValues[1]);
                success = success && MatchPartUtil.PositiveVerify(testSession);

                //Fill one of our custom attribs with a magic number, which is verified in the query.
                testSession.AddAttrib(new XRLXeAttribParam(Constants.CONTEXT_MYCONTEXT1,  
                                                              new XRLXeIntValue(MAGIC_NUMBER)));
                success = success && MatchPartUtil.PositiveVerify(testSession);
                Global.RO.Info("Deleting session " + testSession.GetSessionID());
                testSession.Delete();
                success = success && MatchPartUtil.NegativeVerify(testSession);
                if (success) ResultCode=TEST_RESULTS.PASSED;
            }
        }
        [TestCase, Description("Create a session on each of the servers in a partition, by giving it different modes." +
                               "Set the delete to immediate, and ensure the session is removed from both servers."), Ignore]
        public class P_Delete : TestBase {
            protected override void Execute() {
                bool success = true;
                MatchSession testSession = MatchPartUtil.CreateGenericSession("PartitionDelete", 
                                                                                   (long) Parent.MyValues[0], (long) Parent.MyValues[1]);
                success = success && MatchPartUtil.PositiveVerify(testSession);

                //save the title
                MatchTitle titleInfo = MatchTitleMgr.SnapshotMatchTitle(testSession.TitleID);
                //set the title delete to occur immediately
                titleInfo.DeleteDelaySeconds = 0;
                MatchTitleMgr.UpdateMatchTitle(titleInfo);
                //reload title
                MatchFDs.ReloadTitleInfo();

                Global.RO.Info("Deleting session " + testSession.GetSessionID());
                testSession.Delete();
                success = success && MatchPartUtil.NegativeVerify(testSession);
                success = success && MatchUtil.VerifySessionNotInDB(testSession);
                
                if (success) ResultCode=TEST_RESULTS.PASSED;
                //restore the title before we finish
                MatchTitleMgr.RestoreMatchTitleFromSnapshot(testSession.TitleID);
                MatchFDs.ReloadTitleInfo();
            }
        }


    }

    //This is where the meat of partitioning testing is, dealing with generated breadcrumbs.  We run
    //on the combinations of ranked/standard and first partition/second partition.
    [CompoundCase("Ranked_StartOnFirstPartition", Constants.X_ATTRIBUTE_GAME_TYPE_RANKED, 
                  Constants.CONTEXT_GAME_MODE_MODEA, Constants.CONTEXT_GAME_MODE_MODEB)]
    [CompoundCase("Ranked_StartOnSecondPartition", Constants.X_ATTRIBUTE_GAME_TYPE_RANKED,
                  Constants.CONTEXT_GAME_MODE_MODEB, Constants.CONTEXT_GAME_MODE_MODEA)]
    [CompoundCase("Standard_StartOnFirstPartition", Constants.X_ATTRIBUTE_GAME_TYPE_STANDARD,
                  Constants.CONTEXT_GAME_MODE_MODEA, Constants.CONTEXT_GAME_MODE_MODEB)]
    [CompoundCase("Standard_StartOnSecondPartition", Constants.X_ATTRIBUTE_GAME_TYPE_STANDARD,
                  Constants.CONTEXT_GAME_MODE_MODEB, Constants.CONTEXT_GAME_MODE_MODEA)]
    [TestGroup]
    public class PartitioningBreadCrumbs_Positive : TestNode
    {

        [TestCase, Description("Create a breadcrumbed session on each of the servers in a partition, by giving it different modes." +
                               "Verify the session in question is on the server.")]
        public class P_Create : TestBase {
            protected override void Execute() {
                bool success = true;
                MatchSession testSession = MatchPartUtil.CreateBreadcrumbedSession("PartitionBreadcrumbCreate", 
                                                                                   (long) Parent.MyValues[0], (long) Parent.MyValues[1], 
                                                                                   (long) Parent.MyValues[2]);
                success = success && MatchPartUtil.PositiveVerify(testSession);
                Global.RO.Info("Deleting session " + testSession.GetSessionID());
                testSession.Delete();
                success = success && MatchPartUtil.NegativeVerify(testSession);
                if (success) ResultCode=TEST_RESULTS.PASSED;
            }
        }


        [TestCase, Description("Update a breadcrumbed session on each of the servers in a partition, by giving it a different " + 
                               "magic number.  Verify the session in question is on the server and is updated."  +
                               "also verify that the update occurs on both places.")]
        public class P_Update : TestBase {
            protected override void Execute() {
                bool success = true;
                const int MAGIC_NUMBER = 43;
                MatchSession testSession = MatchPartUtil.CreateBreadcrumbedSession("PartitionBreadcrumbUpdate", 
                                                                                   (long) Parent.MyValues[0], (long) Parent.MyValues[1], 
                                                                                   (long) Parent.MyValues[2]);
                success = success && MatchPartUtil.PositiveVerify(testSession);
                //Fill one of our custom attribs with a magic number, which is verified in the
                //query.  This isn't in the defaults, so we add it.
                testSession.AddAttrib(new XRLXeAttribParam(Constants.CONTEXT_MYCONTEXT1,  
                                                              new XRLXeIntValue(MAGIC_NUMBER)));
                //let's also modify the joins.  This is verified in the find-by-id search.
                testSession.Join(1,0);
                success = success && MatchPartUtil.PositiveVerify(testSession);
                Global.RO.Info("Deleting session " + testSession.GetSessionID());
                testSession.Delete();
                success = success && MatchPartUtil.NegativeVerify(testSession);
                if (success) ResultCode=TEST_RESULTS.PASSED;
            }
        }

        //this may not need to be run on every type.
        [TestCase, Description("Empty the servers, and then create a breadcrumbed session.  Ensure that a find-by-query on the " +
                               "breadcrumb returns no sessions.  In a way this should be already taken care of, because" +
                               "it would be a different mode, and therefore could never match anyways.")]
        public class P_Search_Ignores_Breadcrumbs : TestBase {

            protected override void Execute() {
                //delete server.  Use match session mgr?
                //query beforehand on this server, to make sure we don't see any.
                XRL2SearchSession searchReq = new XRL2SearchSession(true, Constants.SESSION_MATCH_QUERY_QUERY1);
                searchReq.UpdateAttrib(new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_TYPE,
                                                            new XRLXeIntValue((long) Parent.MyValues[0])));
                searchReq.UpdateAttrib(new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE,
                                                            new XRLXeIntValue((long) Parent.MyValues[1])));
                searchReq.baseSearchSession.dwTitleID = MatchPartUtil.DEFAULT_TITLEID;
                XRL2SearchResults searchResp = MatchUtil.CustomSearch(searchReq);
                if (searchResp != null) {
                    Global.RO.Warn("Error!  Found a session before starting the test.  Test will almost certainly fail!");
                }
                MatchSession testSession = MatchPartUtil.CreateBreadcrumbedSession("PartitionBreadcrumbShouldBeIgnored", 
                                                                                   (long) Parent.MyValues[0], (long) Parent.MyValues[1], 
                                                                                   (long) Parent.MyValues[2]);
//                searchReq = testSession.CreateSearchSession(Constants.SESSION_MATCH_QUERY_QUERY1);
                //search the old mode
                searchResp = MatchUtil.CustomSearch(searchReq);
                try {
                    if (searchResp != null) {
                        throw new Exception("Error!  Found a session when searching by query.  This table should be empty save the breadcrumb!");
                    } else {
                        ResultCode=TEST_RESULTS.PASSED;                    
                    }
                } finally {
                    testSession.Delete();
                }
            }
        }

        [TestCase, Description("Create a breadcrumbed session and split it.  Verify a new session is created, and that it does not" +
                               " have a breadcrumb.  Verify the original breadcrumb and session are still present.")]
        public class P_SplitBreadcrumbs : TestBase {

            protected override void Execute() {
                MatchSession testSession = 
                    MatchPartUtil.CreateBreadcrumbedSession("PartitionSplit R:" + Parent.MyValues[0] + "M:" + Parent.MyValues[1],
                                                            (long) Parent.MyValues[0], (long) Parent.MyValues[1], (long) Parent.MyValues[2]);
                //leave a marker on the original session.
                testSession.AddAttrib(new XRLXeAttribParam(Constants.PROPERTY_MYFLOAT64PROP1,
                                                               new XRLXeDoubleValue(7357.53551017)));

                bool success = MatchPartUtil.PositiveVerify(testSession);
                MatchSession splittedSession = testSession.Split(true);  //split this session
                //make the splitted session unique for queries.
                splittedSession.UpdateAttrib(new XRLXeAttribParam(Constants.PROPERTY_MYFLOAT64PROP1,
                                                               new XRLXeDoubleValue(58117.53551017)));
                Global.RO.Info("Verifying original session");
                if (MatchPartUtil.PositiveVerify(testSession)) {
                    Global.RO.Success("Original session verifies");
                } else {
                    Global.RO.Error("Original session does not verify!");
                    success = false;
                }
                Global.RO.Info("Verifying splitted session");
                if (MatchPartUtil.PositiveVerify(splittedSession)) {
                    Global.RO.Success("Splitted session verifies");
                } else {
                    Global.RO.Error("Splitted session does not verify!");
                    success = false;
                }
                //ensure we don't get a breadcrumb in the splitted session.  Do this by searching
                //for a session on the original session's breadcrumb server.  Also make sure the
                //splitted session isn't intentionally a breadcrumb.  We can't perform this check if
                //they're supposed to all be on the same DB though.
                string origServer = MatchUtil.FindServerForSession(testSession, true);
                string newServer = MatchUtil.FindServerForSession(splittedSession, true);
                if (origServer != newServer) {
                    if (MatchUtil.QueryDBForSessionData(origServer, splittedSession) != null) {
                        Global.RO.Error("The split session has a breadcrumb or session on " + 
                                        origServer + " with ID " + splittedSession.GetSessionID());
                        success = false;
                    }
                }
                if (splittedSession.IsBreadcrumbed()) {
                    Global.RO.Error("The split session is breacrumbed!");
                    success = false;
                }

//                Global.RO.Info(dbData.ToString());
                testSession.Delete();
                splittedSession.Delete();
                if (success) ResultCode=TEST_RESULTS.PASSED;
            }
        }

        [TestCase, Description("Create a breadcrumbed session on each of the servers in a partition, by giving it different modes." +
                               "Set the delete to immediate, and ensure the session is removed from both servers.  Repeat for a delay" +
                               " that is 300, and ensure it *is* on the DB, but not findable.  Also verify the delayed_date is not 0.")]
        [CompoundCase("Delay_0", 0)]
        [CompoundCase("Delay_300", 300)]
        public class P_Delete : TestBase {
            protected override void Execute() {
                bool success = true;
                MatchSession testSession = MatchPartUtil.CreateBreadcrumbedSession("PartitionBreadcrumbDelete", 
                                                                                   (long) Parent.Parent.MyValues[0], (long) Parent.Parent.MyValues[1], 
                                                                                   (long) Parent.Parent.MyValues[2]);
                success = success && MatchPartUtil.PositiveVerify(testSession);

                //save the title
                MatchTitle titleInfo = MatchTitleMgr.SnapshotMatchTitle(testSession.TitleID);
                //set the title delete to occur according to the delay in the values array.
                titleInfo.DeleteDelaySeconds = (int) MyValues[0];
                MatchTitleMgr.UpdateMatchTitle(titleInfo);
                //reload title
                MatchFDs.ReloadTitleInfo();

                Global.RO.Info("Deleting session " + testSession.GetSessionID());
                testSession.Delete();
                success = success && MatchPartUtil.NegativeVerify(testSession);
                if (titleInfo.DeleteDelaySeconds == 0) {
                    success = success && MatchUtil.VerifySessionNotInDB(testSession);
                }
                
                if (success) ResultCode=TEST_RESULTS.PASSED;
                //restore the title before we finish
                MatchTitleMgr.RestoreMatchTitleFromSnapshot(testSession.TitleID);
                MatchFDs.ReloadTitleInfo();
            }
        }


        [TestCase, Description("Create a breadcrumbed session on each of the servers in a partition, by giving it different modes." +
                               "DeadXbox the session, and ensure they no longer show up in either search by ID or by query.")]
        public class P_DeadXbox : TestBase {
            protected override void Execute() {
                bool success = true;
                MatchSession testSession = MatchPartUtil.CreateBreadcrumbedSession("PartitionBreadcrumbDeadXbox", 
                                                                                   (long) Parent.MyValues[0], (long) Parent.MyValues[1], 
                                                                                   (long) Parent.MyValues[2]);
                success = success && MatchPartUtil.PositiveVerify(testSession);

                Global.RO.Info("DeadXboxing session " + testSession.GetSessionID());
                testSession.DeadXbox();
                success = success && MatchPartUtil.NegativeVerify(testSession);
                
                if (success) ResultCode=TEST_RESULTS.PASSED;
            }
        }


        [TestCase, Description("Create a breadcrumbed session on each of the servers in a partition, by giving it different modes." +
                               "Set the expiration to be really, really soon.  Wait for that expiration date to pass, and trigger" +
                               " a cleanup script that causes those sessions to be cleaned.")]
        public class P_Expiration : TestBase {

            private static void RunExpirationJob(string serverName) {
                XMatch xmatch = new XMatch();
                xmatch.ConnectToServer(serverName);
                string sql = "use msdb exec sp_start_job 'XMatch_j_remove_expired_sessions'";
                xmatch.IssueCommand(sql);
                xmatch.Close();
            }
            protected override void Execute() {
                bool success = true;

                //prep the DB by setting the expiration time
                //save the title
                MatchTitle titleInfo = MatchTitleMgr.SnapshotMatchTitle(MatchPartUtil.DEFAULT_TITLEID);
                titleInfo.SessionExpiration = 1; //have sessions expire in one second.  Defaults to
                                                 //86400, or 24 hours.
                MatchTitleMgr.UpdateMatchTitle(titleInfo);

                try {  //title is not in a bad state, so ensure we can clean up with a big try
                    //reload title
                    MatchFDs.ReloadTitleInfo();

                    //create a session which has this expiration time
                    MatchSession testSession = MatchPartUtil.CreateBreadcrumbedSession("PartitionBreadcrumbExpiration", 
                                                                                       (long) Parent.MyValues[0], (long) Parent.MyValues[1], 
                                                                                       (long) Parent.MyValues[2]);
                    //not using PositiveVerify because we mucked with the expiration date.
                    success = success && MatchUtil.VerifyServerAndPartitionInfo(testSession);

                    //kick off the job
                    string origServer = MatchUtil.FindServerForSession(testSession, true);
                    string newServer = MatchUtil.FindServerForSession(testSession, false);

                    Global.RO.Info("Waiting for session to expire");
                    System.Threading.Thread.Sleep(1000);

                    RunExpirationJob(origServer);
                    if (origServer != newServer) RunExpirationJob(newServer);

                    Global.RO.Info("Waiting for job to complete");
                    System.Threading.Thread.Sleep(1000);  //wait a moment for the job to run
                
                    success = success && MatchPartUtil.NegativeVerify(testSession);
                    success = success && MatchUtil.VerifySessionNotInDB(testSession);

                    if (success) {
                        testSession.SkipCleanup();
                        ResultCode=TEST_RESULTS.PASSED;
                    }
                } finally {
                    //restore the title before we finish
                    MatchTitleMgr.RestoreMatchTitleFromSnapshot(MatchPartUtil.DEFAULT_TITLEID);
                    MatchFDs.ReloadTitleInfo();
                }
            }
        }

        [TestCase, Description("Create a generic session on each of the servers in a partition, set the expiration date, and then" +
                               "create a breadcrumb.  Wait for that expiration date to pass, and trigger" +
                               " a cleanup script that causes those sessions to be cleaned.")]
        public class P_Expiration_During_Breadcrumbing : TestBase {

            private static void RunExpirationJob(string serverName) {
                XMatch xmatch = new XMatch();
                xmatch.ConnectToServer(serverName);
                string sql = "use msdb exec sp_start_job 'XMatch_j_remove_expired_sessions'";
                xmatch.IssueCommand(sql);
                xmatch.Close();
            }
            protected override void Execute() {
                bool success = true;

                //create a session which has this expiration time
                MatchSession testSession = MatchPartUtil.CreateGenericSession("PartitionBreadcrumbExpiration_During", 
                                                                              (long) Parent.MyValues[0], (long) Parent.MyValues[1]);
                    
                //prep the DB by setting the expiration time
                //save the title
                MatchTitle titleInfo = MatchTitleMgr.SnapshotMatchTitle(MatchPartUtil.DEFAULT_TITLEID);
                titleInfo.SessionExpiration = 1; //have sessions expire in one second.  Defaults to
                                                 //86400, or 24 hours.
                MatchTitleMgr.UpdateMatchTitle(titleInfo);

                try {  //title is not in a bad state, so ensure we can clean up with a big try
                    //reload title
                    MatchFDs.ReloadTitleInfo();
                    testSession.UpdateAttrib(new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE,
                                                                  new XRLXeIntValue((long) Parent.MyValues[2])));

                    //not using PositiveVerify because we mucked with the expiration date.
                    success = success && MatchUtil.VerifyServerAndPartitionInfo(testSession);

                    //kick off the job
                    string origServer = MatchUtil.FindServerForSession(testSession, true);
                    string newServer = MatchUtil.FindServerForSession(testSession, false);

                    Global.RO.Info("Waiting for session to expire");
                    System.Threading.Thread.Sleep(1000);

                    RunExpirationJob(origServer);
                    if (origServer != newServer) RunExpirationJob(newServer);

                    Global.RO.Info("Waiting for job to complete");
                    System.Threading.Thread.Sleep(1000);  //wait a moment for the job to run
                
                    success = success && MatchPartUtil.NegativeVerify(testSession);
                    success = success && MatchUtil.VerifySessionNotInDB(testSession);
                
                    if (success) ResultCode=TEST_RESULTS.PASSED;
                } finally {
                    //restore the title before we finish
                    MatchTitleMgr.RestoreMatchTitleFromSnapshot(MatchPartUtil.DEFAULT_TITLEID);
                    MatchFDs.ReloadTitleInfo();
                }
            }
        }
    }

    //tests that don't really need to be run on starting on first and second partitions.
    [TestGroup]
    public class PartitioningBreadCrumbs_SingleTests : TestNode {
        [TestCase, Description("breadcrumb a session, but place it on the same server(i.e. a session of mode 3.  After a" + 
                               "delete, try to split off that session.")]
        public class P_DeleteMode3AndSplit : TestBase {
            protected override void Execute() {
                bool success = true;
                //Start by setting delay to 300

                //save the title
                MatchTitle titleInfo = MatchTitleMgr.SnapshotMatchTitle(Constants.XENON_TITLE);
                //set the title delete to occur immediately
                titleInfo.DeleteDelaySeconds = 300;
                MatchTitleMgr.UpdateMatchTitle(titleInfo);
                //reload title
                MatchFDs.ReloadTitleInfo();

                //Use XENON_TITLE, which has modes 0,1,2 on the same server.
                MatchSession testSession = MatchPartUtil.CreateGenericSession("P_DeleteMode3AndSplit", 
                                                                              Constants.X_ATTRIBUTE_GAME_TYPE_RANKED, 
                                                                              Constants.CONTEXT_GAME_MODE_MODEA,
                                                                              Constants.XENON_TITLE);
                //update to mode b.  We should get a mode 3 session.
                testSession.UpdateAttrib(new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE,
                                                              new XRLXeIntValue(Constants.CONTEXT_GAME_MODE_MODEB)));
                success = success && MatchPartUtil.PositiveVerify(testSession);
                testSession.Delete();
                success = success && MatchPartUtil.NegativeVerify(testSession);
                //now split
                MatchSession newSession = testSession.Split(true);
                success = success && MatchPartUtil.PositiveVerify(newSession);            
                if (success) ResultCode=TEST_RESULTS.PASSED;            

                //restore the title before we finish
                MatchTitleMgr.RestoreMatchTitleFromSnapshot(testSession.TitleID);
                MatchFDs.ReloadTitleInfo();
            }
        }
    }


    [CompoundCase("Ranked_StartOnFirstPartition", Constants.X_ATTRIBUTE_GAME_TYPE_RANKED, 
                  Constants.CONTEXT_GAME_MODE_MODEA, Constants.CONTEXT_GAME_MODE_MODEB)]
    [CompoundCase("Ranked_StartOnSecondPartition", Constants.X_ATTRIBUTE_GAME_TYPE_RANKED,
                  Constants.CONTEXT_GAME_MODE_MODEB, Constants.CONTEXT_GAME_MODE_MODEA)]
    [CompoundCase("Standard_StartOnFirstPartition", Constants.X_ATTRIBUTE_GAME_TYPE_STANDARD,
                  Constants.CONTEXT_GAME_MODE_MODEA, Constants.CONTEXT_GAME_MODE_MODEB)]
    [CompoundCase("Standard_StartOnSecondPartition", Constants.X_ATTRIBUTE_GAME_TYPE_STANDARD,
                  Constants.CONTEXT_GAME_MODE_MODEB, Constants.CONTEXT_GAME_MODE_MODEA)]
    [TestGroup]
    public class PartitioningBreadCrumbs_Negative : TestNode {

        ///Negative test cases

        //This is a lot less likely to happen, because as it turns out there's a foreign key
        //constraint on the server.  Ignored for now.
        [TestCase, Description("Create a breadcrumbed session on each of the servers in a partition, by giving it different modes." +
                               "Point the appropriate bucket to a nonexistant server.  Verify queries fail but " +
                               "do not crash the server.  Reset this server afterwards."), Ignore]
        public class N_Bad_Server : TestBase {
            private void SetInterfaceBucketServer(string environment, uint titleId, int bucketId, string newServerName) {
                Npdb npdbHandle = new Npdb();
                npdbHandle.ConnectToServer();
                string sql = "update t_interface_buckets set vc_server = '" + newServerName + "'" +
                    " where vc_environment = '" + environment + "' " +
                    " and vc_interface = 'xmatch'" +
                    " and i_title_id = 0x" + titleId.ToString("X") +
                    " and i_bucket = " + bucketId;
                npdbHandle.IssueCommand(sql);
                npdbHandle.Close();
            }

            protected override void Execute() {
                bool success = true;
                MatchSession testSession = MatchPartUtil.CreateBreadcrumbedSession("PartitionBadServer", 
                                                                                   (long) Parent.MyValues[0], (long) Parent.MyValues[1], 
                                                                                   (long) Parent.MyValues[2]);                
                InterfaceBucket breadcrumbBucket = MatchUtil.FindInterfaceBucketForSession(testSession, true);
                InterfaceBucket sandwichBucket = MatchUtil.FindInterfaceBucketForSession(testSession, false);
                //mess up the buckets.  For now let's just run it straight through NPDB.  We'll
                //point it to a client machine, as it has to satisfy a foreign key constraint.
                SetInterfaceBucketServer(breadcrumbBucket.Environment, breadcrumbBucket.TitleId, 
                                         breadcrumbBucket.Bucket, "xeclisxxx010");
                SetInterfaceBucketServer(sandwichBucket.Environment, sandwichBucket.TitleId, 
                                         sandwichBucket.Bucket, "xeclisxxx010");
                MatchFDs.ReloadTitleInfo();

                //now that they're messed up, let's try searches.
                try {
                    MatchUtil.VerifySearchByID(testSession);
                    Global.RO.Error("No exception found when searching by ID!");
                    success = false;
                } catch (Exception) {
                    Global.RO.Success("Exception occurred as expected when searching by ID");
                }
                try {
                    MatchUtil.VerifySearchByQuery(testSession);
                    Global.RO.Error("No exception found when searching by Query!");
                    success = false;
                } catch (Exception) {
                    Global.RO.Success("Exception occurred as expected when searching by Query");
                }
                //TODO:Repeat for updates and deletes.

                if (success) ResultCode=TEST_RESULTS.PASSED;
                //reset everything to good states.
                SetInterfaceBucketServer(breadcrumbBucket.Environment, breadcrumbBucket.TitleId, 
                                         breadcrumbBucket.Bucket, breadcrumbBucket.Server);
                SetInterfaceBucketServer(sandwichBucket.Environment, sandwichBucket.TitleId, 
                                         sandwichBucket.Bucket, sandwichBucket.Server);
                MatchFDs.ReloadTitleInfo();
            }
        }
        [TestCase, Description("Create a breadcrumbed session on each of the servers in a partition, by giving it different modes." +
                               "Delete the bucket that this server would use.  Verify queries fail but " +
                               "do not crash the server.  Reset this server afterwards.")]
        public class N_Missing_Bucket : TestBase {

            private void InsertInterfaceBucketServer(InterfaceBucket bucket) {
                Npdb npdbHandle = new Npdb();
                npdbHandle.ConnectToServer();
                string sql = "if not exists( select * from t_interface_buckets" +
                    " where vc_environment = '" + bucket.Environment + "' " +
                    " and vc_interface = 'xmatch'" +
                    " and i_title_id = 0x" + bucket.TitleId.ToString("X") +
                    " and i_bucket = " + bucket.Bucket + ")" +
                    " BEGIN " +
                    " insert into t_interface_buckets (vc_environment, vc_interface, i_title_id, i_bucket, vc_server, vc_next_server," +
                    " dt_migration_start, vc_info1, vc_info2, vc_info3, vc_info4)" +
                    " values ('" + bucket.Environment + "', 'xmatch', 0x" + bucket.TitleId.ToString("X") +", " + bucket.Bucket + 
                    ", '" + bucket.Server + "', '" + bucket.NextServer + "', '1900-01-01 12:00:00.000', '', '', '', '' )" + 
                    " END ";
//                Global.RO.Info(sql);
                npdbHandle.IssueCommand(sql);
                npdbHandle.Close();
            }

            private void DeleteInterfaceBucketServer(string environment, uint titleId, int bucketId) {
                Npdb npdbHandle = new Npdb();
                npdbHandle.ConnectToServer();
                string sql = "delete from t_interface_buckets" +
                    " where vc_environment = '" + environment + "' " +
                    " and vc_interface = 'xmatch'" +
                    " and i_title_id = 0x" + titleId.ToString("X") +
                    " and i_bucket = " + bucketId;
                npdbHandle.IssueCommand(sql);
                npdbHandle.Close();
            }

            protected override void Execute() {
                bool success = true;
                MatchSession testSession = MatchPartUtil.CreateBreadcrumbedSession("PartitionMissingServer", 
                                                                                   (long) Parent.MyValues[0], (long) Parent.MyValues[1], 
                                                                                   (long) Parent.MyValues[2]);                
                InterfaceBucket breadcrumbBucket = MatchUtil.FindInterfaceBucketForSession(testSession, true);
                InterfaceBucket sandwichBucket = MatchUtil.FindInterfaceBucketForSession(testSession, false);
                //Toast the buckets.  This could be really, really bad for future tests.  Ensure
                //that we will always reinsert via a big try.
                try {
                    DeleteInterfaceBucketServer(breadcrumbBucket.Environment, breadcrumbBucket.TitleId, 
                                                breadcrumbBucket.Bucket);
                    DeleteInterfaceBucketServer(sandwichBucket.Environment, sandwichBucket.TitleId, 
                                                sandwichBucket.Bucket);
                    MatchFDs.ReloadTitleInfo();

                    //now that they're messed up, let's try searches.
                    try {
                        MatchUtil.VerifySearchByID(testSession);
                        Global.RO.Error("No exception found when searching by ID!");
                        success = false;
                    } catch (Exception) {
                        Global.RO.Success("Exception occurred as expected when searching by ID");
                    }
                    try {
                        MatchUtil.VerifySearchByQuery(testSession);
                        Global.RO.Error("No exception found when searching by Query!");
                        success = false;
                    } catch (Exception) {
                        Global.RO.Success("Exception occurred as expected when searching by Query");
                    }
                    //TODO:Repeat for updates and deletes.

                    if (success) ResultCode=TEST_RESULTS.PASSED;
                } finally {
                    //reset everything to good states.
                    InsertInterfaceBucketServer(breadcrumbBucket);
                    InsertInterfaceBucketServer(sandwichBucket);
                    MatchFDs.ReloadTitleInfo();
                }
            }
        }


        [TestCase, Description("Set an update sproc so that it returns an error. Attempt to update a sproc so it creates a breadcrumb."+
                               "Verify the error is returned. Verify no breadcrumb or sandwich is created.")]
        public class N_Bad_Update : TestBase {
            protected override void Execute() {
                bool success = true;
                //let's store the server names we're going to use
                MatchSession dummySession =MatchPartUtil.CreateBreadcrumbedSession("SessionToGetDBNames", 
                                                                                   (long) Parent.MyValues[0], (long) Parent.MyValues[1], 
                                                                                   (long) Parent.MyValues[2]);                
                string firstServer = MatchUtil.FindServerForSession(dummySession, true);
                string secondServer = MatchUtil.FindServerForSession(dummySession, false);
                dummySession.Delete();  //clean up immediately

                //now the real test.
                MatchSession testSession = MatchPartUtil.CreateGenericSession("BadUpdateSession", 
                                                                              (long) Parent.MyValues[0], (long) Parent.MyValues[1]);
                //set the update
                XmatchSprocSet updateSproc = new XmatchSprocSet("p_match_session_v2_0x" + MatchPartUtil.DEFAULT_TITLEID.ToString("X") + 
                                                                "_update", firstServer, secondServer);
                updateSproc.SetSprocToTimeout();
                try {
                    //result--the update should have failed.
                    Global.RO.Info("If update-related errors should follow, these are expected.");
                    if (testSession.UpdateAttrib(new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE,
                                                                      new XRLXeIntValue((long) Parent.MyValues[2])))) {
                        Global.RO.Error("The update returns no error!");
                        success = false;
                    } else {
                        Global.RO.Success("Update failed, as expected.");
                    }
                    //check DB--we should have a session on the first server(original), but not on the
                    //second.  Update should have straight-up failed.
                    Global.RO.Info("Checking data on original server " + firstServer);
                    MatchUtil.SessionDBData firstServerData = MatchUtil.QueryDBForSessionData(firstServer, testSession);
                    if (firstServerData == null) {
                        Global.RO.Error("Original server's data is missing!");
                        success = false;
                    } else {
                        ValueCheck.Test("Original server's breadcrumb status", ((int) MatchUtil.RowState.ORIGINAL_ROW), firstServerData.breadcrumbState);
                    }
                    //can only check for sandwich if servers are different
                    if (firstServer != secondServer) {
                        MatchUtil.SessionDBData secondServerData = MatchUtil.QueryDBForSessionData(secondServer, testSession);
                        if (secondServerData != null) {
                            Global.RO.Error("Found a sandwich session on the second server " + secondServer + "!");
                            success = false;
                        }
                    }

                    if (success) ResultCode=TEST_RESULTS.PASSED;
                } catch (Exception e) {
                    Global.RO.Error("Unexpected exception found!  " + e.ToString());
                } finally {
                    updateSproc.ResetSprocToOriginal();
                    testSession.Delete();  //clean up
                }
            }
        }


        [TestCase, Description("Set an update sproc so that it returns an error. Attempt to update a sproc so it creates a breadcrumb."+
                               "Verify the error is returned. Verify no breadcrumb or sandwich is created.")]
        public class N_Bad_Delete : TestBase {
            protected override void Execute() {
                bool success = true;

                MatchSession testSession = MatchPartUtil.CreateBreadcrumbedSession("BadDeleteSession", 
                                                                                   (long) Parent.MyValues[0], (long) Parent.MyValues[1],
                                                                                   (long) Parent.MyValues[2]);
                string firstServer = MatchUtil.FindServerForSession(testSession, true);
                string secondServer = MatchUtil.FindServerForSession(testSession, false);

                //set the delete
                XmatchSprocSet deleteSproc = new XmatchSprocSet("p_match_session_v2_0x" + MatchPartUtil.DEFAULT_TITLEID.ToString("X") + 
                                                                "_delete", firstServer, secondServer);
                deleteSproc.SetSprocToTimeout();
                try {
                    //result--the delete should have failed.
                    Global.RO.Info("If delete-related errors should follow, these are expected.");
                    if (testSession.Delete(120000)) {
                        Global.RO.Error("The delete returns no exception!");
                        success = false;
                    } else {
                        Global.RO.Success("Delete failed, as expected.");
                    }

                    //TODO!  Should the delete retry itself, and therefore after some time we should
                    //see a deleted session(that we can no longer query for?)
                    if (success) ResultCode=TEST_RESULTS.PASSED;
                } catch (Exception e) {
                    Global.RO.Error("Unexpected exception found!  " + e.ToString());
                } finally {
                    deleteSproc.ResetSprocToOriginal();
                    testSession.Delete();
                }
            }
        }
   
    }

    
    [CompoundCase("Ranked_StartOnFirstPartition", Constants.X_ATTRIBUTE_GAME_TYPE_RANKED, 
                  Constants.CONTEXT_GAME_MODE_MODEA, Constants.CONTEXT_GAME_MODE_MODEB)]
    [CompoundCase("Ranked_StartOnSecondPartition", Constants.X_ATTRIBUTE_GAME_TYPE_RANKED,
                  Constants.CONTEXT_GAME_MODE_MODEB, Constants.CONTEXT_GAME_MODE_MODEA)]
    [CompoundCase("Standard_StartOnFirstPartition", Constants.X_ATTRIBUTE_GAME_TYPE_STANDARD,
                  Constants.CONTEXT_GAME_MODE_MODEA, Constants.CONTEXT_GAME_MODE_MODEB)]
    [CompoundCase("Standard_StartOnSecondPartition", Constants.X_ATTRIBUTE_GAME_TYPE_STANDARD,
                  Constants.CONTEXT_GAME_MODE_MODEB, Constants.CONTEXT_GAME_MODE_MODEA)]
    [TestGroup]
    public class Partitioning_Concurrency_Tests : TestNode {

        //Internal class for encapsulating an async call to update.
        public class AsyncUpdate {
            public const double GOOD_VALUE = 53551017.7357;
            public const double BAD_VALUE = 911;
            public const double STARTING_VALUE = 0;

            public static void RunUpdateOnDoubleProperty(MatchSession session, double value) {
                Global.RO.Info("Beginning update on " + session.GetSessionID() + " to value " +value);
                try {
                    if (!((MatchSession) session).UpdateAttrib(new XRLXeAttribParam(Constants.PROPERTY_MYFLOAT64PROP1,
                                                                                 new XRLXeDoubleValue(value)))) {
                        Global.RO.Warn("Asynchronous session update failed on value " + value + ".  Check event viewer!");
                    } else {
                        Global.RO.Info("Session updated to value " + value);
                    }
                } catch (Exception e) {
                    Global.RO.Error("Update to value " + value + "threw exception!" + e.ToString());
                }

            }
                    
            public static void UpdateToGoodValues(object data) {
                RunUpdateOnDoubleProperty((MatchSession) data, GOOD_VALUE);
            }
            
            public static void UpdateToBadValues(object data) {
                RunUpdateOnDoubleProperty((MatchSession) data, BAD_VALUE);
            }

            public static void RunModeUpdate(MatchSession session, long value) {
                Global.RO.Info("Beginning update on " + session.GetSessionID() + " to mode " + value);
                try {
                    if (!((MatchSession) session).UpdateAttrib(new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE,
                                                                                    new XRLXeIntValue(value)))) {
                        Global.RO.Warn("Asynchronous session update failed on mode " + value + ".  Check event viewer!");
                    } else {
                        Global.RO.Info("Session mode updated to value " + value);
                    }
                } catch (Exception e) {
                    Global.RO.Error("Update to value " + value + "threw exception!" + e.ToString());
                }

            }


            public static void UpdateModeToA(object data) {
                RunModeUpdate((MatchSession) data, Constants.CONTEXT_GAME_MODE_MODEA);
            }

            public static void UpdateModeToB(object data) {
                RunModeUpdate((MatchSession) data, Constants.CONTEXT_GAME_MODE_MODEB);
            }
        }

        enum TestMode {
                FIRST_DELAY,
                BOTH_DELAY
        };
        [TestCase, Description("Run two updates.  In FIRST_DELAY, have the second start and complete while the first is running." +
                               " In the BOTH_DELAY, have the second start while the first is running, but complete after the first" +
                               " is completed.")]
        [CompoundCase("FirstDelay_SecondNormal", TestMode.FIRST_DELAY)]
        [CompoundCase("BothDelay", TestMode.BOTH_DELAY)]
        public class P_Cause_Two_Updates : TestBase {
            private bool CheckForValue(SqlDataReader reader, string prefix) {
                bool success = true;
                reader.Read();
                if (reader.IsDBNull(0)) {
                    Global.RO.Error(prefix + ":Error in query!  Null reported when querying for attribute!");
                    success = false;
                }
                double property = reader.GetDouble(0);
                if (property == AsyncUpdate.GOOD_VALUE) {
                    Global.RO.Success(prefix + ":First update written, as expected");
                } else if (property == AsyncUpdate.BAD_VALUE) {
                    Global.RO.Error(prefix + ":Error!  Second value written!");
                    success = false;
                } else {
                    Global.RO.Error(prefix + ":Unexpected value found(" + property + ")!");
                    success = false;
                }
                return success;
            }

            protected override void Execute() {
                bool success = true;

                MatchSession testSession = MatchPartUtil.CreateBreadcrumbedSession("CauseTwoUpdates", 
                                                                                   (long) Parent.Parent.MyValues[0], (long) Parent.Parent.MyValues[1],
                                                                                   (long) Parent.Parent.MyValues[2]);

                string breadcrumbServer = MatchUtil.FindServerForSession(testSession, true);
                string sandwichServer = MatchUtil.FindServerForSession(testSession, false);
                Global.RO.Info("Breadcrumb server: {0}, Sandwich server: {1}", breadcrumbServer, sandwichServer);
                
                //seed with a value
                testSession.AddAttrib(new XRLXeAttribParam(Constants.PROPERTY_MYFLOAT64PROP1,
                                                           new XRLXeDoubleValue(AsyncUpdate.STARTING_VALUE)));
                XmatchSprocSet updateSproc = new XmatchSprocSet("p_match_session_v2_0x" + MatchPartUtil.DEFAULT_TITLEID.ToString("X") + 
                                                                "_updatecomplete", testSession);

                Thread updateFirstThread = new Thread(AsyncUpdate.UpdateToGoodValues); //TODO: use ThreadMaker to create this thread so it's name is properly associated with any output
                Thread updateSecondThread = new Thread(AsyncUpdate.UpdateToBadValues); //TODO: use ThreadMaker to create this thread so it's name is properly associated with any output
                updateSproc.SetSprocToDelayedExecution(); //set the delay over here.
                updateFirstThread.Start(testSession);
                System.Threading.Thread.Sleep(100);  //sleep just a moment, to ensure the first thread starts.

                //in the FIRST_DELAY case, we'll reset the sproc here, so that the second sproc is
                //not delayed.
                if ((TestMode) MyValues[0] == TestMode.FIRST_DELAY) { updateSproc.ResetSprocToOriginal(); }

                updateSecondThread.Start(testSession);

                if (!updateFirstThread.Join(30000)) Global.RO.Warn("Timed out(30s) waiting on first update!");
                if (!updateSecondThread.Join(30000)) Global.RO.Warn("Timed out(30s) waiting on second update!");

                //in the BOTH_DELAY case, we can't forget to reset the sproc, so we'll do that here.
                if ((TestMode) MyValues[0] == TestMode.BOTH_DELAY) { updateSproc.ResetSprocToOriginal(); }

                //query DB for this property.  Stored property should be the one in the first update.
                XMatch xmatchHandle;
                xmatchHandle = new XMatch();
                xmatchHandle.ConnectToServer(breadcrumbServer);

                SqlDataReader reader = MatchUtil.QueryDBForAttribute(xmatchHandle, testSession, Constants.PROPERTY_MYFLOAT64PROP1);
                success = success && CheckForValue(reader, "Breadcrumb");
                reader.Close();

                xmatchHandle.Close();
                xmatchHandle.ConnectToServer(sandwichServer);
                reader = MatchUtil.QueryDBForAttribute(xmatchHandle, testSession, Constants.PROPERTY_MYFLOAT64PROP1);
                success = success && CheckForValue(reader, "Sandwich");

                xmatchHandle.Close();//don't forget to close!

                if (success) ResultCode=TEST_RESULTS.PASSED;
            }
        }


        [TestCase, Description("Set an update to be delayed.  Run a delete during this.  We want to be sure that the delete goes" + 
                               " through even while an update is running.")] 
        public class P_Update_And_Delete : TestBase {
            protected override void Execute() {
                MatchSession testSession = MatchPartUtil.CreateBreadcrumbedSession("CauseTwoUpdates", 
                                                                                   (long) Parent.MyValues[0], (long) Parent.MyValues[1],
                                                                                   (long) Parent.MyValues[2]);
                //seed with a value
                testSession.AddAttrib(new XRLXeAttribParam(Constants.PROPERTY_MYFLOAT64PROP1,
                                                           new XRLXeDoubleValue(AsyncUpdate.STARTING_VALUE)));

                XmatchSprocSet updateSproc = new XmatchSprocSet("p_match_session_v2_0x" + MatchPartUtil.DEFAULT_TITLEID.ToString("X") + 
                                                                "_updatecomplete", testSession);            

                Thread updateFirstThread = new Thread(AsyncUpdate.UpdateToGoodValues); //TODO: use ThreadMaker to create this thread so it's name is properly associated with any output
                updateSproc.SetSprocToDelayedExecution();
                try {
                    updateFirstThread.Start(testSession);
                    testSession.Delete();
                } finally {
                    updateSproc.ResetSprocToOriginal();
                }
                //ensure we've got the delete on both servers.
                MatchUtil.SessionDBData sessionData = 
                    MatchUtil.QueryDBForSessionData(MatchUtil.FindServerForSession(testSession, false), testSession);

                //the session should either be gone from the table, or have its deletion time set.
                if (sessionData != null) {
                    ValueCheck.Test("Marked as deleted on sandwich server", true, sessionData.isDeleted);
                }
                sessionData = 
                    MatchUtil.QueryDBForSessionData(MatchUtil.FindServerForSession(testSession, true), testSession);

                //same as above
                if (sessionData != null) {
                    ValueCheck.Test("Marked as deleted on breadcrumb server", true, sessionData.isDeleted);
                }
                ResultCode=TEST_RESULTS.PASSED;
            }
        }

        [TestCase, Description("Set an sandwich-creating update to be delayed.  Run a delete during this.  We want to be sure that the delete goes" + 
                               " through even while an update is running.  When complete, ensure the sandwich is not orphaned(i.e. it is deleted," + 
                               " along with the breadcrumb")] 
        public class P_Update_Mode_And_Delete_ie_Little_Orphan_Annie : TestBase {
            protected override void Execute() {
                MatchSession testSession = MatchPartUtil.CreateGenericSession("OrphanAnnieSyndrome", 
                                                                              (long) Parent.MyValues[0], (long) Parent.MyValues[1]);

                string breadcrumbServer = MatchUtil.FindServerForSession(testSession, true);
                string sandwichServer = MatchUtil.FindServerForSession(testSession, false);
                Global.RO.Info("Breadcrumb server: {0}, Sandwich server: {1}", breadcrumbServer, sandwichServer);

                testSession.AllowUpdateAtAllTimes(); //useful so that internal consistency
                                                          //check doesn't get in the way of the test

                //seed with a value
                XmatchSprocSet updateSproc = new XmatchSprocSet("p_match_session_v2_0x" + MatchPartUtil.DEFAULT_TITLEID.ToString("X") + 
                                                                "_updatecomplete", testSession);            

                Thread updateFirstThread;
                //let's make the thread update to the other mode
                if (((long)Parent.MyValues[1]) == Constants.CONTEXT_GAME_MODE_MODEA) {
                    updateFirstThread = new Thread(AsyncUpdate.UpdateModeToB); //TODO: use ThreadMaker to create this thread so it's name is properly associated with any output
                } else {
                    updateFirstThread = new Thread(AsyncUpdate.UpdateModeToA); //TODO: use ThreadMaker to create this thread so it's name is properly associated with any output
                }

                updateSproc.SetSprocToDelayedExecution();
                try {
                    updateFirstThread.Start(testSession);
                    System.Threading.Thread.Sleep(100);  //sleep just a moment, to ensure the first thread starts.
                    testSession.Delete();
                    if (!updateFirstThread.Join(30000)) Global.RO.Warn("Timed out(30s) waiting on first update!");
                } finally {
                    updateSproc.ResetSprocToOriginal();
                }
                //ensure we've got the delete on both servers.
                MatchUtil.SessionDBData sessionData = 
                    MatchUtil.QueryDBForSessionData(MatchUtil.FindServerForSession(testSession, false), testSession);
                //Session should be completely deleted...  sessionData should be null for the sandwich.
//                ValueCheck.Test("Marked as deleted on sandwich server", true,
//                sessionData.isDeleted);
                ValueCheck.TestNull("Must be completely deleted from sandwich server", sessionData);
                sessionData = 
                    MatchUtil.QueryDBForSessionData(MatchUtil.FindServerForSession(testSession, true), testSession);
                ValueCheck.Test("Marked as deleted on breadcrumb server", true, sessionData.isDeleted);
                ResultCode=TEST_RESULTS.PASSED;
            }
        }



    }


    //NOTE:For these to work, the title must have special configuration changes.  Specifically,
    //modec must point to a third title sql server.  Currently this requires manual npdb changes to
    //t_servers and t_interface_buckets.
    //Ignored as they require three title sql servers, an unusual configuration.
    [Ignore]
    [TestGroup]
    public class Partitioning_Round_Robin_Tests : TestNode {

        [TestCase, Description("Create a title with two partitions. One of those partitions has round robining. Create " + 
                               "sessions that should appear on each and verify they end up in the appropriate server.")]
        public class P_Round_Robin_And_Partitioning_Create : TestBase {
            protected override void Execute() {
                bool success = true;
                
                //create three sessions...
                //one ranked, mode 0
                //two standard, mode 0, 1
                MatchSession [] sessions = new MatchSession[3];
                sessions[0] = MatchPartUtil.CreateGenericSession("RRTesting_ranked_mode0", Constants.X_ATTRIBUTE_GAME_TYPE_RANKED, 
                                                   Constants.CONTEXT_GAME_MODE_MODEA, Constants.XENON_ROUND_ROBINED_TITLE);
                sessions[1] = MatchPartUtil.CreateGenericSession("RRTesting_standard_mode0", Constants.X_ATTRIBUTE_GAME_TYPE_STANDARD, 
                                                   Constants.CONTEXT_GAME_MODE_MODEA, Constants.XENON_ROUND_ROBINED_TITLE);
                sessions[2] = MatchPartUtil.CreateGenericSession("RRTesting_standard_mode1", Constants.X_ATTRIBUTE_GAME_TYPE_STANDARD, Constants.CONTEXT_GAME_MODE_MODEB, Constants.XENON_ROUND_ROBINED_TITLE);
                
                //make sure we can find them.
                foreach (MatchSession session in sessions) {
                    if (session.IsRanked()) {
                        success = MatchPartUtil.PositiveVerify(session) && success;
                    } else {
                        success = MatchPartUtil.PositiveVerifyAndRetryQuery(session) && success;
                    }
                }
                foreach (MatchSession session in sessions) {
                    session.Delete();
                }
                if (success) ResultCode=TEST_RESULTS.PASSED;
            }
        }

        //TODO--clean this/compound this with above
        [TestCase, Description("Create a title with two partitions. One of those partitions has round robining. Create " + 
                               "sessions that should appear on each and verify they end up in the appropriate server.  Same as " + 
                               "above, but we round-robin the ranked instead.")]
        public class P_Round_Robin_And_Partitioning_Create_Reverse_Standard_and_Ranked : TestBase {
            protected override void Execute() {
                bool success = true;
                
                //create three sessions...
                //one standard, mode 0
                //two ranked, mode 0, 1
                MatchSession [] sessions = new MatchSession[3];
                sessions[0] = MatchPartUtil.CreateGenericSession("RRTesting_standard_mode0", Constants.X_ATTRIBUTE_GAME_TYPE_STANDARD, Constants.CONTEXT_GAME_MODE_MODEA, Constants.XENON_ROUND_ROBINED_TITLE);
                sessions[1] = MatchPartUtil.CreateGenericSession("RRTesting_ranked_mode0", Constants.X_ATTRIBUTE_GAME_TYPE_RANKED, Constants.CONTEXT_GAME_MODE_MODEA, Constants.XENON_ROUND_ROBINED_TITLE);
                sessions[2] = MatchPartUtil.CreateGenericSession("RRTesting_ranked_mode1", Constants.X_ATTRIBUTE_GAME_TYPE_RANKED, Constants.CONTEXT_GAME_MODE_MODEB, Constants.XENON_ROUND_ROBINED_TITLE);
                
                //make sure we can find them.
                foreach (MatchSession session in sessions) {
                    if (session.IsRanked()) {
                        success = MatchPartUtil.PositiveVerify(session) && success;
                    } else {
                        success = MatchPartUtil.PositiveVerifyAndRetryQuery(session) && success;
                    }
                }
                foreach (MatchSession session in sessions) {
                    session.Delete();
                }
                if (success) ResultCode=TEST_RESULTS.PASSED;
            }
        }   

        [TestCase, Description("Use the title above, but create a breadcrumbed session by starting with a generic session, " + 
                               "and then placing the breadcrumb on the round-robined server.  This doesn't work now because " +
                               "the verify code uses the RRID in the session--however, for a sandwich, it is placed without " +
                               "any knowledge of it, besides the breadcrumb...")]
        public class P_Round_Robin_And_Breadcrumbing : TestBase {
            protected override void Execute() {
                bool success = true;
                
                MatchSession session = 
                    MatchPartUtil.CreateGenericSession("RRTest_Breadcrumb", Constants.X_ATTRIBUTE_GAME_TYPE_RANKED, 
                                                       Constants.CONTEXT_GAME_MODE_MODEA, Constants.XENON_ROUND_ROBINED_TITLE);
                try {
                    if (! session.UpdateAttrib(new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE, 
                                                                    new XRLXeIntValue(Constants.CONTEXT_GAME_MODE_MODEB)))) {
                        throw new Exception("Could not create a breadcrumbed session!  Update of game mode failed!");
                    }
                } finally {
                    success = MatchPartUtil.PositiveVerifyAndRetryQuery(session) && success;
                }
                session.Delete();
                success = MatchPartUtil.NegativeVerify(session) && success;
                if (success) ResultCode=TEST_RESULTS.PASSED;
            }
        }   


        [TestCase, Description("Use the title above, but create a breadcrumb and move it back to the same mode.  Ensure it is" +
                               "either merged or breadcrumbed to different servers.")]
        public class P_Round_Robin_And_Breadcrumbing_Move_Twice_Ranked : TestBase {
            protected override void Execute() {
                bool success = true;
                
                MatchSession session = 
                    MatchPartUtil.CreateGenericSession("RRTest_Breadcrumb_Twice", Constants.X_ATTRIBUTE_GAME_TYPE_RANKED, 
                                                       Constants.CONTEXT_GAME_MODE_MODEB, 0xFFFF009B /*Constants.XENON_ROUND_ROBINED_TITLE*/);

                try {
                    if (! session.UpdateAttrib(new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE, 
                                                                    new XRLXeIntValue(Constants.CONTEXT_GAME_MODE_MODEA)))) {
                        throw new Exception("Could not create a breadcrumbed session!  Update of game mode failed!");
                    }
                    if (! session.UpdateAttrib(new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE, 
                                                                    new XRLXeIntValue(Constants.CONTEXT_GAME_MODE_MODEB)))) {
                        throw new Exception("Could not move back to original!  Update of game mode failed!");
                    }
                    success = MatchPartUtil.PositiveVerifyAndRetryQuery(session) && success;
                } finally {
                    session.Delete();
                }
                success = MatchPartUtil.NegativeVerify(session) && success;
                if (success) ResultCode=TEST_RESULTS.PASSED;
            }
        }   

        [TestCase, Description("Use the title above, but create a breadcrumb and move it back to the same mode.  Ensure it is" +
                               "either merged or breadcrumbed to different servers.  Standard session this time, and 1->0.")]
        public class P_Round_Robin_And_Breadcrumbing_Move_Twice_Standard : TestBase {
            protected override void Execute() {
                bool success = true;
                
                MatchSession session = 
                    MatchPartUtil.CreateGenericSession("RRTest_Breadcrumb_Twice", Constants.X_ATTRIBUTE_GAME_TYPE_STANDARD, 
                                                       Constants.CONTEXT_GAME_MODE_MODEB, 0xFFFF009B /*Constants.XENON_ROUND_ROBINED_TITLE*/);
                try {
                    if (! session.UpdateAttrib(new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE, 
                                                                    new XRLXeIntValue(Constants.CONTEXT_GAME_MODE_MODEA)))) {
                        throw new Exception("Could not create a breadcrumbed session!  Update of game mode failed!");
                    }
                    if (! session.UpdateAttrib(new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE, 
                                                                    new XRLXeIntValue(Constants.CONTEXT_GAME_MODE_MODEB)))) {
                        throw new Exception("Could not move back to original!  Update of game mode failed!");
                    }
                    if (! session.UpdateAttrib(new XRLXeAttribParam(Constants.X_ATTRIBUTE_GAME_MODE, 
                                                                    new XRLXeIntValue(Constants.CONTEXT_GAME_MODE_MODEA)))) {
                        throw new Exception("Could not move back to original!  Update of game mode failed!");
                    }
                    success = MatchPartUtil.PositiveVerifyAndRetryQuery(session) && success;
                } finally {
                    session.Delete();
                }
                success = MatchPartUtil.NegativeVerify(session) && success;
                if (success) ResultCode=TEST_RESULTS.PASSED;
            }
        }   


    }
    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XMatchTest\Stress2Split.cs ===
using System;
using System.Collections;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.Matchmaking;
using xonline.common.config;

namespace XMatchTest
{
    /// <summary>
    /// This class does Session Delete
    /// </summary>
    public class Stress2SplitSession : MatchStressBase
    {
        public override void Run()
        {
            uint titleID; Queue sessQ;
            Stress2Helpers.GetRandomTitleAndQ(out titleID, out sessQ);

            byte[] sessID = null;
            bool isRanked = false;
            SessIDAndSgAddr sessIDAndSgAddr = null;
            try
            {
                sessIDAndSgAddr = (SessIDAndSgAddr)sessQ.Dequeue(); //dequeue so we
                                                                                    //don't see it
                                                                                    //deleted mid-stream.
                if (!STFMatchCounters.CreateAllowed(sessIDAndSgAddr.ranked)) 
                {
                    sessQ.Enqueue(sessIDAndSgAddr);
                    SkipTest("Stress2SplitSession: create disallowed.");
                }
                sessID = sessIDAndSgAddr.SessID;
                isRanked = sessIDAndSgAddr.ranked;
            }
            catch (InvalidOperationException)
            {
                SkipTest("Stress2SplitSession: sessQ is empty.");
            }

            //maybe this will fix a session leak--force the new XNAddr to use the one we've
            //pre-randomly generated.  Note all other requests currently have the XRL layer create the
            //SGADDR instead of passing it in.
            SGADDR sgAddr = new SGADDR();  //defaults to xenon client.
            XRLxnaddr newXnaddr = MatchUtil.CreateRandomXNADDR();
            newXnaddr.abOnline = sgAddr.toByteArray();

            try
            {
                XRLSplitSession splitReq = new XRLSplitSession(sessID, titleID, newXnaddr,
                    Stress2Helpers.GetRandomAttribs(isRanked));
                XRL2SingleSearchResult splitResp;
                if (splitReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out splitResp))
                {
                    SessIDAndSgAddr hostInfo = new SessIDAndSgAddr(splitResp.SessionID, sgAddr, isRanked);
                    sessQ.Enqueue(hostInfo);
                    STFMatchCounters.AddToSessionCount(hostInfo);
                }
                else
                {
                    FailTest("Stress2SplitSession failed", splitReq.XErr);
                }
            }
            finally
            {
                sessQ.Enqueue(sessIDAndSgAddr);
                //population control--if the value is 5% too big after a create, then delete the next session
                //immediately afterwards.  NOTE THIS IS NOT CAPTURED IN THE TPS.
                XMatchTest.LimitSessionQueue(sessQ, titleID);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XMatchTest\StressHostDelete.cs ===
using System;
using System.Collections;
using ServerTestFramework;
using ServerTestFramework.LiveService.Matchmaking;
using xonline.common.config;

namespace XMatchTest
{
	/// <summary>
	/// This class does Session Delete
	/// </summary>
    public abstract class StressHostDeleteTitleBase : TestNode
    {
        protected void Run(uint TitleID, Queue sessQ)
        {
            byte[] sessID = null;

            // Don't completely drain the queue
            if (sessQ.Count < 100)
            {
                MatchStressBase.SkipTest("StressHostDeleteTitleBase: sessQ is not full enough.");
            }
            try
            {
                sessID = (byte[])sessQ.Dequeue();
            }
            catch (InvalidOperationException)
            {
                MatchStressBase.SkipTest("StressHostDeleteTitleBase: sessQ is empty.");
            }

            XRLDeleteSession delReq = new XRLDeleteSession(sessID);
            delReq.dwTitleID = TitleID;

            if (!delReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd)))
            {
                MatchStressBase.FailTest("DeleteSession failed", delReq.XErr);
            }
        }
    }

	public class StressHostDeleteTitle1 : StressHostDeleteTitleBase
	{
		public override void Run()
		{
            Run(StressParams.STRESS_TITLE_ID1, StressParams.sessionQ1);
		}
	}

	public class StressHostDeleteTitle2 : StressHostDeleteTitleBase
	{
		public override void Run()
		{
            Run(StressParams.STRESS_TITLE_ID2, StressParams.sessionQ2);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XMatchTest\StressHostUpdate.cs ===
using System;
using System.Collections;
using ServerTestFramework;
using ServerTestFramework.LiveService.Matchmaking;
using ServerTestFramework.Utilities;
using xonline.common.config;

namespace XMatchTest
{
	/// <summary>
	/// This class does Session Update
	/// </summary>
	public abstract class StressHostUpdateTitleBase : MatchStressBase
	{
		protected void Run(uint TitleID, uint maxIntAttrib, Queue sessQ)
		{
            byte[] sessID = null;

			try
			{
				sessID = (byte [])sessQ.Dequeue();
			}
			catch(InvalidOperationException)
			{
                SkipTest("StressHostUpdateTitleBase: sessQ is empty.");
			}

			XRLCreateUpdateSession	updateReq = new XRLCreateUpdateSession();
			uint					intAttribID = StressParams.INT_ATTRIB_ID;
			uint					numUpdateAttrib = 0;
			WireData				[]attribs;
			long					[] intValueArray;

			updateReq.baseSession.dwTitleID = TitleID;
			Array.Copy(sessID,updateReq.baseSession.SessionID,sessID.Length);

			// random value: the number of attributes that will be updated
			do
			{
				numUpdateAttrib = (uint)(RandomEx.GlobalRandGen.Next((int)maxIntAttrib));
			}while(numUpdateAttrib == 0);
			attribs = new WireData[numUpdateAttrib];
			intValueArray = new long[numUpdateAttrib];

			for(uint i = 0; i < numUpdateAttrib; i++)
			{
				intValueArray[i] = StressParams.intValueArray[i%StressParams.COMB_SIZE];
			}
			updateReq.AttribOffsetsLen = numUpdateAttrib;
			for(uint i = 0; i < numUpdateAttrib; i++)
			{
				attribs[i] = new XRLIntAttribute(intAttribID++, intValueArray[i]);
			}
			updateReq.AddAttribs(attribs);

			if(updateReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd)))
			{
				sessQ.Enqueue(sessID);	// put the sessionID back until deleteSession is called
			}
			else
			{
                FailTest("UpdateSession failed:", updateReq.XErr);
			}
		}
	}

	public class StressHostUpdateTitle1 : StressHostUpdateTitleBase
	{
		public override void Run()
		{
            Run(StressParams.STRESS_TITLE_ID1, StressParams.MAX_INT_ATTRIB1, StressParams.sessionQ1);
		}
	}

	public class StressHostUpdateTitle2 : StressHostUpdateTitleBase
	{
		public override void Run()
		{
            Run(StressParams.STRESS_TITLE_ID2, StressParams.MAX_INT_ATTRIB2, StressParams.sessionQ2);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XMatchTest\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\XMatchTest\StressParams.cs ===
using System;
using System.IO;
using System.Collections;
using System.Collections.Generic;
using ServerTestFramework.LiveService.Matchmaking;
using ServerTestFramework.Utilities;

namespace XMatchTest
{
	internal class StressParams
	{
		public const uint	STRESS_TITLE_ID1 = 0xFFED94B1;
		public const uint	STRESS_TITLE_ID2 = 0xFFED534C;
		public const uint	DEADXBOX1_TITLE_ID = 0xFFED0001;

		public const uint	INT_ATTRIB_ID = 0x1;	// These IDs are fixed in sp for both Titles

		public const uint	MAX_INT_ATTRIB1 = 10;	// total int attributes for title 1
		public const uint	MAX_INT_ATTRIB2 = 6;	// total int attribs for title 2

		public const uint	COMMON_SP_INDEX = 1;
		public const uint	SUMMARY_SP_INDEX = 0x80000003;
		public const uint	BYID_SP_INDEX = 2;		// GetSessionByID query stored procedure's index

		public const uint	HOSTVALIDTITLEDEADXBOX = 5;
		public const uint	NONHOSTVALIDTITLEDEADXBOX = 45;
		public const uint	NONMULTIPLAYERDEADXBOX = 50;

		public const uint	COMB_SIZE = 5;
		public static long	[] intValueArray = new long[5]{888,666,333,999,111};

		public static TextWriter	Safetw;		// thread safe
		public static int createThreadCount = 20;

		public static Queue			sessionQ1 = Queue.Synchronized(new Queue());	// for title 1
		public static Queue			sessionQ2 = Queue.Synchronized(new Queue());	// for title 2

	}
	/// <summary>
	/// It will be used for XBox 360 stress testing.
	/// </summary>
	internal class Stress2Params
	{
		public const	int				presListenerPort = 802;
		public static	XPresListener	presListener = new XPresListener(presListenerPort,-1,-1);

		/*************************************************************************************
		 *  configurable settings 
		 ************************************************************************************/

                // Mode.  This can be either STRESS_TESTING, MIGRATION_TESTING, or SINGLE_TITLE_TESTING.
                //  --STRESS_TESTING is what existed beforehand, and models one big title and nine
                //    smaller ones.
                //  --MIGRATION_TESTING creates heavyweight sessions that carry more logging data with
                //    them.  This is designed to more easily track down the histories of sessions
                //    and allows better debug data.
                //  --SINGLE_TITLE_TESTING is like STRESS_TESTING, but based on only one title.  
                public static string mode = "UNINITIALIZED_MODE";


		// the array value can be either 1 (use null for this search request) or 0 (pass real value)
		public static	uint[]	myContextParamValues = new uint[100]; 
		public static	uint[]	int32PropParamValues = new uint[100];
		public static	uint[]	int64PropParamValues = new uint[100];
		public static	uint[]	float32PropParamValues = new uint[100];
		public static	uint[]	float64PropParamValues = new uint[100];
		public static	uint[]	dateTimePropParamValues = new uint[100];

		// every title has 6 title defined attributes, one of each type
		// createSession/searchSession: the value of each attribute/searchParameter can only be one of the followings.
		public static int	[] int32ValueArray = new int[5]{1,2,3,4,5};
		public static long	[] int64ValueArray = new long[5]{111,222,333,444,555};
		public static float	[] float32ValueArray = new float[5]{0.1f,0.2f,0.3f,0.4f,0.5f};
		public static double[] float64ValueArray = new double[5]{1.1,1.2,1.3,1.4,1.5};
		public static long	dValue1 = new DateTime(2002,8,12).ToFileTimeUtc(),dValue2 = new DateTime(2004,8,10).ToFileTimeUtc();
		public static long  dValue3 = new DateTime(2005,1,1).ToFileTimeUtc(),dValue4 = new DateTime(2005,12,31).ToFileTimeUtc();
		public static long	dValue5 = new DateTime(2005,8,8).ToFileTimeUtc();
		public static long	[] dateTimeValueArray = new long[5]{dValue1,dValue2,dValue3,dValue4,dValue5};

		// the percentage of each type of affiliate returned from presence
		public static uint	friendRatio = 0;
		public static uint	posRatio = 0;
		public static uint	compRatio = 0;
		public static uint	negRatio = 0;
		public static uint	avoidRatio = 0;
            
            //number of initial sessions to create
            public static uint numOpenRankedSessionsForNonHit;
            public static uint numOpenSocialSessionsForNonHit;
            public static uint numOpenRankedSessionsForHit;
            public static uint numOpenSocialSessionsForHit;
            public static uint numLobbySessionsForHit;

                // parameters used during updates
                public static uint    percentChanceOfChangingMode;
                public static uint    percentChanceOfClosingSession;

                // parameters used during creation.  Default to zero, can be overwritten by xml file
                public static double    percentChanceFullRankedSessionForHit = 0;
                public static double    percentChanceFullStandardSessionForHit = 0;

                // switch just for the Round Robin mode.  If we use this, the more detailed verify
                // in migration will check this many times for where an unranked session is.  Since
                // the requests is round-robined, we should eventually come across the session in
                // question.  Used only in migration mode stress.            

                public static uint    RoundRobinSearchRetries;

            //override mode.  Usually sessions are set to 50/50 chance of Mode A and mode B.  The
            //LobbySessions override makes it 100% A, while the Halo3Sessions override makes it
            //50/50 of B and C.
            public static string sessionModeSettings = "NO_SETTINGS";

            //Complex title schema flag.  Use this to enable a larger number of attributes in each
            //session's create.  Defaults to false.
            public static bool complexTitleSchema = false;

            //Custom title schema.  Use this to enable a replacement schema for requests.  This
            //replacement is defined when the flag is read.  Presence of this overrides the flag
            //"complexTitleSchema".  The two should not be used in conjunction.
            public static MatchTitleSchema customTitleSchema = null;

            //counters for the number of sessions.
            public static long numActiveRankedSessions = 0;
            public static long numActiveStandardSessions = 0;

            // these testing titles have exact the same xlast except titleIDs.
            // 0xffff008e (server 1)simulate popular titles, which has 150K sessions for both ranked and social match
            // 0xffff0074-0xffff008d (server 2): simulate normal titles.
            // Note that these can be overridden by the StressTitleOverride in XmatchTest.cs
            public static uint[] StressTitles = new uint[10] {
                0xFFFF0074, 0xFFFF0075, 0xFFFF0076, 0xFFFF0077, 0xFFFF0078,
                0xFFFF008A, 0xFFFF008B, 0xFFFF008C, 0xFFFF008D, 0xFFFF008E
            };

            public static Queue[] SessionQs = new Queue[10] {
                Queue.Synchronized(new Queue()), Queue.Synchronized(new Queue()),
                Queue.Synchronized(new Queue()), Queue.Synchronized(new Queue()),
                Queue.Synchronized(new Queue()), Queue.Synchronized(new Queue()),
                Queue.Synchronized(new Queue()), Queue.Synchronized(new Queue()),
                Queue.Synchronized(new Queue()), Queue.Synchronized(new Queue())
            };

            //This template covers a complex session for use with the weighted search.
            public static XRLXeAttribParam[] sessionTemplateComplex = new XRLXeAttribParam[49] {
                new XRLXeAttribParam(Stress2Params.PROPERTY_INT32PROP, new XRLXeIntValue(20)),
                new XRLXeAttribParam(Stress2Params.PROPERTY_DATETIMEPROP, new XRLXeDateTimeValue(2)),
                new XRLXeAttribParam(Stress2Params.PROPERTY_FLOAT32PROP, new XRLXeFloatValue(1)),
                new XRLXeAttribParam(Stress2Params.PROPERTY_FLOAT64PROP, new XRLXeDoubleValue(1)),
                new XRLXeAttribParam(Stress2Params.PROPERTY_MYFLOAT64PROP2, new XRLXeDoubleValue(1)),
                new XRLXeAttribParam(Stress2Params.CONTEXT_MYCONTEXT, new XRLXeIntValue(2)),
//                new XRLXeAttribParam(Stress2Params.PROPERTY_GAMERNAME, new XRLXeIntValue(2)),

                //these are the party-size params
                new XRLXeAttribParam(Stress2Params.PROPERTY_INT64PROP, new XRLXeIntValue(4)),
                new XRLXeAttribParam(Stress2Params.PROPERTY_MYINT64PROP2, new XRLXeIntValue(4)),
                new XRLXeAttribParam(Stress2Params.PROPERTY_MYINT64PROP3, new XRLXeIntValue(4)),
                new XRLXeAttribParam(Stress2Params.PROPERTY_MYINT64PROP4, new XRLXeIntValue(4)),
                new XRLXeAttribParam(Stress2Params.PROPERTY_MYINT64PROP5, new XRLXeIntValue(4)),
                new XRLXeAttribParam(Stress2Params.PROPERTY_MYINT64PROP6, new XRLXeIntValue(4)),
                new XRLXeAttribParam(Stress2Params.PROPERTY_MYINT64PROP7, new XRLXeIntValue(4)),
                new XRLXeAttribParam(Stress2Params.PROPERTY_MYINT64PROP8, new XRLXeIntValue(4)),
                new XRLXeAttribParam(Stress2Params.PROPERTY_MYINT64PROP9, new XRLXeIntValue(4)),
                new XRLXeAttribParam(Stress2Params.PROPERTY_MYINT64PROP10, new XRLXeIntValue(4)),
                new XRLXeAttribParam(Stress2Params.PROPERTY_MYINT64PROP11, new XRLXeIntValue(4)),
                new XRLXeAttribParam(Stress2Params.PROPERTY_MYINT64PROP12, new XRLXeIntValue(4)),
                new XRLXeAttribParam(Stress2Params.PROPERTY_MYINT64PROP13, new XRLXeIntValue(4)),
                new XRLXeAttribParam(Stress2Params.PROPERTY_MYINT64PROP14, new XRLXeIntValue(4)),
                new XRLXeAttribParam(Stress2Params.PROPERTY_MYINT64PROP15, new XRLXeIntValue(4)),
                new XRLXeAttribParam(Stress2Params.PROPERTY_MYINT64PROP16, new XRLXeIntValue(4)),
                new XRLXeAttribParam(Stress2Params.PROPERTY_MYINT64PROP17, new XRLXeIntValue(4)),
                new XRLXeAttribParam(Stress2Params.PROPERTY_MYINT64PROP18, new XRLXeIntValue(4)),
                new XRLXeAttribParam(Stress2Params.PROPERTY_MYINT64PROP19, new XRLXeIntValue(4)),
                new XRLXeAttribParam(Stress2Params.PROPERTY_MYINT64PROP20, new XRLXeIntValue(4)),
                new XRLXeAttribParam(Stress2Params.PROPERTY_MYINT64PROP21, new XRLXeIntValue(4)),
                new XRLXeAttribParam(Stress2Params.PROPERTY_MYINT64PROP22, new XRLXeIntValue(4)),
                new XRLXeAttribParam(Stress2Params.PROPERTY_MYINT64PROP23, new XRLXeIntValue(4)),
                new XRLXeAttribParam(Stress2Params.PROPERTY_MYINT64PROP24, new XRLXeIntValue(4)),
                new XRLXeAttribParam(Stress2Params.PROPERTY_MYINT64PROP25, new XRLXeIntValue(4)),
                new XRLXeAttribParam(Stress2Params.PROPERTY_MYINT64PROP26, new XRLXeIntValue(4)),
/////

                new XRLXeAttribParam(Stress2Params.PROPERTY_MYINT64PROP27, new XRLXeIntValue(2)),
                new XRLXeAttribParam(Stress2Params.PROPERTY_MYINT64PROP28, new XRLXeIntValue(2)),
                new XRLXeAttribParam(Stress2Params.PROPERTY_MYINT64PROP29, new XRLXeIntValue(2)),
                new XRLXeAttribParam(Stress2Params.PROPERTY_MYINT64PROP30, new XRLXeIntValue(2)),
                new XRLXeAttribParam(Stress2Params.PROPERTY_MYINT64PROP31, new XRLXeIntValue(2)),
                new XRLXeAttribParam(Stress2Params.PROPERTY_MYINT64PROP32, new XRLXeIntValue(2)),
                new XRLXeAttribParam(Stress2Params.PROPERTY_MYINT64PROP33, new XRLXeIntValue(20)),
                new XRLXeAttribParam(Stress2Params.PROPERTY_MYINT64PROP34, new XRLXeIntValue(2)),
                new XRLXeAttribParam(Stress2Params.PROPERTY_MYINT64PROP35, new XRLXeIntValue(2)),
                new XRLXeAttribParam(Stress2Params.PROPERTY_MYINT64PROP36, new XRLXeIntValue(2)),
                new XRLXeAttribParam(Stress2Params.PROPERTY_MYINT64PROP37, new XRLXeIntValue(2)),
                new XRLXeAttribParam(Stress2Params.PROPERTY_MYINT64PROP38, new XRLXeIntValue(2)),
                new XRLXeAttribParam(Stress2Params.PROPERTY_MYINT64PROP39, new XRLXeIntValue(2)),
                new XRLXeAttribParam(Stress2Params.PROPERTY_MYINT64PROP40, new XRLXeIntValue(2)),
                new XRLXeAttribParam(Stress2Params.PROPERTY_MYINT64PROP41, new XRLXeIntValue(2)),
                new XRLXeAttribParam(Stress2Params.PROPERTY_MYINT32PROP2, new XRLXeIntValue(20)),
                new XRLXeAttribParam(Stress2Params.PROPERTY_MYFLOAT32PROP2, new XRLXeFloatValue(1)),
            };

            public static XRLXeAttribParamWeighted[] weightedParamComplex = new XRLXeAttribParamWeighted [13]{
                new XRLXeAttribParamWeighted(Stress2Params.PROPERTY_MYINT64PROP34, (float) .05, new XRLXeIntValue(2)),
                new XRLXeAttribParamWeighted(Stress2Params.PROPERTY_MYINT64PROP35, (float) .05, new XRLXeIntValue(2)),
                new XRLXeAttribParamWeighted(Stress2Params.PROPERTY_MYINT64PROP36, (float) .05, new XRLXeIntValue(2)),
                new XRLXeAttribParamWeighted(Stress2Params.PROPERTY_MYINT64PROP37, (float) .05, new XRLXeIntValue(2)),
                new XRLXeAttribParamWeighted(Stress2Params.PROPERTY_MYINT64PROP38, (float) .05, new XRLXeIntValue(2)),
                new XRLXeAttribParamWeighted(Stress2Params.PROPERTY_MYINT64PROP39, (float) .05, new XRLXeIntValue(2)),
                new XRLXeAttribParamWeighted(Stress2Params.PROPERTY_MYINT64PROP40, (float) .05, new XRLXeIntValue(2)),
                new XRLXeAttribParamWeighted(Stress2Params.PROPERTY_MYINT64PROP41, (float) .05, new XRLXeIntValue(2)),
                new XRLXeAttribParamWeighted(Stress2Params.PROPERTY_FLOAT64PROP, (float) .05, new XRLXeDoubleValue(1)),
                new XRLXeAttribParamWeighted(Stress2Params.PROPERTY_MYFLOAT64PROP2, (float) .05, new XRLXeDoubleValue(1)),
                new XRLXeAttribParamWeighted(Stress2Params.PROPERTY_MYFLOAT32PROP1, (float) .05, new XRLXeFloatValue(1)), //not
                                                                                                                          //in template!
                new XRLXeAttribParamWeighted(Stress2Params.PROPERTY_MYFLOAT32PROP2, (float) .05, new XRLXeFloatValue(1)),
                new XRLXeAttribParamWeighted(Stress2Params.PROPERTY_MU, (float) (.05 / 6), new XRLXeDoubleValue(6)),
            };
            
            //These parameters are sometimes passed up.  No more than seven of these will actually
            //be passed up.  Reduced to three, and actual value lowered.
            public static XRLXeAttribParam[] nonWeightedOptionalParams = new XRLXeAttribParam[26] {
                new XRLXeAttribParam(Stress2Params.PROPERTY_INT64PROP, new XRLXeIntValue(2)),
                new XRLXeAttribParam(Stress2Params.PROPERTY_MYINT64PROP2, new XRLXeIntValue(2)),
                new XRLXeAttribParam(Stress2Params.PROPERTY_MYINT64PROP3, new XRLXeIntValue(2)),
                new XRLXeAttribParam(Stress2Params.PROPERTY_MYINT64PROP4, new XRLXeIntValue(2)),
                new XRLXeAttribParam(Stress2Params.PROPERTY_MYINT64PROP5, new XRLXeIntValue(2)),
                new XRLXeAttribParam(Stress2Params.PROPERTY_MYINT64PROP6, new XRLXeIntValue(2)),
                new XRLXeAttribParam(Stress2Params.PROPERTY_MYINT64PROP7, new XRLXeIntValue(2)),
                new XRLXeAttribParam(Stress2Params.PROPERTY_MYINT64PROP8, new XRLXeIntValue(2)),
                new XRLXeAttribParam(Stress2Params.PROPERTY_MYINT64PROP9, new XRLXeIntValue(2)),
                new XRLXeAttribParam(Stress2Params.PROPERTY_MYINT64PROP10, new XRLXeIntValue(2)),
                new XRLXeAttribParam(Stress2Params.PROPERTY_MYINT64PROP11, new XRLXeIntValue(2)),
                new XRLXeAttribParam(Stress2Params.PROPERTY_MYINT64PROP12, new XRLXeIntValue(2)),
                new XRLXeAttribParam(Stress2Params.PROPERTY_MYINT64PROP13, new XRLXeIntValue(2)),
                new XRLXeAttribParam(Stress2Params.PROPERTY_MYINT64PROP14, new XRLXeIntValue(2)),
                new XRLXeAttribParam(Stress2Params.PROPERTY_MYINT64PROP15, new XRLXeIntValue(2)),
                new XRLXeAttribParam(Stress2Params.PROPERTY_MYINT64PROP16, new XRLXeIntValue(2)),
                new XRLXeAttribParam(Stress2Params.PROPERTY_MYINT64PROP17, new XRLXeIntValue(2)),
                new XRLXeAttribParam(Stress2Params.PROPERTY_MYINT64PROP18, new XRLXeIntValue(2)),
                new XRLXeAttribParam(Stress2Params.PROPERTY_MYINT64PROP19, new XRLXeIntValue(2)),
                new XRLXeAttribParam(Stress2Params.PROPERTY_MYINT64PROP20, new XRLXeIntValue(2)),
                new XRLXeAttribParam(Stress2Params.PROPERTY_MYINT64PROP21, new XRLXeIntValue(2)),
                new XRLXeAttribParam(Stress2Params.PROPERTY_MYINT64PROP22, new XRLXeIntValue(2)),
                new XRLXeAttribParam(Stress2Params.PROPERTY_MYINT64PROP23, new XRLXeIntValue(2)),
                new XRLXeAttribParam(Stress2Params.PROPERTY_MYINT64PROP24, new XRLXeIntValue(2)),
                new XRLXeAttribParam(Stress2Params.PROPERTY_MYINT64PROP25, new XRLXeIntValue(2)),
                new XRLXeAttribParam(Stress2Params.PROPERTY_MYINT64PROP26, new XRLXeIntValue(2)),
            };

            public static XRLXeAttribParam[] nonWeightedParamsComplex = new XRLXeAttribParam [6]{
//too many of these cause difficulty matching.  Removing four bools.
                new XRLXeAttribParam(Stress2Params.PROPERTY_MYINT64PROP27, new XRLXeIntValue(2)), //nat
                new XRLXeAttribParam(Stress2Params.PROPERTY_MYINT64PROP28, new XRLXeIntValue(2)),
/*
                new XRLXeAttribParam(Stress2Params.PROPERTY_MYINT64PROP29, new XRLXeIntValue(2)),//bool
                new XRLXeAttribParam(Stress2Params.PROPERTY_MYINT64PROP30, new XRLXeIntValue(2)),//bool
                new XRLXeAttribParam(Stress2Params.PROPERTY_MYINT64PROP31, new XRLXeIntValue(2)),//bool
                new XRLXeAttribParam(Stress2Params.PROPERTY_MYINT64PROP32, new XRLXeIntValue(2)),//bool
*/
//drop the range filters as well.
/*
                new XRLXeAttribParam(Stress2Params.PROPERTY_MYINT64PROP33, new XRLXeIntValue(20)),//range
                new XRLXeAttribParam(Stress2Params.PROPERTY_INT32PROP, new XRLXeIntValue(20)),    //range
                new XRLXeAttr