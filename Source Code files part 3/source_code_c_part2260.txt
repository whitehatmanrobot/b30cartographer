gzag_INTERFACE_DEFINED__

/* interface ICrZigzag */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ICrZigzag;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4E5A64A0-0C8B-11d2-A484-00C04F8EFB69")
    ICrZigzag : public IDXTGridSize
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct ICrZigzagVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICrZigzag __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICrZigzag __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICrZigzag __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ICrZigzag __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ICrZigzag __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ICrZigzag __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ICrZigzag __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            ICrZigzag __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            ICrZigzag __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            ICrZigzag __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            ICrZigzag __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            ICrZigzag __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            ICrZigzag __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_gridSizeX )( 
            ICrZigzag __RPC_FAR * This,
            /* [retval][out] */ short __RPC_FAR *pX);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_gridSizeX )( 
            ICrZigzag __RPC_FAR * This,
            /* [in] */ short newX);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_gridSizeY )( 
            ICrZigzag __RPC_FAR * This,
            /* [retval][out] */ short __RPC_FAR *pY);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_gridSizeY )( 
            ICrZigzag __RPC_FAR * This,
            /* [in] */ short newY);
        
        END_INTERFACE
    } ICrZigzagVtbl;

    interface ICrZigzag
    {
        CONST_VTBL struct ICrZigzagVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICrZigzag_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICrZigzag_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICrZigzag_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICrZigzag_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ICrZigzag_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ICrZigzag_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ICrZigzag_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ICrZigzag_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define ICrZigzag_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define ICrZigzag_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define ICrZigzag_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define ICrZigzag_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define ICrZigzag_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define ICrZigzag_get_gridSizeX(This,pX)	\
    (This)->lpVtbl -> get_gridSizeX(This,pX)

#define ICrZigzag_put_gridSizeX(This,newX)	\
    (This)->lpVtbl -> put_gridSizeX(This,newX)

#define ICrZigzag_get_gridSizeY(This,pY)	\
    (This)->lpVtbl -> get_gridSizeY(This,pY)

#define ICrZigzag_put_gridSizeY(This,newY)	\
    (This)->lpVtbl -> put_gridSizeY(This,newY)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICrZigzag_INTERFACE_DEFINED__ */


#ifndef __ICrWheel_INTERFACE_DEFINED__
#define __ICrWheel_INTERFACE_DEFINED__

/* interface ICrWheel */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ICrWheel;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3943DE80-1464-11d2-A484-00C04F8EFB69")
    ICrWheel : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_spokes( 
            /* [retval][out] */ short __RPC_FAR *pX) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_spokes( 
            /* [in] */ short newX) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICrWheelVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICrWheel __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICrWheel __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICrWheel __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ICrWheel __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ICrWheel __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ICrWheel __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ICrWheel __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            ICrWheel __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            ICrWheel __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            ICrWheel __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            ICrWheel __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            ICrWheel __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            ICrWheel __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_spokes )( 
            ICrWheel __RPC_FAR * This,
            /* [retval][out] */ short __RPC_FAR *pX);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_spokes )( 
            ICrWheel __RPC_FAR * This,
            /* [in] */ short newX);
        
        END_INTERFACE
    } ICrWheelVtbl;

    interface ICrWheel
    {
        CONST_VTBL struct ICrWheelVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICrWheel_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICrWheel_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICrWheel_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICrWheel_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ICrWheel_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ICrWheel_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ICrWheel_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ICrWheel_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define ICrWheel_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define ICrWheel_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define ICrWheel_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define ICrWheel_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define ICrWheel_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define ICrWheel_get_spokes(This,pX)	\
    (This)->lpVtbl -> get_spokes(This,pX)

#define ICrWheel_put_spokes(This,newX)	\
    (This)->lpVtbl -> put_spokes(This,newX)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE ICrWheel_get_spokes_Proxy( 
    ICrWheel __RPC_FAR * This,
    /* [retval][out] */ short __RPC_FAR *pX);


void __RPC_STUB ICrWheel_get_spokes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ICrWheel_put_spokes_Proxy( 
    ICrWheel __RPC_FAR * This,
    /* [in] */ short newX);


void __RPC_STUB ICrWheel_put_spokes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICrWheel_INTERFACE_DEFINED__ */


#ifndef __IDXTChroma_INTERFACE_DEFINED__
#define __IDXTChroma_INTERFACE_DEFINED__

/* interface IDXTChroma */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTChroma;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1D4637E2-383C-11d2-952A-00C04FA34F05")
    IDXTChroma : public IDispatch
    {
    public:
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Color( 
            /* [in] */ VARIANT newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Color( 
            /* [retval][out] */ VARIANT __RPC_FAR *pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTChromaVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTChroma __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTChroma __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTChroma __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDXTChroma __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDXTChroma __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDXTChroma __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDXTChroma __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Color )( 
            IDXTChroma __RPC_FAR * This,
            /* [in] */ VARIANT newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Color )( 
            IDXTChroma __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pVal);
        
        END_INTERFACE
    } IDXTChromaVtbl;

    interface IDXTChroma
    {
        CONST_VTBL struct IDXTChromaVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTChroma_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTChroma_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTChroma_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTChroma_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTChroma_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTChroma_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTChroma_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTChroma_put_Color(This,newVal)	\
    (This)->lpVtbl -> put_Color(This,newVal)

#define IDXTChroma_get_Color(This,pVal)	\
    (This)->lpVtbl -> get_Color(This,pVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTChroma_put_Color_Proxy( 
    IDXTChroma __RPC_FAR * This,
    /* [in] */ VARIANT newVal);


void __RPC_STUB IDXTChroma_put_Color_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTChroma_get_Color_Proxy( 
    IDXTChroma __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pVal);


void __RPC_STUB IDXTChroma_get_Color_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTChroma_INTERFACE_DEFINED__ */


#ifndef __IDXTDropShadow_INTERFACE_DEFINED__
#define __IDXTDropShadow_INTERFACE_DEFINED__

/* interface IDXTDropShadow */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTDropShadow;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1D4637E3-383C-11d2-952A-00C04FA34F05")
    IDXTDropShadow : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Color( 
            /* [retval][out] */ VARIANT __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Color( 
            /* [in] */ VARIANT newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_OffX( 
            /* [retval][out] */ int __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_OffX( 
            /* [in] */ int newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_OffY( 
            /* [retval][out] */ int __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_OffY( 
            /* [in] */ int newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Positive( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Positive( 
            /* [in] */ VARIANT_BOOL newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTDropShadowVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTDropShadow __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTDropShadow __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTDropShadow __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDXTDropShadow __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDXTDropShadow __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDXTDropShadow __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDXTDropShadow __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Color )( 
            IDXTDropShadow __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Color )( 
            IDXTDropShadow __RPC_FAR * This,
            /* [in] */ VARIANT newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_OffX )( 
            IDXTDropShadow __RPC_FAR * This,
            /* [retval][out] */ int __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_OffX )( 
            IDXTDropShadow __RPC_FAR * This,
            /* [in] */ int newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_OffY )( 
            IDXTDropShadow __RPC_FAR * This,
            /* [retval][out] */ int __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_OffY )( 
            IDXTDropShadow __RPC_FAR * This,
            /* [in] */ int newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Positive )( 
            IDXTDropShadow __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Positive )( 
            IDXTDropShadow __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        END_INTERFACE
    } IDXTDropShadowVtbl;

    interface IDXTDropShadow
    {
        CONST_VTBL struct IDXTDropShadowVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTDropShadow_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTDropShadow_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTDropShadow_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTDropShadow_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTDropShadow_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTDropShadow_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTDropShadow_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTDropShadow_get_Color(This,pVal)	\
    (This)->lpVtbl -> get_Color(This,pVal)

#define IDXTDropShadow_put_Color(This,newVal)	\
    (This)->lpVtbl -> put_Color(This,newVal)

#define IDXTDropShadow_get_OffX(This,pVal)	\
    (This)->lpVtbl -> get_OffX(This,pVal)

#define IDXTDropShadow_put_OffX(This,newVal)	\
    (This)->lpVtbl -> put_OffX(This,newVal)

#define IDXTDropShadow_get_OffY(This,pVal)	\
    (This)->lpVtbl -> get_OffY(This,pVal)

#define IDXTDropShadow_put_OffY(This,newVal)	\
    (This)->lpVtbl -> put_OffY(This,newVal)

#define IDXTDropShadow_get_Positive(This,pVal)	\
    (This)->lpVtbl -> get_Positive(This,pVal)

#define IDXTDropShadow_put_Positive(This,newVal)	\
    (This)->lpVtbl -> put_Positive(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTDropShadow_get_Color_Proxy( 
    IDXTDropShadow __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pVal);


void __RPC_STUB IDXTDropShadow_get_Color_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTDropShadow_put_Color_Proxy( 
    IDXTDropShadow __RPC_FAR * This,
    /* [in] */ VARIANT newVal);


void __RPC_STUB IDXTDropShadow_put_Color_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTDropShadow_get_OffX_Proxy( 
    IDXTDropShadow __RPC_FAR * This,
    /* [retval][out] */ int __RPC_FAR *pVal);


void __RPC_STUB IDXTDropShadow_get_OffX_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTDropShadow_put_OffX_Proxy( 
    IDXTDropShadow __RPC_FAR * This,
    /* [in] */ int newVal);


void __RPC_STUB IDXTDropShadow_put_OffX_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTDropShadow_get_OffY_Proxy( 
    IDXTDropShadow __RPC_FAR * This,
    /* [retval][out] */ int __RPC_FAR *pVal);


void __RPC_STUB IDXTDropShadow_get_OffY_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTDropShadow_put_OffY_Proxy( 
    IDXTDropShadow __RPC_FAR * This,
    /* [in] */ int newVal);


void __RPC_STUB IDXTDropShadow_put_OffY_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTDropShadow_get_Positive_Proxy( 
    IDXTDropShadow __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);


void __RPC_STUB IDXTDropShadow_get_Positive_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTDropShadow_put_Positive_Proxy( 
    IDXTDropShadow __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL newVal);


void __RPC_STUB IDXTDropShadow_put_Positive_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTDropShadow_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxtmsft_0211 */
/* [local] */ 

typedef 
enum DISPID_DXTCHECKERBOARD
    {	DISPID_DXTCHECKERBOARD_DIRECTION	= 1,
	DISPID_DXTCHECKERBOARD_SQUARESX	= DISPID_DXTCHECKERBOARD_DIRECTION + 1,
	DISPID_DXTCHECKERBOARD_SQUARESY	= DISPID_DXTCHECKERBOARD_SQUARESX + 1
    }	DISPID_DXTCHECKERBOARD;



extern RPC_IF_HANDLE __MIDL_itf_dxtmsft_0211_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtmsft_0211_v0_0_s_ifspec;

#ifndef __IDXTCheckerBoard_INTERFACE_DEFINED__
#define __IDXTCheckerBoard_INTERFACE_DEFINED__

/* interface IDXTCheckerBoard */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTCheckerBoard;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AD3C2576-117C-4510-84DD-B668971DCFD1")
    IDXTCheckerBoard : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Direction( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrDirection) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Direction( 
            /* [in] */ BSTR bstrDirection) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_SquaresX( 
            /* [retval][out] */ int __RPC_FAR *pnSquaresX) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_SquaresX( 
            /* [in] */ int nSquaresX) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_SquaresY( 
            /* [retval][out] */ int __RPC_FAR *pnSquaresY) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_SquaresY( 
            /* [in] */ int nSquaresY) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTCheckerBoardVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTCheckerBoard __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTCheckerBoard __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTCheckerBoard __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDXTCheckerBoard __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDXTCheckerBoard __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDXTCheckerBoard __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDXTCheckerBoard __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            IDXTCheckerBoard __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            IDXTCheckerBoard __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            IDXTCheckerBoard __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            IDXTCheckerBoard __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            IDXTCheckerBoard __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            IDXTCheckerBoard __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Direction )( 
            IDXTCheckerBoard __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrDirection);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Direction )( 
            IDXTCheckerBoard __RPC_FAR * This,
            /* [in] */ BSTR bstrDirection);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SquaresX )( 
            IDXTCheckerBoard __RPC_FAR * This,
            /* [retval][out] */ int __RPC_FAR *pnSquaresX);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_SquaresX )( 
            IDXTCheckerBoard __RPC_FAR * This,
            /* [in] */ int nSquaresX);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SquaresY )( 
            IDXTCheckerBoard __RPC_FAR * This,
            /* [retval][out] */ int __RPC_FAR *pnSquaresY);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_SquaresY )( 
            IDXTCheckerBoard __RPC_FAR * This,
            /* [in] */ int nSquaresY);
        
        END_INTERFACE
    } IDXTCheckerBoardVtbl;

    interface IDXTCheckerBoard
    {
        CONST_VTBL struct IDXTCheckerBoardVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTCheckerBoard_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTCheckerBoard_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTCheckerBoard_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTCheckerBoard_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTCheckerBoard_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTCheckerBoard_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTCheckerBoard_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTCheckerBoard_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IDXTCheckerBoard_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IDXTCheckerBoard_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IDXTCheckerBoard_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IDXTCheckerBoard_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IDXTCheckerBoard_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define IDXTCheckerBoard_get_Direction(This,pbstrDirection)	\
    (This)->lpVtbl -> get_Direction(This,pbstrDirection)

#define IDXTCheckerBoard_put_Direction(This,bstrDirection)	\
    (This)->lpVtbl -> put_Direction(This,bstrDirection)

#define IDXTCheckerBoard_get_SquaresX(This,pnSquaresX)	\
    (This)->lpVtbl -> get_SquaresX(This,pnSquaresX)

#define IDXTCheckerBoard_put_SquaresX(This,nSquaresX)	\
    (This)->lpVtbl -> put_SquaresX(This,nSquaresX)

#define IDXTCheckerBoard_get_SquaresY(This,pnSquaresY)	\
    (This)->lpVtbl -> get_SquaresY(This,pnSquaresY)

#define IDXTCheckerBoard_put_SquaresY(This,nSquaresY)	\
    (This)->lpVtbl -> put_SquaresY(This,nSquaresY)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTCheckerBoard_get_Direction_Proxy( 
    IDXTCheckerBoard __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrDirection);


void __RPC_STUB IDXTCheckerBoard_get_Direction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTCheckerBoard_put_Direction_Proxy( 
    IDXTCheckerBoard __RPC_FAR * This,
    /* [in] */ BSTR bstrDirection);


void __RPC_STUB IDXTCheckerBoard_put_Direction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTCheckerBoard_get_SquaresX_Proxy( 
    IDXTCheckerBoard __RPC_FAR * This,
    /* [retval][out] */ int __RPC_FAR *pnSquaresX);


void __RPC_STUB IDXTCheckerBoard_get_SquaresX_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTCheckerBoard_put_SquaresX_Proxy( 
    IDXTCheckerBoard __RPC_FAR * This,
    /* [in] */ int nSquaresX);


void __RPC_STUB IDXTCheckerBoard_put_SquaresX_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTCheckerBoard_get_SquaresY_Proxy( 
    IDXTCheckerBoard __RPC_FAR * This,
    /* [retval][out] */ int __RPC_FAR *pnSquaresY);


void __RPC_STUB IDXTCheckerBoard_get_SquaresY_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTCheckerBoard_put_SquaresY_Proxy( 
    IDXTCheckerBoard __RPC_FAR * This,
    /* [in] */ int nSquaresY);


void __RPC_STUB IDXTCheckerBoard_put_SquaresY_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTCheckerBoard_INTERFACE_DEFINED__ */


#ifndef __IDXTRevealTrans_INTERFACE_DEFINED__
#define __IDXTRevealTrans_INTERFACE_DEFINED__

/* interface IDXTRevealTrans */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTRevealTrans;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B8095006-A128-464B-8B2D-90580AEE2B05")
    IDXTRevealTrans : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Transition( 
            /* [retval][out] */ int __RPC_FAR *pnTransition) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Transition( 
            /* [in] */ int nTransition) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTRevealTransVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTRevealTrans __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTRevealTrans __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTRevealTrans __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDXTRevealTrans __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDXTRevealTrans __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDXTRevealTrans __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDXTRevealTrans __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            IDXTRevealTrans __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            IDXTRevealTrans __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            IDXTRevealTrans __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            IDXTRevealTrans __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            IDXTRevealTrans __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            IDXTRevealTrans __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Transition )( 
            IDXTRevealTrans __RPC_FAR * This,
            /* [retval][out] */ int __RPC_FAR *pnTransition);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Transition )( 
            IDXTRevealTrans __RPC_FAR * This,
            /* [in] */ int nTransition);
        
        END_INTERFACE
    } IDXTRevealTransVtbl;

    interface IDXTRevealTrans
    {
        CONST_VTBL struct IDXTRevealTransVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTRevealTrans_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTRevealTrans_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTRevealTrans_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTRevealTrans_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTRevealTrans_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTRevealTrans_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTRevealTrans_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTRevealTrans_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IDXTRevealTrans_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IDXTRevealTrans_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IDXTRevealTrans_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IDXTRevealTrans_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IDXTRevealTrans_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define IDXTRevealTrans_get_Transition(This,pnTransition)	\
    (This)->lpVtbl -> get_Transition(This,pnTransition)

#define IDXTRevealTrans_put_Transition(This,nTransition)	\
    (This)->lpVtbl -> put_Transition(This,nTransition)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTRevealTrans_get_Transition_Proxy( 
    IDXTRevealTrans __RPC_FAR * This,
    /* [retval][out] */ int __RPC_FAR *pnTransition);


void __RPC_STUB IDXTRevealTrans_get_Transition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTRevealTrans_put_Transition_Proxy( 
    IDXTRevealTrans __RPC_FAR * This,
    /* [in] */ int nTransition);


void __RPC_STUB IDXTRevealTrans_put_Transition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTRevealTrans_INTERFACE_DEFINED__ */


#ifndef __IDXTMask_INTERFACE_DEFINED__
#define __IDXTMask_INTERFACE_DEFINED__

/* interface IDXTMask */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTMask;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A1067146-B063-47d7-A54A-2C2309E9889D")
    IDXTMask : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Color( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvarColor) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Color( 
            /* [in] */ VARIANT varColor) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTMaskVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTMask __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTMask __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTMask __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDXTMask __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDXTMask __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDXTMask __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDXTMask __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Color )( 
            IDXTMask __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarColor);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Color )( 
            IDXTMask __RPC_FAR * This,
            /* [in] */ VARIANT varColor);
        
        END_INTERFACE
    } IDXTMaskVtbl;

    interface IDXTMask
    {
        CONST_VTBL struct IDXTMaskVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTMask_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTMask_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTMask_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTMask_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTMask_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTMask_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTMask_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTMask_get_Color(This,pvarColor)	\
    (This)->lpVtbl -> get_Color(This,pvarColor)

#define IDXTMask_put_Color(This,varColor)	\
    (This)->lpVtbl -> put_Color(This,varColor)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTMask_get_Color_Proxy( 
    IDXTMask __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarColor);


void __RPC_STUB IDXTMask_get_Color_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTMask_put_Color_Proxy( 
    IDXTMask __RPC_FAR * This,
    /* [in] */ VARIANT varColor);


void __RPC_STUB IDXTMask_put_Color_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTMask_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxtmsft_0214 */
/* [local] */ 

typedef 
enum DISPID_DXTALPHAIMAGELOADER
    {	DISPID_DXTALPHAIMAGELOADER_SRC	= 1,
	DISPID_DXTALPHAIMAGELOADER_SIZINGMETHOD	= DISPID_DXTALPHAIMAGELOADER_SRC + 1
    }	DISPID_DXTALPHAIMAGELOADER;



extern RPC_IF_HANDLE __MIDL_itf_dxtmsft_0214_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtmsft_0214_v0_0_s_ifspec;

#ifndef __IDXTAlphaImageLoader_INTERFACE_DEFINED__
#define __IDXTAlphaImageLoader_INTERFACE_DEFINED__

/* interface IDXTAlphaImageLoader */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTAlphaImageLoader;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A5F2D3E8-7A7E-48E5-BC75-40790BE4A941")
    IDXTAlphaImageLoader : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Src( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrSrc) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Src( 
            /* [in] */ BSTR bstrSrc) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_SizingMethod( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrSizingMethod) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_SizingMethod( 
            /* [in] */ BSTR bstrSizingMethod) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTAlphaImageLoaderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTAlphaImageLoader __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTAlphaImageLoader __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTAlphaImageLoader __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDXTAlphaImageLoader __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDXTAlphaImageLoader __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDXTAlphaImageLoader __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDXTAlphaImageLoader __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Src )( 
            IDXTAlphaImageLoader __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrSrc);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Src )( 
            IDXTAlphaImageLoader __RPC_FAR * This,
            /* [in] */ BSTR bstrSrc);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SizingMethod )( 
            IDXTAlphaImageLoader __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrSizingMethod);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_SizingMethod )( 
            IDXTAlphaImageLoader __RPC_FAR * This,
            /* [in] */ BSTR bstrSizingMethod);
        
        END_INTERFACE
    } IDXTAlphaImageLoaderVtbl;

    interface IDXTAlphaImageLoader
    {
        CONST_VTBL struct IDXTAlphaImageLoaderVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTAlphaImageLoader_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTAlphaImageLoader_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTAlphaImageLoader_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTAlphaImageLoader_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTAlphaImageLoader_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTAlphaImageLoader_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTAlphaImageLoader_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTAlphaImageLoader_get_Src(This,pbstrSrc)	\
    (This)->lpVtbl -> get_Src(This,pbstrSrc)

#define IDXTAlphaImageLoader_put_Src(This,bstrSrc)	\
    (This)->lpVtbl -> put_Src(This,bstrSrc)

#define IDXTAlphaImageLoader_get_SizingMethod(This,pbstrSizingMethod)	\
    (This)->lpVtbl -> get_SizingMethod(This,pbstrSizingMethod)

#define IDXTAlphaImageLoader_put_SizingMethod(This,bstrSizingMethod)	\
    (This)->lpVtbl -> put_SizingMethod(This,bstrSizingMethod)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTAlphaImageLoader_get_Src_Proxy( 
    IDXTAlphaImageLoader __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrSrc);


void __RPC_STUB IDXTAlphaImageLoader_get_Src_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTAlphaImageLoader_put_Src_Proxy( 
    IDXTAlphaImageLoader __RPC_FAR * This,
    /* [in] */ BSTR bstrSrc);


void __RPC_STUB IDXTAlphaImageLoader_put_Src_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTAlphaImageLoader_get_SizingMethod_Proxy( 
    IDXTAlphaImageLoader __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrSizingMethod);


void __RPC_STUB IDXTAlphaImageLoader_get_SizingMethod_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTAlphaImageLoader_put_SizingMethod_Proxy( 
    IDXTAlphaImageLoader __RPC_FAR * This,
    /* [in] */ BSTR bstrSizingMethod);


void __RPC_STUB IDXTAlphaImageLoader_put_SizingMethod_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTAlphaImageLoader_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxtmsft_0215 */
/* [local] */ 

typedef 
enum DISPID_DXTRANDOMBARS
    {	DISPID_DXTRANDOMBARS_ORIENTATION	= 1
    }	DISPID_DXTRANDOMBARS;



extern RPC_IF_HANDLE __MIDL_itf_dxtmsft_0215_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtmsft_0215_v0_0_s_ifspec;

#ifndef __IDXTRandomBars_INTERFACE_DEFINED__
#define __IDXTRandomBars_INTERFACE_DEFINED__

/* interface IDXTRandomBars */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTRandomBars;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8A6D2022-4A8F-4EB9-BB25-AA05201F9C84")
    IDXTRandomBars : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Orientation( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrOrientation) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Orientation( 
            /* [in] */ BSTR bstrOrientation) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTRandomBarsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTRandomBars __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTRandomBars __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTRandomBars __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDXTRandomBars __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDXTRandomBars __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDXTRandomBars __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDXTRandomBars __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            IDXTRandomBars __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            IDXTRandomBars __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            IDXTRandomBars __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            IDXTRandomBars __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            IDXTRandomBars __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            IDXTRandomBars __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Orientation )( 
            IDXTRandomBars __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrOrientation);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Orientation )( 
            IDXTRandomBars __RPC_FAR * This,
            /* [in] */ BSTR bstrOrientation);
        
        END_INTERFACE
    } IDXTRandomBarsVtbl;

    interface IDXTRandomBars
    {
        CONST_VTBL struct IDXTRandomBarsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTRandomBars_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTRandomBars_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTRandomBars_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTRandomBars_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTRandomBars_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTRandomBars_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTRandomBars_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTRandomBars_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IDXTRandomBars_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IDXTRandomBars_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IDXTRandomBars_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IDXTRandomBars_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IDXTRandomBars_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define IDXTRandomBars_get_Orientation(This,pbstrOrientation)	\
    (This)->lpVtbl -> get_Orientation(This,pbstrOrientation)

#define IDXTRandomBars_put_Orientation(This,bstrOrientation)	\
    (This)->lpVtbl -> put_Orientation(This,bstrOrientation)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTRandomBars_get_Orientation_Proxy( 
    IDXTRandomBars __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrOrientation);


void __RPC_STUB IDXTRandomBars_get_Orientation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTRandomBars_put_Orientation_Proxy( 
    IDXTRandomBars __RPC_FAR * This,
    /* [in] */ BSTR bstrOrientation);


void __RPC_STUB IDXTRandomBars_put_Orientation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTRandomBars_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxtmsft_0216 */
/* [local] */ 

typedef 
enum DISPID_DXTSTRIPS
    {	DISPID_DXTSTRIPS_MOTION	= 1
    }	DISPID_DXTSTRIPS;



extern RPC_IF_HANDLE __MIDL_itf_dxtmsft_0216_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtmsft_0216_v0_0_s_ifspec;

#ifndef __IDXTStrips_INTERFACE_DEFINED__
#define __IDXTStrips_INTERFACE_DEFINED__

/* interface IDXTStrips */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTStrips;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A83C9B5C-FB11-4AF5-8F65-D03F151D3ED5")
    IDXTStrips : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Motion( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrMotion) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Motion( 
            /* [in] */ BSTR bstrMotion) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTStripsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTStrips __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTStrips __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTStrips __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDXTStrips __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDXTStrips __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDXTStrips __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDXTStrips __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            IDXTStrips __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            IDXTStrips __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            IDXTStrips __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            IDXTStrips __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            IDXTStrips __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            IDXTStrips __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Motion )( 
            IDXTStrips __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrMotion);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Motion )( 
            IDXTStrips __RPC_FAR * This,
            /* [in] */ BSTR bstrMotion);
        
        END_INTERFACE
    } IDXTStripsVtbl;

    interface IDXTStrips
    {
        CONST_VTBL struct IDXTStripsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTStrips_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTStrips_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTStrips_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTStrips_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTStrips_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTStrips_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTStrips_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTStrips_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IDXTStrips_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IDXTStrips_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IDXTStrips_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IDXTStrips_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IDXTStrips_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define IDXTStrips_get_Motion(This,pbstrMotion)	\
    (This)->lpVtbl -> get_Motion(This,pbstrMotion)

#define IDXTStrips_put_Motion(This,bstrMotion)	\
    (This)->lpVtbl -> put_Motion(This,bstrMotion)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTStrips_get_Motion_Proxy( 
    IDXTStrips __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrMotion);


void __RPC_STUB IDXTStrips_get_Motion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTStrips_put_Motion_Proxy( 
    IDXTStrips __RPC_FAR * This,
    /* [in] */ BSTR bstrMotion);


void __RPC_STUB IDXTStrips_put_Motion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTStrips_INTERFACE_DEFINED__ */


#ifndef __IDXTAlpha_INTERFACE_DEFINED__
#define __IDXTAlpha_INTERFACE_DEFINED__

/* interface IDXTAlpha */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTAlpha;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1D4637E0-383C-11d2-952A-00C04FA34F05")
    IDXTAlpha : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Opacity( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Opacity( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_FinishOpacity( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_FinishOpacity( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Style( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Style( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_StartX( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_StartX( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_StartY( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_StartY( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_FinishX( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_FinishX( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_FinishY( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_FinishY( 
            /* [in] */ long newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTAlphaVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTAlpha __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTAlpha __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTAlpha __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDXTAlpha __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDXTAlpha __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDXTAlpha __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDXTAlpha __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Opacity )( 
            IDXTAlpha __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Opacity )( 
            IDXTAlpha __RPC_FAR * This,
            /* [in] */ long newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_FinishOpacity )( 
            IDXTAlpha __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_FinishOpacity )( 
            IDXTAlpha __RPC_FAR * This,
            /* [in] */ long newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Style )( 
            IDXTAlpha __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Style )( 
            IDXTAlpha __RPC_FAR * This,
            /* [in] */ long newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StartX )( 
            IDXTAlpha __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_StartX )( 
            IDXTAlpha __RPC_FAR * This,
            /* [in] */ long newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StartY )( 
            IDXTAlpha __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_StartY )( 
            IDXTAlpha __RPC_FAR * This,
            /* [in] */ long newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_FinishX )( 
            IDXTAlpha __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_FinishX )( 
            IDXTAlpha __RPC_FAR * This,
            /* [in] */ long newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_FinishY )( 
            IDXTAlpha __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_FinishY )( 
            IDXTAlpha __RPC_FAR * This,
            /* [in] */ long newVal);
        
        END_INTERFACE
    } IDXTAlphaVtbl;

    interface IDXTAlpha
    {
        CONST_VTBL struct IDXTAlphaVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTAlpha_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTAlpha_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTAlpha_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTAlpha_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTAlpha_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTAlpha_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTAlpha_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTAlpha_get_Opacity(This,pVal)	\
    (This)->lpVtbl -> get_Opacity(This,pVal)

#define IDXTAlpha_put_Opacity(This,newVal)	\
    (This)->lpVtbl -> put_Opacity(This,newVal)

#define IDXTAlpha_get_FinishOpacity(This,pVal)	\
    (This)->lpVtbl -> get_FinishOpacity(This,pVal)

#define IDXTAlpha_put_FinishOpacity(This,newVal)	\
    (This)->lpVtbl -> put_FinishOpacity(This,newVal)

#define IDXTAlpha_get_Style(This,pVal)	\
    (This)->lpVtbl -> get_Style(This,pVal)

#define IDXTAlpha_put_Style(This,newVal)	\
    (This)->lpVtbl -> put_Style(This,newVal)

#define IDXTAlpha_get_StartX(This,pVal)	\
    (This)->lpVtbl -> get_StartX(This,pVal)

#define IDXTAlpha_put_StartX(This,newVal)	\
    (This)->lpVtbl -> put_StartX(This,newVal)

#define IDXTAlpha_get_StartY(This,pVal)	\
    (This)->lpVtbl -> get_StartY(This,pVal)

#define IDXTAlpha_put_StartY(This,newVal)	\
    (This)->lpVtbl -> put_StartY(This,newVal)

#define IDXTAlpha_get_FinishX(This,pVal)	\
    (This)->lpVtbl -> get_FinishX(This,pVal)

#define IDXTAlpha_put_FinishX(This,newVal)	\
    (This)->lpVtbl -> put_FinishX(This,newVal)

#define IDXTAlpha_get_FinishY(This,pVal)	\
    (This)->lpVtbl -> get_FinishY(This,pVal)

#define IDXTAlpha_put_FinishY(This,newVal)	\
    (This)->lpVtbl -> put_FinishY(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTAlpha_get_Opacity_Proxy( 
    IDXTAlpha __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IDXTAlpha_get_Opacity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTAlpha_put_Opacity_Proxy( 
    IDXTAlpha __RPC_FAR * This,
    /* [in] */ long newVal);


void __RPC_STUB IDXTAlpha_put_Opacity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTAlpha_get_FinishOpacity_Proxy( 
    IDXTAlpha __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IDXTAlpha_get_FinishOpacity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTAlpha_put_FinishOpacity_Proxy( 
    IDXTAlpha __RPC_FAR * This,
    /* [in] */ long newVal);


void __RPC_STUB IDXTAlpha_put_FinishOpacity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTAlpha_get_Style_Proxy( 
    IDXTAlpha __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IDXTAlpha_get_Style_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTAlpha_put_Style_Proxy( 
    IDXTAlpha __RPC_FAR * This,
    /* [in] */ long newVal);


void __RPC_STUB IDXTAlpha_put_Style_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTAlpha_get_StartX_Proxy( 
    IDXTAlpha __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IDXTAlpha_get_StartX_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTAlpha_put_StartX_Proxy( 
    IDXTAlpha __RPC_FAR * This,
    /* [in] */ long newVal);


void __RPC_STUB IDXTAlpha_put_StartX_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTAlpha_get_StartY_Proxy( 
    IDXTAlpha __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IDXTAlpha_get_StartY_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTAlpha_put_StartY_Proxy( 
    IDXTAlpha __RPC_FAR * This,
    /* [in] */ long newVal);


void __RPC_STUB IDXTAlpha_put_StartY_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTAlpha_get_FinishX_Proxy( 
    IDXTAlpha __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IDXTAlpha_get_FinishX_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTAlpha_put_FinishX_Proxy( 
    IDXTAlpha __RPC_FAR * This,
    /* [in] */ long newVal);


void __RPC_STUB IDXTAlpha_put_FinishX_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTAlpha_get_FinishY_Proxy( 
    IDXTAlpha __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IDXTAlpha_get_FinishY_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTAlpha_put_FinishY_Proxy( 
    IDXTAlpha __RPC_FAR * This,
    /* [in] */ long newVal);


void __RPC_STUB IDXTAlpha_put_FinishY_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTAlpha_INTERFACE_DEFINED__ */


#ifndef __IDXTGlow_INTERFACE_DEFINED__
#define __IDXTGlow_INTERFACE_DEFINED__

/* interface IDXTGlow */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTGlow;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1D4637E4-383C-11d2-952A-00C04FA34F05")
    IDXTGlow : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Color( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvarColor) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Color( 
            /* [in] */ VARIANT varColor) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Strength( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Strength( 
            /* [in] */ long newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTGlowVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTGlow __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTGlow __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTGlow __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDXTGlow __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDXTGlow __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDXTGlow __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDXTGlow __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Color )( 
            IDXTGlow __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarColor);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Color )( 
            IDXTGlow __RPC_FAR * This,
            /* [in] */ VARIANT varColor);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Strength )( 
            IDXTGlow __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Strength )( 
            IDXTGlow __RPC_FAR * This,
            /* [in] */ long newVal);
        
        END_INTERFACE
    } IDXTGlowVtbl;

    interface IDXTGlow
    {
        CONST_VTBL struct IDXTGlowVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTGlow_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTGlow_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTGlow_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTGlow_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTGlow_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTGlow_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTGlow_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTGlow_get_Color(This,pvarColor)	\
    (This)->lpVtbl -> get_Color(This,pvarColor)

#define IDXTGlow_put_Color(This,varColor)	\
    (This)->lpVtbl -> put_Color(This,varColor)

#define IDXTGlow_get_Strength(This,pVal)	\
    (This)->lpVtbl -> get_Strength(This,pVal)

#define IDXTGlow_put_Strength(This,newVal)	\
    (This)->lpVtbl -> put_Strength(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTGlow_get_Color_Proxy( 
    IDXTGlow __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarColor);


void __RPC_STUB IDXTGlow_get_Color_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTGlow_put_Color_Proxy( 
    IDXTGlow __RPC_FAR * This,
    /* [in] */ VARIANT varColor);


void __RPC_STUB IDXTGlow_put_Color_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTGlow_get_Strength_Proxy( 
    IDXTGlow __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IDXTGlow_get_Strength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTGlow_put_Strength_Proxy( 
    IDXTGlow __RPC_FAR * This,
    /* [in] */ long newVal);


void __RPC_STUB IDXTGlow_put_Strength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTGlow_INTERFACE_DEFINED__ */


#ifndef __IDXTShadow_INTERFACE_DEFINED__
#define __IDXTShadow_INTERFACE_DEFINED__

/* interface IDXTShadow */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTShadow;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1D4637E6-383C-11d2-952A-00C04FA34F05")
    IDXTShadow : public IDispatch
    {
    public:
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Color( 
            /* [in] */ BSTR bstrColor) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Color( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrColor) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Direction( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Direction( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Strength( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Strength( 
            /* [in] */ long newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTShadowVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTShadow __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTShadow __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTShadow __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDXTShadow __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDXTShadow __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDXTShadow __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDXTShadow __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Color )( 
            IDXTShadow __RPC_FAR * This,
            /* [in] */ BSTR bstrColor);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Color )( 
            IDXTShadow __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrColor);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Direction )( 
            IDXTShadow __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Direction )( 
            IDXTShadow __RPC_FAR * This,
            /* [in] */ long newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Strength )( 
            IDXTShadow __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Strength )( 
            IDXTShadow __RPC_FAR * This,
            /* [in] */ long newVal);
        
        END_INTERFACE
    } IDXTShadowVtbl;

    interface IDXTShadow
    {
        CONST_VTBL struct IDXTShadowVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTShadow_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTShadow_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTShadow_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTShadow_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTShadow_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTShadow_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTShadow_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTShadow_put_Color(This,bstrColor)	\
    (This)->lpVtbl -> put_Color(This,bstrColor)

#define IDXTShadow_get_Color(This,pbstrColor)	\
    (This)->lpVtbl -> get_Color(This,pbstrColor)

#define IDXTShadow_get_Direction(This,pVal)	\
    (This)->lpVtbl -> get_Direction(This,pVal)

#define IDXTShadow_put_Direction(This,newVal)	\
    (This)->lpVtbl -> put_Direction(This,newVal)

#define IDXTShadow_get_Strength(This,pVal)	\
    (This)->lpVtbl -> get_Strength(This,pVal)

#define IDXTShadow_put_Strength(This,newVal)	\
    (This)->lpVtbl -> put_Strength(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTShadow_put_Color_Proxy( 
    IDXTShadow __RPC_FAR * This,
    /* [in] */ BSTR bstrColor);


void __RPC_STUB IDXTShadow_put_Color_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTShadow_get_Color_Proxy( 
    IDXTShadow __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrColor);


void __RPC_STUB IDXTShadow_get_Color_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTShadow_get_Direction_Proxy( 
    IDXTShadow __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IDXTShadow_get_Direction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTShadow_put_Direction_Proxy( 
    IDXTShadow __RPC_FAR * This,
    /* [in] */ long newVal);


void __RPC_STUB IDXTShadow_put_Direction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTShadow_get_Strength_Proxy( 
    IDXTShadow __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IDXTShadow_get_Strength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTShadow_put_Strength_Proxy( 
    IDXTShadow __RPC_FAR * This,
    /* [in] */ long newVal);


void __RPC_STUB IDXTShadow_put_Strength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTShadow_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxtmsft_0220 */
/* [local] */ 

typedef 
enum DISPID_DXTWAVE
    {	DISPID_DXTWAVE_ADD	= 1,
	DISPID_DXTWAVE_FREQ	= DISPID_DXTWAVE_ADD + 1,
	DISPID_DXTWAVE_LIGHTSTRENGTH	= DISPID_DXTWAVE_FREQ + 1,
	DISPID_DXTWAVE_PHASE	= DISPID_DXTWAVE_LIGHTSTRENGTH + 1,
	DISPID_DXTWAVE_STRENGTH	= DISPID_DXTWAVE_PHASE + 1
    }	DISPID_DXTWAVE;



extern RPC_IF_HANDLE __MIDL_itf_dxtmsft_0220_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtmsft_0220_v0_0_s_ifspec;

#ifndef __IDXTWave_INTERFACE_DEFINED__
#define __IDXTWave_INTERFACE_DEFINED__

/* interface IDXTWave */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTWave;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1D4637E7-383C-11d2-952A-00C04FA34F05")
    IDXTWave : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Add( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Add( 
            /* [in] */ VARIANT_BOOL newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Freq( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Freq( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_LightStrength( 
            /* [retval][out] */ int __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_LightStrength( 
            /* [in] */ int newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Phase( 
            /* [retval][out] */ int __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Phase( 
            /* [in] */ int newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Strength( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Strength( 
            /* [in] */ long newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTWaveVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTWave __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTWave __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTWave __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDXTWave __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDXTWave __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDXTWave __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDXTWave __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Add )( 
            IDXTWave __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Add )( 
            IDXTWave __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Freq )( 
            IDXTWave __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Freq )( 
            IDXTWave __RPC_FAR * This,
            /* [in] */ long newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_LightStrength )( 
            IDXTWave __RPC_FAR * This,
            /* [retval][out] */ int __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_LightStrength )( 
            IDXTWave __RPC_FAR * This,
            /* [in] */ int newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Phase )( 
            IDXTWave __RPC_FAR * This,
            /* [retval][out] */ int __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Phase )( 
            IDXTWave __RPC_FAR * This,
            /* [in] */ int newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Strength )( 
            IDXTWave __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Strength )( 
            IDXTWave __RPC_FAR * This,
            /* [in] */ long newVal);
        
        END_INTERFACE
    } IDXTWaveVtbl;

    interface IDXTWave
    {
        CONST_VTBL struct IDXTWaveVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTWave_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTWave_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTWave_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTWave_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTWave_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTWave_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTWave_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTWave_get_Add(This,pVal)	\
    (This)->lpVtbl -> get_Add(This,pVal)

#define IDXTWave_put_Add(This,newVal)	\
    (This)->lpVtbl -> put_Add(This,newVal)

#define IDXTWave_get_Freq(This,pVal)	\
    (This)->lpVtbl -> get_Freq(This,pVal)

#define IDXTWave_put_Freq(This,newVal)	\
    (This)->lpVtbl -> put_Freq(This,newVal)

#define IDXTWave_get_LightStrength(This,pVal)	\
    (This)->lpVtbl -> get_LightStrength(This,pVal)

#define IDXTWave_put_LightStrength(This,newVal)	\
    (This)->lpVtbl -> put_LightStrength(This,newVal)

#define IDXTWave_get_Phase(This,pVal)	\
    (This)->lpVtbl -> get_Phase(This,pVal)

#define IDXTWave_put_Phase(This,newVal)	\
    (This)->lpVtbl -> put_Phase(This,newVal)

#define IDXTWave_get_Strength(This,pVal)	\
    (This)->lpVtbl -> get_Strength(This,pVal)

#define IDXTWave_put_Strength(This,newVal)	\
    (This)->lpVtbl -> put_Strength(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTWave_get_Add_Proxy( 
    IDXTWave __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);


void __RPC_STUB IDXTWave_get_Add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTWave_put_Add_Proxy( 
    IDXTWave __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL newVal);


void __RPC_STUB IDXTWave_put_Add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTWave_get_Freq_Proxy( 
    IDXTWave __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IDXTWave_get_Freq_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTWave_put_Freq_Proxy( 
    IDXTWave __RPC_FAR * This,
    /* [in] */ long newVal);


void __RPC_STUB IDXTWave_put_Freq_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTWave_get_LightStrength_Proxy( 
    IDXTWave __RPC_FAR * This,
    /* [retval][out] */ int __RPC_FAR *pVal);


void __RPC_STUB IDXTWave_get_LightStrength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTWave_put_LightStrength_Proxy( 
    IDXTWave __RPC_FAR * This,
    /* [in] */ int newVal);


void __RPC_STUB IDXTWave_put_LightStrength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTWave_get_Phase_Proxy( 
    IDXTWave __RPC_FAR * This,
    /* [retval][out] */ int __RPC_FAR *pVal);


void __RPC_STUB IDXTWave_get_Phase_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTWave_put_Phase_Proxy( 
    IDXTWave __RPC_FAR * This,
    /* [in] */ int newVal);


void __RPC_STUB IDXTWave_put_Phase_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTWave_get_Strength_Proxy( 
    IDXTWave __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IDXTWave_get_Strength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTWave_put_Strength_Proxy( 
    IDXTWave __RPC_FAR * This,
    /* [in] */ long newVal);


void __RPC_STUB IDXTWave_put_Strength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTWave_INTERFACE_DEFINED__ */


#ifndef __IDXTLight_INTERFACE_DEFINED__
#define __IDXTLight_INTERFACE_DEFINED__

/* interface IDXTLight */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTLight;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F9EFBEC1-4302-11D2-952A-00C04FA34F05")
    IDXTLight : public IDispatch
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE addAmbient( 
            int r,
            int g,
            int b,
            int strength) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE addPoint( 
            int x,
            int y,
            int z,
            int r,
            int g,
            int b,
            int strength) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE addCone( 
            int x,
            int y,
            int z,
            int tx,
            int ty,
            int r,
            int g,
            int b,
            int strength,
            int spread) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE moveLight( 
            int lightNum,
            int x,
            int y,
            int z,
            BOOL fAbsolute) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE ChangeStrength( 
            int lightNum,
            int dStrength,
            BOOL fAbsolute) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE ChangeColor( 
            int lightNum,
            int R,
            int G,
            int B,
            BOOL fAbsolute) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Clear( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTLightVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTLight __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTLight __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTLight __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDXTLight __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDXTLight __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDXTLight __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDXTLight __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *addAmbient )( 
            IDXTLight __RPC_FAR * This,
            int r,
            int g,
            int b,
            int strength);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *addPoint )( 
            IDXTLight __RPC_FAR * This,
            int x,
            int y,
            int z,
            int r,
            int g,
            int b,
            int strength);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *addCone )( 
            IDXTLight __RPC_FAR * This,
            int x,
            int y,
            int z,
            int tx,
            int ty,
            int r,
            int g,
            int b,
            int strength,
            int spread);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *moveLight )( 
            IDXTLight __RPC_FAR * This,
            int lightNum,
            int x,
            int y,
            int z,
            BOOL fAbsolute);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ChangeStrength )( 
            IDXTLight __RPC_FAR * This,
            int lightNum,
            int dStrength,
            BOOL fAbsolute);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ChangeColor )( 
            IDXTLight __RPC_FAR * This,
            int lightNum,
            int R,
            int G,
            int B,
            BOOL fAbsolute);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clear )( 
            IDXTLight __RPC_FAR * This);
        
        END_INTERFACE
    } IDXTLightVtbl;

    interface IDXTLight
    {
        CONST_VTBL struct IDXTLightVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTLight_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTLight_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTLight_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTLight_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTLight_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTLight_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTLight_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTLight_addAmbient(This,r,g,b,strength)	\
    (This)->lpVtbl -> addAmbient(This,r,g,b,strength)

#define IDXTLight_addPoint(This,x,y,z,r,g,b,strength)	\
    (This)->lpVtbl -> addPoint(This,x,y,z,r,g,b,strength)

#define IDXTLight_addCone(This,x,y,z,tx,ty,r,g,b,strength,spread)	\
    (This)->lpVtbl -> addCone(This,x,y,z,tx,ty,r,g,b,strength,spread)

#define IDXTLight_moveLight(This,lightNum,x,y,z,fAbsolute)	\
    (This)->lpVtbl -> moveLight(This,lightNum,x,y,z,fAbsolute)

#define IDXTLight_ChangeStrength(This,lightNum,dStrength,fAbsolute)	\
    (This)->lpVtbl -> ChangeStrength(This,lightNum,dStrength,fAbsolute)

#define IDXTLight_ChangeColor(This,lightNum,R,G,B,fAbsolute)	\
    (This)->lpVtbl -> ChangeColor(This,lightNum,R,G,B,fAbsolute)

#define IDXTLight_Clear(This)	\
    (This)->lpVtbl -> Clear(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id] */ HRESULT STDMETHODCALLTYPE IDXTLight_addAmbient_Proxy( 
    IDXTLight __RPC_FAR * This,
    int r,
    int g,
    int b,
    int strength);


void __RPC_STUB IDXTLight_addAmbient_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IDXTLight_addPoint_Proxy( 
    IDXTLight __RPC_FAR * This,
    int x,
    int y,
    int z,
    int r,
    int g,
    int b,
    int strength);


void __RPC_STUB IDXTLight_addPoint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IDXTLight_addCone_Proxy( 
    IDXTLight __RPC_FAR * This,
    int x,
    int y,
    int z,
    int tx,
    int ty,
    int r,
    int g,
    int b,
    int strength,
    int spread);


void __RPC_STUB IDXTLight_addCone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IDXTLight_moveLight_Proxy( 
    IDXTLight __RPC_FAR * This,
    int lightNum,
    int x,
    int y,
    int z,
    BOOL fAbsolute);


void __RPC_STUB IDXTLight_moveLight_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IDXTLight_ChangeStrength_Proxy( 
    IDXTLight __RPC_FAR * This,
    int lightNum,
    int dStrength,
    BOOL fAbsolute);


void __RPC_STUB IDXTLight_ChangeStrength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IDXTLight_ChangeColor_Proxy( 
    IDXTLight __RPC_FAR * This,
    int lightNum,
    int R,
    int G,
    int B,
    BOOL fAbsolute);


void __RPC_STUB IDXTLight_ChangeColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IDXTLight_Clear_Proxy( 
    IDXTLight __RPC_FAR * This);


void __RPC_STUB IDXTLight_Clear_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTLight_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxtmsft_0222 */
/* [local] */ 

typedef 
enum DISPID_DXTMOTIONBLUR
    {	DISPID_DXTMOTIONBLUR_ADD	= 1,
	DISPID_DXTMOTIONBLUR_DIRECTION	= DISPID_DXTMOTIONBLUR_ADD + 1,
	DISPID_DXTMOTIONBLUR_STRENGTH	= DISPID_DXTMOTIONBLUR_DIRECTION + 1
    }	DISPID_DXTMOTIONBLUR;



extern RPC_IF_HANDLE __MIDL_itf_dxtmsft_0222_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtmsft_0222_v0_0_s_ifspec;

#ifndef __IDXTMotionBlur_INTERFACE_DEFINED__
#define __IDXTMotionBlur_INTERFACE_DEFINED__

/* interface IDXTMotionBlur */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTMotionBlur;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("089057BE-D3F5-4A2C-B10A-A5130184A0F7")
    IDXTMotionBlur : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Add( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfAdd) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Add( 
            /* [in] */ VARIANT_BOOL fAdd) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Direction( 
            /* [retval][out] */ short __RPC_FAR *pnDirection) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Direction( 
            /* [in] */ short nDirection) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Strength( 
            /* [retval][out] */ long __RPC_FAR *pnStrength) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Strength( 
            /* [in] */ long nStrength) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTMotionBlurVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTMotionBlur __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTMotionBlur __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTMotionBlur __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDXTMotionBlur __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDXTMotionBlur __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDXTMotionBlur __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDXTMotionBlur __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Add )( 
            IDXTMotionBlur __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfAdd);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Add )( 
            IDXTMotionBlur __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL fAdd);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Direction )( 
            IDXTMotionBlur __RPC_FAR * This,
            /* [retval][out] */ short __RPC_FAR *pnDirection);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Direction )( 
            IDXTMotionBlur __RPC_FAR * This,
            /* [in] */ short nDirection);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Strength )( 
            IDXTMotionBlur __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pnStrength);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Strength )( 
            IDXTMotionBlur __RPC_FAR * This,
            /* [in] */ long nStrength);
        
        END_INTERFACE
    } IDXTMotionBlurVtbl;

    interface IDXTMotionBlur
    {
        CONST_VTBL struct IDXTMotionBlurVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTMotionBlur_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTMotionBlur_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTMotionBlur_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTMotionBlur_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTMotionBlur_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTMotionBlur_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTMotionBlur_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTMotionBlur_get_Add(This,pfAdd)	\
    (This)->lpVtbl -> get_Add(This,pfAdd)

#define IDXTMotionBlur_put_Add(This,fAdd)	\
    (This)->lpVtbl -> put_Add(This,fAdd)

#define IDXTMotionBlur_get_Direction(This,pnDirection)	\
    (This)->lpVtbl -> get_Direction(This,pnDirection)

#define IDXTMotionBlur_put_Direction(This,nDirection)	\
    (This)->lpVtbl -> put_Direction(This,nDirection)

#define IDXTMotionBlur_get_Strength(This,pnStrength)	\
    (This)->lpVtbl -> get_Strength(This,pnStrength)

#define IDXTMotionBlur_put_Strength(This,nStrength)	\
    (This)->lpVtbl -> put_Strength(This,nStrength)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTMotionBlur_get_Add_Proxy( 
    IDXTMotionBlur __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfAdd);


void __RPC_STUB IDXTMotionBlur_get_Add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTMotionBlur_put_Add_Proxy( 
    IDXTMotionBlur __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL fAdd);


void __RPC_STUB IDXTMotionBlur_put_Add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTMotionBlur_get_Direction_Proxy( 
    IDXTMotionBlur __RPC_FAR * This,
    /* [retval][out] */ short __RPC_FAR *pnDirection);


void __RPC_STUB IDXTMotionBlur_get_Direction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTMotionBlur_put_Direction_Proxy( 
    IDXTMotionBlur __RPC_FAR * This,
    /* [in] */ short nDirection);


void __RPC_STUB IDXTMotionBlur_put_Direction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTMotionBlur_get_Strength_Proxy( 
    IDXTMotionBlur __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pnStrength);


void __RPC_STUB IDXTMotionBlur_get_Strength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTMotionBlur_put_Strength_Proxy( 
    IDXTMotionBlur __RPC_FAR * This,
    /* [in] */ long nStrength);


void __RPC_STUB IDXTMotionBlur_put_Strength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTMotionBlur_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxtmsft_0223 */
/* [local] */ 

typedef 
enum DISPID_DXTMATRIX
    {	DISPID_DXTMATRIX_M11	= 1,
	DISPID_DXTMATRIX_M12	= DISPID_DXTMATRIX_M11 + 1,
	DISPID_DXTMATRIX_DX	= DISPID_DXTMATRIX_M12 + 1,
	DISPID_DXTMATRIX_M21	= DISPID_DXTMATRIX_DX + 1,
	DISPID_DXTMATRIX_M22	= DISPID_DXTMATRIX_M21 + 1,
	DISPID_DXTMATRIX_DY	= DISPID_DXTMATRIX_M22 + 1,
	DISPID_DXTMATRIX_SIZINGMETHOD	= DISPID_DXTMATRIX_DY + 1,
	DISPID_DXTMATRIX_FILTERTYPE	= DISPID_DXTMATRIX_SIZINGMETHOD + 1
    }	DISPID_DXTMATRIX;



extern RPC_IF_HANDLE __MIDL_itf_dxtmsft_0223_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtmsft_0223_v0_0_s_ifspec;

#ifndef __IDXTMatrix_INTERFACE_DEFINED__
#define __IDXTMatrix_INTERFACE_DEFINED__

/* interface IDXTMatrix */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTMatrix;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AC66A493-0F0C-4C76-825C-9D68BEDE9188")
    IDXTMatrix : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_M11( 
            /* [retval][out] */ float __RPC_FAR *pflM11) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_M11( 
            /* [in] */ const float flM11) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_M12( 
            /* [retval][out] */ float __RPC_FAR *pflM12) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_M12( 
            /* [in] */ const float flM12) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Dx( 
            /* [retval][out] */ float __RPC_FAR *pfldx) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Dx( 
            /* [in] */ const float fldx) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_M21( 
            /* [retval][out] */ float __RPC_FAR *pflM21) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_M21( 
            /* [in] */ const float flM21) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_M22( 
            /* [retval][out] */ float __RPC_FAR *pflM22) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_M22( 
            /* [in] */ const float flM22) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Dy( 
            /* [retval][out] */ float __RPC_FAR *pfldy) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Dy( 
            /* [in] */ const float fldy) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_SizingMethod( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrSizingMethod) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_SizingMethod( 
            /* [in] */ const BSTR bstrSizingMethod) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_FilterType( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrFilterType) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_FilterType( 
            /* [in] */ const BSTR bstrFilterType) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTMatrixVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTMatrix __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTMatrix __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTMatrix __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDXTMatrix __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDXTMatrix __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDXTMatrix __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDXTMatrix __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_M11 )( 
            IDXTMatrix __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pflM11);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_M11 )( 
            IDXTMatrix __RPC_FAR * This,
            /* [in] */ const float flM11);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_M12 )( 
            IDXTMatrix __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pflM12);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_M12 )( 
            IDXTMatrix __RPC_FAR * This,
            /* [in] */ const float flM12);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Dx )( 
            IDXTMatrix __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pfldx);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Dx )( 
            IDXTMatrix __RPC_FAR * This,
            /* [in] */ const float fldx);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_M21 )( 
            IDXTMatrix __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pflM21);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_M21 )( 
            IDXTMatrix __RPC_FAR * This,
            /* [in] */ const float flM21);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_M22 )( 
            IDXTMatrix __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pflM22);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_M22 )( 
            IDXTMatrix __RPC_FAR * This,
            /* [in] */ const float flM22);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Dy )( 
            IDXTMatrix __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pfldy);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Dy )( 
            IDXTMatrix __RPC_FAR * This,
            /* [in] */ const float fldy);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SizingMethod )( 
            IDXTMatrix __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrSizingMethod);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_SizingMethod )( 
            IDXTMatrix __RPC_FAR * This,
            /* [in] */ const BSTR bstrSizingMethod);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_FilterType )( 
            IDXTMatrix __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrFilterType);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_FilterType )( 
            IDXTMatrix __RPC_FAR * This,
            /* [in] */ const BSTR bstrFilterType);
        
        END_INTERFACE
    } IDXTMatrixVtbl;

    interface IDXTMatrix
    {
        CONST_VTBL struct IDXTMatrixVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTMatrix_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTMatrix_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTMatrix_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTMatrix_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTMatrix_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTMatrix_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTMatrix_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTMatrix_get_M11(This,pflM11)	\
    (This)->lpVtbl -> get_M11(This,pflM11)

#define IDXTMatrix_put_M11(This,flM11)	\
    (This)->lpVtbl -> put_M11(This,flM11)

#define IDXTMatrix_get_M12(This,pflM12)	\
    (This)->lpVtbl -> get_M12(This,pflM12)

#define IDXTMatrix_put_M12(This,flM12)	\
    (This)->lpVtbl -> put_M12(This,flM12)

#define IDXTMatrix_get_Dx(This,pfldx)	\
    (This)->lpVtbl -> get_Dx(This,pfldx)

#define IDXTMatrix_put_Dx(This,fldx)	\
    (This)->lpVtbl -> put_Dx(This,fldx)

#define IDXTMatrix_get_M21(This,pflM21)	\
    (This)->lpVtbl -> get_M21(This,pflM21)

#define IDXTMatrix_put_M21(This,flM21)	\
    (This)->lpVtbl -> put_M21(This,flM21)

#define IDXTMatrix_get_M22(This,pflM22)	\
    (This)->lpVtbl -> get_M22(This,pflM22)

#define IDXTMatrix_put_M22(This,flM22)	\
    (This)->lpVtbl -> put_M22(This,flM22)

#define IDXTMatrix_get_Dy(This,pfldy)	\
    (This)->lpVtbl -> get_Dy(This,pfldy)

#define IDXTMatrix_put_Dy(This,fldy)	\
    (This)->lpVtbl -> put_Dy(This,fldy)

#define IDXTMatrix_get_SizingMethod(This,pbstrSizingMethod)	\
    (This)->lpVtbl -> get_SizingMethod(This,pbstrSizingMethod)

#define IDXTMatrix_put_SizingMethod(This,bstrSizingMethod)	\
    (This)->lpVtbl -> put_SizingMethod(This,bstrSizingMethod)

#define IDXTMatrix_get_FilterType(This,pbstrFilterType)	\
    (This)->lpVtbl -> get_FilterType(This,pbstrFilterType)

#define IDXTMatrix_put_FilterType(This,bstrFilterType)	\
    (This)->lpVtbl -> put_FilterType(This,bstrFilterType)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTMatrix_get_M11_Proxy( 
    IDXTMatrix __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pflM11);


void __RPC_STUB IDXTMatrix_get_M11_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTMatrix_put_M11_Proxy( 
    IDXTMatrix __RPC_FAR * This,
    /* [in] */ const float flM11);


void __RPC_STUB IDXTMatrix_put_M11_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTMatrix_get_M12_Proxy( 
    IDXTMatrix __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pflM12);


void __RPC_STUB IDXTMatrix_get_M12_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTMatrix_put_M12_Proxy( 
    IDXTMatrix __RPC_FAR * This,
    /* [in] */ const float flM12);


void __RPC_STUB IDXTMatrix_put_M12_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTMatrix_get_Dx_Proxy( 
    IDXTMatrix __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pfldx);


void __RPC_STUB IDXTMatrix_get_Dx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTMatrix_put_Dx_Proxy( 
    IDXTMatrix __RPC_FAR * This,
    /* [in] */ const float fldx);


void __RPC_STUB IDXTMatrix_put_Dx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTMatrix_get_M21_Proxy( 
    IDXTMatrix __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pflM21);


void __RPC_STUB IDXTMatrix_get_M21_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTMatrix_put_M21_Proxy( 
    IDXTMatrix __RPC_FAR * This,
    /* [in] */ const float flM21);


void __RPC_STUB IDXTMatrix_put_M21_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTMatrix_get_M22_Proxy( 
    IDXTMatrix __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pflM22);


void __RPC_STUB IDXTMatrix_get_M22_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTMatrix_put_M22_Proxy( 
    IDXTMatrix __RPC_FAR * This,
    /* [in] */ const float flM22);


void __RPC_STUB IDXTMatrix_put_M22_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTMatrix_get_Dy_Proxy( 
    IDXTMatrix __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pfldy);


void __RPC_STUB IDXTMatrix_get_Dy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTMatrix_put_Dy_Proxy( 
    IDXTMatrix __RPC_FAR * This,
    /* [in] */ const float fldy);


void __RPC_STUB IDXTMatrix_put_Dy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTMatrix_get_SizingMethod_Proxy( 
    IDXTMatrix __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrSizingMethod);


void __RPC_STUB IDXTMatrix_get_SizingMethod_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTMatrix_put_SizingMethod_Proxy( 
    IDXTMatrix __RPC_FAR * This,
    /* [in] */ const BSTR bstrSizingMethod);


void __RPC_STUB IDXTMatrix_put_SizingMethod_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTMatrix_get_FilterType_Proxy( 
    IDXTMatrix __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrFilterType);


void __RPC_STUB IDXTMatrix_get_FilterType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTMatrix_put_FilterType_Proxy( 
    IDXTMatrix __RPC_FAR * This,
    /* [in] */ const BSTR bstrFilterType);


void __RPC_STUB IDXTMatrix_put_FilterType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTMatrix_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxtmsft_0224 */
/* [local] */ 

typedef 
enum DISPID_DXTICMFILTER
    {	DISPID_DXTICMFILTER_COLORSPACE	= 1,
	DISPID_DXTICMFILTER_INTENT	= DISPID_DXTICMFILTER_COLORSPACE + 1
    }	DISPID_DXTICMFILTER;



extern RPC_IF_HANDLE __MIDL_itf_dxtmsft_0224_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtmsft_0224_v0_0_s_ifspec;

#ifndef __IDXTICMFilter_INTERFACE_DEFINED__
#define __IDXTICMFilter_INTERFACE_DEFINED__

/* interface IDXTICMFilter */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTICMFilter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("734321ED-1E7B-4E1C-BBFA-89C819800E2F")
    IDXTICMFilter : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_ColorSpace( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrColorSpace) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_ColorSpace( 
            /* [in] */ BSTR bstrColorSpace) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Intent( 
            /* [retval][out] */ short __RPC_FAR *pnIntent) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Intent( 
            /* [in] */ short nIntent) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTICMFilterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTICMFilter __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTICMFilter __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTICMFilter __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDXTICMFilter __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDXTICMFilter __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDXTICMFilter __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDXTICMFilter __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ColorSpace )( 
            IDXTICMFilter __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrColorSpace);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ColorSpace )( 
            IDXTICMFilter __RPC_FAR * This,
            /* [in] */ BSTR bstrColorSpace);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Intent )( 
            IDXTICMFilter __RPC_FAR * This,
            /* [retval][out] */ short __RPC_FAR *pnIntent);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Intent )( 
            IDXTICMFilter __RPC_FAR * This,
            /* [in] */ short nIntent);
        
        END_INTERFACE
    } IDXTICMFilterVtbl;

    interface IDXTICMFilter
    {
        CONST_VTBL struct IDXTICMFilterVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTICMFilter_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTICMFilter_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTICMFilter_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTICMFilter_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTICMFilter_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTICMFilter_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTICMFilter_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTICMFilter_get_ColorSpace(This,pbstrColorSpace)	\
    (This)->lpVtbl -> get_ColorSpace(This,pbstrColorSpace)

#define IDXTICMFilter_put_ColorSpace(This,bstrColorSpace)	\
    (This)->lpVtbl -> put_ColorSpace(This,bstrColorSpace)

#define IDXTICMFilter_get_Intent(This,pnIntent)	\
    (This)->lpVtbl -> get_Intent(This,pnIntent)

#define IDXTICMFilter_put_Intent(This,nIntent)	\
    (This)->lpVtbl -> put_Intent(This,nIntent)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTICMFilter_get_ColorSpace_Proxy( 
    IDXTICMFilter __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrColorSpace);


void __RPC_STUB IDXTICMFilter_get_ColorSpace_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTICMFilter_put_ColorSpace_Proxy( 
    IDXTICMFilter __RPC_FAR * This,
    /* [in] */ BSTR bstrColorSpace);


void __RPC_STUB IDXTICMFilter_put_ColorSpace_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTICMFilter_get_Intent_Proxy( 
    IDXTICMFilter __RPC_FAR * This,
    /* [retval][out] */ short __RPC_FAR *pnIntent);


void __RPC_STUB IDXTICMFilter_get_Intent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTICMFilter_put_Intent_Proxy( 
    IDXTICMFilter __RPC_FAR * This,
    /* [in] */ short nIntent);


void __RPC_STUB IDXTICMFilter_put_Intent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTICMFilter_INTERFACE_DEFINED__ */



#ifndef __DXTMSFTLib_LIBRARY_DEFINED__
#define __DXTMSFTLib_LIBRARY_DEFINED__

/* library DXTMSFTLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_DXTMSFTLib;

EXTERN_C const CLSID CLSID_DXTComposite;

#ifdef __cplusplus

class DECLSPEC_UUID("9A43A844-0831-11D1-817F-0000F87557DB")
DXTComposite;
#endif

EXTERN_C const CLSID CLSID_DXLUTBuilder;

#ifdef __cplusplus

class DECLSPEC_UUID("1E54333B-2A00-11d1-8198-0000F87557DB")
DXLUTBuilder;
#endif

EXTERN_C const CLSID CLSID_DXTGradientD;

#ifdef __cplusplus

class DECLSPEC_UUID("623E2882-FC0E-11d1-9A77-0000F8756A10")
DXTGradientD;
#endif

EXTERN_C const CLSID CLSID_DXTWipe;

#ifdef __cplusplus

class DECLSPEC_UUID("AF279B30-86EB-11D1-81BF-0000F87557DB")
DXTWipe;
#endif

EXTERN_C const CLSID CLSID_DXTGradientWipe;

#ifdef __cplusplus

class DECLSPEC_UUID("B96F67A2-30C2-47E8-BD85-70A2C948B50F")
DXTGradientWipe;
#endif

EXTERN_C const CLSID CLSID_DXTConvolution;

#ifdef __cplusplus

class DECLSPEC_UUID("2BC0EF29-E6BA-11d1-81DD-0000F87557DB")
DXTConvolution;
#endif

EXTERN_C const CLSID CLSID_CrBlur;

#ifdef __cplusplus

class DECLSPEC_UUID("7312498D-E87A-11d1-81E0-0000F87557DB")
CrBlur;
#endif

EXTERN_C const CLSID CLSID_CrEmboss;

#ifdef __cplusplus

class DECLSPEC_UUID("F515306D-0156-11d2-81EA-0000F87557DB")
CrEmboss;
#endif

EXTERN_C const CLSID CLSID_CrEngrave;

#ifdef __cplusplus

class DECLSPEC_UUID("F515306E-0156-11d2-81EA-0000F87557DB")
CrEngrave;
#endif

EXTERN_C const CLSID CLSID_DXFade;

#ifdef __cplusplus

class DECLSPEC_UUID("16B280C5-EE70-11D1-9066-00C04FD9189D")
DXFade;
#endif

EXTERN_C const CLSID CLSID_BasicImageEffects;

#ifdef __cplusplus

class DECLSPEC_UUID("16B280C8-EE70-11D1-9066-00C04FD9189D")
BasicImageEffects;
#endif

EXTERN_C const CLSID CLSID_Pixelate;

#ifdef __cplusplus

class DECLSPEC_UUID("4CCEA634-FBE0-11d1-906A-00C04FD9189D")
Pixelate;
#endif

EXTERN_C const CLSID CLSID_CrIris;

#ifdef __cplusplus

class DECLSPEC_UUID("3F69F351-0379-11D2-A484-00C04F8EFB69")
CrIris;
#endif

EXTERN_C const CLSID CLSID_DXTIris;

#ifdef __cplusplus

class DECLSPEC_UUID("049F2CE6-D996-4721-897A-DB15CE9EB73D")
DXTIris;
#endif

EXTERN_C const CLSID CLSID_CrSlide;

#ifdef __cplusplus

class DECLSPEC_UUID("810E402F-056B-11D2-A484-00C04F8EFB69")
CrSlide;
#endif

EXTERN_C const CLSID CLSID_DXTSlide;

#ifdef __cplusplus

class DECLSPEC_UUID("D1C5A1E7-CC47-4E32-BDD2-4B3C5FC50AF5")
DXTSlide;
#endif

EXTERN_C const CLSID CLSID_CrRadialWipe;

#ifdef __cplusplus

class DECLSPEC_UUID("424B71AF-0695-11D2-A484-00C04F8EFB69")
CrRadialWipe;
#endif

EXTERN_C const CLSID CLSID_DXTRadialWipe;

#ifdef __cplusplus

class DECLSPEC_UUID("164484A9-35D9-4FB7-9FAB-48273B96AA1D")
DXTRadialWipe;
#endif

EXTERN_C const CLSID CLSID_CrBarn;

#ifdef __cplusplus

class DECLSPEC_UUID("C3BDF740-0B58-11d2-A484-00C04F8EFB69")
CrBarn;
#endif

EXTERN_C const CLSID CLSID_DXTBarn;

#ifdef __cplusplus

class DECLSPEC_UUID("EC9BA17D-60B5-462B-A6D8-14B89057E22A")
DXTBarn;
#endif

EXTERN_C const CLSID CLSID_CrBlinds;

#ifdef __cplusplus

class DECLSPEC_UUID("00C429C0-0BA9-11d2-A484-00C04F8EFB69")
CrBlinds;
#endif

EXTERN_C const CLSID CLSID_DXTBlinds;

#ifdef __cplusplus

class DECLSPEC_UUID("9A4A4A51-FB3A-4F4B-9B57-A2912A289769")
DXTBlinds;
#endif

EXTERN_C const CLSID CLSID_CrStretch;

#ifdef __cplusplus

class DECLSPEC_UUID("7658F2A2-0A83-11d2-A484-00C04F8EFB69")
CrStretch;
#endif

EXTERN_C const CLSID CLSID_DXTStretch;

#ifdef __cplusplus

class DECLSPEC_UUID("F088DE73-BDD0-4E3C-81F8-6D32F4FE9D28")
DXTStretch;
#endif

EXTERN_C const CLSID CLSID_CrInset;

#ifdef __cplusplus

class DECLSPEC_UUID("93073C40-0BA5-11d2-A484-00C04F8EFB69")
CrInset;
#endif

EXTERN_C const CLSID CLSID_DXTInset;

#ifdef __cplusplus

class DECLSPEC_UUID("76F363F2-7E9F-4ED7-A6A7-EE30351B6628")
DXTInset;
#endif

EXTERN_C const CLSID CLSID_CrSpiral;

#ifdef __cplusplus

class DECLSPEC_UUID("ACA97E00-0C7D-11d2-A484-00C04F8EFB69")
CrSpiral;
#endif

EXTERN_C const CLSID CLSID_DXTSpiral;

#ifdef __cplusplus

class DECLSPEC_UUID("4A03DCB9-6E17-4A39-8845-4EE7DC5331A5")
DXTSpiral;
#endif

EXTERN_C const CLSID CLSID_CrZigzag;

#ifdef __cplusplus

class DECLSPEC_UUID("E6E73D20-0C8A-11D2-A484-00C04F8EFB69")
CrZigzag;
#endif

EXTERN_C const CLSID CLSID_DXTZigzag;

#ifdef __cplusplus

class DECLSPEC_UUID("23E26328-3928-40F2-95E5-93CAD69016EB")
DXTZigzag;
#endif

EXTERN_C const CLSID CLSID_CrWheel;

#ifdef __cplusplus

class DECLSPEC_UUID("5AE1DAE0-1461-11d2-A484-00C04F8EFB69")
CrWheel;
#endif

EXTERN_C const CLSID CLSID_DXTChroma;

#ifdef __cplusplus

class DECLSPEC_UUID("421516C1-3CF8-11D2-952A-00C04FA34F05")
DXTChroma;
#endif

EXTERN_C const CLSID CLSID_DXTDropShadow;

#ifdef __cplusplus

class DECLSPEC_UUID("ADC6CB86-424C-11D2-952A-00C04FA34F05")
DXTDropShadow;
#endif

EXTERN_C const CLSID CLSID_DXTCheckerBoard;

#ifdef __cplusplus

class DECLSPEC_UUID("B3EE7802-8224-4787-A1EA-F0DE16DEABD3")
DXTCheckerBoard;
#endif

EXTERN_C const CLSID CLSID_DXTRevealTrans;

#ifdef __cplusplus

class DECLSPEC_UUID("E31E87C4-86EA-4940-9B8A-5BD5D179A737")
DXTRevealTrans;
#endif

EXTERN_C const CLSID CLSID_DXTMaskFilter;

#ifdef __cplusplus

class DECLSPEC_UUID("3A04D93B-1EDD-4f3f-A375-A03EC19572C4")
DXTMaskFilter;
#endif

EXTERN_C const CLSID CLSID_DXTAlphaImageLoader;

#ifdef __cplusplus

class DECLSPEC_UUID("0C7EFBDE-0303-4C6F-A4F7-31FA2BE5E397")
DXTAlphaImageLoader;
#endif

EXTERN_C const CLSID CLSID_DXTRandomDissolve;

#ifdef __cplusplus

class DECLSPEC_UUID("F7F4A1B6-8E87-452F-A2D7-3077F508DBC0")
DXTRandomDissolve;
#endif

EXTERN_C const CLSID CLSID_DXTRandomBars;

#ifdef __cplusplus

class DECLSPEC_UUID("2E7700B7-27C4-437F-9FBF-1E8BE2817566")
DXTRandomBars;
#endif

EXTERN_C const CLSID CLSID_DXTStrips;

#ifdef __cplusplus

class DECLSPEC_UUID("63A4B1FC-259A-4A5B-8129-A83B8C9E6F4F")
DXTStrips;
#endif

EXTERN_C const CLSID CLSID_DXTGlow;

#ifdef __cplusplus

class DECLSPEC_UUID("9F8E6421-3D9B-11D2-952A-00C04FA34F05")
DXTGlow;
#endif

EXTERN_C const CLSID CLSID_DXTShadow;

#ifdef __cplusplus

class DECLSPEC_UUID("E71B4063-3E59-11D2-952A-00C04FA34F05")
DXTShadow;
#endif

EXTERN_C const CLSID CLSID_DXTAlpha;

#ifdef __cplusplus

class DECLSPEC_UUID("ADC6CB82-424C-11D2-952A-00C04FA34F05")
DXTAlpha;
#endif

EXTERN_C const CLSID CLSID_DXTWave;

#ifdef __cplusplus

class DECLSPEC_UUID("ADC6CB88-424C-11D2-952A-00C04FA34F05")
DXTWave;
#endif

EXTERN_C const CLSID CLSID_DXTLight;

#ifdef __cplusplus

class DECLSPEC_UUID("F9EFBEC2-4302-11D2-952A-00C04FA34F05")
DXTLight;
#endif

EXTERN_C const CLSID CLSID_DXTMotionBlur;

#ifdef __cplusplus

class DECLSPEC_UUID("DD13DE77-D3BA-42D4-B5C6-7745FA4E2D4B")
DXTMotionBlur;
#endif

EXTERN_C const CLSID CLSID_DXTMatrix;

#ifdef __cplusplus

class DECLSPEC_UUID("4ABF5A06-5568-4834-BEE3-327A6D95A685")
DXTMatrix;
#endif

EXTERN_C const CLSID CLSID_DXTICMFilter;

#ifdef __cplusplus

class DECLSPEC_UUID("A1BFB370-5A9F-4429-BB72-B13E2FEAEDEF")
DXTICMFilter;
#endif
#endif /* __DXTMSFTLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long __RPC_FAR *, unsigned long            , VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long __RPC_FAR *, VARIANT __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\eaphosterror.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this source code is subject to the terms of the Microsoft
// premium shared source license agreement under which you licensed
// this source code. If you did not accept the terms of the license
// agreement, you are not authorized to use this source code.
// For the terms of the license, please see the license agreement
// signed by you and Microsoft.
// THE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
//////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation
//
// SYNOPSIS
//
//   Scenario-specific error codes, reported by EapHost and Eap Method DLLs.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef EAPHOSTERROR_H
#define EAPHOSTERROR_H
#pragma once

#ifdef __cplusplus
extern "C" {
#endif

#define FACILITY_EAP                   0x0042  // 66L
#define FACILITY_EAP_MESSAGE           0x0842  // 66L + MessageId bit


// Errors common across different groups.
#define _EAP_CERT_FIRST     (+ 0x0)
#define _EAP_CERT_LAST      (+ 0xF)

#define _EAP_CERT_NOT_FOUND           (+ 0x1)
#define _EAP_CERT_INVALID             (+ 0x2)
#define _EAP_CERT_EXPIRED             (+ 0x3)
#define _EAP_CERT_REVOKED             (+ 0x4)
#define _EAP_CERT_OTHER_ERROR         (+ 0x5)
#define _EAP_CERT_REJECTED            (+ 0x6)
#define _EAP_CERT_NAME_REQUIRED       (+ 0x7)

#define _EAP_GENERAL_FIRST  (+ 0x10)   // (+16)
#define _EAP_GENERAL_LAST   (+ 0x3F)   // (+31)

//
// Individual groups of Eap-related Errors.
//

#define EAP_GROUP_MASK       0x0000FF00L


#define EAP_E_EAPHOST_FIRST  0x80420000L
#define EAP_E_EAPHOST_LAST   0x804200FFL
#define EAP_I_EAPHOST_FIRST  0x80420000L
#define EAP_I_EAPHOST_LAST   0x804200FFL

// Cert-Store can't be accessed on either authenticator or peer
#define EAP_E_CERT_STORE_INACCESSIBLE               0x80420010  // (EAP_E_EAPHOST_FIRST + _EAP_GENERAL_FIRST + 0)

// Requested EAP-method is not installed
#define EAP_E_EAPHOST_METHOD_NOT_INSTALLED          0x80420011  // (EAP_E_EAPHOST_FIRST + _EAP_GENERAL_FIRST + 1)

// 
#define EAP_E_EAPHOST_THIRDPARTY_METHOD_HOST_RESET  0x80420012  // (EAP_E_EAPHOST_FIRST + _EAP_GENERAL_FIRST + 2)

// EAPHost not able to communicate with EAPQEC on a NAP enabled client
#define EAP_E_EAPHOST_EAPQEC_INACCESSIBLE           0x80420013  // (EAP_E_EAPHOST_FIRST + _EAP_GENERAL_FIRST + 3)

// EAPHost returns this error, if the authenticator fails the authentication after peer sent its identity
#define EAP_E_EAPHOST_IDENTITY_UNKNOWN              0x80420014  // (EAP_E_EAPHOST_FIRST + _EAP_GENERAL_FIRST + 4)

// EAPHost returns this error on authentication failure.
#define EAP_E_AUTHENTICATION_FAILED                 0x80420015  // (EAP_E_EAPHOST_FIRST + _EAP_GENERAL_FIRST + 5)

// EAPHost returns this error, when the client & the server aren't configured with compatible EAP-types.
#define EAP_I_EAPHOST_EAP_NEGOTIATION_FAILED        0x40420016  // (EAP_I_EAPHOST_FIRST + _EAP_GENERAL_FIRST + 6)

// EAPMethod received an EAP packet that can not be processed
#define EAP_E_EAPHOST_METHOD_INVALID_PACKET         0x80420017  // (EAP_E_EAPHOST_FIRST + _EAP_GENERAL_FIRST + 7)

// EAPHost received a packet that can not be processed. 
#define EAP_E_EAPHOST_REMOTE_INVALID_PACKET         0x80420018  // (EAP_E_EAPHOST_FIRST + _EAP_GENERAL_FIRST + 8)

// EAPHost ConfigSchema validation failed
#define EAP_E_EAPHOST_XML_MALFORMED                 0x80420019  // (EAP_E_EAPHOST_FIRST + _EAP_GENERAL_FIRST + 9)

// EAPHost returns this error, when a configured EAP-method does not support a requested operation (procedure call)
#define EAP_E_EAPHOST_METHOD_OPERATION_NOT_SUPPORTED                 0x80420020  // (EAP_E_EAPHOST_FIRST + _EAP_GENERAL_FIRST + 10)


#define EAP_E_USER_FIRST  0x80420100L
#define EAP_E_USER_LAST   0x804201FFL
#define EAP_I_USER_FIRST  0x40420100L
#define EAP_I_USER_LAST   0x404201FFL

// EAPHost could not find user-certificate for authentication    
#define EAP_E_USER_CERT_NOT_FOUND           0x80420100  // (EAP_E_USER_FIRST + _EAP_CERT_FIRST + _EAP_CERT_NOT_FOUND)

// user-cert being user for authentication does not have proper usage (EKU) set 
#define EAP_E_USER_CERT_INVALID             0x80420101  // (EAP_E_USER_FIRST + _EAP_CERT_FIRST + _EAP_CERT_INVALID)

// EAPhost found user-cert which has expired already
#define EAP_E_USER_CERT_EXPIRED             0x80420102  // (EAP_E_USER_FIRST + _EAP_CERT_FIRST + _EAP_CERT_EXPIRED)

// user-cert being used for authentication has been revoked
#define EAP_E_USER_CERT_REVOKED             0x80420103  // (EAP_E_USER_FIRST + _EAP_CERT_FIRST + _EAP_CERT_REVOKED)

// unknown error occured with user-cert being used for authentication
#define EAP_E_USER_CERT_OTHER_ERROR         0x80420104  // (EAP_E_USER_FIRST + _EAP_CERT_FIRST + _EAP_CERT_OTHER_ERROR)

// Authenticator rejected user-cert for authentication
#define EAP_E_USER_CERT_REJECTED            0x80420105  // (EAP_E_USER_FIRST + _EAP_CERT_FIRST + _EAP_CERT_REJECTED)

// Received EAP-Failure after Identity exchange:  There is likely a problem with the authenticating user's account.
#define EAP_I_USER_ACCOUNT_OTHER_ERROR      0x40420110  // (EAP_I_USER_FIRST + _EAP_GENERAL_FIRST + 0

// Authenticator rejected user credentials for authentication 
#define EAP_E_USER_CREDENTIALS_REJECTED     0x80420111  // (EAP_E_USER_FIRST + _EAP_GENERAL_FIRST + 1)


#define EAP_E_SERVER_FIRST  0x80420200L
#define EAP_E_SERVER_LAST   0x804202FFL

// EAPHost could not find server-certificate for authentication    
#define EAP_E_SERVER_CERT_NOT_FOUND         0x80420200  // (EAP_E_SERVER_FIRST + _EAP_CERT_FIRST + _EAP_CERT_NOT_FOUND)

// server-cert being user for authentication does not have proper usage (EKU) set  
#define EAP_E_SERVER_CERT_INVALID           0x80420201  // (EAP_E_SERVER_FIRST + _EAP_CERT_FIRST + _EAP_CERT_INVALID)

// EAPhost found server-cert which has expired already
#define EAP_E_SERVER_CERT_EXPIRED           0x80420202  // (EAP_E_SERVER_FIRST + _EAP_CERT_FIRST + _EAP_CERT_EXPIRED)

// server-cert being used for authentication has been revoked
#define EAP_E_SERVER_CERT_REVOKED           0x80420203  // (EAP_E_SERVER_FIRST + _EAP_CERT_FIRST + _EAP_CERT_REVOKED)

// unknown error occured with server-cert being used for authentication
#define EAP_E_SERVER_CERT_OTHER_ERROR       0x80420204  // (EAP_E_SERVER_FIRST + _EAP_CERT_FIRST + _EAP_CERT_OTHER_ERROR)


#define EAP_E_USER_ROOT_CERT_FIRST  0x80420300L
#define EAP_E_USER_ROOT_CERT_LAST   0x804203FFL


// EAPHost could not find a certificate in trusted-root cert-store for user cert velidation
#define EAP_E_USER_ROOT_CERT_NOT_FOUND      0x80420300  // (EAP_E_USER_ROOT_CERT_FIRST + _EAP_CERT_FIRST + _EAP_CERT_NOT_FOUND)

// The authentication failed because the root certificate used for this network is invalid
#define EAP_E_USER_ROOT_CERT_INVALID        0x80420301  // (EAP_E_USER_ROOT_CERT_FIRST + _EAP_CERT_FIRST + _EAP_CERT_INVALID)

// Trusted root certificate needed for user-cert validation has been expired.
#define EAP_E_USER_ROOT_CERT_EXPIRED        0x80420302  // (EAP_E_USER_ROOT_CERT_FIRST + _EAP_CERT_FIRST + _EAP_CERT_EXPIRED)

#define EAP_E_SERVER_ROOT_CERT_FIRST  0x80420400L
#define EAP_E_SERVER_ROOT_CERT_LAST   0x804204FFL

// EAPHost could not find a Root certificate in trusted-root cert-store for server cert velidation
#define EAP_E_SERVER_ROOT_CERT_NOT_FOUND        0x80420400  // (EAP_E_SERVER_ROOT_CERT_FIRST + _EAP_CERT_FIRST + _EAP_CERT_NOT_FOUND)

// The authentication failed because the server certificate required for this network on the server computer is invalid
#define EAP_E_SERVER_ROOT_CERT_INVALID          0x80420401  // (EAP_E_SERVER_ROOT_CERT_FIRST + _EAP_CERT_FIRST + _EAP_CERT_INVALID)

// The authentication failed because the certificate on the server computer does not have a server name specified
#define EAP_E_SERVER_ROOT_CERT_NAME_REQUIRED    0x80420406  // (EAP_E_SERVER_ROOT_CERT_FIRST + _EAP_CERT_FIRST + _EAP_CERT_NAME_REQUIRED)


// Alternate names for certain errors.
#define EAP_METHOD_INVALID_PACKET  EAP_E_EAPHOST_METHOD_INVALID_PACKET
#define EAP_INVALID_PACKET         EAP_E_EAPHOST_REMOTE_INVALID_PACKET

// This is not a fixed GUID when it reaches supplicant, but 1st portion will be 
// filled by Generic Win32/Ras error. This helps create unique GUID for every 
// unique error that we don't understand. This helps collect SQM data.
EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Default \
        = { 0x00000000, 0x0000, 0x0000, 0, 0, 0, 0, 0, 0, 0, 0 };


EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Cause_MethodDLLNotFound \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 0, 1 } };

EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Repair_ContactSysadmin \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 0, 2 } };

EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Cause_CertStoreInaccessible \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 0, 4 } };

EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Cause_Generic_AuthFailure \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 1, 4 } };

EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Cause_IdentityUnknown \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 2, 4 } };


EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Cause_Server_CertExpired \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 0, 5 } };

EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Cause_Server_CertInvalid \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 0, 6 } };

EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Cause_Server_CertNotFound \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 0, 7 } };

EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Cause_Server_CertRevoked \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 0, 8 } };

EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Cause_Server_CertOtherError \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 1, 8 } };

EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Cause_User_CertExpired \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 0, 9 } };

EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Cause_User_CertInvalid \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 0, 0xA } };

EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Cause_User_CertNotFound \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 0, 0xB } };

EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Cause_User_CertOtherError \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 0, 0xC } };

EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Cause_User_CertRejected \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 0, 0xD } };

EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Cause_User_CertRevoked \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 0, 0xE } };

EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Cause_User_Account_OtherProblem \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 1, 0xE } };

EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Cause_User_CredsRejected \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 2, 0xE } };

EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Cause_User_Root_CertExpired \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 0, 0xF } };

EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Cause_User_Root_CertInvalid \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 0, 0x10 } };

EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Cause_User_Root_CertNotFound \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 0, 0x11 } };

EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Cause_Server_Root_CertNameRequired \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 0, 0x12 } };

EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Cause_Server_Root_CertNotFound \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 1, 0x12 } };

EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Cause_ThirdPartyMethod_Host_Reset \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 2, 0x12 } };

EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Cause_EapQecInaccessible \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 3, 0x12 } };

EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Repair_Server_ClientSelectServerCert \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 0, 0x18 } };

EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Repair_User_AuthFailure \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 0, 0x19 } };

EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Repair_User_GetNewCert \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 0, 0x1A } };

EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Repair_User_SelectValidCert \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 0, 0x1B } };

EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Repair_Retry_Authentication \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 1, 0x1B } };

EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Cause_EapNegotiationFailed \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 0, 0x1C } };

EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Cause_XmlMalformed \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 0, 0x1D } };

EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Cause_MethodDoesNotSupportOperation \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 0, 0x1E } };

EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Help_ObtainingCerts \
        = { 0xf535eea3, 0x1bdd, 0x46ca, { 0xa2, 0xfc, 0xa6, 0x65, 0x59, 0x39, 0xb7, 0xe8 } };

// This currently is a generic networking troubleshooting help page, not EAP specific.
EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Help_Troubleshooting \
        = { 0x33307acf, 0x0698, 0x41ba, { 0xb0, 0x14, 0xea, 0x0a, 0x2e, 0xb8, 0xd0, 0xa8 } };

#ifdef __cplusplus
}
#endif

#endif // EAPHOSTERROR_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\eaphostpeerconfigapis.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this source code is subject to the terms of the Microsoft
// premium shared source license agreement under which you licensed
// this source code. If you did not accept the terms of the license
// agreement, you are not authorized to use this source code.
// For the terms of the license, please see the license agreement
// signed by you and Microsoft.
// THE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation
//
// SYNOPSIS
//
//   Declares methods that are used to configure EAP methods.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef EAPHOSTPEERCONFIGAPIS_H
#define EAPHOSTPEERCONFIGAPIS_H
#pragma once

#ifndef UNDER_CE
#include "msxml6.h"
#else
#include "objbase.h"    //Required by msxml2.h
#include "msxml2.h"
#endif

#include "EapTypes.h"

#ifdef __cplusplus
extern "C" {
#endif


// This API is used to enumerate all the EAP Methods installed and available for use; this
// includes legacy EAP Methods too. Returns non zero return code up on error.
DWORD WINAPI EapHostPeerGetMethods(
                // API fills the structure to have installed EAP Methods. Caller should free the inner pointers
                // using EapHostPeerFreeMemory starting at the inner most pointer.
                OUT EAP_METHOD_INFO_ARRAY* pEapMethodInfoArray,
                // In case of error, API fills ppEapError if possible. Caller should free ppEapError using EapHostPeerFreeErrorMemory
                OUT EAP_ERROR** ppEapError
                );


// This API is used to invoke configure UI of the specified EAP Method.
// API Returns non zero return code up on error.
DWORD WINAPI EapHostPeerInvokeConfigUI(
                // window handle of the parent window under which configuration dialog will show up
                IN HWND hwndParent,
                // Flags to control the behavior of the EAP Method.
                IN DWORD dwFlags,
                // Identifies the EAP Method to configure
                IN EAP_METHOD_TYPE eapMethodType,
                // Size of input configuration; this could be 0 when there is no configuration
                IN DWORD dwSizeOfConfigIn,
                // input configuration, this couldb NULL when there is no configuration
                IN __in_ecount_opt(dwSizeOfConfigIn) const BYTE* pConfigIn,
                // pointer to DWORD that receives configuration after user updated using UI
                OUT DWORD* pdwSizeOfConfigOut,
                // buffer that receives updated configuration after user updated using UI.
                // Caller should free the memory using EapHostPeerFreeMemory.
                OUT BYTE** ppConfigOut,
                // In case of error, API fills ppEapError if possible. Caller should free ppEapError using EapHostPeerFreeErrorMemory
                OUT EAP_ERROR** pEapError
                );

// This API is used to obtain the fields to be shown in Single Sign On scenario for
// showing UI in long screen. The structures returned have details on how to show the fields.
// API Returns non zero return code up on error.
DWORD WINAPI EapHostPeerQueryCredentialInputFields(
                // handle to the impersonation token that is used while signle sign on.
                IN HANDLE hUserImpersonationToken,
                // identifies the EAP Method supplicant wants to use
                IN EAP_METHOD_TYPE eapMethodType,
                // control the behavior of the EAP Methods
                IN DWORD dwFlags,
                // size of input configuration data
                IN DWORD dwEapConnDataSize,
                // configuration data that is used for the EAP method
                IN __in_ecount(dwEapConnDataSize) const BYTE* pbEapConnData,
                // structure that gets filled with fields and how they should be shown to the user.
                // Caller should free the inner pointers using EapHostPeerFreeMemory starting
                // at the inner most pointer.
                OUT EAP_CONFIG_INPUT_FIELD_ARRAY *pEapConfigInputFieldArray,
                // In case of error, API fills ppEapError if possible. Caller should free ppEapError using EapHostPeerFreeErrorMemory
                OUT EAP_ERROR** pEapError
                );


// Supplicant up on receiving user inputs from Single Sign On UI, calls this API to obtain
// credential blob that could used start authentication
// API Returns non zero return code up on error.
DWORD WINAPI EapHostPeerQueryUserBlobFromCredentialInputFields(
                // handle to the impersonation token that is used while signle sign on.
                IN HANDLE hUserImpersonationToken,
                // identifies the EAP Method supplicant wants to use
                IN EAP_METHOD_TYPE eapMethodType,
                // control the behavior of the EAP Methods
                IN DWORD dwFlags,
                // size of input configuration data
                IN DWORD dwEapConnDataSize,
                // configuration data that is used for the EAP method
                IN __in_ecount(dwEapConnDataSize) const BYTE* pbEapConnData,
                // structure containing the data entered by the user in Single Sign On UI
                IN const EAP_CONFIG_INPUT_FIELD_ARRAY *pEapConfigInputFieldArray,
                // pointer to DWORD that receives the size of credential blob, if supplicant passes in
                // non-zero size and non-NULL data below, EAPHost will just attempt to Update
                // the blob with passed in values (if method supports) instead of creating a new one.
                __inout DWORD *pdwUserBlobSize,
                // Pointer that receives the credential blob that can be used in authentication.
                // For incoming data caller should always allocate this memory using LocalAlloc()
                // Caller should free the memory using EapHostPeerFreeMemory.
                __inout  __deref_out_ecount(*pdwUserBlobSize) BYTE **ppbUserBlob,
                // In case of error, API fills ppEapError if possible. Caller should free ppEapError using EapHostPeerFreeErrorMemory
                OUT EAP_ERROR** pEapError
                );


// Tunnel Methods call this function to invoke Identity UI of the inner Methods.
// This function returns the identity as well as the credentials to use to start the authentication.
DWORD WINAPI EapHostPeerInvokeIdentityUI (
                // API's version number for ease of interoperability. It must be 0.
                IN DWORD dwVersion,
                // identifies the EAP Method supplicant wants to use
                IN EAP_METHOD_TYPE eapMethodType,
                // EAP_FLAG_xxx defined in eaptypes.w
                IN DWORD dwFlags,
                // window handle of the parent window under which configuration dialog will show up
                IN HWND hwndParent,
                // size of the buffer (pConnectionData) in bytes
                IN DWORD dwSizeofConnectionData,
                // configuration data that is used for the EAP method
                IN __in_ecount(dwSizeofConnectionData) const BYTE* pConnectionData,
                // size of the ubuffer pUserData
                IN DWORD dwSizeofUserData,
                // user credential information pertinent to this auth
                IN __in_ecount_opt(dwSizeofUserData) const BYTE* pUserData,
                // size of the buffer pUserDataOut.
                __inout DWORD* pdwSizeOfUserDataOut,
                // user data information returned by method.
                // Caller should release this using EapHostPeerFreeMemory
                OUT __deref_out_ecount(*pdwSizeOfUserDataOut)BYTE** ppUserDataOut,
                // identity returned by method. Caller should release this using EapHostPeerFreeMemory
                OUT __deref_out LPWSTR* ppwszIdentity,
                // In case of error, API fills ppEapError if possible. Caller should free ppEapError
                // using EapHostPeerFreeErrorMemory
                OUT EAP_ERROR** ppEapError,
                // Reserved for future usage. It must be NULL.
                __inout LPVOID *ppvReserved
                );


// While doing authentication with EapHost, when supplicant receives action code of EapHostPeerResponseInvokeUi
// supplicant should call EapHostPeerGetUIContext to get UI context data. After that. it then should call this
// API from a process where UI can be brought up.
// API Returns non zero return code up on error.
DWORD WINAPI EapHostPeerInvokeInteractiveUI(
                // window handle of the parent window under which dialog will show up
                IN HWND hwndParent,
                // size of UIcontext data received from EapHostPeerGetUIContext call
                IN DWORD dwSizeofUIContextData,
                // UIcontext data received from EapHostPeerGetUIContext call
                IN __in_ecount_opt(dwSizeofUIContextData) const BYTE* pUIContextData,
                // pointer to DWORD that receives data from interactive UI that is used for authentication
                // to continue
                OUT DWORD* pdwSizeOfDataFromInteractiveUI,
                // pointer that receives buffer filled with interactive UI that is used for authentication
                // to continue. Caller should free the memory using EapHostPeerFreeMemory.
                OUT __deref_out_ecount(*pdwSizeOfDataFromInteractiveUI) BYTE** ppDataFromInteractiveUI,
                // In case of error, API fills ppEapError if possible. Caller should free ppEapError using EapHostPeerFreeErrorMemory
                OUT EAP_ERROR** pEapError
                );

// This API will enable supplicants to collect necessary information from EAPHost to raise interactive UI and collect user information
// supplicant should call EapHostPeerQueryInteractiveUIInputFields() API first after it receives
// EapHostPeerResponseInvokeUi actionCode from EAPHost. If the return value from this API
// is EAP_E_EAPHOST_METHOD_OPERATION_NOT_SUPPORTED, then supplicant should fall back to
// traditional model of invoking method interactive UI, i.e. by calling EapHostPeerInvokeInteractiveUI()
// API Returns non zero return code up on error.
DWORD WINAPI EapHostPeerQueryInteractiveUIInputFields (
                // API's version number for ease of interoperability. It must be 0.
                IN DWORD dwVersion,
                // control the behavior of the EAP Methods
                IN DWORD dwFlags,
                // size of UIcontext data EAPHost runtime
                IN DWORD dwSizeofUIContextData,
                // UIContext data received from EAPHost runtime
                IN __in_ecount(dwSizeofUIContextData) const BYTE* pUIContextData,
                // structure that gets filled with fields and how they should be shown to the user.
                // Caller should free the inner pointers using EapHostPeerFreeMemory starting at the inner most pointer.
                OUT EAP_INTERACTIVE_UI_DATA *pEapInteractiveUIData,
                // In case of error, API fills ppEapError if possible.  Caller should free ppEapError using EapHostPeerFreeErrorMemory
                OUT EAP_ERROR** ppEapError,
                // Reserved for future usage. It must be NULL.
                __inout LPVOID *ppvReserved
                );

// This API will enable supplicants to convert user information into a user-blob which can be consumed by EAPHost runtime APIs
// API Returns non zero return code up on error.
DWORD WINAPI EapHostPeerQueryUIBlobFromInteractiveUIInputFields(
                // API's version number for ease of interoperability. It must be 0.
                IN DWORD dwVersion,
                // control the behavior of the EAP Methods
                IN DWORD dwFlags,
                // size of UIcontext data EAPHost runtime
                IN DWORD dwSizeofUIContextData,
                // UIContext data received from EAPHost runtime
                IN __in_ecount(dwSizeofUIContextData) const BYTE* pUIContextData,
                // structure that carries data provided by user
                IN const EAP_INTERACTIVE_UI_DATA *pEapInteractiveUIData,
                // pointer to DWORD that receives size of credential blob, if supplicant passes in
                // non-zero size and non-NULL data below, EAPHost will just attempt to Update
                // the blob with passed in values (if method supports) instead of creating a new one.
                __inout DWORD * pdwSizeOfDataFromInteractiveUI,
                // Pointer that receives the credential blob that can be used in authentication.
                // Caller should free the memory using EapHostPeerFreeMemory.
                __inout __deref_out_ecount(*pdwSizeOfDataFromInteractiveUI) BYTE ** ppDataFromInteractiveUI,
                // In case of error, API fills ppEapError if possible.  Caller should free ppEapError using EapHostPeerFreeErrorMemory
                OUT EAP_ERROR** ppEapError,
                // Reserved for future usage. It must be NULL.
                __inout LPVOID *ppvReserved
                );


// Supplicant can utilize XML based EAP configuration storing, managing, editing. When it wants to call EapHostPeerConfigureUI
// or when it has to start authentication, it calls this API to convert XML configuration into blob.
// API Returns non zero return code up on error.
DWORD WINAPI EapHostPeerConfigXml2Blob(
                // controls the behavior of the EAP Method
                IN DWORD dwFlags,
                // a node containing EAP XML configuration inside it
                IN IXMLDOMNode* pConfigDoc,
                // pointer to DWORD that receives the configuration blob size
                OUT DWORD* pdwSizeOfConfigOut,
                // pointer that receives configuration blob. Caller should free the memory using EapHostPeerFreeMemory.
                OUT __deref_out_ecount(*pdwSizeOfConfigOut) BYTE** ppConfigOut,
                // pointer that receives the EAP Method specified in the XML configuration
                OUT EAP_METHOD_TYPE* pEapMethodType,
                // In case of error, API fills ppEapError if possible. Caller should free ppEapError using EapHostPeerFreeErrorMemory
                OUT EAP_ERROR** ppEapError
                );


// Supplicant can utilize XML based EAP credentials storing, managing, editing. When it wants to start
// authentication, it calls this API to convert XML based credentials into blob.
// API Returns non zero return code up on error.
DWORD WINAPI EapHostPeerCredentialsXml2Blob(
                // controls the behavior of the EAP Method
                IN DWORD dwFlags,
                // XML node that contains credentials
                IN IXMLDOMNode* pCredentialsDoc,
                // size of configuration blob that the credentials are configured for
                IN DWORD dwSizeOfConfigIn,
                // configuration blob that the credentials are configured for
                IN __in_ecount(dwSizeOfConfigIn) BYTE* pConfigIn,
                // pointer to DWORD that receives size of the credentials blob.
                OUT  DWORD* pdwSizeOfCredentialsOut,
                // pointer that receives credential blob buffer.  Caller should free the memory using
                // EapHostPeerFreeMemory.
                OUT __deref_out_ecount(*pdwSizeOfCredentialsOut) BYTE** ppCredentialsOut,
                // pointer that receives the EAP Method specified in the XML configuration
                OUT EAP_METHOD_TYPE* pEapMethodType,
                // In case of error, API fills ppEapError if possible. Caller should free ppEapError using EapHostPeerFreeErrorMemory
                OUT EAP_ERROR** ppEapError
                );


// Supplicant can utilize XML based EAP credentials storing, managing, editing. When it wants to start
// convert configuration blob to XML, it can call this API.
// API Returns non zero return code up on error.
DWORD WINAPI EapHostPeerConfigBlob2Xml(
                // controls the behavior of the EAP Method
                IN DWORD dwFlags,
                // identifies the EAP Method
                IN EAP_METHOD_TYPE eapMethodType,
                // Size of configuration blob that supplicant wants to convert
                IN DWORD dwSizeOfConfigIn,
                // Configuration blob that supplicant wants to convert
                IN __in_ecount(dwSizeOfConfigIn) BYTE* pConfigIn,
                // XML document that contains XML form of the blob. If the EAP Method does not support
                // EapPeerConfigBlob2Xml function, the XML contains ConfigBlob node with blob in string form
                OUT IXMLDOMDocument2** ppConfigDoc,
                // In case of error, API fills ppEapError if possible. Caller should free ppEapError using EapHostPeerFreeErrorMemory
                OUT EAP_ERROR** ppEapError
                );

// Supplicant calls this API to free memory returned by Config APIs. Supplicant should not use this API
// for freeing EAP_ERROR structure.
VOID WINAPI EapHostPeerFreeMemory(BYTE* pData);

// Supplicant calls this API to free EAP_ERROR memory, which will get filled when an API fails.
VOID WINAPI EapHostPeerFreeErrorMemory(EAP_ERROR* pEapError);


#ifdef __cplusplus
}
#endif

#endif // EAPHOSTPEERCONFIGAPIS_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\eaphostpeertypes.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this source code is subject to the terms of the Microsoft
// premium shared source license agreement under which you licensed
// this source code. If you did not accept the terms of the license
// agreement, you are not authorized to use this source code.
// For the terms of the license, please see the license agreement
// signed by you and Microsoft.
// THE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation.
//
// SYNOPSIS
//
//    IDL source for interaction with EAPHost supplicants.
//
////////////////////////////////////////////////////////////

#ifndef EAPHOSTPEERTYPES_H
#define EAPHOSTPEERTYPES_H
#pragma once

// Request to provide guest access.
#define EAP_PEER_FLAG_GUEST_ACCESS           0x00000040 

typedef
#ifdef __midl
   [v1_enum]
#endif


// Possible reasons for which EAP-method can call getResult from EAPhost 
enum tagEapHostPeerMethodResultReason
{
   // if method has obtained success from some
   EapHostPeerMethodResultAltSuccessReceived = 1,

   // method timedout waiting for response
   EapHostPeerMethodResultTimeout,

   // normal completion of authentication process
   EapHostPeerMethodResultFromMethod
} EapHostPeerMethodResultReason;

   
typedef
#ifdef __midl
   [v1_enum]
#endif
enum tagEapHostPeerResponseAction
{
        // Discard the request as EAP cannot use it.
        EapHostPeerResponseDiscard = 0,
        // Send the packet to the authenticator
        EapHostPeerResponseSend,
        // Respond to EAP by acting on the returned attributes
        EapHostPeerResponseResult,
        // Invoke appropriate UI based on the context
        EapHostPeerResponseInvokeUi,
        // Display a string to the user received as part of a notification 
        // request
        // EapHostPeerResponseNotification,
        // The supplicant needs to take an action based on the context.
        EapHostPeerResponseRespond,
        // The supplicant needs to restart authentication with the same session. 
   //EapHostPeerResponseResetAuthentication,
        // The session could not be found. So the supplicant either needs to 
        // start session again with the same packet or discard the packet. 
   EapHostPeerResponseStartAuthentication,
        // The supplicant needs to take no action at all.
        EapHostPeerResponseNone
} EapHostPeerResponseAction;


typedef
#ifdef __midl
   [v1_enum]
#endif
enum tagEapHostPeerAuthParams {
   EapHostPeerAuthStatus = 1,    // current auth status
   EapHostPeerIdentity,           // obtain the inner method id
   EapHostPeerIdentityExtendedInfo // obtained from Identity packet
                                                                  // This includes NLA information for wireless
} EapHostPeerAuthParams;


typedef
#ifdef __midl
   [v1_enum]
#endif

// possible values for EAP status during authentication process
enum _EAPHOST_AUTH_STATUS
{
   EapHostInvalidSession = 0,
   EapHostAuthNotStarted,
   EapHostAuthIdentityExchange,
   EapHostAuthNegotiatingType,
   EapHostAuthInProgress,
   EapHostAuthSucceeded,
   EapHostAuthFailed
} EAPHOST_AUTH_STATUS;


// describes the current authentication info through different stages
// of EAP authentication process.
typedef struct _EAPHOST_AUTH_INFO
{
   EAPHOST_AUTH_STATUS status;
   DWORD dwErrorCode;
   DWORD dwReasonCode;
} EAPHOST_AUTH_INFO;


// Describes the isolation state of a machine, i.e. 
// whether connectivity is affected.
typedef
#ifdef __midl
   [v1_enum]
#endif
enum _ISOLATION_STATE
{
   ISOLATION_STATE_UNKNOWN = 0,
   ISOLATION_STATE_NOT_RESTRICTED = 1,
   ISOLATION_STATE_IN_PROBATION = 2,
   ISOLATION_STATE_RESTRICTED_ACCESS = 3
} ISOLATION_STATE;


// This carries the result information passed from EAPHost to EAP-method,
// when EAP-method calls GetResult
typedef struct tagEapHostPeerMethodResult
{
   BOOL fIsSuccess;
   DWORD dwFailureReasonCode;
   BOOL fSaveConnectionData;
   DWORD dwSizeofConnectionData;
#ifdef __midl   
   [size_is(dwSizeofConnectionData)] BYTE* pConnectionData;
#else
   BYTE* pConnectionData;
#endif
   BOOL fSaveUserData;
   DWORD dwSizeofUserData;
#ifdef __midl   
   [size_is(dwSizeofUserData)] BYTE* pUserData;
#else
   BYTE* pUserData;
#endif
   EAP_ATTRIBUTES* pAttribArray;
   ISOLATION_STATE isolationState;      
   EAP_METHOD_INFO* pEapMethodInfo;
   EAP_ERROR* pEapError;
} EapHostPeerMethodResult;

#endif //EAPHOSTPEERTYPES_IDL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\eaptypes.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this source code is subject to the terms of the Microsoft
// premium shared source license agreement under which you licensed
// this source code. If you did not accept the terms of the license
// agreement, you are not authorized to use this source code.
// For the terms of the license, please see the license agreement
// signed by you and Microsoft.
// THE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation.
//
// SYNOPSIS
//
//    IDL source for interaction with EAPHost supplicants.
//
////////////////////////////////////////////////////////////

#ifndef EAPTYPES_H
#define EAPTYPES_H
#pragma once

// Mulitply defined IsEqualGUID in objbase.h and guiddef.h
#define _SYS_GUID_OPERATORS_
#include <guiddef.h>  // Used by EAP_ERROR structure.

// Properties that EAP Methods support
#define eapPropCipherSuiteNegotiation 0x00000001
#define eapPropMutualAuth             0x00000002
#define eapPropIntegrity              0x00000004
#define eapPropReplayProtection       0x00000008
#define eapPropConfidentiality        0x00000010
#define eapPropKeyDerivation          0x00000020
#define eapPropKeyStrength64          0x00000040
#define eapPropKeyStrength128         0x00000080
#define eapPropKeyStrength256         0x00000100
#define eapPropKeyStrength512         0x00000200
#define eapPropKeyStrength1024        0x00000400
#define eapPropDictionaryAttackResistance 0x00000800
#define eapPropFastReconnect          0x00001000
#define eapPropCryptoBinding          0x00002000
#define eapPropSessionIndependence    0x00004000
#define eapPropFragmentation          0x00008000
#define eapPropChannelBinding         0x00010000
#define eapPropNap                    0x00020000
#define eapPropStandalone             0x00040000
#define eapPropMppeEncryption         0x00080000
#define eapPropTunnelMethod           0x00100000
#define eapPropSupportsConfig         0x00200000
#define eapPropCertifiedMethod        0x00400000
#define eapPropReserved               0x80000000

// Registry NameValue that stores Properties supported by EAP Method
#define EAP_VALUENAME_PROPERTIES L"Properties"

typedef DWORD EAP_SESSIONID;


typedef struct _EAP_TYPE
{
   BYTE type;
   DWORD dwVendorId;
   DWORD dwVendorType;
} EAP_TYPE;


// definition of EAP_METHOD_TYPE used for describing an EAP method
typedef struct _EAP_METHOD_TYPE
{
   EAP_TYPE eapType;
   DWORD dwAuthorId;
} EAP_METHOD_TYPE;


// Information pertaining to each EAP method is populated in this structure format
typedef struct _EAP_METHOD_INFO
{
   EAP_METHOD_TYPE eaptype;
   LPWSTR pwszAuthorName;
   LPWSTR pwszFriendlyName;
   DWORD eapProperties;
   struct _EAP_METHOD_INFO* pInnerMethodInfo;
} EAP_METHOD_INFO;


// EAPHost populates this array with the information for all the eap-methods installed
// on machine and passes it to a supplicant
struct _EAP_METHOD_INFO_ARRAY_EX;


typedef struct _EAP_METHOD_INFO_EX
{
   EAP_METHOD_TYPE eaptype;
   LPWSTR pwszAuthorName;
   LPWSTR pwszFriendlyName;
   DWORD eapProperties;
   struct _EAP_METHOD_INFO_ARRAY_EX* pInnerMethodInfoArray;
} EAP_METHOD_INFO_EX;


typedef struct _EAP_METHOD_INFO_ARRAY
{
   DWORD dwNumberOfMethods;
   EAP_METHOD_INFO* pEapMethods;
} EAP_METHOD_INFO_ARRAY;

// EAPHost populates this error structs with appropriate information and passes it to
// supplicant, which can use this information for error reporting and troubleshooting
typedef struct _EAP_METHOD_INFO_ARRAY_EX
{
   DWORD dwNumberOfMethods;
   EAP_METHOD_INFO_EX* pEapMethods;
} EAP_METHOD_INFO_ARRAY_EX;

typedef struct _EAP_ERROR
{
   DWORD dwWinError;
   EAP_METHOD_TYPE type;
   DWORD dwReasonCode;

   GUID   rootCauseGuid;
   GUID   repairGuid;
   GUID   helpLinkGuid;

   LPWSTR pRootCauseString;
   LPWSTR pRepairString;
} EAP_ERROR;


EXTERN_C const CLSID GUID_EapHost_Default;

EXTERN_C const CLSID GUID_EapHost_Cause_MethodDLLNotFound;
EXTERN_C const CLSID GUID_EapHost_Cause_EapNegotiationFailed;    //*!*
EXTERN_C const CLSID GUID_EapHost_Cause_ThirdPartyMethod_Host_Reset;
EXTERN_C const CLSID GUID_EapHost_Cause_XmlMalformed;
EXTERN_C const CLSID GUID_EapHost_Cause_MethodDoesNotSupportOperation;
EXTERN_C const CLSID GUID_EapHost_Cause_EapQecInaccessible;      //*!*

EXTERN_C const CLSID GUID_EapHost_Cause_Generic_AuthFailure;
EXTERN_C const CLSID GUID_EapHost_Cause_IdentityUnknown;

EXTERN_C const CLSID GUID_EapHost_Cause_CertStoreInaccessible;

EXTERN_C const CLSID GUID_EapHost_Cause_User_CertExpired;
EXTERN_C const CLSID GUID_EapHost_Cause_User_CertInvalid;
EXTERN_C const CLSID GUID_EapHost_Cause_User_CertNotFound;
EXTERN_C const CLSID GUID_EapHost_Cause_User_CertOtherError;
EXTERN_C const CLSID GUID_EapHost_Cause_User_CertRejected;
EXTERN_C const CLSID GUID_EapHost_Cause_User_CertRevoked;
EXTERN_C const CLSID GUID_EapHost_Cause_User_Account_OtherProblem;
EXTERN_C const CLSID GUID_EapHost_Cause_User_CredsRejected;

EXTERN_C const CLSID GUID_EapHost_Cause_Server_CertExpired;
EXTERN_C const CLSID GUID_EapHost_Cause_Server_CertInvalid;
EXTERN_C const CLSID GUID_EapHost_Cause_Server_CertNotFound;
EXTERN_C const CLSID GUID_EapHost_Cause_Server_CertOtherError;
EXTERN_C const CLSID GUID_EapHost_Cause_Server_CertRevoked;

EXTERN_C const CLSID GUID_EapHost_Cause_User_Root_CertExpired;
EXTERN_C const CLSID GUID_EapHost_Cause_User_Root_CertInvalid;
EXTERN_C const CLSID GUID_EapHost_Cause_User_Root_CertNotFound;

EXTERN_C const CLSID GUID_EapHost_Cause_Server_Root_CertNotFound;
EXTERN_C const CLSID GUID_EapHost_Cause_Server_Root_CertNameRequired;

EXTERN_C const CLSID GUID_EapHost_Repair_ContactSysadmin;
EXTERN_C const CLSID GUID_EapHost_Repair_Retry_Authentication;

EXTERN_C const CLSID GUID_EapHost_Repair_User_AuthFailure;
EXTERN_C const CLSID GUID_EapHost_Repair_User_GetNewCert;
EXTERN_C const CLSID GUID_EapHost_Repair_User_SelectValidCert;

EXTERN_C const CLSID GUID_EapHost_Repair_Server_ClientSelectServerCert;

EXTERN_C const CLSID GUID_EapHost_Help_ObtainingCerts;
EXTERN_C const CLSID GUID_EapHost_Help_Troubleshooting;

//--------------------------


typedef
#ifdef __midl
   [v1_enum]
#endif

// Attributes that EAP Methods support
enum _EAP_ATTRIBUTE_TYPE
{
    eatMinimum = 0,                // Undefined
    eatUserName,                   // Value field is a Pointer
    eatUserPassword,               // Value field is a Pointer
    eatMD5CHAPPassword,            // Value field is a Pointer
    eatNASIPAddress,               // Value field is a 32 bit integral value
    eatNASPort,                    // Value field is a 32 bit integral value
    eatServiceType,                // Value field is a 32 bit integral value
    eatFramedProtocol,             // Value field is a 32 bit integral value
    eatFramedIPAddress,            // Value field is a 32 bit integral value
    eatFramedIPNetmask,            // Value field is a 32 bit integral value
    eatFramedRouting = 10,         // Value field is a 32 bit integral value
    eatFilterId,                   // Value field is a Pointer
    eatFramedMTU,                  // Value field is a 32 bit integral value
    eatFramedCompression,          // Value field is a 32 bit integral value
    eatLoginIPHost,                // Value field is a 32 bit integral value
    eatLoginService,               // Value field is a 32 bit integral value
    eatLoginTCPPort,               // Value field is a 32 bit integral value
    eatUnassigned17,               // Undefined
    eatReplyMessage,               // Value field is a Pointer
    eatCallbackNumber,             // Value field is a Pointer
    eatCallbackId =20,             // Value field is a Pointer
    eatUnassigned21,               // Undefined
    eatFramedRoute,                // Value field is a Pointer
    eatFramedIPXNetwork,           // Value field is a 32 bit integral value
    eatState,                      // Value field is a Pointer
    eatClass,                      // Value field is a Pointer
    eatVendorSpecific,             // Value field is a Pointer
    eatSessionTimeout,             // Value field is a 32 bit integral value
    eatIdleTimeout,                // Value field is a 32 bit integral value
    eatTerminationAction,          // Value field is a 32 bit integral value
    eatCalledStationId = 30,       // Value field is a Pointer
    eatCallingStationId,           // Value field is a Pointer
    eatNASIdentifier,              // Value field is a Pointer
    eatProxyState,                 // Value field is a Pointer
    eatLoginLATService,            // Value field is a Pointer
    eatLoginLATNode,               // Value field is a Pointer
    eatLoginLATGroup,              // Value field is a Pointer
    eatFramedAppleTalkLink,        // Value field is a 32 bit integral value
    eatFramedAppleTalkNetwork,     // Value field is a 32 bit integral value
    eatFramedAppleTalkZone,        // Value field is a Pointer
    eatAcctStatusType = 40,        // Value field is a 32 bit integral value
    eatAcctDelayTime,              // Value field is a 32 bit integral value
    eatAcctInputOctets,            // Value field is a 32 bit integral value
    eatAcctOutputOctets,           // Value field is a 32 bit integral value
    eatAcctSessionId,              // Value field is a Pointer
    eatAcctAuthentic,              // Value field is a 32 bit integral value
    eatAcctSessionTime,            // Value field is a 32 bit integral value
    eatAcctInputPackets,           // Value field is a 32 bit integral value
    eatAcctOutputPackets,          // Value field is a 32 bit integral value
    eatAcctTerminateCause,         // Value field is a 32 bit integral value
    eatAcctMultiSessionId = 50,    // Value field is a Pointer
    eatAcctLinkCount,              // Value field is a 32 bit integral value
    eatAcctEventTimeStamp = 55,    // Value field is a 32 bit integral value
    eatMD5CHAPChallenge = 60,      // Value field is a Pointer
    eatNASPortType,                // Value field is a 32 bit integral value
    eatPortLimit,                  // Value field is a 32 bit integral value
    eatLoginLATPort,               // Value field is a Pointer
    eatTunnelType,                 // Value field is a 32 bit integral value
    eatTunnelMediumType,           // Value field is a 32 bit integral value
    eatTunnelClientEndpoint,       // Value field is a Pointer
    eatTunnelServerEndpoint,       // Value field is a Pointer
    eatARAPPassword = 70,          // Value field is a Pointer
    eatARAPFeatures,               // Value field is a Pointer
    eatARAPZoneAccess,             // Value field is a 32 bit integral value
    eatARAPSecurity,               // Value field is a 32 bit integral value
    eatARAPSecurityData,           // Value field is a Pointer
    eatPasswordRetry,              // Value field is a 32 bit integral value
    eatPrompt,                     // Value field is a 32 bit integral value
    eatConnectInfo,                // Value field is a Pointer
    eatConfigurationToken,         // Value field is a Pointer
    eatEAPMessage,                 // Value field is a Pointer
    eatSignature = 80,             // Value field is a Pointer
    eatARAPChallengeResponse = 84, // Value field is a Pointer
    eatAcctInterimInterval = 85,   // Value field is a 32 bit integral value
    eatNASIPv6Address = 95,  // Value field is a Pointer
    eatFramedInterfaceId, // Value field is a Pointer
    eatFramedIPv6Prefix, // Value field is a Pointer
    eatLoginIPv6Host, // Value field is a Pointer
    eatFramedIPv6Route, // Value field is a Pointer
    eatFramedIPv6Pool, // Value field is a Pointer
    eatARAPGuestLogon = 8096,      // Value field is a 32 bit integral value
    eatCertificateOID,             // Value field is a Pointer
    eatEAPConfiguration,           // Value field is a Pointer
    eatPEAPEmbeddedEAPTypeId,      // Value field is a 32 bit integral value
    eatPEAPFastRoamedSession,      // Value field is a 32 bit integral value
    eatEAPTLV = 8102,              // Value field is a Pointer
    eatCredentialsChanged,        // Value field is a Integer with boolean
                                   // semantics
    eatInnerEapMethodType,         // Value field is a pointer
                                   // EapMethodType of the inner method in
                                   // case of Tunnelled method
    eatClearTextPassword = 8107,   // Value field is a pointer
                                   // Clear text password that can be used
                                   // by certain password based eap methods
                                   // to authenticate a user.
    eatQuarantineSoH     = 8150, // Value field is a pointer
    eatPeerId                 = 9000,  // Value field is a pointer
    eatServerId,                          // Value field is a pointer
    eatMethodId,                          // Value field is a pointer
    eatEMSK,                               // Value field is a pointer
    eatSessionId,                               // Value field is a pointer
    eatReserved = 0xFFFFFFFF       // Undefined
} EAP_ATTRIBUTE_TYPE, EapAttributeType;


// format for carrying EAP attribute TLV (type, length and value)
typedef struct _EAP_ATTRIBUTE
{
        EAP_ATTRIBUTE_TYPE eaType;
        DWORD dwLength;
#ifdef __midl
        [size_is(dwLength)] BYTE* pValue;
#else
    BYTE *pValue;
#endif
} EAP_ATTRIBUTE, EapAttribute;


// List of EAP-attributes
typedef struct _EAP_ATTRIBUTES
{
        DWORD dwNumberOfAttributes;
#ifdef __midl
        [size_is(dwNumberOfAttributes)] EAP_ATTRIBUTE* pAttribs;
#else
    EAP_ATTRIBUTE *pAttribs;
#endif
} EAP_ATTRIBUTES, EapAttributes;


// No UI should be displayed
#define EAP_FLAG_Reserved1              0x00000001
#define EAP_FLAG_NON_INTERACTIVE        0x00000002

// The user data was obtained from Winlogon
#define EAP_FLAG_LOGON                  0x00000004

// Show the Credentails UI before authenticating even if cached creds are present
#define EAP_FLAG_PREVIEW                0x00000008

#define EAP_FLAG_Reserved2              0x00000010

// Authentication is for machine, i.e. not for user. Not setting this flag means
// it is user authentication.
#define EAP_FLAG_MACHINE_AUTH           0x00000020

// Request to provide guest access
#define EAP_FLAG_GUEST_ACCESS           0x00000040

#define EAP_FLAG_Reserved3              0x00000080

#define EAP_FLAG_Reserved4              0x00000100

// Indicates this is the first call after m/c resumed from hibernation.
#define EAP_FLAG_RESUME_FROM_HIBERNATE  0x00000200

#define EAP_FLAG_Reserved5              0x00000400

#define EAP_FLAG_Reserved6              0x00000800

// Should have this or make it reserved?
#define EAP_FLAG_FULL_AUTH              0x00001000

///   New EapHost Flags

// Prefer Credentails passed in BeginSession instead of other form of
// credentials, even if config says use certain way of cred retrieval. If this fails, fallback to
// Method specific credentail retrieval
#define EAP_FLAG_PREFER_ALT_CREDENTIALS     0x00002000

#define EAP_FLAG_Reserved7                  0x00004000

// To inform the cause of reauth is a NAP callback
#define EAP_PEER_FLAG_HEALTH_STATE_CHANGE   0x00008000

// Continue authentication with information available. If can not proceed, fail
// the authentication
#define EAP_FLAG_SUPRESS_UI                 0x00010000

// Pre logon scenario like PLAP
#define EAP_FLAG_PRE_LOGON                  0x00020000

// User Authentication. For legacy Methods not setting EAP_FLAG_MACHINE_AUTH
// also means user authentication.
#define EAP_FLAG_USER_AUTH                  0x00040000

// Config can be viewed but not updated
#define EAP_FLAG_CONFG_READONLY             0x00080000

#define EAP_FLAG_Reserved8                  0x00100000

// the various states of the input fields
#define EAP_CONFIG_INPUT_FIELD_PROPS_DEFAULT                0X00000000
#define EAP_CONFIG_INPUT_FIELD_PROPS_NON_DISPLAYABLE        0X00000001

// This specifies that supplicant should cache this field data
#define EAP_CONFIG_INPUT_FIELD_PROPS_NON_PERSIST            0X00000002


// default property value for entries field to be shown in UI
#define EAP_UI_INPUT_FIELD_PROPS_DEFAULT          EAP_CONFIG_INPUT_FIELD_PROPS_DEFAULT
// To qualify certain entry data on UI is non-displayable (e.g. password)
#define EAP_UI_INPUT_FIELD_PROPS_NON_DISPLAYABLE  EAP_CONFIG_INPUT_FIELD_PROPS_NON_DISPLAYABLE
// This specifies that supplicant should cache this field data
#define EAP_UI_INPUT_FIELD_PROPS_NON_PERSIST            0X00000002
// This specifies that following field is read only (non-editable)
#define EAP_UI_INPUT_FIELD_PROPS_READ_ONLY              0X00000004


// the types of fields that eap can request to show
typedef enum _EAP_CONFIG_INPUT_FIELD_TYPE {
    EapConfigInputUsername,
    EapConfigInputPassword,
    EapConfigInputNetworkUsername,
    EapConfigInputNetworkPassword,
    EapConfigInputPin,
    EapConfigInputPSK,
    EapConfigInputEdit
} EAP_CONFIG_INPUT_FIELD_TYPE, *PEAP_CONFIG_INPUT_FIELD_TYPE;

#define EAP_CREDENTIAL_VERSION                     1
#define EAP_INTERACTIVE_UI_DATA_VERSION            1
#define EAPHOST_PEER_API_VERSION                   1
#define EAPHOST_METHOD_API_VERSION                 1
#define MAX_EAP_CONFIG_INPUT_FIELD_LENGTH          256
#define MAX_EAP_CONFIG_INPUT_FIELD_VALUE_LENGTH    1024


// structure for carrying EAP input field
typedef struct _EAP_CONFIG_INPUT_FIELD_DATA {
    DWORD dwSize;
    EAP_CONFIG_INPUT_FIELD_TYPE Type;
    DWORD dwFlagProps;
    LPWSTR pwszLabel;
    LPWSTR pwszData;
    DWORD dwMinDataLength;
    DWORD dwMaxDataLength;
} EAP_CONFIG_INPUT_FIELD_DATA, *PEAP_CONFIG_INPUT_FIELD_DATA;


// List of EAP input fields
typedef struct _EAP_CONFIG_INPUT_FIELD_ARRAY {
    DWORD dwVersion; // used for versioning
    DWORD dwNumberOfFields;
#ifdef __midl
    [size_is(dwNumberOfFields)] EAP_CONFIG_INPUT_FIELD_DATA* pFields;
#else
    EAP_CONFIG_INPUT_FIELD_DATA* pFields;
#endif
} EAP_CONFIG_INPUT_FIELD_ARRAY, *PEAP_CONFIG_INPUT_FIELD_ARRAY;


// provides type of data, EAP_INTERACTIVE_UI_DATA can carry
typedef enum _EAP_INTERACTIVE_UI_DATA_TYPE {
    EapCredReq,
    EapCredResp,
    EapCredExpiryReq,
    EapCredExpiryResp,
} EAP_INTERACTIVE_UI_DATA_TYPE;


// following determine type of data blob that can be pointed by
// pbUiData member of EAP_INTERACTIVE_UI_DATA
typedef EAP_CONFIG_INPUT_FIELD_ARRAY EAP_CRED_REQ;
typedef EAP_CONFIG_INPUT_FIELD_ARRAY EAP_CRED_RESP;

// pNewCreds can be NULL in case of EAP_CRED_EXPIRY_REQ
// in case of REQ, pNewCreds can be empty (will not be looked at)
typedef struct _EAP_CRED_EXPIRY_REQ {
    EAP_CONFIG_INPUT_FIELD_ARRAY curCreds;
    EAP_CONFIG_INPUT_FIELD_ARRAY newCreds;
} EAP_CRED_EXPIRY_REQ, EAP_CRED_EXPIRY_RESP;

#ifdef __midl
    typedef [switch_type(EAP_INTERACTIVE_UI_DATA_TYPE)]
    union {
       [case(EapCredReq, EapCredResp)]      EAP_CRED_REQ*  credData;
       [case(EapCredExpiryReq,EapCredExpiryResp)] EAP_CRED_EXPIRY_REQ* credExpiryData;
       [default]      ;
    } EAP_UI_DATA_FORMAT;
#else
    typedef union {
       EAP_CRED_REQ*  credData;
       EAP_CRED_EXPIRY_REQ* credExpiryData;
    } EAP_UI_DATA_FORMAT;
#endif


// Data carried from EAP-method to supplicant for interactive UI to raised
typedef struct _EAP_INTERACTIVE_UI_DATA {
    //specifies version of data structure. It must be 0.
    DWORD dwVersion;
    //specifies size of the entire structure.
    DWORD dwSize;
    // this determines what kind of interactive data is passed.
    EAP_INTERACTIVE_UI_DATA_TYPE dwDataType;
    // specifies size of the data pointed by pbUiByte.
    DWORD cbUiData;
    // pointer to a data blob of a type determined by dwDataType above.
    // This can be of type EAP_CRED_REQ/EAP_CRED_RESP or
    // EAP_CRED_EXPIRY_REQ/EAP_CRED_EXPIRY_RESP depending on uiDataType above
#ifdef __midl
    [switch_is (dwDataType)] EAP_UI_DATA_FORMAT pbUiData;
#else
    EAP_UI_DATA_FORMAT pbUiData;
#endif
} EAP_INTERACTIVE_UI_DATA ;


#endif //EAPTYPES_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\eapmethodtypes.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this source code is subject to the terms of the Microsoft
// premium shared source license agreement under which you licensed
// this source code. If you did not accept the terms of the license
// agreement, you are not authorized to use this source code.
// For the terms of the license, please see the license agreement
// signed by you and Microsoft.
// THE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation
//
// SYNOPSIS
//
//   Declares datastructures that executes the peer eap state machine.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef EAPMETHODAPIS_H
#define EAPMETHODAPIS_H
#pragma once

#ifdef __cplusplus
extern "C" {
#endif

// structure that represents EAP packet on the wire
typedef struct tagEapPacket
{
   BYTE Code;
   BYTE Id;
   BYTE Length[2];
   BYTE Data[1];
   // Any additional data following the first byte. The length of
   // the data can be deduced by the length fields.
} EapPacket;

//
// EAP packet codes from EAP spec.
//
typedef
#ifdef __midl
   [v1_enum]
#endif

// possible values for 'code' in EAPPacket
enum tagEapCode
{
   EapCodeMinimum = 1,
   EapCodeRequest = 1,
   EapCodeResponse,
   EapCodeSuccess,
   EapCodeFailure,
   EapCodeMaximum = EapCodeFailure
} EapCode;

// This is a handle to an eap session owned by the individual eap methods.
typedef VOID* EAP_SESSION_HANDLE;

   
#ifdef __cplusplus
}
#endif

#endif // EAPMETHODAPIS_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\edevdefs.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this source code is subject to the terms of the Microsoft end-user
// license agreement (EULA) under which you licensed this SOFTWARE PRODUCT.
// If you did not accept the terms of the EULA, you are not authorized to use
// this source code. For a copy of the EULA, please see the LICENSE.RTF on your
// install media.
//
//===========================================================================
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
// KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
// PURPOSE.
//
//
//===========================================================================
//
// filename edevdefs.h 
//
// External Device (like a VCR) control interface parameter and value definitions
//
// Note:new constants added: ED_BASE+800L -> ED_BASE+811L

#ifndef __EDEVDEFS__
#define __EDEVDEFS__


#define ED_BASE		        		0x1000L

// this is used to tell the device communications object which
// physical communications port to use.
#define DEV_PORT_SIM	1
#define DEV_PORT_COM1	2	// standard serial ports
#define DEV_PORT_COM2	3
#define DEV_PORT_COM3	4
#define DEV_PORT_COM4	5
#define DEV_PORT_DIAQ	6	// Diaquest driver
#define DEV_PORT_ARTI	7	// ARTI driver
#define DEV_PORT_1394	8	// IEEE 1394 Bus
#define DEV_PORT_USB	9	// Universal Serial Bus
#define DEV_PORT_MIN	DEV_PORT_SIM
#define DEV_PORT_MAX	DEV_PORT_USB


//	IAMExtDevice Capability Items:  unless otherwise specified, these items return 
//	   OATRUE or OAFALSE.  All return values are in pdwValue unless otherwise specified:

#define ED_DEVCAP_CAN_RECORD			ED_BASE+1L
#define ED_DEVCAP_CAN_RECORD_STROBE		ED_BASE+2L	// for multitrack devices: 
													// switches currently recording tracks off 
													// and selected non-recording tracks into record
#define ED_DEVCAP_HAS_AUDIO			ED_BASE+3L
#define ED_DEVCAP_HAS_VIDEO			ED_BASE+4L
#define ED_DEVCAP_USES_FILES		ED_BASE+5L
#define ED_DEVCAP_CAN_SAVE			ED_BASE+6L

#define ED_DEVCAP_DEVICE_TYPE		ED_BASE+7L	// returns one of the following:
#define ED_DEVTYPE_VCR				ED_BASE+8L
#define ED_DEVTYPE_LASERDISK		ED_BASE+9L
#define ED_DEVTYPE_ATR 				ED_BASE+10L
#define ED_DEVTYPE_DDR				ED_BASE+11L
#define ED_DEVTYPE_ROUTER 			ED_BASE+12L
#define ED_DEVTYPE_KEYER 			ED_BASE+13L
#define ED_DEVTYPE_MIXER_VIDEO 		ED_BASE+14L
#define ED_DEVTYPE_DVE 				ED_BASE+15L
#define ED_DEVTYPE_WIPEGEN 			ED_BASE+16L
#define ED_DEVTYPE_MIXER_AUDIO 		ED_BASE+17L
#define ED_DEVTYPE_CG 				ED_BASE+18L
#define ED_DEVTYPE_TBC 				ED_BASE+19L
#define ED_DEVTYPE_TCG 				ED_BASE+20L
#define ED_DEVTYPE_GPI 				ED_BASE+21L
#define ED_DEVTYPE_JOYSTICK 		ED_BASE+22L
#define ED_DEVTYPE_KEYBOARD			ED_BASE+23L

// returns mfr-specific ID from external device.
#define ED_DEVCAP_EXTERNAL_DEVICE_ID	ED_BASE+24L

#define ED_DEVCAP_TIMECODE_READ		ED_BASE+25L
#define ED_DEVCAP_TIMECODE_WRITE	ED_BASE+26L
//	used for seekable non-timecode enabled devices
#define ED_DEVCAP_CTLTRK_READ		ED_BASE+27L
//	used for seekable non-timecode enabled devices
#define ED_DEVCAP_INDEX_READ		ED_BASE+28L

// returns device preroll time in current time format
#define ED_DEVCAP_PREROLL			ED_BASE+29L
// returns device postroll time in current time format
#define ED_DEVCAP_POSTROLL			ED_BASE+30L

// returns indication of device's synchronization accuracy.
#define ED_DEVCAP_SYNC_ACCURACY		ED_BASE+31L	// returns one of the following:
#define ED_SYNCACC_PRECISE			ED_BASE+32L
#define ED_SYNCACC_FRAME			ED_BASE+33L
#define ED_SYNCACC_ROUGH			ED_BASE+34L

// returns device's normal framerate.
#define ED_DEVCAP_NORMAL_RATE	ED_BASE+35L	// returns one of the following:
#define ED_RATE_24				ED_BASE+36L
#define ED_RATE_25				ED_BASE+37L
#define ED_RATE_2997			ED_BASE+38L
#define ED_RATE_30				ED_BASE+39L

#define ED_DEVCAP_CAN_PREVIEW	ED_BASE+40L
#define ED_DEVCAP_CAN_MONITOR_SOURCES	ED_BASE+41L

// indicates implementation allows testing of methods/parameters by
// setting the hi bit of a parm that makes sense - see individual methods
// for details.
#define ED_DEVCAP_CAN_TEST			ED_BASE+42L
	
// indicates device accepts video as an input.
#define ED_DEVCAP_VIDEO_INPUTS		ED_BASE+43L

// indicates device accepts audio as an input.
#define ED_DEVCAP_AUDIO_INPUTS		ED_BASE+44L

#define ED_DEVCAP_NEEDS_CALIBRATING	ED_BASE+45L

#define ED_DEVCAP_SEEK_TYPE			ED_BASE+46L	// returns one of the following:
#define ED_SEEK_PERFECT				ED_BASE+47L	// indicates device can execute seek 
												// within 1 video frames without signal 
												//	break (like a DDR)
#define ED_SEEK_FAST				ED_BASE+48L	// indicates device can move pretty quick 
												//  with short break in signal
#define ED_SEEK_SLOW				ED_BASE+49L	// seeks like a tape transport

#define ED_POWER_ON					ED_BASE+50L
#define ED_POWER_OFF				ED_BASE+51L
#define ED_POWER_STANDBY			ED_BASE+52L

#define ED_ACTIVE					ED_BASE+53L
#define ED_INACTIVE 				ED_BASE+54L
#define ED_ALL						ED_BASE+55L
#define ED_TEST						ED_BASE+56L

//	IAMExtTransport Capability Items:  unless otherwise specified, these items return 
//	   OATRUE or OAFALSE.  All return values are in pdwValue unless otherwise specified:

#define ED_TRANSCAP_CAN_EJECT			ED_BASE+100L
#define ED_TRANSCAP_CAN_BUMP_PLAY		ED_BASE+101L	// variable speed for synchronizing
#define ED_TRANSCAP_CAN_PLAY_BACKWARDS	ED_BASE+102L	// servo locked for use during an edit
#define ED_TRANSCAP_CAN_SET_EE			ED_BASE+103L	// show device's input on its output
#define ED_TRANSCAP_CAN_SET_PB			ED_BASE+104L	// show media playback on device's output
#define ED_TRANSCAP_CAN_DELAY_VIDEO_IN	ED_BASE+105L	// transport can do delayed-in video edits
#define ED_TRANSCAP_CAN_DELAY_VIDEO_OUT	ED_BASE+106L	// transport can do delayed-out video edits
#define ED_TRANSCAP_CAN_DELAY_AUDIO_IN	ED_BASE+107L	// transport can do delayed-in audio edits
#define ED_TRANSCAP_CAN_DELAY_AUDIO_OUT	ED_BASE+108L	// transport can do delayed-out audio edits
#define ED_TRANSCAP_FWD_VARIABLE_MAX	ED_BASE+109L	// max forward speed (multiple of play speed) 
														//  in pdblValue
#define ED_TRANSCAP_FWD_VARIABLE_MIN	ED_BASE+800L	// min forward speed (multiple of play speed) 
														//  in pdblValue
#define ED_TRANSCAP_REV_VARIABLE_MAX	ED_BASE+110L	// max reverse speed (multiple of play speed) in
														//  pdblValue
#define ED_TRANSCAP_REV_VARIABLE_MIN	ED_BASE+801L	// min reverse speed (multiple of play speed)
														//  in pdblValue
#define ED_TRANSCAP_FWD_SHUTTLE_MAX		ED_BASE+802L	// max forward speed in Shuttle mode (multiple
														//  of play speed) in pdblValue
#define ED_TRANSCAP_FWD_SHUTTLE_MIN		ED_BASE+803L	// min forward speed in Shuttle mode (multiple
														//  of play speed) in pdblValue
#define ED_TRANSCAP_REV_SHUTTLE_MAX		ED_BASE+804L	// max reverse speed in Shuttle mode (multiple
														//  of play speed) in pdblValue
#define ED_TRANSCAP_REV_SHUTTLE_MIN		ED_BASE+805L	// min reverse speed in Shuttle mode (multiple
														//  of play speed) in pdblValue
#define ED_TRANSCAP_NUM_AUDIO_TRACKS	ED_BASE+111L	// returns number of audio tracks
#define ED_TRANSCAP_LTC_TRACK			ED_BASE+112L	// returns track number of LTC timecode track.
														//  ED_ALL means no dedicated timecode track
#define ED_TRANSCAP_NEEDS_TBC			ED_BASE+113L	// device's output not stable
#define ED_TRANSCAP_NEEDS_CUEING		ED_BASE+114L	// device must be cued prior to performing edit
#define ED_TRANSCAP_CAN_INSERT			ED_BASE+115L
#define ED_TRANSCAP_CAN_ASSEMBLE		ED_BASE+116L
#define ED_TRANSCAP_FIELD_STEP			ED_BASE+117L	// device responds to Frame Advance command by 
														//  advancing one field
#define ED_TRANSCAP_CLOCK_INC_RATE		ED_BASE+118L	// VISCA command - keep for compatibility
#define ED_TRANSCAP_CAN_DETECT_LENGTH	ED_BASE+119L
#define ED_TRANSCAP_CAN_FREEZE			ED_BASE+120L
#define ED_TRANSCAP_HAS_TUNER			ED_BASE+121L
#define ED_TRANSCAP_HAS_TIMER			ED_BASE+122L
#define ED_TRANSCAP_HAS_CLOCK			ED_BASE+123L
#define ED_TRANSCAP_MULTIPLE_EDITS		ED_BASE+806L	// OATRUE means device/filter can support
														//  multiple edit events
#define ED_TRANSCAP_IS_MASTER			ED_BASE+807L	// OATRUE means device is the master clock
														//  for synchronizing (this sets timecode-to-
														//  reference clock offset for editing)
#define ED_TRANSCAP_HAS_DT				ED_BASE+814L	// OATRUE means device has Dynamic Tracking

//	IAMExtTransport Media States
#define ED_MEDIA_SPIN_UP			ED_BASE+130L
#define ED_MEDIA_SPIN_DOWN			ED_BASE+131L
#define ED_MEDIA_UNLOAD				ED_BASE+132L

//	IAMExtTransport Modes
#define	ED_MODE_PLAY				ED_BASE+200L
#define	ED_MODE_STOP				ED_BASE+201L
#define	ED_MODE_FREEZE				ED_BASE+202L	// really "pause"
#define	ED_MODE_THAW				ED_BASE+203L
#define	ED_MODE_FF					ED_BASE+204L
#define	ED_MODE_REW					ED_BASE+205L
#define	ED_MODE_RECORD				ED_BASE+206L
#define	ED_MODE_RECORD_STROBE		ED_BASE+207L
#define ED_MODE_RECORD_FREEZE		ED_BASE+808L	// never "put", only "get"
#define	ED_MODE_STEP				ED_BASE+208L	// same as "jog"
#define	ED_MODE_STEP_FWD			ED_BASE+208L	// same as ED_MODE_STEP
#define	ED_MODE_STEP_REV			ED_BASE+809L
#define	ED_MODE_SHUTTLE				ED_BASE+209L
#define	ED_MODE_EDIT_CUE			ED_BASE+210L
#define ED_MODE_VAR_SPEED			ED_BASE+211L
#define ED_MODE_PERFORM				ED_BASE+212L	// returned status only
#define	ED_MODE_LINK_ON				ED_BASE+280L
#define	ED_MODE_LINK_OFF			ED_BASE+281L
#define ED_MODE_NOTIFY_ENABLE		ED_BASE+810L
#define ED_MODE_NOTIFY_DISABLE		ED_BASE+811L
#define ED_MODE_SHOT_SEARCH			ED_BASE+812L

//	IAMTimecodeReader/Generator/Display defines
//
// Timecode Generator Mode params and values:
//
#define ED_TCG_TIMECODE_TYPE		ED_BASE+400L	// can be one of the following:
#define ED_TCG_SMPTE_LTC			ED_BASE+401L
#define ED_TCG_SMPTE_VITC			ED_BASE+402L
#define ED_TCG_MIDI_QF				ED_BASE+403L
#define ED_TCG_MIDI_FULL			ED_BASE+404L

#define ED_TCG_FRAMERATE			ED_BASE+405L	// can be one of the following:
#define ED_FORMAT_SMPTE_30			ED_BASE+406L
#define ED_FORMAT_SMPTE_30DROP		ED_BASE+407L
#define ED_FORMAT_SMPTE_25			ED_BASE+408L
#define ED_FORMAT_SMPTE_24			ED_BASE+409L

#define ED_TCG_SYNC_SOURCE			ED_BASE+410L	// can be one of the following:
#define ED_TCG_VIDEO				ED_BASE+411L
#define ED_TCG_READER				ED_BASE+412L
#define ED_TCG_FREE					ED_BASE+413L

#define ED_TCG_REFERENCE_SOURCE		ED_BASE+414L	// can have one these values:
													//	ED_TCG_FREE || ED_TCG_READER 
													//	(for regen/jamsync)

// TimeCodeReader Mode params and values:
#define ED_TCR_SOURCE			ED_BASE+416L	// can be one of the following:
// ED_TCG (already defined)
#define ED_TCR_LTC				ED_BASE+417L
#define ED_TCR_VITC				ED_BASE+418L
#define ED_TCR_CT				ED_BASE+419L	// Control Track
#define ED_TCR_FTC				ED_BASE+420L	// File TimeCode - for file-based devices
												//  that wish they were transports
// ED_MODE_NOTIFY_ENABLE can be OATRUE or OAFALSE (defined in transport mode
//  section of this file).  
#define ED_TCR_LAST_VALUE		ED_BASE+421L	// for notification mode - 
												//  successive calls to GetTimecode
												//  return the last read value
// TimeCode Display Mode params and values:
//
#define ED_TCD_SOURCE			ED_BASE+422L	// can be one of the following:
#define ED_TCR					ED_BASE+423L
#define ED_TCG					ED_BASE+424L

#define ED_TCD_SIZE				ED_BASE+425L	// can be one of the following:
#define ED_SMALL				ED_BASE+426L
#define ED_MED					ED_BASE+427L
#define ED_LARGE				ED_BASE+428L

#define ED_TCD_POSITION			ED_BASE+429L	// can be one of the following:
#define ED_TOP					0x0001
#define ED_MIDDLE				0x0002
#define ED_BOTTOM				0x0004			// or'd  with
#define ED_LEFT					0x0100
#define ED_CENTER				0x0200
#define ED_RIGHT				0x0400

#define ED_TCD_INTENSITY		ED_BASE+436L	// can be one of the following:
#define ED_HIGH					ED_BASE+437L
#define ED_LOW					ED_BASE+438L

#define ED_TCD_TRANSPARENCY		ED_BASE+439L	// 0-4, 0 is opaque

#define ED_TCD_INVERT			ED_BASE+440L	// OATRUE=black on white
												// OAFALSE=white on black
//	IAMExtTransport defines
//
// Transport status, params and values
//

// IAMExtTransport Status items and and values:
#define ED_MODE					ED_BASE+500L	// see ED_MODE_xxx values above
#define	ED_ERROR				ED_BASE+501L
#define	ED_LOCAL				ED_BASE+502L
#define	ED_RECORD_INHIBIT		ED_BASE+503L
#define	ED_SERVO_LOCK			ED_BASE+504L
#define	ED_MEDIA_PRESENT		ED_BASE+505L
#define	ED_MEDIA_LENGTH			ED_BASE+506L
#define	ED_MEDIA_SIZE			ED_BASE+507L
#define	ED_MEDIA_TRACK_COUNT	ED_BASE+508L
#define	ED_MEDIA_TRACK_LENGTH	ED_BASE+509L
#define	ED_MEDIA_SIDE			ED_BASE+510L

#define	ED_MEDIA_TYPE			ED_BASE+511L	// can be one of the following:
#define	ED_MEDIA_VHS			ED_BASE+512L
#define	ED_MEDIA_SVHS			ED_BASE+513L
#define	ED_MEDIA_HI8			ED_BASE+514L
#define	ED_MEDIA_UMATIC			ED_BASE+515L
#define	ED_MEDIA_DVC			ED_BASE+516L
#define	ED_MEDIA_1_INCH			ED_BASE+517L
#define	ED_MEDIA_D1				ED_BASE+518L
#define	ED_MEDIA_D2				ED_BASE+519L
#define	ED_MEDIA_D3				ED_BASE+520L
#define	ED_MEDIA_D5				ED_BASE+521L
#define	ED_MEDIA_DBETA			ED_BASE+522L
#define	ED_MEDIA_BETA			ED_BASE+523L
#define	ED_MEDIA_8MM			ED_BASE+524L
#define	ED_MEDIA_DDR			ED_BASE+525L
#define	ED_MEDIA_SX				ED_BASE+813L
#define	ED_MEDIA_OTHER			ED_BASE+526L
#define	ED_MEDIA_CLV			ED_BASE+527L
#define	ED_MEDIA_CAV			ED_BASE+528L
#define ED_MEDIA_POSITION		ED_BASE+529L

#define ED_LINK_MODE			ED_BASE+530L	// OATRUE if transport controls
							 					// are linked to graph's RUN, 
							 					// STOP, and PAUSE methods

// IAMExtTransport Basic Parms
#define	ED_TRANSBASIC_TIME_FORMAT	ED_BASE+540L	// can be one of the following:
#define	ED_FORMAT_MILLISECONDS		ED_BASE+541L
#define	ED_FORMAT_FRAMES			ED_BASE+542L
#define ED_FORMAT_REFERENCE_TIME	ED_BASE+543L

#define	ED_FORMAT_HMSF				ED_BASE+547L
#define	ED_FORMAT_TMSF				ED_BASE+548L

#define	ED_TRANSBASIC_TIME_REFERENCE	ED_BASE+549L	// can be one of the following:
#define	ED_TIMEREF_TIMECODE			ED_BASE+550L
#define	ED_TIMEREF_CONTROL_TRACK	ED_BASE+551L
#define	ED_TIMEREF_INDEX			ED_BASE+552L

#define	ED_TRANSBASIC_SUPERIMPOSE		ED_BASE+553L	// enable/disable onscreen display
#define	ED_TRANSBASIC_END_STOP_ACTION	ED_BASE+554L	// can be one of: ED_MODE_STOP |
														//	ED_MODE_REWIND | ED_MODE_FREEZE
#define	ED_TRANSBASIC_RECORD_FORMAT	ED_BASE+555L	// can be one of the following:
#define	ED_RECORD_FORMAT_SP			ED_BASE+556L
#define	ED_RECORD_FORMAT_LP			ED_BASE+557L
#define	ED_RECORD_FORMAT_EP			ED_BASE+558L

#define	ED_TRANSBASIC_STEP_COUNT	ED_BASE+559L
#define	ED_TRANSBASIC_STEP_UNIT		ED_BASE+560L	// can be one of the following:
#define	ED_STEP_FIELD				ED_BASE+561L
#define	ED_STEP_FRAME				ED_BASE+562L
#define	ED_STEP_3_2					ED_BASE+563L

#define	ED_TRANSBASIC_PREROLL		ED_BASE+564L
#define	ED_TRANSBASIC_RECPREROLL	ED_BASE+565L
#define	ED_TRANSBASIC_POSTROLL		ED_BASE+566L
#define	ED_TRANSBASIC_EDIT_DELAY	ED_BASE+567L
#define	ED_TRANSBASIC_PLAYTC_DELAY	ED_BASE+568L
#define	ED_TRANSBASIC_RECTC_DELAY	ED_BASE+569L
#define ED_TRANSBASIC_EDIT_FIELD	ED_BASE+570L
#define	ED_TRANSBASIC_FRAME_SERVO	ED_BASE+571L
#define	ED_TRANSBASIC_CF_SERVO		ED_BASE+572L
#define	ED_TRANSBASIC_SERVO_REF		ED_BASE+573L	// can be one of the following:
#define	ED_REF_EXTERNAL				ED_BASE+574L
#define	ED_REF_INPUT				ED_BASE+575L
#define	ED_REF_INTERNAL				ED_BASE+576L
#define	ED_REF_AUTO					ED_BASE+577L

#define	ED_TRANSBASIC_WARN_GL		ED_BASE+578L
#define	ED_TRANSBASIC_SET_TRACKING	ED_BASE+579L	// can be one of the following:
#define	ED_TRACKING_PLUS			ED_BASE+580L
#define	ED_TRACKING_MINUS			ED_BASE+581L
#define	ED_TRACKING_RESET			ED_BASE+582L

#define	ED_TRANSBASIC_SET_FREEZE_TIMEOUT	ED_BASE+583L
#define	ED_TRANSBASIC_VOLUME_NAME		ED_BASE+584L
#define	ED_TRANSBASIC_BALLISTIC_1		ED_BASE+585L	// space for proprietary data
#define	ED_TRANSBASIC_BALLISTIC_2		ED_BASE+586L
#define	ED_TRANSBASIC_BALLISTIC_3		ED_BASE+587L
#define	ED_TRANSBASIC_BALLISTIC_4		ED_BASE+588L
#define	ED_TRANSBASIC_BALLISTIC_5		ED_BASE+589L
#define	ED_TRANSBASIC_BALLISTIC_6		ED_BASE+590L
#define	ED_TRANSBASIC_BALLISTIC_7		ED_BASE+591L
#define	ED_TRANSBASIC_BALLISTIC_8		ED_BASE+592L
#define	ED_TRANSBASIC_BALLISTIC_9		ED_BASE+593L
#define	ED_TRANSBASIC_BALLISTIC_10		ED_BASE+594L
#define	ED_TRANSBASIC_BALLISTIC_11		ED_BASE+595L
#define	ED_TRANSBASIC_BALLISTIC_12		ED_BASE+596L
#define	ED_TRANSBASIC_BALLISTIC_13		ED_BASE+597L
#define	ED_TRANSBASIC_BALLISTIC_14		ED_BASE+598L
#define	ED_TRANSBASIC_BALLISTIC_15		ED_BASE+599L
#define	ED_TRANSBASIC_BALLISTIC_16		ED_BASE+600L
#define	ED_TRANSBASIC_BALLISTIC_17		ED_BASE+601L
#define	ED_TRANSBASIC_BALLISTIC_18		ED_BASE+602L
#define	ED_TRANSBASIC_BALLISTIC_19		ED_BASE+603L
#define	ED_TRANSBASIC_BALLISTIC_20		ED_BASE+604L

// consumer VCR items
#define	ED_TRANSBASIC_SETCLOCK			ED_BASE+605L
#define	ED_TRANSBASIC_SET_COUNTER_FORMAT	ED_BASE+606L	// uses time format flags
#define	ED_TRANSBASIC_SET_COUNTER_VALUE	ED_BASE+607L

#define	ED_TRANSBASIC_SETTUNER_CH_UP	ED_BASE+608L
#define	ED_TRANSBASIC_SETTUNER_CH_DN	ED_BASE+609L
#define	ED_TRANSBASIC_SETTUNER_SK_UP	ED_BASE+610L
#define	ED_TRANSBASIC_SETTUNER_SK_DN	ED_BASE+611L
#define	ED_TRANSBASIC_SETTUNER_CH		ED_BASE+612L
#define	ED_TRANSBASIC_SETTUNER_NUM		ED_BASE+613L

#define	ED_TRANSBASIC_SETTIMER_EVENT	ED_BASE+614L
#define	ED_TRANSBASIC_SETTIMER_STARTDAY	ED_BASE+615L
#define	ED_TRANSBASIC_SETTIMER_STARTTIME	ED_BASE+616L
#define	ED_TRANSBASIC_SETTIMER_STOPDAY	ED_BASE+617L
#define	ED_TRANSBASIC_SETTIMER_STOPTIME	ED_BASE+618L

// IAMExtTransport video parameters
#define	ED_TRANSVIDEO_SET_OUTPUT	ED_BASE+630L	// can be one of the following:
#define	ED_E2E						ED_BASE+631L
#define	ED_PLAYBACK					ED_BASE+632L
#define	ED_OFF						ED_BASE+633L

#define	ED_TRANSVIDEO_SET_SOURCE	ED_BASE+634L

// IAMExtTransport audio parameters
#define	ED_TRANSAUDIO_ENABLE_OUTPUT	ED_BASE+640L	// can be the following:
#define	ED_AUDIO_ALL				0x10000000	//	or any of the following OR'd together
#define ED_AUDIO_1					0x0000001L
#define ED_AUDIO_2					0x0000002L
#define ED_AUDIO_3					0x0000004L
#define ED_AUDIO_4					0x0000008L
#define ED_AUDIO_5					0x0000010L
#define ED_AUDIO_6					0x0000020L
#define ED_AUDIO_7					0x0000040L
#define ED_AUDIO_8					0x0000080L
#define ED_AUDIO_9					0x0000100L
#define ED_AUDIO_10					0x0000200L
#define ED_AUDIO_11					0x0000400L
#define ED_AUDIO_12					0x0000800L
#define ED_AUDIO_13					0x0001000L
#define ED_AUDIO_14					0x0002000L
#define ED_AUDIO_15					0x0004000L
#define ED_AUDIO_16					0x0008000L
#define ED_AUDIO_17					0x0010000L
#define ED_AUDIO_18					0x0020000L
#define ED_AUDIO_19					0x0040000L
#define ED_AUDIO_20					0x0080000L
#define ED_AUDIO_21					0x0100000L
#define ED_AUDIO_22					0x0200000L
#define ED_AUDIO_23					0x0400000L
#define ED_AUDIO_24					0x0800000L
#define ED_VIDEO					0x2000000L	// for Edit props below

#define	ED_TRANSAUDIO_ENABLE_RECORD		ED_BASE+642L
#define	ED_TRANSAUDIO_ENABLE_SELSYNC	ED_BASE+643L
#define	ED_TRANSAUDIO_SET_SOURCE		ED_BASE+644L
#define	ED_TRANSAUDIO_SET_MONITOR		ED_BASE+645L


// Edit Property Set-related defs

// The following values reflect (and control) the state of an 
// edit property set
#define ED_INVALID		ED_BASE+652L
#define ED_EXECUTING	ED_BASE+653L
#define ED_REGISTER		ED_BASE+654L
#define ED_DELETE		ED_BASE+655L

// Edit property set parameters and values
#define ED_EDIT_HEVENT	ED_BASE+656L	// event handle to signal event 
										// completion
#define ED_EDIT_TEST	ED_BASE+657L	// returns OAFALSE if filter thinks
										//  edit can be done, OATRUE if not
#define ED_EDIT_IMMEDIATE	ED_BASE+658L	// OATRUE means start put the 
										// device into edit mode (editing
										// "on the fly") immediately upon
										//  execution of Mode(ED_MODE_EDIT_CUE)
#define ED_EDIT_MODE	ED_BASE+659L
// can be one of the following values:
#define ED_EDIT_MODE_ASSEMBLE		ED_BASE+660L
#define ED_EDIT_MODE_INSERT			ED_BASE+661L
#define ED_EDIT_MODE_CRASH_RECORD	ED_BASE+662L
#define ED_EDIT_MODE_BOOKMARK_TIME	ED_BASE+663L		// these two are for
#define ED_EDIT_MODE_BOOKMARK_CHAPTER	ED_BASE+664L	// laserdisks

#define ED_EDIT_MASTER	ED_BASE+666L	// OATRUE causes device 
										//  not to synchronize

#define ED_EDIT_TRACK		ED_BASE+667L
// can be one of the following possible OR'd values:
//	ED_VIDEO, ED_AUDIO_1 thru ED_AUDIO_24 (or ED_AUDIO_ALL)

#define ED_EDIT_SRC_INPOINT		ED_BASE+668L	// in current time format
#define ED_EDIT_SRC_OUTPOINT	ED_BASE+669L	// in current time format
#define ED_EDIT_REC_INPOINT		ED_BASE+670L	// in current time format
#define ED_EDIT_REC_OUTPOINT	ED_BASE+671L	// in current time format

#define ED_EDIT_REHEARSE_MODE	ED_BASE+672L
// can be one of the following possible values:
#define ED_EDIT_BVB		ED_BASE+673L	// means rehearse the edit with 
										//  "black-video-black"
#define ED_EDIT_VBV		ED_BASE+674L
#define ED_EDIT_VVV		ED_BASE+675L
#define ED_EDIT_PERFORM	ED_BASE+676L	// means perform the edit with no 
										//  rehearsal.

// Set this property to OATRUE to kill the edit if in progress
#define ED_EDIT_ABORT	ED_BASE+677L
// how long to wait for edit to complete
#define ED_EDIT_TIMEOUT	ED_BASE+678L		// in current time format

// This property causes the device to seek to a point specified by
// ED_EDIT_SEEK_MODE (see below).  NOTE: Only one event at a time can seek.
#define ED_EDIT_SEEK		ED_BASE+679L	// OATRUE means do it now.  
#define ED_EDIT_SEEK_MODE	ED_BASE+680L
//possible values:
#define ED_EDIT_SEEK_EDIT_IN	ED_BASE+681L	// seek to edit's inpoint
#define ED_EDIT_SEEK_EDIT_OUT	ED_BASE+682L	// seek to edit's outpoint
#define ED_EDIT_SEEK_PREROLL	ED_BASE+683L	// seek to edit's 
												//  inpoint-preroll
#define ED_EDIT_SEEK_PREROLL_CT	ED_BASE+684L	// seek to preroll point 
							// using control track (used for tapes with 
							// discontinuoustimecode before edit point: seek
							// to inpoint using timecode, then backup to 
							// preroll point using control track)
#define ED_EDIT_SEEK_BOOKMARK	ED_BASE+685L	// seek to bookmark (just like 
												//  timecode search)
// This property is used for multiple-VCR systems where each machine must
//  cue to a different location relative to the graph's reference clock.  The
//  basic idea is that an edit event is setup with an ED_EDIT_OFFSET property
//  that tells the VCR what offset to maintain between it's timecode (converted
//	to reference clock units) and the reference clock.
#define ED_EDIT_OFFSET	ED_BASE+686L		// in current time format

#define ED_EDIT_PREREAD	ED_BASE+815L		// OATRUE means device supports
											//  pre-read (recorder can also be
											//  player

//
// Some error codes:
// 
// device could be in local mode
#define ED_ERR_DEVICE_NOT_READY		ED_BASE+700L

#endif // __EDEVDEFS__

// eof edevdefs.h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\eapmethodpeerapis.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this source code is subject to the terms of the Microsoft
// premium shared source license agreement under which you licensed
// this source code. If you did not accept the terms of the license
// agreement, you are not authorized to use this source code.
// For the terms of the license, please see the license agreement
// signed by you and Microsoft.
// THE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation
//
// SYNOPSIS
//
//   Declares datastructures that are needed by eap methods on the Peer.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef EAPPEERMETHODAPIS_H
#define EAPPEERMETHODAPIS_H
#pragma once

#ifndef UNDER_CE
#include "msxml6.h"
#else
#include "objbase.h"    //Required by msxml2.h
#include "msxml2.h"
#endif
#include "EapMethodTypes.h"

#ifdef __cplusplus
extern "C" {
#endif

//
// Defines used for installation of EAP DLL
// HKLM\System\CCS\Services\Eaphost\Methods\[AuthorId]\[EapTypeId])
//
// Custom EAP DLL registry installation example:
//                     Name      =  Sample.dll,
//                     AuthorId  =  311(Microsoft),
//                     EapTypeId = (decimal 40)
// HKLM\System\CCS\Services\Eaphost\Methods\311\40
//
//      PeerDllPath             (REG_EXPAND_SZ) %SystemRoot%\system32\sample.dll
//      PeerConfigUIPath        (REG_EXPAND_SZ) %SystemRoot%\system32\sample.dll
//      PeerInteractiveUIPath   (REG_EXPAND_SZ) %SystemRoot%\system32\sample.dll
//      PeerIdentityPath        (REG_EXPAND_SZ) %SystemRoot%\system32\sample.dll
//      PeerFriendlyName        (REG_SZ) Sample EAP Protocol
//      PeerRequireConfigUI     (REG_DWORD)     1

//
// Defines used for installation of EAP DLL
// HKLM\System\CCS\Services\Eaphost\Methods\[AuthorId]\254\[VendorId]\[EapTypeId])
//
// Custom Expanded EAP DLL registry installation example:
//                     Name      =  Sample.dll,
//                     AuthorId  =  311(Microsoft),
//                     VendorId  =  311(Microsoft),
//                     EapTypeId = (decimal 40)
// HKLM\System\CCS\Services\Eaphost\Methods\311\254\311\40
//
//      PeerDllPath             (REG_EXPAND_SZ) %SystemRoot%\system32\sample.dll
//      PeerConfigUIPath        (REG_EXPAND_SZ) %SystemRoot%\system32\sample.dll
//      PeerInteractiveUIPath   (REG_EXPAND_SZ) %SystemRoot%\system32\sample.dll
//      PeerIdentityPath        (REG_EXPAND_SZ) %SystemRoot%\system32\sample.dll
//      PeerFriendlyName        (REG_SZ) Sample EAP Protocol
//      PeerRequireConfigUI     (REG_DWORD)     1


#ifndef UNDER_CE

#define EAP_REGISTRY_LOCATION   \
    TEXT("System\\CurrentControlSet\\Services\\EapHost\\Methods")

#else

#define EAP_REGISTRY_LOCATION   \
    TEXT("Comm\\EapHost\\Extension")

#endif

#define EAP_PEER_VALUENAME_DLL_PATH          TEXT("PeerDllPath")
#define EAP_PEER_VALUENAME_FRIENDLY_NAME     TEXT("PeerFriendlyName")
#define EAP_PEER_VALUENAME_CONFIGUI          TEXT("PeerConfigUIPath")
#define EAP_PEER_VALUENAME_REQUIRE_CONFIGUI  TEXT("PeerRequireConfigUI")
#define EAP_PEER_VALUENAME_IDENTITY          TEXT("PeerIdentityPath")
#define EAP_PEER_VALUENAME_INTERACTIVEUI     TEXT("PeerInteractiveUIPath")
#define EAP_PEER_VALUENAME_INVOKE_NAMEDLG    TEXT("PeerInvokeUsernameDialog")
#define EAP_PEER_VALUENAME_INVOKE_PWDDLG     TEXT("PeerInvokePasswordDialog")
#define EAP_PEER_VALUENAME_PROPERTIES        TEXT("Properties")


// ENUMERATIONS USED by EAP methods on the peer to communicate their status to
// EapHost.

typedef
#ifdef __midl
   [v1_enum]
#endif
enum tagEapPeerMethodResponseAction
{
        // Discard the request as EAP cannot use it.
        EapPeerMethodResponseActionDiscard = 0,
        // Send the packet to the authenticator
        EapPeerMethodResponseActionSend,
        // Respond to EAP by acting on the returned attributes
        EapPeerMethodResponseActionResult,
        // Invoke appropriate UI based on the context
        EapPeerMethodResponseActionInvokeUI,
        // The supplicant needs to take an action based on the context.
        EapPeerMethodResponseActionRespond,
        // The supplicant needs to take no action at all.
        EapPeerMethodResponseActionNone
} EapPeerMethodResponseAction;


typedef
#ifdef __midl
   [v1_enum]
#endif
enum tagEapPeerMethodResultReason
{
   EapPeerMethodResultUnknown = 1,
   EapPeerMethodResultSuccess,
   EapPeerMethodResultFailure
} EapPeerMethodResultReason;


// Structures used by EAP methods on the peer to communicate with the host.

typedef struct tagEapPeerMethodOuput
{
        //EapPeerMethodDecision decision;
        //EapPeerMethodState state;
        EapPeerMethodResponseAction action;
        BOOL fAllowNotifications;
} EapPeerMethodOutput;

// This structure is used in EapPeerGetResult API to convey the authentication result and pass
// additional information to the EapHost and Supplicant.
typedef struct tagEapPeerMethodResult
{
        BOOL fIsSuccess;
   DWORD dwFailureReasonCode;
        BOOL fSaveConnectionData;
        DWORD dwSizeofConnectionData;
   __field_bcount(dwSizeofConnectionData) BYTE* pConnectionData;
        BOOL fSaveUserData;
        DWORD dwSizeofUserData;
   __field_bcount(dwSizeofUserData) BYTE* pUserData;
   EAP_ATTRIBUTES* pAttribArray;
    EAP_ERROR* pEapError;
} EapPeerMethodResult;


// List of functions corresponding to the particular EAP method
typedef struct _EAP_PEER_METHOD_ROUTINES
{
   DWORD dwVersion;
   EAP_TYPE* pEapType;

   DWORD (APIENTRY * EapPeerInitialize) (EAP_ERROR** pEapError);

   DWORD (APIENTRY * EapPeerGetIdentity) (
                        IN DWORD flags,
                        IN DWORD dwSizeofConnectionData,
                        IN const BYTE* pConnectionData,
                        IN DWORD dwSizeofUserData,
                        IN const BYTE* pUserData,
                        IN HANDLE hTokenImpersonateUser,
                        OUT BOOL* pfInvokeUI,
                        IN OUT DWORD* pdwSizeOfUserDataOut,
                        OUT BYTE** ppUserDataOut,
                        OUT WCHAR** ppwszIdentity,
                        OUT EAP_ERROR** ppEapError
                        );

   DWORD (APIENTRY * EapPeerBeginSession) (
                        IN DWORD dwFlags,
                        IN const EapAttributes* const pAttributeArray,
                        IN HANDLE hTokenImpersonateUser,
                        IN DWORD dwSizeofConnectionData,
                        IN BYTE* pConnectionData,
                        IN DWORD dwSizeofUserData,
                        IN BYTE* pUserData,
                        IN DWORD dwMaxSendPacketSize,
                        OUT EAP_SESSION_HANDLE* pSessionHandle,
                        OUT EAP_ERROR** pEapError
                        );

   DWORD (APIENTRY * EapPeerSetCredentials) (
                        IN EAP_SESSION_HANDLE sessionHandle,
                        IN WCHAR* pwszIdentity,
                        IN WCHAR* pwszPassword,
                        OUT EAP_ERROR** pEapError
                        );
   DWORD (APIENTRY * EapPeerProcessRequestPacket) (
                        IN EAP_SESSION_HANDLE sessionHandle,
                        IN DWORD cbReceivePacket,
                        IN EapPacket* pReceivePacket,
                        OUT EapPeerMethodOutput* pEapOutput,
                        OUT EAP_ERROR** pEapError
                        );

   DWORD (APIENTRY * EapPeerGetResponsePacket) (
                        IN EAP_SESSION_HANDLE sessionHandle,
                        IN OUT DWORD* pcbSendPacket,
                        OUT EapPacket* pSendPacket,
                        OUT EAP_ERROR** pEapError
                        );

   DWORD (APIENTRY * EapPeerGetResult) (
                        IN EAP_SESSION_HANDLE sessionHandle,
                        IN EapPeerMethodResultReason reason,
                        OUT EapPeerMethodResult* ppResult,
                        OUT EAP_ERROR** pEapError
                        );

   DWORD (APIENTRY * EapPeerGetUIContext) (
                        IN EAP_SESSION_HANDLE sessionHandle,
                        OUT DWORD* dwSizeOfUIContextData,
                        OUT BYTE** pUIContextData,
                        OUT EAP_ERROR** pEapError
                        );

   DWORD (APIENTRY * EapPeerSetUIContext) (
                        IN EAP_SESSION_HANDLE sessionHandle,
                        IN DWORD dwSizeOfUIContextData,
                        IN const BYTE* pUIContextData,
                        OUT EapPeerMethodOutput* pEapOutput,
                        OUT EAP_ERROR** pEapError
                        );

   DWORD (APIENTRY * EapPeerGetResponseAttributes) (
                        IN EAP_SESSION_HANDLE sessionHandle,
                        OUT EapAttributes* pAttribs,
                        OUT EAP_ERROR** pEapError
                        );

   DWORD (APIENTRY * EapPeerSetResponseAttributes) (
                        IN EAP_SESSION_HANDLE sessionHandle,
                        IN EapAttributes* pAttribs,
                        OUT EapPeerMethodOutput* pEapOutput,
                        OUT EAP_ERROR** pEapError
                        );

   DWORD (APIENTRY * EapPeerEndSession) (
                        IN EAP_SESSION_HANDLE sessionHandle,
                        OUT EAP_ERROR** pEapError
                        );

   DWORD (APIENTRY * EapPeerShutdown) (OUT EAP_ERROR** pEapError);
} EAP_PEER_METHOD_ROUTINES;



//
// EAP Functions
//

// General comment regarding all APIs defined in this file:
//
// If the function succeeds, it returns ERROR_SUCCESS. Otherwise, it is
// considered failure.
//
// If an error code is returned, the out parameter ppEapError will contain
// related error information. The caller is expected to look into it to
// find out the error informations.
// However, there are some situation that it may not be possible to fill
// out information for ppEapError. For example, in out of memory situation,
// the method implementation may not be able to allocate memory for
// ppEapError as well. If for any reason it is not possible to fill ppEapError,
// *ppEapError should be set to NULL.


// This function should be an exported function from the DLL
//
// If any other APIs in this file returns EAP_ERROR, use this
// function to free the memory allocated for it
VOID WINAPI EapPeerFreeErrorMemory(IN EAP_ERROR* pEapError);


// This function should be an exported function from the DLL
//
// Returns information related to a given EAP type.
// Parameters:
// - pEapType:
//   the EAP type for this EAP method. Implementation should check this input
//   to make sure that it is the same as the method being implemented.
//
// - pEapInfo:
//   returns all the information related for pEapType.
DWORD WINAPI EapPeerGetInfo(
         IN EAP_TYPE* pEapType,
         OUT EAP_PEER_METHOD_ROUTINES* pEapInfo,
         OUT EAP_ERROR** ppEapError
         );


// This is the first function that EAPHost should call on this method.
// The only exception is EapPeerFreeErrorMemory() and EapPeerGetInfo(),
// which can be called at any time.
// This function should be called only once and it should initialize
// everything needed for this method work properly.
DWORD WINAPI EapPeerInitialize(OUT EAP_ERROR** pEapError);


// EAPHost will call this function, and it would return user data
// and user identity.
// Parameters:
// - dwFlags:
//   EAP_FLAG_xxx defined in eaptypes.w
//
// - dwSizeofConnectionData:
//   size of the buffer (pConnectionData) in bytes
//
// - pConnectionData:
//   connection data specific to this method. It will be used to decide
//   the user data returned from this API, when the user data depends on
//   certain connection data configuration. The method implementation should
//   have default values for connection data, and when this parameter
//   is NULL, the default connection data should be used.
//
// - dwSizeofUserData:
//   size of the buffer (pUserData) in bytes.
//
// - pUserData:
//   the user data specific to this authentication. It will be used to
//   pre-populate the user data.
//   When this API is called for the first time, or when it needs to start
//   a fresh authentication sessin, this parameter will be NULL.
//   When it is not NULL, its content should be the user data returned
//   from EapPeerGetResult() (*ppResult)->pUserData from previous successful
//   authentication session, if that session indicated that user data should be
//   saved.
//
// - pfInvokeUI:
//   should return true if the user identity and user data blob can not be
//   returned successfully and the method decides that it has to collect the
//   information from the user through UI.
//
// - pdwSizeOfUserDataOut:
//   *pdwSizeOfUserDataOut is the size of buffer *ppUserDataOut
//
// - ppUserDataOut:
//   returned user data. The data will be passed to EapPeerBeginSession()
//   as input pUserData
//
// - ppwszIdentity:
//   returned user identity. It will be included in the identity response packet
//   and returned to the server.
DWORD WINAPI EapPeerGetIdentity (
                IN DWORD dwFlags,
                IN DWORD dwSizeofConnectionData,
                IN const BYTE* pConnectionData,
                IN DWORD dwSizeofUserData,
                IN const BYTE* pUserData,
                IN HANDLE hTokenImpersonateUser,
                OUT BOOL* pfInvokeUI,
                IN OUT DWORD* pdwSizeOfUserDataOut,
                OUT BYTE** ppUserDataOut,
                OUT __out LPWSTR* ppwszIdentity,
                OUT EAP_ERROR** ppEapError
                );


// Start an authentication session.
// Parameters:
// - dwFlags:
//   EAP_FLAG_xxx defined in eaptypes.w
//
// - pAttributeArray:
//   attributes passed to the method.
//
// - hTokenImpersonateUser:
//   Impersonation token for the user to be authenticated.
//
// - dwSizeofConnectionData:
//   size of the buffer (pConnectionData) in bytes
//
// - pConnectionData:
//   See the comment for pConnectionData for EapPeerGetIdentity()
//
// - dwSizeofUserData:
//   size of the buffer (pUserData) in bytes
//
// - pUserData:
//   user data returned from EapPeerGetIdentity()
//
// - dwMaxSendPacketSize:
//   maximum packet size that the method can send. If the method needs to
//   send a message larger than this size, the method has to handle fragmentation
//   and resembling.
//
// - pSessionHandle:
//   This is an "identifier" of the authentication session.
//   When other EapPeerXxxx() functions with a sessionHandle parameter
//   being called, *pSessionHandle will be passed as the session handle.
//   The method should be able to use this to find the information related
//   the authentication session.
DWORD WINAPI EapPeerBeginSession(
         IN DWORD dwFlags,
         IN const EapAttributes* const pAttributeArray,
         IN HANDLE hTokenImpersonateUser,
         IN DWORD dwSizeofConnectionData,
         IN BYTE* pConnectionData,
         IN DWORD dwSizeofUserData,
         IN BYTE* pUserData,
         IN DWORD dwMaxSendPacketSize,
         OUT EAP_SESSION_HANDLE* pSessionHandle,
         OUT EAP_ERROR** pEapError
         );


// A method exports either EapPeerGetIdentity (and EapPeerInvokeIdentityUI) or
// exports EapPeerSetCredentials (and sets the InvokeUserNameDlg regkey). The
// registry key controls which of the two apis will get called.
DWORD WINAPI EapPeerSetCredentials(
         IN EAP_SESSION_HANDLE sessionHandle,
         IN __in LPWSTR pwszIdentity,
         IN __in LPWSTR pwszPassword,
         OUT EAP_ERROR** pEapError
         );


// EAPHost will pass the packet to the method for processing.
// Parameters:
// - sessionHandle:
//   the value returned through *pSessionHandle from EapPeerBeginSession()
//
// - cbRecevedPacket:
//   buffer size of (pReceivePacket) in bytes
//
// - pReceivedPacket:
//   pointer to received packet
//
// - pEapOutput:
//   the method should fill this struct to tell the supplicant what to do.
DWORD WINAPI EapPeerProcessRequestPacket(
         IN EAP_SESSION_HANDLE sessionHandle,
         IN DWORD cbReceivedPacket,
         IN EapPacket* pReceivedPacket,
         OUT EapPeerMethodOutput* pEapOutput,
         OUT EAP_ERROR** pEapError
         );


// This function returns the packet to be sent to the server.
// Parameters:
// - sessionHandle:
//   the value returned through *pSessionHandle from EapPeerBeginSession()
//
// - pcbSendPacket:
//   *pcbSendPacket is the size of the buffer for (pSendPacket) when passed in.
//   Upon return, *pcbSendPacket is the sizeof the actual content in pSendPacket
//
// - pSendPacket:
//   pointer to a buffer that contains the packet to send upon return
DWORD WINAPI EapPeerGetResponsePacket(
         IN EAP_SESSION_HANDLE sessionHandle,
         IN OUT DWORD* pcbSendPacket,
         OUT EapPacket* pSendPacket,
         OUT EAP_ERROR** pEapError
         );


// This will get called either when a method says that it has completed auth.
// or when the lower layer receives an alternative result.
// parameters:
// - sessionHandle:
//   the value returned through *pSessionHandle from EapPeerBeginSession()
//
// - reason:
//   one of the reason enum defined above in this file.
//
// - ppResult:
//   Method should fill this struct with related information as defined
//   by EapPeerMethodResult
DWORD WINAPI EapPeerGetResult(
         IN EAP_SESSION_HANDLE sessionHandle,
         IN EapPeerMethodResultReason reason,
         OUT EapPeerMethodResult* ppResult,
         OUT EAP_ERROR** pEapError
         );

// This will get called if UI should be raised during authentication session.
// This function will always be followed by EapPeerInvokeInteractiveUI() and
// then followed by EapPeerSetUIContext()
// parameters:
// - sessionHandle:
//   the value returned through *pSessionHandle from EapPeerBeginSession()
//
// - pdwSizeOfUIContextData:
//   *pdwSizeOfUIContextData is the size of *ppUIContextData in bytes.
//
// - ppUIContextData:
//   It will be passed to EapPeerInvokeInteractiveUI() as IN parameter
//   pUIContextData
DWORD WINAPI EapPeerGetUIContext(
         IN EAP_SESSION_HANDLE sessionHandle,
         OUT DWORD* pdwSizeOfUIContextData,
         OUT BYTE** ppUIContextData,
         OUT EAP_ERROR** pEapError
      );


// It will be called after UI has been raised. Refer to EapPeerGetUIContext()
// for more information.
// parameters:
// - sessionHandle:
//   the value returned through *pSessionHandle from EapPeerBeginSession()
//
// - dwSizeOfUIContextData:
//   size of pUIContextData in bytes.
//
// - pUIContextData:
//   This is the data returned from EapPeerInvokeInteractiveUI() OUT parameter
//   *ppDataFromInteractiveUI
//
// - pEapOutput:
//   the method should fill this struct to tell the supplicant what to do.
DWORD WINAPI EapPeerSetUIContext(
        IN EAP_SESSION_HANDLE sessionHandle,
        IN DWORD dwSizeOfUIContextData,
        IN const BYTE* pUIContextData,
        OUT EapPeerMethodOutput* pEapOutput,
        OUT EAP_ERROR** pEapError
     );


// If EAPHost calls any of the EapPeerXxxx() function, and that function has
// pEapOutput as a OUT parameter, and the action code in it is
// EapPeerMethodResponseActionRespond, this function will be the next function
// that EAPHost will call.
// And it will be follow by a call to EapPeerSetResponseAttributes()
// parameters:
// - sessionHandle:
//   the value returned through *pSessionHandle from EapPeerBeginSession()
//
// - pAttributes:
//   method should fill this with the attributes it need to return.
DWORD WINAPI EapPeerGetResponseAttributes(
        IN EAP_SESSION_HANDLE sessionHandle,
        OUT EapAttributes* pAttribs,
        OUT EAP_ERROR** pEapError
     );


// See EapPeerGetResponseAttributes() for when this function will be called.
// parameters:
// - sessionHandle:
//   the value returned through *pSessionHandle from EapPeerBeginSession()
//
// - pAttributes:
//   attributes passed to this method.
//
// - pEapOutput:
//   the method should fill this struct to tell the supplicant what to do.
DWORD WINAPI EapPeerSetResponseAttributes(
         IN EAP_SESSION_HANDLE sessionHandle,
         IN EapAttributes* pAttribs,
         OUT EapPeerMethodOutput* pEapOutput,
         OUT EAP_ERROR** pEapError
      );

// The last function that will be called for this authentication session.
// - sessionHandle:
//   the value returned through *pSessionHandle from EapPeerBeginSession()
//
DWORD WINAPI EapPeerEndSession(
         IN EAP_SESSION_HANDLE sessionHandle,
         OUT EAP_ERROR** pEapError
         );

// This is the last function that EAPHost should call on this method.
// The only exception is EapPeerFreeErrorMemory() and EapPeerGetInfo(),
// which can be called at any time.
// This function should be called only once and it should un-initialize
// everything for this method.
DWORD WINAPI EapPeerShutdown(OUT EAP_ERROR** pEapError);


// It should raise a configuration UI so that the user can configure the method
// parameters:
// - pEapType:
//   method type for this method
//
// - hwndParent:
//   The parent window for the UI to be raised by this function.
//
// - dwFlags:
//   EAP_FLAG_xxx defined in eaptypes.w
//
// - dwSizeOfConnectionDataIn:
//   size of pConnectionDataIn in bytes
//
// - pConnectionDataIn:
//   Used to pre-populate the configuration UI. The first time this function
//   is called, or if it is desired to start from scratch, it will be NULL,
//   otherwise, it will be the data returned from previous
//   EapPeerInvokeConfigUI() ppConnectionDataOut OUT parameter
//
// - pdwSizeOfConnectionDataOut:
//   *pdwSizeOfConnectionDataOut is the size of *ppConnectionDataOut
//
// - ppConnectionDataOut:
//   *ppConnectionDataOut is configuration data returned from this functioin.
//   It will be used to pass to next EapPeerInvokeConfigUI() call.
DWORD WINAPI EapPeerInvokeConfigUI(
         IN EAP_METHOD_TYPE* pEapType,
         IN HWND hwndParent,
         IN DWORD dwFlags,
         IN DWORD dwSizeOfConnectionDataIn,
         IN BYTE* pConnectionDataIn,
         OUT DWORD* pdwSizeOfConnectionDataOut,
         OUT BYTE** ppConnectionDataOut,
         OUT EAP_ERROR** pEapError
         );

// This function should raise interactive UI for the Method. What UI to be raised and how to raise
// is Method specific information that is embedded in pUIContextData.
//
// Parameters:
// - pEapType:
//   method type for this method
//
// - hwndParent:
//   The parent window for the UI to be raised by this function.
//
// - dwFlags:
//   EAP_FLAG_xxx defined in eaptypes.w
// - dwSizeofUIContextData:
//   Number of bytes of UIContext data referred by pUIContextData.
// - pUIContextData:
//   A blob that conveys the state of the authentication and describes what and how to show the UI
//   to the user.
// - pdwSizeOfDataFromInteractiveUI
//   Number of bytes of blob referred by *ppDataFromInteractiveUI.
// - ppDataFromInteractiveUI
//   A UI context blob that captures the result of UI interaction
// - pEapError
//   Pointer to pointer to EAP_ERROR that will be filled by the Method in the case of error. In some cases
//  the structure might not be filled.
DWORD WINAPI EapPeerInvokeInteractiveUI(
         IN EAP_METHOD_TYPE* pEapType,
         IN HWND hwndParent,
         IN DWORD dwSizeofUIContextData,
         IN BYTE* pUIContextData,
         OUT DWORD* pdwSizeOfDataFromInteractiveUI,
         OUT BYTE** ppDataFromInteractiveUI,
         OUT EAP_ERROR** pEapError
         );


// This function should raise credential UI for the Method. Method can use the configuration passed in to
// decide what kind of UI should be shown to the user.
//
// Parameters:
// - pEapType:
//   method type for this method
//
// - dwFlags:
//   EAP_FLAG_xxx defined in eaptypes.w
//
// - hwndParent:
//   The parent window for the UI to be raised by this function.
//
// - dwSizeOfConnectionData:
//   Number of bytes of pConnectionData.
//
// - pConnectionData:
//   Configuration blob for the Method.
//
// - dwSizeOfUserData
//   Number of bytes of pUserData.
//
// - pUserData
//   Cached credential blob. This would be NULL if this is the first time successful authentication is being done.
//
// - ppwszIdentity
//   Pointer to unicode string that receives the identity that EapHost should use as part of EAP Identity reponse.
//
// - pEapError
//   Pointer to pointer to EAP_ERROR that will be filled by the Method in the case of error. In some cases
//  the structure might not be filled.
DWORD WINAPI EapPeerInvokeIdentityUI(
         IN EAP_METHOD_TYPE* pEapType,
         IN DWORD dwFlags,
         IN HWND hwndParent,
         IN DWORD dwSizeOfConnectionData,
         IN const BYTE* pConnectionData,
         IN DWORD dwSizeOfUserData,
         IN const BYTE* pUserData,
         OUT DWORD* pdwSizeOfUserDataOut,
         OUT BYTE** ppUserDataOut,
         OUT __out LPWSTR* ppwszIdentity,
         OUT EAP_ERROR** pEapError
         );


// This function returns credential fields to be shown to the user for the authentication. As part of this function
// Method should not bring up UI instead it should describe what credentials are to be obtained. Based on the
// return values, Supplicant draws the UI to the user and obtains the requested credentials.
//
// Parameters:
// - hUserImpersonationToken:
//   Impersonation token of the user/machine who is being authenticated.
//
// - eapMethodType
//   method type for this method
//
// - dwFlags:
//   EAP_FLAG_xxx defined in eaptypes.w
//
 // - dwEapConnDataSize:
//   Number of bytes of pbEapConnData.
//
// - pbEapConnData:
//   Configuration blob for the Method.
//
// - dwSizeOfUserData
//   Number of bytes of pUserData.
//
// - pEapConfigFieldsArray
//   Pointer to EAP_CONFIG_INPUT_FIELD_ARRAY that receives array of credential fields.
//
// - pEapError
//   Pointer to pointer to EAP_ERROR that will be filled by the Method in the case of error. In some cases
//  the structure might not be filled.
DWORD WINAPI EapPeerQueryCredentialInputFields(
         IN HANDLE hUserImpersonationToken,
         IN EAP_METHOD_TYPE eapMethodType,
         IN DWORD dwFlags,
         IN DWORD dwEapConnDataSize,
         IN __in_ecount(dwEapConnDataSize) BYTE* pbEapConnData,
         OUT EAP_CONFIG_INPUT_FIELD_ARRAY* pEapConfigFieldsArray,
         OUT EAP_ERROR** pEapError
         );


// This function returns credential blob based on the credentials passed in the credential array structure.
// Method should not bring up UI. It should convert the credentials in to a blob that could be passed to
// EapPeerBeginSession.
//
// Parameters:
// - hUserImpersonationToken:
//   Impersonation token of the user/machine who is being authenticated.
//
// - eapMethodType
//   method type for this method
//
// - dwFlags:
//   EAP_FLAG_xxx defined in eaptypes.w
//
 // - dwEapConnDataSize:
//   Number of bytes of pbEapConnData.
//
// - pbEapConnData:
//   Configuration blob for the Method.
//
// - dwSizeOfUserData
//   Number of bytes of pUserData.
//
// - pEapConfigFieldsArray
//   Pointer to EAP_CONFIG_INPUT_FIELD_ARRAY that contains array of credential fields filled by supplicant.
//
// - pdwUserBlobSize:
//  Pointer to DWORD that receives the size of the ppbUserBlob.
//
// - ppbUserBlob
//  Pointer to buffer that receives credential blob.
//
// - pEapError
//   Pointer to pointer to EAP_ERROR that will be filled by the Method in the case of error. In some cases
//  the structure might not be filled.
DWORD WINAPI EapPeerQueryUserBlobFromCredentialInputFields(
         IN HANDLE hUserImpersonationToken,
         IN EAP_METHOD_TYPE eapMethodType,
         IN DWORD dwFlags,
         IN DWORD dwEapConnDataSize,
         IN __in_ecount(dwEapConnDataSize) BYTE* pbEapConnData,
         IN const EAP_CONFIG_INPUT_FIELD_ARRAY *pEapConfigInputFieldArray,
         // pointer to DWORD that receives size of credential blob, if EAPHost passes in
         // non-zero size and non-NULL data below, EAP-method will just attempt to Update
         // the blob with passed in values (if supported) instead of creating a new one. EAP-method
         // is not expected to release the passed in buffer, EAPHost will release it after API completion..
         IN OUT DWORD *pdwUserBlobSize,
         IN OUT __deref_out_ecount(*pdwUserBlobSize) BYTE **ppbUserBlob,
         OUT EAP_ERROR** pEapError
         );

// This function returns fields to be displayed during interactive time when alternative UI is used.
// Method should not bring up UI in this function.
//
DWORD WINAPI EapPeerQueryInteractiveUIInputFields(
        // API's version number for ease of interoperability. It must be 0.
        IN DWORD dwVersion,
        // control the behavior of the EAP Methods
        IN DWORD dwFlags,
        // size of UIcontext data EAPHost runtime
        IN DWORD dwSizeofUIContextData,
        // UIContext data received from EAPHost runtime
        IN __in_ecount(dwSizeofUIContextData) const BYTE* pUIContextData,
        //structure that gets filled with fields and how they should be shown to the user.
        // Caller (EapHost) should free the memory using EapPeerFreeMemory.
        OUT EAP_INTERACTIVE_UI_DATA* pEapInteractiveUIData,
        // In case of error, API fills ppEapError if possible.  Caller should free ppEapError using EapPeerFreeErrorMemory
        OUT EAP_ERROR** ppEapError,
        // Reserved for future usage. It must be NULL.
        IN OUT LPVOID *pvReserved
        );

// This function returns interactive UI blob from the UI fields filled by the user
//
DWORD WINAPI EapPeerQueryUIBlobFromInteractiveUIInputFields(
        // API's version number for ease of interoperability. It must be 0.
        IN DWORD dwVersion,
        // control the behavior of the EAP Methods
        IN DWORD dwFlags,
        // size of UIcontext data EAPHost runtime
        IN DWORD dwSizeofUIContextData,
        // UIContext data received from EAPHost runtime
        IN __in_ecount(dwSizeofUIContextData) const BYTE* pUIContextData,
        // structure that carries data provided by user
        IN const EAP_INTERACTIVE_UI_DATA *pEapInteractiveUIData,
        // pointer to DWORD that receives size of credential blob
        OUT DWORD * pdwSizeOfDataFromInteractiveUI,
        // Pointer that receives the credential blob that can be used in authentication.
        // Caller (EapHost) should free the memory using EapPeerFreeMemory.
        OUT __deref_out_ecount(*pdwSizeOfDataFromInteractiveUI) BYTE ** ppDataFromInteractiveUI,
        // In case of error, API fills ppEapError if possible.  Caller should free ppEapError using EapPeerFreeErrorMemory
        OUT EAP_ERROR** ppEapError,
        // Reserved for future usage. It must be NULL.
        IN OUT LPVOID *pvReserved
        );


// This function converts XML document containing configuration information into a blob that could be passed to other
// APIs that expect configuration blob.
//
// Parameters:
// - dwFlags:
//   EAP_FLAG_xxx defined in eaptypes.w
//
// - eapMethodType
//   method type for this method
//
 // - dwEapConnDataSize:
//   Number of bytes of pbEapConnData.
//
// - pConfigDoc:
//   Pointer to XMLDOMDocument2 that refers to the XML document containg the configuration XML
//
// - ppConfigOut
//   Pointer to buffer that receives configuration blob.
//
// - pdwSizeOfConfigOut
//   Pointer to DWORD that receives size of ppConfigOut.
//
// - pEapError
//   Pointer to pointer to EAP_ERROR that will be filled by the Method in the case of error. In some cases
//  the structure might not be filled.
DWORD WINAPI EapPeerConfigXml2Blob(
                IN DWORD dwFlags,
                IN EAP_METHOD_TYPE eapMethodType,
                IN IXMLDOMDocument2* pConfigDoc,
                OUT __out_ecount(*pdwSizeOfConfigOut) BYTE** ppConfigOut,
                OUT DWORD* pdwSizeOfConfigOut,
                OUT EAP_ERROR** pEapError
                );


// This function converts XML document containing credential information into a blob that could be passed to other
// APIs that expect credential blob.
//
// Parameters:
// - dwFlags:
//   EAP_FLAG_xxx defined in eaptypes.w
//
// - eapMethodType
//   method type for this method
//
// - pCredentialsDoc:
//   Pointer to XMLDOMDocument2 that refers to the XML document containg the credential XML
//
// - pConfigIn
//   Pointer to buffer that contains configuration blob.
//
// - dwSizeOfConfigIn
//   Size of pConfigIn
//
// - ppCredentialsOut
//  Pointer to buffer that receives the credential blob
//
// - pdwSizeOfCredentialsOut
//  Pointer to DWORD that receives size of ppCredentialsOut
//
// - pEapError
//   Pointer to pointer to EAP_ERROR that will be filled by the Method in the case of error. In some cases
//  the structure might not be filled.
DWORD WINAPI EapPeerCredentialsXml2Blob(
                IN DWORD dwFlags,
                IN EAP_METHOD_TYPE eapMethodType,
                IN IXMLDOMDocument2* pCredentialsDoc,
                IN __in_ecount(dwSizeOfConfigIn) const BYTE* pConfigIn,
                IN DWORD dwSizeOfConfigIn,
                OUT __out_ecount(*pdwSizeOfCredentialsOut) BYTE** ppCredentialsOut,
                OUT DWORD* pdwSizeOfCredentialsOut,
                OUT EAP_ERROR** pEapError
                );


// This function converts configuration blob into configuration XML document. Methods exporting this API
// will be supporting exporting of and importing of configuration with out problem. It also helps administrators
// modify the configuration.
//
// Parameters:
// - dwFlags:
//   EAP_FLAG_xxx defined in eaptypes.w
//
// - eapMethodType
//   method type for this method
//
// - pConfigIn:
//   Configuration blob
//
// - dwSizeOfConfigIn
//   Size of pConfigIn
//
// - ppConfigDoc
//  Pointer to IXMLDOMDocument2 that receives configuration XML for the given configuration blob.
//
// - pEapError
//   Pointer to pointer to EAP_ERROR that will be filled by the Method in the case of error. In some cases
//  the structure might not be filled.
DWORD WINAPI EapPeerConfigBlob2Xml(
                IN DWORD dwFlags,
                IN EAP_METHOD_TYPE eapMethodType,
                IN __in_ecount(dwSizeOfConfigIn) const BYTE* pConfigIn,
                IN DWORD dwSizeOfConfigIn,
                OUT IXMLDOMDocument2** ppConfigDoc,
                OUT EAP_ERROR** pEapError
                );


// This function frees memory returned by the configuration APIs. This function is called by EapHost when
// it is done with the memory returned by the Method.
//
// Parameters:
// - pUIContextData:
//   Any memory returned by configuration APIs.
//
VOID WINAPI EapPeerFreeMemory(
        IN void* pUIContextData
        );

#ifdef __cplusplus
}
#endif

#endif // EAP_PEER_METHOD_APIS_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\enums.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0543 */
/* Compiler settings for enums.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __enums_h__
#define __enums_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_enums_0000_0000 */
/* [local] */ 

typedef /* [public] */ 
enum ReadyStateConstants
    {	amvUninitialized	= 0,
	amvLoading	= 1,
	amvInteractive	= 3,
	amvComplete	= 4
    } 	ReadyStateConstants;



extern RPC_IF_HANDLE __MIDL_itf_enums_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_enums_0000_0000_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\eappapis.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this source code is subject to the terms of the Microsoft
// premium shared source license agreement under which you licensed
// this source code. If you did not accept the terms of the license
// agreement, you are not authorized to use this source code.
// For the terms of the license, please see the license agreement
// signed by you and Microsoft.
// THE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
//////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation
//
// SYNOPSIS
//
//   Declares apis to invoke peer apis on eaphost.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef EAPPAPIS_H
#define EAPPAPIS_H
#pragma once

#ifdef __cplusplus
extern "C" {
#endif

typedef void (CALLBACK *NotificationHandler) (
                 IN GUID connectionId,
                 IN void* pContextData
                 );


// General note about the memory allocated for the OUT parameters:
//
// If memory is dynamically allocated for the OUT parameters, the memory
// will be available until the caller makes the next call. If the caller
// want to keep the content cross multiple calls, the caller must keep its
// own copy.
// To have all the allocated memory (allocated by this DLL) reclaimed,
// the caller finally must call either EapHostPeerEndSession() or
// EapHostPeerClearConnection().
//
// EAP_ERROR** OUT parameter is an exception. The caller must call
// EapHostPeerFreeEapError() to free the memory.
//
//
// Thread safety:
// EapHostPeerInitialize() and EapHostPeerUninitialize() are always thread
// safe.
//
// EapHostPeerFreeEapError() is not thread safe. There should be only one
// thread being called to free the same EAP_ERROR*. And obviously it should
// not be called more than once for the same EAP_ERROR*.
//
// For all the other functions, there should only be one thread calling them
// for the same session. However, it is safe for multiple threads to call them
// for different sessions.
//
// If the functions succeed, they return ERROR_SUCCESS. Otherwise, it is
// considered failure.
//
// If an error code is returned, the out parameter ppEapError will contain
// related error information. The caller is expected to look into it to
// find out the error informations.
// However, there are some situation that it may not be possible to fill
// out information for ppEapError. For example, in out of memory situation,
// the method implementation may not be able to allocate memory for
// ppEapError as well. If for any reason it is not possible to fill ppEapError,
// *ppEapError should be set to NULL.


// Must call this before it starts to call any other fucntion.
// If this function fails, no other EapHostPeer... functions can be called.
//
// Inside this function, it calls CoInitializeEx(NULL, COINIT_MULTITHREADED)
// So the client should not initialize a conflicting COM environment.
// If the client really needs a different COM environment, it should use the
// COM APIs directly instead of using this C style APIs.
DWORD APIENTRY EapHostPeerInitialize();

// Must call this after it is done calling any other EapHostPeer...
// functions.
// Inside this function it calls CoUninitialize().
void APIENTRY EapHostPeerUninitialize();

// If this function succeeds, no matter the calls to other functions
// succeed or fail, the caller MUST call EapHostPeerEndSession() to end
// the authentication session. if EapHostPeerBeginSession() provides a
// valid GUID to register the connectionand, then EapHostPeerClearConnection()
// must be called at the very end (i.e. there will be no more authentication
// on this GUID) to remove the connection. The connection GUID
// is valid cross multiple authentications.
//
// However, if this function fails, the caller can not proceed with
// other calls. It should NOT call EapHostPeerEndSession() or
// EapHostPeerClearConnection() if this function fails.
//
// For the same pConnectionId, EapHostPeerEndSession() must be called
// before EapHostPeerBeginSession() can be called again.
//
// Parameters:
// - dwFlags:
//   EAP_FLAG_xxx defined in eaptypes.w
//
// - eapType:
//   the EAP method type to be used for the authentication.
//
// - pAttributeArray:
//   attributes passed to the method.
//
// - hTokenImpersonateUser:
//   Impersonation token for the user to be authenticated.
//
// - dwSizeofConnectionData:
//   size of the buffer (pConnectionData) in bytes
//
// - pConnectionData:
//   See the comment for pConnectionData for EapPeerGetIdentity()
//
// - dwSizeofUserData:
//   size of the buffer (pUserData) in bytes
//
// - pUserData:
//   user data returned from EapPeerGetIdentity()
//
// - dwMaxSendPacketSize:
//   maximum packet size that the method can send. If the method needs to
//   send a message larger than this size, the method has to handle fragmentation
//   and resembling.
//
// - pConnectionId:
//   It can be NULL. Otherwise, it should point to a valid GUID which respresent
//   the connection. When re-authentication is needed due to system health change,
//   the callback function func will be called and this GUID pointer will
//   be passed as an IN parameter to indicate which connection the callback
//   is for.
//
// - func:
//   callback function pointer used for re-authentication. This function
//   will be called when system health changes and a re-authentication is needed.
//   if the function handler is NULL, pContextData will be ignored,
//   and it means the caller is not interested in system health change
//   notification
//
// - pSessionId:
//   Return session ID in it. This is used to identify the authentication session.
DWORD APIENTRY
EapHostPeerBeginSession(
   IN DWORD dwFlags,
   IN EAP_METHOD_TYPE eapType,
   IN const EapAttributes* const pAttributeArray,
   IN HANDLE hTokenImpersonateUser,
   IN DWORD dwSizeofConnectionData,
   IN const BYTE* const pConnectionData,
   IN DWORD dwSizeofUserData,
   IN const BYTE* const pUserData,
   IN DWORD dwMaxSendPacketSize,
   // If the supplicant is intrested in re-auth caused by NAP health change,
   // it should provide a unique GUID.
   // When this function is called by PEAP inner method, it will be NULL.
   //
   // When pConnectionId is NULL, func and pContextData will be ignored.
   IN const GUID* const pConnectionId,
   // if the function handler is NULL, pContextData will be ignored,
   // and it means the caller is not interested in SoH change notification
   // from EapQec.
   IN NotificationHandler func,
   // a pointer to some data that the supplicant want to associate with
   // the connection when NotificationHandler call back is called.
   // When NotificationHandler is called, it will be called as:
   // func(*pCOnnectionId, pContextData).
   IN void* pContextData,
   OUT EAP_SESSIONID* pSessionId,
   OUT EAP_ERROR** ppEapError
   );



// Supplicant will pass the packet to EAPHost for processing.
// Parameters:
// - sessionHandle:
//   the value returned through *pSessionId from EapHostPeerBeginSession()
//
// - cbReceivePacket:
//   buffer size of (pReceivePacket) in bytes
//
// - pReceivePacket:
//   pointer to received packet
//
// - pEapOutput:
//   It will tell the supplicant what's the next EAPHost API that it should call.
DWORD APIENTRY
EapHostPeerProcessReceivedPacket(
   IN EAP_SESSIONID sessionHandle,
   IN DWORD cbReceivePacket,
   IN const BYTE* const pReceivePacket,
   OUT EapHostPeerResponseAction* pEapOutput,
   OUT EAP_ERROR** ppEapError
   );


// This function returns the packet to be sent. Supplicant should send the
// returned packet to server.
//
// Parameters:
// - sessionHandle:
//   the value returned through *pSessionId from EapHostPeerBeginSession()
//
// - pcbSendPacket:
//   Upon return, *pcbSendPacket is the sizeof the actual content in pSendPacket
//
// - ppSendPacket:
//   pointer to a buffer that contains the packet to send upon return
DWORD APIENTRY
EapHostPeerGetSendPacket(
   IN EAP_SESSIONID sessionHandle,
	OUT DWORD* pcbSendPacket,
	OUT BYTE** ppSendPacket,
	OUT EAP_ERROR** ppEapError
	);


// Supplicant calls this function to retrieve authentication result.
// Parameters:
// - sessionHandle:
//   the value returned through *pSessionId from EapHostPeerBeginSession()
//
// - reason:
//   One of the reason code defined in eaphostPeerTypes.h
//
// - ppResult:
//   EAPHost will fill this struct with related information as defined
//   by EapHostPeerMethodResult
DWORD APIENTRY
EapHostPeerGetResult(
   IN EAP_SESSIONID sessionHandle,
	IN EapHostPeerMethodResultReason reason,
	OUT EapHostPeerMethodResult* ppResult,
	OUT EAP_ERROR** ppEapError
	   );


// This will get called if UI should be raised during authentication session.
// This function will always be followed by EapHostPeerInvokeInteractiveUI()
// and then followed by EapHostPeerSetUIContext()
// Parameters:
// - sessionHandle:
//   the value returned through *pSessionId from EapHostPeerBeginSession()
//
// - pdwSizeOfUIContextData:
//   *pdwSizeOfUIContextData is the size of *ppUIContextData in bytes.
//
// - ppUIContextData:
//   It will be passed to EapHostPeerInvokeInteractiveUI() as IN parameter
//   pUIContextData
DWORD APIENTRY
EapHostPeerGetUIContext(
   IN EAP_SESSIONID sessionHandle,
   OUT DWORD* pdwSizeOfUIContextData,
   OUT BYTE** ppUIContextData,
	OUT EAP_ERROR** ppEapError
   );


// It will be called after UI has been raised. Refer to EapHostPeerGetUIContext()
// for more information.
//
// Parameters:
// - sessionHandle:
//   the value returned through *pSessionId from EapHostPeerBeginSession()
//
// - dwSizeOfUIContextData:
//   size of pUIContextData in bytes.
//
// - pUIContextData:
//   This is the data returned from EapHostPeerInvokeInteractiveUI() OUT
//   parameter
//   *ppDataFromInteractiveUI
//
// - pEapOutput:
//   It will tell the supplicant what's the next EAPHost API that it should call.
DWORD APIENTRY
EapHostPeerSetUIContext(
   IN EAP_SESSIONID sessionHandle,
   IN DWORD dwSizeOfUIContextData,
   IN const BYTE* const pUIContextData,
   OUT EapHostPeerResponseAction* pEapOutput,
	OUT EAP_ERROR** ppEapError
	);


// Return EAP attributes to supplicant. Supplicant should call
// EapHostPeerSetResponseAttributes() after it calls this function and finishes
// processing of the EAP attributes.
//
// Parameters:
// - sessionHandle:
//   the value returned through *pSessionId from EapHostPeerBeginSession()
//
// - pAttributes:
//   EAP attributes returned to supplicant.
DWORD APIENTRY
EapHostPeerGetResponseAttributes(
   IN EAP_SESSIONID sessionHandle,
   OUT EapAttributes* pAttribs,
	OUT EAP_ERROR** ppEapError
   );


// See EapHostPeerGetResponseAttributes() for when this function will be called.
// Even if supplicant doesn't care about or doesn't understand the attributes
// returned from EapHostPeerGetResponseAttributes(), it should still call
// this function and pass a valid EapAttributes* which contains 0 EapAttribute
//
// Parameters:
// - sessionHandle:
//   the value returned through *pSessionId from EapHostPeerBeginSession()
//
// - pAttribs:
//   EAP attributes that the supplicant passes to EAPHost
DWORD APIENTRY
EapHostPeerSetResponseAttributes(
   IN EAP_SESSIONID sessionHandle,
   IN const EapAttributes* const pAttribs,
   OUT EapHostPeerResponseAction* pEapOutput,
	OUT EAP_ERROR** ppEapError
   );


// Supplicant calls it to retrieve authentication status.
//
// Parameters:
// - sessionHandle:
//   the value returned through *pSessionId from EapHostPeerBeginSession()
//
// - authParam:
//   one of the EapHostPeerAuthParams values defined in Eaphostpeertypes.h
//
// - pcbAuthData:
//   *pcbAuthData is the size of *ppAuthData in bytes
//
// - ppAuthData:
//   contains the returned authentication data. Interpretation of the data
//   depends on the "authParam" passed in
DWORD APIENTRY
EapHostPeerGetAuthStatus(
   IN EAP_SESSIONID sessionHandle,
   IN EapHostPeerAuthParams authParam,
   OUT DWORD* pcbAuthData,
   OUT BYTE** ppAuthData,
   OUT EAP_ERROR** ppEapError
   );


// Authentication has finished so clear up the data stored for this session.
// After this call, the session will no longer be valid.
//
// Parameters:
// - sessionHandle:
//   the value returned through *pSessionId from EapHostPeerBeginSession()
DWORD APIENTRY
EapHostPeerEndSession(
   IN EAP_SESSIONID sessionHandle,
   OUT EAP_ERROR** ppEapError
   );


// Clear up the connection. After this call, all states associated with this
// pConnectionId will be deleted, and no re-authentication will be triggered
// for connection associated with this GUID.
//
// Parameters:
// - pConnectionId:
//   the same connection GUID passed into EapHostPeerBeginSession(). If
//   a NULL is passed to EapHostPeerBeginSession() as the connection id,
//   then there is no need to call this API.
DWORD APIENTRY
EapHostPeerClearConnection(
   IN GUID* pConnectionId,
   OUT EAP_ERROR** ppEapError
   );


// If any of the previous function is called, and an EAP_ERROR is returned,
// this function must be called to free the memory.
void APIENTRY EapHostPeerFreeEapError(IN EAP_ERROR* pEapError);

// EAPHost will call this function, and it would return user data and user identity.

DWORD APIENTRY
EapHostPeerGetIdentity (
      // API's version number for ease of interoperability. It must be 0.
      IN DWORD dwVersion,
      // EAP_FLAG_xxx defined in eaptypes.w
      IN DWORD dwFlags,
      // Eap method type
      IN EAP_METHOD_TYPE eapMethodType,
      // size of the buffer (pConnectionData) in bytes
      IN DWORD dwSizeofConnectionData,
      // configuration data that is used for the EAP method
      IN __in_ecount(dwSizeofConnectionData) const BYTE* pConnectionData,
      // size of the ubuffer pUserData
      IN DWORD dwSizeofUserData,
      // user credential information pertinent to this auth
      IN __in_ecount_opt(dwSizeofUserData) const BYTE* pUserData,
      // impersonation token for logged on user, to obtain user-related information
      IN HANDLE hTokenImpersonateUser,
      // should return true if the user identity and user data blob can not be returned
      // successfully and in needs to be collected through UI
      OUT BOOL* pfInvokeUI,
      // size of the buffer pUserDataOut. caller should free this using EapHostPeerFreeRuntimeMemory
      __inout DWORD* pdwSizeOfUserDataOut,
      // user data information returned by method.
      OUT __deref_out_ecount(*pdwSizeOfUserDataOut) BYTE** ppUserDataOut,
      // identity returned by method. caller should free this using EapHostPeerFreeRuntimeMemory
      OUT __deref_out LPWSTR* ppwszIdentity,
      // In case of error, API fills ppEapError if possible. Caller should free ppEapError
      // using EapHostPeerFreeErrorMemory
      OUT EAP_ERROR** ppEapError,
      // Reserved for future usage. It must be NULL.
      __inout BYTE **ppvReserved
      );

// In case of GetInentity returned memory needs to be released using this API
void APIENTRY EapHostPeerFreeRuntimeMemory (IN BYTE* pData);


#ifdef __cplusplus
}
#endif

#endif // EAPPAPIS_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\emptyvc.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES.
//

#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0286 */
/* at Tue Jan 23 14:30:42 2007
 */
/* Compiler settings for ..\emptyvc.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __emptyvc_h__
#define __emptyvc_h__

/* Forward Declarations */ 

#ifndef __IEmptyVolumeCacheCallBack_FWD_DEFINED__
#define __IEmptyVolumeCacheCallBack_FWD_DEFINED__
typedef interface IEmptyVolumeCacheCallBack IEmptyVolumeCacheCallBack;
#endif 	/* __IEmptyVolumeCacheCallBack_FWD_DEFINED__ */


#ifndef __IEmptyVolumeCache_FWD_DEFINED__
#define __IEmptyVolumeCache_FWD_DEFINED__
typedef interface IEmptyVolumeCache IEmptyVolumeCache;
#endif 	/* __IEmptyVolumeCache_FWD_DEFINED__ */


#ifndef __IEmptyVolumeCache2_FWD_DEFINED__
#define __IEmptyVolumeCache2_FWD_DEFINED__
typedef interface IEmptyVolumeCache2 IEmptyVolumeCache2;
#endif 	/* __IEmptyVolumeCache2_FWD_DEFINED__ */


/* header files for imported files */
#include "objidl.h"
#include "oleidl.h"
#include "oaidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_emptyvc_0000 */
/* [local] */ 

//=--------------------------------------------------------------------------=
// emptyvc.h
//=--------------------------------------------------------------------------=
// Copyright (c) Microsoft Corporation. All rights reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=

#pragma comment(lib,"uuid.lib")

//---------------------------------------------------------------------------=
// Empty Volume Cache Interfaces.



// IEmptyVolumeCache Flags
#define EVCF_HASSETTINGS             0x0001
#define EVCF_ENABLEBYDEFAULT         0x0002
#define EVCF_REMOVEFROMLIST          0x0004
#define EVCF_ENABLEBYDEFAULT_AUTO    0x0008
#define EVCF_DONTSHOWIFZERO          0x0010
#define EVCF_SETTINGSMODE            0x0020
#define EVCF_OUTOFDISKSPACE          0x0040

// IEmptyVolumeCacheCallBack Flags
#define EVCCBF_LASTNOTIFICATION  0x0001

////////////////////////////////////////////////////////////////////////////
//  Interface Definitions
#ifndef _LPEMPTYVOLUMECACHECALLBACK_DEFINED
#define _LPEMPTYVOLUMECACHECALLBACK_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_emptyvc_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_emptyvc_0000_v0_0_s_ifspec;

#ifndef __IEmptyVolumeCacheCallBack_INTERFACE_DEFINED__
#define __IEmptyVolumeCacheCallBack_INTERFACE_DEFINED__

/* interface IEmptyVolumeCacheCallBack */
/* [unique][uuid][object] */ 

typedef /* [unique] */ IEmptyVolumeCacheCallBack __RPC_FAR *LPEMPTYVOLUMECACHECALLBACK;


EXTERN_C const IID IID_IEmptyVolumeCacheCallBack;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6E793361-73C6-11D0-8469-00AA00442901")
    IEmptyVolumeCacheCallBack : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ScanProgress( 
            /* [in] */ DWORDLONG dwlSpaceUsed,
            /* [in] */ DWORD dwFlags,
            /* [unique][in] */ LPCWSTR pcwszStatus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PurgeProgress( 
            /* [in] */ DWORDLONG dwlSpaceFreed,
            /* [in] */ DWORDLONG dwlSpaceToFree,
            /* [in] */ DWORD dwFlags,
            /* [unique][in] */ LPCWSTR pcwszStatus) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEmptyVolumeCacheCallBackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEmptyVolumeCacheCallBack __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEmptyVolumeCacheCallBack __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEmptyVolumeCacheCallBack __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ScanProgress )( 
            IEmptyVolumeCacheCallBack __RPC_FAR * This,
            /* [in] */ DWORDLONG dwlSpaceUsed,
            /* [in] */ DWORD dwFlags,
            /* [unique][in] */ LPCWSTR pcwszStatus);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PurgeProgress )( 
            IEmptyVolumeCacheCallBack __RPC_FAR * This,
            /* [in] */ DWORDLONG dwlSpaceFreed,
            /* [in] */ DWORDLONG dwlSpaceToFree,
            /* [in] */ DWORD dwFlags,
            /* [unique][in] */ LPCWSTR pcwszStatus);
        
        END_INTERFACE
    } IEmptyVolumeCacheCallBackVtbl;

    interface IEmptyVolumeCacheCallBack
    {
        CONST_VTBL struct IEmptyVolumeCacheCallBackVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEmptyVolumeCacheCallBack_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEmptyVolumeCacheCallBack_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEmptyVolumeCacheCallBack_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEmptyVolumeCacheCallBack_ScanProgress(This,dwlSpaceUsed,dwFlags,pcwszStatus)	\
    (This)->lpVtbl -> ScanProgress(This,dwlSpaceUsed,dwFlags,pcwszStatus)

#define IEmptyVolumeCacheCallBack_PurgeProgress(This,dwlSpaceFreed,dwlSpaceToFree,dwFlags,pcwszStatus)	\
    (This)->lpVtbl -> PurgeProgress(This,dwlSpaceFreed,dwlSpaceToFree,dwFlags,pcwszStatus)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEmptyVolumeCacheCallBack_ScanProgress_Proxy( 
    IEmptyVolumeCacheCallBack __RPC_FAR * This,
    /* [in] */ DWORDLONG dwlSpaceUsed,
    /* [in] */ DWORD dwFlags,
    /* [unique][in] */ LPCWSTR pcwszStatus);


void __RPC_STUB IEmptyVolumeCacheCallBack_ScanProgress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEmptyVolumeCacheCallBack_PurgeProgress_Proxy( 
    IEmptyVolumeCacheCallBack __RPC_FAR * This,
    /* [in] */ DWORDLONG dwlSpaceFreed,
    /* [in] */ DWORDLONG dwlSpaceToFree,
    /* [in] */ DWORD dwFlags,
    /* [unique][in] */ LPCWSTR pcwszStatus);


void __RPC_STUB IEmptyVolumeCacheCallBack_PurgeProgress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEmptyVolumeCacheCallBack_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_emptyvc_0108 */
/* [local] */ 

#endif
#ifndef _LPEMPTYVOLUMECACHE_DEFINED
#define _LPEMPTYVOLUMECACHE_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_emptyvc_0108_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_emptyvc_0108_v0_0_s_ifspec;

#ifndef __IEmptyVolumeCache_INTERFACE_DEFINED__
#define __IEmptyVolumeCache_INTERFACE_DEFINED__

/* interface IEmptyVolumeCache */
/* [unique][uuid][object] */ 

typedef /* [unique] */ IEmptyVolumeCache __RPC_FAR *LPEMPTYVOLUMECACHE;


EXTERN_C const IID IID_IEmptyVolumeCache;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8FCE5227-04DA-11d1-A004-00805F8ABE06")
    IEmptyVolumeCache : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ HKEY hkRegKey,
            /* [in] */ LPCWSTR pcwszVolume,
            /* [out] */ LPWSTR __RPC_FAR *ppwszDisplayName,
            /* [out] */ LPWSTR __RPC_FAR *ppwszDescription,
            /* [out] */ DWORD __RPC_FAR *pdwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSpaceUsed( 
            /* [out] */ DWORDLONG __RPC_FAR *pdwlSpaceUsed,
            /* [in] */ IEmptyVolumeCacheCallBack __RPC_FAR *picb) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Purge( 
            /* [in] */ DWORDLONG dwlSpaceToFree,
            /* [in] */ IEmptyVolumeCacheCallBack __RPC_FAR *picb) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ShowProperties( 
            /* [in] */ HWND hwnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Deactivate( 
            /* [out] */ DWORD __RPC_FAR *pdwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEmptyVolumeCacheVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEmptyVolumeCache __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEmptyVolumeCache __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEmptyVolumeCache __RPC_FAR * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Initialize )( 
            IEmptyVolumeCache __RPC_FAR * This,
            /* [in] */ HKEY hkRegKey,
            /* [in] */ LPCWSTR pcwszVolume,
            /* [out] */ LPWSTR __RPC_FAR *ppwszDisplayName,
            /* [out] */ LPWSTR __RPC_FAR *ppwszDescription,
            /* [out] */ DWORD __RPC_FAR *pdwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSpaceUsed )( 
            IEmptyVolumeCache __RPC_FAR * This,
            /* [out] */ DWORDLONG __RPC_FAR *pdwlSpaceUsed,
            /* [in] */ IEmptyVolumeCacheCallBack __RPC_FAR *picb);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Purge )( 
            IEmptyVolumeCache __RPC_FAR * This,
            /* [in] */ DWORDLONG dwlSpaceToFree,
            /* [in] */ IEmptyVolumeCacheCallBack __RPC_FAR *picb);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ShowProperties )( 
            IEmptyVolumeCache __RPC_FAR * This,
            /* [in] */ HWND hwnd);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Deactivate )( 
            IEmptyVolumeCache __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwFlags);
        
        END_INTERFACE
    } IEmptyVolumeCacheVtbl;

    interface IEmptyVolumeCache
    {
        CONST_VTBL struct IEmptyVolumeCacheVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEmptyVolumeCache_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEmptyVolumeCache_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEmptyVolumeCache_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEmptyVolumeCache_Initialize(This,hkRegKey,pcwszVolume,ppwszDisplayName,ppwszDescription,pdwFlags)	\
    (This)->lpVtbl -> Initialize(This,hkRegKey,pcwszVolume,ppwszDisplayName,ppwszDescription,pdwFlags)

#define IEmptyVolumeCache_GetSpaceUsed(This,pdwlSpaceUsed,picb)	\
    (This)->lpVtbl -> GetSpaceUsed(This,pdwlSpaceUsed,picb)

#define IEmptyVolumeCache_Purge(This,dwlSpaceToFree,picb)	\
    (This)->lpVtbl -> Purge(This,dwlSpaceToFree,picb)

#define IEmptyVolumeCache_ShowProperties(This,hwnd)	\
    (This)->lpVtbl -> ShowProperties(This,hwnd)

#define IEmptyVolumeCache_Deactivate(This,pdwFlags)	\
    (This)->lpVtbl -> Deactivate(This,pdwFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [local] */ HRESULT STDMETHODCALLTYPE IEmptyVolumeCache_Initialize_Proxy( 
    IEmptyVolumeCache __RPC_FAR * This,
    /* [in] */ HKEY hkRegKey,
    /* [in] */ LPCWSTR pcwszVolume,
    /* [out] */ LPWSTR __RPC_FAR *ppwszDisplayName,
    /* [out] */ LPWSTR __RPC_FAR *ppwszDescription,
    /* [out] */ DWORD __RPC_FAR *pdwFlags);


void __RPC_STUB IEmptyVolumeCache_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEmptyVolumeCache_GetSpaceUsed_Proxy( 
    IEmptyVolumeCache __RPC_FAR * This,
    /* [out] */ DWORDLONG __RPC_FAR *pdwlSpaceUsed,
    /* [in] */ IEmptyVolumeCacheCallBack __RPC_FAR *picb);


void __RPC_STUB IEmptyVolumeCache_GetSpaceUsed_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEmptyVolumeCache_Purge_Proxy( 
    IEmptyVolumeCache __RPC_FAR * This,
    /* [in] */ DWORDLONG dwlSpaceToFree,
    /* [in] */ IEmptyVolumeCacheCallBack __RPC_FAR *picb);


void __RPC_STUB IEmptyVolumeCache_Purge_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEmptyVolumeCache_ShowProperties_Proxy( 
    IEmptyVolumeCache __RPC_FAR * This,
    /* [in] */ HWND hwnd);


void __RPC_STUB IEmptyVolumeCache_ShowProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEmptyVolumeCache_Deactivate_Proxy( 
    IEmptyVolumeCache __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwFlags);


void __RPC_STUB IEmptyVolumeCache_Deactivate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEmptyVolumeCache_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_emptyvc_0109 */
/* [local] */ 

#endif
#ifndef _LPEMPTYVOLUMECACHE2_DEFINED
#define _LPEMPTYVOLUMECACHE2_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_emptyvc_0109_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_emptyvc_0109_v0_0_s_ifspec;

#ifndef __IEmptyVolumeCache2_INTERFACE_DEFINED__
#define __IEmptyVolumeCache2_INTERFACE_DEFINED__

/* interface IEmptyVolumeCache2 */
/* [unique][uuid][object] */ 

typedef /* [unique] */ IEmptyVolumeCache2 __RPC_FAR *LPEMPTYVOLUMECACHE2;


EXTERN_C const IID IID_IEmptyVolumeCache2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("02b7e3ba-4db3-11d2-b2d9-00c04f8eec8c")
    IEmptyVolumeCache2 : public IEmptyVolumeCache
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE InitializeEx( 
            /* [in] */ HKEY hkRegKey,
            /* [in] */ LPCWSTR pcwszVolume,
            /* [in] */ LPCWSTR pcwszKeyName,
            /* [out] */ LPWSTR __RPC_FAR *ppwszDisplayName,
            /* [out] */ LPWSTR __RPC_FAR *ppwszDescription,
            /* [out] */ LPWSTR __RPC_FAR *ppwszBtnText,
            /* [out] */ DWORD __RPC_FAR *pdwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEmptyVolumeCache2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEmptyVolumeCache2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEmptyVolumeCache2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEmptyVolumeCache2 __RPC_FAR * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Initialize )( 
            IEmptyVolumeCache2 __RPC_FAR * This,
            /* [in] */ HKEY hkRegKey,
            /* [in] */ LPCWSTR pcwszVolume,
            /* [out] */ LPWSTR __RPC_FAR *ppwszDisplayName,
            /* [out] */ LPWSTR __RPC_FAR *ppwszDescription,
            /* [out] */ DWORD __RPC_FAR *pdwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSpaceUsed )( 
            IEmptyVolumeCache2 __RPC_FAR * This,
            /* [out] */ DWORDLONG __RPC_FAR *pdwlSpaceUsed,
            /* [in] */ IEmptyVolumeCacheCallBack __RPC_FAR *picb);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Purge )( 
            IEmptyVolumeCache2 __RPC_FAR * This,
            /* [in] */ DWORDLONG dwlSpaceToFree,
            /* [in] */ IEmptyVolumeCacheCallBack __RPC_FAR *picb);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ShowProperties )( 
            IEmptyVolumeCache2 __RPC_FAR * This,
            /* [in] */ HWND hwnd);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Deactivate )( 
            IEmptyVolumeCache2 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwFlags);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InitializeEx )( 
            IEmptyVolumeCache2 __RPC_FAR * This,
            /* [in] */ HKEY hkRegKey,
            /* [in] */ LPCWSTR pcwszVolume,
            /* [in] */ LPCWSTR pcwszKeyName,
            /* [out] */ LPWSTR __RPC_FAR *ppwszDisplayName,
            /* [out] */ LPWSTR __RPC_FAR *ppwszDescription,
            /* [out] */ LPWSTR __RPC_FAR *ppwszBtnText,
            /* [out] */ DWORD __RPC_FAR *pdwFlags);
        
        END_INTERFACE
    } IEmptyVolumeCache2Vtbl;

    interface IEmptyVolumeCache2
    {
        CONST_VTBL struct IEmptyVolumeCache2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEmptyVolumeCache2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEmptyVolumeCache2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEmptyVolumeCache2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEmptyVolumeCache2_Initialize(This,hkRegKey,pcwszVolume,ppwszDisplayName,ppwszDescription,pdwFlags)	\
    (This)->lpVtbl -> Initialize(This,hkRegKey,pcwszVolume,ppwszDisplayName,ppwszDescription,pdwFlags)

#define IEmptyVolumeCache2_GetSpaceUsed(This,pdwlSpaceUsed,picb)	\
    (This)->lpVtbl -> GetSpaceUsed(This,pdwlSpaceUsed,picb)

#define IEmptyVolumeCache2_Purge(This,dwlSpaceToFree,picb)	\
    (This)->lpVtbl -> Purge(This,dwlSpaceToFree,picb)

#define IEmptyVolumeCache2_ShowProperties(This,hwnd)	\
    (This)->lpVtbl -> ShowProperties(This,hwnd)

#define IEmptyVolumeCache2_Deactivate(This,pdwFlags)	\
    (This)->lpVtbl -> Deactivate(This,pdwFlags)


#define IEmptyVolumeCache2_InitializeEx(This,hkRegKey,pcwszVolume,pcwszKeyName,ppwszDisplayName,ppwszDescription,ppwszBtnText,pdwFlags)	\
    (This)->lpVtbl -> InitializeEx(This,hkRegKey,pcwszVolume,pcwszKeyName,ppwszDisplayName,ppwszDescription,ppwszBtnText,pdwFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [local] */ HRESULT STDMETHODCALLTYPE IEmptyVolumeCache2_InitializeEx_Proxy( 
    IEmptyVolumeCache2 __RPC_FAR * This,
    /* [in] */ HKEY hkRegKey,
    /* [in] */ LPCWSTR pcwszVolume,
    /* [in] */ LPCWSTR pcwszKeyName,
    /* [out] */ LPWSTR __RPC_FAR *ppwszDisplayName,
    /* [out] */ LPWSTR __RPC_FAR *ppwszDescription,
    /* [out] */ LPWSTR __RPC_FAR *ppwszBtnText,
    /* [out] */ DWORD __RPC_FAR *pdwFlags);


void __RPC_STUB IEmptyVolumeCache2_InitializeEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEmptyVolumeCache2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_emptyvc_0110 */
/* [local] */ 

#endif


extern RPC_IF_HANDLE __MIDL_itf_emptyvc_0110_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_emptyvc_0110_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  HWND_UserSize(     unsigned long __RPC_FAR *, unsigned long            , HWND __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  HWND_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, HWND __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  HWND_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, HWND __RPC_FAR * ); 
void                      __RPC_USER  HWND_UserFree(     unsigned long __RPC_FAR *, HWND __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\errno.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/***
*errno.h - system wide error numbers (set by system calls)
*
*Purpose:
*       This file defines the system-wide error numbers (set by
*       system calls).  Conforms to the XENIX standard.  Extended
*       for compatibility with Uniforum standard.
*       [System V]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_ERRNO
#define _INC_ERRNO

#include <crtdefs.h>

#ifdef  __cplusplus
extern "C" {
#endif

/* Error Codes */

#define EPERM           1
#define ENOENT          2
#define ESRCH           3
#define EINTR           4
#define EIO             5
#define ENXIO           6
#define E2BIG           7
#define ENOEXEC         8
#define EBADF           9
#define ECHILD          10
#define EAGAIN          11
#define ENOMEM          12
#define EACCES          13
#define EFAULT          14
#define EBUSY           16
#define EEXIST          17
#define EXDEV           18
#define ENODEV          19
#define ENOTDIR         20
#define EISDIR          21
#define ENFILE          23
#define EMFILE          24
#define ENOTTY          25
#define EFBIG           27
#define ENOSPC          28
#define ESPIPE          29
#define EROFS           30
#define EMLINK          31
#define EPIPE           32
#define EDOM            33
#define EDEADLK         36
#define ENAMETOOLONG    38
#define ENOLCK          39
#define ENOSYS          40
#define ENOTEMPTY       41

/* Error codes used in the Secure CRT functions */

#ifndef RC_INVOKED
#if !defined(_SECURECRT_ERRCODE_VALUES_DEFINED)
#define _SECURECRT_ERRCODE_VALUES_DEFINED
#define EINVAL          22
#define ERANGE          34
#define EILSEQ          42
#define STRUNCATE       80
#endif
#endif


#ifdef  __cplusplus
}
#endif

#endif  /* _INC_ERRNO */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\errorrep.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//

#ifndef __ERRORREP_H__
#define __ERRORREP_H__

#ifdef __cplusplus
extern "C" {
#endif

typedef enum tagEFaultRepRetVal
{
    frrvOk = 0,
    frrvOkManifest,
    frrvOkQueued,
    frrvErr,
    frrvErrNoDW,
    frrvErrTimeout,
    frrvLaunchDebugger,
    frrvOkHeadless
} EFaultRepRetVal;

EFaultRepRetVal APIENTRY ReportFault(LPEXCEPTION_POINTERS pep, DWORD dwMode);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\errors.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this source code is subject to the terms of the Microsoft end-user
// license agreement (EULA) under which you licensed this SOFTWARE PRODUCT.
// If you did not accept the terms of the EULA, you are not authorized to use
// this source code. For a copy of the EULA, please see the LICENSE.RTF on your
// install media.
//
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//
//--------------------------------------------------------------------------;

#ifndef __ERRORS__
#define __ERRORS__

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

#ifndef _AMOVIE_
#define AMOVIEAPI   DECLSPEC_IMPORT
#else
#define AMOVIEAPI
#endif

// codes 0-01ff are reserved for OLE
#define VFW_FIRST_CODE   0x200
#define MAX_ERROR_TEXT_LEN 160

#include <VFWMSGS.H>                    // includes all message definitions

#ifdef UNICODE
typedef BOOL (WINAPI* AMGETERRORTEXTPROCW)(HRESULT, WCHAR *, DWORD);
AMOVIEAPI DWORD WINAPI AMGetErrorTextW( HRESULT hr , __out_ecount(MaxLen) WCHAR *pbuffer , DWORD MaxLen);
#define AMGetErrorText  AMGetErrorTextW
typedef AMGETERRORTEXTPROCW AMGETERRORTEXTPROC;
#else
typedef BOOL (WINAPI* AMGETERRORTEXTPROCA)(HRESULT, char *, DWORD);
AMOVIEAPI DWORD WINAPI AMGetErrorTextA( HRESULT hr , char *pbuffer , DWORD MaxLen);
#define AMGetErrorText  AMGetErrorTextA
typedef AMGETERRORTEXTPROCA AMGETERRORTEXTPROC;
#endif

#ifdef __cplusplus
}
#endif // __cplusplus
#endif // __ERRORS__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\evntcons.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//

/*++

Copyright 2004 (c) Microsoft Corporation. All rights reserved.

Module Name:

    evntcons.h

Abstract:

    This defines the event consumer API

Revision History:

    Insung Park (insungp) 26-Aug-2004 
        Created the file.

--*/

#ifndef _EVNTCONS_H_
#define _EVNTCONS_H_

#pragma once

#include <wmistr.h>
#include <evntrace.h>
#include <evntprov.h>

#ifdef __cplusplus
extern "C" {
#endif

#if defined (_MSC_VER)
#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4201) // nonstandard extension used : nameless struct/union
#pragma warning(disable:4214) // nonstandard extension used : bit field types other then int
#endif

#define EVENT_HEADER_EXT_TYPE_RELATED_ACTIVITYID   0x0001
#define EVENT_HEADER_EXT_TYPE_SID                  0x0002
#define EVENT_HEADER_EXT_TYPE_TS_ID                0x0003
#define EVENT_HEADER_EXT_TYPE_INSTANCE_INFO        0x0004

typedef struct _EVENT_HEADER_EXTENDED_DATA_ITEM {

    USHORT      Reserved1;                      // Reserved for internal use
    USHORT      ExtType;                        // Extended info type 
    struct {
        USHORT  Linkage             :  1;       // Indicates additional extended 
                                                // data item
        USHORT  Reserved2           : 15;
    };
    USHORT      DataSize;                       // Size of extended info data
    ULONGLONG   DataPtr;                        // Pointer to extended info data

} EVENT_HEADER_EXTENDED_DATA_ITEM, *PEVENT_HEADER_EXTENDED_DATA_ITEM;

//
// Structures for extended items.
//

typedef struct _EVENT_EXTENDED_ITEM_INSTANCE {
    ULONG InstanceId;
    ULONG ParentInstanceId;
    GUID  ParentGuid;
} EVENT_EXTENDED_ITEM_INSTANCE, *PEVENT_EXTENDED_ITEM_INSTANCE;

typedef struct _EVENT_EXTENDED_ITEM_RELATED_ACTIVITYID {
    GUID  RelatedActivityId;
} EVENT_EXTENDED_ITEM_RELATED_ACTIVITYID, *PEVENT_EXTENDED_ITEM_RELATED_ACTIVITYID;

typedef struct _EVENT_EXTENDED_ITEM_TS_ID {
    ULONG SessionId;
} EVENT_EXTENDED_ITEM_TS_ID, *PEVENT_EXTENDED_ITEM_TS_ID;


#define EVENT_HEADER_PROPERTY_XML               0x0001
#define EVENT_HEADER_PROPERTY_FORWARDED_XML     0x0002
#define EVENT_HEADER_PROPERTY_LEGACY_EVENTLOG   0x0004

#define EVENT_HEADER_FLAG_EXTENDED_INFO         0x0001
#define EVENT_HEADER_FLAG_PRIVATE_SESSION       0x0002
#define EVENT_HEADER_FLAG_STRING_ONLY           0x0004
#define EVENT_HEADER_FLAG_TRACE_MESSAGE         0x0008
#define EVENT_HEADER_FLAG_NO_CPUTIME            0x0010
#define EVENT_HEADER_FLAG_32_BIT_HEADER         0x0020
#define EVENT_HEADER_FLAG_64_BIT_HEADER         0x0040
#define EVENT_HEADER_FLAG_CLASSIC_HEADER        0x0100

typedef struct _EVENT_HEADER {

    USHORT              Size;                   // Event Size
    USHORT              HeaderType;             // Header Type
    USHORT              Flags;                  // Flags
    USHORT              EventProperty;          // User given event property
    ULONG               ThreadId;               // Thread Id
    ULONG               ProcessId;              // Process Id
    LARGE_INTEGER       TimeStamp;              // Event Timestamp
    GUID                ProviderId;             // Provider Id
    EVENT_DESCRIPTOR    EventDescriptor;        // Event Descriptor
    union {
        struct {
            ULONG       KernelTime;             // Kernel Mode CPU ticks
            ULONG       UserTime;               // User mode CPU ticks
        };
        ULONG64         ProcessorTime;          // Processor Clock 
                                                // for private session events
    };
    GUID                ActivityId;             // Activity Id

} EVENT_HEADER, *PEVENT_HEADER;

typedef struct _EVENT_RECORD {

    EVENT_HEADER        EventHeader;            // Event header
    ETW_BUFFER_CONTEXT  BufferContext;          // Buffer context
    USHORT              ExtendedDataCount;      // Number of extended
                                                // data items
    USHORT              UserDataLength;         // User data length
    PEVENT_HEADER_EXTENDED_DATA_ITEM            // Pointer to an array of 
                        ExtendedData;           // extended data items                                               
    PVOID               UserData;               // Pointer to user data
    PVOID               UserContext;            // Context from OpenTrace
} EVENT_RECORD, *PEVENT_RECORD;

#define EVENT_ENABLE_PROPERTY_SID                   0x00000001
#define EVENT_ENABLE_PROPERTY_TS_ID                 0x00000002

//
// Consumer API
//
#define PROCESS_TRACE_MODE_REAL_TIME                0x00000100
#define PROCESS_TRACE_MODE_RAW_TIMESTAMP            0x00001000
#define PROCESS_TRACE_MODE_EVENT_RECORD             0x10000000


//
// Event Security APIs
//

#if !defined(UNDER_CE)

typedef enum {
    EventSecuritySetDACL,
    EventSecuritySetSACL,
    EventSecurityAddDACL,
    EventSecurityAddSACL,
    EventSecurityMax
} EVENTSECURITYOPERATION;

#if (WINVER >= _WIN32_WINNT_LONGHORN)
ULONG
EVNTAPI
EventAccessControl(
    IN LPGUID                   Guid,
    IN ULONG                    Operation,
    IN PSID                     Sid,
    IN ULONG                    Rights,
    IN BOOLEAN                  AllowOrDeny
    );
#endif 

#if (WINVER >= _WIN32_WINNT_LONGHORN)
ULONG
EVNTAPI
EventAccessQuery(
    IN LPGUID                   Guid,
    IN OUT PSECURITY_DESCRIPTOR Buffer,
    IN OUT PULONG               BufferSize
    );
#endif

#if (WINVER >= _WIN32_WINNT_LONGHORN)
ULONG
EVNTAPI
EventAccessRemove(
    IN LPGUID                   Guid
    );
#endif 

#endif // !defined(UNDER_CE)

#if defined(UNDER_CE)
EXTERN_C
HANDLE
EVNTAPI 
CeEventSubscribe(
    __in_z LPCWSTR szChannelPath,
    __in DWORD grfSubscribeFlags,
    __in DWORD dwLevel,
    __in ULONGLONG ullMatchAnyKeywordMask,
    __in ULONGLONG ullMatchAllKeywordMask
    );


EXTERN_C
ULONG
EVNTAPI
CeEventNext(
    __in HANDLE hSubscription
    );

EXTERN_C
ULONG
EVNTAPI
CeEventRead(
    __in HANDLE hSubscription,
    __out PEVENT_DESCRIPTOR pEventDescriptor,
    __out_bcount_opt(cbEventData) PVOID pEventData,
    __in ULONG cbEventData,
    __out_opt ULONG* pcbEventData,
    __out_opt ULONG* pcEventDataDescriptors
    );


EXTERN_C
ULONG
EVNTAPI
CeEventClose(
    __in HANDLE hSubscription
    );


#endif // defined(UNDER_CE)

#if defined (_MSC_VER)
#if _MSC_VER >= 1200
#pragma warning(pop)              // restore 4201,4214
#else
#pragma warning(default:4201) // nonstandard extension used : nameless struct/union
#pragma warning(default:4214) // nonstandard extension used : bit field types other then int
#endif
#endif 

#ifdef __cplusplus
}
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\ex.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//

// CE's ExXxx Functions

#pragma once

#include <netwdm.h> // for PSLIST_HEADER, PSLIST_ENTRY

PSLIST_ENTRY
ExpInterlockedFlushSList (
    __inout PSLIST_HEADER ListHead);

PSLIST_ENTRY
ExpInterlockedPopEntrySList (
    __inout PSLIST_HEADER ListHead
    );

PSLIST_ENTRY
ExpInterlockedPushEntrySList (
    __inout PSLIST_HEADER ListHead,
    __inout PSLIST_ENTRY ListEntry
    );
    
    
__inline KPROCESSOR_MODE 
ExGetPreviousMode()
{
    return KernelMode;
}

///////////////////////////////////////////////////////////////////////////////
//  ExInterlockedPushEntrySList()
//
//  Routine Description:
//
//      Push a single SINGLE_LIST_ENTRY to the given SINGLE_LIST_HEADER with
//      lock taken.
//
//  Arguments:
//
//      pListHead   :: Points to SINGLE_LIST_HEADER structure to initialize.
//      pEntry      :: The SINGLE_LIST_ENTRY to be added.
//      pLock       :: Lock to take.
//
//  Return Value:
//
//      None.
//

_inline
VOID
ExInterlockedPushEntrySList(
    PSLIST_HEADER       pListHead,
    PSINGLE_LIST_ENTRY  pEntry,
    PKSPIN_LOCK         pLock)
{
    KeAcquireSpinLockAtDpcLevel(pLock);

    pEntry->Next         = pListHead->Next.Next;
    pListHead->Next.Next = pEntry;
    pListHead->Depth++;

    KeReleaseSpinLockFromDpcLevel(pLock);

}   //  ExInterlockedPushEntryList()



///////////////////////////////////////////////////////////////////////////////
//  ExInterlockedPopEntrySList()
//
//  Routine Description:
//
//      Extract a single SINGLE_LIST_ENTRY from a given SINGLE_LIST_HEADER with 
//      lock taken.
//
//  Arguments:
//
//      pListHead   :: Points to SINGLE_LIST_HEADER structure to initialize.
//      pLock       :: Lock to take.
//
//  Return Value:
//
//      SINGLE_LIST_ENTRY extracted.
//

_inline
PVOID
ExInterlockedPopEntrySList(
    PSLIST_HEADER   pListHead,
    PKSPIN_LOCK     pLock)
{
    PVOID   pvReturn;

    KeAcquireSpinLockAtDpcLevel(pLock);

    pvReturn = pListHead->Next.Next;
    
    if (pListHead->Next.Next)
    {
        pListHead->Next.Next = pListHead->Next.Next->Next;
        pListHead->Depth--;
    }

    KeReleaseSpinLockFromDpcLevel(pLock);
    
    return pvReturn;

}   //  ExInterlockedPopEntrySList()




//
//  Define executive resource data structures.
//

typedef CRITICAL_SECTION ERESOURCE, *PERESOURCE;

__inline NTSTATUS 
ExInitializeResourceLite(
    __out PERESOURCE pResource)
{
    InitializeCriticalSection(pResource);
    return STATUS_SUCCESS;
}

__inline NTSTATUS 
ExDeleteResourceLite(
    __inout PERESOURCE pResource)
{
    DeleteCriticalSection(pResource);
    return STATUS_SUCCESS;
}

__inline BOOLEAN
ExAcquireResourceExclusiveLite (
    __inout PERESOURCE pResource,
    __in BOOLEAN Wait)
//
//  The ExAcquireResourceExclusiveLite routine acquires the given resource for exclusive access by the calling thread.
//
//  ExAcquireResourceExclusiveLite returns TRUE if the resource is acquired. 
//  This routine returns FALSE if the input Wait is FALSE and exclusive access cannot be granted immediately.
//
{
    BOOLEAN ResourceAcquired;
    
    if (Wait)
    {
        EnterCriticalSection(pResource);
        ResourceAcquired = TRUE;
    }
    else
    {
#ifdef UNDER_CE
        ResourceAcquired = TryEnterCriticalSection(pResource) ? TRUE : FALSE;
#else
        ResourceAcquired = TryEnterCriticalSection(pResource);
#endif
    }
    
    return ResourceAcquired;
}

__inline BOOLEAN
ExAcquireResourceSharedLite (
    __inout PERESOURCE pResource,
    __in BOOLEAN Wait)
//
//  The ExAcquireResourceSharedLite routine acquires the given resource for shared access by the calling thread.
//
{
    // For simplification on CE, we just use exclusive access all the time.
    
    return ExAcquireResourceExclusiveLite(pResource, Wait);
}

__inline VOID
ExReleaseResourceLite(
    __inout PERESOURCE pResource
    )
{
    LeaveCriticalSection(pResource);
}

#define ExInitializeResource        ExInitializeResourceLite
#define ExDeleteResource            ExDeleteResourceLite
#define	ExAcquireResourceExclusive	ExAcquireResourceExclusiveLite
#define	ExAcquireResourceShared  	ExAcquireResourceSharedLite
#define	ExReleaseResource           ExReleaseResourceLite

//
//  ExCallback support
//

#ifndef UNDER_CE
#include <lpc.h> // For POBJECT_ATTRIBUTES
#endif

typedef VOID (*PCALLBACK_FUNCTION ) (
    __in_opt PVOID CallbackContext,
    __in_opt PVOID Argument1,
    __in_opt PVOID Argument2
    );

#ifndef UNDER_CE
VOID
ExNotifyCallback (
    __in PVOID CallbackObject,
    __in_opt PVOID Argument1,
    __in_opt PVOID Argument2
    );

NTSTATUS
ExCreateCallback (
    __deref_out PCALLBACK_OBJECT *CallbackObject,
    __in POBJECT_ATTRIBUTES ObjectAttributes,
    __in BOOLEAN Create,
    __in BOOLEAN AllowMultipleCallbacks
    );
#endif

typedef GUID UUID;

#ifdef UNDER_CE
NTSTATUS 
#else
NTSTATUS RPC_ENTRY
#endif
ExUuidCreate (
    OUT UUID  * Uuid
    );
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\evntrace.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    EvnTrace.h

Abstract:

    Public headers for event tracing control applications,
    consumers and providers

--*/

#ifndef _EVNTRACE_
#define _EVNTRACE_

#pragma once

#if defined(_WINNT_) || defined(WINNT)
#ifndef WMIAPI
#ifndef MIDL_PASS
#ifdef _WMI_SOURCE_
#define WMIAPI __stdcall
#else
#define WMIAPI DECLSPEC_IMPORT __stdcall
#endif // _WMI_SOURCE
#endif // MIDL_PASS

#endif // WMIAPI

#if defined(UNDER_CE)
typedef const GUID* LPCGUID;
typedef GUID* LPGUID;
#else
#include <guiddef.h>
#endif // !defined(UNDER_CE)

#if !defined(UNDER_CE)
//
// EventTraceGuid is used to identify a event tracing session
//
DEFINE_GUID ( /* 68fdd900-4a3e-11d1-84f4-0000f80464e3 */
    EventTraceGuid,
    0x68fdd900,
    0x4a3e,
    0x11d1,
    0x84, 0xf4, 0x00, 0x00, 0xf8, 0x04, 0x64, 0xe3
  );

//
// SystemTraceControlGuid. Used to specify event tracing for kernel
//
DEFINE_GUID ( /* 9e814aad-3204-11d2-9a82-006008a86939 */
    SystemTraceControlGuid,
    0x9e814aad,
    0x3204,
    0x11d2,
    0x9a, 0x82, 0x00, 0x60, 0x08, 0xa8, 0x69, 0x39
  );

//
// EventTraceConfigGuid. Used to report system configuration records
//
DEFINE_GUID ( /* 01853a65-418f-4f36-aefc-dc0f1d2fd235 */
    EventTraceConfigGuid,
    0x01853a65,
    0x418f,
    0x4f36,
    0xae, 0xfc, 0xdc, 0x0f, 0x1d, 0x2f, 0xd2, 0x35
  );

//
// DefaultTraceSecurityGuid. Specifies the default event tracing security
//
DEFINE_GUID ( /* 0811c1af-7a07-4a06-82ed-869455cdf713 */
    DefaultTraceSecurityGuid,
    0x0811c1af,
    0x7a07,
    0x4a06,
    0x82, 0xed, 0x86, 0x94, 0x55, 0xcd, 0xf7, 0x13
  );



#endif // !defined(UNDER_CE)

#define KERNEL_LOGGER_NAMEW         L"NT Kernel Logger"
#define GLOBAL_LOGGER_NAMEW         L"GlobalLogger"
#define EVENT_LOGGER_NAMEW          L"EventLog"
#define DIAG_LOGGER_NAMEW           L"DiagLog"

#define KERNEL_LOGGER_NAMEA         "NT Kernel Logger"
#define GLOBAL_LOGGER_NAMEA         "GlobalLogger"
#define EVENT_LOGGER_NAMEA          "EventLog"
#define DIAG_LOGGER_NAMEA           "DiagLog"



#define MAX_MOF_FIELDS                      16  // Limit of USE_MOF_PTR fields
typedef ULONG64 TRACEHANDLE, *PTRACEHANDLE;

//types for event data going to System Event Logger
#define SYSTEM_EVENT_TYPE                        1

//
// predefined generic event types (0x00 to 0x09 reserved).
//

#define EVENT_TRACE_TYPE_INFO               0x00  // Info or point event
#define EVENT_TRACE_TYPE_START              0x01  // Start event
#define EVENT_TRACE_TYPE_END                0x02  // End event
#define EVENT_TRACE_TYPE_STOP               0x02  // Stop event (WinEvent compatible)
#define EVENT_TRACE_TYPE_DC_START           0x03  // Collection start marker
#define EVENT_TRACE_TYPE_DC_END             0x04  // Collection end marker
#define EVENT_TRACE_TYPE_EXTENSION          0x05  // Extension/continuation
#define EVENT_TRACE_TYPE_REPLY              0x06  // Reply event
#define EVENT_TRACE_TYPE_DEQUEUE            0x07  // De-queue event
#define EVENT_TRACE_TYPE_RESUME             0x07  // Resume event (WinEvent compatible)
#define EVENT_TRACE_TYPE_CHECKPOINT         0x08  // Generic checkpoint event
#define EVENT_TRACE_TYPE_SUSPEND            0x08  // Suspend event (WinEvent compatible)
#define EVENT_TRACE_TYPE_WINEVT_SEND        0x09  // Send Event (WinEvent compatible)
#define EVENT_TRACE_TYPE_WINEVT_RECEIVE     0XF0  // Receive Event (WinEvent compatible)

//
// Predefined Event Tracing Levels for Software/Debug Tracing
//
//
// Trace Level is UCHAR and passed in through the EnableLevel parameter
// in EnableTrace API. It is retrieved by the provider using the
// GetTraceEnableLevel macro.It should be interpreted as an integer value
// to mean everything at or below that level will be traced.
//
// Here are the possible Levels.
//

#define TRACE_LEVEL_NONE        0   // Tracing is not on
#define TRACE_LEVEL_CRITICAL    1   // Abnormal exit or termination
#define TRACE_LEVEL_FATAL       1   // Deprecated name for Abnormal exit or termination
#define TRACE_LEVEL_ERROR       2   // Severe errors that need logging
#define TRACE_LEVEL_WARNING     3   // Warnings such as allocation failure
#define TRACE_LEVEL_INFORMATION 4   // Includes non-error cases(e.g.,Entry-Exit)
#define TRACE_LEVEL_VERBOSE     5   // Detailed traces from intermediate steps
#define TRACE_LEVEL_RESERVED6   6
#define TRACE_LEVEL_RESERVED7   7
#define TRACE_LEVEL_RESERVED8   8
#define TRACE_LEVEL_RESERVED9   9


//
// Event types for Process & Threads
//

#define EVENT_TRACE_TYPE_LOAD                  0x0A      // Load image

//
// Event types for IO subsystem
//

#define EVENT_TRACE_TYPE_IO_READ               0x0A
#define EVENT_TRACE_TYPE_IO_WRITE              0x0B
#define EVENT_TRACE_TYPE_IO_READ_INIT          0x0C
#define EVENT_TRACE_TYPE_IO_WRITE_INIT         0x0D
#define EVENT_TRACE_TYPE_IO_FLUSH              0x0E
#define EVENT_TRACE_TYPE_IO_FLUSH_INIT         0x0F


//
// Event types for Memory subsystem
//

#define EVENT_TRACE_TYPE_MM_TF                 0x0A      // Transition fault
#define EVENT_TRACE_TYPE_MM_DZF                0x0B      // Demand Zero fault
#define EVENT_TRACE_TYPE_MM_COW                0x0C      // Copy on Write
#define EVENT_TRACE_TYPE_MM_GPF                0x0D      // Guard Page fault
#define EVENT_TRACE_TYPE_MM_HPF                0x0E      // Hard page fault
#define EVENT_TRACE_TYPE_MM_AV                 0x0F      // Access violation

//
// Event types for Network subsystem, all protocols
//

#define EVENT_TRACE_TYPE_SEND                  0x0A     // Send
#define EVENT_TRACE_TYPE_RECEIVE               0x0B     // Receive
#define EVENT_TRACE_TYPE_CONNECT               0x0C     // Connect
#define EVENT_TRACE_TYPE_DISCONNECT            0x0D     // Disconnect
#define EVENT_TRACE_TYPE_RETRANSMIT            0x0E     // ReTransmit
#define EVENT_TRACE_TYPE_ACCEPT                0x0F     // Accept
#define EVENT_TRACE_TYPE_RECONNECT             0x10     // ReConnect
#define EVENT_TRACE_TYPE_CONNFAIL              0x11     // Fail
#define EVENT_TRACE_TYPE_COPY_TCP              0x12     // Copy in PendData
#define EVENT_TRACE_TYPE_COPY_ARP              0x13     // NDIS_STATUS_RESOURCES Copy
#define EVENT_TRACE_TYPE_ACKFULL               0x14     // A full data ACK
#define EVENT_TRACE_TYPE_ACKPART               0x15     // A Partial data ACK
#define EVENT_TRACE_TYPE_ACKDUP                0x16     // A Duplicate data ACK


//
// Event Types for the Header (to handle internal event headers)
//

#define EVENT_TRACE_TYPE_GUIDMAP                0x0A
#define EVENT_TRACE_TYPE_CONFIG                 0x0B
#define EVENT_TRACE_TYPE_SIDINFO                0x0C
#define EVENT_TRACE_TYPE_SECURITY               0x0D

//
// Event Types for Registry subsystem
//

#define EVENT_TRACE_TYPE_REGCREATE                  0x0A     // NtCreateKey
#define EVENT_TRACE_TYPE_REGOPEN                    0x0B     // NtOpenKey
#define EVENT_TRACE_TYPE_REGDELETE                  0x0C     // NtDeleteKey
#define EVENT_TRACE_TYPE_REGQUERY                   0x0D     // NtQueryKey
#define EVENT_TRACE_TYPE_REGSETVALUE                0x0E     // NtSetValueKey
#define EVENT_TRACE_TYPE_REGDELETEVALUE             0x0F     // NtDeleteValueKey
#define EVENT_TRACE_TYPE_REGQUERYVALUE              0x10     // NtQueryValueKey
#define EVENT_TRACE_TYPE_REGENUMERATEKEY            0x11     // NtEnumerateKey
#define EVENT_TRACE_TYPE_REGENUMERATEVALUEKEY       0x12     // NtEnumerateValueKey
#define EVENT_TRACE_TYPE_REGQUERYMULTIPLEVALUE      0x13     // NtQueryMultipleValueKey
#define EVENT_TRACE_TYPE_REGSETINFORMATION          0x14     // NtSetInformationKey
#define EVENT_TRACE_TYPE_REGFLUSH                   0x15     // NtFlushKey
#define EVENT_TRACE_TYPE_REGKCBCREATE               0x16     // KcbCreate
#define EVENT_TRACE_TYPE_REGKCBDELETE               0x17     // KcbDelete
#define EVENT_TRACE_TYPE_REGKCBRUNDOWNBEGIN         0x18     // KcbRundownBegin
#define EVENT_TRACE_TYPE_REGKCBRUNDOWNEND           0x19     // KcbRundownEnd
#define EVENT_TRACE_TYPE_REGVIRTUALIZE              0x1A     // VirtualizeKey
#define EVENT_TRACE_TYPE_REGCLOSE                   0x1B     // NtClose (KeyObject)

//
// Event types for system configuration records
//
#define EVENT_TRACE_TYPE_CONFIG_CPU             0x0A     // CPU Configuration
#define EVENT_TRACE_TYPE_CONFIG_PHYSICALDISK    0x0B     // Physical Disk Configuration
#define EVENT_TRACE_TYPE_CONFIG_LOGICALDISK     0x0C     // Logical Disk Configuration
#define EVENT_TRACE_TYPE_CONFIG_NIC             0x0D     // NIC Configuration
#define EVENT_TRACE_TYPE_CONFIG_VIDEO           0x0E     // Video Adapter Configuration
#define EVENT_TRACE_TYPE_CONFIG_SERVICES        0x0F     // Active Services
#define EVENT_TRACE_TYPE_CONFIG_POWER           0x10     // ACPI Configuration
#define EVENT_TRACE_TYPE_CONFIG_NETINFO         0x11     // Networking Configuration

#define EVENT_TRACE_TYPE_CONFIG_IRQ             0x15     // IRQ assigned to devices
#define EVENT_TRACE_TYPE_CONFIG_PNP             0x16     // PnP device info
#define EVENT_TRACE_TYPE_CONFIG_IDECHANNEL      0x17     // Primary/Secondary IDE channel Configuration


//
// Enable flags for Kernel Events
//
#define EVENT_TRACE_FLAG_PROCESS            0x00000001  // process start & end
#define EVENT_TRACE_FLAG_THREAD             0x00000002  // thread start & end
#define EVENT_TRACE_FLAG_IMAGE_LOAD         0x00000004  // image load

#define EVENT_TRACE_FLAG_DISK_IO            0x00000100  // physical disk IO
#define EVENT_TRACE_FLAG_DISK_FILE_IO       0x00000200  // requires disk IO

#define EVENT_TRACE_FLAG_MEMORY_PAGE_FAULTS 0x00001000  // all page faults
#define EVENT_TRACE_FLAG_MEMORY_HARD_FAULTS 0x00002000  // hard faults only

#define EVENT_TRACE_FLAG_NETWORK_TCPIP      0x00010000  // tcpip send & receive

#define EVENT_TRACE_FLAG_REGISTRY           0x00020000  // registry calls
#define EVENT_TRACE_FLAG_DBGPRINT           0x00040000  // DbgPrint(ex) Calls

//
// Enable flags for Kernel Events on Vista and above 
//
#define EVENT_TRACE_FLAG_PROCESS_COUNTERS   0x00000008  // process perf counters
#define EVENT_TRACE_FLAG_CSWITCH            0x00000010  // context switches 
#define EVENT_TRACE_FLAG_DPC                0x00000020  // deffered procedure calls 
#define EVENT_TRACE_FLAG_INTERRUPT          0x00000040  // interrupts
#define EVENT_TRACE_FLAG_SYSTEMCALL         0x00000080  // system calls

#define EVENT_TRACE_FLAG_DISK_IO_INIT       0x00000400  // physical disk IO initiation

#define EVENT_TRACE_FLAG_ALPC               0x00100000  // ALPC traces
#define EVENT_TRACE_FLAG_SPLIT_IO           0x00200000  // split io traces (VolumeManager)

#define EVENT_TRACE_FLAG_DRIVER             0x00800000  // driver delays
#define EVENT_TRACE_FLAG_PROFILE            0x01000000  // sample based profiling
#define EVENT_TRACE_FLAG_FILE_IO            0x02000000  // file IO
#define EVENT_TRACE_FLAG_FILE_IO_INIT       0x04000000  // file IO initiation

//
// Pre-defined Enable flags for everybody else
//
#define EVENT_TRACE_FLAG_EXTENSION          0x80000000  // Indicates more flags
#define EVENT_TRACE_FLAG_FORWARD_WMI        0x40000000  // Can forward to WMI
#define EVENT_TRACE_FLAG_ENABLE_RESERVE     0x20000000  // Reserved

//
// Logger Mode flags
//
#define EVENT_TRACE_FILE_MODE_NONE          0x00000000  // Logfile is off
#define EVENT_TRACE_FILE_MODE_SEQUENTIAL    0x00000001  // Log sequentially
#define EVENT_TRACE_FILE_MODE_CIRCULAR      0x00000002  // Log in circular manner
#define EVENT_TRACE_FILE_MODE_APPEND        0x00000004  // Append sequential log

#define EVENT_TRACE_REAL_TIME_MODE          0x00000100  // Real time mode on
#define EVENT_TRACE_DELAY_OPEN_FILE_MODE    0x00000200  // Delay opening file
#define EVENT_TRACE_BUFFERING_MODE          0x00000400  // Buffering mode only
#define EVENT_TRACE_PRIVATE_LOGGER_MODE     0x00000800  // Process Private Logger
#define EVENT_TRACE_ADD_HEADER_MODE         0x00001000  // Add a logfile header

#define EVENT_TRACE_USE_GLOBAL_SEQUENCE     0x00004000  // Use global sequence no.
#define EVENT_TRACE_USE_LOCAL_SEQUENCE      0x00008000  // Use local sequence no.

#define EVENT_TRACE_RELOG_MODE              0x00010000  // Relogger

#define EVENT_TRACE_USE_PAGED_MEMORY        0x01000000  // Use pageable buffers

//
// Logger Mode flags on XP and above
//
#define EVENT_TRACE_FILE_MODE_NEWFILE       0x00000008  // Auto-switch log file
#define EVENT_TRACE_FILE_MODE_PREALLOCATE   0x00000020  // Pre-allocate mode

//
// Logger Mode flags on Vista and above
//
#define EVENT_TRACE_NONSTOPPABLE_MODE       0x00000040  // Session cannot be stopped (Autologger only)
#define EVENT_TRACE_SECURE_MODE             0x00000080  // Secure session
#define EVENT_TRACE_USE_KBYTES_FOR_SIZE     0x00002000  // Use KBytes as file size unit
#define EVENT_TRACE_PRIVATE_IN_PROC         0x00020000  // In process private logger
#define EVENT_TRACE_MODE_RESERVED           0x00100000  // Reserved bit, used to signal Heap/Critsec tracing


//
// ControlTrace Codes
//
#define EVENT_TRACE_CONTROL_QUERY           0
#define EVENT_TRACE_CONTROL_STOP            1
#define EVENT_TRACE_CONTROL_UPDATE          2

//
// Flush ControlTrace Codes for XP and above
//
#define EVENT_TRACE_CONTROL_FLUSH           3       // Flushes all the buffers

//
// Flags used by WMI Trace Message
// Note that the order or value of these flags should NOT be changed as they are processed
// in this order.
//
#define TRACE_MESSAGE_SEQUENCE              1  // Message should include a sequence number
#define TRACE_MESSAGE_GUID                  2  // Message includes a GUID
#define TRACE_MESSAGE_COMPONENTID           4  // Message has no GUID, Component ID instead
#define TRACE_MESSAGE_TIMESTAMP             8  // Message includes a timestamp
#define TRACE_MESSAGE_PERFORMANCE_TIMESTAMP 16 // *Obsolete* Clock type is controlled by the logger
#define TRACE_MESSAGE_SYSTEMINFO            32 // Message includes system information TID,PID

//
// Vista flags set by system to indicate provider pointer size.
//

#define TRACE_MESSAGE_POINTER32             0x0040  // Message logged by 32 bit provider
#define TRACE_MESSAGE_POINTER64             0x0080  // Message logged by 64 bit provider

#define TRACE_MESSAGE_FLAG_MASK         0xFFFF  // Only the lower 16 bits of flags are placed in the message
                                                // those above 16 bits are reserved for local processing
#define TRACE_MESSAGE_MAXIMUM_SIZE  8*1024      // the maximum size allowed for a single trace message
                                                // longer messages will return ERROR_BUFFER_OVERFLOW
//
// Flags to indicate to consumer which fields
// in the EVENT_TRACE_HEADER are valid
//

#define EVENT_TRACE_USE_PROCTIME   0x0001    // ProcessorTime field is valid
#define EVENT_TRACE_USE_NOCPUTIME  0x0002    // No Kernel/User/Processor Times

//
// TRACE_HEADER_FLAG values are used in the Flags field of EVENT_TRACE_HEADER
// structure while calling into TraceEvent API
//

#define TRACE_HEADER_FLAG_USE_TIMESTAMP     0x00000200
#define TRACE_HEADER_FLAG_TRACED_GUID       0x00020000 // denotes a trace
#define TRACE_HEADER_FLAG_LOG_WNODE         0x00040000 // request to log Wnode
#define TRACE_HEADER_FLAG_USE_GUID_PTR      0x00080000 // Guid is actually a pointer
#define TRACE_HEADER_FLAG_USE_MOF_PTR       0x00100000 // MOF data are dereferenced

#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning (disable:4201)

//
// Trace header for all legacy events. 
//

typedef struct _EVENT_TRACE_HEADER {        // overlays WNODE_HEADER
    USHORT          Size;                   // Size of entire record
    union {
        USHORT      FieldTypeFlags;         // Indicates valid fields
        struct {
            UCHAR   HeaderType;             // Header type - internal use only
            UCHAR   MarkerFlags;            // Marker - internal use only
        };
    };
    union {
        ULONG       Version;
        struct {
            UCHAR   Type;                   // event type
            UCHAR   Level;                  // trace instrumentation level
            USHORT  Version;                // version of trace record
        } Class;
    };
    ULONG           ThreadId;               // Thread Id
    ULONG           ProcessId;              // Process Id
    LARGE_INTEGER   TimeStamp;              // time when event happens
    union {
        GUID        Guid;                   // Guid that identifies event
        ULONGLONG   GuidPtr;                // use with WNODE_FLAG_USE_GUID_PTR
    };
    union {
        struct {
            ULONG   KernelTime;             // Kernel Mode CPU ticks
            ULONG   UserTime;               // User mode CPU ticks
        };
        ULONG64     ProcessorTime;          // Processor Clock
        struct {
            ULONG   ClientContext;          // Reserved
            ULONG   Flags;                  // Event Flags
        };
    };
} EVENT_TRACE_HEADER, *PEVENT_TRACE_HEADER;

//
// This header is used to trace and track transaction co-relations
//
typedef struct _EVENT_INSTANCE_HEADER {
    USHORT          Size;
    union {
        USHORT      FieldTypeFlags;     // Indicates valid fields
        struct {
            UCHAR   HeaderType;         // Header type - internal use only
            UCHAR   MarkerFlags;        // Marker - internal use only
        };
    };
    union {
        ULONG       Version;
        struct {
            UCHAR   Type;
            UCHAR   Level;
            USHORT  Version;
        } Class;
    };
    ULONG           ThreadId;
    ULONG           ProcessId;
    LARGE_INTEGER   TimeStamp;
    ULONGLONG       RegHandle;
    ULONG           InstanceId;
    ULONG           ParentInstanceId;
    union {
        struct {
            ULONG   KernelTime;             // Kernel Mode CPU ticks
            ULONG   UserTime;               // User mode CPU ticks
        };
        ULONG64     ProcessorTime;          // Processor Clock
        struct {
            ULONG   EventId;                // Event ID
            ULONG   Flags;                  // Trace header Flags
        };
    };
    ULONGLONG       ParentRegHandle;
} EVENT_INSTANCE_HEADER, *PEVENT_INSTANCE_HEADER;

#if _MSC_VER >= 1200
#pragma warning(pop)
#endif

//
// Following are structures and macros for use with USE_MOF_PTR
//

// Trace data types
#define ETW_NULL_TYPE_VALUE                 0
#define ETW_OBJECT_TYPE_VALUE               1
#define ETW_STRING_TYPE_VALUE               2
#define ETW_SBYTE_TYPE_VALUE                3
#define ETW_BYTE_TYPE_VALUE                 4
#define ETW_INT16_TYPE_VALUE                5
#define ETW_UINT16_TYPE_VALUE               6
#define ETW_INT32_TYPE_VALUE                7
#define ETW_UINT32_TYPE_VALUE               8
#define ETW_INT64_TYPE_VALUE                9
#define ETW_UINT64_TYPE_VALUE               10
#define ETW_CHAR_TYPE_VALUE                 11
#define ETW_SINGLE_TYPE_VALUE               12
#define ETW_DOUBLE_TYPE_VALUE               13
#define ETW_BOOLEAN_TYPE_VALUE              14
#define ETW_DECIMAL_TYPE_VALUE              15
// Extended types
#define ETW_GUID_TYPE_VALUE                 101
#define ETW_ASCIICHAR_TYPE_VALUE            102
#define ETW_ASCIISTRING_TYPE_VALUE          103
#define ETW_COUNTED_STRING_TYPE_VALUE       104
#define ETW_POINTER_TYPE_VALUE              105
#define ETW_SIZET_TYPE_VALUE                106
#define ETW_HIDDEN_TYPE_VALUE               107
#define ETW_BOOL_TYPE_VALUE                 108
#define ETW_COUNTED_ANSISTRING_TYPE_VALUE   109
#define ETW_REVERSED_COUNTED_STRING_TYPE_VALUE 110
#define ETW_REVERSED_COUNTED_ANSISTRING_TYPE_VALUE 111
#define ETW_NON_NULL_TERMINATED_STRING_TYPE_VALUE 112
#define ETW_REDUCED_ANSISTRING_TYPE_VALUE   113
#define ETW_REDUCED_STRING_TYPE_VALUE       114
#define ETW_SID_TYPE_VALUE                  115
#define ETW_VARIANT_TYPE_VALUE              116
#define ETW_PTVECTOR_TYPE_VALUE             117
#define ETW_WMITIME_TYPE_VALUE              118
#define ETW_DATETIME_TYPE_VALUE             119
#define ETW_REFRENCE_TYPE_VALUE             120


#define DEFINE_TRACE_MOF_FIELD(MOF, ptr, length, type) \
    (MOF)->DataPtr  = (ULONG64) ptr; \
    (MOF)->Length   = (ULONG) length; \
    (MOF)->DataType = (ULONG) type;

typedef struct _MOF_FIELD {
    ULONG64     DataPtr;    // Pointer to the field. Up to 64-bits only
    ULONG       Length;     // Length of the MOF field
    ULONG       DataType;   // Type of data
} MOF_FIELD, *PMOF_FIELD;



#if !(defined(_NTDDK_) || defined(_NTIFS_)) || defined(_WMIKM_)

#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning (disable:4201)

//
// This is the header for every logfile. The memory for LoggerName
// and LogFileName must be contiguous adjacent to this structure
// Allows both user-mode and kernel-mode to understand the header
//
typedef struct _TRACE_LOGFILE_HEADER {
    ULONG           BufferSize;         // Logger buffer size in Kbytes
    union {
        ULONG       Version;            // Logger version
        struct {
            UCHAR   MajorVersion;
            UCHAR   MinorVersion;
            UCHAR   SubVersion;
            UCHAR   SubMinorVersion;
        } VersionDetail;
    };
    ULONG           ProviderVersion;    // defaults to NT version
    ULONG           NumberOfProcessors; // Number of Processors
    LARGE_INTEGER   EndTime;            // Time when logger stops
    ULONG           TimerResolution;    // assumes timer is constant!!!
    ULONG           MaximumFileSize;    // Maximum in Mbytes
    ULONG           LogFileMode;        // specify logfile mode
    ULONG           BuffersWritten;     // used to file start of Circular File
    union {
        GUID LogInstanceGuid;           // For RealTime Buffer Delivery
        struct {
            ULONG   StartBuffers;       // Count of buffers written at start.
            ULONG   PointerSize;        // Size of pointer type in bits
            ULONG   EventsLost;         // Events losts during log session
            ULONG   CpuSpeedInMHz;      // Cpu Speed in MHz
        };
    };
#if defined(_WMIKM_)
    PWCHAR          LoggerName;
    PWCHAR          LogFileName;
    RTL_TIME_ZONE_INFORMATION TimeZone;
#else
    LPWSTR          LoggerName;
    LPWSTR          LogFileName;
    TIME_ZONE_INFORMATION TimeZone;
#endif
    LARGE_INTEGER   BootTime;
    LARGE_INTEGER   PerfFreq;           // Reserved
    LARGE_INTEGER   StartTime;          // Reserved
    ULONG           ReservedFlags;      // Reserved
    ULONG           BuffersLost;
} TRACE_LOGFILE_HEADER, *PTRACE_LOGFILE_HEADER;

#if _MSC_VER >= 1200
#pragma warning(pop)
#endif

#endif // !_NTDDK_ || _WMIKM_

//
// Instance Information to track parent child relationship of Instances.
//
typedef struct EVENT_INSTANCE_INFO {
    HANDLE      RegHandle;
    ULONG       InstanceId;
} EVENT_INSTANCE_INFO, *PEVENT_INSTANCE_INFO;

#if !defined(_WMIKM_) && !defined(_NTDDK_) && !defined(_NTIFS_)
//
// Structures that have UNICODE and ANSI versions are defined here
//

//
// Logger configuration and running statistics. This structure is used
// by user-mode callers, such as PDH library
//

typedef struct _EVENT_TRACE_PROPERTIES {
    WNODE_HEADER Wnode;
//
// data provided by caller
    ULONG BufferSize;                   // buffer size for logging (kbytes)
    ULONG MinimumBuffers;               // minimum to preallocate
    ULONG MaximumBuffers;               // maximum buffers allowed
    ULONG MaximumFileSize;              // maximum logfile size (in MBytes)
    ULONG LogFileMode;                  // sequential, circular
    ULONG FlushTimer;                   // buffer flush timer, in seconds
    ULONG EnableFlags;                  // trace enable flags
    LONG  AgeLimit;                     // age decay time, in minutes

// data returned to caller
    ULONG NumberOfBuffers;              // no of buffers in use
    ULONG FreeBuffers;                  // no of buffers free
    ULONG EventsLost;                   // event records lost
    ULONG BuffersWritten;               // no of buffers written to file
    ULONG LogBuffersLost;               // no of logfile write failures
    ULONG RealTimeBuffersLost;          // no of rt delivery failures
    HANDLE LoggerThreadId;              // thread id of Logger
    ULONG LogFileNameOffset;            // Offset to LogFileName
    ULONG LoggerNameOffset;             // Offset to LoggerName
} EVENT_TRACE_PROPERTIES, *PEVENT_TRACE_PROPERTIES;

// NOTE:
// If AgeLimit is 0, default is used
// If AgeLimit is < 0, buffer aging is turned off


//
// Data Provider structures
//
// Used by RegisterTraceGuids()
//
typedef struct  _TRACE_GUID_REGISTRATION {
    LPCGUID Guid;            // Guid of data block being registered or updated.
    HANDLE RegHandle;        // Guid Registration Handle is returned.
} TRACE_GUID_REGISTRATION, *PTRACE_GUID_REGISTRATION;

//
// Data consumer structures
//

#endif // !_NTDDK_ || _WMIKM_

typedef struct _TRACE_GUID_PROPERTIES {
    GUID    Guid;
    ULONG   GuidType;
    ULONG   LoggerId;
    ULONG   EnableLevel;
    ULONG   EnableFlags;
    BOOLEAN     IsEnable;
} TRACE_GUID_PROPERTIES, *PTRACE_GUID_PROPERTIES;

typedef struct _ETW_BUFFER_CONTEXT {
    UCHAR                   ProcessorNumber;
    UCHAR                   Alignment;
    USHORT                  LoggerId;
} ETW_BUFFER_CONTEXT, *PETW_BUFFER_CONTEXT;

//
// Provider Information Flags used on Vista and above
//
#define TRACE_PROVIDER_FLAG_LEGACY (0x00000001)
#define TRACE_PROVIDER_FLAG_PRE_ENABLE (0x00000002)

//
// Enable Information for Provider Instance 
// Used on Vista and above
//
typedef struct _TRACE_ENABLE_INFO {

    ULONG       IsEnabled;
    UCHAR       Level;
    UCHAR       Reserved1;
    USHORT      LoggerId;
    ULONG       EnableProperty;
    ULONG       Reserved2;
    ULONGLONG   MatchAnyKeyword;
    ULONGLONG   MatchAllKeyword;    

} TRACE_ENABLE_INFO, *PTRACE_ENABLE_INFO;

//
// Instance Information for Provider 
// Used on Vista and above
//
typedef struct _TRACE_PROVIDER_INSTANCE_INFO {

    ULONG NextOffset;
    ULONG EnableCount;
    ULONG Pid;
    ULONG Flags;
    
} TRACE_PROVIDER_INSTANCE_INFO, *PTRACE_PROVIDER_INSTANCE_INFO;

//
// GUID Information Used on Vista and above
//
typedef struct _TRACE_GUID_INFO {
    ULONG InstanceCount;
    ULONG Reserved;
} TRACE_GUID_INFO, *PTRACE_GUID_INFO;

//
// An EVENT_TRACE consists of a fixed header (EVENT_TRACE_HEADER) and
// optionally a variable portion pointed to by MofData. The datablock
// layout of the variable portion is unknown to the Logger and must
// be obtained from WBEM CIMOM database.
//

#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning (disable:4201)
typedef struct _EVENT_TRACE {
    EVENT_TRACE_HEADER      Header;             // Event trace header
    ULONG                   InstanceId;         // Instance Id of this event
    ULONG                   ParentInstanceId;   // Parent Instance Id.
    GUID                    ParentGuid;         // Parent Guid;
    PVOID                   MofData;            // Pointer to Variable Data
    ULONG                   MofLength;          // Variable Datablock Length
    union {
        ULONG               ClientContext;
        ETW_BUFFER_CONTEXT  BufferContext;
    };
} EVENT_TRACE, *PEVENT_TRACE;
#if _MSC_VER >= 1200
#pragma warning(pop)
#endif

#if !defined(_WMIKM_) && !defined(_NTDDK_) && !defined(_NTIFS_)


typedef struct _EVENT_RECORD
                EVENT_RECORD, *PEVENT_RECORD;

typedef struct _EVENT_TRACE_LOGFILEW
                EVENT_TRACE_LOGFILEW, *PEVENT_TRACE_LOGFILEW;

typedef struct _EVENT_TRACE_LOGFILEA
                EVENT_TRACE_LOGFILEA, *PEVENT_TRACE_LOGFILEA;

typedef ULONG (WINAPI * PEVENT_TRACE_BUFFER_CALLBACKW)
                (PEVENT_TRACE_LOGFILEW Logfile);

typedef ULONG (WINAPI * PEVENT_TRACE_BUFFER_CALLBACKA)
                (PEVENT_TRACE_LOGFILEA Logfile);

typedef VOID (WINAPI *PEVENT_CALLBACK)( PEVENT_TRACE pEvent );

typedef VOID (WINAPI *PEVENT_RECORD_CALLBACK) (PEVENT_RECORD EventRecord);

//
// Prototype for service request callback. Data providers register with WMI
// by passing a service request callback function that is called for all
// wmi requests.

typedef ULONG (
#ifndef MIDL_PASS
WINAPI
#endif
*WMIDPREQUEST)(
    IN WMIDPREQUESTCODE RequestCode,
    IN PVOID RequestContext,
    IN OUT ULONG *BufferSize,
    IN OUT PVOID Buffer
    );

#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning (disable:4201)

struct _EVENT_TRACE_LOGFILEW {
    LPWSTR                  LogFileName;      // Logfile Name
    LPWSTR                  LoggerName;       // LoggerName
    LONGLONG                CurrentTime;      // timestamp of last event
    ULONG                   BuffersRead;      // buffers read to date
    union {
        // Mode of the logfile
        ULONG               LogFileMode;
        // Processing flags used on Vista and above
        ULONG               ProcessTraceMode; 
    };
    EVENT_TRACE             CurrentEvent;     // Current Event from this stream.
    TRACE_LOGFILE_HEADER    LogfileHeader;    // logfile header structure
    PEVENT_TRACE_BUFFER_CALLBACKW             // callback before each buffer
                            BufferCallback;   // is read
    //
    // following variables are filled for BufferCallback.
    //
    ULONG                   BufferSize;
    ULONG                   Filled;
    ULONG                   EventsLost;
    //
    // following needs to be propaged to each buffer
    //
    union {
        // Callback with EVENT_TRACE
        PEVENT_CALLBACK         EventCallback;
        // Callback with EVENT_RECORD on Vista and above
        PEVENT_RECORD_CALLBACK  EventRecordCallback;
    };

    ULONG                   IsKernelTrace;    // TRUE for kernel logfile

    PVOID                   Context;          // reserved for internal use
};

struct _EVENT_TRACE_LOGFILEA {
    LPSTR                   LogFileName;      // Logfile Name
    LPSTR                   LoggerName;       // LoggerName
    LONGLONG                CurrentTime;      // timestamp of last event
    ULONG                   BuffersRead;      // buffers read to date
    union {
        ULONG               LogFileMode;      // Mode of the logfile
        ULONG               ProcessTraceMode; // Processing flags
    };
    EVENT_TRACE             CurrentEvent;     // Current Event from this stream
    TRACE_LOGFILE_HEADER    LogfileHeader;    // logfile header structure
    PEVENT_TRACE_BUFFER_CALLBACKA             // callback before each buffer
                            BufferCallback;   // is read

    //
    // following variables are filled for BufferCallback.
    //
    ULONG                   BufferSize;
    ULONG                   Filled;
    ULONG                   EventsLost;
    //
    // following needs to be propaged to each buffer
    //
    union {
        PEVENT_CALLBACK         EventCallback;  // callback for every event
        PEVENT_RECORD_CALLBACK  EventRecordCallback;
    };


    ULONG                   IsKernelTrace;  // TRUE for kernel logfile

    PVOID                   Context;        // reserved for internal use
};
#if _MSC_VER >= 1200
#pragma warning(pop)
#endif


//
// Define generic structures
//

#if defined(_UNICODE) || defined(UNICODE)

#define PEVENT_TRACE_BUFFER_CALLBACK    PEVENT_TRACE_BUFFER_CALLBACKW
#define EVENT_TRACE_LOGFILE             EVENT_TRACE_LOGFILEW
#define PEVENT_TRACE_LOGFILE            PEVENT_TRACE_LOGFILEW
#define KERNEL_LOGGER_NAME              KERNEL_LOGGER_NAMEW
#define GLOBAL_LOGGER_NAME              GLOBAL_LOGGER_NAMEW
#define EVENT_LOGGER_NAME               EVENT_LOGGER_NAMEW

#else

#define PEVENT_TRACE_BUFFER_CALLBACK    PEVENT_TRACE_BUFFER_CALLBACKA
#define EVENT_TRACE_LOGFILE             EVENT_TRACE_LOGFILEA
#define PEVENT_TRACE_LOGFILE            PEVENT_TRACE_LOGFILEA
#define KERNEL_LOGGER_NAME              KERNEL_LOGGER_NAMEA
#define GLOBAL_LOGGER_NAME              GLOBAL_LOGGER_NAMEA
#define EVENT_LOGGER_NAME               EVENT_LOGGER_NAMEA

#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// Logger control APIs
//

//
// Use the routine below to start an event trace session
//

// ULONG
// StartTrace(
//      OUT PTRACEHANDLE TraceHandle,
//      IN LPTSTR InstanceName,
//      IN OUT PEVENT_TRACE_PROPERTIES Properties
//      );


EXTERN_C
ULONG
WMIAPI
StartTraceW(
    __out PTRACEHANDLE TraceHandle,
    __in LPCWSTR InstanceName,
    __inout PEVENT_TRACE_PROPERTIES Properties
    );

EXTERN_C
ULONG
WMIAPI
StartTraceA(
    __out PTRACEHANDLE TraceHandle,
    __in LPCSTR InstanceName,
    __inout PEVENT_TRACE_PROPERTIES Properties
    );

//
// Use the routine below to stop an event trace session
//

#if !defined(UNDER_CE)

//
// ULONG
// StopTrace(
//      IN TRACEHANDLE TraceHandle,
//      IN LPTSTR InstanceName,
//      IN OUT PEVENT_TRACE_PROPERTIES Properties
//      );

EXTERN_C
ULONG
WMIAPI
StopTraceW(
    __in TRACEHANDLE TraceHandle,
    __in_opt LPCWSTR InstanceName,
    __inout PEVENT_TRACE_PROPERTIES Properties
    );

EXTERN_C
ULONG
WMIAPI
StopTraceA(
    __in TRACEHANDLE TraceHandle,
    __in_opt LPCSTR InstanceName,
    __inout PEVENT_TRACE_PROPERTIES Properties
    );

#endif // !defined(UNDER_CE)

//
// Use the routine below to query the properties of an event trace session
//

#if !defined(UNDER_CE)

// ULONG
// QueryTrace(
//      IN TRACEHANDLE TraceHandle,
//      IN LPTSTR InstanceName,
//      IN OUT PEVENT_TRACE_PROPERTIES Properties
//      );

EXTERN_C
ULONG
WMIAPI
QueryTraceW(
    __in TRACEHANDLE TraceHandle,
    __in_opt LPCWSTR InstanceName,
    __inout PEVENT_TRACE_PROPERTIES Properties
    );

EXTERN_C
ULONG
WMIAPI
QueryTraceA(
    __in TRACEHANDLE TraceHandle,
    __in_opt LPCSTR InstanceName,
    __inout PEVENT_TRACE_PROPERTIES Properties
    );

#endif // !defined(UNDER_CE)

//
// Use the routine below to update certain properties of an event trace session
//

// ULONG
// UpdateTrace(
//      IN (PTRACEHANDLE TraceHandle,
//      IN LPTSTR InstanceName,
//      IN OUT PEVENT_TRACE_PROPERTIES Properties
//      );

#if !defined(UNDER_CE)

EXTERN_C
ULONG
WMIAPI
UpdateTraceW(
    __in TRACEHANDLE TraceHandle,
    __in_opt LPCWSTR InstanceName,
    __inout PEVENT_TRACE_PROPERTIES Properties
    );

EXTERN_C
ULONG
WMIAPI
UpdateTraceA(
    __in TRACEHANDLE TraceHandle,
    __in_opt LPCSTR InstanceName,
    __inout PEVENT_TRACE_PROPERTIES Properties
    );

#endif // !defined(UNDER_CE)

//
// Use the routine below to request that all active buffers an event trace
// session be "flushed", or written out.
//

// ULONG
// FlushTrace(
//      IN TRACEHANDLE TraceHandle,
//      IN LPTSTR InstanceName,
//      IN OUT PEVENT_TRACE_PROPERTIES Properties
//      );

#if (WINVER >= _WIN32_WINNT_WINXP) && !defined(UNDER_CE)
EXTERN_C
ULONG
WMIAPI
FlushTraceW(
    __in TRACEHANDLE TraceHandle,
    __in_opt LPCWSTR InstanceName,
    __inout PEVENT_TRACE_PROPERTIES Properties
    );
#endif

#if (WINVER >= _WIN32_WINNT_WINXP) && !defined(UNDER_CE)
EXTERN_C
ULONG
WMIAPI
FlushTraceA(
    __in TRACEHANDLE TraceHandle,
    __in_opt LPCSTR InstanceName,
    __inout PEVENT_TRACE_PROPERTIES Properties
    );
#endif

//
// Generic trace control routine
//
EXTERN_C
ULONG
WMIAPI
ControlTraceW(
    __in TRACEHANDLE TraceHandle,
    __in_opt LPCWSTR InstanceName,
    __inout PEVENT_TRACE_PROPERTIES Properties,
    __in ULONG ControlCode
    );

EXTERN_C
ULONG
WMIAPI
ControlTraceA(
    __in TRACEHANDLE TraceHandle,
    __in_opt LPCSTR InstanceName,
    __inout PEVENT_TRACE_PROPERTIES Properties,
    __in ULONG ControlCode
    );

#if !defined(UNDER_CE)
//
// ULONG
// QueryAllTraces(
//  OUT PEVENT_TRACE_PROPERTIES *PropertyArray,
//  IN ULONG PropertyArrayCount,
//  OUT PULONG LoggerCount
//  );
//

EXTERN_C
ULONG
WMIAPI
QueryAllTracesW(
    __out_ecount(PropertyArrayCount) PEVENT_TRACE_PROPERTIES *PropertyArray,
    __in  ULONG PropertyArrayCount,
    __out PULONG LoggerCount
    );

EXTERN_C
ULONG
WMIAPI
QueryAllTracesA(
    __out_ecount(PropertyArrayCount) PEVENT_TRACE_PROPERTIES *PropertyArray,
    __in  ULONG PropertyArrayCount,
    __out PULONG LoggerCount
    );
#endif // !defined(UNDER_CE)

//
// Data Provider Enable APIs
//

#if !defined(UNDER_CE)
EXTERN_C
ULONG
WMIAPI
EnableTrace(
    __in ULONG Enable,
    __in ULONG EnableFlag,
    __in ULONG EnableLevel,
    __in LPCGUID ControlGuid,
    __in TRACEHANDLE TraceHandle
    );
#endif // !defined(UNDER_CE)


typedef struct _EVENT_FILTER_DESCRIPTOR
               EVENT_FILTER_DESCRIPTOR, *PEVENT_FILTER_DESCRIPTOR;

#if (WINVER >= _WIN32_WINNT_LONGHORN) || defined(UNDER_CE)
EXTERN_C
ULONG
WMIAPI
EnableTraceEx(
    __in LPCGUID ProviderId,
    __in_opt LPCGUID SourceId,
    __in TRACEHANDLE TraceHandle,
    __in ULONG IsEnabled,
    __in UCHAR Level,
    __in ULONGLONG MatchAnyKeyword,
    __in ULONGLONG MatchAllKeyword,
    __in ULONG EnableProperty,
    __in_opt PEVENT_FILTER_DESCRIPTOR EnableFilterDesc
    );
#endif 


typedef enum _TRACE_QUERY_INFO_CLASS {
    TraceGuidQueryList,
    TraceGuidQueryInfo,
    TraceGuidQueryProcess
} TRACE_QUERY_INFO_CLASS;

#if (WINVER >= _WIN32_WINNT_LONGHORN) || defined(UNDER_CE)
EXTERN_C
ULONG
WMIAPI
EnumerateTraceGuidsEx(
    __in TRACE_QUERY_INFO_CLASS TraceQueryInfoClass,
    __in_bcount_opt(InBufferSize) PVOID InBuffer,
    __in ULONG InBufferSize,
    __out_bcount_opt(OutBufferSize) PVOID OutBuffer,
    __in ULONG OutBufferSize,
    __out PULONG ReturnLength
    );
#endif

//
// Data Provider APIs
//

#if !defined(UNDER_CE)
EXTERN_C
ULONG
WMIAPI
CreateTraceInstanceId(
    __in HANDLE RegHandle,
    __inout PEVENT_INSTANCE_INFO pInstInfo
    );
#endif // !defined(UNDER_CE)

//
// Use the routine below to generate and record an event trace
//

#if !defined(UNDER_CE)
EXTERN_C
ULONG
WMIAPI
TraceEvent(
    __in TRACEHANDLE  TraceHandle,
    __inout PEVENT_TRACE_HEADER EventTrace
    );

EXTERN_C
ULONG
WMIAPI
TraceEventInstance(
    __in TRACEHANDLE TraceHandle,
    __in PEVENT_INSTANCE_HEADER EventTrace,
    __in PEVENT_INSTANCE_INFO pInstInfo,
    __in_opt PEVENT_INSTANCE_INFO pParentInstInfo
    );
#endif // !defined(UNDER_CE)

//
// Use the routine below to register a guid for tracing
//

//
// ULONG
// RegisterTraceGuids(
//  IN WMIDPREQUEST  RequestAddress,
//  IN PVOID         RequestContext,
//  IN LPCGUID       ControlGuid,
//  IN ULONG         GuidCount,
//  IN PTRACE_GUID_REGISTRATION TraceGuidReg,
//  IN LPCTSTR       MofImagePath,
//  IN LPCTSTR       MofResourceName,
//  OUT PTRACEHANDLE RegistrationHandle
//  );
//

EXTERN_C
ULONG
WMIAPI
RegisterTraceGuidsW(
    __in WMIDPREQUEST  RequestAddress,
    __in_opt PVOID     RequestContext,
    __in LPCGUID       ControlGuid,
    __in ULONG         GuidCount,
    __in_ecount_opt(GuidCount) PTRACE_GUID_REGISTRATION TraceGuidReg,
    __in_opt LPCWSTR   MofImagePath,
    __in_opt LPCWSTR   MofResourceName,
    __out PTRACEHANDLE RegistrationHandle
    );

EXTERN_C
ULONG
WMIAPI
RegisterTraceGuidsA(
    __in WMIDPREQUEST  RequestAddress,
    __in_opt PVOID     RequestContext,
    __in LPCGUID       ControlGuid,
    __in ULONG         GuidCount,
    __in_ecount_opt(GuidCount) PTRACE_GUID_REGISTRATION TraceGuidReg,
    __in_opt LPCSTR        MofImagePath,
    __in_opt LPCSTR        MofResourceName,
    __out PTRACEHANDLE RegistrationHandle
    );


#if (WINVER >= _WIN32_WINNT_WINXP) && !defined(UNDER_CE)
EXTERN_C
ULONG
WMIAPI
EnumerateTraceGuids(
    __inout_ecount(PropertyArrayCount) PTRACE_GUID_PROPERTIES *GuidPropertiesArray,
    __in ULONG PropertyArrayCount,
    __out PULONG GuidCount
    );
#endif 

EXTERN_C
ULONG
WMIAPI
UnregisterTraceGuids(
    __in TRACEHANDLE RegistrationHandle
    );

EXTERN_C
TRACEHANDLE
WMIAPI
GetTraceLoggerHandle(
    __in PVOID Buffer
    );

EXTERN_C
UCHAR
WMIAPI
GetTraceEnableLevel(
    __in TRACEHANDLE TraceHandle
    );

EXTERN_C
ULONG
WMIAPI
GetTraceEnableFlags(
    __in TRACEHANDLE TraceHandle
    );

typedef enum _EVT_SUBSCRIBE_FLAGS
{
    EvtSubscribeToFutureEvents      = 1,
    EvtSubscribeStartAtOldestRecord = 2,
    EvtSubscribeStartAfterBookmark  = 3,
    EvtSubscribeOriginMask          = 3,

    EvtSubscribeTolerateQueryErrors = 0x1000,

    EvtSubscribeStrict              = 0x10000,

} EVT_SUBSCRIBE_FLAGS;


//
// Data Consumer APIs and structures start here
//

#if !defined(UNDER_CE)
//
// TRACEHANDLE
// OpenTrace(
//  IN OUT PEVENT_TRACE_LOGFILE Logfile
//  );
//

EXTERN_C
TRACEHANDLE
WMIAPI
OpenTraceA(
    __inout PEVENT_TRACE_LOGFILEA Logfile
    );

EXTERN_C
TRACEHANDLE
WMIAPI
OpenTraceW(
    __inout PEVENT_TRACE_LOGFILEW Logfile
    );

EXTERN_C
ULONG
WMIAPI
ProcessTrace(
    __in_ecount(HandleCount) PTRACEHANDLE HandleArray,
    __in ULONG HandleCount,
    __in_opt LPFILETIME StartTime,
    __in_opt LPFILETIME EndTime
    );

EXTERN_C
ULONG
WMIAPI
CloseTrace(
    __in TRACEHANDLE TraceHandle
    );

EXTERN_C
ULONG
WMIAPI
SetTraceCallback(
    __in LPCGUID pGuid,
    __in PEVENT_CALLBACK EventCallback
    );

EXTERN_C
ULONG
WMIAPI
RemoveTraceCallback (
    __in LPCGUID pGuid
    );
#endif // !defined(UNDER_CE)

//
// The routines for tracing Messages follow
//
EXTERN_C
ULONG
__cdecl
TraceMessage(
    __in TRACEHANDLE  LoggerHandle,
    __in ULONG        MessageFlags,
    __in LPGUID       MessageGuid,
    __in USHORT       MessageNumber,
    ...
);

EXTERN_C
ULONG
TraceMessageVa(
    __in TRACEHANDLE  LoggerHandle,
    __in ULONG        MessageFlags,
    __in LPGUID       MessageGuid,
    __in USHORT       MessageNumber,
    __in va_list      MessageArgList
);

#if defined(UNDER_CE)
EXTERN_C
HANDLE
CeEventSubscribeChannel(
        __in_z LPCWSTR ChannelPath,
        __in DWORD SubscribeFlags,
        __in HANDLE hEventMessageQueue,
        __in DWORD Level,
        __in ULONGLONG MatchAnyKeywordMask,
        __in ULONGLONG MatchAllKeywordMask
        );

EXTERN_C
HANDLE
CeEventSubscribeProvider(
        __in LPCGUID ProviderId,
        __in DWORD SubscribeFlags,
        __in HANDLE hEventMessageQueue,
        __in DWORD Level,
        __in ULONGLONG MatchAnyKeywordMask,
        __in ULONGLONG MatchAllKeywordMask
        );
#endif // defined(UNDER_CE)

#ifdef __cplusplus
}       // extern "C"
#endif

//
//
// Define the encoding independent routines
//

#if defined(UNICODE) || defined(_UNICODE)
#define RegisterTraceGuids      RegisterTraceGuidsW
#define StartTrace              StartTraceW
#define ControlTrace            ControlTraceW
#if defined(__TRACE_W2K_COMPATIBLE)
#define StopTrace(a,b,c)        ControlTraceW((a),(b),(c), \
                                        EVENT_TRACE_CONTROL_STOP)
#define QueryTrace(a,b,c)       ControlTraceW((a),(b),(c), \
                                        EVENT_TRACE_CONTROL_QUERY)
#define UpdateTrace(a,b,c)      ControlTraceW((a),(b),(c), \
                                        EVENT_TRACE_CONTROL_UPDATE)
#else
#define StopTrace               StopTraceW
#define QueryTrace              QueryTraceW
#define UpdateTrace             UpdateTraceW
#endif
#if (NTDDI_VERSION >= NTDDI_WINXP)
#define FlushTrace              FlushTraceW
#endif // NTDDI_VERSION >= NTDDI_WINXP
#define QueryAllTraces          QueryAllTracesW
#define OpenTrace               OpenTraceW
#else
#define RegisterTraceGuids      RegisterTraceGuidsA
#define StartTrace              StartTraceA
#define ControlTrace            ControlTraceA
#if defined(__TRACE_W2K_COMPATIBLE)
#define StopTrace(a,b,c)        ControlTraceA((a),(b),(c), \
                                        EVENT_TRACE_CONTROL_STOP)
#define QueryTrace(a,b,c)       ControlTraceA((a),(b),(c), \
                                        EVENT_TRACE_CONTROL_QUERY)
#define UpdateTrace(a,b,c)      ControlTraceA((a),(b),(c), \
                                        EVENT_TRACE_CONTROL_UPDATE)
#else
#define StopTrace               StopTraceA
#define QueryTrace              QueryTraceA
#define UpdateTrace             UpdateTraceA
#endif
#if (NTDDI_VERSION >= NTDDI_WINXP)
#define FlushTrace              FlushTraceA
#endif // NTDDI_VERSION >= NTDDI_WINXP
#define QueryAllTraces          QueryAllTracesA
#define OpenTrace               OpenTraceA
#endif  // UNICODE

#endif /* _WMIKM_  && _NTDDK_ */

#endif // WINNT
#endif /* _EVNTRACE_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\evntprov.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//

/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    evntprov.h

Abstract:

    This defines the unified provider side user mode API.

Revision History:

@@BEGIN_DDKSPLIT 
    Insung Park (insungp) 26-Aug-2004 
        Created the file.
@@END_DDKSPLIT 
--*/

#ifndef _EVNTPROV_H_
#define _EVNTPROV_H_

#pragma once

#if defined(UNDER_CE)
#define EVNTAPI WINAPI
#else
#ifndef EVNTAPI
#ifndef MIDL_PASS
#ifdef _EVNT_SOURCE_
#define EVNTAPI __stdcall
#else
#define EVNTAPI DECLSPEC_IMPORT __stdcall
#endif // _EVNT_SOURCE_
#endif // MIDL_PASS
#endif // EVNTAPI
#endif // !UNDER_CE

#ifdef __cplusplus
extern "C" {
#endif

#if defined(UNDER_CE)
typedef const GUID* LPCGUID;
#endif

#define EVENT_MIN_LEVEL                      (0)
#define EVENT_MAX_LEVEL                      (0xff)

#define EVENT_ACTIVITY_CTRL_GET_ID           (1)
#define EVENT_ACTIVITY_CTRL_SET_ID           (2)
#define EVENT_ACTIVITY_CTRL_CREATE_ID        (3)
#define EVENT_ACTIVITY_CTRL_GET_SET_ID       (4)
#define EVENT_ACTIVITY_CTRL_CREATE_SET_ID    (5)

typedef ULONGLONG REGHANDLE, *PREGHANDLE;

#define MAX_EVENT_DATA_DESCRIPTORS           (128)
#define MAX_EVENT_FILTER_DATA_SIZE           (1024)

//
// EVENT_DATA_DESCRIPTOR is used to pass in user data items
// in events.
// 
typedef struct _EVENT_DATA_DESCRIPTOR {

    ULONGLONG   Ptr;        // Pointer to data
    ULONG       Size;       // Size of data in bytes
    ULONG       Reserved;

} EVENT_DATA_DESCRIPTOR, *PEVENT_DATA_DESCRIPTOR;

//
// EVENT_DESCRIPTOR describes and categorizes an event.
// 
typedef struct _EVENT_DESCRIPTOR {

    USHORT      Id;
    UCHAR       Version;
    UCHAR       Channel;
    UCHAR       Level;
    UCHAR       Opcode;
    USHORT      Task;
    ULONGLONG   Keyword;

} EVENT_DESCRIPTOR, *PEVENT_DESCRIPTOR;

typedef const EVENT_DESCRIPTOR *PCEVENT_DESCRIPTOR;

//
// EVENT_FILTER_DESCRIPTOR is used to pass in enable filter
// data item to a user callback function.
// 
typedef struct _EVENT_FILTER_DESCRIPTOR {

    ULONGLONG   Ptr;
    ULONG       Size;
    ULONG       Type;

} EVENT_FILTER_DESCRIPTOR, *PEVENT_FILTER_DESCRIPTOR;

#ifndef _ETW_KM_ 

//
// Optional callback function that users provide
//
typedef 
VOID
(NTAPI *PENABLECALLBACK) (
    __in LPCGUID SourceId,
    __in ULONG IsEnabled,
    __in UCHAR Level,
    __in ULONGLONG MatchAnyKeyword,
    __in ULONGLONG MatchAllKeyword,
    __in_opt PEVENT_FILTER_DESCRIPTOR FilterData,
    __in_opt PVOID CallbackContext
    );  

//
// Registration APIs
//

#if (WINVER >= _WIN32_WINNT_LONGHORN)
ULONG
EVNTAPI
EventRegister(
    __in LPCGUID ProviderId,
    __in_opt PENABLECALLBACK EnableCallback,
    __in_opt PVOID CallbackContext,
    __out PREGHANDLE RegHandle
    );
#endif

#if (WINVER >= _WIN32_WINNT_LONGHORN)
ULONG
EVNTAPI
EventUnregister(
    __in REGHANDLE RegHandle
    );
#endif

//
// Control (Is Enabled) APIs
//

#if (WINVER >= _WIN32_WINNT_LONGHORN) || defined(UNDER_CE)
BOOLEAN
EVNTAPI
EventEnabled(
    __in REGHANDLE RegHandle,
    __in PCEVENT_DESCRIPTOR EventDescriptor
    );
#endif

#if (WINVER >= _WIN32_WINNT_LONGHORN) || defined(UNDER_CE)
BOOLEAN
EVNTAPI
EventProviderEnabled(
    __in REGHANDLE RegHandle,
    __in UCHAR Level,
    __in ULONGLONG Keyword
    );
#endif

//
// Writing (Publishing/Logging) APIs
//

#if (WINVER >= _WIN32_WINNT_LONGHORN) || defined(UNDER_CE)
ULONG
EVNTAPI
EventWrite(
    __in REGHANDLE RegHandle,
    __in PCEVENT_DESCRIPTOR EventDescriptor,
    __in ULONG UserDataCount,
    __in_ecount_opt(UserDataCount) PEVENT_DATA_DESCRIPTOR UserData
    );
#endif

#if (WINVER >= _WIN32_WINNT_LONGHORN) && !defined(UNDER_CE)
ULONG
EVNTAPI
EventWriteTransfer(
    __in REGHANDLE RegHandle,
    __in PCEVENT_DESCRIPTOR EventDescriptor,
    __in_opt LPCGUID ActivityId,
    __in LPCGUID RelatedActivityId,
    __in ULONG UserDataCount,
    __in_ecount_opt(UserDataCount) PEVENT_DATA_DESCRIPTOR UserData
    );
#endif

#if (WINVER >= _WIN32_WINNT_LONGHORN) && !defined(UNDER_CE)
ULONG
EVNTAPI
EventWriteString(
    __in REGHANDLE RegHandle,
    __in UCHAR Level,
    __in ULONGLONG Keyword,
    __in PCWSTR String
    );
#endif

//
// ActivityId Control APIs
//

#if (WINVER >= _WIN32_WINNT_LONGHORN) && !defined(UNDER_CE)
ULONG
EVNTAPI
EventActivityIdControl(
    __in    ULONG ControlCode,
    __inout LPGUID ActivityId
    );
#endif

#endif // _ETW_KM_ 


//
// Macros to create Event and Event Data Descriptors
//

FORCEINLINE
VOID
EventDataDescCreate(
    __out PEVENT_DATA_DESCRIPTOR EventDataDescriptor,
    __in  const VOID* DataPtr,
    __in  ULONG DataSize
    )
{
    EventDataDescriptor->Ptr = (ULONGLONG) DataPtr;
    EventDataDescriptor->Size = DataSize;
    EventDataDescriptor->Reserved = 0;
}

FORCEINLINE
VOID
EventDescCreate(
    __out PEVENT_DESCRIPTOR         EventDescriptor,
    __in  USHORT                    Id,
    __in  UCHAR                     Version,
    __in  UCHAR                     Channel,
    __in  UCHAR                     Level,
    __in  USHORT                    Task,
    __in  UCHAR                     Opcode,
    __in  ULONGLONG                 Keyword
    )
{
    EventDescriptor->Id         = Id;
    EventDescriptor->Version    = Version;
    EventDescriptor->Channel    = Channel;
    EventDescriptor->Level      = Level;
    EventDescriptor->Task       = Task;
    EventDescriptor->Opcode     = Opcode;
    EventDescriptor->Keyword    = Keyword;
}

FORCEINLINE
VOID
EventDescZero(
    __out PEVENT_DESCRIPTOR         EventDescriptor
    )
{
    memset(EventDescriptor, 0, sizeof(EVENT_DESCRIPTOR));
}

//
// Macros to extract info from an Event Descriptor
//

FORCEINLINE
USHORT
EventDescGetId(
    __in PCEVENT_DESCRIPTOR EventDescriptor
    )
{
    return (EventDescriptor->Id);
}

FORCEINLINE
UCHAR
EventDescGetVersion(
    __in PCEVENT_DESCRIPTOR EventDescriptor
    )
{
    return (EventDescriptor->Version);
}

FORCEINLINE
USHORT
EventDescGetTask(
    __in PCEVENT_DESCRIPTOR EventDescriptor
    )
{
    return (EventDescriptor->Task);
}

FORCEINLINE
UCHAR
EventDescGetOpcode(
    __in PCEVENT_DESCRIPTOR EventDescriptor
    )
{
    return (EventDescriptor->Opcode);
}

FORCEINLINE
UCHAR
EventDescGetChannel(
    __in PCEVENT_DESCRIPTOR EventDescriptor
    )
{
    return (EventDescriptor->Channel);
}

FORCEINLINE
UCHAR
EventDescGetLevel(
    __in PCEVENT_DESCRIPTOR EventDescriptor
    )
{
    return (EventDescriptor->Level);
}

FORCEINLINE
ULONGLONG
EventDescGetKeyword(
    __in PCEVENT_DESCRIPTOR EventDescriptor
    )
{
    return (EventDescriptor->Keyword);
}

//
// Macros to set info into an Event Descriptor
//

FORCEINLINE
PEVENT_DESCRIPTOR
EventDescSetId(
    __in PEVENT_DESCRIPTOR          EventDescriptor,
    __in USHORT                     Id
    )
{
    EventDescriptor->Id         = Id;
    return (EventDescriptor);
}

FORCEINLINE
PEVENT_DESCRIPTOR
EventDescSetVersion(
    __in PEVENT_DESCRIPTOR          EventDescriptor,
    __in UCHAR                      Version
    )
{
    EventDescriptor->Version    = Version;
    return (EventDescriptor);
}

FORCEINLINE
PEVENT_DESCRIPTOR
EventDescSetTask(
    __in PEVENT_DESCRIPTOR          EventDescriptor,
    __in USHORT                     Task
    )
{
    EventDescriptor->Task       = Task;
    return (EventDescriptor);
}

FORCEINLINE
PEVENT_DESCRIPTOR
EventDescSetOpcode(
    __in PEVENT_DESCRIPTOR          EventDescriptor,
    __in UCHAR                      Opcode
    )
{
    EventDescriptor->Opcode     = Opcode;
    return (EventDescriptor);
}

FORCEINLINE
PEVENT_DESCRIPTOR
EventDescSetLevel(
    __in PEVENT_DESCRIPTOR          EventDescriptor,
    __in UCHAR                      Level
    )
{
    EventDescriptor->Level      = Level;
    return (EventDescriptor);
}

FORCEINLINE
PEVENT_DESCRIPTOR
EventDescSetChannel(
    __in PEVENT_DESCRIPTOR          EventDescriptor,
    __in UCHAR                      Channel
    )
{
    EventDescriptor->Channel    = Channel;
    return (EventDescriptor);
}

FORCEINLINE
PEVENT_DESCRIPTOR
EventDescSetKeyword(
    __in PEVENT_DESCRIPTOR          EventDescriptor,
    __in ULONGLONG                  Keyword
    )
{
    EventDescriptor->Keyword    = Keyword;
    return (EventDescriptor);
}


FORCEINLINE
PEVENT_DESCRIPTOR
EventDescOrKeyword(
    __in PEVENT_DESCRIPTOR          EventDescriptor,
    __in ULONGLONG                  Keyword
    )
{
    EventDescriptor->Keyword    |= Keyword;
    return (EventDescriptor);
}


#ifdef __cplusplus
}
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\evcode.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this source code is subject to the terms of the Microsoft end-user
// license agreement (EULA) under which you licensed this SOFTWARE PRODUCT.
// If you did not accept the terms of the EULA, you are not authorized to use
// this source code. For a copy of the EULA, please see the LICENSE.RTF on your
// install media.
//
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//
//--------------------------------------------------------------------------;

//
// list of standard Quartz event codes and the expected params
//

// Event codes are broken into two groups
//   -- system event codes
//   -- extension event codes
// All system event codes are below EC_USER

#define EC_SYSTEMBASE                       0x00
#define EC_USER                             0x8000


// System-defined event codes
// ==========================
//
// There are three types of system-defined event codes:
//
// 1.  Those which are always passed through to the application
//     (To be collected by calls to GetEvent or within WaitForCompletion.)
//     (e.g. EC_ERRORABORT, EC_USERABORT.)
//
// 2.  Those which are pure internal and will never be passed to
//     the application.  (e.g. EC_SHUTDOWN)
//
// 3.  Those which have default handling.  Default handing implies that
//     the event is not passed to the application.  However, default
//     handling may be canceled by calling
//     IMediaEvent::CancelDefaultHandling.  If the default handling is
//     cancelled in this way, then the message will be delivered to the
//     application and the application must action it appropriately.
//     Default handling can be restored by calling RestoreDefaultHandling.
//
// We will refer to these events as application, internal and defaulted
// events respectively.
//
// System-defined events may have interface pointers, BSTR's, etc passed
// as parameters.  It is therefore essential that, for any message
// retrieved using GetEvent, a matching call to FreeEventParams is made
// to ensure that relevant interfaces are released and storage freed.
// Failure to call FreeEventParams will result in memory leaks, if not
// worse.
//
// Filters sending these messages to the filter graph should not AddRef()
// any interfaces that they may pass as parameters.  The filter graph
// manager will AddRef them if required.  E.g. if the event is to be queued
// for the application or queued to a worker thread.

// Each event listed below is immediately followed by a parameter list
// detailing the types of the parameters associated with the message,
// and an indication of whether the message is an application, internal
// or defaulted message.  This is then followed by a short description.
// The use of "void" in the parameter list implies that the parameter is not
// used.  Such parameters should be zero.



#define EC_COMPLETE                         0x01
// ( HRESULT, void ) : defaulted (special)
// Signals the completed playback of a stream within the graph.  This message
// is sent by renderers when they receive end-of-stream.  The default handling
// of this message results in a _SINGLE_ EC_COMPLETE being sent to the
// application when ALL of the individual renderers have signaled EC_COMPLETE
// to the filter graph.  If the default handing is canceled, the application
// will see all of the individual EC_COMPLETEs.


#define EC_USERABORT                        0x02
// ( void, void ) : application
// In some sense, the user has requested that playback be terminated.
// This message is typically sent by renderers that render into a
// window if the user closes the window into which it was rendering.
// It is up to the application to decide if playback should actually
// be stopped.


#define EC_ERRORABORT                       0x03
// ( HRESULT, void ) : application
// Operation aborted because of error


#define EC_TIME                             0x04
// ( DWORD, DWORD ) : application
// The requested reference time occurred.  (This event is currently not used).
// lParam1 is low dword of ref time, lParam2 is high dword of reftime.


#define EC_REPAINT                          0x05
// ( IPin * (could be NULL), void ) : defaulted
// A repaint is required - lParam1 contains the (IPin *) that needs the data
// to be sent again. Default handling is: if the output pin which the IPin is
// attached  to supports the IMediaEventSink interface then it will be called
// with the EC_REPAINT first.  If that fails then normal repaint processing is
// done by the filter graph.


// Stream error notifications
#define EC_STREAM_ERROR_STOPPED             0x06
#define EC_STREAM_ERROR_STILLPLAYING        0x07
// ( HRESULT, DWORD ) : application
// lParam 1 is major code, lParam2 is minor code, either may be zero.

// see also EC_STREAM_REROR_RECOVERED below

#define EC_ERROR_STILLPLAYING               0x08
// ( HRESULT, void ) : application
// The filter graph manager may issue Run's to the graph asynchronously.
// If such a Run fails, EC_ERROR_STILLPLAYING is issued to notify the
// application of the failure.  The state of the underlying filters
// at such a time will be indeterminate - they will all have been asked
// to run, but some are almost certainly not.


#define EC_PALETTE_CHANGED                  0x09
// ( void, void ) : application
// notify application that the video palette has changed


#define EC_VIDEO_SIZE_CHANGED               0x0A
// ( DWORD, void ) : application
// Sent by video renderers.
// Notifies the application that the native video size has changed.
// LOWORD of the DWORD is the new width, HIWORD is the new height.


#define EC_QUALITY_CHANGE                   0x0B
// ( void, void ) : application
// Notify application that playback degradation has occurred


#define EC_SHUTTING_DOWN                    0x0C
// ( void, void ) : internal
// This message is sent by the filter graph manager to any plug-in
// distributors which support IMediaEventSink to notify them that
// the filter graph is starting to shutdown.


#define EC_CLOCK_CHANGED                    0x0D
// ( void, void ) : application
// Notify application that the clock has changed.
// (i.e. SetSyncSource has been called on the filter graph and has been
// distributed successfully to the filters in the graph.)


#define EC_PAUSED                           0x0E
// ( HRESULT, void ) : application
// Notify application the previous pause request has completed


#define EC_OPENING_FILE                     0x10
#define EC_BUFFERING_DATA                   0x11
// ( BOOL, void ) : application
// lParam1 == 1   --> starting to open file or buffer data
// lParam1 == 0   --> not opening or buffering any more
// (This event does not appear to be used by ActiveMovie.)


#define EC_FULLSCREEN_LOST                  0x12
// ( void, IBaseFilter * ) : application
// Sent by full screen renderers when switched away from full screen.
// IBaseFilter may be NULL.


#define EC_ACTIVATE                         0x13
// ( BOOL, IBaseFilter * ) : internal
// Sent by video renderers when they lose or gain activation.
// lParam1 is set to 1 if gained or 0 if lost
// lParam2 is the IBaseFilter* for the filter that is sending the message
// Used for sound follows focus and full-screen switching


#define EC_NEED_RESTART                     0x14
// ( void, void ) : defaulted
// Sent by renderers when they regain a resource (e.g. audio renderer).
// Causes a restart by Pause/put_Current/Run (if running).


#define EC_WINDOW_DESTROYED                 0x15
// ( IBaseFilter *, void ) : internal
// Sent by video renderers when the window has been destroyed. Handled
// by the filter graph / distributor telling the resource manager.
// lParam1 is the IBaseFilter* of the filter whose window is being destroyed


#define EC_DISPLAY_CHANGED                  0x16
// ( IPin *, void ) : internal
// Sent by renderers when they detect a display change. the filter graph
// will arrange for the graph to be stopped and the pin send in lParam1
// to be reconnected. by being reconnected it allows a renderer to reset
// and connect with a more appropriate format for the new display mode
// lParam1 contains an (IPin *) that should be reconnected by the graph


#define EC_STARVATION                       0x17
// ( void, void ) : defaulted
// Sent by a filter when it detects starvation. Default handling (only when
// running) is for the graph to be paused until all filters enter the
// paused state and then run. Normally this would be sent by a parser or source
// filter when too little data is arriving.


#define EC_OLE_EVENT                0x18
// ( BSTR, BSTR ) : application
// Sent by a filter to pass a text string to the application.
// Conventionally, the first string is a type, and the second a parameter.


#define EC_NOTIFY_WINDOW                    0x19
// ( HWND, void ) : internal
// Pass the window handle around during pin connection.

#define EC_STREAM_CONTROL_STOPPED       0x1A
// ( IPin * pSender, DWORD dwCookie )
// Notification that an earlier call to IAMStreamControl::StopAt
// has now take effect.  Calls to the method can be marked
// with a cookie which is passed back in the second parameter,
// allowing applications to easily tie together request
// and completion notifications.
//
// NB: IPin will point to the pin that actioned the Stop.  This
// may not be the pin that the StopAt was sent to.

#define EC_STREAM_CONTROL_STARTED       0x1B
// ( IPin * pSender, DWORD dwCookie )
// Notification that an earlier call to IAMStreamControl::StartAt
// has now take effect.  Calls to the method can be marked
// with a cookie which is passed back in the second parameter,
// allowing applications to easily tie together request
// and completion notifications.
//
// NB: IPin will point to the pin that actioned the Start.  This
// may not be the pin that the StartAt was sent to.

#define EC_END_OF_SEGMENT                   0x1C
//
// ( const REFERENCE_TIME *pStreamTimeAtEndOfSegment, DWORD dwSegmentNumber )
//
// pStreamTimeAtEndOfSegment
//     pointer to the accumulated stream clock
//     time since the start of the segment - this is directly computable
//     as the sum of the previous and current segment durations (Stop - Start)
//     and the rate applied to each segment
//     The source add this time to the time within each segment to get
//     a total elapsed time
//
// dwSegmentNumber
//     Segment number - starts at 0
//
// Notifies that a segment end has been reached when the
// AM_SEEKING_Segment flags was set for IMediaSeeking::SetPositions
// Passes in an IMediaSeeking interface to allow the next segment
// to be defined by the application

#define EC_SEGMENT_STARTED                  0x1D
//
// ( const REFERENCE_TIME *pStreamTimeAtStartOfSegment, DWORD dwSegmentNumber)
//
// pStreamTimeAtStartOfSegment
//     pointer to the accumulated stream clock
//     time since the start of the segment - this is directly computable
//     as the sum of the previous segment durations (Stop - Start)
//     and the rate applied to each segment
//
// dwSegmentNumber
//     Segment number - starts at 0
//
// Notifies that a new segment has been started.
// This is sent synchronously by any entity that will issue
// EC_END_OF_SEGMENT when a new segment is started
// (See IMediaSeeking::SetPositions - AM_SEEKING_Segment flag)
// It is used to compute how many EC_END_OF_SEGMENT notifications
// to expect at the end of a segment and as a consitency check

#define EC_LENGTH_CHANGED                  0x1E
// (void, void)
// sent to indicate that the length of the "file" has changed

#define EC_STEP_COMPLETE                      0x24
// (BOOL bCancelled, void)
// Step request complete
// if bCancelled is TRUE the step was cancelled.  This can happen
// if the application issued some control request or because there
// was a mode change etc etc

// Event code 25 is reserved for future use.

#define EC_TIMECODE_AVAILABLE           0x30
// Sent by filter supporting timecode
// Param1 has a pointer to the sending object
// Param2 has the device ID of the sending object

#define EC_EXTDEVICE_MODE_CHANGE        0x31
// Sent by filter supporting IAMExtDevice
// Param1 has the new mode
// Param2 has the device ID of the sending object

#define EC_STATE_CHANGE                    0x32
// ( FILTER_STATE, BOOL bInternal)
// Used to notify the application of any state changes in the filter graph.
// lParam1  is of type enum FILTER_STATE (defined in strmif.h) and indicates
//          the state of the filter graph.
//
// lParam2 == 0 indicates that the previous state change request has completed
//              & a change in application state.
// lParam2 == 1 reserved for future use to indicate internal state changes.

#define EC_VMR_RENDERDEVICE_SET                 0x53
// (Render_Device type, void)
// Identifies the type of rendering mechanism the VMR
// is using to display video.  Types used include:
#define VMR_RENDER_DEVICE_OVERLAY       0x01
#define VMR_RENDER_DEVICE_VIDMEM        0x02
#define VMR_RENDER_DEVICE_SYSMEM        0x04


#define EC_VMR_SURFACE_FLIPPED          0x54
// (hr - Flip return code, void)
// Identifies the VMR's allocator-presenter has called the DDraw flip api on
// the surface being presented.   This allows the VMR to keep its DX-VA table
// of DDraw surfaces in sync with DDraws flipping chain.

#define EC_VMR_RECONNECTION_FAILED      0x55
// (hr - ReceiveConnection return code, void)
// Identifies that an upstream decoder tried to perform a dynamic format
// change and the VMR was unable to accept the new format.

#ifdef UNDER_CE

///////////////////////////////////////////////////////////////////////////////
// Windows Media Event-Codes
///////////////////////////////////////////////////////////////////////////////

#define EC_PLEASE_REOPEN            0x40
// (void, void) : application
// Something has changed enough that the graph should be re-rendered.

#define EC_STATUS                       0x41
// ( BSTR, BSTR) : application
// Two arbitrary strings, a short one and a long one.

#define EC_MARKER_HIT               0x42
// (int, void) : application
// The specified "marker #" has just been passed

#define EC_LOADSTATUS               0x43

// (int, void) : application
// Sent when various points during the loading of a network file are reached
#define AM_LOADSTATUS_CLOSED            0x0000
#define AM_LOADSTATUS_LOADINGDESCR      0x0001
#define AM_LOADSTATUS_LOADINGMCAST      0x0002
#define AM_LOADSTATUS_LOCATING      0x0003
#define AM_LOADSTATUS_CONNECTING    0x0004
#define AM_LOADSTATUS_OPENING       0x0005
#define AM_LOADSTATUS_OPEN      0x0006

#define EC_FILE_CLOSED              0x44
// (void, void) : application
// Sent when the file is involuntarily closed, i.e. by a network server shutdown

#define EC_ERRORABORTEX             0x45
// ( HRESULT, BSTR ) : application
// Operation aborted because of error.  Additional information available.

#define EC_EOS_SOON            0x046
// (void, void) : application
// sent when the source filter is about to deliver an EOS downstream....

#define EC_CONTENTPROPERTY_CHANGED   0x47
// (ULONG, void) 
// Sent when a streaming media filter receives a change in stream description information.
// the UI is expected to re-query for the changed property in response
#define AM_CONTENTPROPERTY_TITLE     0x0001
#define AM_CONTENTPROPERTY_AUTHOR    0x0002
#define AM_CONTENTPROPERTY_COPYRIGHT 0x0004
#define AM_CONTENTPROPERTY_DESCRIPTION 0x0008

#define EC_BANDWIDTHCHANGE          0x48
// (WORD, long) : application
// sent when the bandwidth of the streaming data has changed.  First parameter
// is the new level of bandwidth. Second is the MAX number of levels. Second
// parameter may be 0, if the max levels could not be determined.

#define EC_VIDEOFRAMEREADY          0x49
// (void, void) : application
// sent to notify the application that the first video frame is about to be drawn

#define EC_DRMSTATUS                0x4A
// (int, BSTR) : application
// Sent when various points during the DRM process are reached.  First param is
// the subcategory, second param is a descriptive string.
#define WMT_DRMSTATUS_GENERIC           0x0000
#define WMT_DRMSTATUS_BEGINLICENSE  0x0001
#define WMT_DRMSTATUS_ENDLICENSE    0x0002
#define WMT_DRMSTATUS_BEGININDIV    0x0003
#define WMT_DRMSTATUS_ENDINDIV      0x0004

///////////////////////////////////////////////////////////////////////////////
// Video CD Event-Codes
///////////////////////////////////////////////////////////////////////////////

// Sent by the Video CD source filter to indicate that a user selection is
// required (call Numeric(long)) to continue play. lParam1 is the number of
// selections available; lParam2 is the base of selection number
#define EC_VCD_SELECT                      0x50

// Sent by the Video CD source filter to indicate that a user command is
// required (call Next(), Prevous(), Default() or Return()) to continue play.
// Neither lParam1 or lParam2 is used
#define EC_VCD_PLAY                        0x51

// Sent by the Video CD source filter to indicate that end list has been
// reached and a new user command is required (call Next(), Prevous(),
// Default() or Return()) to continue play
// Neither lParam1 or lParam2 is used
#define EC_VCD_END                         0x52

////////////////////////////////////////
// Meirab - Adding events for previous and back asynchronous handling
///////////////////////////////////////
#define EC_PLAY_NEXT                        0x60
#define EC_PLAY_PREVIOUS                    0x61

// Events for DRM levels protection (Macrovision ..etc).
#define EC_DRM_LEVEL                        0x62

// Event for indicating that an error has happened, and we have recovered from the error
#define EC_STREAM_ERROR_RECOVERED           0x63

////////////////////////////////////////////////////////////////////////////////
// Capture Events
////////////////////////////////////////////////////////////////////////////////
#define EC_CAP_FILE_COMPLETED           0x101
#define EC_CAP_SAMPLE_PROCESSED         0x102
#define EC_BUFFER_FULL                  0x103
#define EC_CAP_FILE_WRITE_ERROR         0x104
#define EC_BUFFER_DOWNSTREAM_ERROR      0x105
#define EC_CAMERA_SAMPLE_SCANNED        0x106
#define EC_CAMERA_FOCUS_COMPLETE        0x107


#define EC_AUDIOFRAMEREADY              0x120
// (void, void) : application
// sent to notify the application that the first audio frame is about to be rendered

#endif // UNDER_CE
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\excpt.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/***
*excpt.h - defines exception values, types and routines
*
*
*Purpose:
*       This file contains the definitions and prototypes for the compiler-
*       dependent intrinsics, support functions and keywords which implement
*       the structured exception handling extensions.
*
****/

#pragma once

#ifndef _INC_EXCPT
#define _INC_EXCPT

#include <crtdefs.h>

#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,_CRT_PACKING)
#endif  /* _MSC_VER */

#ifdef __cplusplus
extern "C" {
#endif

/*
 * Exception disposition return values.
 */
typedef enum _EXCEPTION_DISPOSITION {
    ExceptionContinueExecution,
    ExceptionContinueSearch,
    ExceptionNestedException,
    ExceptionCollidedUnwind,
    ExceptionExecuteHandler
} EXCEPTION_DISPOSITION;


/*
 * Prototype for SEH support function.
 */

/*
 * Declare some standard structures
 */
typedef struct _EXCEPTION_POINTERS *Exception_info_ptr;
struct _EXCEPTION_RECORD;
struct _RUNTIME_FUNCTION;
struct _EXCEPTION_REGISTRATION_RECORD;

struct _CONTEXT;
struct _EXCEPTION_RECORD;
struct _EXCEPTION_POINTERS;
typedef struct _CONTEXT *PCONTEXT;
typedef struct _EXCEPTION_RECORD *PEXCEPTION_RECORD;
typedef struct _EXCEPTION_POINTERS *PEXCEPTION_POINTERS;
typedef struct _EXCEPTION_REGISTRATION_RECORD *PEXCEPTION_REGISTRATION_RECORD;
typedef PCONTEXT LPCONTEXT;
typedef PEXCEPTION_RECORD LPEXCEPTION_RECORD;
typedef PEXCEPTION_POINTERS LPEXCEPTION_POINTERS;

typedef struct _DISPATCHER_CONTEXT {
#ifdef _X86_
    struct _EXCEPTION_REGISTRATION_RECORD *RegistrationPointer;
    unsigned long ControlPc;
#else
    unsigned long ControlPc;
    struct _RUNTIME_FUNCTION *FunctionEntry;
    unsigned long EstablisherFrame;
    PCONTEXT ContextRecord;
#endif
} DISPATCHER_CONTEXT, *PDISPATCHER_CONTEXT;

typedef EXCEPTION_DISPOSITION EXCEPTION_ROUTINE (
    struct _EXCEPTION_RECORD *ExceptionRecord,
    void *EstablisherFrame,
    struct _CONTEXT *ContextRecord,
    struct _DISPATCHER_CONTEXT *DispatcherContext
    );
typedef EXCEPTION_ROUTINE *PEXCEPTION_ROUTINE;

#ifdef _X86_
EXCEPTION_ROUTINE _except_handler3;
#else
EXCEPTION_ROUTINE __C_specific_handler;
#endif

/*
 * Keywords and intrinsics for SEH
 */

#ifdef  _MSC_VER

#if     !defined(__cplusplus)
#define try                             __try
#define except                          __except
#define finally                         __finally
#define leave                           __leave
#endif

#define GetExceptionCode                _exception_code
#define exception_code                  _exception_code
#define GetExceptionInformation         (struct _EXCEPTION_POINTERS *)_exception_info
#define exception_info                  (struct _EXCEPTION_POINTERS *)_exception_info
#define AbnormalTermination             _abnormal_termination
#define abnormal_termination            _abnormal_termination

unsigned long __cdecl _exception_code(void);
void *        __cdecl _exception_info(void);
int           __cdecl _abnormal_termination(void);

#endif


/*
 * Legal values for expression in except().
 */

#define EXCEPTION_EXECUTE_HANDLER        1
#define EXCEPTION_CONTINUE_SEARCH        0
#define EXCEPTION_CONTINUE_EXECUTION    -1


/*
 * for convenience, define a type name for a pointer to signal-handler
 */

typedef void (__cdecl * _PHNDLR)(int);

/*
 * Exception-action table used by the C runtime to identify and dispose of
 * exceptions corresponding to C runtime errors or C signals.
 */
struct _XCPT_ACTION {

    /*
     * exception code or number. defined by the host OS.
     */
    unsigned long XcptNum;

    /*
     * signal code or number. defined by the C runtime.
     */
    int SigNum;

    /*
     * exception action code. either a special code or the address of
     * a handler function. always determines how the exception filter
     * should dispose of the exception.
     */
    _PHNDLR XcptAction;
};

extern struct _XCPT_ACTION _XcptActTab[];

/*
 * number of entries in the exception-action table
 */
extern int _XcptActTabCount;

/*
 * size of exception-action table (in bytes)
 */
extern int _XcptActTabSize;

/*
 * index of the first floating point exception entry
 */
extern int _First_FPE_Indx;

/*
 * number of FPE entries
 */
extern int _Num_FPE;

/*
 * return values and prototype for the exception filter function used in the
 * C startup
 */
int __cdecl _XcptFilter(unsigned long, struct _EXCEPTION_POINTERS *);

int __cdecl UnhandledExceptionFilter(struct _EXCEPTION_POINTERS*);

#ifdef __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_EXCPT */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\extapi.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
///////////////////////////////////////////////////////////////
// Copyright (c) Microsoft Corporation. All rights reserved. //
///////////////////////////////////////////////////////////////


#pragma once

#ifndef _ExTAPI_H_
#define _ExTAPI_H_


#include <windows.h>


#ifdef __cplusplus
extern "C" {
#endif


// ExTAPI LINEERR_ constants
#define LINEERR_INCORRECTPASSWORD               0x80010001

// Line barring modes
#define LINEBARRMODE_OUT                        0x00000001
#define LINEBARRMODE_OUT_INT                    0x00000002
#define LINEBARRMODE_OUT_INTEXTOHOME            0x00000004
#define LINEBARRMODE_IN                         0x00000008
#define LINEBARRMODE_IN_ROAM                    0x00000010
#define LINEBARRMODE_IN_NOTINSIM                0x00000020
#define LINEBARRMODE_ALL                        0x00000040
#define LINEBARRMODE_ALL_OUT                    0x00000080
#define LINEBARRMODE_ALL_IN                     0x00000100

// Line call-waiting states
#define LINECALLWAITING_ENABLED                 0x00000001
#define LINECALLWAITING_DISABLED                0x00000002

// Line capability classes
#define LINECAPSCLASS_VOICE                     0x00000001
#define LINECAPSCLASS_DATA                      0x00000002
#define LINECAPSCLASS_FAX                       0x00000004
#define LINECAPSCLASS_SMS                       0x00000008
#define LINECAPSCLASS_SYNCDATA                  0x00000010
#define LINECAPSCLASS_ASYNCDATA                 0x00000020
#define LINECAPSCLASS_PACKET                    0x00000040
#define LINECAPSCLASS_PAD                       0x00000080
#define LINECAPSCLASS_ALL                       0x000000ff

// Line equipment states
#define LINEEQUIPSTATE_MINIMUM                  0x00000001
#define LINEEQUIPSTATE_RXONLY                   0x00000002
#define LINEEQUIPSTATE_TXONLY                   0x00000003
#define LINEEQUIPSTATE_NOTXRX                   0x00000004
#define LINEEQUIPSTATE_FULL                     0x00000005

// Line GPRS class types
#define LINEGPRSCLASS_GSMANDGPRS                0x00000001
#define LINEGPRSCLASS_GSMORGPRS                 0x00000002
#define LINEGPRSCLASS_GSMORGPRS_EXCLUSIVE       0x00000003
#define LINEGPRSCLASS_GPRSONLY                  0x00000004
#define LINEGPRSCLASS_GSMONLY                   0x00000005

// Line GPRS class changed types
#define LINEGPRSCLASSCHANGED_NETWORK            0x00000001
#define LINEGPRSCLASSCHANGED_RADIO              0x00000002

// Line HSCSD air-rates
#define LINEHSCSDAIRRATE_9600                   0x00000001
#define LINEHSCSDAIRRATE_14400                  0x00000002
#define LINEHSCSDAIRRATE_19200                  0x00000003
#define LINEHSCSDAIRRATE_28800                  0x00000004
#define LINEHSCSDAIRRATE_38400                  0x00000005
#define LINEHSCSDAIRRATE_43200                  0x00000006
#define LINEHSCSDAIRRATE_57600                  0x00000007

// Line HSCSD codings
#define LINEHSCSDCODING_4800                    0x00000001
#define LINEHSCSDCODING_9600                    0x00000002
#define LINEHSCSDCODING_14400                   0x00000004

// Line mute states
#define LINEMUTESTATE_MUTEENABLED               0x00000001
#define LINEMUTESTATE_MUTEDISABLED              0x00000002

// Line operator formats
#define LINEOPFORMAT_NONE                       0x00000000
#define LINEOPFORMAT_ALPHASHORT                 0x00000001
#define LINEOPFORMAT_ALPHALONG                  0x00000002
#define LINEOPFORMAT_NUMERIC                    0x00000004
#define LINEOPFORMAT_ACCESS_TYPE                0x00000008

// Line operator statuses
#define LINEOPSTATUS_UNKNOWN                    0x00000000
#define LINEOPSTATUS_AVAILABLE                  0x00000001
#define LINEOPSTATUS_CURRENT                    0x00000002
#define LINEOPSTATUS_FORBIDDEN                  0x00000003

// Line radio presence states
#define LINERADIOPRESENCE_PRESENT               0x00000001
#define LINERADIOPRESENCE_NOTPRESENT            0x00000002

// Line radio support states
#define LINERADIOSUPPORT_OFF                    0x00000001
#define LINERADIOSUPPORT_ON                     0x00000002
#define LINERADIOSUPPORT_UNKNOWN                0x00000003

// Line register modes
#define LINEREGMODE_AUTOMATIC                   0x00000001
#define LINEREGMODE_MANUAL                      0x00000002
#define LINEREGMODE_MANAUTO                     0x00000003
#define LINEREGMODE_AUTOGSM                     0x00000004
#define LINEREGMODE_MANUALGSM                   0x00000005
#define LINEREGMODE_AUTOCDMA                    0x00000006
#define LINEREGMODE_MANUALCDMA                  0x00000007

// Line register status
#define LINEREGSTATUS_UNKNOWN                   0x00000001
#define LINEREGSTATUS_DENIED                    0x00000002
#define LINEREGSTATUS_UNREGISTERED              0x00000003
#define LINEREGSTATUS_ATTEMPTING                0x00000004
#define LINEREGSTATUS_HOME                      0x00000005
#define LINEREGSTATUS_ROAM                      0x00000006
#define LINEREGSTATUS_DIGITAL                   0x00000007
#define LINEREGSTATUS_ANALOG                    0x00000008

// Line send caller-ID states
#define LINESENDCALLERID_ENABLED                0x00000001
#define LINESENDCALLERID_DISABLED               0x00000002

// Line system types, CDMA
#define LINESYSTEMTYPE_NONE                     0x00000000
#define LINESYSTEMTYPE_IS95A                    0x00000001
#define LINESYSTEMTYPE_IS95B                    0x00000002
#define LINESYSTEMTYPE_1XRTTPACKET              0x00000004
// Line system types, GSM
#define LINESYSTEMTYPE_GSM                      0x00000008
#define LINESYSTEMTYPE_GPRS                     0x00000010
// Line system types, GSM, CDMA, UMTS, HSDPA
#define LINESYSTEMTYPE_EDGE                     0x00000020
#define LINESYSTEMTYPE_1XEVDOPACKET     0x00000040
#define LINESYSTEMTYPE_1XEVDVPACKET     0x00000080
#define LINESYSTEMTYPE_UMTS                     0x00000100
#define LINESYSTEMTYPE_HSDPA                    0x00000200

// Line USSD flags
#define LINEUSSDFLAG_ACTIONREQUIRED             0x00000001
#define LINEUSSDFLAG_ACTIONNOTNEEDED            0x00000002
#define LINEUSSDFLAG_TERMINATED                 0x00000004
#define LINEUSSDFLAG_OTHERCLIENTRESPONDED       0x00000008
#define LINEUSSDFLAG_UNSUPPORTED                0x00000010
#define LINEUSSDFLAG_TIMEOUT                    0x00000020
#define LINEUSSDFLAG_ENDSESSION                 0x00000040

// Special LINEOPERATOR index values
#define LINEOPERATOR_USEFIRSTAVAILABLEINDEX     (-1)

// Line operator statuses
#define LINEACCESSTYPE_UNKNOWN                  0x00000000
#define LINEACCESSTYPE_UMTS                     0x00000001
#define LINEACCESSTYPE_GSM                      0x00000002
#define LINEACCESSTYPE_GSM_COMPACT              0x00000003

// Maximum string lengths
#define MAX_LENGTH_OPERATOR_LONG                32
#define MAX_LENGTH_OPERATOR_SHORT               16
#define MAX_LENGTH_OPERATOR_NUMERIC             16


// LINE_DEVSPECIFIC message types
#define LINE_EQUIPSTATECHANGE                   0x00000100
    // dwParam1 = LINE_EQUIPSTATECHANGE
    // dwParam2 = One of the LINEEQUIPSTATE_* constants
    // dwParam3 = One of the LINERADIOSUPPORT_* constants

#define LINE_GPRSCLASS                          0x00000101
    // dwParam1 = LINE_GPRSCLASS
    // dwParam2 = One of the LINEGPRSCLASS_* constants
    // dwParam3 = One of the LINEGPRSCLASSCHANGED_* constants

#define LINE_GPRSREGISTERSTATE                  0x00000102
    // dwParam1 = LINE_GPRSREGISTERSTATE
    // dwParam2 = One of the LINEREGSTATUS_* constants
    // dwParam3 Unused

#define LINE_RADIOPRESENCE                      0x00000103
    // dwParam1 = LINE_RADIOPRESENCE
    // dwParam2 = One of the LINERADIOPRESENCE_* constants
    // dwParam3 Unused

#define LINE_REGISTERSTATE                      0x00000104
    // dwParam1 = LINE_REGISTERSTATE
    // dwParam2 = One of the LINEREGSTATUS_* constants
    // dwParam3 Unused

#define LINE_USSD                               0x00000105
    // dwParam1 = LINE_USSD
    // dwParam2 = Message identifier
    // dwParam3 = Size in bytes of message
    
#define LINE_CURRENTLINECHANGE                  0x00000106
    // dwParam1 = LINE_CURRENTLINECHANGE
    // dwParam2 = New line identifier
    // dwParam3 = New address ID

#define LINE_CURRENTSYSTEMCHANGE                0x00000107
    // dwParam1 = LINE_CURRENTSYSTEMCHANGE
    // dwParam2 = New system coverage (LINESYSTEMTYPE_*)
    // dwParam3 = unused


// Structures
typedef struct lineoperator_tag {
    DWORD dwIndex;
    DWORD dwValidFields;
    DWORD dwStatus;
    TCHAR lpszLongName[MAX_LENGTH_OPERATOR_LONG];
    TCHAR lpszShortName[MAX_LENGTH_OPERATOR_SHORT];
    TCHAR lpszNumName[MAX_LENGTH_OPERATOR_NUMERIC];
} LINEOPERATOR, *LPLINEOPERATOR;

typedef struct lineoperatorex_tag {
    DWORD cbSize;
    DWORD dwIndex;
    DWORD dwValidFields;
    DWORD dwStatus;
    TCHAR lpszLongName[MAX_LENGTH_OPERATOR_LONG];
    TCHAR lpszShortName[MAX_LENGTH_OPERATOR_SHORT];
    TCHAR lpszNumName[MAX_LENGTH_OPERATOR_NUMERIC];
    DWORD dwAccessType;
} LINEOPERATOREX, *LPLINEOPERATOREX;

typedef struct lineoperatorstatus_tag {
    DWORD dwTotalSize;
    DWORD dwNeededSize;
    DWORD dwUsedSize;
    DWORD dwPreferredCount;
    DWORD dwPreferredSize;
    DWORD dwPreferredOffset;
    DWORD dwAvailableCount;
    DWORD dwAvailableSize;
    DWORD dwAvailableOffset;
} LINEOPERATORSTATUS, *LPLINEOPERATORSTATUS;

typedef struct linegeneralinfo_tag {
    DWORD dwTotalSize;
    DWORD dwNeededSize;
    DWORD dwUsedSize;
    DWORD dwManufacturerSize;
    DWORD dwManufacturerOffset;
    DWORD dwModelSize;
    DWORD dwModelOffset;
    DWORD dwRevisionSize;
    DWORD dwRevisionOffset;
    DWORD dwSerialNumberSize;
    DWORD dwSerialNumberOffset;
    DWORD dwSubscriberNumberSize;
    DWORD dwSubscriberNumberOffset;
} LINEGENERALINFO, *LPLINEGENERALINFO;

// Functions
LONG WINAPI lineGetCallBarringCaps(
    HLINE hLine,
    LPDWORD lpdwModes,
    LPDWORD lpdwClasses
);

LONG WINAPI lineGetCallBarringState(
    HLINE hLine,
    DWORD dwMode,
    LPDWORD lpdwClasses,
    LPCTSTR lpszPassword
);

LONG WINAPI lineGetCallWaitingCaps(
    HLINE hLine,
    LPDWORD lpdwClasses
);

LONG WINAPI lineGetCallWaitingState(
    HLINE hLine,
    LPDWORD lpdwClasses
);

LONG WINAPI lineGetCurrentAddressID(
    HLINE hLine,
    LPDWORD lpdwAddressID
);

LONG WINAPI lineGetCurrentHSCSDStatus(
    HLINE hLine,
    LPDWORD lpdwChannelsIn,
    LPDWORD lpdwChannelsOut,
    LPDWORD lpdwChannelCoding,
    LPDWORD lpdwAirInterfaceRate
);

LONG WINAPI lineGetCurrentOperator(
    HLINE hLine,
    LPLINEOPERATOR lpCurrentOperator
);

LONG WINAPI lineGetCurrentOperatorEx(
    HLINE hLine,
    LPLINEOPERATOREX lpCurrentOperatorEx
);

LONG WINAPI lineGetCurrentSystemType(
    HLINE hLine,
    LPDWORD lpdwCurrentSystemType
);

LONG WINAPI lineGetEquipmentState(
    HLINE hLine,
    LPDWORD lpdwState,
    LPDWORD lpdwRadioSupport
);

LONG WINAPI lineGetGeneralInfo(
    HLINE hLine,
    LPLINEGENERALINFO lpLineGeneralInfo
);

LONG WINAPI lineGetGPRSClass(
    HLINE hLine,
    LPDWORD lpdwClass
);

LONG WINAPI lineGetHSCSDCaps(
    HLINE hLine,
    LPDWORD lpdwClass,
    LPDWORD lpdwChannelsIn,
    LPDWORD lpdwChannelsOut,
    LPDWORD lpdwChannelsSum,
    LPDWORD lpdwChannelCodings
);

LONG WINAPI lineGetHSCSDState(
    HLINE hLine,
    LPDWORD lpdwChannelsIn,
    LPDWORD lpdwMaxChannelsIn,
    LPDWORD lpdwChannelCodings,
    LPDWORD lpdwAirInterfaceRate
);

LONG WINAPI lineGetMuteState(
    HLINE hLine,
    LPDWORD lpdwState
);

LONG WINAPI lineGetNumberCalls(
    HLINE hLine,
    LPDWORD lpdwNumActiveCalls,
    LPDWORD lpdwNumOnHoldCalls,
    LPDWORD lpdwNumOnHoldPendCalls
);

LONG WINAPI lineGetOperatorStatus(
    HLINE hLine,
    LPLINEOPERATORSTATUS lpOperatorStatus
);

LONG WINAPI lineGetOperatorStatusEx(
    HLINE hLine,
    LPLINEOPERATORSTATUS lpOperatorStatus
);

LONG WINAPI lineGetRadioPresence(
    HLINE hLine,
    LPDWORD lpdwRadioPresence
);

LONG WINAPI lineGetRegisterStatus(
    HLINE hLine,
    LPDWORD lpdwRegisterStatus
);

LONG WINAPI lineGetSendCallerIDState(
    HLINE hLine,
    LPDWORD lpdwState
);

LONG WINAPI lineGetUSSD(
    HLINE hLine,
    DWORD dwID,
    LPBYTE lpbUSSD,
    DWORD dwUSSDSize,
    LPDWORD lpdwFlags
);

LONG WINAPI lineRegister(
    HLINE hLine,
    DWORD dwRegisterMode,
    LPCTSTR lpszOperator,
    DWORD dwOperatorFormat
);

LONG WINAPI lineRegisterEx(
    HLINE hLine,
    DWORD dwRegisterMode,
    LPLINEOPERATOREX lpOperatorEx
);

LONG WINAPI lineSendUSSD(
    HLINE hLine,
    const BYTE* const lpbUSSD,
    DWORD dwUSSDSize,
    DWORD dwFlags
);

LONG WINAPI lineSetCallBarringPassword(
    HLINE hLine,
    DWORD dwMode,
    LPCTSTR lpszOldPassword,
    LPCTSTR lpszNewPassword
);

LONG WINAPI lineSetCallBarringState(
    HLINE hLine,
    DWORD dwMode,
    DWORD dwClasses,
    LPCTSTR lpszPassword
);

LONG WINAPI lineSetCallWaitingState(
    HLINE hLine,
    DWORD dwClasses,
    DWORD dwState
);

LONG WINAPI lineSetCurrentAddressID(
    HLINE hLine,
    DWORD dwAddressID
);

LONG WINAPI lineSetEquipmentState(
    HLINE hLine,
    DWORD dwState
);

LONG WINAPI lineSetGPRSClass(
    HLINE hLine,
    DWORD dwClass
);

LONG WINAPI lineSetHSCSDState(
    HLINE hLine,
    DWORD dwChannelsIn,
    DWORD dwMaxChannelsIn,
    DWORD dwChannelCodings,
    DWORD dwAirInterfaceRate
);

LONG WINAPI lineSetMuteState(
    HLINE hLine,
    DWORD dwState
);

LONG WINAPI lineSetSendCallerIDState(
    HLINE hLine,
    DWORD dwState
);

LONG WINAPI lineSetPreferredOperator(
    HLINE hLine,
    LPLINEOPERATOR lpOperator
);

LONG WINAPI lineSetPreferredOperatorEx(
    HLINE hLine,
    LPLINEOPERATOREX lpOperatorEx
);

LONG WINAPI lineUnregister(
    HLINE hLine
);


#ifdef __cplusplus
}
#endif


#endif // _ExTAPI_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\float.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/***
*float.h - constants for floating point values
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains defines for a number of implementation dependent
*       values which are commonly used by sophisticated numerical (floating
*       point) programs.
*       [ANSI]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_FLOAT
#define _INC_FLOAT

/*
 * STDLIB is included for legacy reasons.  It contains the "old" function
 * declarations.
 */
#include <stdlib.h>

#include <crtdefs.h>

#ifdef  __cplusplus
extern "C" {
#endif

_CRTIMP errno_t __cdecl _controlfp_s(__out_opt unsigned int *_CurrentState, __in unsigned int _NewValue, __in unsigned int _Mask);

_CRTIMP __checkReturn int __cdecl _isnanf(__in float);
_CRTIMP __checkReturn int __cdecl _isunordered(__in double, __in double);
_CRTIMP __checkReturn int __cdecl _isunorderedf(__in float, __in float);


#ifdef  __cplusplus
}
#endif

#endif  /* _INC_FLOAT */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\fourcc.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this source code is subject to the terms of the Microsoft
// premium shared source license agreement under which you licensed
// this source code. If you did not accept the terms of the license
// agreement, you are not authorized to use this source code.
// For the terms of the license, please see the license agreement
// signed by you and Microsoft.
// THE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//
//--------------------------------------------------------------------------;

// FOURCCMap
//
// provides a mapping between old-style multimedia format DWORDs
// and new-style GUIDs.
//
// A range of 4 billion GUIDs has been allocated to ensure that this
// mapping can be done straightforwardly one-to-one in both directions.
//
// January 95


#ifndef __FOURCC__
#define __FOURCC__


// Multimedia format types are marked with DWORDs built from four 8-bit
// chars and known as FOURCCs. New multimedia AM_MEDIA_TYPE definitions include
// a subtype GUID. In order to simplify the mapping, GUIDs in the range:
//    XXXXXXXX-0000-0010-8000-00AA00389B71
// are reserved for FOURCCs.

class FOURCCMap : public GUID
{

public:
    FOURCCMap();
    FOURCCMap(DWORD Fourcc);
    FOURCCMap(const GUID *);


    DWORD GetFOURCC(void);
    void SetFOURCC(DWORD fourcc);
    void SetFOURCC(const GUID *);

private:
    void InitGUID();
};

#define GUID_Data2      0
#define GUID_Data3     0x10
#define GUID_Data4_1   0xaa000080
#define GUID_Data4_2   0x719b3800

inline void
FOURCCMap::InitGUID() {
    Data2 = GUID_Data2;
    Data3 = GUID_Data3;
    ((DWORD *)Data4)[0] = GUID_Data4_1;
    ((DWORD *)Data4)[1] = GUID_Data4_2;
}

inline
FOURCCMap::FOURCCMap() {
    InitGUID();
    SetFOURCC( DWORD(0));
}

inline
FOURCCMap::FOURCCMap(DWORD fourcc)
{
    InitGUID();
    SetFOURCC(fourcc);
}

inline
FOURCCMap::FOURCCMap(const GUID * pGuid)
{
    InitGUID();
    SetFOURCC(pGuid);
}

inline void
FOURCCMap::SetFOURCC(const GUID * pGuid)
{
    FOURCCMap * p = (FOURCCMap*) pGuid;
    SetFOURCC(p->GetFOURCC());
}

inline void
FOURCCMap::SetFOURCC(DWORD fourcc)
{
    Data1 = fourcc;
}

inline DWORD
FOURCCMap::GetFOURCC(void)
{
    return Data1;
}

#endif /* __FOURCC__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\exdisp.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES.
//

#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0286 */
/* at Fri Jan 26 17:19:16 2007
 */
/* Compiler settings for ..\exdisp.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __exdisp_h__
#define __exdisp_h__

/* Forward Declarations */ 

#ifndef __IWebBrowser_FWD_DEFINED__
#define __IWebBrowser_FWD_DEFINED__
typedef interface IWebBrowser IWebBrowser;
#endif 	/* __IWebBrowser_FWD_DEFINED__ */


#ifndef __DWebBrowserEvents_FWD_DEFINED__
#define __DWebBrowserEvents_FWD_DEFINED__
typedef interface DWebBrowserEvents DWebBrowserEvents;
#endif 	/* __DWebBrowserEvents_FWD_DEFINED__ */


#ifndef __IWebBrowserApp_FWD_DEFINED__
#define __IWebBrowserApp_FWD_DEFINED__
typedef interface IWebBrowserApp IWebBrowserApp;
#endif 	/* __IWebBrowserApp_FWD_DEFINED__ */


#ifndef __IWebBrowser2_FWD_DEFINED__
#define __IWebBrowser2_FWD_DEFINED__
typedef interface IWebBrowser2 IWebBrowser2;
#endif 	/* __IWebBrowser2_FWD_DEFINED__ */


#ifndef __DWebBrowserEvents2_FWD_DEFINED__
#define __DWebBrowserEvents2_FWD_DEFINED__
typedef interface DWebBrowserEvents2 DWebBrowserEvents2;
#endif 	/* __DWebBrowserEvents2_FWD_DEFINED__ */


#ifndef __WebBrowser_V1_FWD_DEFINED__
#define __WebBrowser_V1_FWD_DEFINED__

#ifdef __cplusplus
typedef class WebBrowser_V1 WebBrowser_V1;
#else
typedef struct WebBrowser_V1 WebBrowser_V1;
#endif /* __cplusplus */

#endif 	/* __WebBrowser_V1_FWD_DEFINED__ */


#ifndef __WebBrowser_FWD_DEFINED__
#define __WebBrowser_FWD_DEFINED__

#ifdef __cplusplus
typedef class WebBrowser WebBrowser;
#else
typedef struct WebBrowser WebBrowser;
#endif /* __cplusplus */

#endif 	/* __WebBrowser_FWD_DEFINED__ */


#ifndef __InternetExplorer_FWD_DEFINED__
#define __InternetExplorer_FWD_DEFINED__

#ifdef __cplusplus
typedef class InternetExplorer InternetExplorer;
#else
typedef struct InternetExplorer InternetExplorer;
#endif /* __cplusplus */

#endif 	/* __InternetExplorer_FWD_DEFINED__ */


#ifndef __ShellBrowserWindow_FWD_DEFINED__
#define __ShellBrowserWindow_FWD_DEFINED__

#ifdef __cplusplus
typedef class ShellBrowserWindow ShellBrowserWindow;
#else
typedef struct ShellBrowserWindow ShellBrowserWindow;
#endif /* __cplusplus */

#endif 	/* __ShellBrowserWindow_FWD_DEFINED__ */


#ifndef __DShellWindowsEvents_FWD_DEFINED__
#define __DShellWindowsEvents_FWD_DEFINED__
typedef interface DShellWindowsEvents DShellWindowsEvents;
#endif 	/* __DShellWindowsEvents_FWD_DEFINED__ */


#ifndef __IShellWindows_FWD_DEFINED__
#define __IShellWindows_FWD_DEFINED__
typedef interface IShellWindows IShellWindows;
#endif 	/* __IShellWindows_FWD_DEFINED__ */


#ifndef __ShellWindows_FWD_DEFINED__
#define __ShellWindows_FWD_DEFINED__

#ifdef __cplusplus
typedef class ShellWindows ShellWindows;
#else
typedef struct ShellWindows ShellWindows;
#endif /* __cplusplus */

#endif 	/* __ShellWindows_FWD_DEFINED__ */


#ifndef __IShellUIHelper_FWD_DEFINED__
#define __IShellUIHelper_FWD_DEFINED__
typedef interface IShellUIHelper IShellUIHelper;
#endif 	/* __IShellUIHelper_FWD_DEFINED__ */


#ifndef __IShellUIHelper2_FWD_DEFINED__
#define __IShellUIHelper2_FWD_DEFINED__
typedef interface IShellUIHelper2 IShellUIHelper2;
#endif 	/* __IShellUIHelper2_FWD_DEFINED__ */


#ifndef __ShellUIHelper_FWD_DEFINED__
#define __ShellUIHelper_FWD_DEFINED__

#ifdef __cplusplus
typedef class ShellUIHelper ShellUIHelper;
#else
typedef struct ShellUIHelper ShellUIHelper;
#endif /* __cplusplus */

#endif 	/* __ShellUIHelper_FWD_DEFINED__ */


#ifndef __DShellNameSpaceEvents_FWD_DEFINED__
#define __DShellNameSpaceEvents_FWD_DEFINED__
typedef interface DShellNameSpaceEvents DShellNameSpaceEvents;
#endif 	/* __DShellNameSpaceEvents_FWD_DEFINED__ */


#ifndef __IShellFavoritesNameSpace_FWD_DEFINED__
#define __IShellFavoritesNameSpace_FWD_DEFINED__
typedef interface IShellFavoritesNameSpace IShellFavoritesNameSpace;
#endif 	/* __IShellFavoritesNameSpace_FWD_DEFINED__ */


#ifndef __IShellNameSpace_FWD_DEFINED__
#define __IShellNameSpace_FWD_DEFINED__
typedef interface IShellNameSpace IShellNameSpace;
#endif 	/* __IShellNameSpace_FWD_DEFINED__ */


#ifndef __ShellNameSpace_FWD_DEFINED__
#define __ShellNameSpace_FWD_DEFINED__

#ifdef __cplusplus
typedef class ShellNameSpace ShellNameSpace;
#else
typedef struct ShellNameSpace ShellNameSpace;
#endif /* __cplusplus */

#endif 	/* __ShellNameSpace_FWD_DEFINED__ */


#ifndef __ShellShellNameSpace_FWD_DEFINED__
#define __ShellShellNameSpace_FWD_DEFINED__

#ifdef __cplusplus
typedef class ShellShellNameSpace ShellShellNameSpace;
#else
typedef struct ShellShellNameSpace ShellShellNameSpace;
#endif /* __cplusplus */

#endif 	/* __ShellShellNameSpace_FWD_DEFINED__ */


#ifndef __IScriptErrorList_FWD_DEFINED__
#define __IScriptErrorList_FWD_DEFINED__
typedef interface IScriptErrorList IScriptErrorList;
#endif 	/* __IScriptErrorList_FWD_DEFINED__ */


#ifndef __CScriptErrorList_FWD_DEFINED__
#define __CScriptErrorList_FWD_DEFINED__

#ifdef __cplusplus
typedef class CScriptErrorList CScriptErrorList;
#else
typedef struct CScriptErrorList CScriptErrorList;
#endif /* __cplusplus */

#endif 	/* __CScriptErrorList_FWD_DEFINED__ */


/* header files for imported files */
#include "ocidl.h"
#include "docobj.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_exdisp_0000 */
/* [local] */ 

#define SID_SkipHung IID_IEnumVARIANT


extern RPC_IF_HANDLE __MIDL_itf_exdisp_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_exdisp_0000_v0_0_s_ifspec;


#ifndef __SHDocVw_LIBRARY_DEFINED__
#define __SHDocVw_LIBRARY_DEFINED__

/* library SHDocVw */
/* [version][lcid][helpstring][uuid] */ 

typedef /* [helpstring] */ 
enum CommandStateChangeConstants
    {	CSC_UPDATECOMMANDS	= 0xffffffff,
	CSC_NAVIGATEFORWARD	= 0x1,
	CSC_NAVIGATEBACK	= 0x2
    }	CommandStateChangeConstants;

typedef /* [helpstring] */ 
enum SecureLockIconConstants
    {	secureLockIconUnsecure	= 0,
	secureLockIconMixed	= 0x1,
	secureLockIconSecureUnknownBits	= 0x2,
	secureLockIconSecure40Bit	= 0x3,
	secureLockIconSecure56Bit	= 0x4,
	secureLockIconSecureFortezza	= 0x5,
	secureLockIconSecure128Bit	= 0x6
    }	SecureLockIconConstants;

typedef /* [helpstring] */ 
enum ShellWindowTypeConstants
    {	SWC_EXPLORER	= 0,
	SWC_BROWSER	= 0x1,
	SWC_3RDPARTY	= 0x2,
	SWC_CALLBACK	= 0x4,
	SWC_DESKTOP	= 0x8
    }	ShellWindowTypeConstants;

typedef /* [hidden][helpstring] */ 
enum ShellWindowFindWindowOptions
    {	SWFO_NEEDDISPATCH	= 0x1,
	SWFO_INCLUDEPENDING	= 0x2,
	SWFO_COOKIEPASSED	= 0x4
    }	ShellWindowFindWindowOptions;


EXTERN_C const IID LIBID_SHDocVw;

#ifndef __IWebBrowser_INTERFACE_DEFINED__
#define __IWebBrowser_INTERFACE_DEFINED__

/* interface IWebBrowser */
/* [object][oleautomation][dual][hidden][helpcontext][helpstring][uuid] */ 

typedef /* [helpstring] */ 
enum BrowserNavConstants
    {	navOpenInNewWindow	= 0x1,
	navNoHistory	= 0x2,
	navNoReadFromCache	= 0x4,
	navNoWriteToCache	= 0x8,
	navAllowAutosearch	= 0x10,
	navBrowserBar	= 0x20,
	navHyperlink	= 0x40,
	navEnforceRestricted	= 0x80,
	navNewWindowsManaged	= 0x100,
	navUntrustedForDownload	= 0x200,
	navTrustedForActiveX	= 0x400,
	navOpenInNewTab	= 0x800,
	navOpenInBackgroundTab	= 0x1000,
	navKeepWordWheelText	= 0x2000
    }	BrowserNavConstants;

typedef /* [helpstring] */ 
enum RefreshConstants
    {	REFRESH_NORMAL	= 0,
	REFRESH_IFEXPIRED	= 1,
	REFRESH_COMPLETELY	= 3
    }	RefreshConstants;


EXTERN_C const IID IID_IWebBrowser;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("EAB22AC1-30C1-11CF-A7EB-0000C05BAE0B")
    IWebBrowser : public IDispatch
    {
    public:
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE GoBack( void) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE GoForward( void) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE GoHome( void) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE GoSearch( void) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Navigate( 
            /* [in] */ BSTR URL,
            /* [optional][in] */ VARIANT __RPC_FAR *Flags,
            /* [optional][in] */ VARIANT __RPC_FAR *TargetFrameName,
            /* [optional][in] */ VARIANT __RPC_FAR *PostData,
            /* [optional][in] */ VARIANT __RPC_FAR *Headers) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Refresh( void) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Refresh2( 
            /* [optional][in] */ VARIANT __RPC_FAR *Level) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Stop( void) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Application( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDisp) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Parent( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDisp) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Container( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDisp) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Document( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDisp) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_TopLevelContainer( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pBool) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Type( 
            /* [retval][out] */ BSTR __RPC_FAR *Type) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Left( 
            /* [retval][out] */ long __RPC_FAR *pl) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Left( 
            /* [in] */ long Left) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Top( 
            /* [retval][out] */ long __RPC_FAR *pl) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Top( 
            /* [in] */ long Top) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Width( 
            /* [retval][out] */ long __RPC_FAR *pl) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Width( 
            /* [in] */ long Width) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Height( 
            /* [retval][out] */ long __RPC_FAR *pl) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Height( 
            /* [in] */ long Height) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_LocationName( 
            /* [retval][out] */ BSTR __RPC_FAR *LocationName) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_LocationURL( 
            /* [retval][out] */ BSTR __RPC_FAR *LocationURL) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Busy( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pBool) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWebBrowserVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWebBrowser __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWebBrowser __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWebBrowser __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IWebBrowser __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IWebBrowser __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IWebBrowser __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IWebBrowser __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GoBack )( 
            IWebBrowser __RPC_FAR * This);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GoForward )( 
            IWebBrowser __RPC_FAR * This);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GoHome )( 
            IWebBrowser __RPC_FAR * This);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GoSearch )( 
            IWebBrowser __RPC_FAR * This);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Navigate )( 
            IWebBrowser __RPC_FAR * This,
            /* [in] */ BSTR URL,
            /* [optional][in] */ VARIANT __RPC_FAR *Flags,
            /* [optional][in] */ VARIANT __RPC_FAR *TargetFrameName,
            /* [optional][in] */ VARIANT __RPC_FAR *PostData,
            /* [optional][in] */ VARIANT __RPC_FAR *Headers);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Refresh )( 
            IWebBrowser __RPC_FAR * This);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Refresh2 )( 
            IWebBrowser __RPC_FAR * This,
            /* [optional][in] */ VARIANT __RPC_FAR *Level);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Stop )( 
            IWebBrowser __RPC_FAR * This);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Application )( 
            IWebBrowser __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDisp);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Parent )( 
            IWebBrowser __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDisp);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Container )( 
            IWebBrowser __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDisp);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Document )( 
            IWebBrowser __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDisp);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_TopLevelContainer )( 
            IWebBrowser __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pBool);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Type )( 
            IWebBrowser __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *Type);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Left )( 
            IWebBrowser __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pl);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Left )( 
            IWebBrowser __RPC_FAR * This,
            /* [in] */ long Left);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Top )( 
            IWebBrowser __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pl);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Top )( 
            IWebBrowser __RPC_FAR * This,
            /* [in] */ long Top);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Width )( 
            IWebBrowser __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pl);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Width )( 
            IWebBrowser __RPC_FAR * This,
            /* [in] */ long Width);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Height )( 
            IWebBrowser __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pl);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Height )( 
            IWebBrowser __RPC_FAR * This,
            /* [in] */ long Height);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_LocationName )( 
            IWebBrowser __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *LocationName);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_LocationURL )( 
            IWebBrowser __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *LocationURL);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Busy )( 
            IWebBrowser __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pBool);
        
        END_INTERFACE
    } IWebBrowserVtbl;

    interface IWebBrowser
    {
        CONST_VTBL struct IWebBrowserVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWebBrowser_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWebBrowser_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWebBrowser_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWebBrowser_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWebBrowser_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWebBrowser_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWebBrowser_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWebBrowser_GoBack(This)	\
    (This)->lpVtbl -> GoBack(This)

#define IWebBrowser_GoForward(This)	\
    (This)->lpVtbl -> GoForward(This)

#define IWebBrowser_GoHome(This)	\
    (This)->lpVtbl -> GoHome(This)

#define IWebBrowser_GoSearch(This)	\
    (This)->lpVtbl -> GoSearch(This)

#define IWebBrowser_Navigate(This,URL,Flags,TargetFrameName,PostData,Headers)	\
    (This)->lpVtbl -> Navigate(This,URL,Flags,TargetFrameName,PostData,Headers)

#define IWebBrowser_Refresh(This)	\
    (This)->lpVtbl -> Refresh(This)

#define IWebBrowser_Refresh2(This,Level)	\
    (This)->lpVtbl -> Refresh2(This,Level)

#define IWebBrowser_Stop(This)	\
    (This)->lpVtbl -> Stop(This)

#define IWebBrowser_get_Application(This,ppDisp)	\
    (This)->lpVtbl -> get_Application(This,ppDisp)

#define IWebBrowser_get_Parent(This,ppDisp)	\
    (This)->lpVtbl -> get_Parent(This,ppDisp)

#define IWebBrowser_get_Container(This,ppDisp)	\
    (This)->lpVtbl -> get_Container(This,ppDisp)

#define IWebBrowser_get_Document(This,ppDisp)	\
    (This)->lpVtbl -> get_Document(This,ppDisp)

#define IWebBrowser_get_TopLevelContainer(This,pBool)	\
    (This)->lpVtbl -> get_TopLevelContainer(This,pBool)

#define IWebBrowser_get_Type(This,Type)	\
    (This)->lpVtbl -> get_Type(This,Type)

#define IWebBrowser_get_Left(This,pl)	\
    (This)->lpVtbl -> get_Left(This,pl)

#define IWebBrowser_put_Left(This,Left)	\
    (This)->lpVtbl -> put_Left(This,Left)

#define IWebBrowser_get_Top(This,pl)	\
    (This)->lpVtbl -> get_Top(This,pl)

#define IWebBrowser_put_Top(This,Top)	\
    (This)->lpVtbl -> put_Top(This,Top)

#define IWebBrowser_get_Width(This,pl)	\
    (This)->lpVtbl -> get_Width(This,pl)

#define IWebBrowser_put_Width(This,Width)	\
    (This)->lpVtbl -> put_Width(This,Width)

#define IWebBrowser_get_Height(This,pl)	\
    (This)->lpVtbl -> get_Height(This,pl)

#define IWebBrowser_put_Height(This,Height)	\
    (This)->lpVtbl -> put_Height(This,Height)

#define IWebBrowser_get_LocationName(This,LocationName)	\
    (This)->lpVtbl -> get_LocationName(This,LocationName)

#define IWebBrowser_get_LocationURL(This,LocationURL)	\
    (This)->lpVtbl -> get_LocationURL(This,LocationURL)

#define IWebBrowser_get_Busy(This,pBool)	\
    (This)->lpVtbl -> get_Busy(This,pBool)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IWebBrowser_GoBack_Proxy( 
    IWebBrowser __RPC_FAR * This);


void __RPC_STUB IWebBrowser_GoBack_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IWebBrowser_GoForward_Proxy( 
    IWebBrowser __RPC_FAR * This);


void __RPC_STUB IWebBrowser_GoForward_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IWebBrowser_GoHome_Proxy( 
    IWebBrowser __RPC_FAR * This);


void __RPC_STUB IWebBrowser_GoHome_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IWebBrowser_GoSearch_Proxy( 
    IWebBrowser __RPC_FAR * This);


void __RPC_STUB IWebBrowser_GoSearch_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IWebBrowser_Navigate_Proxy( 
    IWebBrowser __RPC_FAR * This,
    /* [in] */ BSTR URL,
    /* [optional][in] */ VARIANT __RPC_FAR *Flags,
    /* [optional][in] */ VARIANT __RPC_FAR *TargetFrameName,
    /* [optional][in] */ VARIANT __RPC_FAR *PostData,
    /* [optional][in] */ VARIANT __RPC_FAR *Headers);


void __RPC_STUB IWebBrowser_Navigate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IWebBrowser_Refresh_Proxy( 
    IWebBrowser __RPC_FAR * This);


void __RPC_STUB IWebBrowser_Refresh_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IWebBrowser_Refresh2_Proxy( 
    IWebBrowser __RPC_FAR * This,
    /* [optional][in] */ VARIANT __RPC_FAR *Level);


void __RPC_STUB IWebBrowser_Refresh2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IWebBrowser_Stop_Proxy( 
    IWebBrowser __RPC_FAR * This);


void __RPC_STUB IWebBrowser_Stop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWebBrowser_get_Application_Proxy( 
    IWebBrowser __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDisp);


void __RPC_STUB IWebBrowser_get_Application_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWebBrowser_get_Parent_Proxy( 
    IWebBrowser __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDisp);


void __RPC_STUB IWebBrowser_get_Parent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWebBrowser_get_Container_Proxy( 
    IWebBrowser __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDisp);


void __RPC_STUB IWebBrowser_get_Container_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWebBrowser_get_Document_Proxy( 
    IWebBrowser __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDisp);


void __RPC_STUB IWebBrowser_get_Document_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWebBrowser_get_TopLevelContainer_Proxy( 
    IWebBrowser __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pBool);


void __RPC_STUB IWebBrowser_get_TopLevelContainer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWebBrowser_get_Type_Proxy( 
    IWebBrowser __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *Type);


void __RPC_STUB IWebBrowser_get_Type_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWebBrowser_get_Left_Proxy( 
    IWebBrowser __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pl);


void __RPC_STUB IWebBrowser_get_Left_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IWebBrowser_put_Left_Proxy( 
    IWebBrowser __RPC_FAR * This,
    /* [in] */ long Left);


void __RPC_STUB IWebBrowser_put_Left_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWebBrowser_get_Top_Proxy( 
    IWebBrowser __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pl);


void __RPC_STUB IWebBrowser_get_Top_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IWebBrowser_put_Top_Proxy( 
    IWebBrowser __RPC_FAR * This,
    /* [in] */ long Top);


void __RPC_STUB IWebBrowser_put_Top_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWebBrowser_get_Width_Proxy( 
    IWebBrowser __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pl);


void __RPC_STUB IWebBrowser_get_Width_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IWebBrowser_put_Width_Proxy( 
    IWebBrowser __RPC_FAR * This,
    /* [in] */ long Width);


void __RPC_STUB IWebBrowser_put_Width_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWebBrowser_get_Height_Proxy( 
    IWebBrowser __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pl);


void __RPC_STUB IWebBrowser_get_Height_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IWebBrowser_put_Height_Proxy( 
    IWebBrowser __RPC_FAR * This,
    /* [in] */ long Height);


void __RPC_STUB IWebBrowser_put_Height_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWebBrowser_get_LocationName_Proxy( 
    IWebBrowser __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *LocationName);


void __RPC_STUB IWebBrowser_get_LocationName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWebBrowser_get_LocationURL_Proxy( 
    IWebBrowser __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *LocationURL);


void __RPC_STUB IWebBrowser_get_LocationURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWebBrowser_get_Busy_Proxy( 
    IWebBrowser __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pBool);


void __RPC_STUB IWebBrowser_get_Busy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWebBrowser_INTERFACE_DEFINED__ */


#ifndef __DWebBrowserEvents_DISPINTERFACE_DEFINED__
#define __DWebBrowserEvents_DISPINTERFACE_DEFINED__

/* dispinterface DWebBrowserEvents */
/* [hidden][helpstring][uuid] */ 


EXTERN_C const IID DIID_DWebBrowserEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("EAB22AC2-30C1-11CF-A7EB-0000C05BAE0B")
    DWebBrowserEvents : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct DWebBrowserEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            DWebBrowserEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            DWebBrowserEvents __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            DWebBrowserEvents __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            DWebBrowserEvents __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            DWebBrowserEvents __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            DWebBrowserEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            DWebBrowserEvents __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        END_INTERFACE
    } DWebBrowserEventsVtbl;

    interface DWebBrowserEvents
    {
        CONST_VTBL struct DWebBrowserEventsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define DWebBrowserEvents_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define DWebBrowserEvents_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define DWebBrowserEvents_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define DWebBrowserEvents_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define DWebBrowserEvents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define DWebBrowserEvents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define DWebBrowserEvents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* __DWebBrowserEvents_DISPINTERFACE_DEFINED__ */


#ifndef __IWebBrowserApp_INTERFACE_DEFINED__
#define __IWebBrowserApp_INTERFACE_DEFINED__

/* interface IWebBrowserApp */
/* [object][dual][oleautomation][hidden][helpcontext][helpstring][uuid] */ 


EXTERN_C const IID IID_IWebBrowserApp;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0002DF05-0000-0000-C000-000000000046")
    IWebBrowserApp : public IWebBrowser
    {
    public:
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Quit( void) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE ClientToWindow( 
            /* [out][in] */ int __RPC_FAR *pcx,
            /* [out][in] */ int __RPC_FAR *pcy) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE PutProperty( 
            /* [in] */ BSTR Property,
            /* [in] */ VARIANT vtValue) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE GetProperty( 
            /* [in] */ BSTR Property,
            /* [retval][out] */ VARIANT __RPC_FAR *pvtValue) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR __RPC_FAR *Name) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_HWND( 
            /* [retval][out] */ SHANDLE_PTR __RPC_FAR *pHWND) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_FullName( 
            /* [retval][out] */ BSTR __RPC_FAR *FullName) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Path( 
            /* [retval][out] */ BSTR __RPC_FAR *Path) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Visible( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pBool) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Visible( 
            /* [in] */ VARIANT_BOOL Value) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_StatusBar( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pBool) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_StatusBar( 
            /* [in] */ VARIANT_BOOL Value) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_StatusText( 
            /* [retval][out] */ BSTR __RPC_FAR *StatusText) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_StatusText( 
            /* [in] */ BSTR StatusText) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ToolBar( 
            /* [retval][out] */ int __RPC_FAR *Value) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ToolBar( 
            /* [in] */ int Value) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_MenuBar( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *Value) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_MenuBar( 
            /* [in] */ VARIANT_BOOL Value) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_FullScreen( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbFullScreen) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_FullScreen( 
            /* [in] */ VARIANT_BOOL bFullScreen) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWebBrowserAppVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWebBrowserApp __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWebBrowserApp __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWebBrowserApp __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IWebBrowserApp __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IWebBrowserApp __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IWebBrowserApp __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IWebBrowserApp __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GoBack )( 
            IWebBrowserApp __RPC_FAR * This);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GoForward )( 
            IWebBrowserApp __RPC_FAR * This);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GoHome )( 
            IWebBrowserApp __RPC_FAR * This);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GoSearch )( 
            IWebBrowserApp __RPC_FAR * This);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Navigate )( 
            IWebBrowserApp __RPC_FAR * This,
            /* [in] */ BSTR URL,
            /* [optional][in] */ VARIANT __RPC_FAR *Flags,
            /* [optional][in] */ VARIANT __RPC_FAR *TargetFrameName,
            /* [optional][in] */ VARIANT __RPC_FAR *PostData,
            /* [optional][in] */ VARIANT __RPC_FAR *Headers);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Refresh )( 
            IWebBrowserApp __RPC_FAR * This);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Refresh2 )( 
            IWebBrowserApp __RPC_FAR * This,
            /* [optional][in] */ VARIANT __RPC_FAR *Level);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Stop )( 
            IWebBrowserApp __RPC_FAR * This);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Application )( 
            IWebBrowserApp __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDisp);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Parent )( 
            IWebBrowserApp __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDisp);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Container )( 
            IWebBrowserApp __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDisp);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Document )( 
            IWebBrowserApp __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDisp);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_TopLevelContainer )( 
            IWebBrowserApp __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pBool);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Type )( 
            IWebBrowserApp __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *Type);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Left )( 
            IWebBrowserApp __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pl);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Left )( 
            IWebBrowserApp __RPC_FAR * This,
            /* [in] */ long Left);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Top )( 
            IWebBrowserApp __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pl);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Top )( 
            IWebBrowserApp __RPC_FAR * This,
            /* [in] */ long Top);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Width )( 
            IWebBrowserApp __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pl);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Width )( 
            IWebBrowserApp __RPC_FAR * This,
            /* [in] */ long Width);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Height )( 
            IWebBrowserApp __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pl);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Height )( 
            IWebBrowserApp __RPC_FAR * This,
            /* [in] */ long Height);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_LocationName )( 
            IWebBrowserApp __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *LocationName);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_LocationURL )( 
            IWebBrowserApp __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *LocationURL);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Busy )( 
            IWebBrowserApp __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pBool);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Quit )( 
            IWebBrowserApp __RPC_FAR * This);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ClientToWindow )( 
            IWebBrowserApp __RPC_FAR * This,
            /* [out][in] */ int __RPC_FAR *pcx,
            /* [out][in] */ int __RPC_FAR *pcy);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PutProperty )( 
            IWebBrowserApp __RPC_FAR * This,
            /* [in] */ BSTR Property,
            /* [in] */ VARIANT vtValue);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProperty )( 
            IWebBrowserApp __RPC_FAR * This,
            /* [in] */ BSTR Property,
            /* [retval][out] */ VARIANT __RPC_FAR *pvtValue);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )( 
            IWebBrowserApp __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *Name);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_HWND )( 
            IWebBrowserApp __RPC_FAR * This,
            /* [retval][out] */ SHANDLE_PTR __RPC_FAR *pHWND);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_FullName )( 
            IWebBrowserApp __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *FullName);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Path )( 
            IWebBrowserApp __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *Path);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Visible )( 
            IWebBrowserApp __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pBool);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Visible )( 
            IWebBrowserApp __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL Value);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StatusBar )( 
            IWebBrowserApp __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pBool);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_StatusBar )( 
            IWebBrowserApp __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL Value);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StatusText )( 
            IWebBrowserApp __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *StatusText);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_StatusText )( 
            IWebBrowserApp __RPC_FAR * This,
            /* [in] */ BSTR StatusText);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ToolBar )( 
            IWebBrowserApp __RPC_FAR * This,
            /* [retval][out] */ int __RPC_FAR *Value);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ToolBar )( 
            IWebBrowserApp __RPC_FAR * This,
            /* [in] */ int Value);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_MenuBar )( 
            IWebBrowserApp __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *Value);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_MenuBar )( 
            IWebBrowserApp __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL Value);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_FullScreen )( 
            IWebBrowserApp __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbFullScreen);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_FullScreen )( 
            IWebBrowserApp __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL bFullScreen);
        
        END_INTERFACE
    } IWebBrowserAppVtbl;

    interface IWebBrowserApp
    {
        CONST_VTBL struct IWebBrowserAppVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWebBrowserApp_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWebBrowserApp_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWebBrowserApp_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWebBrowserApp_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWebBrowserApp_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWebBrowserApp_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWebBrowserApp_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWebBrowserApp_GoBack(This)	\
    (This)->lpVtbl -> GoBack(This)

#define IWebBrowserApp_GoForward(This)	\
    (This)->lpVtbl -> GoForward(This)

#define IWebBrowserApp_GoHome(This)	\
    (This)->lpVtbl -> GoHome(This)

#define IWebBrowserApp_GoSearch(This)	\
    (This)->lpVtbl -> GoSearch(This)

#define IWebBrowserApp_Navigate(This,URL,Flags,TargetFrameName,PostData,Headers)	\
    (This)->lpVtbl -> Navigate(This,URL,Flags,TargetFrameName,PostData,Headers)

#define IWebBrowserApp_Refresh(This)	\
    (This)->lpVtbl -> Refresh(This)

#define IWebBrowserApp_Refresh2(This,Level)	\
    (This)->lpVtbl -> Refresh2(This,Level)

#define IWebBrowserApp_Stop(This)	\
    (This)->lpVtbl -> Stop(This)

#define IWebBrowserApp_get_Application(This,ppDisp)	\
    (This)->lpVtbl -> get_Application(This,ppDisp)

#define IWebBrowserApp_get_Parent(This,ppDisp)	\
    (This)->lpVtbl -> get_Parent(This,ppDisp)

#define IWebBrowserApp_get_Container(This,ppDisp)	\
    (This)->lpVtbl -> get_Container(This,ppDisp)

#define IWebBrowserApp_get_Document(This,ppDisp)	\
    (This)->lpVtbl -> get_Document(This,ppDisp)

#define IWebBrowserApp_get_TopLevelContainer(This,pBool)	\
    (This)->lpVtbl -> get_TopLevelContainer(This,pBool)

#define IWebBrowserApp_get_Type(This,Type)	\
    (This)->lpVtbl -> get_Type(This,Type)

#define IWebBrowserApp_get_Left(This,pl)	\
    (This)->lpVtbl -> get_Left(This,pl)

#define IWebBrowserApp_put_Left(This,Left)	\
    (This)->lpVtbl -> put_Left(This,Left)

#define IWebBrowserApp_get_Top(This,pl)	\
    (This)->lpVtbl -> get_Top(This,pl)

#define IWebBrowserApp_put_Top(This,Top)	\
    (This)->lpVtbl -> put_Top(This,Top)

#define IWebBrowserApp_get_Width(This,pl)	\
    (This)->lpVtbl -> get_Width(This,pl)

#define IWebBrowserApp_put_Width(This,Width)	\
    (This)->lpVtbl -> put_Width(This,Width)

#define IWebBrowserApp_get_Height(This,pl)	\
    (This)->lpVtbl -> get_Height(This,pl)

#define IWebBrowserApp_put_Height(This,Height)	\
    (This)->lpVtbl -> put_Height(This,Height)

#define IWebBrowserApp_get_LocationName(This,LocationName)	\
    (This)->lpVtbl -> get_LocationName(This,LocationName)

#define IWebBrowserApp_get_LocationURL(This,LocationURL)	\
    (This)->lpVtbl -> get_LocationURL(This,LocationURL)

#define IWebBrowserApp_get_Busy(This,pBool)	\
    (This)->lpVtbl -> get_Busy(This,pBool)


#define IWebBrowserApp_Quit(This)	\
    (This)->lpVtbl -> Quit(This)

#define IWebBrowserApp_ClientToWindow(This,pcx,pcy)	\
    (This)->lpVtbl -> ClientToWindow(This,pcx,pcy)

#define IWebBrowserApp_PutProperty(This,Property,vtValue)	\
    (This)->lpVtbl -> PutProperty(This,Property,vtValue)

#define IWebBrowserApp_GetProperty(This,Property,pvtValue)	\
    (This)->lpVtbl -> GetProperty(This,Property,pvtValue)

#define IWebBrowserApp_get_Name(This,Name)	\
    (This)->lpVtbl -> get_Name(This,Name)

#define IWebBrowserApp_get_HWND(This,pHWND)	\
    (This)->lpVtbl -> get_HWND(This,pHWND)

#define IWebBrowserApp_get_FullName(This,FullName)	\
    (This)->lpVtbl -> get_FullName(This,FullName)

#define IWebBrowserApp_get_Path(This,Path)	\
    (This)->lpVtbl -> get_Path(This,Path)

#define IWebBrowserApp_get_Visible(This,pBool)	\
    (This)->lpVtbl -> get_Visible(This,pBool)

#define IWebBrowserApp_put_Visible(This,Value)	\
    (This)->lpVtbl -> put_Visible(This,Value)

#define IWebBrowserApp_get_StatusBar(This,pBool)	\
    (This)->lpVtbl -> get_StatusBar(This,pBool)

#define IWebBrowserApp_put_StatusBar(This,Value)	\
    (This)->lpVtbl -> put_StatusBar(This,Value)

#define IWebBrowserApp_get_StatusText(This,StatusText)	\
    (This)->lpVtbl -> get_StatusText(This,StatusText)

#define IWebBrowserApp_put_StatusText(This,StatusText)	\
    (This)->lpVtbl -> put_StatusText(This,StatusText)

#define IWebBrowserApp_get_ToolBar(This,Value)	\
    (This)->lpVtbl -> get_ToolBar(This,Value)

#define IWebBrowserApp_put_ToolBar(This,Value)	\
    (This)->lpVtbl -> put_ToolBar(This,Value)

#define IWebBrowserApp_get_MenuBar(This,Value)	\
    (This)->lpVtbl -> get_MenuBar(This,Value)

#define IWebBrowserApp_put_MenuBar(This,Value)	\
    (This)->lpVtbl -> put_MenuBar(This,Value)

#define IWebBrowserApp_get_FullScreen(This,pbFullScreen)	\
    (This)->lpVtbl -> get_FullScreen(This,pbFullScreen)

#define IWebBrowserApp_put_FullScreen(This,bFullScreen)	\
    (This)->lpVtbl -> put_FullScreen(This,bFullScreen)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IWebBrowserApp_Quit_Proxy( 
    IWebBrowserApp __RPC_FAR * This);


void __RPC_STUB IWebBrowserApp_Quit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IWebBrowserApp_ClientToWindow_Proxy( 
    IWebBrowserApp __RPC_FAR * This,
    /* [out][in] */ int __RPC_FAR *pcx,
    /* [out][in] */ int __RPC_FAR *pcy);


void __RPC_STUB IWebBrowserApp_ClientToWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IWebBrowserApp_PutProperty_Proxy( 
    IWebBrowserApp __RPC_FAR * This,
    /* [in] */ BSTR Property,
    /* [in] */ VARIANT vtValue);


void __RPC_STUB IWebBrowserApp_PutProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IWebBrowserApp_GetProperty_Proxy( 
    IWebBrowserApp __RPC_FAR * This,
    /* [in] */ BSTR Property,
    /* [retval][out] */ VARIANT __RPC_FAR *pvtValue);


void __RPC_STUB IWebBrowserApp_GetProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWebBrowserApp_get_Name_Proxy( 
    IWebBrowserApp __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *Name);


void __RPC_STUB IWebBrowserApp_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWebBrowserApp_get_HWND_Proxy( 
    IWebBrowserApp __RPC_FAR * This,
    /* [retval][out] */ SHANDLE_PTR __RPC_FAR *pHWND);


void __RPC_STUB IWebBrowserApp_get_HWND_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWebBrowserApp_get_FullName_Proxy( 
    IWebBrowserApp __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *FullName);


void __RPC_STUB IWebBrowserApp_get_FullName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWebBrowserApp_get_Path_Proxy( 
    IWebBrowserApp __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *Path);


void __RPC_STUB IWebBrowserApp_get_Path_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWebBrowserApp_get_Visible_Proxy( 
    IWebBrowserApp __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pBool);


void __RPC_STUB IWebBrowserApp_get_Visible_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IWebBrowserApp_put_Visible_Proxy( 
    IWebBrowserApp __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL Value);


void __RPC_STUB IWebBrowserApp_put_Visible_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWebBrowserApp_get_StatusBar_Proxy( 
    IWebBrowserApp __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pBool);


void __RPC_STUB IWebBrowserApp_get_StatusBar_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IWebBrowserApp_put_StatusBar_Proxy( 
    IWebBrowserApp __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL Value);


void __RPC_STUB IWebBrowserApp_put_StatusBar_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWebBrowserApp_get_StatusText_Proxy( 
    IWebBrowserApp __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *StatusText);


void __RPC_STUB IWebBrowserApp_get_StatusText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IWebBrowserApp_put_StatusText_Proxy( 
    IWebBrowserApp __RPC_FAR * This,
    /* [in] */ BSTR StatusText);


void __RPC_STUB IWebBrowserApp_put_StatusText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWebBrowserApp_get_ToolBar_Proxy( 
    IWebBrowserApp __RPC_FAR * This,
    /* [retval][out] */ int __RPC_FAR *Value);


void __RPC_STUB IWebBrowserApp_get_ToolBar_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IWebBrowserApp_put_ToolBar_Proxy( 
    IWebBrowserApp __RPC_FAR * This,
    /* [in] */ int Value);


void __RPC_STUB IWebBrowserApp_put_ToolBar_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWebBrowserApp_get_MenuBar_Proxy( 
    IWebBrowserApp __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *Value);


void __RPC_STUB IWebBrowserApp_get_MenuBar_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IWebBrowserApp_put_MenuBar_Proxy( 
    IWebBrowserApp __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL Value);


void __RPC_STUB IWebBrowserApp_put_MenuBar_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWebBrowserApp_get_FullScreen_Proxy( 
    IWebBrowserApp __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbFullScreen);


void __RPC_STUB IWebBrowserApp_get_FullScreen_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IWebBrowserApp_put_FullScreen_Proxy( 
    IWebBrowserApp __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL bFullScreen);


void __RPC_STUB IWebBrowserApp_put_FullScreen_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWebBrowserApp_INTERFACE_DEFINED__ */


#ifndef __IWebBrowser2_INTERFACE_DEFINED__
#define __IWebBrowser2_INTERFACE_DEFINED__

/* interface IWebBrowser2 */
/* [object][dual][oleautomation][hidden][helpcontext][helpstring][uuid] */ 


EXTERN_C const IID IID_IWebBrowser2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D30C1661-CDAF-11d0-8A3E-00C04FC9E26E")
    IWebBrowser2 : public IWebBrowserApp
    {
    public:
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Navigate2( 
            /* [in] */ VARIANT __RPC_FAR *URL,
            /* [optional][in] */ VARIANT __RPC_FAR *Flags,
            /* [optional][in] */ VARIANT __RPC_FAR *TargetFrameName,
            /* [optional][in] */ VARIANT __RPC_FAR *PostData,
            /* [optional][in] */ VARIANT __RPC_FAR *Headers) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE QueryStatusWB( 
            /* [in] */ OLECMDID cmdID,
            /* [retval][out] */ OLECMDF __RPC_FAR *pcmdf) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE ExecWB( 
            /* [in] */ OLECMDID cmdID,
            /* [in] */ OLECMDEXECOPT cmdexecopt,
            /* [optional][in] */ VARIANT __RPC_FAR *pvaIn,
            /* [optional][in][out] */ VARIANT __RPC_FAR *pvaOut) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE ShowBrowserBar( 
            /* [in] */ VARIANT __RPC_FAR *pvaClsid,
            /* [optional][in] */ VARIANT __RPC_FAR *pvarShow,
            /* [optional][in] */ VARIANT __RPC_FAR *pvarSize) = 0;
        
        virtual /* [bindable][propget][id] */ HRESULT STDMETHODCALLTYPE get_ReadyState( 
            /* [out][retval] */ READYSTATE __RPC_FAR *plReadyState) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Offline( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbOffline) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Offline( 
            /* [in] */ VARIANT_BOOL bOffline) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Silent( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbSilent) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Silent( 
            /* [in] */ VARIANT_BOOL bSilent) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_RegisterAsBrowser( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbRegister) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_RegisterAsBrowser( 
            /* [in] */ VARIANT_BOOL bRegister) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_RegisterAsDropTarget( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbRegister) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_RegisterAsDropTarget( 
            /* [in] */ VARIANT_BOOL bRegister) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_TheaterMode( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbRegister) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_TheaterMode( 
            /* [in] */ VARIANT_BOOL bRegister) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_AddressBar( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *Value) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_AddressBar( 
            /* [in] */ VARIANT_BOOL Value) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Resizable( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *Value) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Resizable( 
            /* [in] */ VARIANT_BOOL Value) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWebBrowser2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWebBrowser2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWebBrowser2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GoBack )( 
            IWebBrowser2 __RPC_FAR * This);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GoForward )( 
            IWebBrowser2 __RPC_FAR * This);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GoHome )( 
            IWebBrowser2 __RPC_FAR * This);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GoSearch )( 
            IWebBrowser2 __RPC_FAR * This);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Navigate )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [in] */ BSTR URL,
            /* [optional][in] */ VARIANT __RPC_FAR *Flags,
            /* [optional][in] */ VARIANT __RPC_FAR *TargetFrameName,
            /* [optional][in] */ VARIANT __RPC_FAR *PostData,
            /* [optional][in] */ VARIANT __RPC_FAR *Headers);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Refresh )( 
            IWebBrowser2 __RPC_FAR * This);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Refresh2 )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [optional][in] */ VARIANT __RPC_FAR *Level);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Stop )( 
            IWebBrowser2 __RPC_FAR * This);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Application )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDisp);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Parent )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDisp);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Container )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDisp);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Document )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDisp);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_TopLevelContainer )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pBool);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Type )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *Type);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Left )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pl);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Left )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [in] */ long Left);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Top )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pl);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Top )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [in] */ long Top);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Width )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pl);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Width )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [in] */ long Width);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Height )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pl);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Height )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [in] */ long Height);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_LocationName )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *LocationName);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_LocationURL )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *LocationURL);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Busy )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pBool);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Quit )( 
            IWebBrowser2 __RPC_FAR * This);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ClientToWindow )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [out][in] */ int __RPC_FAR *pcx,
            /* [out][in] */ int __RPC_FAR *pcy);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PutProperty )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [in] */ BSTR Property,
            /* [in] */ VARIANT vtValue);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProperty )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [in] */ BSTR Property,
            /* [retval][out] */ VARIANT __RPC_FAR *pvtValue);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *Name);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_HWND )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [retval][out] */ SHANDLE_PTR __RPC_FAR *pHWND);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_FullName )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *FullName);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Path )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *Path);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Visible )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pBool);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Visible )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL Value);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StatusBar )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pBool);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_StatusBar )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL Value);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StatusText )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *StatusText);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_StatusText )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [in] */ BSTR StatusText);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ToolBar )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [retval][out] */ int __RPC_FAR *Value);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ToolBar )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [in] */ int Value);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_MenuBar )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *Value);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_MenuBar )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL Value);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_FullScreen )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbFullScreen);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_FullScreen )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL bFullScreen);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Navigate2 )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *URL,
            /* [optional][in] */ VARIANT __RPC_FAR *Flags,
            /* [optional][in] */ VARIANT __RPC_FAR *TargetFrameName,
            /* [optional][in] */ VARIANT __RPC_FAR *PostData,
            /* [optional][in] */ VARIANT __RPC_FAR *Headers);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryStatusWB )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [in] */ OLECMDID cmdID,
            /* [retval][out] */ OLECMDF __RPC_FAR *pcmdf);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ExecWB )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [in] */ OLECMDID cmdID,
            /* [in] */ OLECMDEXECOPT cmdexecopt,
            /* [optional][in] */ VARIANT __RPC_FAR *pvaIn,
            /* [optional][in][out] */ VARIANT __RPC_FAR *pvaOut);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ShowBrowserBar )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *pvaClsid,
            /* [optional][in] */ VARIANT __RPC_FAR *pvarShow,
            /* [optional][in] */ VARIANT __RPC_FAR *pvarSize);
        
        /* [bindable][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ReadyState )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [out][retval] */ READYSTATE __RPC_FAR *plReadyState);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Offline )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbOffline);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Offline )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL bOffline);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Silent )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbSilent);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Silent )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL bSilent);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_RegisterAsBrowser )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbRegister);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_RegisterAsBrowser )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL bRegister);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_RegisterAsDropTarget )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbRegister);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_RegisterAsDropTarget )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL bRegister);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_TheaterMode )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbRegister);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_TheaterMode )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL bRegister);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_AddressBar )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *Value);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_AddressBar )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL Value);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Resizable )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *Value);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Resizable )( 
            IWebBrowser2 __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL Value);
        
        END_INTERFACE
    } IWebBrowser2Vtbl;

    interface IWebBrowser2
    {
        CONST_VTBL struct IWebBrowser2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWebBrowser2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWebBrowser2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWebBrowser2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWebBrowser2_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWebBrowser2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWebBrowser2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWebBrowser2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWebBrowser2_GoBack(This)	\
    (This)->lpVtbl -> GoBack(This)

#define IWebBrowser2_GoForward(This)	\
    (This)->lpVtbl -> GoForward(This)

#define IWebBrowser2_GoHome(This)	\
    (This)->lpVtbl -> GoHome(This)

#define IWebBrowser2_GoSearch(This)	\
    (This)->lpVtbl -> GoSearch(This)

#define IWebBrowser2_Navigate(This,URL,Flags,TargetFrameName,PostData,Headers)	\
    (This)->lpVtbl -> Navigate(This,URL,Flags,TargetFrameName,PostData,Headers)

#define IWebBrowser2_Refresh(This)	\
    (This)->lpVtbl -> Refresh(This)

#define IWebBrowser2_Refresh2(This,Level)	\
    (This)->lpVtbl -> Refresh2(This,Level)

#define IWebBrowser2_Stop(This)	\
    (This)->lpVtbl -> Stop(This)

#define IWebBrowser2_get_Application(This,ppDisp)	\
    (This)->lpVtbl -> get_Application(This,ppDisp)

#define IWebBrowser2_get_Parent(This,ppDisp)	\
    (This)->lpVtbl -> get_Parent(This,ppDisp)

#define IWebBrowser2_get_Container(This,ppDisp)	\
    (This)->lpVtbl -> get_Container(This,ppDisp)

#define IWebBrowser2_get_Document(This,ppDisp)	\
    (This)->lpVtbl -> get_Document(This,ppDisp)

#define IWebBrowser2_get_TopLevelContainer(This,pBool)	\
    (This)->lpVtbl -> get_TopLevelContainer(This,pBool)

#define IWebBrowser2_get_Type(This,Type)	\
    (This)->lpVtbl -> get_Type(This,Type)

#define IWebBrowser2_get_Left(This,pl)	\
    (This)->lpVtbl -> get_Left(This,pl)

#define IWebBrowser2_put_Left(This,Left)	\
    (This)->lpVtbl -> put_Left(This,Left)

#define IWebBrowser2_get_Top(This,pl)	\
    (This)->lpVtbl -> get_Top(This,pl)

#define IWebBrowser2_put_Top(This,Top)	\
    (This)->lpVtbl -> put_Top(This,Top)

#define IWebBrowser2_get_Width(This,pl)	\
    (This)->lpVtbl -> get_Width(This,pl)

#define IWebBrowser2_put_Width(This,Width)	\
    (This)->lpVtbl -> put_Width(This,Width)

#define IWebBrowser2_get_Height(This,pl)	\
    (This)->lpVtbl -> get_Height(This,pl)

#define IWebBrowser2_put_Height(This,Height)	\
    (This)->lpVtbl -> put_Height(This,Height)

#define IWebBrowser2_get_LocationName(This,LocationName)	\
    (This)->lpVtbl -> get_LocationName(This,LocationName)

#define IWebBrowser2_get_LocationURL(This,LocationURL)	\
    (This)->lpVtbl -> get_LocationURL(This,LocationURL)

#define IWebBrowser2_get_Busy(This,pBool)	\
    (This)->lpVtbl -> get_Busy(This,pBool)


#define IWebBrowser2_Quit(This)	\
    (This)->lpVtbl -> Quit(This)

#define IWebBrowser2_ClientToWindow(This,pcx,pcy)	\
    (This)->lpVtbl -> ClientToWindow(This,pcx,pcy)

#define IWebBrowser2_PutProperty(This,Property,vtValue)	\
    (This)->lpVtbl -> PutProperty(This,Property,vtValue)

#define IWebBrowser2_GetProperty(This,Property,pvtValue)	\
    (This)->lpVtbl -> GetProperty(This,Property,pvtValue)

#define IWebBrowser2_get_Name(This,Name)	\
    (This)->lpVtbl -> get_Name(This,Name)

#define IWebBrowser2_get_HWND(This,pHWND)	\
    (This)->lpVtbl -> get_HWND(This,pHWND)

#define IWebBrowser2_get_FullName(This,FullName)	\
    (This)->lpVtbl -> get_FullName(This,FullName)

#define IWebBrowser2_get_Path(This,Path)	\
    (This)->lpVtbl -> get_Path(This,Path)

#define IWebBrowser2_get_Visible(This,pBool)	\
    (This)->lpVtbl -> get_Visible(This,pBool)

#define IWebBrowser2_put_Visible(This,Value)	\
    (This)->lpVtbl -> put_Visible(This,Value)

#define IWebBrowser2_get_StatusBar(This,pBool)	\
    (This)->lpVtbl -> get_StatusBar(This,pBool)

#define IWebBrowser2_put_StatusBar(This,Value)	\
    (This)->lpVtbl -> put_StatusBar(This,Value)

#define IWebBrowser2_get_StatusText(This,StatusText)	\
    (This)->lpVtbl -> get_StatusText(This,StatusText)

#define IWebBrowser2_put_StatusText(This,StatusText)	\
    (This)->lpVtbl -> put_StatusText(This,StatusText)

#define IWebBrowser2_get_ToolBar(This,Value)	\
    (This)->lpVtbl -> get_ToolBar(This,Value)

#define IWebBrowser2_put_ToolBar(This,Value)	\
    (This)->lpVtbl -> put_ToolBar(This,Value)

#define IWebBrowser2_get_MenuBar(This,Value)	\
    (This)->lpVtbl -> get_MenuBar(This,Value)

#define IWebBrowser2_put_MenuBar(This,Value)	\
    (This)->lpVtbl -> put_MenuBar(This,Value)

#define IWebBrowser2_get_FullScreen(This,pbFullScreen)	\
    (This)->lpVtbl -> get_FullScreen(This,pbFullScreen)

#define IWebBrowser2_put_FullScreen(This,bFullScreen)	\
    (This)->lpVtbl -> put_FullScreen(This,bFullScreen)


#define IWebBrowser2_Navigate2(This,URL,Flags,TargetFrameName,PostData,Headers)	\
    (This)->lpVtbl -> Navigate2(This,URL,Flags,TargetFrameName,PostData,Headers)

#define IWebBrowser2_QueryStatusWB(This,cmdID,pcmdf)	\
    (This)->lpVtbl -> QueryStatusWB(This,cmdID,pcmdf)

#define IWebBrowser2_ExecWB(This,cmdID,cmdexecopt,pvaIn,pvaOut)	\
    (This)->lpVtbl -> ExecWB(This,cmdID,cmdexecopt,pvaIn,pvaOut)

#define IWebBrowser2_ShowBrowserBar(This,pvaClsid,pvarShow,pvarSize)	\
    (This)->lpVtbl -> ShowBrowserBar(This,pvaClsid,pvarShow,pvarSize)

#define IWebBrowser2_get_ReadyState(This,plReadyState)	\
    (This)->lpVtbl -> get_ReadyState(This,plReadyState)

#define IWebBrowser2_get_Offline(This,pbOffline)	\
    (This)->lpVtbl -> get_Offline(This,pbOffline)

#define IWebBrowser2_put_Offline(This,bOffline)	\
    (This)->lpVtbl -> put_Offline(This,bOffline)

#define IWebBrowser2_get_Silent(This,pbSilent)	\
    (This)->lpVtbl -> get_Silent(This,pbSilent)

#define IWebBrowser2_put_Silent(This,bSilent)	\
    (This)->lpVtbl -> put_Silent(This,bSilent)

#define IWebBrowser2_get_RegisterAsBrowser(This,pbRegister)	\
    (This)->lpVtbl -> get_RegisterAsBrowser(This,pbRegister)

#define IWebBrowser2_put_RegisterAsBrowser(This,bRegister)	\
    (This)->lpVtbl -> put_RegisterAsBrowser(This,bRegister)

#define IWebBrowser2_get_RegisterAsDropTarget(This,pbRegister)	\
    (This)->lpVtbl -> get_RegisterAsDropTarget(This,pbRegister)

#define IWebBrowser2_put_RegisterAsDropTarget(This,bRegister)	\
    (This)->lpVtbl -> put_RegisterAsDropTarget(This,bRegister)

#define IWebBrowser2_get_TheaterMode(This,pbRegister)	\
    (This)->lpVtbl -> get_TheaterMode(This,pbRegister)

#define IWebBrowser2_put_TheaterMode(This,bRegister)	\
    (This)->lpVtbl -> put_TheaterMode(This,bRegister)

#define IWebBrowser2_get_AddressBar(This,Value)	\
    (This)->lpVtbl -> get_AddressBar(This,Value)

#define IWebBrowser2_put_AddressBar(This,Value)	\
    (This)->lpVtbl -> put_AddressBar(This,Value)

#define IWebBrowser2_get_Resizable(This,Value)	\
    (This)->lpVtbl -> get_Resizable(This,Value)

#define IWebBrowser2_put_Resizable(This,Value)	\
    (This)->lpVtbl -> put_Resizable(This,Value)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IWebBrowser2_Navigate2_Proxy( 
    IWebBrowser2 __RPC_FAR * This,
    /* [in] */ VARIANT __RPC_FAR *URL,
    /* [optional][in] */ VARIANT __RPC_FAR *Flags,
    /* [optional][in] */ VARIANT __RPC_FAR *TargetFrameName,
    /* [optional][in] */ VARIANT __RPC_FAR *PostData,
    /* [optional][in] */ VARIANT __RPC_FAR *Headers);


void __RPC_STUB IWebBrowser2_Navigate2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IWebBrowser2_QueryStatusWB_Proxy( 
    IWebBrowser2 __RPC_FAR * This,
    /* [in] */ OLECMDID cmdID,
    /* [retval][out] */ OLECMDF __RPC_FAR *pcmdf);


void __RPC_STUB IWebBrowser2_QueryStatusWB_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IWebBrowser2_ExecWB_Proxy( 
    IWebBrowser2 __RPC_FAR * This,
    /* [in] */ OLECMDID cmdID,
    /* [in] */ OLECMDEXECOPT cmdexecopt,
    /* [optional][in] */ VARIANT __RPC_FAR *pvaIn,
    /* [optional][in][out] */ VARIANT __RPC_FAR *pvaOut);


void __RPC_STUB IWebBrowser2_ExecWB_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IWebBrowser2_ShowBrowserBar_Proxy( 
    IWebBrowser2 __RPC_FAR * This,
    /* [in] */ VARIANT __RPC_FAR *pvaClsid,
    /* [optional][in] */ VARIANT __RPC_FAR *pvarShow,
    /* [optional][in] */ VARIANT __RPC_FAR *pvarSize);


void __RPC_STUB IWebBrowser2_ShowBrowserBar_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][propget][id] */ HRESULT STDMETHODCALLTYPE IWebBrowser2_get_ReadyState_Proxy( 
    IWebBrowser2 __RPC_FAR * This,
    /* [out][retval] */ READYSTATE __RPC_FAR *plReadyState);


void __RPC_STUB IWebBrowser2_get_ReadyState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWebBrowser2_get_Offline_Proxy( 
    IWebBrowser2 __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbOffline);


void __RPC_STUB IWebBrowser2_get_Offline_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IWebBrowser2_put_Offline_Proxy( 
    IWebBrowser2 __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL bOffline);


void __RPC_STUB IWebBrowser2_put_Offline_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWebBrowser2_get_Silent_Proxy( 
    IWebBrowser2 __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbSilent);


void __RPC_STUB IWebBrowser2_get_Silent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IWebBrowser2_put_Silent_Proxy( 
    IWebBrowser2 __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL bSilent);


void __RPC_STUB IWebBrowser2_put_Silent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWebBrowser2_get_RegisterAsBrowser_Proxy( 
    IWebBrowser2 __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbRegister);


void __RPC_STUB IWebBrowser2_get_RegisterAsBrowser_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IWebBrowser2_put_RegisterAsBrowser_Proxy( 
    IWebBrowser2 __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL bRegister);


void __RPC_STUB IWebBrowser2_put_RegisterAsBrowser_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWebBrowser2_get_RegisterAsDropTarget_Proxy( 
    IWebBrowser2 __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbRegister);


void __RPC_STUB IWebBrowser2_get_RegisterAsDropTarget_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IWebBrowser2_put_RegisterAsDropTarget_Proxy( 
    IWebBrowser2 __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL bRegister);


void __RPC_STUB IWebBrowser2_put_RegisterAsDropTarget_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWebBrowser2_get_TheaterMode_Proxy( 
    IWebBrowser2 __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbRegister);


void __RPC_STUB IWebBrowser2_get_TheaterMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IWebBrowser2_put_TheaterMode_Proxy( 
    IWebBrowser2 __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL bRegister);


void __RPC_STUB IWebBrowser2_put_TheaterMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWebBrowser2_get_AddressBar_Proxy( 
    IWebBrowser2 __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *Value);


void __RPC_STUB IWebBrowser2_get_AddressBar_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IWebBrowser2_put_AddressBar_Proxy( 
    IWebBrowser2 __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL Value);


void __RPC_STUB IWebBrowser2_put_AddressBar_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWebBrowser2_get_Resizable_Proxy( 
    IWebBrowser2 __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *Value);


void __RPC_STUB IWebBrowser2_get_Resizable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IWebBrowser2_put_Resizable_Proxy( 
    IWebBrowser2 __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL Value);


void __RPC_STUB IWebBrowser2_put_Resizable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWebBrowser2_INTERFACE_DEFINED__ */


#ifndef __DWebBrowserEvents2_DISPINTERFACE_DEFINED__
#define __DWebBrowserEvents2_DISPINTERFACE_DEFINED__

/* dispinterface DWebBrowserEvents2 */
/* [hidden][helpstring][uuid] */ 


EXTERN_C const IID DIID_DWebBrowserEvents2;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("34A715A0-6587-11D0-924A-0020AFC7AC4D")
    DWebBrowserEvents2 : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct DWebBrowserEvents2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            DWebBrowserEvents2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            DWebBrowserEvents2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            DWebBrowserEvents2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            DWebBrowserEvents2 __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            DWebBrowserEvents2 __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            DWebBrowserEvents2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            DWebBrowserEvents2 __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        END_INTERFACE
    } DWebBrowserEvents2Vtbl;

    interface DWebBrowserEvents2
    {
        CONST_VTBL struct DWebBrowserEvents2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define DWebBrowserEvents2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define DWebBrowserEvents2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define DWebBrowserEvents2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define DWebBrowserEvents2_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define DWebBrowserEvents2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define DWebBrowserEvents2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define DWebBrowserEvents2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* __DWebBrowserEvents2_DISPINTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_WebBrowser_V1;

#ifdef __cplusplus

class DECLSPEC_UUID("EAB22AC3-30C1-11CF-A7EB-0000C05BAE0B")
WebBrowser_V1;
#endif

EXTERN_C const CLSID CLSID_WebBrowser;

#ifdef __cplusplus

class DECLSPEC_UUID("8856F961-340A-11D0-A96B-00C04FD705A2")
WebBrowser;
#endif

EXTERN_C const CLSID CLSID_InternetExplorer;

#ifdef __cplusplus

class DECLSPEC_UUID("0002DF01-0000-0000-C000-000000000046")
InternetExplorer;
#endif

EXTERN_C const CLSID CLSID_ShellBrowserWindow;

#ifdef __cplusplus

class DECLSPEC_UUID("c08afd90-f2a1-11d1-8455-00a0c91f3880")
ShellBrowserWindow;
#endif

#ifndef __DShellWindowsEvents_DISPINTERFACE_DEFINED__
#define __DShellWindowsEvents_DISPINTERFACE_DEFINED__

/* dispinterface DShellWindowsEvents */
/* [helpstring][uuid] */ 


EXTERN_C const IID DIID_DShellWindowsEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("fe4106e0-399a-11d0-a48c-00a0c90a8f39")
    DShellWindowsEvents : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct DShellWindowsEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            DShellWindowsEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            DShellWindowsEvents __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            DShellWindowsEvents __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            DShellWindowsEvents __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            DShellWindowsEvents __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            DShellWindowsEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            DShellWindowsEvents __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        END_INTERFACE
    } DShellWindowsEventsVtbl;

    interface DShellWindowsEvents
    {
        CONST_VTBL struct DShellWindowsEventsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define DShellWindowsEvents_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define DShellWindowsEvents_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define DShellWindowsEvents_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define DShellWindowsEvents_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define DShellWindowsEvents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define DShellWindowsEvents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define DShellWindowsEvents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* __DShellWindowsEvents_DISPINTERFACE_DEFINED__ */


#ifndef __IShellWindows_INTERFACE_DEFINED__
#define __IShellWindows_INTERFACE_DEFINED__

/* interface IShellWindows */
/* [object][dual][oleautomation][helpstring][uuid] */ 


EXTERN_C const IID IID_IShellWindows;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("85CB6900-4D95-11CF-960C-0080C7F4EE85")
    IShellWindows : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long __RPC_FAR *Count) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Item( 
            /* [optional][in] */ VARIANT index,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *Folder) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE _NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunk) = 0;
        
        virtual /* [hidden][helpstring] */ HRESULT STDMETHODCALLTYPE Register( 
            /* [in] */ IDispatch __RPC_FAR *pid,
            /* [in] */ long hwnd,
            /* [in] */ int swClass,
            /* [out] */ long __RPC_FAR *plCookie) = 0;
        
        virtual /* [hidden][helpstring] */ HRESULT STDMETHODCALLTYPE RegisterPending( 
            /* [in] */ long lThreadId,
            /* [in] */ VARIANT __RPC_FAR *pvarloc,
            /* [in] */ VARIANT __RPC_FAR *pvarlocRoot,
            /* [in] */ int swClass,
            /* [out] */ long __RPC_FAR *plCookie) = 0;
        
        virtual /* [hidden][helpstring] */ HRESULT STDMETHODCALLTYPE Revoke( 
            /* [in] */ long lCookie) = 0;
        
        virtual /* [hidden][helpstring] */ HRESULT STDMETHODCALLTYPE OnNavigate( 
            /* [in] */ long lCookie,
            /* [in] */ VARIANT __RPC_FAR *pvarLoc) = 0;
        
        virtual /* [hidden][helpstring] */ HRESULT STDMETHODCALLTYPE OnActivated( 
            /* [in] */ long lCookie,
            /* [in] */ VARIANT_BOOL fActive) = 0;
        
        virtual /* [hidden][helpstring] */ HRESULT STDMETHODCALLTYPE FindWindowSW( 
            /* [in] */ VARIANT __RPC_FAR *pvarLoc,
            /* [in] */ VARIANT __RPC_FAR *pvarLocRoot,
            /* [in] */ int swClass,
            /* [out] */ long __RPC_FAR *phwnd,
            /* [in] */ int swfwOptions,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppdispOut) = 0;
        
        virtual /* [hidden][helpstring] */ HRESULT STDMETHODCALLTYPE OnCreated( 
            /* [in] */ long lCookie,
            /* [in] */ IUnknown __RPC_FAR *punk) = 0;
        
        virtual /* [hidden][helpstring] */ HRESULT STDMETHODCALLTYPE ProcessAttachDetach( 
            /* [in] */ VARIANT_BOOL fAttach) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IShellWindowsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IShellWindows __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IShellWindows __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IShellWindows __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IShellWindows __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IShellWindows __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IShellWindows __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IShellWindows __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            IShellWindows __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *Count);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Item )( 
            IShellWindows __RPC_FAR * This,
            /* [optional][in] */ VARIANT index,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *Folder);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *_NewEnum )( 
            IShellWindows __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunk);
        
        /* [hidden][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Register )( 
            IShellWindows __RPC_FAR * This,
            /* [in] */ IDispatch __RPC_FAR *pid,
            /* [in] */ long hwnd,
            /* [in] */ int swClass,
            /* [out] */ long __RPC_FAR *plCookie);
        
        /* [hidden][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RegisterPending )( 
            IShellWindows __RPC_FAR * This,
            /* [in] */ long lThreadId,
            /* [in] */ VARIANT __RPC_FAR *pvarloc,
            /* [in] */ VARIANT __RPC_FAR *pvarlocRoot,
            /* [in] */ int swClass,
            /* [out] */ long __RPC_FAR *plCookie);
        
        /* [hidden][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Revoke )( 
            IShellWindows __RPC_FAR * This,
            /* [in] */ long lCookie);
        
        /* [hidden][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnNavigate )( 
            IShellWindows __RPC_FAR * This,
            /* [in] */ long lCookie,
            /* [in] */ VARIANT __RPC_FAR *pvarLoc);
        
        /* [hidden][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnActivated )( 
            IShellWindows __RPC_FAR * This,
            /* [in] */ long lCookie,
            /* [in] */ VARIANT_BOOL fActive);
        
        /* [hidden][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindWindowSW )( 
            IShellWindows __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *pvarLoc,
            /* [in] */ VARIANT __RPC_FAR *pvarLocRoot,
            /* [in] */ int swClass,
            /* [out] */ long __RPC_FAR *phwnd,
            /* [in] */ int swfwOptions,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppdispOut);
        
        /* [hidden][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnCreated )( 
            IShellWindows __RPC_FAR * This,
            /* [in] */ long lCookie,
            /* [in] */ IUnknown __RPC_FAR *punk);
        
        /* [hidden][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ProcessAttachDetach )( 
            IShellWindows __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL fAttach);
        
        END_INTERFACE
    } IShellWindowsVtbl;

    interface IShellWindows
    {
        CONST_VTBL struct IShellWindowsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IShellWindows_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IShellWindows_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IShellWindows_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IShellWindows_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IShellWindows_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IShellWindows_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IShellWindows_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IShellWindows_get_Count(This,Count)	\
    (This)->lpVtbl -> get_Count(This,Count)

#define IShellWindows_Item(This,index,Folder)	\
    (This)->lpVtbl -> Item(This,index,Folder)

#define IShellWindows__NewEnum(This,ppunk)	\
    (This)->lpVtbl -> _NewEnum(This,ppunk)

#define IShellWindows_Register(This,pid,hwnd,swClass,plCookie)	\
    (This)->lpVtbl -> Register(This,pid,hwnd,swClass,plCookie)

#define IShellWindows_RegisterPending(This,lThreadId,pvarloc,pvarlocRoot,swClass,plCookie)	\
    (This)->lpVtbl -> RegisterPending(This,lThreadId,pvarloc,pvarlocRoot,swClass,plCookie)

#define IShellWindows_Revoke(This,lCookie)	\
    (This)->lpVtbl -> Revoke(This,lCookie)

#define IShellWindows_OnNavigate(This,lCookie,pvarLoc)	\
    (This)->lpVtbl -> OnNavigate(This,lCookie,pvarLoc)

#define IShellWindows_OnActivated(This,lCookie,fActive)	\
    (This)->lpVtbl -> OnActivated(This,lCookie,fActive)

#define IShellWindows_FindWindowSW(This,pvarLoc,pvarLocRoot,swClass,phwnd,swfwOptions,ppdispOut)	\
    (This)->lpVtbl -> FindWindowSW(This,pvarLoc,pvarLocRoot,swClass,phwnd,swfwOptions,ppdispOut)

#define IShellWindows_OnCreated(This,lCookie,punk)	\
    (This)->lpVtbl -> OnCreated(This,lCookie,punk)

#define IShellWindows_ProcessAttachDetach(This,fAttach)	\
    (This)->lpVtbl -> ProcessAttachDetach(This,fAttach)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IShellWindows_get_Count_Proxy( 
    IShellWindows __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *Count);


void __RPC_STUB IShellWindows_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IShellWindows_Item_Proxy( 
    IShellWindows __RPC_FAR * This,
    /* [optional][in] */ VARIANT index,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *Folder);


void __RPC_STUB IShellWindows_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IShellWindows__NewEnum_Proxy( 
    IShellWindows __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunk);


void __RPC_STUB IShellWindows__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][helpstring] */ HRESULT STDMETHODCALLTYPE IShellWindows_Register_Proxy( 
    IShellWindows __RPC_FAR * This,
    /* [in] */ IDispatch __RPC_FAR *pid,
    /* [in] */ long hwnd,
    /* [in] */ int swClass,
    /* [out] */ long __RPC_FAR *plCookie);


void __RPC_STUB IShellWindows_Register_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][helpstring] */ HRESULT STDMETHODCALLTYPE IShellWindows_RegisterPending_Proxy( 
    IShellWindows __RPC_FAR * This,
    /* [in] */ long lThreadId,
    /* [in] */ VARIANT __RPC_FAR *pvarloc,
    /* [in] */ VARIANT __RPC_FAR *pvarlocRoot,
    /* [in] */ int swClass,
    /* [out] */ long __RPC_FAR *plCookie);


void __RPC_STUB IShellWindows_RegisterPending_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][helpstring] */ HRESULT STDMETHODCALLTYPE IShellWindows_Revoke_Proxy( 
    IShellWindows __RPC_FAR * This,
    /* [in] */ long lCookie);


void __RPC_STUB IShellWindows_Revoke_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][helpstring] */ HRESULT STDMETHODCALLTYPE IShellWindows_OnNavigate_Proxy( 
    IShellWindows __RPC_FAR * This,
    /* [in] */ long lCookie,
    /* [in] */ VARIANT __RPC_FAR *pvarLoc);


void __RPC_STUB IShellWindows_OnNavigate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][helpstring] */ HRESULT STDMETHODCALLTYPE IShellWindows_OnActivated_Proxy( 
    IShellWindows __RPC_FAR * This,
    /* [in] */ long lCookie,
    /* [in] */ VARIANT_BOOL fActive);


void __RPC_STUB IShellWindows_OnActivated_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][helpstring] */ HRESULT STDMETHODCALLTYPE IShellWindows_FindWindowSW_Proxy( 
    IShellWindows __RPC_FAR * This,
    /* [in] */ VARIANT __RPC_FAR *pvarLoc,
    /* [in] */ VARIANT __RPC_FAR *pvarLocRoot,
    /* [in] */ int swClass,
    /* [out] */ long __RPC_FAR *phwnd,
    /* [in] */ int swfwOptions,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppdispOut);


void __RPC_STUB IShellWindows_FindWindowSW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][helpstring] */ HRESULT STDMETHODCALLTYPE IShellWindows_OnCreated_Proxy( 
    IShellWindows __RPC_FAR * This,
    /* [in] */ long lCookie,
    /* [in] */ IUnknown __RPC_FAR *punk);


void __RPC_STUB IShellWindows_OnCreated_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][helpstring] */ HRESULT STDMETHODCALLTYPE IShellWindows_ProcessAttachDetach_Proxy( 
    IShellWindows __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL fAttach);


void __RPC_STUB IShellWindows_ProcessAttachDetach_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IShellWindows_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_ShellWindows;

#ifdef __cplusplus

class DECLSPEC_UUID("9BA05972-F6A8-11CF-A442-00A0C90A8F39")
ShellWindows;
#endif

#ifndef __IShellUIHelper_INTERFACE_DEFINED__
#define __IShellUIHelper_INTERFACE_DEFINED__

/* interface IShellUIHelper */
/* [object][dual][oleautomation][helpstring][uuid] */ 


EXTERN_C const IID IID_IShellUIHelper;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("729FE2F8-1EA8-11d1-8F85-00C04FC2FBE1")
    IShellUIHelper : public IDispatch
    {
    public:
        virtual /* [id][hidden] */ HRESULT STDMETHODCALLTYPE ResetFirstBootMode( void) = 0;
        
        virtual /* [id][hidden] */ HRESULT STDMETHODCALLTYPE ResetSafeMode( void) = 0;
        
        virtual /* [id][hidden] */ HRESULT STDMETHODCALLTYPE RefreshOfflineDesktop( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE AddFavorite( 
            /* [in] */ BSTR URL,
            /* [in][optional] */ VARIANT __RPC_FAR *Title) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE AddChannel( 
            /* [in] */ BSTR URL) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE AddDesktopComponent( 
            /* [in] */ BSTR URL,
            /* [in] */ BSTR Type,
            /* [in][optional] */ VARIANT __RPC_FAR *Left,
            /* [in][optional] */ VARIANT __RPC_FAR *Top,
            /* [in][optional] */ VARIANT __RPC_FAR *Width,
            /* [in][optional] */ VARIANT __RPC_FAR *Height) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE IsSubscribed( 
            /* [in] */ BSTR URL,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pBool) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE NavigateAndFind( 
            /* [in] */ BSTR URL,
            /* [in] */ BSTR strQuery,
            /* [in] */ VARIANT __RPC_FAR *varTargetFrame) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE ImportExportFavorites( 
            /* [in] */ VARIANT_BOOL fImport,
            /* [in] */ BSTR strImpExpPath) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE AutoCompleteSaveForm( 
            /* [in][optional] */ VARIANT __RPC_FAR *Form) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE AutoScan( 
            /* [in] */ BSTR strSearch,
            /* [in] */ BSTR strFailureUrl,
            /* [in][optional] */ VARIANT __RPC_FAR *pvarTargetFrame) = 0;
        
        virtual /* [id][hidden] */ HRESULT STDMETHODCALLTYPE AutoCompleteAttach( 
            /* [in][optional] */ VARIANT __RPC_FAR *Reserved) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE ShowBrowserUI( 
            /* [in] */ BSTR bstrName,
            /* [in] */ VARIANT __RPC_FAR *pvarIn,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarOut) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IShellUIHelperVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IShellUIHelper __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IShellUIHelper __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IShellUIHelper __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IShellUIHelper __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IShellUIHelper __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IShellUIHelper __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IShellUIHelper __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][hidden] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ResetFirstBootMode )( 
            IShellUIHelper __RPC_FAR * This);
        
        /* [id][hidden] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ResetSafeMode )( 
            IShellUIHelper __RPC_FAR * This);
        
        /* [id][hidden] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RefreshOfflineDesktop )( 
            IShellUIHelper __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddFavorite )( 
            IShellUIHelper __RPC_FAR * This,
            /* [in] */ BSTR URL,
            /* [in][optional] */ VARIANT __RPC_FAR *Title);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddChannel )( 
            IShellUIHelper __RPC_FAR * This,
            /* [in] */ BSTR URL);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddDesktopComponent )( 
            IShellUIHelper __RPC_FAR * This,
            /* [in] */ BSTR URL,
            /* [in] */ BSTR Type,
            /* [in][optional] */ VARIANT __RPC_FAR *Left,
            /* [in][optional] */ VARIANT __RPC_FAR *Top,
            /* [in][optional] */ VARIANT __RPC_FAR *Width,
            /* [in][optional] */ VARIANT __RPC_FAR *Height);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsSubscribed )( 
            IShellUIHelper __RPC_FAR * This,
            /* [in] */ BSTR URL,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pBool);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NavigateAndFind )( 
            IShellUIHelper __RPC_FAR * This,
            /* [in] */ BSTR URL,
            /* [in] */ BSTR strQuery,
            /* [in] */ VARIANT __RPC_FAR *varTargetFrame);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ImportExportFavorites )( 
            IShellUIHelper __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL fImport,
            /* [in] */ BSTR strImpExpPath);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AutoCompleteSaveForm )( 
            IShellUIHelper __RPC_FAR * This,
            /* [in][optional] */ VARIANT __RPC_FAR *Form);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AutoScan )( 
            IShellUIHelper __RPC_FAR * This,
            /* [in] */ BSTR strSearch,
            /* [in] */ BSTR strFailureUrl,
            /* [in][optional] */ VARIANT __RPC_FAR *pvarTargetFrame);
        
        /* [id][hidden] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AutoCompleteAttach )( 
            IShellUIHelper __RPC_FAR * This,
            /* [in][optional] */ VARIANT __RPC_FAR *Reserved);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ShowBrowserUI )( 
            IShellUIHelper __RPC_FAR * This,
            /* [in] */ BSTR bstrName,
            /* [in] */ VARIANT __RPC_FAR *pvarIn,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarOut);
        
        END_INTERFACE
    } IShellUIHelperVtbl;

    interface IShellUIHelper
    {
        CONST_VTBL struct IShellUIHelperVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IShellUIHelper_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IShellUIHelper_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IShellUIHelper_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IShellUIHelper_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IShellUIHelper_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IShellUIHelper_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IShellUIHelper_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IShellUIHelper_ResetFirstBootMode(This)	\
    (This)->lpVtbl -> ResetFirstBootMode(This)

#define IShellUIHelper_ResetSafeMode(This)	\
    (This)->lpVtbl -> ResetSafeMode(This)

#define IShellUIHelper_RefreshOfflineDesktop(This)	\
    (This)->lpVtbl -> RefreshOfflineDesktop(This)

#define IShellUIHelper_AddFavorite(This,URL,Title)	\
    (This)->lpVtbl -> AddFavorite(This,URL,Title)

#define IShellUIHelper_AddChannel(This,URL)	\
    (This)->lpVtbl -> AddChannel(This,URL)

#define IShellUIHelper_AddDesktopComponent(This,URL,Type,Left,Top,Width,Height)	\
    (This)->lpVtbl -> AddDesktopComponent(This,URL,Type,Left,Top,Width,Height)

#define IShellUIHelper_IsSubscribed(This,URL,pBool)	\
    (This)->lpVtbl -> IsSubscribed(This,URL,pBool)

#define IShellUIHelper_NavigateAndFind(This,URL,strQuery,varTargetFrame)	\
    (This)->lpVtbl -> NavigateAndFind(This,URL,strQuery,varTargetFrame)

#define IShellUIHelper_ImportExportFavorites(This,fImport,strImpExpPath)	\
    (This)->lpVtbl -> ImportExportFavorites(This,fImport,strImpExpPath)

#define IShellUIHelper_AutoCompleteSaveForm(This,Form)	\
    (This)->lpVtbl -> AutoCompleteSaveForm(This,Form)

#define IShellUIHelper_AutoScan(This,strSearch,strFailureUrl,pvarTargetFrame)	\
    (This)->lpVtbl -> AutoScan(This,strSearch,strFailureUrl,pvarTargetFrame)

#define IShellUIHelper_AutoCompleteAttach(This,Reserved)	\
    (This)->lpVtbl -> AutoCompleteAttach(This,Reserved)

#define IShellUIHelper_ShowBrowserUI(This,bstrName,pvarIn,pvarOut)	\
    (This)->lpVtbl -> ShowBrowserUI(This,bstrName,pvarIn,pvarOut)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][hidden] */ HRESULT STDMETHODCALLTYPE IShellUIHelper_ResetFirstBootMode_Proxy( 
    IShellUIHelper __RPC_FAR * This);


void __RPC_STUB IShellUIHelper_ResetFirstBootMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][hidden] */ HRESULT STDMETHODCALLTYPE IShellUIHelper_ResetSafeMode_Proxy( 
    IShellUIHelper __RPC_FAR * This);


void __RPC_STUB IShellUIHelper_ResetSafeMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][hidden] */ HRESULT STDMETHODCALLTYPE IShellUIHelper_RefreshOfflineDesktop_Proxy( 
    IShellUIHelper __RPC_FAR * This);


void __RPC_STUB IShellUIHelper_RefreshOfflineDesktop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IShellUIHelper_AddFavorite_Proxy( 
    IShellUIHelper __RPC_FAR * This,
    /* [in] */ BSTR URL,
    /* [in][optional] */ VARIANT __RPC_FAR *Title);


void __RPC_STUB IShellUIHelper_AddFavorite_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IShellUIHelper_AddChannel_Proxy( 
    IShellUIHelper __RPC_FAR * This,
    /* [in] */ BSTR URL);


void __RPC_STUB IShellUIHelper_AddChannel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IShellUIHelper_AddDesktopComponent_Proxy( 
    IShellUIHelper __RPC_FAR * This,
    /* [in] */ BSTR URL,
    /* [in] */ BSTR Type,
    /* [in][optional] */ VARIANT __RPC_FAR *Left,
    /* [in][optional] */ VARIANT __RPC_FAR *Top,
    /* [in][optional] */ VARIANT __RPC_FAR *Width,
    /* [in][optional] */ VARIANT __RPC_FAR *Height);


void __RPC_STUB IShellUIHelper_AddDesktopComponent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IShellUIHelper_IsSubscribed_Proxy( 
    IShellUIHelper __RPC_FAR * This,
    /* [in] */ BSTR URL,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pBool);


void __RPC_STUB IShellUIHelper_IsSubscribed_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IShellUIHelper_NavigateAndFind_Proxy( 
    IShellUIHelper __RPC_FAR * This,
    /* [in] */ BSTR URL,
    /* [in] */ BSTR strQuery,
    /* [in] */ VARIANT __RPC_FAR *varTargetFrame);


void __RPC_STUB IShellUIHelper_NavigateAndFind_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IShellUIHelper_ImportExportFavorites_Proxy( 
    IShellUIHelper __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL fImport,
    /* [in] */ BSTR strImpExpPath);


void __RPC_STUB IShellUIHelper_ImportExportFavorites_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IShellUIHelper_AutoCompleteSaveForm_Proxy( 
    IShellUIHelper __RPC_FAR * This,
    /* [in][optional] */ VARIANT __RPC_FAR *Form);


void __RPC_STUB IShellUIHelper_AutoCompleteSaveForm_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IShellUIHelper_AutoScan_Proxy( 
    IShellUIHelper __RPC_FAR * This,
    /* [in] */ BSTR strSearch,
    /* [in] */ BSTR strFailureUrl,
    /* [in][optional] */ VARIANT __RPC_FAR *pvarTargetFrame);


void __RPC_STUB IShellUIHelper_AutoScan_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][hidden] */ HRESULT STDMETHODCALLTYPE IShellUIHelper_AutoCompleteAttach_Proxy( 
    IShellUIHelper __RPC_FAR * This,
    /* [in][optional] */ VARIANT __RPC_FAR *Reserved);


void __RPC_STUB IShellUIHelper_AutoCompleteAttach_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IShellUIHelper_ShowBrowserUI_Proxy( 
    IShellUIHelper __RPC_FAR * This,
    /* [in] */ BSTR bstrName,
    /* [in] */ VARIANT __RPC_FAR *pvarIn,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarOut);


void __RPC_STUB IShellUIHelper_ShowBrowserUI_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IShellUIHelper_INTERFACE_DEFINED__ */


#ifndef __IShellUIHelper2_INTERFACE_DEFINED__
#define __IShellUIHelper2_INTERFACE_DEFINED__

/* interface IShellUIHelper2 */
/* [object][dual][oleautomation][helpstring][uuid] */ 


EXTERN_C const IID IID_IShellUIHelper2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a7fe6eda-1932-4281-b881-87b31b8bc52c")
    IShellUIHelper2 : public IShellUIHelper
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE AddSearchProvider( 
            /* [in] */ BSTR URL) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE RunOnceShown( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE SkipRunOnce( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE CustomizeSettings( 
            /* [in] */ VARIANT_BOOL fSQM,
            /* [in] */ VARIANT_BOOL fPhishing,
            /* [in] */ BSTR bstrLocale) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE SqmEnabled( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfEnabled) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE PhishingEnabled( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfEnabled) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE BrandImageUri( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrUri) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE SkipTabsWelcome( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE DiagnoseConnection( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE CustomizeClearType( 
            /* [in] */ VARIANT_BOOL fSet) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE IsSearchProviderInstalled( 
            /* [in] */ BSTR URL,
            /* [retval][out] */ DWORD __RPC_FAR *pdwResult) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE IsSearchMigrated( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfMigrated) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE DefaultSearchProvider( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrName) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE RunOnceRequiredSettingsComplete( 
            /* [in] */ VARIANT_BOOL fComplete) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE RunOnceHasShown( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfShown) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE SearchGuideUrl( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrUrl) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IShellUIHelper2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IShellUIHelper2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IShellUIHelper2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IShellUIHelper2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IShellUIHelper2 __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IShellUIHelper2 __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IShellUIHelper2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IShellUIHelper2 __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][hidden] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ResetFirstBootMode )( 
            IShellUIHelper2 __RPC_FAR * This);
        
        /* [id][hidden] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ResetSafeMode )( 
            IShellUIHelper2 __RPC_FAR * This);
        
        /* [id][hidden] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RefreshOfflineDesktop )( 
            IShellUIHelper2 __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddFavorite )( 
            IShellUIHelper2 __RPC_FAR * This,
            /* [in] */ BSTR URL,
            /* [in][optional] */ VARIANT __RPC_FAR *Title);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddChannel )( 
            IShellUIHelper2 __RPC_FAR * This,
            /* [in] */ BSTR URL);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddDesktopComponent )( 
            IShellUIHelper2 __RPC_FAR * This,
            /* [in] */ BSTR URL,
            /* [in] */ BSTR Type,
            /* [in][optional] */ VARIANT __RPC_FAR *Left,
            /* [in][optional] */ VARIANT __RPC_FAR *Top,
            /* [in][optional] */ VARIANT __RPC_FAR *Width,
            /* [in][optional] */ VARIANT __RPC_FAR *Height);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsSubscribed )( 
            IShellUIHelper2 __RPC_FAR * This,
            /* [in] */ BSTR URL,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pBool);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NavigateAndFind )( 
            IShellUIHelper2 __RPC_FAR * This,
            /* [in] */ BSTR URL,
            /* [in] */ BSTR strQuery,
            /* [in] */ VARIANT __RPC_FAR *varTargetFrame);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ImportExportFavorites )( 
            IShellUIHelper2 __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL fImport,
            /* [in] */ BSTR strImpExpPath);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AutoCompleteSaveForm )( 
            IShellUIHelper2 __RPC_FAR * This,
            /* [in][optional] */ VARIANT __RPC_FAR *Form);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AutoScan )( 
            IShellUIHelper2 __RPC_FAR * This,
            /* [in] */ BSTR strSearch,
            /* [in] */ BSTR strFailureUrl,
            /* [in][optional] */ VARIANT __RPC_FAR *pvarTargetFrame);
        
        /* [id][hidden] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AutoCompleteAttach )( 
            IShellUIHelper2 __RPC_FAR * This,
            /* [in][optional] */ VARIANT __RPC_FAR *Reserved);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ShowBrowserUI )( 
            IShellUIHelper2 __RPC_FAR * This,
            /* [in] */ BSTR bstrName,
            /* [in] */ VARIANT __RPC_FAR *pvarIn,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarOut);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddSearchProvider )( 
            IShellUIHelper2 __RPC_FAR * This,
            /* [in] */ BSTR URL);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RunOnceShown )( 
            IShellUIHelper2 __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SkipRunOnce )( 
            IShellUIHelper2 __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CustomizeSettings )( 
            IShellUIHelper2 __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL fSQM,
            /* [in] */ VARIANT_BOOL fPhishing,
            /* [in] */ BSTR bstrLocale);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SqmEnabled )( 
            IShellUIHelper2 __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfEnabled);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PhishingEnabled )( 
            IShellUIHelper2 __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfEnabled);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BrandImageUri )( 
            IShellUIHelper2 __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrUri);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SkipTabsWelcome )( 
            IShellUIHelper2 __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DiagnoseConnection )( 
            IShellUIHelper2 __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CustomizeClearType )( 
            IShellUIHelper2 __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL fSet);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsSearchProviderInstalled )( 
            IShellUIHelper2 __RPC_FAR * This,
            /* [in] */ BSTR URL,
            /* [retval][out] */ DWORD __RPC_FAR *pdwResult);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsSearchMigrated )( 
            IShellUIHelper2 __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfMigrated);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DefaultSearchProvider )( 
            IShellUIHelper2 __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrName);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RunOnceRequiredSettingsComplete )( 
            IShellUIHelper2 __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL fComplete);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RunOnceHasShown )( 
            IShellUIHelper2 __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfShown);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SearchGuideUrl )( 
            IShellUIHelper2 __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrUrl);
        
        END_INTERFACE
    } IShellUIHelper2Vtbl;

    interface IShellUIHelper2
    {
        CONST_VTBL struct IShellUIHelper2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IShellUIHelper2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IShellUIHelper2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IShellUIHelper2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IShellUIHelper2_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IShellUIHelper2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IShellUIHelper2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IShellUIHelper2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IShellUIHelper2_ResetFirstBootMode(This)	\
    (This)->lpVtbl -> ResetFirstBootMode(This)

#define IShellUIHelper2_ResetSafeMode(This)	\
    (This)->lpVtbl -> ResetSafeMode(This)

#define IShellUIHelper2_RefreshOfflineDesktop(This)	\
    (This)->lpVtbl -> RefreshOfflineDesktop(This)

#define IShellUIHelper2_AddFavorite(This,URL,Title)	\
    (This)->lpVtbl -> AddFavorite(This,URL,Title)

#define IShellUIHelper2_AddChannel(This,URL)	\
    (This)->lpVtbl -> AddChannel(This,URL)

#define IShellUIHelper2_AddDesktopComponent(This,URL,Type,Left,Top,Width,Height)	\
    (This)->lpVtbl -> AddDesktopComponent(This,URL,Type,Left,Top,Width,Height)

#define IShellUIHelper2_IsSubscribed(This,URL,pBool)	\
    (This)->lpVtbl -> IsSubscribed(This,URL,pBool)

#define IShellUIHelper2_NavigateAndFind(This,URL,strQuery,varTargetFrame)	\
    (This)->lpVtbl -> NavigateAndFind(This,URL,strQuery,varTargetFrame)

#define IShellUIHelper2_ImportExportFavorites(This,fImport,strImpExpPath)	\
    (This)->lpVtbl -> ImportExportFavorites(This,fImport,strImpExpPath)

#define IShellUIHelper2_AutoCompleteSaveForm(This,Form)	\
    (This)->lpVtbl -> AutoCompleteSaveForm(This,Form)

#define IShellUIHelper2_AutoScan(This,strSearch,strFailureUrl,pvarTargetFrame)	\
    (This)->lpVtbl -> AutoScan(This,strSearch,strFailureUrl,pvarTargetFrame)

#define IShellUIHelper2_AutoCompleteAttach(This,Reserved)	\
    (This)->lpVtbl -> AutoCompleteAttach(This,Reserved)

#define IShellUIHelper2_ShowBrowserUI(This,bstrName,pvarIn,pvarOut)	\
    (This)->lpVtbl -> ShowBrowserUI(This,bstrName,pvarIn,pvarOut)


#define IShellUIHelper2_AddSearchProvider(This,URL)	\
    (This)->lpVtbl -> AddSearchProvider(This,URL)

#define IShellUIHelper2_RunOnceShown(This)	\
    (This)->lpVtbl -> RunOnceShown(This)

#define IShellUIHelper2_SkipRunOnce(This)	\
    (This)->lpVtbl -> SkipRunOnce(This)

#define IShellUIHelper2_CustomizeSettings(This,fSQM,fPhishing,bstrLocale)	\
    (This)->lpVtbl -> CustomizeSettings(This,fSQM,fPhishing,bstrLocale)

#define IShellUIHelper2_SqmEnabled(This,pfEnabled)	\
    (This)->lpVtbl -> SqmEnabled(This,pfEnabled)

#define IShellUIHelper2_PhishingEnabled(This,pfEnabled)	\
    (This)->lpVtbl -> PhishingEnabled(This,pfEnabled)

#define IShellUIHelper2_BrandImageUri(This,pbstrUri)	\
    (This)->lpVtbl -> BrandImageUri(This,pbstrUri)

#define IShellUIHelper2_SkipTabsWelcome(This)	\
    (This)->lpVtbl -> SkipTabsWelcome(This)

#define IShellUIHelper2_DiagnoseConnection(This)	\
    (This)->lpVtbl -> DiagnoseConnection(This)

#define IShellUIHelper2_CustomizeClearType(This,fSet)	\
    (This)->lpVtbl -> CustomizeClearType(This,fSet)

#define IShellUIHelper2_IsSearchProviderInstalled(This,URL,pdwResult)	\
    (This)->lpVtbl -> IsSearchProviderInstalled(This,URL,pdwResult)

#define IShellUIHelper2_IsSearchMigrated(This,pfMigrated)	\
    (This)->lpVtbl -> IsSearchMigrated(This,pfMigrated)

#define IShellUIHelper2_DefaultSearchProvider(This,pbstrName)	\
    (This)->lpVtbl -> DefaultSearchProvider(This,pbstrName)

#define IShellUIHelper2_RunOnceRequiredSettingsComplete(This,fComplete)	\
    (This)->lpVtbl -> RunOnceRequiredSettingsComplete(This,fComplete)

#define IShellUIHelper2_RunOnceHasShown(This,pfShown)	\
    (This)->lpVtbl -> RunOnceHasShown(This,pfShown)

#define IShellUIHelper2_SearchGuideUrl(This,pbstrUrl)	\
    (This)->lpVtbl -> SearchGuideUrl(This,pbstrUrl)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id] */ HRESULT STDMETHODCALLTYPE IShellUIHelper2_AddSearchProvider_Proxy( 
    IShellUIHelper2 __RPC_FAR * This,
    /* [in] */ BSTR URL);


void __RPC_STUB IShellUIHelper2_AddSearchProvider_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IShellUIHelper2_RunOnceShown_Proxy( 
    IShellUIHelper2 __RPC_FAR * This);


void __RPC_STUB IShellUIHelper2_RunOnceShown_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IShellUIHelper2_SkipRunOnce_Proxy( 
    IShellUIHelper2 __RPC_FAR * This);


void __RPC_STUB IShellUIHelper2_SkipRunOnce_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IShellUIHelper2_CustomizeSettings_Proxy( 
    IShellUIHelper2 __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL fSQM,
    /* [in] */ VARIANT_BOOL fPhishing,
    /* [in] */ BSTR bstrLocale);


void __RPC_STUB IShellUIHelper2_CustomizeSettings_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IShellUIHelper2_SqmEnabled_Proxy( 
    IShellUIHelper2 __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfEnabled);


void __RPC_STUB IShellUIHelper2_SqmEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IShellUIHelper2_PhishingEnabled_Proxy( 
    IShellUIHelper2 __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfEnabled);


void __RPC_STUB IShellUIHelper2_PhishingEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IShellUIHelper2_BrandImageUri_Proxy( 
    IShellUIHelper2 __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrUri);


void __RPC_STUB IShellUIHelper2_BrandImageUri_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IShellUIHelper2_SkipTabsWelcome_Proxy( 
    IShellUIHelper2 __RPC_FAR * This);


void __RPC_STUB IShellUIHelper2_SkipTabsWelcome_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IShellUIHelper2_DiagnoseConnection_Proxy( 
    IShellUIHelper2 __RPC_FAR * This);


void __RPC_STUB IShellUIHelper2_DiagnoseConnection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IShellUIHelper2_CustomizeClearType_Proxy( 
    IShellUIHelper2 __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL fSet);


void __RPC_STUB IShellUIHelper2_CustomizeClearType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IShellUIHelper2_IsSearchProviderInstalled_Proxy( 
    IShellUIHelper2 __RPC_FAR * This,
    /* [in] */ BSTR URL,
    /* [retval][out] */ DWORD __RPC_FAR *pdwResult);


void __RPC_STUB IShellUIHelper2_IsSearchProviderInstalled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IShellUIHelper2_IsSearchMigrated_Proxy( 
    IShellUIHelper2 __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfMigrated);


void __RPC_STUB IShellUIHelper2_IsSearchMigrated_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IShellUIHelper2_DefaultSearchProvider_Proxy( 
    IShellUIHelper2 __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrName);


void __RPC_STUB IShellUIHelper2_DefaultSearchProvider_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IShellUIHelper2_RunOnceRequiredSettingsComplete_Proxy( 
    IShellUIHelper2 __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL fComplete);


void __RPC_STUB IShellUIHelper2_RunOnceRequiredSettingsComplete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IShellUIHelper2_RunOnceHasShown_Proxy( 
    IShellUIHelper2 __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfShown);


void __RPC_STUB IShellUIHelper2_RunOnceHasShown_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IShellUIHelper2_SearchGuideUrl_Proxy( 
    IShellUIHelper2 __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrUrl);


void __RPC_STUB IShellUIHelper2_SearchGuideUrl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IShellUIHelper2_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_ShellUIHelper;

#ifdef __cplusplus

class DECLSPEC_UUID("64AB4BB7-111E-11d1-8F79-00C04FC2FBE1")
ShellUIHelper;
#endif

#ifndef __DShellNameSpaceEvents_DISPINTERFACE_DEFINED__
#define __DShellNameSpaceEvents_DISPINTERFACE_DEFINED__

/* dispinterface DShellNameSpaceEvents */
/* [uuid] */ 


EXTERN_C const IID DIID_DShellNameSpaceEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("55136806-B2DE-11D1-B9F2-00A0C98BC547")
    DShellNameSpaceEvents : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct DShellNameSpaceEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            DShellNameSpaceEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            DShellNameSpaceEvents __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            DShellNameSpaceEvents __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            DShellNameSpaceEvents __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            DShellNameSpaceEvents __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            DShellNameSpaceEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            DShellNameSpaceEvents __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        END_INTERFACE
    } DShellNameSpaceEventsVtbl;

    interface DShellNameSpaceEvents
    {
        CONST_VTBL struct DShellNameSpaceEventsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define DShellNameSpaceEvents_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define DShellNameSpaceEvents_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define DShellNameSpaceEvents_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define DShellNameSpaceEvents_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define DShellNameSpaceEvents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define DShellNameSpaceEvents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define DShellNameSpaceEvents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* __DShellNameSpaceEvents_DISPINTERFACE_DEFINED__ */


#ifndef __IShellFavoritesNameSpace_INTERFACE_DEFINED__
#define __IShellFavoritesNameSpace_INTERFACE_DEFINED__

/* interface IShellFavoritesNameSpace */
/* [hidden][unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IShellFavoritesNameSpace;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("55136804-B2DE-11D1-B9F2-00A0C98BC547")
    IShellFavoritesNameSpace : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE MoveSelectionUp( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE MoveSelectionDown( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ResetSort( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE NewFolder( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Synchronize( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Import( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Export( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE InvokeContextMenuCommand( 
            /* [in] */ BSTR strCommand) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE MoveSelectionTo( void) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SubscriptionsEnabled( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pBool) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CreateSubscriptionForSelection( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pBool) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE DeleteSubscriptionForSelection( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pBool) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetRoot( 
            /* [in] */ BSTR bstrFullPath) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IShellFavoritesNameSpaceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IShellFavoritesNameSpace __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IShellFavoritesNameSpace __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IShellFavoritesNameSpace __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IShellFavoritesNameSpace __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IShellFavoritesNameSpace __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IShellFavoritesNameSpace __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IShellFavoritesNameSpace __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveSelectionUp )( 
            IShellFavoritesNameSpace __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveSelectionDown )( 
            IShellFavoritesNameSpace __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ResetSort )( 
            IShellFavoritesNameSpace __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NewFolder )( 
            IShellFavoritesNameSpace __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Synchronize )( 
            IShellFavoritesNameSpace __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Import )( 
            IShellFavoritesNameSpace __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Export )( 
            IShellFavoritesNameSpace __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InvokeContextMenuCommand )( 
            IShellFavoritesNameSpace __RPC_FAR * This,
            /* [in] */ BSTR strCommand);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveSelectionTo )( 
            IShellFavoritesNameSpace __RPC_FAR * This);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SubscriptionsEnabled )( 
            IShellFavoritesNameSpace __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pBool);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateSubscriptionForSelection )( 
            IShellFavoritesNameSpace __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pBool);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteSubscriptionForSelection )( 
            IShellFavoritesNameSpace __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pBool);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetRoot )( 
            IShellFavoritesNameSpace __RPC_FAR * This,
            /* [in] */ BSTR bstrFullPath);
        
        END_INTERFACE
    } IShellFavoritesNameSpaceVtbl;

    interface IShellFavoritesNameSpace
    {
        CONST_VTBL struct IShellFavoritesNameSpaceVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IShellFavoritesNameSpace_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IShellFavoritesNameSpace_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IShellFavoritesNameSpace_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IShellFavoritesNameSpace_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IShellFavoritesNameSpace_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IShellFavoritesNameSpace_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IShellFavoritesNameSpace_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IShellFavoritesNameSpace_MoveSelectionUp(This)	\
    (This)->lpVtbl -> MoveSelectionUp(This)

#define IShellFavoritesNameSpace_MoveSelectionDown(This)	\
    (This)->lpVtbl -> MoveSelectionDown(This)

#define IShellFavoritesNameSpace_ResetSort(This)	\
    (This)->lpVtbl -> ResetSort(This)

#define IShellFavoritesNameSpace_NewFolder(This)	\
    (This)->lpVtbl -> NewFolder(This)

#define IShellFavoritesNameSpace_Synchronize(This)	\
    (This)->lpVtbl -> Synchronize(This)

#define IShellFavoritesNameSpace_Import(This)	\
    (This)->lpVtbl -> Import(This)

#define IShellFavoritesNameSpace_Export(This)	\
    (This)->lpVtbl -> Export(This)

#define IShellFavoritesNameSpace_InvokeContextMenuCommand(This,strCommand)	\
    (This)->lpVtbl -> InvokeContextMenuCommand(This,strCommand)

#define IShellFavoritesNameSpace_MoveSelectionTo(This)	\
    (This)->lpVtbl -> MoveSelectionTo(This)

#define IShellFavoritesNameSpace_get_SubscriptionsEnabled(This,pBool)	\
    (This)->lpVtbl -> get_SubscriptionsEnabled(This,pBool)

#define IShellFavoritesNameSpace_CreateSubscriptionForSelection(This,pBool)	\
    (This)->lpVtbl -> CreateSubscriptionForSelection(This,pBool)

#define IShellFavoritesNameSpace_DeleteSubscriptionForSelection(This,pBool)	\
    (This)->lpVtbl -> DeleteSubscriptionForSelection(This,pBool)

#define IShellFavoritesNameSpace_SetRoot(This,bstrFullPath)	\
    (This)->lpVtbl -> SetRoot(This,bstrFullPath)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IShellFavoritesNameSpace_MoveSelectionUp_Proxy( 
    IShellFavoritesNameSpace __RPC_FAR * This);


void __RPC_STUB IShellFavoritesNameSpace_MoveSelectionUp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IShellFavoritesNameSpace_MoveSelectionDown_Proxy( 
    IShellFavoritesNameSpace __RPC_FAR * This);


void __RPC_STUB IShellFavoritesNameSpace_MoveSelectionDown_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IShellFavoritesNameSpace_ResetSort_Proxy( 
    IShellFavoritesNameSpace __RPC_FAR * This);


void __RPC_STUB IShellFavoritesNameSpace_ResetSort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IShellFavoritesNameSpace_NewFolder_Proxy( 
    IShellFavoritesNameSpace __RPC_FAR * This);


void __RPC_STUB IShellFavoritesNameSpace_NewFolder_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IShellFavoritesNameSpace_Synchronize_Proxy( 
    IShellFavoritesNameSpace __RPC_FAR * This);


void __RPC_STUB IShellFavoritesNameSpace_Synchronize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IShellFavoritesNameSpace_Import_Proxy( 
    IShellFavoritesNameSpace __RPC_FAR * This);


void __RPC_STUB IShellFavoritesNameSpace_Import_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IShellFavoritesNameSpace_Export_Proxy( 
    IShellFavoritesNameSpace __RPC_FAR * This);


void __RPC_STUB IShellFavoritesNameSpace_Export_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IShellFavoritesNameSpace_InvokeContextMenuCommand_Proxy( 
    IShellFavoritesNameSpace __RPC_FAR * This,
    /* [in] */ BSTR strCommand);


void __RPC_STUB IShellFavoritesNameSpace_InvokeContextMenuCommand_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IShellFavoritesNameSpace_MoveSelectionTo_Proxy( 
    IShellFavoritesNameSpace __RPC_FAR * This);


void __RPC_STUB IShellFavoritesNameSpace_MoveSelectionTo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IShellFavoritesNameSpace_get_SubscriptionsEnabled_Proxy( 
    IShellFavoritesNameSpace __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pBool);


void __RPC_STUB IShellFavoritesNameSpace_get_SubscriptionsEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IShellFavoritesNameSpace_CreateSubscriptionForSelection_Proxy( 
    IShellFavoritesNameSpace __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pBool);


void __RPC_STUB IShellFavoritesNameSpace_CreateSubscriptionForSelection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IShellFavoritesNameSpace_DeleteSubscriptionForSelection_Proxy( 
    IShellFavoritesNameSpace __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pBool);


void __RPC_STUB IShellFavoritesNameSpace_DeleteSubscriptionForSelection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IShellFavoritesNameSpace_SetRoot_Proxy( 
    IShellFavoritesNameSpace __RPC_FAR * This,
    /* [in] */ BSTR bstrFullPath);


void __RPC_STUB IShellFavoritesNameSpace_SetRoot_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IShellFavoritesNameSpace_INTERFACE_DEFINED__ */


#ifndef __IShellNameSpace_INTERFACE_DEFINED__
#define __IShellNameSpace_INTERFACE_DEFINED__

/* interface IShellNameSpace */
/* [hidden][unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IShellNameSpace;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("e572d3c9-37be-4ae2-825d-d521763e3108")
    IShellNameSpace : public IShellFavoritesNameSpace
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_EnumOptions( 
            /* [retval][out] */ LONG __RPC_FAR *pgrfEnumFlags) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_EnumOptions( 
            /* [in] */ LONG lVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SelectedItem( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *pItem) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_SelectedItem( 
            /* [in] */ IDispatch __RPC_FAR *pItem) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Root( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvar) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Root( 
            /* [in] */ VARIANT var) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Depth( 
            /* [retval][out] */ int __RPC_FAR *piDepth) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Depth( 
            /* [in] */ int iDepth) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Mode( 
            /* [retval][out] */ UINT __RPC_FAR *puMode) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Mode( 
            /* [in] */ UINT uMode) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Flags( 
            /* [retval][out] */ DWORD __RPC_FAR *pdwFlags) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Flags( 
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_TVFlags( 
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TVFlags( 
            /* [retval][out] */ DWORD __RPC_FAR *dwFlags) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Columns( 
            /* [retval][out] */ BSTR __RPC_FAR *bstrColumns) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Columns( 
            /* [in] */ BSTR bstrColumns) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CountViewTypes( 
            /* [retval][out] */ int __RPC_FAR *piTypes) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetViewType( 
            /* [in] */ int iType) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SelectedItems( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Expand( 
            /* [in] */ VARIANT var,
            int iDepth) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE UnselectAll( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IShellNameSpaceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IShellNameSpace __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IShellNameSpace __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IShellNameSpace __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IShellNameSpace __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IShellNameSpace __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IShellNameSpace __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IShellNameSpace __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveSelectionUp )( 
            IShellNameSpace __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveSelectionDown )( 
            IShellNameSpace __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ResetSort )( 
            IShellNameSpace __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NewFolder )( 
            IShellNameSpace __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Synchronize )( 
            IShellNameSpace __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Import )( 
            IShellNameSpace __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Export )( 
            IShellNameSpace __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InvokeContextMenuCommand )( 
            IShellNameSpace __RPC_FAR * This,
            /* [in] */ BSTR strCommand);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveSelectionTo )( 
            IShellNameSpace __RPC_FAR * This);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SubscriptionsEnabled )( 
            IShellNameSpace __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pBool);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateSubscriptionForSelection )( 
            IShellNameSpace __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pBool);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteSubscriptionForSelection )( 
            IShellNameSpace __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pBool);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetRoot )( 
            IShellNameSpace __RPC_FAR * This,
            /* [in] */ BSTR bstrFullPath);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_EnumOptions )( 
            IShellNameSpace __RPC_FAR * This,
            /* [retval][out] */ LONG __RPC_FAR *pgrfEnumFlags);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_EnumOptions )( 
            IShellNameSpace __RPC_FAR * This,
            /* [in] */ LONG lVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SelectedItem )( 
            IShellNameSpace __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *pItem);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_SelectedItem )( 
            IShellNameSpace __RPC_FAR * This,
            /* [in] */ IDispatch __RPC_FAR *pItem);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Root )( 
            IShellNameSpace __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Root )( 
            IShellNameSpace __RPC_FAR * This,
            /* [in] */ VARIANT var);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Depth )( 
            IShellNameSpace __RPC_FAR * This,
            /* [retval][out] */ int __RPC_FAR *piDepth);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Depth )( 
            IShellNameSpace __RPC_FAR * This,
            /* [in] */ int iDepth);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Mode )( 
            IShellNameSpace __RPC_FAR * This,
            /* [retval][out] */ UINT __RPC_FAR *puMode);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Mode )( 
            IShellNameSpace __RPC_FAR * This,
            /* [in] */ UINT uMode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Flags )( 
            IShellNameSpace __RPC_FAR * This,
            /* [retval][out] */ DWORD __RPC_FAR *pdwFlags);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Flags )( 
            IShellNameSpace __RPC_FAR * This,
            /* [in] */ DWORD dwFlags);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_TVFlags )( 
            IShellNameSpace __RPC_FAR * This,
            /* [in] */ DWORD dwFlags);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_TVFlags )( 
            IShellNameSpace __RPC_FAR * This,
            /* [retval][out] */ DWORD __RPC_FAR *dwFlags);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Columns )( 
            IShellNameSpace __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *bstrColumns);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Columns )( 
            IShellNameSpace __RPC_FAR * This,
            /* [in] */ BSTR bstrColumns);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CountViewTypes )( 
            IShellNameSpace __RPC_FAR * This,
            /* [retval][out] */ int __RPC_FAR *piTypes);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetViewType )( 
            IShellNameSpace __RPC_FAR * This,
            /* [in] */ int iType);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SelectedItems )( 
            IShellNameSpace __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Expand )( 
            IShellNameSpace __RPC_FAR * This,
            /* [in] */ VARIANT var,
            int iDepth);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UnselectAll )( 
            IShellNameSpace __RPC_FAR * This);
        
        END_INTERFACE
    } IShellNameSpaceVtbl;

    interface IShellNameSpace
    {
        CONST_VTBL struct IShellNameSpaceVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IShellNameSpace_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IShellNameSpace_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IShellNameSpace_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IShellNameSpace_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IShellNameSpace_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IShellNameSpace_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IShellNameSpace_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IShellNameSpace_MoveSelectionUp(This)	\
    (This)->lpVtbl -> MoveSelectionUp(This)

#define IShellNameSpace_MoveSelectionDown(This)	\
    (This)->lpVtbl -> MoveSelectionDown(This)

#define IShellNameSpace_ResetSort(This)	\
    (This)->lpVtbl -> ResetSort(This)

#define IShellNameSpace_NewFolder(This)	\
    (This)->lpVtbl -> NewFolder(This)

#define IShellNameSpace_Synchronize(This)	\
    (This)->lpVtbl -> Synchronize(This)

#define IShellNameSpace_Import(This)	\
    (This)->lpVtbl -> Import(This)

#define IShellNameSpace_Export(This)	\
    (This)->lpVtbl -> Export(This)

#define IShellNameSpace_InvokeContextMenuCommand(This,strCommand)	\
    (This)->lpVtbl -> InvokeContextMenuCommand(This,strCommand)

#define IShellNameSpace_MoveSelectionTo(This)	\
    (This)->lpVtbl -> MoveSelectionTo(This)

#define IShellNameSpace_get_SubscriptionsEnabled(This,pBool)	\
    (This)->lpVtbl -> get_SubscriptionsEnabled(This,pBool)

#define IShellNameSpace_CreateSubscriptionForSelection(This,pBool)	\
    (This)->lpVtbl -> CreateSubscriptionForSelection(This,pBool)

#define IShellNameSpace_DeleteSubscriptionForSelection(This,pBool)	\
    (This)->lpVtbl -> DeleteSubscriptionForSelection(This,pBool)

#define IShellNameSpace_SetRoot(This,bstrFullPath)	\
    (This)->lpVtbl -> SetRoot(This,bstrFullPath)


#define IShellNameSpace_get_EnumOptions(This,pgrfEnumFlags)	\
    (This)->lpVtbl -> get_EnumOptions(This,pgrfEnumFlags)

#define IShellNameSpace_put_EnumOptions(This,lVal)	\
    (This)->lpVtbl -> put_EnumOptions(This,lVal)

#define IShellNameSpace_get_SelectedItem(This,pItem)	\
    (This)->lpVtbl -> get_SelectedItem(This,pItem)

#define IShellNameSpace_put_SelectedItem(This,pItem)	\
    (This)->lpVtbl -> put_SelectedItem(This,pItem)

#define IShellNameSpace_get_Root(This,pvar)	\
    (This)->lpVtbl -> get_Root(This,pvar)

#define IShellNameSpace_put_Root(This,var)	\
    (This)->lpVtbl -> put_Root(This,var)

#define IShellNameSpace_get_Depth(This,piDepth)	\
    (This)->lpVtbl -> get_Depth(This,piDepth)

#define IShellNameSpace_put_Depth(This,iDepth)	\
    (This)->lpVtbl -> put_Depth(This,iDepth)

#define IShellNameSpace_get_Mode(This,puMode)	\
    (This)->lpVtbl -> get_Mode(This,puMode)

#define IShellNameSpace_put_Mode(This,uMode)	\
    (This)->lpVtbl -> put_Mode(This,uMode)

#define IShellNameSpace_get_Flags(This,pdwFlags)	\
    (This)->lpVtbl -> get_Flags(This,pdwFlags)

#define IShellNameSpace_put_Flags(This,dwFlags)	\
    (This)->lpVtbl -> put_Flags(This,dwFlags)

#define IShellNameSpace_put_TVFlags(This,dwFlags)	\
    (This)->lpVtbl -> put_TVFlags(This,dwFlags)

#define IShellNameSpace_get_TVFlags(This,dwFlags)	\
    (This)->lpVtbl -> get_TVFlags(This,dwFlags)

#define IShellNameSpace_get_Columns(This,bstrColumns)	\
    (This)->lpVtbl -> get_Columns(This,bstrColumns)

#define IShellNameSpace_put_Columns(This,bstrColumns)	\
    (This)->lpVtbl -> put_Columns(This,bstrColumns)

#define IShellNameSpace_get_CountViewTypes(This,piTypes)	\
    (This)->lpVtbl -> get_CountViewTypes(This,piTypes)

#define IShellNameSpace_SetViewType(This,iType)	\
    (This)->lpVtbl -> SetViewType(This,iType)

#define IShellNameSpace_SelectedItems(This,ppid)	\
    (This)->lpVtbl -> SelectedItems(This,ppid)

#define IShellNameSpace_Expand(This,var,iDepth)	\
    (This)->lpVtbl -> Expand(This,var,iDepth)

#define IShellNameSpace_UnselectAll(This)	\
    (This)->lpVtbl -> UnselectAll(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IShellNameSpace_get_EnumOptions_Proxy( 
    IShellNameSpace __RPC_FAR * This,
    /* [retval][out] */ LONG __RPC_FAR *pgrfEnumFlags);


void __RPC_STUB IShellNameSpace_get_EnumOptions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IShellNameSpace_put_EnumOptions_Proxy( 
    IShellNameSpace __RPC_FAR * This,
    /* [in] */ LONG lVal);


void __RPC_STUB IShellNameSpace_put_EnumOptions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IShellNameSpace_get_SelectedItem_Proxy( 
    IShellNameSpace __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *pItem);


void __RPC_STUB IShellNameSpace_get_SelectedItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IShellNameSpace_put_SelectedItem_Proxy( 
    IShellNameSpace __RPC_FAR * This,
    /* [in] */ IDispatch __RPC_FAR *pItem);


void __RPC_STUB IShellNameSpace_put_SelectedItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IShellNameSpace_get_Root_Proxy( 
    IShellNameSpace __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvar);


void __RPC_STUB IShellNameSpace_get_Root_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IShellNameSpace_put_Root_Proxy( 
    IShellNameSpace __RPC_FAR * This,
    /* [in] */ VARIANT var);


void __RPC_STUB IShellNameSpace_put_Root_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IShellNameSpace_get_Depth_Proxy( 
    IShellNameSpace __RPC_FAR * This,
    /* [retval][out] */ int __RPC_FAR *piDepth);


void __RPC_STUB IShellNameSpace_get_Depth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IShellNameSpace_put_Depth_Proxy( 
    IShellNameSpace __RPC_FAR * This,
    /* [in] */ int iDepth);


void __RPC_STUB IShellNameSpace_put_Depth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IShellNameSpace_get_Mode_Proxy( 
    IShellNameSpace __RPC_FAR * This,
    /* [retval][out] */ UINT __RPC_FAR *puMode);


void __RPC_STUB IShellNameSpace_get_Mode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IShellNameSpace_put_Mode_Proxy( 
    IShellNameSpace __RPC_FAR * This,
    /* [in] */ UINT uMode);


void __RPC_STUB IShellNameSpace_put_Mode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IShellNameSpace_get_Flags_Proxy( 
    IShellNameSpace __RPC_FAR * This,
    /* [retval][out] */ DWORD __RPC_FAR *pdwFlags);


void __RPC_STUB IShellNameSpace_get_Flags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IShellNameSpace_put_Flags_Proxy( 
    IShellNameSpace __RPC_FAR * This,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IShellNameSpace_put_Flags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IShellNameSpace_put_TVFlags_Proxy( 
    IShellNameSpace __RPC_FAR * This,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IShellNameSpace_put_TVFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IShellNameSpace_get_TVFlags_Proxy( 
    IShellNameSpace __RPC_FAR * This,
    /* [retval][out] */ DWORD __RPC_FAR *dwFlags);


void __RPC_STUB IShellNameSpace_get_TVFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IShellNameSpace_get_Columns_Proxy( 
    IShellNameSpace __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *bstrColumns);


void __RPC_STUB IShellNameSpace_get_Columns_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IShellNameSpace_put_Columns_Proxy( 
    IShellNameSpace __RPC_FAR * This,
    /* [in] */ BSTR bstrColumns);


void __RPC_STUB IShellNameSpace_put_Columns_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IShellNameSpace_get_CountViewTypes_Proxy( 
    IShellNameSpace __RPC_FAR * This,
    /* [retval][out] */ int __RPC_FAR *piTypes);


void __RPC_STUB IShellNameSpace_get_CountViewTypes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IShellNameSpace_SetViewType_Proxy( 
    IShellNameSpace __RPC_FAR * This,
    /* [in] */ int iType);


void __RPC_STUB IShellNameSpace_SetViewType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IShellNameSpace_SelectedItems_Proxy( 
    IShellNameSpace __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid);


void __RPC_STUB IShellNameSpace_SelectedItems_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IShellNameSpace_Expand_Proxy( 
    IShellNameSpace __RPC_FAR * This,
    /* [in] */ VARIANT var,
    int iDepth);


void __RPC_STUB IShellNameSpace_Expand_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IShellNameSpace_UnselectAll_Proxy( 
    IShellNameSpace __RPC_FAR * This);


void __RPC_STUB IShellNameSpace_UnselectAll_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IShellNameSpace_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_ShellNameSpace;

#ifdef __cplusplus

class DECLSPEC_UUID("55136805-B2DE-11D1-B9F2-00A0C98BC547")
ShellNameSpace;
#endif

EXTERN_C const CLSID CLSID_ShellShellNameSpace;

#ifdef __cplusplus

class DECLSPEC_UUID("2F2F1F96-2BC1-4b1c-BE28-EA3774F4676A")
ShellShellNameSpace;
#endif

#ifndef __IScriptErrorList_INTERFACE_DEFINED__
#define __IScriptErrorList_INTERFACE_DEFINED__

/* interface IScriptErrorList */
/* [object][dual][hidden][oleautomation][helpstring][uuid] */ 


EXTERN_C const IID IID_IScriptErrorList;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F3470F24-15FD-11d2-BB2E-00805FF7EFCA")
    IScriptErrorList : public IDispatch
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE advanceError( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE retreatError( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE canAdvanceError( 
            /* [retval][out] */ BOOL __RPC_FAR *pfCanAdvance) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE canRetreatError( 
            /* [retval][out] */ BOOL __RPC_FAR *pfCanRetreat) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE getErrorLine( 
            /* [retval][out] */ LONG __RPC_FAR *plLine) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE getErrorChar( 
            /* [retval][out] */ LONG __RPC_FAR *plChar) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE getErrorCode( 
            /* [retval][out] */ LONG __RPC_FAR *plCode) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE getErrorMsg( 
            /* [retval][out] */ BSTR __RPC_FAR *pstr) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE getErrorUrl( 
            /* [retval][out] */ BSTR __RPC_FAR *pstr) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE getAlwaysShowLockState( 
            /* [retval][out] */ BOOL __RPC_FAR *pfAlwaysShowLocked) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE getDetailsPaneOpen( 
            /* [retval][out] */ BOOL __RPC_FAR *pfDetailsPaneOpen) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE setDetailsPaneOpen( 
            BOOL fDetailsPaneOpen) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE getPerErrorDisplay( 
            /* [retval][out] */ BOOL __RPC_FAR *pfPerErrorDisplay) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE setPerErrorDisplay( 
            BOOL fPerErrorDisplay) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IScriptErrorListVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IScriptErrorList __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IScriptErrorList __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IScriptErrorList __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IScriptErrorList __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IScriptErrorList __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IScriptErrorList __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IScriptErrorList __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *advanceError )( 
            IScriptErrorList __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *retreatError )( 
            IScriptErrorList __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *canAdvanceError )( 
            IScriptErrorList __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pfCanAdvance);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *canRetreatError )( 
            IScriptErrorList __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pfCanRetreat);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getErrorLine )( 
            IScriptErrorList __RPC_FAR * This,
            /* [retval][out] */ LONG __RPC_FAR *plLine);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getErrorChar )( 
            IScriptErrorList __RPC_FAR * This,
            /* [retval][out] */ LONG __RPC_FAR *plChar);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getErrorCode )( 
            IScriptErrorList __RPC_FAR * This,
            /* [retval][out] */ LONG __RPC_FAR *plCode);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getErrorMsg )( 
            IScriptErrorList __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pstr);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getErrorUrl )( 
            IScriptErrorList __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pstr);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getAlwaysShowLockState )( 
            IScriptErrorList __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pfAlwaysShowLocked);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getDetailsPaneOpen )( 
            IScriptErrorList __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pfDetailsPaneOpen);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *setDetailsPaneOpen )( 
            IScriptErrorList __RPC_FAR * This,
            BOOL fDetailsPaneOpen);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getPerErrorDisplay )( 
            IScriptErrorList __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pfPerErrorDisplay);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *setPerErrorDisplay )( 
            IScriptErrorList __RPC_FAR * This,
            BOOL fPerErrorDisplay);
        
        END_INTERFACE
    } IScriptErrorListVtbl;

    interface IScriptErrorList
    {
        CONST_VTBL struct IScriptErrorListVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IScriptErrorList_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IScriptErrorList_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IScriptErrorList_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IScriptErrorList_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IScriptErrorList_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IScriptErrorList_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IScriptErrorList_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IScriptErrorList_advanceError(This)	\
    (This)->lpVtbl -> advanceError(This)

#define IScriptErrorList_retreatError(This)	\
    (This)->lpVtbl -> retreatError(This)

#define IScriptErrorList_canAdvanceError(This,pfCanAdvance)	\
    (This)->lpVtbl -> canAdvanceError(This,pfCanAdvance)

#define IScriptErrorList_canRetreatError(This,pfCanRetreat)	\
    (This)->lpVtbl -> canRetreatError(This,pfCanRetreat)

#define IScriptErrorList_getErrorLine(This,plLine)	\
    (This)->lpVtbl -> getErrorLine(This,plLine)

#define IScriptErrorList_getErrorChar(This,plChar)	\
    (This)->lpVtbl -> getErrorChar(This,plChar)

#define IScriptErrorList_getErrorCode(This,plCode)	\
    (This)->lpVtbl -> getErrorCode(This,plCode)

#define IScriptErrorList_getErrorMsg(This,pstr)	\
    (This)->lpVtbl -> getErrorMsg(This,pstr)

#define IScriptErrorList_getErrorUrl(This,pstr)	\
    (This)->lpVtbl -> getErrorUrl(This,pstr)

#define IScriptErrorList_getAlwaysShowLockState(This,pfAlwaysShowLocked)	\
    (This)->lpVtbl -> getAlwaysShowLockState(This,pfAlwaysShowLocked)

#define IScriptErrorList_getDetailsPaneOpen(This,pfDetailsPaneOpen)	\
    (This)->lpVtbl -> getDetailsPaneOpen(This,pfDetailsPaneOpen)

#define IScriptErrorList_setDetailsPaneOpen(This,fDetailsPaneOpen)	\
    (This)->lpVtbl -> setDetailsPaneOpen(This,fDetailsPaneOpen)

#define IScriptErrorList_getPerErrorDisplay(This,pfPerErrorDisplay)	\
    (This)->lpVtbl -> getPerErrorDisplay(This,pfPerErrorDisplay)

#define IScriptErrorList_setPerErrorDisplay(This,fPerErrorDisplay)	\
    (This)->lpVtbl -> setPerErrorDisplay(This,fPerErrorDisplay)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id] */ HRESULT STDMETHODCALLTYPE IScriptErrorList_advanceError_Proxy( 
    IScriptErrorList __RPC_FAR * This);


void __RPC_STUB IScriptErrorList_advanceError_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IScriptErrorList_retreatError_Proxy( 
    IScriptErrorList __RPC_FAR * This);


void __RPC_STUB IScriptErrorList_retreatError_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IScriptErrorList_canAdvanceError_Proxy( 
    IScriptErrorList __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pfCanAdvance);


void __RPC_STUB IScriptErrorList_canAdvanceError_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IScriptErrorList_canRetreatError_Proxy( 
    IScriptErrorList __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pfCanRetreat);


void __RPC_STUB IScriptErrorList_canRetreatError_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IScriptErrorList_getErrorLine_Proxy( 
    IScriptErrorList __RPC_FAR * This,
    /* [retval][out] */ LONG __RPC_FAR *plLine);


void __RPC_STUB IScriptErrorList_getErrorLine_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IScriptErrorList_getErrorChar_Proxy( 
    IScriptErrorList __RPC_FAR * This,
    /* [retval][out] */ LONG __RPC_FAR *plChar);


void __RPC_STUB IScriptErrorList_getErrorChar_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IScriptErrorList_getErrorCode_Proxy( 
    IScriptErrorList __RPC_FAR * This,
    /* [retval][out] */ LONG __RPC_FAR *plCode);


void __RPC_STUB IScriptErrorList_getErrorCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IScriptErrorList_getErrorMsg_Proxy( 
    IScriptErrorList __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pstr);


void __RPC_STUB IScriptErrorList_getErrorMsg_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IScriptErrorList_getErrorUrl_Proxy( 
    IScriptErrorList __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pstr);


void __RPC_STUB IScriptErrorList_getErrorUrl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IScriptErrorList_getAlwaysShowLockState_Proxy( 
    IScriptErrorList __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pfAlwaysShowLocked);


void __RPC_STUB IScriptErrorList_getAlwaysShowLockState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IScriptErrorList_getDetailsPaneOpen_Proxy( 
    IScriptErrorList __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pfDetailsPaneOpen);


void __RPC_STUB IScriptErrorList_getDetailsPaneOpen_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IScriptErrorList_setDetailsPaneOpen_Proxy( 
    IScriptErrorList __RPC_FAR * This,
    BOOL fDetailsPaneOpen);


void __RPC_STUB IScriptErrorList_setDetailsPaneOpen_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IScriptErrorList_getPerErrorDisplay_Proxy( 
    IScriptErrorList __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pfPerErrorDisplay);


void __RPC_STUB IScriptErrorList_getPerErrorDisplay_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IScriptErrorList_setPerErrorDisplay_Proxy( 
    IScriptErrorList __RPC_FAR * This,
    BOOL fPerErrorDisplay);


void __RPC_STUB IScriptErrorList_setPerErrorDisplay_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IScriptErrorList_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_CScriptErrorList;

#ifdef __cplusplus

class DECLSPEC_UUID("EFD01300-160F-11d2-BB2E-00805FF7EFCA")
CScriptErrorList;
#endif
#endif /* __SHDocVw_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\exdispid.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES.
//
#ifndef EXDISPID_H_
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright 1995-1998 Microsoft Corporation. All Rights Reserved.
//
//  File: exdispid.h
//
//--------------------------------------------------------------------------


//
// Dispatch IDS for IExplorer Dispatch Events.
//
#define DISPID_BEFORENAVIGATE     100   // this is sent before navigation to give a chance to abort
#define DISPID_NAVIGATECOMPLETE   101   // in async, this is sent when we have enough to show
#define DISPID_STATUSTEXTCHANGE   102
#define DISPID_QUIT               103
#define DISPID_DOWNLOADCOMPLETE   104
#define DISPID_COMMANDSTATECHANGE 105
#define DISPID_DOWNLOADBEGIN      106
#define DISPID_NEWWINDOW          107   // sent when a new window should be created
#define DISPID_PROGRESSCHANGE     108   // sent when download progress is updated
#define DISPID_WINDOWMOVE         109   // sent when main window has been moved
#define DISPID_WINDOWRESIZE       110   // sent when main window has been sized
#define DISPID_WINDOWACTIVATE     111   // sent when main window has been activated
#define DISPID_PROPERTYCHANGE     112   // sent when the PutProperty method is called
#define DISPID_TITLECHANGE        113   // sent when the document title changes
#define DISPID_TITLEICONCHANGE    114   // sent when the top level window icon may have changed.

#define DISPID_FRAMEBEFORENAVIGATE    200
#define DISPID_FRAMENAVIGATECOMPLETE  201
#define DISPID_FRAMENEWWINDOW         204

#define DISPID_BEFORENAVIGATE2              250           // hyperlink clicked on
#define DISPID_NEWWINDOW2                   251
#define DISPID_NAVIGATECOMPLETE2            252           // UIActivate new document
#define DISPID_ONQUIT                       253
#define DISPID_ONVISIBLE                    254           // sent when the window goes visible/hidden
#define DISPID_ONTOOLBAR                    255           // sent when the toolbar should be shown/hidden
#define DISPID_ONMENUBAR                    256           // sent when the menubar should be shown/hidden
#define DISPID_ONSTATUSBAR                  257           // sent when the statusbar should be shown/hidden
#define DISPID_ONFULLSCREEN                 258           // sent when kiosk mode should be on/off
#define DISPID_DOCUMENTCOMPLETE             259           // new document goes ReadyState_Complete
#define DISPID_ONTHEATERMODE                260           // sent when theater mode should be on/off
#define DISPID_ONADDRESSBAR                 261           // sent when the address bar should be shown/hidden
#define DISPID_WINDOWSETRESIZABLE           262           // sent to set the style of the host window frame
#define DISPID_WINDOWCLOSING                263           // sent before script window.close closes the window 
#define DISPID_WINDOWSETLEFT                264           // sent when the put_left method is called on the WebOC
#define DISPID_WINDOWSETTOP                 265           // sent when the put_top method is called on the WebOC
#define DISPID_WINDOWSETWIDTH               266           // sent when the put_width method is called on the WebOC
#define DISPID_WINDOWSETHEIGHT              267           // sent when the put_height method is called on the WebOC 
#define DISPID_CLIENTTOHOSTWINDOW           268           // sent during window.open to request conversion of dimensions
#define DISPID_SETSECURELOCKICON            269           // sent to suggest the appropriate security icon to show
#define DISPID_FILEDOWNLOAD                 270           // Fired to indicate the File Download dialog is opening
#define DISPID_NAVIGATEERROR                271           // Fired to indicate the a binding error has occured
#define DISPID_PRIVACYIMPACTEDSTATECHANGE   272           // Fired when the user's browsing experience is impacted
#define DISPID_NEWWINDOW3                   273
#define DISPID_VIEWUPDATE                   281           // Fired when the contents of a shell browser window change
#define DISPID_SETPHISHINGFILTERSTATUS      282           // Fired by the Phishing Filter API to signal what state the analysis is in
#define DISPID_WINDOWSTATECHANGED           283           // Fired to indicate that the browser window's visibility or enabled state has changed

// Printing events
#define DISPID_PRINTTEMPLATEINSTANTIATION   225           // Fired to indicate that a print template is instantiated
#define DISPID_PRINTTEMPLATETEARDOWN        226           // Fired to indicate that a print templete is completely gone 
#define DISPID_UPDATEPAGESTATUS             227           // Fired to indicate that the spooling status has changed

// define the events for the shell window list
#define DISPID_WINDOWREGISTERED             200           // Window registered
#define DISPID_WINDOWREVOKED                201           // Window Revoked

#define DISPID_RESETFIRSTBOOTMODE       1
#define DISPID_RESETSAFEMODE            2
#define DISPID_REFRESHOFFLINEDESKTOP    3
#define DISPID_ADDFAVORITE              4
#define DISPID_ADDCHANNEL               5
#define DISPID_ADDDESKTOPCOMPONENT      6
#define DISPID_ISSUBSCRIBED             7
#define DISPID_NAVIGATEANDFIND          8
#define DISPID_IMPORTEXPORTFAVORITES    9
#define DISPID_AUTOCOMPLETESAVEFORM     10
#define DISPID_AUTOSCAN                 11
#define DISPID_AUTOCOMPLETEATTACH       12
#define DISPID_SHOWBROWSERUI            13
#define DISPID_ADDSEARCHPROVIDER        14
#define DISPID_RUNONCESHOWN             15
#define DISPID_SKIPRUNONCE              16
#define DISPID_CUSTOMIZESETTINGS        17
#define DISPID_SQMENABLED               18
#define DISPID_PHISHINGENABLED          19
#define DISPID_BRANDIMAGEURI            20
#define DISPID_SKIPTABSWELCOME          21
#define DISPID_DIAGNOSECONNECTION       22
#define DISPID_CUSTOMIZECLEARTYPE       23
#define DISPID_ISSEARCHPROVIDERINSTALLED 24
#define DISPID_ISSEARCHMIGRATED         25
#define DISPID_DEFAULTSEARCHPROVIDER    26
#define DISPID_RUNONCEREQUIREDSETTINGSCOMPLETE 27
#define DISPID_RUNONCEHASSHOWN          28
#define DISPID_SEARCHGUIDEURL           29
#define DISPID_SHELLUIHELPERLAST        30

#define DISPID_ADVANCEERROR             10
#define DISPID_RETREATERROR             11
#define DISPID_CANADVANCEERROR          12
#define DISPID_CANRETREATERROR          13
#define DISPID_GETERRORLINE             14
#define DISPID_GETERRORCHAR             15
#define DISPID_GETERRORCODE             16
#define DISPID_GETERRORMSG              17
#define DISPID_GETERRORURL              18
#define DISPID_GETDETAILSSTATE          19
#define DISPID_SETDETAILSSTATE          20
#define DISPID_GETPERERRSTATE           21
#define DISPID_SETPERERRSTATE           22
#define DISPID_GETALWAYSSHOWLOCKSTATE   23

// Dispatch IDS for ShellFavoritesNameSpace Dispatch Events.
//
#define DISPID_FAVSELECTIONCHANGE       1
#define DISPID_SELECTIONCHANGE          2
#define DISPID_DOUBLECLICK              3
#define DISPID_INITIALIZED              4

#define DISPID_MOVESELECTIONUP          1
#define DISPID_MOVESELECTIONDOWN        2
#define DISPID_RESETSORT                3
#define DISPID_NEWFOLDER                4
#define DISPID_SYNCHRONIZE              5
#define DISPID_IMPORT                   6
#define DISPID_EXPORT                   7
#define DISPID_INVOKECONTEXTMENU        8
#define DISPID_MOVESELECTIONTO          9
#define DISPID_SUBSCRIPTIONSENABLED     10
#define DISPID_CREATESUBSCRIPTION       11
#define DISPID_DELETESUBSCRIPTION       12
#define DISPID_SETROOT                  13
#define DISPID_ENUMOPTIONS              14
#define DISPID_SELECTEDITEM             15
#define DISPID_ROOT                     16
#define DISPID_DEPTH                    17
#define DISPID_MODE                     18
#define DISPID_FLAGS                    19
#define DISPID_TVFLAGS                  20
#define DISPID_NSCOLUMNS                21
#define DISPID_COUNTVIEWTYPES           22
#define DISPID_SETVIEWTYPE              23
#define DISPID_SELECTEDITEMS            24
#define DISPID_EXPAND                   25
#define DISPID_UNSELECTALL              26

#define EXDISPID_H_
#endif // EXDISPID_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\fdrm.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//

// **************************************************************************
//  APIs for dealing with File Base Digital Rights Managed (FDRM) content
//                                  
//  FileDrmIsDRM                    Determine if an object is FDRM protected
//  FileDrmCreateFile               Open a file containing FDRM content
//  FileDrmCreateForwardableContent Create forwardable version of content
//  FileDrmNotifyEnable             Enable FDRM provider notifications
//  FileDrmNotifyDisable            Disable FDRM provider notifications
//  FileDrmShowLicenseInfo          Show rights associated with an object
//  FileDrmHandleError              Display error UI / try to correct problem
//  FileDrmRenewRights              Renews the rights for a FDRM object
//  FileDrmGetMetric                Retrieve FDRM metric
//  FileDrmVerifyRights             Verify that an object can be used
//  FileDrmCommitRights             Commits the rights used by an object
//  FileDrmDelete                   Delete an object and rights
//  FileDrmStoreContent             Stores protected content on the device
// **************************************************************************

#ifndef FDRM_H
#define FDRM_H

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

// **************************************************************************
// ERROR CODES
//
// [SUCCESS]
//      S_FDRM_NOPROVIDER
//          API call succeeded but no FDRM provider is installed.
//
//      S_FDRM_NOTDRMOBJECT
//          API call succeeded but the passed in  object is not FDRM protected.
//
// {ERROR]
//      E_FDRM_FILEDELETED
//          Object did not have rights and could not be reactived. User choose
//           to delete the object.
//
//      E_FDRM_LICENSEPENDING
//          Object cannot be used now but there is an outstanding request for 
//          some type of rights renewal
//
//      E_FDRM_CANCELLED
//          User chose not to use object with prompt based rights
//
//      E_FDRM_NOTDRMOBJECT
//          API call failed since the passed in object was not FDRM protected.
//
//      E_FDRM_NOTALLOWED
//          Requested operation is not allowed for this object or object does
//          not have sufficient rights to be used.
//
//      E_FDRM_NOFORWARDRIGHTS
//          Object does not have rights to be forwarded
//
//      E_FDRM_NONOTIFY
//          Object was never registered for notifications
//
//      E_FDRM_NOPROVIDER
//          API call failed since no FDRM provider was installed.
//
//      E_FDRM_UNKNOWNMETRIC
//          Unknown metric type requested from FDRM_GetMetric.
//
//      E_FDRM_ERRORNOTHANDLED
//          Error could not be handled by FDRM_HandleError. 
//
// **************************************************************************

// Define some names for results of HRESULT_FROM_WIN32
#define E_INSUFFICIENT_BUFFER   HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)
#define E_FILE_NOT_FOUND        HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)

#define FACILITY_FDRM           FACILITY_ITF

// Start HRESULT codes at 512 to avoid conflicting with COM-defined codes
#define CODE_OFFSET             0x0200
#define S_FDRM_NOTDRMOBJECT     MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_FDRM, (CODE_OFFSET + 3))
#define S_FDRM_NOPROVIDER       MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_FDRM, (CODE_OFFSET + 7))

#define E_FDRM_FILEDELETED      MAKE_HRESULT(SEVERITY_ERROR, FACILITY_FDRM, (CODE_OFFSET + 0))
#define E_FDRM_LICENSEPENDING   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_FDRM, (CODE_OFFSET + 1))
#define E_FDRM_CANCELLED        MAKE_HRESULT(SEVERITY_ERROR, FACILITY_FDRM, (CODE_OFFSET + 2))
#define E_FDRM_NOTDRMOBJECT     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_FDRM, (CODE_OFFSET + 3))
#define E_FDRM_NOTALLOWED       MAKE_HRESULT(SEVERITY_ERROR, FACILITY_FDRM, (CODE_OFFSET + 4))
#define E_FDRM_NOFORWARDRIGHTS  MAKE_HRESULT(SEVERITY_ERROR, FACILITY_FDRM, (CODE_OFFSET + 5))
#define E_FDRM_NONOTIFY         MAKE_HRESULT(SEVERITY_ERROR, FACILITY_FDRM, (CODE_OFFSET + 6))
#define E_FDRM_NOPROVIDER       MAKE_HRESULT(SEVERITY_ERROR, FACILITY_FDRM, (CODE_OFFSET + 7))
#define E_FDRM_UNKNOWNMETRIC    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_FDRM, (CODE_OFFSET + 8))
#define E_FDRM_ERRORNOTHANDLED  MAKE_HRESULT(SEVERITY_ERROR, FACILITY_FDRM, (CODE_OFFSET + 9))

// **************************************************************************
// Bitmasks for various rights associated with content
// **************************************************************************
#define FDRRF_PLAY           0x00000001      // Play audio/video content
#define FDRRF_DISPLAY        0x00000002      // Display images
#define FDRRF_EXECUTE        0x00000004      // Execute applications
#define FDRRF_PRINT          0x00000008      // Print content
#define FDRRF_FORWARD        0x00000010      // Content can be forwarded    

// **************************************************************************
//  Bitmask flags to control FileDrmGetForwardContent API
// **************************************************************************
#define FDRCF_BARE           0x00000001      // Bare file
#define FDRCF_MIMEENCODED    0x00000002      // Add needed MIME headers

// **************************************************************************
//  Bitmask flags to control FileDrmVerifyRights and FileDrmCommitRights
//
//      FDRVF_NOUI      Supress all UI display. This allows the calling 
//                      application to ensure that this call will not block
//                      waiting for user input.
//
//      FDRVF_NORENEW   Does not attempt to update the rights associated with
//                      a piece of content (either through user interaction
//                      or automatically). 
//                      
//      FDRVF_VERIFY_CONTINUE   Specified when FileDrmCommitRights has been
//                              called and returned success for a piece of
//                              content and the consuming app of the content
//                              is still consuming the same isntance of the 
//                              content but needs to reverify rights. For
//                              example a media player might begin playing a
//                              song but be interrrupted by a phone call. Once
//                              the phone call completes the media player
//                              will call FileDrmVerifyRights to verify that
//                              it still has rights to continue playing that
//                              content. This flag may allow content to continue
//                              being used even if there are no longer valid.
//                              For instance, if the content has restrictions on
//                              the number of times it can be used and that 
//                              usage count went to zero in the last call to
//                              FileDrmCommitRights then the user should still
//                              be allowed to use that content until is has 
//                              been completely consumed.
// **************************************************************************
#define FDRVF_NOUI              0x00000001      // Do not show any UI
#define FDRVF_NORENEW           0x00000002      // No rights renewal
#define FDRVF_VERIFY_CONTINUE   0x00000004      // Verify continued use of content

// Status values returned from FileDrmVerifyRights and FileDrmVerifyRightsEx
#define FDRVS_USER_CAN_UPDATE   0x00000001      // Right invalid but user can update
#define FDRVS_UPDATE_PENDING    0x00000002      // A rights update is pending
#define FDRVS_EXPIRABLE         0x00000004      // Rights are currently valid but can expire

// **************************************************************************
// Bitmask flags to control FileDrmHandleError
// **************************************************************************
// Set by calling app
#define FDRHF_NOCORRECT      0x00000001      // Do not try to correct error

// Set by FileDrmHandleError
#define FDRHF_RETRY          0x00010000      // Calling app should retry op.
#define FDRHF_RIGHTSPENDING  0x00020000      // Rights update pending

// **************************************************************************
// FDRMMETRIC
// 
// Purpose: Metric types that can retrieved using FileDrmGetMetric call
//
// Note: All times are returned in milliseconds
// **************************************************************************
typedef enum tagFDRMMETRIC
{
    FDRM_METRIC_PREVIEW_TIME,       // allowed preview time
    FDRM_METRIC_DELAY_TIME,         // delay before prompting to use rights
    FDRM_METRIC_REVERIFY_TIME       // How often to re-verify rights when using
                                    // content in a continuous manner
} FDRMMETRIC;


// *************************************************************************
//  FILTER Identifiers
// *************************************************************************

// {5A3A54DD-209F-48e6-91DB-6A49F9238413}
DEFINE_GUID(FDRMFT_NONE, 0x5a3a54dd, 0x209f, 0x48e6, 0x91, 0xdb, 0x6a, 0x49, 0xf9, 0x23, 0x84, 0x13);

// {35AB44BA-B7D0-4548-9C3B-6864E9D08281}
DEFINE_GUID(FDRMFT_RINGTONES, 0x35ab44ba, 0xb7d0, 0x4548, 0x9c, 0x3b, 0x68, 0x64, 0xe9, 0xd0, 0x82, 0x81);

// {B7EADA14-F373-4e12-BF17-0722B64362D5}
DEFINE_GUID(FDRMFT_WALLPAPER, 0xb7eada14, 0xf373, 0x4e12, 0xbf, 0x17, 0x7, 0x22, 0xb6, 0x43, 0x62, 0xd5);



// **************************************************************************
// Function Name:   FileDrmIsFDRM
// 
// Purpose: Quickly determines if an object is FDRM protected
//
// Arguments:
//      [IN] pszFile
//          The fully qualified path to the file being checked, including the
//          file extension.
//
//      [OUT] pfDRM
//          A pointer to a BOOL variable which be set to TRUE if the object
//          pointed to by the file is DRM protected; FALSE otherwise
//
// Return Values:
//      HRESULT
//          The function is free to return any HRESULT and the application 
//          should use the SUCCEEDED/FAILED macros to check the results. In
//          addition the following HRESULT codes may be returned
//
//      [SUCCESS]
//          S_FDRM_NOPROVIDER
//              The value pointed to by pfDRM will be FALSE in this case
//
//          S_FDRM_NOTDRMOBJECT
//              The value pointed to by pfDRM will be FALSE in this case
//
// Description:     This function allows an application to quickly determine if
//                  an object is DRM protected. This allows an application to
//                  display an indication that content is DRM protected.
// **************************************************************************
HRESULT FileDrmIsDRM (LPCTSTR pszFile, 
                      PBOOL pfDRM);


// **************************************************************************
// Function Name:   FileDrmCreateFile
// 
// Purpose:         Allow a DRM-aware application to open a DRM protected
//                  object. This function is to be used in place of the 
//                  standard WIN32 CreateFile API.
//
// Arguments:       See CreateFile() for full details of each parameter.
//      [IN] pszFileName
//          The fully qualified path to the file to be opened
//
//      [IN] dwDesiredAccess
//          Type of access to the object.
//
//      [IN] dwShareMode
//          Share mode for the object.
//
//      [IN] lpSecurityAttributes
//          Ignored; set to NULL
//
//      [IN] dwCreationDisposition
//          How to handle existing/new files
//
//      [IN] dwFlagsAndAttributes
//          File attributes for the file.
//
//      [IN] hTemplateFile
//          Ignored; set to NULL
//
//      [OUT] phFile
//          Pointer to a handle variable that will hold the file handle if the
//          call is successful.    
//
// Return Values:
//      In addition to the HRESULT return code the value pointed to by phFile
//      must be set to INVALID_HANDLE_VALUE if an error is returned.
//
//      HRESULT
//          The function is free to return any HRESULT and the application 
//          should use the SUCCEEDED/FAILED macros to check the results. In
//          addition the following HRESULT codes may be returned
//
//      [SUCCESS]
//          S_FDRM_NOPROVIDER
//              The returned rights structure will allow for all rights.
//
//          S_FDRM_NOTDRMOBJECT
//              The returned rights structure will allow for all rights.
//
// Side effects:    File is opened or created as appropriate.
//
// Notes: Use CloseHandle to close the handle returned from this function.
// 
// Description:
//      This function is to be used in place of the standard WIN32 CreateFile
//      API by applications that are "FDRM Aware". With some exceptions as
//      detailed below It behaves the same way as CreateFile and returns any 
//      error that occurs during the call as an the HRESULT created by 
//      HRESULT_FROM_WIN32 called on the value returned from GetLastError().
//
//      When the following conditions are true the FileDrmCreateFile works
//      differently than CreateFile:
//
//      Case 1: Opening FDRM content for use
//
//          1. An FDRM provider is installed.
//          2. The file being created already exists and contains FDRM
//             protected content.
//          3. dwDesiredAccess is set to GENERIC_READ
//          4. dwCreationDisposition is set to OPEN_EXISTING
//
//          In this case FileDrmCreateFile opens the file in such a way that 
//          subsequent calls to ReadFile will return the unencrypted version
//          of the files content such that it can be used by the application.
//          
//      Case 2: Attempting to open FDRM content for write access
//
//          1. An FDRM provider is installed.
//          2. The file being created already exists and contains FDRM
//             protected content
//          3. dwDesiredAccess is set to GENERIC_WRITE
//
//          In this case FileDrmCreateFile will fail to open the file (to 
//          prevent applications from inadvertently overwriting protected
//          content).
//
//      Case 3: Attempting to delete/truncate FDRM content
//
//          1. An FDRM provider is installed.
//          2. The file being created already exists and contains FDRM
//             protected content
//          3. dwCreationDisposition is set to CREATE_ALWAYS or 
//             TRUNCATE_EXISTING.
//
//          In this case FileDrmCreateFile will fail to open the file (to 
//          prevent applications from inadvertently overwriting protected
//          content).
// **************************************************************************
HRESULT FileDrmCreateFile (LPCTSTR pszFileName,
                           DWORD dwDesiredAccess,
                           DWORD dwShareMode,
                           LPSECURITY_ATTRIBUTES lpSecurityAttributes,
                           DWORD dwCreationDisposition,
                           DWORD dwFlagsAndAttributes,
                           HANDLE hTemplateFile,
                           PHANDLE phFile);


// **************************************************************************
// Function Name:   FileDrmCreateForwardableContent
// 
// Purpose: Create a file containing a DRM protected object in a way that 
//          allows it to be forwarded to another user.
//
// Arguments:
//      [IN] pszFileName
//          The fully qualified path to the file to be forwarded.
//
//      [IN] dwFlags
//          Flags to control the format of the generated document. See the 
//          DRCF_* flags for defined values
//
//      [IN] pszOutputFile
//          The fully qualified path for a file to hold the document
//
// Return Values:
//      HRESULT
//          The function is free to return any HRESULT and the application 
//          should use the SUCCEEDED/FAILED macros to check the results. In
//          addition the following HRESULT codes may be returned
//
//      [FAILURE]
//          E_FDRM_NOPROVIDER
//          E_FDRM_NOTDRMOBJECT
//          E_FDRM_NOFORWARDRIGHTS
//
// Side effects:    A new file is created holding the DRM protected content
// 
// Description:
//      Applications that want to forward content can use this API to package
//      format in such a way that it can be sent to another device.
// **************************************************************************
HRESULT FileDrmCreateForwardableContent (LPCTSTR pszFileName, 
                                         DWORD dwFlags,
                                         LPCTSTR pszOutputFile);


// **************************************************************************
// Function Name:   FileDrmNotifyEnable
// 
// Purpose: Register an application with the DRM provider for updates when
//          updated rights are received on the device.
//
// Arguments:
//      [IN] pszFileName 
//          Fully qualified path to the file to receive notifications for
//
//      [OUT] pszValueName
//          Pointer to a buffer to be filled with the name of a registry 
//          DWORD value that will be updated when the rights associated with 
//          the object change. The returned string must always be terminated
//          with a NUL character as long as cchValueLen is >= 1
//
//      [IN] cchValueLen 
//          Length of the pszValueName buffer. Uaing a buffer of size 
//          MAX_PATH will always be sufficient. Passing in a smaller buffer
//          will cause this function to return E_INSUFFICIENT_BUFFER if the
//          buffer is too small to hold the returned string (including the
//          NUL terminator).
//
// Return Values:
//      HRESULT
//          The function is free to return any HRESULT and the application 
//          should use the SUCCEEDED/FAILED macros to check the results. In
//          addition the following HRESULT codes may be returned
//
//      [FAILURE]
//          E_FDRM_NOPROVIDER
//          E_FDRM_NOTDRMOBJECT
//          E_INSUFFICIENTBUFFER
//
// Side effects:
//      On success the psValueName will be filled in with the name of a 
//      registry value that can be monitored by the application. A new 
//      registry value may have been created in the registry. These values 
//      will be under the key HKEY_CURRENT_USER\FDRM\Monitor.
// 
// Note:
//      Notification of expiration of time or count based rights is not
//      supported.
//
// Description:
//      An application that needs to know when a rights renewal has arrived
//      can use this function along with the RegistryNotifyxxxx functions to 
//      receive notifications from the DRM provider.
//
//      The DRM provider will take the passed in filename and generate the 
//      name of a registy value that will be used as a proxy for the file. 
//      The calling application can then register for registry notifications 
//      using this value.  When the DRM provider changes the rights store it 
//      will also write the new rights value (using the DRRF_* values) 
//      to that registry value.
//
//      The DRM provider will reference count calls to FileDrmNotifyEnable
//      and FileDrmNotifyDisable and only stop updating and remove the 
//      registry value when the reference count goes to 0. As well it will
//      monitor processes and remove all outstanding references to the 
//      notification upon process exit.
//
//      Registrations by multiple processes or threads within a single 
//      process that refer to the same filename must return the same registry
//      value name to be monitored.
//
//      The provider will also monitor calls to DeleteFile and remove any
//      outstanding notifications when a FDRM protected file is deleted.
// **************************************************************************
HRESULT FileDrmNotifyEnable (LPCTSTR pszFileName, 
                             LPTSTR pszValueName,
                             DWORD cchValueNameLen);


// **************************************************************************
// Function Name:   FileDrmNotifyDisable
// 
// Purpose: Allows the DRM provider to stop receiving notifications of
//          changes to the rights associated with a file.
//
// Arguments:
//      [IN] pszFileName 
//          Fully qualified path to the file that the application no longer 
//          wants to receive notifications for.
//
// Return Values:
//      HRESULT
//          The function is free to return any HRESULT and the application 
//          should use the SUCCEEDED/FAILED macros to check the results. In
//          addition the following HRESULT codes may be returned
//
//      [FAILURE]
//          E_FDRM_NOPROVIDER
//          E_FDRM_NOTDRMOBJECT
//          E_FDRM_NONOTIFY
//
// Description:
//      See description of FileDrmNotifyEnable
// **************************************************************************
HRESULT FileDrmNotifyDisable (LPCTSTR pszFileName);


// **************************************************************************
// Function Name:   FileDrmShowLicenseInfo
// 
// Purpose: Shows the rights associated with a DRM protected object
//
// Arguments:
//      [IN] hwndParent
//          Handle to the window that owns any UI elements (windows, dialog
//          boxes, or message boxes) displayed by this API.
//
//      [IN] pszFileName 
//          The path of the file to show license information for.
//
// Return Values:
//      HRESULT
//          The function is free to return any HRESULT and the application 
//          should use the SUCCEEDED/FAILED macros to check the results. In
//          addition the following HRESULT codes may be returned
//
//      [SUCCESS]
//          S_FDRM_NOPROVIDER
//          S_FDRM_NOTDRMOBJECT
//
// Description:
//      A dialog is presented to the user showing the rights associated with 
//      the file. This function returns when the user dismisses the dialog.
// **************************************************************************
HRESULT FileDrmShowLicenseInfo (HWND hwndParent,
                                LPCTSTR pszFileName);


// **************************************************************************
// Function Name:   FileDrmHandleError
// 
// Purpose: Displays an error dialog to the user when an error occurs while 
//          trying to use DRM content.
//
// Arguments:
//      [IN] hwndParent
//          Handle to the window that owns any UI elements (windows, dialog
//          boxes, or message boxes) displayed by this API.
//
//      [IN] hrError
//          The HRESULT error to display/handle
//
//      [IN] pszFileName 
//          The file associated with the error
//
//      [IN] dwFlags 
//          Flags controlling the API behavior. A bitmask comprised of FDRHF_* flags.
//
//      [OUT] pdwStatus
//          Status returned by FileDRMHandleError. A bitmask comprised ofr FDRHF_* flags.
//
// Return Values:
//      HRESULT
//          The function will only return the following HRESULTS. The 
//          application must use SUCCEEDED/FAILED macros to check the return.
//
//      [SUCCESS]
//          S_OK
//              The application may wish to check the FDRHF_RETRY and 
//              FDRHF_RIGHTSPENDING bits in *pdwFlags to control additional 
//              handling of the error.
//          
//      [FAILURE]
//          E_FDRM_ERRORNOTHANDLED
//              Applicaton must handle the error. This will occur either 
//              because the FDRM provider cannot handle the error or does not
//              recognize the error.
//
// Side effects:
//      If a rights renewal is requested by the user a network connection may
//      be established to send the renewal. Once the response is received a 
//      notification will be sent to registered applications.
// 
// Description:
//      When an error occurs while using one of the FDRM APIs this API can be
//      called to display error information to the user and (optionally) 
//      attempt to correct the error (most likely by offering the user the 
//      option to acquire additional rights or extend existing rights. If the
//      user requests new/updated rights the new/updated rights will arrive 
//      asynchronously. If the FDRHF_RETRY flag is set upon return from this 
//      function the application may retry the operation that failed.
// **************************************************************************
HRESULT FileDrmHandleError (HWND            hwndParent, 
                            HRESULT         hrError,   
                            LPCTSTR         pszFileName,
                            DWORD           dwFlags,
                            PDWORD          pdwStatus);


// **************************************************************************
// Function Name:   FileDrmRenewRights
// 
// Purpose: Renew the rights associated with DRM protected object
//
// Arguments:
//      [IN] hwndParent
//          Handle to the window that owns any UI elements (windows, dialog
//          boxes, or message boxes) displayed by this API.
//
//      [IN] pszFileName
//          Path to the file containing the DRM protected object
//
// Return Values:
//      HRESULT
//          The function is free to return any HRESULT and the application 
//          should use the SUCCEEDED/FAILED macros to check the results. In
//          addition the following HRESULT codes may be returned
//
//      [SUCCESS]
//          S_FDRM_NOPROVIDER
//          S_FDRM_NOTDRMOBJECT
//
//      [FAILURE]
//          E_FDRM_NOTALLOWED
//              Rights renewal is not allowed for this object type
//
// Side effects:
//      A rights renewal request is generated. This may cause a network 
//      connection to be opened
// 
// Description:
//      This API allows an application to renew rights associated with a DRM 
//      protected object. In most cases this will be handled by the DRM 
//      provider when FileDrmHandleError is called. New/updated rights will 
//      arrive asynchronously.
// **************************************************************************
HRESULT FileDrmRenewRights (HWND hwndParent,
                            LPCTSTR pszFileName);


// **************************************************************************
// Function Name:   FileDrmGetMetric
// 
// Purpose: Retrieves metrics related to using DRM protected objects
//
// Arguments:
//      [IN] drmID
//          Identifier to select which metric you want.
//
//      [OUT] pdwMetric
//          Pointer to a dword variable that will hold the metric
//
// Return Values:
//      HRESULT
//          The function is free to return any HRESULT and the application 
//          should use the SUCCEEDED/FAILED macros to check the results. In
//          addition the following HRESULT codes may be returned
//
//      [FAILURE]
//          E_FDRM_UNKNOWNMETRIC
//
// **************************************************************************
HRESULT FileDrmGetMetric (FDRMMETRIC drmID,
                          DWORD *pdwMetric);

// **************************************************************************
// Function Name:   FileDrmVerifyRights
// 
// Purpose: Allows an application to verify that an object has needed rights 
//          before using DRM protected objects
//
// Arguments:
//      [IN] hwndParent
//          Handle to the window that owns any UI elements (windows, dialog
//          boxes, or message boxes) displayed by this API.
//
//      [IN] pszFileName
//          Path to the file containing the DRM protected object
//
//      [IN] dwRight
//          The right the application wants to use. Only one right may be specified.
//
//      [IN] dwFlags
//          Flags to control the behavior of FDRM_VerifyRights. This is a 
//          bitmap of FDRVF_* flag values.
//
// Return Values:
//      HRESULT
//          The function is free to return any HRESULT and the application 
//          should use the SUCCEEDED/FAILED macros to check the results. In
//          addition the following HRESULT codes may be returned
//
//      [SUCCESS]
//          S_FDRM_NOPROVIDER
//          S_FDRM_NOTDRMOBJECT
//
//      [FAILURE]
//          E_FDRM_FILEDELETED
//          E_FDRM_CANCELLED
//          E_FDRM_LICENSEPENDING
//          E_FDRM_NOTALLOWED
//
// Description:
//      Before an app can use a DRM protected object it must call this API
//      to ensure that the object can be used as intended. This API will
//      verify if the object has the appropriate rights and if necessary will
//      prompt the user if they want to consume rights or renew expired
//      rights. 
// **************************************************************************
HRESULT FileDrmVerifyRights (HWND           hwndParent,
                             LPCTSTR        pszFileName, 
                             DWORD          dwRight,
                             DWORD          dwFlags,
                             PDWORD         pdwRightsStatus);


// **************************************************************************
// Function Name:   FileDrmCommitRights
// 
// Purpose: Allows an application to commits the rights used
//
// Arguments:
//      [IN] hFile
//          Handle to the file containing the object to be used. File must 
//          have been opened using FileDrmCreateFile ().
//
//      [IN] dwRight
//          The right the application wants to use. Only one right may be specified.
//
//      [IN] dwFlags
//          Flags to control the behavior of FileDrmCommitRights. This is a 
//          bitmap of FDRVF_* flag values.
//
// Return Values:
//      HRESULT
//          The function is free to return any HRESULT and the application 
//          should use the SUCCEEDED/FAILED macros to check the results. In
//          addition the following HRESULT codes may be returned
//
//      [SUCCESS]
//          S_FDRM_NOPROVIDER
//          S_FDRM_NOTDRMOBJECT
//
//      [FAILURE]
//          E_FDRM_NOTALLOWED
//          E_FDRM_LICENSEPENDING
//
// Description: Commits the rights associated with an object. The calling
//              application must call FileDrmVerifyRights before this call.
// **************************************************************************
HRESULT FileDrmCommitRights (HANDLE hFile, 
                             DWORD dwRight,
                             DWORD dwFlags);


// **************************************************************************
// Function Name:   FileDrmDeleteFile
// 
// Purpose:         Delete a DRM object as well as the associated rights
//
// Arguments:
//      [IN] pszFileName
//          Path to the file containing the DRM protected object
//
// Return Values:
//      HRESULT
//          The function is free to return any HRESULT and the application 
//          should use the SUCCEEDED/FAILED macros to check the results. In
//          addition the following HRESULT codes may be returned
//
//      [SUCCESS]
//          S_FDRM_NOPROVIDER
//          S_FDRM_NOTDRMOBJECT
//
// Side effects:
//      Rights store updated. File containing object deleted.
// 
// Description:
//      This API deletes both a DRM object and the associated rights.
// **************************************************************************
HRESULT FileDrmDeleteFile (LPCTSTR pszFileName);


// **************************************************************************
// Function Name:   FileDrmStoreContent
// 
// Purpose: Read a file containing MIME-encoded content to be DRM protected 
//          and create the device-locked version of that content as well as 
//          any associated rights or pending rights.
//
// Arguments:
//      [IN] pszInputFileName
//          Fully qualified path to the file containing MIME to be cracked. 
//          This file starts with the Content-Type ("Content-type: ...")
//          optionally preceeded by linear-white-space
//
//      [IN] pszOutputFileName
//          Fully qualified path to the file to hold the object contained 
//          within the MIME message
//
//      pvReserved
//          Reserved. Must be set to NULL
//
//      [OUT] pszMimeType
//          A pointer to the buffer to be filled in with the type of the 
//          embedded object ("image/jpeg"). If this pointer is NULL then this
//          call is to be treated as a request to obtain the size of the
//          buffer needed to hold the MIME type string.
//
//      [IN/OUT] pcchMimeTypeLen
//          A pointer to a DWORD holding the length of the pszMimeType buffer
//          in characters. On entry this value will be the size of the passed
//          buffer. On exit this will be set to the length of the MIME type
//          string including the NUL terminator.
//
// Return Values:
//      HRESULT
//          The function is free to return any HRESULT and the application 
//          should use the SUCCEEDED/FAILED macros to check the results. In
//          addition the following HRESULT codes may be returned
//
//      [FAILURE]
//          E_FDRM_NOPROVIDER
//          E_INSUFFICIENT_BUFFER
//              Output file not created and *pcchMimeTypeLen updated with 
//              needed buffer size
//
// Side effects:
//      A new file is created holding the DRM protected content. The original
//      file is deleted.
// **************************************************************************
HRESULT FileDrmStoreContent (LPCTSTR pszInputFileName, 
                             LPCTSTR pszOutputFileName,
                             LPVOID  pvReserved,
                             LPTSTR  pszMimeType,
                             DWORD  *pcchMimeTypeLen);

// **************************************************************************
// Function Name:   FileDrmVerifyRightsEx
// 
// Purpose: Allows an application to verify that an object has needed rights 
//          before using DRM protected objects. Also allows the user to filter
//          content by its intended use.
//
// Arguments:
//      [IN] hwndParent
//          Handle to the window that owns any UI elements (windows, dialog
//          boxes, or message boxes) displayed by this API.
//
//      [IN] pszFileName
//          Path to the file containing the DRM protected object
//
//      [IN] dwRight
//          The right the application wants to use. Only one right may be
//          specified.
//
//      [IN] dwFlags
//          Flags to control the behavior of FDRM_VerifyRights. This is a 
//          bitmap of FDRVF_* flag values.
//
//      [OUT} pdwRightsStatus
//          Additional information about the status of the right
//          associated with the content. One of the FDRVS_* values
//
//          FDRVS_USER_CAN_UPDATE   Right invalid but user can update
//          FDRVS_UPDATE_PENDING    A rights update is pending
//          FDRVS_EXPIRABLE         Right is currently valid but can
//                                  expire later
//      [IN] pGuidFilter
//          An indication of the intended purpose of the content. If
//          the content pointed to by pszFileName is DRM protected this
//          filter value is checked as well as the rights associated
//          with the content to determine if the content can be used. 
//  
// Return Values:
//      HRESULT
//          The function is free to return any HRESULT and the application 
//          should use the SUCCEEDED/FAILED macros to check the results. In
//          addition the following HRESULT codes may be returned
//
//      [SUCCESS]
//          S_FDRM_NOPROVIDER
//          S_FDRM_NOTDRMOBJECT
//
//      [FAILURE]
//          E_FDRM_FILEDELETED
//          E_FDRM_CANCELLED
//          E_FDRM_LICENSEPENDING
//          E_FDRM_NOTALLOWED
//
// Description:
//      Either this or the FileDrmVerifyRights API must be called before an
//      app can use a DRM protected object. This API will verify if the
//      object has the appropriate rights and if necessary will prompt the
//      user if they want to consume rights or renew expired rights.
// **************************************************************************
HRESULT FileDrmVerifyRightsEx (HWND     hwndParent,
                               LPCTSTR  pszFileName, 
                               DWORD    dwRight,
                               DWORD    dwFlags,
                               PDWORD   pdwRightsStatus,
                               LPGUID   pguidFilter);


#ifdef __cplusplus
}
#endif  // __cplusplus

#endif  // FDRM_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\fsdmgr.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*++


Module Name:

    fsdmgr.h

Abstract:

    This file contains external definitions for the WinCE FSD Manager (FSDMGR.DLL).

Revision History:

--*/

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

#ifndef FSDMGR_H
#define FSDMGR_H

#include <specstrings.h>
#include <storemgr.h>

#ifdef WINCEOEM
#include <extfile.h>
#include <diskio.h>
#endif

#ifndef HDSK
#define HDSK    DWORD
#endif

#ifndef HVOL
#define HVOL    DWORD
#endif

#ifndef PVOLUME
#define PVOLUME DWORD
#endif

#ifndef PFILE
#define PFILE   DWORD
#endif

#ifndef PSEARCH
#define PSEARCH DWORD
#endif

/*  FSD_DISK_INFO structure (returned by FSDMGR_GetDiskInfo):
 */
#define FDI_MBR             0x00000001  // device type has/needs an MBR
#define FDI_CHS_UNCERTAIN   0x00000002  // driver generated CHS values are suspect
#define FDI_UNFORMATTED     0x00000004  // low level format (DISK_IOCTL_FORMAT_MEDIA) needed
#define FDI_PAGEABLE        0x00000008  // device can be used for demand paging
#define FDI_READONLY        0x00000010  // device is read-only
#define FDI_RESERVED        0xffffffe0

typedef struct _FSD_DISK_INFO {
    DWORD   cSectors;
    DWORD   cbSector;
    DWORD   cCylinders;
    DWORD   cHeadsPerCylinder;
    DWORD   cSectorsPerTrack;
    DWORD   dwFlags;            // see FDI_* above
} FSD_DISK_INFO, *PFDI;

/*  FSD_BUFFER_INFO (used in FSD_SCATTER_GATHER_INFO):
 */
typedef struct _FSD_BUFFER_INFO {
    PBYTE   pBuffer;            // pointer to buffer
    DWORD   cbBuffer;           // size of buffer, in bytes
} FSD_BUFFER_INFO, *PFBI;


/*  FSD_SCATTER_GATHER_INFO (used by FSDMGR_ReadDiskEx and FSDMGR_WriteDiskEx):
 */
typedef DWORD (*PFNFSG)(struct _FSD_SCATTER_GATHER_INFO *pfsgi, struct _FSD_SCATTER_GATHER_RESULTS *pfsgr);

typedef struct _FSD_SCATTER_GATHER_INFO {
    DWORD   dwFlags;            // reserved (must be zero)
    DWORD   idDsk;              // disk ID (as passed to XXX_MountDisk)
    DWORD   dwSector;           // starting sector #
    DWORD   cSectors;           // number of sectors to transfer
    PFDI    pfdi;               // address of FSD_DISK_INFO
    DWORD   cfbi;               // count of FSD_BUFFER_INFO structures (can be zero)
    PFBI    pfbi;               // pointer to zero or more FSD_BUFFER_INFO structures
    PFNFSG  pfnCallBack;        // callback function
} FSD_SCATTER_GATHER_INFO, *PFSGI;


/*  FSD_SCATTER_GATHER_RESULTS (returned by FSDMGR_ReadWriteDiskEx and FSDMGR_WriteDiskEx):
 */
typedef struct _FSD_SCATTER_GATHER_RESULTS {
    DWORD   dwFlags;            // reserved
    DWORD   cSectorsTransferred;// total sectors transferred
} FSD_SCATTER_GATHER_RESULTS, *PFSGR;


#define FSD_VERSION_0   0
#define MAX_FSD_DESCRIPTOR 32

#define FSD_ATTRIBUTE_READONLY       0x1
#define FSD_ATTRIBUTE_XIP               0x2     // Indicates XIP support

#define FSD_FLAG_TRANSACTION_SAFE       0x1     // Performs transaction safe operations
#define FSD_FLAG_TRANSACT_WRITES        0x2     // Transacts write operations
#define FSD_FLAG_WFSC_SUPPORTED         0x4     // WriteFile ScatterGather supported
#define FSD_FLAG_LOCKFILE_SUPPORTED     0x8     // Implements Lockfile
#define FSD_FLAG_NETWORK                0x10    // Network filesystem
#define FSD_FLAG_RAMFS                  0x40    // RAM-based file system
#define FSD_FLAG_FILE_SECURITY_SUPPORTED 0x80   // Persistent file/directory security descriptors supported
#define FSD_FLAG_64BIT_FILES_SUPPORTED  0x100   // 64-bit file sizes and offsets supported

typedef struct _FSD_VOLUME_INFO {
    DWORD cbSize;
    DWORD dwFSVersion ; // Version that this FSD conforms to must be one of the defines above
    TCHAR szFSDDesc[MAX_FSD_DESCRIPTOR]; // FSD Name FAT, UDFS
    TCHAR szFSDSubType[MAX_FSD_DESCRIPTOR]; // Subtype FAT12, FAT16, FAT32
    DWORD dwAttributes;
    DWORD dwBlockSize; // This is a hint of the optimal block size for I/O operations.  For FAT this would be cluster size
    DWORD dwFlags;
} FSD_VOLUME_INFO, *PFSD_VOLUME_INFO;


/*  Interfaces exported by FSDMGR.DLL to FSDs
 */
DWORD  FSDMGR_GetDiskInfo(HDSK hDsk, PFDI pfdi);
DWORD  FSDMGR_GetPartInfo(HDSK hDsk, PPARTINFO pPartInfo);
DWORD  FSDMGR_GetStoreInfo(HDSK hDsk, PSTOREINFO pStoreInfo);
DWORD  FSDMGR_ReadDisk(HDSK hDsk, DWORD dwSector, DWORD cSectors, __out_bcount(cbBuffer) PBYTE pBuffer, DWORD cbBuffer);
DWORD  FSDMGR_WriteDisk(HDSK hDsk, DWORD dwSector, DWORD cSectors, __in_bcount(cbBuffer) PBYTE pBuffer, DWORD cbBuffer);
DWORD  FSDMGR_ReadDiskEx(PFSGI pfsgi, PFSGR pfsgr);
DWORD  FSDMGR_WriteDiskEx(PFSGI pfsgi, PFSGR pfsgr);
HVOL   FSDMGR_RegisterVolume(HDSK hDsk, PCWSTR pwsName, PVOLUME pVolume);
HVOL   FSDMGR_GetVolumeHandle(HDSK hDsk);
int    FSDMGR_GetVolumeName(HVOL hVol, __out_ecount(cchMax) PWSTR pwsName, int cchMax);
void   FSDMGR_DeregisterVolume(HVOL hVol);
HANDLE FSDMGR_CreateFileHandle(HVOL hVol, HANDLE hProc, PFILE pFile);
HANDLE FSDMGR_CreateSearchHandle(HVOL hVol, HANDLE hProc, PSEARCH pSearch);
BOOL   FSDMGR_DiskIoControl(HDSK hDsk, DWORD dwIoControlCode, __in_bcount_opt(nInBufSize) LPVOID lpInBuf, DWORD nInBufSize, __out_bcount_opt(nOutBufSize) LPVOID lpOutBuf, DWORD nOutBufSize, LPDWORD lpBytesReturned, LPOVERLAPPED lpOverlapped);
BOOL   FSDMGR_GetRegistryValue(HDSK hDsk, PCTSTR szValueName, PDWORD pdwValue);
BOOL   FSDMGR_GetRegistryString(HDSK hDsk, PCTSTR szValueName, __out_ecount(dwSize) PTSTR szValue, DWORD dwSize);
BOOL   FSDMGR_GetRegistryFlag(HDSK pDsk,const TCHAR *szValueName, PDWORD pdwFlag, DWORD dwSet);
LRESULT FSDMGR_GetMountFlags(HVOL hVol, DWORD* pMountFlags);
LRESULT FSDMGR_AsyncEnterVolume(HVOL hVol, HANDLE* phLock, LPVOID* ppLockData);
LRESULT FSDMGR_AsyncExitVolume(HANDLE hLock, LPVOID pLockData);
BOOL   FSDMGR_GetDiskName(HDSK pDsk, TCHAR *szDiskName);
BOOL   FSDMGR_AdvertiseInterface(const GUID *pGuid, LPCWSTR lpszName, BOOL fAdd);
DWORD  FSDMGR_FormatVolume(HDSK pDsk, LPVOID pParams);
DWORD  FSDMGR_ScanVolume(HDSK pDsk, LPVOID pParams);
DWORD  FSDMGR_CleanVolume(HDSK pDsk, LPVOID pParams);
LRESULT FSDMGR_ParseSecurityDescriptor (
    __in PSECURITY_ATTRIBUTES pSecurityAttributes,
    __out PSECURITY_DESCRIPTOR* ppSecurityDescriptor,
    __out DWORD* pSecurityDescriptorSize);

#ifdef WINCEOEM

// LCKMGR interfaces exported by FSDMGR to FSDs
#include <lockmgr.h>

// Caching functions
DWORD  FSDMGR_CreateCache(HDSK pDsk, DWORD dwStart, DWORD dwEnd, DWORD dwCacheSize, DWORD dwBlockSize, DWORD dwCreateFlags);
DWORD  FSDMGR_DeleteCache(DWORD dwCacheId);
DWORD  FSDMGR_ResizeCache(DWORD dwCacheId, DWORD dwSize, DWORD dwResizeFlags);
DWORD  FSDMGR_CachedRead(DWORD dwCacheId, DWORD dwBlockNum, DWORD dwNumBlocks, PVOID pBuffer, DWORD dwReadFlags);
DWORD  FSDMGR_CachedWrite(DWORD dwCacheId, DWORD dwBlockNum, DWORD dwNumBlocks, PVOID pBuffer, DWORD dwWriteFlags);
DWORD  FSDMGR_FlushCache(DWORD dwCacheId, PSECTOR_LIST_ENTRY pSectorList, DWORD dwNumEntries, DWORD dwFlushFlags);
DWORD  FSDMGR_SyncCache(DWORD dwCacheId, PSECTOR_LIST_ENTRY pSectorList, DWORD dwNumEntries, DWORD dwSyncFlags);
DWORD  FSDMGR_InvalidateCache(DWORD dwCacheId, PSECTOR_LIST_ENTRY pSectorList, DWORD dwNumEntries, DWORD dwFlags);
BOOL   FSDMGR_CacheIoControl(DWORD dwCacheId, DWORD dwIoControlCode, LPVOID lpInBuf, DWORD nInBufSize, LPVOID lpOutBuf, DWORD nOutBufSize, LPDWORD lpBytesReturned, LPOVERLAPPED lpOverlapped);
HDSK   FSDMGR_DeviceHandleToHDSK(HANDLE hDisk);
#endif

// Valid Flags for dwCreateFlags in FSDMGR_CreateCache
#define CACHE_FLAG_WARM      0x1
#define CACHE_FLAG_WRITEBACK 0x2

// Valid Flags for dwWriteFlags in FSDMGR_CachedWrite
#define CACHE_FORCE_WRITETHROUGH 0x1

// Valid Flags for dwFlushFlags in FSDMGR_FlushCache
#define CACHE_SKIP_DEVICE_FLUSH 0x1

// Return value for error in FSDMGR_CreateCache
#define INVALID_CACHE_ID (DWORD)-1

typedef BOOL(* PCLOSEVOLUME)(DWORD dwVolume);
typedef BOOL(* PCREATEDIRECTORYW)(DWORD dwVolume, PCWSTR pwsPathName, PSECURITY_ATTRIBUTES pSecurityAttributes);
typedef BOOL(* PREMOVEDIRECTORYW)(DWORD dwVolume, PCWSTR pwsPathName);
typedef DWORD(* PGETFILEATTRIBUTESW)(DWORD dwVolume, PCWSTR pwsFileName);
typedef BOOL(* PSETFILEATTRIBUTESW)(DWORD dwVolume, PCWSTR pwsFileName, DWORD dwAttributes);
typedef BOOL(* PDELETEFILEW)(DWORD dwVolume, PCWSTR pwsFileName);
typedef BOOL(* PMOVEFILEW)(DWORD dwVolume, PCWSTR pwsOldFileName, PCWSTR pwsNewFileName);
typedef BOOL(* PDELETEANDRENAMEFILEW)(DWORD dwVolume, PCWSTR pwsOldFileName, PCWSTR pwsNewFileName);
typedef BOOL(* PGETDISKFREESPACEW)(DWORD dwVolume, PCWSTR pwsPathName, PDWORD pSectorsPerCluster, PDWORD pBytesPerSector, PDWORD pFreeClusters, PDWORD pClusters);
typedef void(* PNOTIFY)(DWORD dwVolume, DWORD dwFlags);
typedef BOOL(* PREGISTERFILESYSTEMFUNCTION)(DWORD dwVolume, LPVOID pfn);
typedef HANDLE(* PFINDFIRSTFILEW)(DWORD dwVolume, HANDLE hProc, PCWSTR pwsFileSpec, PWIN32_FIND_DATAW pfd);
typedef BOOL(* PFINDNEXTFILEW)(DWORD dwSearch, PWIN32_FIND_DATAW pfd);
typedef BOOL(* PFINDCLOSE)(DWORD dwSearch);
typedef HANDLE(* PCREATEFILEW)(DWORD dwVolume, HANDLE hProc, PCWSTR pwsFileName, DWORD dwAccess, DWORD dwShareMode, PSECURITY_ATTRIBUTES pSecurityAttributes, DWORD dwCreate, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
typedef BOOL(* PREADFILE)(DWORD dwFile, PVOID pBuffer, DWORD cbRead, PDWORD pcbRead, OVERLAPPED *pOverlapped);
typedef BOOL(* PREADFILEWITHSEEK)(DWORD dwFile, PVOID pBuffer, DWORD cbRead, PDWORD pcbRead, OVERLAPPED *pOverlapped, DWORD dwLowOffset, DWORD dwHighOffset);
typedef BOOL(* PWRITEFILE)(DWORD dwFile, LPCVOID pBuffer, DWORD cbWrite, PDWORD pcbWritten, OVERLAPPED *pOverlapped);
typedef BOOL(* PWRITEFILEWITHSEEK)(DWORD dwFile, LPCVOID pBuffer, DWORD cbWrite, PDWORD pcbWritten, OVERLAPPED *pOverlapped, DWORD dwLowOffset, DWORD dwHighOffset);
typedef DWORD(* PSETFILEPOINTER)(DWORD dwFile, LONG lDistanceToMove, PLONG pDistanceToMoveHigh, DWORD dwMoveMethod);
typedef DWORD(* PGETFILESIZE)(DWORD dwFile, PDWORD pFileSizeHigh);
typedef BOOL(* PGETFILEINFORMATIONBYHANDLE)(DWORD dwFile, PBY_HANDLE_FILE_INFORMATION pFileInfo);
typedef BOOL(* PFLUSHFILEBUFFERS)(DWORD dwFile);
typedef BOOL(* PGETFILETIME)(DWORD dwFile, FILETIME *pCreation, FILETIME *pLastAccess, FILETIME *pLastWrite);
typedef BOOL(* PSETFILETIME)(DWORD dwFile, CONST FILETIME *pCreation, CONST FILETIME *pLastAccess, CONST FILETIME *pLastWrite);
typedef BOOL(* PSETENDOFFILE)(DWORD dwFile);
typedef BOOL(* PDEVICEIOCONTROL)(DWORD dwFile, DWORD dwIoControlCode, PVOID pInBuf, DWORD nInBufSize, PVOID pOutBuf, DWORD nOutBufSize, PDWORD pBytesReturned, OVERLAPPED *pOverlapped);
typedef BOOL(* PCLOSEFILE)(DWORD dwFile);
typedef BOOL(* PREFRESHVOLUME)(DWORD dwVolume);
typedef BOOL(* PREADFILESCATTER)(DWORD dwFile, FILE_SEGMENT_ELEMENT aSegmentArray[], DWORD nNumberOfBytesToRead, LPDWORD lpReserved, LPOVERLAPPED lpOverlapped);
typedef BOOL(* PWRITEFILEGATHER)(DWORD dwFile, FILE_SEGMENT_ELEMENT aSegmentArray[], DWORD nNumberOfBytesToWrite, LPDWORD lpReserved, LPOVERLAPPED lpOverlapped);
typedef BOOL(* PFSIOCONTROL)(DWORD dwVolume, DWORD dwIoControlCode, PVOID pInBuf, DWORD nInBufSize, PVOID pOutBuf, DWORD nOutBufSize, PDWORD pBytesReturned, OVERLAPPED *pOverlapped);
typedef BOOL(* PLOCKFILEEX)(DWORD dwFile, DWORD dwFlags, DWORD dwReserved, DWORD nNumberOfBytesToLockLow, DWORD nNumberOfBytesToLockHigh, LPOVERLAPPED lpOverlapped);
typedef BOOL(* PUNLOCKFILEEX)(DWORD dwFile, DWORD dwReserved, DWORD nNumberOfBytesToUnlockLow, DWORD nNumberOfBytesToUnlockHigh, LPOVERLAPPED lpOverlapped);
typedef BOOL(* PGETVOLUMEINFO)(DWORD dwVolume, FSD_VOLUME_INFO *pInfo);

typedef struct tagFILTERHOOK {
    DWORD cbSize;
    DWORD hVolume;
    PCLOSEVOLUME pCloseVolume;
    PCREATEDIRECTORYW pCreateDirectoryW;
    PREMOVEDIRECTORYW pRemoveDirectoryW;
    PGETFILEATTRIBUTESW pGetFileAttributesW;
    PSETFILEATTRIBUTESW pSetFileAttributesW;
    PDELETEFILEW pDeleteFileW;
    PMOVEFILEW pMoveFileW;
    PDELETEANDRENAMEFILEW pDeleteAndRenameFileW;
    PGETDISKFREESPACEW pGetDiskFreeSpaceW;
    PNOTIFY pNotify;
    PREGISTERFILESYSTEMFUNCTION pRegisterFileSystemFunction;
    PFINDFIRSTFILEW pFindFirstFileW;
    PFINDNEXTFILEW pFindNextFileW;
    PFINDCLOSE pFindClose;
    PCREATEFILEW pCreateFileW;
    PREADFILE pReadFile;
    PREADFILEWITHSEEK pReadFileWithSeek;
    PWRITEFILE pWriteFile;
    PWRITEFILEWITHSEEK pWriteFileWithSeek;
    PSETFILEPOINTER pSetFilePointer;
    PGETFILESIZE pGetFileSize;
    PGETFILEINFORMATIONBYHANDLE pGetFileInformationByHandle;
    PFLUSHFILEBUFFERS pFlushFileBuffers;
    PGETFILETIME pGetFileTime;
    PSETFILETIME pSetFileTime;
    PSETENDOFFILE pSetEndOfFile;
    PDEVICEIOCONTROL pDeviceIoControl;
    PCLOSEFILE pCloseFile;
    PREFRESHVOLUME pRefreshVolume;
    PFSIOCONTROL pFsIoControl;
    PLOCKFILEEX pLockFileEx;
    PUNLOCKFILEEX pUnlockFileEx;
    PGETVOLUMEINFO pGetVolumeInfo;
    PREADFILESCATTER pReadFileScatter;
    PWRITEFILEGATHER pWriteFileGather;
} FILTERHOOK, *PFILTERHOOK;


// Additional helper class for use in C++ code
#ifdef __cplusplus

#include <errorrep.h>

// FilterHook_t
//
// Wrapper class for convenient access to the FILTERHOOK type.
//
class FilterHook_t {

public:

    FilterHook_t ()
    {
        ::memset (&m_FilterHook, 0, sizeof (m_FilterHook));
        m_FilterHook.cbSize = sizeof (m_FilterHook);
    }

    BOOL Init (PFILTERHOOK pFilterHook)
    {
        if (pFilterHook && (pFilterHook->cbSize >= sizeof (m_FilterHook))) {
            ::memcpy (&m_FilterHook, pFilterHook, sizeof (m_FilterHook));
            m_FilterHook.cbSize = sizeof (m_FilterHook);
            return TRUE;
        }
        return FALSE;
    }

    virtual ~FilterHook_t ()
    {
#ifdef DEBUG
        // Catch references to a deleted filterhook
        ::memset (&m_FilterHook, 0xCC, sizeof (m_FilterHook));
#endif
    }

    inline DWORD GetVolumeHandle ()
    {
        return m_FilterHook.hVolume;
    }

    //---------------------------------------
    // Wrappers for the FILTERHOOK functions
    //---------------------------------------

    inline BOOL CloseVolume ()
    {
        BOOL fResult = FALSE;
        __try {
            fResult = m_FilterHook.pCloseVolume (m_FilterHook.hVolume);
        } __except (::ReportFault(GetExceptionInformation(), 0), EXCEPTION_EXECUTE_HANDLER) {
            ::SetLastError (ERROR_EXCEPTION_IN_SERVICE);
        }
        return fResult;
    }

    inline BOOL CreateDirectoryW (const WCHAR* pDirectoryName,
            SECURITY_ATTRIBUTES* pSecurityAttributes)
    {
        BOOL fResult = FALSE;
        __try {
            fResult = m_FilterHook.pCreateDirectoryW (m_FilterHook.hVolume,
                    pDirectoryName, pSecurityAttributes);
        } __except (::ReportFault(GetExceptionInformation(), 0), EXCEPTION_EXECUTE_HANDLER) {
            ::SetLastError (ERROR_EXCEPTION_IN_SERVICE);
        }
        return fResult;
    }

    inline BOOL RemoveDirectoryW (const WCHAR* pDirectoryName)
    {
        BOOL fResult = FALSE;
        __try {
            fResult = m_FilterHook.pRemoveDirectoryW (m_FilterHook.hVolume, pDirectoryName);
        } __except (::ReportFault(GetExceptionInformation(), 0), EXCEPTION_EXECUTE_HANDLER) {
            ::SetLastError (ERROR_EXCEPTION_IN_SERVICE);
        }
        return fResult;
    }

    inline DWORD GetFileAttributesW (const WCHAR* pPathName)
    {
        DWORD Result = INVALID_FILE_ATTRIBUTES;
        __try {
            Result = m_FilterHook.pGetFileAttributesW (m_FilterHook.hVolume, pPathName);
        } __except (::ReportFault(GetExceptionInformation(), 0), EXCEPTION_EXECUTE_HANDLER) {
            ::SetLastError (ERROR_EXCEPTION_IN_SERVICE);
        }
        return Result;
    }

    inline BOOL SetFileAttributesW (const WCHAR* pPathName, DWORD Attributes)
    {
        BOOL fResult = FALSE;
        __try {
            fResult = m_FilterHook.pSetFileAttributesW (m_FilterHook.hVolume, pPathName,
                Attributes);
        } __except (::ReportFault(GetExceptionInformation(), 0), EXCEPTION_EXECUTE_HANDLER) {
            ::SetLastError (ERROR_EXCEPTION_IN_SERVICE);
        }
        return fResult;
    }

    inline BOOL DeleteFileW (const WCHAR* pFileName)
    {
        BOOL fResult = FALSE;
        __try {
            fResult = m_FilterHook.pDeleteFileW (m_FilterHook.hVolume, pFileName);
        } __except (::ReportFault(GetExceptionInformation(), 0), EXCEPTION_EXECUTE_HANDLER) {
            ::SetLastError (ERROR_EXCEPTION_IN_SERVICE);
        }
        return fResult;
    }

    inline BOOL MoveFileW (const WCHAR* pOldFileName, const WCHAR* pNewFileName)
    {
        BOOL fResult = FALSE;
        __try {
            fResult = m_FilterHook.pMoveFileW (m_FilterHook.hVolume, pOldFileName,
                pNewFileName);
        } __except (::ReportFault(GetExceptionInformation(), 0), EXCEPTION_EXECUTE_HANDLER) {
            ::SetLastError (ERROR_EXCEPTION_IN_SERVICE);
        }
        return fResult;
    }

    inline BOOL DeleteAndRenameFileW (const WCHAR* pDestFileName, const WCHAR* pSourceFileName)
    {
        BOOL fResult = FALSE;
        __try {
            fResult = m_FilterHook.pDeleteAndRenameFileW (m_FilterHook.hVolume, pDestFileName,
                pSourceFileName);
        } __except (::ReportFault(GetExceptionInformation(), 0), EXCEPTION_EXECUTE_HANDLER) {
            ::SetLastError (ERROR_EXCEPTION_IN_SERVICE);
        }
        return fResult;
    }

    inline BOOL GetDiskFreeSpaceW (const WCHAR* pPathName, DWORD* pSectorsPerCluster,
        DWORD* pBytesPerSector, DWORD* pFreeClusters, DWORD* pClusters)
    {
        BOOL fResult = FALSE;
        __try {
            fResult = m_FilterHook.pGetDiskFreeSpaceW (m_FilterHook.hVolume, pPathName,
                pSectorsPerCluster, pBytesPerSector, pFreeClusters, pClusters);
        } __except (::ReportFault(GetExceptionInformation(), 0), EXCEPTION_EXECUTE_HANDLER) {
            ::SetLastError (ERROR_EXCEPTION_IN_SERVICE);
        }
        return fResult;
    }

    inline void Notify (DWORD Flags)
    {
        __try {
            m_FilterHook.pNotify (m_FilterHook.hVolume, Flags);
        } __except (::ReportFault(GetExceptionInformation(), 0), EXCEPTION_EXECUTE_HANDLER) {
            ::SetLastError (ERROR_EXCEPTION_IN_SERVICE);
        }
    }

    inline BOOL RegisterFileSystemFunction (LPVOID pFn)
    {
        BOOL fResult = FALSE;
        __try {
            fResult = m_FilterHook.pRegisterFileSystemFunction (m_FilterHook.hVolume, pFn);
        } __except (::ReportFault(GetExceptionInformation(), 0), EXCEPTION_EXECUTE_HANDLER) {
            ::SetLastError (ERROR_EXCEPTION_IN_SERVICE);
        }
        return fResult;
    }

    inline HANDLE FindFirstFileW (HANDLE hProc, const WCHAR* pFileSpec, WIN32_FIND_DATA* pFindData)
    {
        HANDLE hResult = INVALID_HANDLE_VALUE;
        __try {
            hResult = m_FilterHook.pFindFirstFileW ((DWORD) m_FilterHook.hVolume,
                                                    hProc,
                                                    (PCWSTR) pFileSpec,
                                                    (PWIN32_FIND_DATAW) pFindData);
        } __except (::ReportFault(GetExceptionInformation(), 0), EXCEPTION_EXECUTE_HANDLER) {
            ::SetLastError (ERROR_EXCEPTION_IN_SERVICE);
        }
        return hResult;
    }

    inline BOOL FindNextFileW (DWORD hSearch, WIN32_FIND_DATA* pFindData)
    {
        BOOL fResult = FALSE;
        __try {
            fResult = m_FilterHook.pFindNextFileW (hSearch, (PWIN32_FIND_DATAW) pFindData);
        } __except (::ReportFault(GetExceptionInformation(), 0), EXCEPTION_EXECUTE_HANDLER) {
            ::SetLastError (ERROR_EXCEPTION_IN_SERVICE);
        }
        return fResult;
    }

    inline BOOL FindClose (DWORD hSearch)
    {
        BOOL fResult = FALSE;
        __try {
            fResult = m_FilterHook.pFindClose (hSearch);
        } __except (::ReportFault(GetExceptionInformation(), 0), EXCEPTION_EXECUTE_HANDLER) {
            ::SetLastError (ERROR_EXCEPTION_IN_SERVICE);
        }
        return fResult;
    }

    inline HANDLE CreateFileW (HANDLE hProc, const WCHAR* FileName, DWORD AccessMode,
            DWORD ShareMode, SECURITY_ATTRIBUTES* pSecurityAttributes,
            DWORD CreationDisposition, DWORD FlagsAndAttributes,
            HANDLE hTemplateFile)
    {
        HANDLE hResult = INVALID_HANDLE_VALUE;
        __try {
            hResult = m_FilterHook.pCreateFileW (m_FilterHook.hVolume, hProc,
                    (WCHAR*)FileName, AccessMode, ShareMode, pSecurityAttributes,
                    CreationDisposition, FlagsAndAttributes, hTemplateFile);
        } __except (::ReportFault(GetExceptionInformation(), 0), EXCEPTION_EXECUTE_HANDLER) {
            ::SetLastError (ERROR_EXCEPTION_IN_SERVICE);
        }
        return hResult;
    }

    inline BOOL ReadFile (DWORD hFile, void* pBuffer, DWORD BufferSize, DWORD* BytesRead,
        OVERLAPPED* pOverlapped)
    {
        BOOL fResult = FALSE;
        __try {
            fResult = m_FilterHook.pReadFile (hFile, pBuffer, BufferSize, BytesRead, pOverlapped);
        } __except (::ReportFault(GetExceptionInformation(), 0), EXCEPTION_EXECUTE_HANDLER) {
            ::SetLastError (ERROR_EXCEPTION_IN_SERVICE);
        }
        return fResult;
    }

    inline BOOL ReadFileWithSeek (DWORD hFile, void* pBuffer, DWORD BufferSize, DWORD* BytesRead,
        OVERLAPPED* pOverlapped, DWORD LowOffset, DWORD HighOffset)
    {
        BOOL fResult = FALSE;
        __try {
            fResult = m_FilterHook.pReadFileWithSeek (hFile, pBuffer, BufferSize, BytesRead,
                pOverlapped, LowOffset, HighOffset);
        } __except (::ReportFault(GetExceptionInformation(), 0), EXCEPTION_EXECUTE_HANDLER) {
            ::SetLastError (ERROR_EXCEPTION_IN_SERVICE);
        }
        return fResult;
    }

    inline BOOL WriteFile (DWORD hFile, const void* pBuffer, DWORD BufferSize,
        DWORD* BytesWritten, OVERLAPPED* pOverlapped)
    {
        BOOL fResult = FALSE;
        __try {
            fResult = m_FilterHook.pWriteFile (hFile, pBuffer, BufferSize, BytesWritten, pOverlapped);
        } __except (::ReportFault(GetExceptionInformation(), 0), EXCEPTION_EXECUTE_HANDLER) {
            ::SetLastError (ERROR_EXCEPTION_IN_SERVICE);
        }
        return fResult;
    }

    inline BOOL WriteFileWithSeek (DWORD hFile, const void* pBuffer, DWORD BufferSize,
        DWORD* BytesWritten, OVERLAPPED* pOverlapped, DWORD LowOffset, DWORD HighOffset)
    {
        BOOL fResult = FALSE;
        __try {
            fResult = m_FilterHook.pWriteFileWithSeek (hFile, pBuffer, BufferSize, BytesWritten,
                pOverlapped, LowOffset, HighOffset);
        } __except (::ReportFault(GetExceptionInformation(), 0), EXCEPTION_EXECUTE_HANDLER) {
            ::SetLastError (ERROR_EXCEPTION_IN_SERVICE);
        }
        return fResult;
    }

    inline DWORD SetFilePointer (DWORD hFile, LONG DistanceToMoveLow, LONG* pDistanceToMoveHigh,
        DWORD MoveMethod)
    {
        DWORD Result = INVALID_SET_FILE_POINTER;
        __try {
            Result = m_FilterHook.pSetFilePointer (hFile, DistanceToMoveLow, pDistanceToMoveHigh,
                MoveMethod);
        } __except (::ReportFault(GetExceptionInformation(), 0), EXCEPTION_EXECUTE_HANDLER) {
            ::SetLastError (ERROR_EXCEPTION_IN_SERVICE);
        }
        return Result;
    }

    inline DWORD GetFileSize (DWORD hFile, DWORD* pFileSizeHigh)
    {
        DWORD Result = INVALID_FILE_SIZE;
        __try {
            Result = m_FilterHook.pGetFileSize (hFile, pFileSizeHigh);
        } __except (::ReportFault(GetExceptionInformation(), 0), EXCEPTION_EXECUTE_HANDLER) {
            ::SetLastError (ERROR_EXCEPTION_IN_SERVICE);
        }
        return Result;
    }

    inline BOOL GetFileInformationByHandle (DWORD hFile, BY_HANDLE_FILE_INFORMATION* pFileInfo)
    {
        BOOL fResult = FALSE;
        __try {
            fResult = m_FilterHook.pGetFileInformationByHandle (hFile, pFileInfo);
        } __except (::ReportFault(GetExceptionInformation(), 0), EXCEPTION_EXECUTE_HANDLER) {
            ::SetLastError (ERROR_EXCEPTION_IN_SERVICE);
        }
        return fResult;
    }

    inline BOOL FlushFileBuffers (DWORD hFile)
    {
        BOOL fResult = FALSE;
        __try {
            fResult = m_FilterHook.pFlushFileBuffers (hFile);
        } __except (::ReportFault(GetExceptionInformation(), 0), EXCEPTION_EXECUTE_HANDLER) {
            ::SetLastError (ERROR_EXCEPTION_IN_SERVICE);
        }
        return fResult;
    }

    inline BOOL GetFileTime (DWORD hFile, FILETIME* pCreation, FILETIME* pLastAccess,
        FILETIME* pLastWrite)
    {
        BOOL fResult = FALSE;
        __try {
            fResult = m_FilterHook.pGetFileTime (hFile, pCreation, pLastAccess, pLastWrite);
        } __except (::ReportFault(GetExceptionInformation(), 0), EXCEPTION_EXECUTE_HANDLER) {
            ::SetLastError (ERROR_EXCEPTION_IN_SERVICE);
        }
        return fResult;
    }

    inline BOOL SetFileTime (DWORD hFile, const FILETIME* pCreation,
        const FILETIME* pLastAccess, const FILETIME* pLastWrite)
    {
        BOOL fResult = FALSE;
        __try {
            fResult = m_FilterHook.pSetFileTime (hFile, pCreation, pLastAccess, pLastWrite);
        } __except (::ReportFault(GetExceptionInformation(), 0), EXCEPTION_EXECUTE_HANDLER) {
            ::SetLastError (ERROR_EXCEPTION_IN_SERVICE);
        }
        return fResult;
    }

    inline BOOL SetEndOfFile (DWORD hFile)
    {
        BOOL fResult = FALSE;
        __try {
            fResult = m_FilterHook.pSetEndOfFile (hFile);
        } __except (::ReportFault(GetExceptionInformation(), 0), EXCEPTION_EXECUTE_HANDLER) {
            ::SetLastError (ERROR_EXCEPTION_IN_SERVICE);
        }
        return fResult;
    }

    inline BOOL DeviceIoControl (DWORD hFile, DWORD Ioctl, void* pInBuf, DWORD InBufSize,
        void* pOutBuf, DWORD OutBufSize, DWORD* pBytesReturned, OVERLAPPED* pOverlapped)
    {
        BOOL fResult = FALSE;
        __try {
            fResult = m_FilterHook.pDeviceIoControl (hFile, Ioctl, pInBuf, InBufSize, pOutBuf,
                OutBufSize, pBytesReturned, pOverlapped);
        } __except (::ReportFault(GetExceptionInformation(), 0), EXCEPTION_EXECUTE_HANDLER) {
            ::SetLastError (ERROR_EXCEPTION_IN_SERVICE);
        }
        return fResult;
    }

    inline BOOL CloseFile (DWORD hFile)
    {
        BOOL fResult = FALSE;
        __try {
            fResult = m_FilterHook.pCloseFile (hFile);
        } __except (::ReportFault(GetExceptionInformation(), 0), EXCEPTION_EXECUTE_HANDLER) {
            ::SetLastError (ERROR_EXCEPTION_IN_SERVICE);
        }
        return fResult;
    }

    inline BOOL RefreshVolume ()
    {
        BOOL fResult = FALSE;
        __try {
            fResult = m_FilterHook.pRefreshVolume (m_FilterHook.hVolume);
        } __except (::ReportFault(GetExceptionInformation(), 0), EXCEPTION_EXECUTE_HANDLER) {
            ::SetLastError (ERROR_EXCEPTION_IN_SERVICE);
        }
        return fResult;
    }

    inline BOOL FsIoControl (DWORD Ioctl, void* pInBuf, DWORD InBufSize,
        void* pOutBuf, DWORD OutBufSize, DWORD* pBytesReturned, OVERLAPPED* pOverlapped)
    {
        BOOL fResult = FALSE;
        __try {
            fResult = m_FilterHook.pFsIoControl (m_FilterHook.hVolume, Ioctl, pInBuf, InBufSize,
                pOutBuf, OutBufSize, pBytesReturned, pOverlapped);
        } __except (::ReportFault(GetExceptionInformation(), 0), EXCEPTION_EXECUTE_HANDLER) {
            ::SetLastError (ERROR_EXCEPTION_IN_SERVICE);
        }
        return fResult;
    }

    inline BOOL LockFileEx (DWORD hFile, DWORD Flags, DWORD Reserved, DWORD BytesToLockLow,
        DWORD BytesToLockHigh, OVERLAPPED* pOverlapped)
    {
        BOOL fResult = FALSE;
        __try {
            fResult = m_FilterHook.pLockFileEx (hFile, Flags, Reserved, BytesToLockLow,
                BytesToLockHigh, pOverlapped);
        } __except (::ReportFault(GetExceptionInformation(), 0), EXCEPTION_EXECUTE_HANDLER) {
            ::SetLastError (ERROR_EXCEPTION_IN_SERVICE);
        }
        return fResult;
    }


    inline BOOL UnlockFileEx (DWORD hFile, DWORD Reserved, DWORD BytesToLockLow,
        DWORD BytesToLockHigh, OVERLAPPED* pOverlapped)
    {
        BOOL fResult = FALSE;
        __try {
            fResult = m_FilterHook.pUnlockFileEx (hFile, Reserved, BytesToLockLow,
                BytesToLockHigh, pOverlapped);
        } __except (::ReportFault(GetExceptionInformation(), 0), EXCEPTION_EXECUTE_HANDLER) {
            ::SetLastError (ERROR_EXCEPTION_IN_SERVICE);
        }
        return fResult;
    }

    inline BOOL GetVolumeInfo (FSD_VOLUME_INFO *pInfo)
    {
        BOOL fResult = FALSE;
        __try {
            fResult = m_FilterHook.pGetVolumeInfo (m_FilterHook.hVolume, pInfo);
        } __except (::ReportFault(GetExceptionInformation(), 0), EXCEPTION_EXECUTE_HANDLER) {
            ::SetLastError (ERROR_EXCEPTION_IN_SERVICE);
        }
        return fResult;
    }

    inline BOOL ReadFileScatter (DWORD hFile, FILE_SEGMENT_ELEMENT SegmentArray[],
        DWORD BytesToRead, DWORD* pReserved, OVERLAPPED* pOverlapped)
    {
        BOOL fResult = FALSE;
        __try {
            fResult = m_FilterHook.pReadFileScatter (hFile, SegmentArray, BytesToRead,
                pReserved, pOverlapped);
        } __except (::ReportFault(GetExceptionInformation(), 0), EXCEPTION_EXECUTE_HANDLER) {
            ::SetLastError (ERROR_EXCEPTION_IN_SERVICE);
        }
        return fResult;
    }

    inline BOOL WriteFileGather (DWORD hFile, FILE_SEGMENT_ELEMENT SegmentArray[],
        DWORD BytesToWrite, DWORD* pReserved, OVERLAPPED* pOverlapped)
    {
        BOOL fResult = FALSE;
        __try {
            fResult = m_FilterHook.pWriteFileGather (hFile, SegmentArray, BytesToWrite,
                pReserved, pOverlapped);
        } __except (::ReportFault(GetExceptionInformation(), 0), EXCEPTION_EXECUTE_HANDLER) {
            ::SetLastError (ERROR_EXCEPTION_IN_SERVICE);
        }
        return fResult;
    }

private:
    // Encapsulates all basic file system function pointers and tracks
    // the volume context to be passed to the file system (hVolume).
    FILTERHOOK m_FilterHook;
};

#endif // __cplusplus


#endif /* FSDMGR_H */


#ifdef FSDAPI

#define DECLAPI(ret,prefix,func)    ret prefix##_##func
#define DECLFSDAPI(ret,prefix,func) DECLAPI(ret,prefix,func)


/*  Interfaces imported by FSDMGR.DLL from FSDs for mount support
 *
 *  Note that the XXX_MountDisk interface must also be exported as
 *  "FSD_MountDisk", since DEVICE.EXE specifically looks for that export
 *  when determining how to load the FSD (ie, using FSDMGR.DLL or
 *  stand-alone).
 *
 *  This requirement is easily satisfied in the DEF file for the FSD;
 *  for example, for an FSD named FATFSD.DLL, the DEF file would contain:
 *
 *      EXPORTS
 *          FATFSD_MountDisk
 *          FATFSD_UnmountDisk
 *          FSD_MountDisk=FATFSD_MountDisk
 *          FSD_UnmountDisk=FATFSD_UnmountDisk
 *          ...
 */

DECLFSDAPI(BOOL, FSDAPI, MountDisk(HDSK hdsk));
DECLFSDAPI(BOOL, FSDAPI, UnmountDisk(HDSK hdsk));
DECLFSDAPI(PVOLUME, FSDAPI, HookVolume(HDSK hdsk, PFILTERHOOK pFilterHook));
DECLFSDAPI(BOOL, FSDAPI, UnhookVolume(PVOLUME pVol));


/*  Interfaces imported by FSDMGR.DLL from FSDs for application support
 *
 *  Add a #define for FSDAPI before including this file, so that the following
 *  prototypes match the interface names your FSD must export.  For example,
 *  an FSD named FATFSD.DLL would want to include the following lines in its
 *  source code:
 *
 *      #define FSDAPI FATFSD
 *      #include <fsdmgr.h>
 *
 *  since FSDMGR.DLL will expect to find exports named "FATFSD_CreateDirectoryW",
 *  "FATFSD_RemoveDirectoryW", etc, if it is asked to load an FSD named FATFSD.DLL.
 */

DECLFSDAPI(BOOL,  FSDAPI, CloseVolume(PVOLUME pVolume));
DECLFSDAPI(BOOL,  FSDAPI, CreateDirectoryW(PVOLUME pVolume, PCWSTR pwsPathName, PSECURITY_ATTRIBUTES pSecurityAttributes));
DECLFSDAPI(BOOL,  FSDAPI, RemoveDirectoryW(PVOLUME pVolume, PCWSTR pwsPathName));
DECLFSDAPI(DWORD, FSDAPI, GetFileAttributesW(PVOLUME pVolume, PCWSTR pwsFileName));
DECLFSDAPI(BOOL,  FSDAPI, SetFileAttributesW(PVOLUME pVolume, PCWSTR pwsFileName, DWORD dwAttributes));
DECLFSDAPI(BOOL,  FSDAPI, DeleteFileW(PVOLUME pVolume, PCWSTR pwsFileName));
DECLFSDAPI(BOOL,  FSDAPI, MoveFileW(PVOLUME pVolume, PCWSTR pwsOldFileName, PCWSTR pwsNewFileName));
DECLFSDAPI(BOOL,  FSDAPI, DeleteAndRenameFileW(PVOLUME pVolume, PCWSTR pwsOldFileName, PCWSTR pwsNewFileName));
DECLFSDAPI(BOOL,  FSDAPI, GetDiskFreeSpaceW(PVOLUME pVolume, PCWSTR pwsPathName, PDWORD pSectorsPerCluster, PDWORD pBytesPerSector, PDWORD pFreeClusters, PDWORD pClusters));
DECLFSDAPI(void,  FSDAPI, Notify(PVOLUME pVolume, DWORD dwFlags));
DECLFSDAPI(BOOL,  FSDAPI, RegisterFileSystemFunction(PVOLUME pVolume, LPVOID pfn));
DECLFSDAPI(HANDLE,FSDAPI, FindFirstFileW(PVOLUME pVolume, HANDLE hProc, PCWSTR pwsFileSpec, PWIN32_FIND_DATAW pfd));
DECLFSDAPI(BOOL,  FSDAPI, FindNextFileW(PSEARCH pSearch, PWIN32_FIND_DATAW pfd));
DECLFSDAPI(BOOL,  FSDAPI, FindClose(PSEARCH pSearch));
DECLFSDAPI(HANDLE,FSDAPI, CreateFileW(PVOLUME pVolume, HANDLE hProc, PCWSTR pwsFileName, DWORD dwAccess, DWORD dwShareMode, PSECURITY_ATTRIBUTES pSecurityAttributes, DWORD dwCreate, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile));
DECLFSDAPI(BOOL,  FSDAPI, ReadFile(PFILE pFile, PVOID pBuffer, DWORD cbRead, PDWORD pcbRead, OVERLAPPED *pOverlapped));
DECLFSDAPI(BOOL,  FSDAPI, ReadFileWithSeek(PFILE pFile, PVOID pBuffer, DWORD cbRead, PDWORD pcbRead, OVERLAPPED *pOverlapped, DWORD dwLowOffset, DWORD dwHighOffset));
DECLFSDAPI(BOOL,  FSDAPI, WriteFile(PFILE pFile, LPCVOID pBuffer, DWORD cbWrite, PDWORD pcbWritten, OVERLAPPED *pOverlapped));
DECLFSDAPI(BOOL,  FSDAPI, WriteFileWithSeek(PFILE pFile, LPCVOID pBuffer, DWORD cbWrite, PDWORD pcbWritten, OVERLAPPED *pOverlapped, DWORD dwLowOffset, DWORD dwHighOffset));
DECLFSDAPI(DWORD, FSDAPI, SetFilePointer(PFILE pFile, LONG lDistanceToMove, PLONG pDistanceToMoveHigh, DWORD dwMoveMethod));
DECLFSDAPI(DWORD, FSDAPI, GetFileSize(PFILE pFile, PDWORD pFileSizeHigh));
DECLFSDAPI(BOOL,  FSDAPI, GetFileInformationByHandle(PFILE pFile, PBY_HANDLE_FILE_INFORMATION pFileInfo));
DECLFSDAPI(BOOL,  FSDAPI, FlushFileBuffers(PFILE pFile));
DECLFSDAPI(BOOL,  FSDAPI, GetFileTime(PFILE pFile, FILETIME *pCreation, FILETIME *pLastAccess, FILETIME *pLastWrite));
DECLFSDAPI(BOOL,  FSDAPI, SetFileTime(PFILE pFile, CONST FILETIME *pCreation, CONST FILETIME *pLastAccess, CONST FILETIME *pLastWrite));
DECLFSDAPI(BOOL,  FSDAPI, SetEndOfFile(PFILE pFile));
DECLFSDAPI(BOOL,  FSDAPI, DeviceIoControl(PFILE pFile, DWORD dwIoControlCode, PVOID pInBuf, DWORD nInBufSize, PVOID pOutBuf, DWORD nOutBufSize, PDWORD pBytesReturned, OVERLAPPED *pOverlapped));
DECLFSDAPI(BOOL,  FSDAPI, CloseFile(PFILE pFile));
DECLFSDAPI(BOOL,  FSDAPI, RefreshVolume(PVOLUME pVolume));
DECLFSDAPI(BOOL,  FSDAPI, FsIoControl(PVOLUME pVolume, DWORD dwIoControlCode, PVOID pInBuf, DWORD nInBufSize, PVOID pOutBuf, DWORD nOutBufSize, PDWORD pBytesReturned, OVERLAPPED *pOverlapped));
DECLFSDAPI(BOOL,  FSDAPI, LockFileEx(PFILE pFile, DWORD dwFlags, DWORD dwReserved, DWORD nNumberOfBytesToLockLow, DWORD nNumberOfBytesToLockHigh, LPOVERLAPPED lpOverlapped));
DECLFSDAPI(BOOL,  FSDAPI, UnlockFileEx(PFILE pFile, DWORD dwReserved, DWORD nNumberOfBytesToUnlockLow, DWORD nNumberOfBytesToUnlockHigh, LPOVERLAPPED lpOverlapped));
DECLFSDAPI(BOOL,  FSDAPI, GetVolumeInfo(PVOLUME pVolume, FSD_VOLUME_INFO *pInfo));

#endif  // FSDAPI


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\fwpstypes.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0543 */
/* Compiler settings for fwpstypes.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __fwpstypes_h__
#define __fwpstypes_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

/* header files for imported files */
#include "fwptypes.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_fwpstypes_0000_0000 */
/* [local] */ 

#if _MSC_VER >=  800
#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4201)
#endif
typedef struct FWPS_FILTER_CONDITION0_
    {
    UINT16 fieldId;
    UINT16 reserved;
    FWP_MATCH_TYPE matchType;
    FWP_CONDITION_VALUE0 conditionValue;
    } 	FWPS_FILTER_CONDITION0;

typedef struct FWPS_ACTION0_
    {
    FWP_ACTION_TYPE type;
    UINT32 calloutId;
    } 	FWPS_ACTION0;

#define FWPS_FILTER_FLAG_CLEAR_ACTION_RIGHT    (0x0001)
#define FWPS_FILTER_FLAG_PERMIT_IF_CALLOUT_UNREGISTERED   (0x0002)
typedef struct FWPM_PROVIDER_CONTEXT0_ FWPM_PROVIDER_CONTEXT0;

typedef struct FWPS_FILTER0_
    {
    UNALIGNEDUINT64 filterId;
    FWP_VALUE0 weight;
    UINT16 subLayerWeight;
    UINT16 flags;
    UINT32 numFilterConditions;
    FWPS_FILTER_CONDITION0 *filterCondition;
    FWPS_ACTION0 action;
    UNALIGNEDUINT64 context;
    FWPM_PROVIDER_CONTEXT0 *providerContext;
    } 	FWPS_FILTER0;

typedef struct FWPS_INCOMING_VALUE0_
    {
    FWP_VALUE0 value;
    } 	FWPS_INCOMING_VALUE0;

typedef struct FWPS_INCOMING_VALUES0_
    {
    UINT16 layerId;
    UINT32 valueCount;
    FWPS_INCOMING_VALUE0 *incomingValue;
    } 	FWPS_INCOMING_VALUES0;

typedef 
enum FWPS_DISCARD_MODULE0_
    {	FWPS_DISCARD_MODULE_NETWORK	= 0,
	FWPS_DISCARD_MODULE_TRANSPORT	= ( FWPS_DISCARD_MODULE_NETWORK + 1 ) ,
	FWPS_DISCARD_MODULE_GENERAL	= ( FWPS_DISCARD_MODULE_TRANSPORT + 1 ) ,
	FWPS_DISCARD_MODULE_MAX	= ( FWPS_DISCARD_MODULE_GENERAL + 1 ) 
    } 	FWPS_DISCARD_MODULE0;

typedef 
enum FWPS_GENERAL_DISCARD_REASON_
    {	FWPS_DISCARD_FIREWALL_POLICY	= 0,
	FWPS_DISCARD_IPSEC	= ( FWPS_DISCARD_FIREWALL_POLICY + 1 ) ,
	FWPS_GENERAL_DISCARD_REASON_MAX	= ( FWPS_DISCARD_IPSEC + 1 ) 
    } 	FWPS_GENERAL_DISCARD_REASON;

typedef struct FWPS_DISCARD_METADATA0_
    {
    FWPS_DISCARD_MODULE0 discardModule;
    UINT32 discardReason;
    UNALIGNEDUINT64 filterId;
    } 	FWPS_DISCARD_METADATA0;

typedef struct FWPS_INBOUND_FRAGMENT_METADATA0_
    {
    UINT32 fragmentIdentification;
    UINT16 fragmentOffset;
    ULONG fragmentLength;
    } 	FWPS_INBOUND_FRAGMENT_METADATA0;

#define FWPS_INCOMING_FLAG_CACHE_SAFE                         (0x00000001)
#define FWPS_INCOMING_FLAG_ENFORCE_QUERY                      (0x00000002)
#define FWPS_INCOMING_FLAG_ABSORB                             (0x00000004)
#define FWPS_INCOMING_FLAG_CONNECTION_FAILING_INDICATION      (0x00000008)
#define FWPS_RIGHT_ACTION_WRITE          (0x00000001)
#define FWPS_CLASSIFY_OUT_FLAG_ABSORB                      (0x00000001)
#define FWPS_CLASSIFY_OUT_FLAG_BUFFER_LIMIT_REACHED        (0x00000002)
#define FWPS_CLASSIFY_OUT_FLAG_NO_MORE_DATA                (0x00000004)
typedef struct FWPS_CLASSIFY_OUT0_
    {
    FWP_ACTION_TYPE actionType;
    UNALIGNEDUINT64 outContext;
    UNALIGNEDUINT64 filterId;
    UINT32 rights;
    UINT32 flags;
    UINT32 reserved;
    } 	FWPS_CLASSIFY_OUT0;

typedef 
enum FWPS_CALLOUT_NOTIFY_TYPE_
    {	FWPS_CALLOUT_NOTIFY_ADD_FILTER	= 0,
	FWPS_CALLOUT_NOTIFY_DELETE_FILTER	= ( FWPS_CALLOUT_NOTIFY_ADD_FILTER + 1 ) ,
	FWPS_CALLOUT_NOTIFY_TYPE_MAX	= ( FWPS_CALLOUT_NOTIFY_DELETE_FILTER + 1 ) 
    } 	FWPS_CALLOUT_NOTIFY_TYPE;

#if _MSC_VER >=  800
#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4201)
#endif
#endif


extern RPC_IF_HANDLE __MIDL_itf_fwpstypes_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_fwpstypes_0000_0000_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\fwpmu.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*
   Copyright (c) Microsoft Corporation

   SYNOPSIS

     Declares the management portion of the FWP API.
*/

#if (NTDDI_VERSION >= NTDDI_WIN6)

///////////////////////////////////////////////////////////////////////////////
//
// GUIDs for built-in layers.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef GLOBUIDS
#define GLOBUIDS

#define INITGUID

#ifdef DEFINE_GUID
#undef DEFINE_GUID

#define DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
        EXTERN_C const GUID DECLSPEC_SELECTANY name \
                = { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } }

#endif //DEFINE_GUID

// c86fd1bf-21cd-497e-a0bb-17425c885c58
DEFINE_GUID(
   FWPM_LAYER_INBOUND_IPPACKET_V4,
   0xc86fd1bf,
   0x21cd,
   0x497e,
   0xa0, 0xbb, 0x17, 0x42, 0x5c, 0x88, 0x5c, 0x58
);

// b5a230d0-a8c0-44f2-916e-991b53ded1f7
DEFINE_GUID(
   FWPM_LAYER_INBOUND_IPPACKET_V4_DISCARD,
   0xb5a230d0,
   0xa8c0,
   0x44f2,
   0x91, 0x6e, 0x99, 0x1b, 0x53, 0xde, 0xd1, 0xf7
);

// f52032cb-991c-46e7-971d-2601459a91ca
DEFINE_GUID(
   FWPM_LAYER_INBOUND_IPPACKET_V6,
   0xf52032cb,
   0x991c,
   0x46e7,
   0x97, 0x1d, 0x26, 0x01, 0x45, 0x9a, 0x91, 0xca
);

// bb24c279-93b4-47a2-83ad-ae1698b50885
DEFINE_GUID(
   FWPM_LAYER_INBOUND_IPPACKET_V6_DISCARD,
   0xbb24c279,
   0x93b4,
   0x47a2,
   0x83, 0xad, 0xae, 0x16, 0x98, 0xb5, 0x08, 0x85
);

// 1e5c9fae-8a84-4135-a331-950b54229ecd
DEFINE_GUID(
   FWPM_LAYER_OUTBOUND_IPPACKET_V4,
   0x1e5c9fae,
   0x8a84,
   0x4135,
   0xa3, 0x31, 0x95, 0x0b, 0x54, 0x22, 0x9e, 0xcd
);

// 08e4bcb5-b647-48f3-953c-e5ddbd03937e
DEFINE_GUID(
   FWPM_LAYER_OUTBOUND_IPPACKET_V4_DISCARD,
   0x08e4bcb5,
   0xb647,
   0x48f3,
   0x95, 0x3c, 0xe5, 0xdd, 0xbd, 0x03, 0x93, 0x7e
);

// a3b3ab6b-3564-488c-9117-f34e82142763
DEFINE_GUID(
   FWPM_LAYER_OUTBOUND_IPPACKET_V6,
   0xa3b3ab6b,
   0x3564,
   0x488c,
   0x91, 0x17, 0xf3, 0x4e, 0x82, 0x14, 0x27, 0x63
);

// 9513d7c4-a934-49dc-91a7-6ccb80cc02e3
DEFINE_GUID(
   FWPM_LAYER_OUTBOUND_IPPACKET_V6_DISCARD,
   0x9513d7c4,
   0xa934,
   0x49dc,
   0x91, 0xa7, 0x6c, 0xcb, 0x80, 0xcc, 0x02, 0xe3
);

// a82acc24-4ee1-4ee1-b465-fd1d25cb10a4
DEFINE_GUID(
   FWPM_LAYER_IPFORWARD_V4,
   0xa82acc24,
   0x4ee1,
   0x4ee1,
   0xb4, 0x65, 0xfd, 0x1d, 0x25, 0xcb, 0x10, 0xa4
);

// 9e9ea773-2fae-4210-8f17-34129ef369eb
DEFINE_GUID(
   FWPM_LAYER_IPFORWARD_V4_DISCARD,
   0x9e9ea773,
   0x2fae,
   0x4210,
   0x8f, 0x17, 0x34, 0x12, 0x9e, 0xf3, 0x69, 0xeb
);

// 7b964818-19c7-493a-b71f-832c3684d28c
DEFINE_GUID(
   FWPM_LAYER_IPFORWARD_V6,
   0x7b964818,
   0x19c7,
   0x493a,
   0xb7, 0x1f, 0x83, 0x2c, 0x36, 0x84, 0xd2, 0x8c
);

// 31524a5d-1dfe-472f-bb93-518ee945d8a2
DEFINE_GUID(
   FWPM_LAYER_IPFORWARD_V6_DISCARD,
   0x31524a5d,
   0x1dfe,
   0x472f,
   0xbb, 0x93, 0x51, 0x8e, 0xe9, 0x45, 0xd8, 0xa2
);

// 5926dfc8-e3cf-4426-a283-dc393f5d0f9d
DEFINE_GUID(
   FWPM_LAYER_INBOUND_TRANSPORT_V4,
   0x5926dfc8,
   0xe3cf,
   0x4426,
   0xa2, 0x83, 0xdc, 0x39, 0x3f, 0x5d, 0x0f, 0x9d
);

// ac4a9833-f69d-4648-b261-6dc84835ef39
DEFINE_GUID(
   FWPM_LAYER_INBOUND_TRANSPORT_V4_DISCARD,
   0xac4a9833,
   0xf69d,
   0x4648,
   0xb2, 0x61, 0x6d, 0xc8, 0x48, 0x35, 0xef, 0x39
);

// 634a869f-fc23-4b90-b0c1-bf620a36ae6f
DEFINE_GUID(
   FWPM_LAYER_INBOUND_TRANSPORT_V6,
   0x634a869f,
   0xfc23,
   0x4b90,
   0xb0, 0xc1, 0xbf, 0x62, 0x0a, 0x36, 0xae, 0x6f
);

// 2a6ff955-3b2b-49d2-9848-ad9d72dcaab7
DEFINE_GUID(
   FWPM_LAYER_INBOUND_TRANSPORT_V6_DISCARD,
   0x2a6ff955,
   0x3b2b,
   0x49d2,
   0x98, 0x48, 0xad, 0x9d, 0x72, 0xdc, 0xaa, 0xb7
);

// 09e61aea-d214-46e2-9b21-b26b0b2f28c8
DEFINE_GUID(
   FWPM_LAYER_OUTBOUND_TRANSPORT_V4,
   0x09e61aea,
   0xd214,
   0x46e2,
   0x9b, 0x21, 0xb2, 0x6b, 0x0b, 0x2f, 0x28, 0xc8
);

// c5f10551-bdb0-43d7-a313-50e211f4d68a
DEFINE_GUID(
   FWPM_LAYER_OUTBOUND_TRANSPORT_V4_DISCARD,
   0xc5f10551,
   0xbdb0,
   0x43d7,
   0xa3, 0x13, 0x50, 0xe2, 0x11, 0xf4, 0xd6, 0x8a
);

// e1735bde-013f-4655-b351-a49e15762df0
DEFINE_GUID(
   FWPM_LAYER_OUTBOUND_TRANSPORT_V6,
   0xe1735bde,
   0x013f,
   0x4655,
   0xb3, 0x51, 0xa4, 0x9e, 0x15, 0x76, 0x2d, 0xf0
);

// f433df69-ccbd-482e-b9b2-57165658c3b3
DEFINE_GUID(
   FWPM_LAYER_OUTBOUND_TRANSPORT_V6_DISCARD,
   0xf433df69,
   0xccbd,
   0x482e,
   0xb9, 0xb2, 0x57, 0x16, 0x56, 0x58, 0xc3, 0xb3
);

// 3b89653c-c170-49e4-b1cd-e0eeeee19a3e
DEFINE_GUID(
   FWPM_LAYER_STREAM_V4,
   0x3b89653c,
   0xc170,
   0x49e4,
   0xb1, 0xcd, 0xe0, 0xee, 0xee, 0xe1, 0x9a, 0x3e
);

// 25c4c2c2-25ff-4352-82f9-c54a4a4726dc
DEFINE_GUID(
   FWPM_LAYER_STREAM_V4_DISCARD,
   0x25c4c2c2,
   0x25ff,
   0x4352,
   0x82, 0xf9, 0xc5, 0x4a, 0x4a, 0x47, 0x26, 0xdc
);

// 47c9137a-7ec4-46b3-b6e4-48e926b1eda4
DEFINE_GUID(
   FWPM_LAYER_STREAM_V6,
   0x47c9137a,
   0x7ec4,
   0x46b3,
   0xb6, 0xe4, 0x48, 0xe9, 0x26, 0xb1, 0xed, 0xa4
);

// 10a59fc7-b628-4c41-9eb8-cf37d55103cf
DEFINE_GUID(
   FWPM_LAYER_STREAM_V6_DISCARD,
   0x10a59fc7,
   0xb628,
   0x4c41,
   0x9e, 0xb8, 0xcf, 0x37, 0xd5, 0x51, 0x03, 0xcf
);

// 3d08bf4e-45f6-4930-a922-417098e20027
DEFINE_GUID(
   FWPM_LAYER_DATAGRAM_DATA_V4,
   0x3d08bf4e,
   0x45f6,
   0x4930,
   0xa9, 0x22, 0x41, 0x70, 0x98, 0xe2, 0x00, 0x27
);

// 18e330c6-7248-4e52-aaab-472ed67704fd
DEFINE_GUID(
   FWPM_LAYER_DATAGRAM_DATA_V4_DISCARD,
   0x18e330c6,
   0x7248,
   0x4e52,
   0xaa, 0xab, 0x47, 0x2e, 0xd6, 0x77, 0x04, 0xfd
);

// fa45fe2f-3cba-4427-87fc-57b9a4b10d00
DEFINE_GUID(
   FWPM_LAYER_DATAGRAM_DATA_V6,
   0xfa45fe2f,
   0x3cba,
   0x4427,
   0x87, 0xfc, 0x57, 0xb9, 0xa4, 0xb1, 0x0d, 0x00
);

// 09d1dfe1-9b86-4a42-be9d-8c315b92a5d0
DEFINE_GUID(
   FWPM_LAYER_DATAGRAM_DATA_V6_DISCARD,
   0x09d1dfe1,
   0x9b86,
   0x4a42,
   0xbe, 0x9d, 0x8c, 0x31, 0x5b, 0x92, 0xa5, 0xd0
);

// 61499990-3cb6-4e84-b950-53b94b6964f3
DEFINE_GUID(
   FWPM_LAYER_INBOUND_ICMP_ERROR_V4,
   0x61499990,
   0x3cb6,
   0x4e84,
   0xb9, 0x50, 0x53, 0xb9, 0x4b, 0x69, 0x64, 0xf3
);

// a6b17075-ebaf-4053-a4e7-213c8121ede5
DEFINE_GUID(
   FWPM_LAYER_INBOUND_ICMP_ERROR_V4_DISCARD,
   0xa6b17075,
   0xebaf,
   0x4053,
   0xa4, 0xe7, 0x21, 0x3c, 0x81, 0x21, 0xed, 0xe5
);

// 65f9bdff-3b2d-4e5d-b8c6-c720651fe898
DEFINE_GUID(
   FWPM_LAYER_INBOUND_ICMP_ERROR_V6,
   0x65f9bdff,
   0x3b2d,
   0x4e5d,
   0xb8, 0xc6, 0xc7, 0x20, 0x65, 0x1f, 0xe8, 0x98
);

// a6e7ccc0-08fb-468d-a472-9771d5595e09
DEFINE_GUID(
   FWPM_LAYER_INBOUND_ICMP_ERROR_V6_DISCARD,
   0xa6e7ccc0,
   0x08fb,
   0x468d,
   0xa4, 0x72, 0x97, 0x71, 0xd5, 0x59, 0x5e, 0x09
);

// 41390100-564c-4b32-bc1d-718048354d7c
DEFINE_GUID(
   FWPM_LAYER_OUTBOUND_ICMP_ERROR_V4,
   0x41390100,
   0x564c,
   0x4b32,
   0xbc, 0x1d, 0x71, 0x80, 0x48, 0x35, 0x4d, 0x7c
);

// b3598d36-0561-4588-a6bf-e955e3f6264b
DEFINE_GUID(
   FWPM_LAYER_OUTBOUND_ICMP_ERROR_V4_DISCARD,
   0xb3598d36,
   0x0561,
   0x4588,
   0xa6, 0xbf, 0xe9, 0x55, 0xe3, 0xf6, 0x26, 0x4b
);

// 7fb03b60-7b8d-4dfa-badd-980176fc4e12
DEFINE_GUID(
   FWPM_LAYER_OUTBOUND_ICMP_ERROR_V6,
   0x7fb03b60,
   0x7b8d,
   0x4dfa,
   0xba, 0xdd, 0x98, 0x01, 0x76, 0xfc, 0x4e, 0x12
);

// 65f2e647-8d0c-4f47-b19b-33a4d3f1357c
DEFINE_GUID(
   FWPM_LAYER_OUTBOUND_ICMP_ERROR_V6_DISCARD,
   0x65f2e647,
   0x8d0c,
   0x4f47,
   0xb1, 0x9b, 0x33, 0xa4, 0xd3, 0xf1, 0x35, 0x7c
);

// 1247d66d-0b60-4a15-8d44-7155d0f53a0c
DEFINE_GUID(
   FWPM_LAYER_ALE_RESOURCE_ASSIGNMENT_V4,
   0x1247d66d,
   0x0b60,
   0x4a15,
   0x8d, 0x44, 0x71, 0x55, 0xd0, 0xf5, 0x3a, 0x0c
);

// 0b5812a2-c3ff-4eca-b88d-c79e20ac6322
DEFINE_GUID(
   FWPM_LAYER_ALE_RESOURCE_ASSIGNMENT_V4_DISCARD,
   0x0b5812a2,
   0xc3ff,
   0x4eca,
   0xb8, 0x8d, 0xc7, 0x9e, 0x20, 0xac, 0x63, 0x22
);

// 55a650e1-5f0a-4eca-a653-88f53b26aa8c
DEFINE_GUID(
   FWPM_LAYER_ALE_RESOURCE_ASSIGNMENT_V6,
   0x55a650e1,
   0x5f0a,
   0x4eca,
   0xa6, 0x53, 0x88, 0xf5, 0x3b, 0x26, 0xaa, 0x8c
);

// cbc998bb-c51f-4c1a-bb4f-9775fcacab2f
DEFINE_GUID(
   FWPM_LAYER_ALE_RESOURCE_ASSIGNMENT_V6_DISCARD,
   0xcbc998bb,
   0xc51f,
   0x4c1a,
   0xbb, 0x4f, 0x97, 0x75, 0xfc, 0xac, 0xab, 0x2f
);

// 88bb5dad-76d7-4227-9c71-df0a3ed7be7e
DEFINE_GUID(
   FWPM_LAYER_ALE_AUTH_LISTEN_V4,
   0x88bb5dad,
   0x76d7,
   0x4227,
   0x9c, 0x71, 0xdf, 0x0a, 0x3e, 0xd7, 0xbe, 0x7e
);

// 371dfada-9f26-45fd-b4eb-c29eb212893f
DEFINE_GUID(
   FWPM_LAYER_ALE_AUTH_LISTEN_V4_DISCARD,
   0x371dfada,
   0x9f26,
   0x45fd,
   0xb4, 0xeb, 0xc2, 0x9e, 0xb2, 0x12, 0x89, 0x3f
);

// 7ac9de24-17dd-4814-b4bd-a9fbc95a321b
DEFINE_GUID(
   FWPM_LAYER_ALE_AUTH_LISTEN_V6,
   0x7ac9de24,
   0x17dd,
   0x4814,
   0xb4, 0xbd, 0xa9, 0xfb, 0xc9, 0x5a, 0x32, 0x1b
);

// 60703b07-63c8-48e9-ada3-12b1af40a617
DEFINE_GUID(
   FWPM_LAYER_ALE_AUTH_LISTEN_V6_DISCARD,
   0x60703b07,
   0x63c8,
   0x48e9,
   0xad, 0xa3, 0x12, 0xb1, 0xaf, 0x40, 0xa6, 0x17
);

// e1cd9fe7-f4b5-4273-96c0-592e487b8650
DEFINE_GUID(
   FWPM_LAYER_ALE_AUTH_RECV_ACCEPT_V4,
   0xe1cd9fe7,
   0xf4b5,
   0x4273,
   0x96, 0xc0, 0x59, 0x2e, 0x48, 0x7b, 0x86, 0x50
);

// 9eeaa99b-bd22-4227-919f-0073c63357b1
DEFINE_GUID(
   FWPM_LAYER_ALE_AUTH_RECV_ACCEPT_V4_DISCARD,
   0x9eeaa99b,
   0xbd22,
   0x4227,
   0x91, 0x9f, 0x00, 0x73, 0xc6, 0x33, 0x57, 0xb1
);

// a3b42c97-9f04-4672-b87e-cee9c483257f
DEFINE_GUID(
   FWPM_LAYER_ALE_AUTH_RECV_ACCEPT_V6,
   0xa3b42c97,
   0x9f04,
   0x4672,
   0xb8, 0x7e, 0xce, 0xe9, 0xc4, 0x83, 0x25, 0x7f
);

// 89455b97-dbe1-453f-a224-13da895af396
DEFINE_GUID(
   FWPM_LAYER_ALE_AUTH_RECV_ACCEPT_V6_DISCARD,
   0x89455b97,
   0xdbe1,
   0x453f,
   0xa2, 0x24, 0x13, 0xda, 0x89, 0x5a, 0xf3, 0x96
);

// c38d57d1-05a7-4c33-904f-7fbceee60e82
DEFINE_GUID(
   FWPM_LAYER_ALE_AUTH_CONNECT_V4,
   0xc38d57d1,
   0x05a7,
   0x4c33,
   0x90, 0x4f, 0x7f, 0xbc, 0xee, 0xe6, 0x0e, 0x82
);

// d632a801-f5ba-4ad6-96e3-607017d9836a
DEFINE_GUID(
   FWPM_LAYER_ALE_AUTH_CONNECT_V4_DISCARD,
   0xd632a801,
   0xf5ba,
   0x4ad6,
   0x96, 0xe3, 0x60, 0x70, 0x17, 0xd9, 0x83, 0x6a
);

// 4a72393b-319f-44bc-84c3-ba54dcb3b6b4
DEFINE_GUID(
   FWPM_LAYER_ALE_AUTH_CONNECT_V6,
   0x4a72393b,
   0x319f,
   0x44bc,
   0x84, 0xc3, 0xba, 0x54, 0xdc, 0xb3, 0xb6, 0xb4
);

// c97bc3b8-c9a3-4e33-8695-8e17aad4de09
DEFINE_GUID(
   FWPM_LAYER_ALE_AUTH_CONNECT_V6_DISCARD,
   0xc97bc3b8,
   0xc9a3,
   0x4e33,
   0x86, 0x95, 0x8e, 0x17, 0xaa, 0xd4, 0xde, 0x09
);

// af80470a-5596-4c13-9992-539e6fe57967
DEFINE_GUID(
   FWPM_LAYER_ALE_FLOW_ESTABLISHED_V4,
   0xaf80470a,
   0x5596,
   0x4c13,
   0x99, 0x92, 0x53, 0x9e, 0x6f, 0xe5, 0x79, 0x67
);

// 146ae4a9-a1d2-4d43-a31a-4c42682b8e4f
DEFINE_GUID(
   FWPM_LAYER_ALE_FLOW_ESTABLISHED_V4_DISCARD,
   0x146ae4a9,
   0xa1d2,
   0x4d43,
   0xa3, 0x1a, 0x4c, 0x42, 0x68, 0x2b, 0x8e, 0x4f
);

// 7021d2b3-dfa4-406e-afeb-6afaf7e70efd
DEFINE_GUID(
   FWPM_LAYER_ALE_FLOW_ESTABLISHED_V6,
   0x7021d2b3,
   0xdfa4,
   0x406e,
   0xaf, 0xeb, 0x6a, 0xfa, 0xf7, 0xe7, 0x0e, 0xfd
);

// 46928636-bbca-4b76-941d-0fa7f5d7d372
DEFINE_GUID(
   FWPM_LAYER_ALE_FLOW_ESTABLISHED_V6_DISCARD,
   0x46928636,
   0xbbca,
   0x4b76,
   0x94, 0x1d, 0x0f, 0xa7, 0xf5, 0xd7, 0xd3, 0x72
);

// f02b1526-a459-4a51-b9e3-759de52b9d2c
DEFINE_GUID(
   FWPM_LAYER_IPSEC_KM_DEMUX_V4,
   0xf02b1526,
   0xa459,
   0x4a51,
   0xb9, 0xe3, 0x75, 0x9d, 0xe5, 0x2b, 0x9d, 0x2c
);

// 2f755cf6-2fd4-4e88-b3e4-a91bca495235
DEFINE_GUID(
   FWPM_LAYER_IPSEC_KM_DEMUX_V6,
   0x2f755cf6,
   0x2fd4,
   0x4e88,
   0xb3, 0xe4, 0xa9, 0x1b, 0xca, 0x49, 0x52, 0x35
);

// eda65c74-610d-4bc5-948f-3c4f89556867
DEFINE_GUID(
   FWPM_LAYER_IPSEC_V4,
   0xeda65c74,
   0x610d,
   0x4bc5,
   0x94, 0x8f, 0x3c, 0x4f, 0x89, 0x55, 0x68, 0x67
);

// 13c48442-8d87-4261-9a29-59d2abc348b4
DEFINE_GUID(
   FWPM_LAYER_IPSEC_V6,
   0x13c48442,
   0x8d87,
   0x4261,
   0x9a, 0x29, 0x59, 0xd2, 0xab, 0xc3, 0x48, 0xb4
);

// b14b7bdb-dbbd-473e-bed4-8b4708d4f270
DEFINE_GUID(
   FWPM_LAYER_IKEEXT_V4,
   0xb14b7bdb,
   0xdbbd,
   0x473e,
   0xbe, 0xd4, 0x8b, 0x47, 0x08, 0xd4, 0xf2, 0x70
);

// b64786b3-f687-4eb9-89d2-8ef32acdabe2
DEFINE_GUID(
   FWPM_LAYER_IKEEXT_V6,
   0xb64786b3,
   0xf687,
   0x4eb9,
   0x89, 0xd2, 0x8e, 0xf3, 0x2a, 0xcd, 0xab, 0xe2
);

#ifndef UNDER_CE
//RPC UM layers are not supported in CE 7.0
// 75a89dda-95e4-40f3-adc7-7688a9c847e1
DEFINE_GUID(
   FWPM_LAYER_RPC_UM,
   0x75a89dda,
   0x95e4,
   0x40f3,
   0xad, 0xc7, 0x76, 0x88, 0xa9, 0xc8, 0x47, 0xe1
);

// 9247bc61-eb07-47ee-872c-bfd78bfd1616
DEFINE_GUID(
   FWPM_LAYER_RPC_EPMAP,
   0x9247bc61,
   0xeb07,
   0x47ee,
   0x87, 0x2c, 0xbf, 0xd7, 0x8b, 0xfd, 0x16, 0x16
);

// 618dffc7-c450-4943-95db-99b4c16a55d4
DEFINE_GUID(
   FWPM_LAYER_RPC_EP_ADD,
   0x618dffc7,
   0xc450,
   0x4943,
   0x95, 0xdb, 0x99, 0xb4, 0xc1, 0x6a, 0x55, 0xd4
);

// 94a4b50b-ba5c-4f27-907a-229fac0c2a7a
DEFINE_GUID(
   FWPM_LAYER_RPC_PROXY_CONN,
   0x94a4b50b,
   0xba5c,
   0x4f27,
   0x90, 0x7a, 0x22, 0x9f, 0xac, 0x0c, 0x2a, 0x7a
);

// f8a38615-e12c-41ac-98df-121ad981aade
DEFINE_GUID(
   FWPM_LAYER_RPC_PROXY_IF,
   0xf8a38615,
   0xe12c,
   0x41ac,
   0x98, 0xdf, 0x12, 0x1a, 0xd9, 0x81, 0xaa, 0xde
);
#endif //UNDER_CE

///////////////////////////////////////////////////////////////////////////////
//
// GUIDs for built-in sublayers.
//
///////////////////////////////////////////////////////////////////////////////

// 758c84f4-fb48-4de9-9aeb-3ed9551ab1fd
DEFINE_GUID(
   FWPM_SUBLAYER_RPC_AUDIT,
   0x758c84f4,
   0xfb48,
   0x4de9,
   0x9a, 0xeb, 0x3e, 0xd9, 0x55, 0x1a, 0xb1, 0xfd
);

// 83f299ed-9ff4-4967-aff4-c309f4dab827
DEFINE_GUID(
   FWPM_SUBLAYER_IPSEC_TUNNEL,
   0x83f299ed,
   0x9ff4,
   0x4967,
   0xaf, 0xf4, 0xc3, 0x09, 0xf4, 0xda, 0xb8, 0x27
);

// eebecc03-ced4-4380-819a-2734397b2b74
DEFINE_GUID(
   FWPM_SUBLAYER_UNIVERSAL,
   0xeebecc03,
   0xced4,
   0x4380,
   0x81, 0x9a, 0x27, 0x34, 0x39, 0x7b, 0x2b, 0x74
);

// 1b75c0ce-ff60-4711-a70f-b4958cc3b2d0
DEFINE_GUID(
   FWPM_SUBLAYER_LIPS,
   0x1b75c0ce,
   0xff60,
   0x4711,
   0xa7, 0x0f, 0xb4, 0x95, 0x8c, 0xc3, 0xb2, 0xd0
);

// 15a66e17-3f3c-4f7b-aa6c-812aa613dd82
DEFINE_GUID(
   FWPM_SUBLAYER_SECURE_SOCKET,
   0x15a66e17,
   0x3f3c,
   0x4f7b,
   0xaa, 0x6c, 0x81, 0x2a, 0xa6, 0x13, 0xdd, 0x82
);

// 337608b9-b7d5-4d5f-82f9-3618618bc058
DEFINE_GUID(
   FWPM_SUBLAYER_TCP_CHIMNEY_OFFLOAD,
   0x337608b9,
   0xb7d5,
   0x4d5f,
   0x82, 0xf9, 0x36, 0x18, 0x61, 0x8b, 0xc0, 0x58
);

// 877519e1-e6a9-41a5-81b4-8c4f118e4a60
DEFINE_GUID(
   FWPM_SUBLAYER_INSPECTION,
   0x877519e1,
   0xe6a9,
   0x41a5,
   0x81, 0xb4, 0x8c, 0x4f, 0x11, 0x8e, 0x4a, 0x60
);

// ba69dc66-5176-4979-9c89-26a7b46a8327
DEFINE_GUID(
   FWPM_SUBLAYER_TEREDO,
   0xba69dc66,
   0x5176,
   0x4979,
   0x9c, 0x89, 0x26, 0xa7, 0xb4, 0x6a, 0x83, 0x27
);

// c8e65357-78bf-4854-b583-336de103f2a6
DEFINE_GUID(
   FWPM_SUBLAYER_SECURITY_MODEL,
   0xc8e65357,
   0x78bf,
   0x4854,
   0xb5, 0x83, 0x33, 0x6d, 0xe1, 0x03, 0xf2, 0xa6
);


#if (NTDDI_VERSION >= NTDDI_WIN6SP1)

// a5082e73-8f71-4559-8a9a-101cea04ef87
DEFINE_GUID(
   FWPM_SUBLAYER_IPSEC_FORWARD_OUTBOUND_TUNNEL,
   0xa5082e73,
   0x8f71,
   0x4559,
   0x8a, 0x9a, 0x10, 0x1c, 0xea, 0x04, 0xef, 0x87
);

#endif // (NTDDI_VERSION >= NTDDI_WIN6SP1)

///////////////////////////////////////////////////////////////////////////////
//
// GUIDs for built-in conditions.
//
///////////////////////////////////////////////////////////////////////////////

// d9ee00de-c1ef-4617-bfe3-ffd8f5a08957
DEFINE_GUID(
   FWPM_CONDITION_IP_LOCAL_ADDRESS,
   0xd9ee00de,
   0xc1ef,
   0x4617,
   0xbf, 0xe3, 0xff, 0xd8, 0xf5, 0xa0, 0x89, 0x57
);

// b235ae9a-1d64-49b8-a44c-5ff3d9095045
DEFINE_GUID(
   FWPM_CONDITION_IP_REMOTE_ADDRESS,
   0xb235ae9a,
   0x1d64,
   0x49b8,
   0xa4, 0x4c, 0x5f, 0xf3, 0xd9, 0x09, 0x50, 0x45
);

// ae96897e-2e94-4bc9-b313-b27ee80e574d
DEFINE_GUID(
   FWPM_CONDITION_IP_SOURCE_ADDRESS,
   0xae96897e,
   0x2e94,
   0x4bc9,
   0xb3, 0x13, 0xb2, 0x7e, 0xe8, 0x0e, 0x57, 0x4d
);

// 2d79133b-b390-45c6-8699-acaceaafed33
DEFINE_GUID(
   FWPM_CONDITION_IP_DESTINATION_ADDRESS,
   0x2d79133b,
   0xb390,
   0x45c6,
   0x86, 0x99, 0xac, 0xac, 0xea, 0xaf, 0xed, 0x33
);

// 6ec7f6c4-376b-45d7-9e9c-d337cedcd237
DEFINE_GUID(
   FWPM_CONDITION_IP_LOCAL_ADDRESS_TYPE,
   0x6ec7f6c4,
   0x376b,
   0x45d7,
   0x9e, 0x9c, 0xd3, 0x37, 0xce, 0xdc, 0xd2, 0x37
);

// 1ec1b7c9-4eea-4f5e-b9ef-76beaaaf17ee
DEFINE_GUID(
   FWPM_CONDITION_IP_DESTINATION_ADDRESS_TYPE,
   0x1ec1b7c9,
   0x4eea,
   0x4f5e,
   0xb9, 0xef, 0x76, 0xbe, 0xaa, 0xaf, 0x17, 0xee
);

// 4cd62a49-59c3-4969-b7f3-bda5d32890a4
DEFINE_GUID(
   FWPM_CONDITION_IP_LOCAL_INTERFACE,
   0x4cd62a49,
   0x59c3,
   0x4969,
   0xb7, 0xf3, 0xbd, 0xa5, 0xd3, 0x28, 0x90, 0xa4
);


#if (NTDDI_VERSION >= NTDDI_WIN6SP1)

// 618a9b6d-386b-4136-ad6e-b51587cfb1cd
DEFINE_GUID(
   FWPM_CONDITION_IP_ARRIVAL_INTERFACE,
   0x618a9b6d,
   0x386b,
   0x4136,
   0xad, 0x6e, 0xb5, 0x15, 0x87, 0xcf, 0xb1, 0xcd 
);

// 89f990de-e798-4e6d-ab76-7c9558292e6f
DEFINE_GUID(
   FWPM_CONDITION_ARRIVAL_INTERFACE_TYPE,
   0x89f990de,
   0xe798,
   0x4e6d,
   0xab, 0x76, 0x7c, 0x95, 0x58, 0x29, 0x2e, 0x6f
);

// 511166dc-7a8c-4aa7-b533-95ab59fb0340
DEFINE_GUID(
   FWPM_CONDITION_ARRIVAL_TUNNEL_TYPE,
   0x511166dc,
   0x7a8c,
   0x4aa7,
   0xb5, 0x33, 0x95, 0xab, 0x59, 0xfb, 0x03, 0x40
);

// cc088db3-1792-4a71-b0f9-037d21cd828b
DEFINE_GUID(
   FWPM_CONDITION_ARRIVAL_INTERFACE_INDEX,
   0xcc088db3,
   0x1792,
   0x4a71,
   0xb0, 0xf9, 0x03, 0x7d, 0x21, 0xcd, 0x82, 0x8b
);

#endif // (NTDDI_VERSION >= NTDDI_WIN6SP1)

// daf8cd14-e09e-4c93-a5ae-c5c13b73ffca
DEFINE_GUID(
   FWPM_CONDITION_INTERFACE_TYPE,
   0xdaf8cd14,
   0xe09e,
   0x4c93,
   0xa5, 0xae, 0xc5, 0xc1, 0x3b, 0x73, 0xff, 0xca
);

#if (NTDDI_VERSION >= NTDDI_WIN6SP1)

#define FWPM_CONDITION_LOCAL_INTERFACE_TYPE FWPM_CONDITION_INTERFACE_TYPE

#endif // (NTDDI_VERSION >= NTDDI_WIN6SP1)

// 77a40437-8779-4868-a261-f5a902f1c0cd
DEFINE_GUID(
   FWPM_CONDITION_TUNNEL_TYPE,
   0x77a40437,
   0x8779,
   0x4868,
   0xa2, 0x61, 0xf5, 0xa9, 0x02, 0xf1, 0xc0, 0xcd
);

#if (NTDDI_VERSION >= NTDDI_WIN6SP1)

#define FWPM_CONDITION_LOCAL_TUNNEL_TYPE FWPM_CONDITION_TUNNEL_TYPE

#endif // (NTDDI_VERSION >= NTDDI_WIN6SP1)

// 1076b8a5-6323-4c5e-9810-e8d3fc9e6136
DEFINE_GUID(
   FWPM_CONDITION_IP_FORWARD_INTERFACE,
   0x1076b8a5,
   0x6323,
   0x4c5e,
   0x98, 0x10, 0xe8, 0xd3, 0xfc, 0x9e, 0x61, 0x36
);

// 3971ef2b-623e-4f9a-8cb1-6e79b806b9a7
DEFINE_GUID(
   FWPM_CONDITION_IP_PROTOCOL,
   0x3971ef2b,
   0x623e,
   0x4f9a,
   0x8c, 0xb1, 0x6e, 0x79, 0xb8, 0x06, 0xb9, 0xa7
);

// 0c1ba1af-5765-453f-af22-a8f791ac775b
DEFINE_GUID(
   FWPM_CONDITION_IP_LOCAL_PORT,
   0x0c1ba1af,
   0x5765,
   0x453f,
   0xaf, 0x22, 0xa8, 0xf7, 0x91, 0xac, 0x77, 0x5b
);

#define FWPM_CONDITION_ICMP_TYPE FWPM_CONDITION_IP_LOCAL_PORT

// c35a604d-d22b-4e1a-91b4-68f674ee674b
DEFINE_GUID(
   FWPM_CONDITION_IP_REMOTE_PORT,
   0xc35a604d,
   0xd22b,
   0x4e1a,
   0x91, 0xb4, 0x68, 0xf6, 0x74, 0xee, 0x67, 0x4b
);

#define FWPM_CONDITION_ICMP_CODE FWPM_CONDITION_IP_REMOTE_PORT

// 4672a468-8a0a-4202-abb4-849e92e66809
DEFINE_GUID(
   FWPM_CONDITION_EMBEDDED_LOCAL_ADDRESS_TYPE,
   0x4672a468,
   0x8a0a,
   0x4202,
   0xab, 0xb4, 0x84, 0x9e, 0x92, 0xe6, 0x68, 0x09
);

// 77ee4b39-3273-4671-b63b-ab6feb66eeb6
DEFINE_GUID(
   FWPM_CONDITION_EMBEDDED_REMOTE_ADDRESS,
   0x77ee4b39,
   0x3273,
   0x4671,
   0xb6, 0x3b, 0xab, 0x6f, 0xeb, 0x66, 0xee, 0xb6
);

// 07784107-a29e-4c7b-9ec7-29c44afafdbc
DEFINE_GUID(
   FWPM_CONDITION_EMBEDDED_PROTOCOL,
   0x07784107,
   0xa29e,
   0x4c7b,
   0x9e, 0xc7, 0x29, 0xc4, 0x4a, 0xfa, 0xfd, 0xbc
);

// bfca394d-acdb-484e-b8e6-2aff79757345
DEFINE_GUID(
   FWPM_CONDITION_EMBEDDED_LOCAL_PORT,
   0xbfca394d,
   0xacdb,
   0x484e,
   0xb8, 0xe6, 0x2a, 0xff, 0x79, 0x75, 0x73, 0x45
);

// cae4d6a1-2968-40ed-a4ce-547160dda88d
DEFINE_GUID(
   FWPM_CONDITION_EMBEDDED_REMOTE_PORT,
   0xcae4d6a1,
   0x2968,
   0x40ed,
   0xa4, 0xce, 0x54, 0x71, 0x60, 0xdd, 0xa8, 0x8d
);

// 632ce23b-5167-435c-86d7-e903684aa80c
DEFINE_GUID(
   FWPM_CONDITION_FLAGS,
   0x632ce23b,
   0x5167,
   0x435c,
   0x86, 0xd7, 0xe9, 0x03, 0x68, 0x4a, 0xa8, 0x0c
);

// 8784c146-ca97-44d6-9fd1-19fb1840cbf7
DEFINE_GUID(
   FWPM_CONDITION_DIRECTION,
   0x8784c146,
   0xca97,
   0x44d6,
   0x9f, 0xd1, 0x19, 0xfb, 0x18, 0x40, 0xcb, 0xf7
);

// 667fd755-d695-434a-8af5-d3835a1259bc
DEFINE_GUID(
   FWPM_CONDITION_INTERFACE_INDEX,
   0x667fd755,
   0xd695,
   0x434a,
   0x8a, 0xf5, 0xd3, 0x83, 0x5a, 0x12, 0x59, 0xbc
);

#if (NTDDI_VERSION >= NTDDI_WIN6SP1)

#define FWPM_CONDITION_LOCAL_INTERFACE_INDEX FWPM_CONDITION_INTERFACE_INDEX

#endif // (NTDDI_VERSION >= NTDDI_WIN6SP1)


// 0cd42473-d621-4be3-ae8c-72a348d283e1
DEFINE_GUID(
   FWPM_CONDITION_SUB_INTERFACE_INDEX,
   0x0cd42473,
   0xd621,
   0x4be3,
   0xae, 0x8c, 0x72, 0xa3, 0x48, 0xd2, 0x83, 0xe1
);

#if (NTDDI_VERSION >= NTDDI_WIN6SP1)

#define FWPM_CONDITION_ARRIVAL_SUB_INTERFACE_INDEX \
        FWPM_CONDITION_SUB_INTERFACE_INDEX

#endif // (NTDDI_VERSION >= NTDDI_WIN6SP1)

// 2311334d-c92d-45bf-9496-edf447820e2d
DEFINE_GUID(
   FWPM_CONDITION_SOURCE_INTERFACE_INDEX,
   0x2311334d,
   0xc92d,
   0x45bf,
   0x94, 0x96, 0xed, 0xf4, 0x47, 0x82, 0x0e, 0x2d
);

// 055edd9d-acd2-4361-8dab-f9525d97662f
DEFINE_GUID(
   FWPM_CONDITION_SOURCE_SUB_INTERFACE_INDEX,
   0x055edd9d,
   0xacd2,
   0x4361,
   0x8d, 0xab, 0xf9, 0x52, 0x5d, 0x97, 0x66, 0x2f
);

// 35cf6522-4139-45ee-a0d5-67b80949d879
DEFINE_GUID(
   FWPM_CONDITION_DESTINATION_INTERFACE_INDEX,
   0x35cf6522,
   0x4139,
   0x45ee,
   0xa0, 0xd5, 0x67, 0xb8, 0x09, 0x49, 0xd8, 0x79
);

// 2b7d4399-d4c7-4738-a2f5-e994b43da388
DEFINE_GUID(
   FWPM_CONDITION_DESTINATION_SUB_INTERFACE_INDEX,
   0x2b7d4399,
   0xd4c7,
   0x4738,
   0xa2, 0xf5, 0xe9, 0x94, 0xb4, 0x3d, 0xa3, 0x88
);

// d78e1e87-8644-4ea5-9437-d809ecefc971
DEFINE_GUID(
   FWPM_CONDITION_ALE_APP_ID,
   0xd78e1e87,
   0x8644,
   0x4ea5,
   0x94, 0x37, 0xd8, 0x09, 0xec, 0xef, 0xc9, 0x71
);

// af043a0a-b34d-4f86-979c-c90371af6e66
DEFINE_GUID(
   FWPM_CONDITION_ALE_USER_ID,
   0xaf043a0a,
   0xb34d,
   0x4f86,
   0x97, 0x9c, 0xc9, 0x03, 0x71, 0xaf, 0x6e, 0x66
);

// f63073b7-0189-4ab0-95a4-6123cbfab862
DEFINE_GUID(
   FWPM_CONDITION_ALE_REMOTE_USER_ID,
   0xf63073b7,
   0x0189,
   0x4ab0,
   0x95, 0xa4, 0x61, 0x23, 0xcb, 0xfa, 0xb8, 0x62
);

// 1aa47f51-7f93-4508-a271-81abb00c9cab
DEFINE_GUID(
   FWPM_CONDITION_ALE_REMOTE_MACHINE_ID,
   0x1aa47f51,
   0x7f93,
   0x4508,
   0xa2, 0x71, 0x81, 0xab, 0xb0, 0x0c, 0x9c, 0xab
);

// 1c974776-7182-46e9-afd3-b02910e30334
DEFINE_GUID(
   FWPM_CONDITION_ALE_PROMISCUOUS_MODE,
   0x1c974776,
   0x7182,
   0x46e9,
   0xaf, 0xd3, 0xb0, 0x29, 0x10, 0xe3, 0x03, 0x34
);

// b9f4e088-cb98-4efb-a2c7-ad07332643db
DEFINE_GUID(
   FWPM_CONDITION_ALE_SIO_FIREWALL_SYSTEM_PORT,
   0xb9f4e088,
   0xcb98,
   0x4efb,
   0xa2, 0xc7, 0xad, 0x07, 0x33, 0x26, 0x43, 0xdb
);

// 46275a9d-c03f-4d77-b784-1c57f4d02753
DEFINE_GUID(
   FWPM_CONDITION_ALE_NAP_CONTEXT,
   0x46275a9d,
   0xc03f,
   0x4d77,
   0xb7, 0x84, 0x1c, 0x57, 0xf4, 0xd0, 0x27, 0x53
);

// 9bf0ee66-06c9-41b9-84da-288cb43af51f
DEFINE_GUID(
    FWPM_CONDITION_REMOTE_USER_TOKEN,
    0x9bf0ee66,
    0x06c9,
    0x41b9,
    0x84, 0xda, 0x28, 0x8c, 0xb4, 0x3a, 0xf5, 0x1f
);

// 7c9c7d9f-0075-4d35-a0d1-8311c4cf6af1
DEFINE_GUID(
   FWPM_CONDITION_RPC_IF_UUID,
   0x7c9c7d9f,
   0x0075,
   0x4d35,
   0xa0, 0xd1, 0x83, 0x11, 0xc4, 0xcf, 0x6a, 0xf1
);

// eabfd9b7-1262-4a2e-adaa-5f96f6fe326d
DEFINE_GUID(
   FWPM_CONDITION_RPC_IF_VERSION,
   0xeabfd9b7,
   0x1262,
   0x4a2e,
   0xad, 0xaa, 0x5f, 0x96, 0xf6, 0xfe, 0x32, 0x6d
);

// 238a8a32-3199-467d-871c-272621ab3896
DEFINE_GUID(
    FWPM_CONDITION_RPC_IF_FLAG,
    0x238a8a32,
    0x3199,
    0x467d,
    0x87, 0x1c, 0x27, 0x26, 0x21, 0xab, 0x38, 0x96
);

// ff2e7b4d-3112-4770-b636-4d24ae3a6af2
DEFINE_GUID(
    FWPM_CONDITION_DCOM_APP_ID,
    0xff2e7b4d,
    0x3112,
    0x4770,
    0xb6, 0x36, 0x4d, 0x24, 0xae, 0x3a, 0x6a, 0xf2
);

// d024de4d-deaa-4317-9c85-e40ef6e140c3
DEFINE_GUID(
    FWPM_CONDITION_IMAGE_NAME,
    0xd024de4d,
    0xdeaa,
    0x4317,
    0x9c, 0x85, 0xe4, 0x0e, 0xf6, 0xe1, 0x40, 0xc3
);

// 2717bc74-3a35-4ce7-b7ef-c838fabdec45
DEFINE_GUID(
    FWPM_CONDITION_RPC_PROTOCOL,
    0x2717bc74,
    0x3a35,
    0x4ce7,
    0xb7, 0xef, 0xc8, 0x38, 0xfa, 0xbd, 0xec, 0x45
);

// daba74ab-0d67-43e7-986e-75b84f82f594
DEFINE_GUID(
   FWPM_CONDITION_RPC_AUTH_TYPE,
   0xdaba74ab,
   0x0d67,
   0x43e7,
   0x98, 0x6e, 0x75, 0xb8, 0x4f, 0x82, 0xf5, 0x94
);

// e5a0aed5-59ac-46ea-be05-a5f05ecf446e
DEFINE_GUID(
   FWPM_CONDITION_RPC_AUTH_LEVEL,
   0xe5a0aed5,
   0x59ac,
   0x46ea,
   0xbe, 0x05, 0xa5, 0xf0, 0x5e, 0xcf, 0x44, 0x6e
);

// 0d306ef0-e974-4f74-b5c7-591b0da7d562
DEFINE_GUID(
   FWPM_CONDITION_SEC_ENCRYPT_ALGORITHM,
   0x0d306ef0,
   0xe974,
   0x4f74,
   0xb5, 0xc7, 0x59, 0x1b, 0x0d, 0xa7, 0xd5, 0x62
);

// 4772183b-ccf8-4aeb-bce1-c6c6161c8fe4
DEFINE_GUID(
    FWPM_CONDITION_SEC_KEY_SIZE,
    0x4772183b,
    0xccf8,
    0x4aeb,
    0xbc, 0xe1, 0xc6, 0xc6, 0x16, 0x1c, 0x8f, 0xe4
);

// 03a629cb-6e52-49f8-9c41-5709633c09cf
DEFINE_GUID(
   FWPM_CONDITION_IP_LOCAL_ADDRESS_V4,
   0x03a629cb,
   0x6e52,
   0x49f8,
   0x9c, 0x41, 0x57, 0x09, 0x63, 0x3c, 0x09, 0xcf
);

// 2381be84-7524-45b3-a05b-1e637d9c7a6a
DEFINE_GUID(
   FWPM_CONDITION_IP_LOCAL_ADDRESS_V6,
   0x2381be84,
   0x7524,
   0x45b3,
   0xa0, 0x5b, 0x1e, 0x63, 0x7d, 0x9c, 0x7a, 0x6a
);

// 1bd0741d-e3df-4e24-8634-762046eef6eb
DEFINE_GUID(
    FWPM_CONDITION_PIPE,
    0x1bd0741d,
    0xe3df,
    0x4e24,
    0x86, 0x34, 0x76, 0x20, 0x46, 0xee, 0xf6, 0xeb
);

// 1febb610-3bcc-45e1-bc36-2e067e2cb186
DEFINE_GUID(
   FWPM_CONDITION_IP_REMOTE_ADDRESS_V4,
   0x1febb610,
   0x3bcc,
   0x45e1,
   0xbc, 0x36, 0x2e, 0x06, 0x7e, 0x2c, 0xb1, 0x86
);

// 246e1d8c-8bee-4018-9b98-31d4582f3361
DEFINE_GUID(
   FWPM_CONDITION_IP_REMOTE_ADDRESS_V6,
   0x246e1d8c,
   0x8bee,
   0x4018,
   0x9b, 0x98, 0x31, 0xd4, 0x58, 0x2f, 0x33, 0x61
);

// e31180a8-bbbd-4d14-a65e-7157b06233bb
DEFINE_GUID(
    FWPM_CONDITION_PROCESS_WITH_RPC_IF_UUID,
    0xe31180a8,
    0xbbbd,
    0x4d14,
    0xa6, 0x5e, 0x71, 0x57, 0xb0, 0x62, 0x33, 0xbb
);

// dccea0b9-0886-4360-9c6a-ab043a24fba9
DEFINE_GUID(
    FWPM_CONDITION_RPC_EP_VALUE,
    0xdccea0b9,
    0x0886,
    0x4360,
    0x9c, 0x6a, 0xab, 0x04, 0x3a, 0x24, 0xfb, 0xa9
);

// 218b814a-0a39-49b8-8e71-c20c39c7dd2e
DEFINE_GUID(
    FWPM_CONDITION_RPC_EP_FLAGS,
    0x218b814a,
    0x0a39,
    0x49b8,
    0x8e, 0x71, 0xc2, 0x0c, 0x39, 0xc7, 0xdd, 0x2e
);

// c228fc1e-403a-4478-be05-c9baa4c05ace
DEFINE_GUID(
    FWPM_CONDITION_CLIENT_TOKEN,
    0xc228fc1e,
    0x403a,
    0x4478,
    0xbe, 0x05, 0xc9, 0xba, 0xa4, 0xc0, 0x5a, 0xce
);

// b605a225-c3b3-48c7-9833-7aefa9527546
DEFINE_GUID(
    FWPM_CONDITION_RPC_SERVER_NAME,
    0xb605a225,
    0xc3b3,
    0x48c7,
    0x98, 0x33, 0x7a, 0xef, 0xa9, 0x52, 0x75, 0x46
);

// 8090f645-9ad5-4e3b-9f9f-8023ca097909
DEFINE_GUID(
    FWPM_CONDITION_RPC_SERVER_PORT,
    0x8090f645,
    0x9ad5,
    0x4e3b,
    0x9f, 0x9f, 0x80, 0x23, 0xca, 0x09, 0x79, 0x09
);

// 40953fe2-8565-4759-8488-1771b4b4b5db
DEFINE_GUID(
    FWPM_CONDITION_RPC_PROXY_AUTH_TYPE,
    0x40953fe2,
    0x8565,
    0x4759,
    0x84, 0x88, 0x17, 0x71, 0xb4, 0xb4, 0xb5, 0xdb
);

// a3ec00c7-05f4-4df7-91f2-5f60d91ff443
DEFINE_GUID(
    FWPM_CONDITION_CLIENT_CERT_KEY_LENGTH,
    0xa3ec00c7,
    0x05f4,
    0x4df7,
    0x91, 0xf2, 0x5f, 0x60, 0xd9, 0x1f, 0xf4, 0x43
);

// c491ad5e-f882-4283-b916-436b103ff4ad
DEFINE_GUID(
    FWPM_CONDITION_CLIENT_CERT_OID,
    0xc491ad5e,
    0xf882,
    0x4283,
    0xb9, 0x16, 0x43, 0x6b, 0x10, 0x3f, 0xf4, 0xad
);

// 056d336d-ca55-489f-94b9-a4962f8246e2
DEFINE_GUID(
   FWPM_CONDITION_SCOPE_ID,
   0x056d336d,
   0xca55,
   0x489f,
   0x94, 0xb9, 0xa4, 0x96, 0x2f, 0x82, 0x46, 0xe2
);


///////////////////////////////////////////////////////////////////////////////
//
// GUIDs for built-in providers.
//
///////////////////////////////////////////////////////////////////////////////

// 10ad9216-ccde-456c-8b16-e9f04e60a90b
DEFINE_GUID(
   FWPM_PROVIDER_IKEEXT,
   0x10ad9216,
   0xccde,
   0x456c,
   0x8b, 0x16, 0xe9, 0xf0, 0x4e, 0x60, 0xa9, 0x0b
);

// 896aa19e-9a34-4bcb-ae79-beb9127c84b9
DEFINE_GUID(
   FWPM_PROVIDER_TCP_CHIMNEY_OFFLOAD,
   0x896aa19e,
   0x9a34,
   0x4bcb,
   0xae, 0x79, 0xbe, 0xb9, 0x12, 0x7c, 0x84, 0xb9
);


///////////////////////////////////////////////////////////////////////////////
//
// GUIDs for built-in callouts.
//
///////////////////////////////////////////////////////////////////////////////

// 5132900d-5e84-4b5f-80e4-01741e81ff10
DEFINE_GUID(
   FWPM_CALLOUT_IPSEC_INBOUND_TRANSPORT_V4,
   0x5132900d,
   0x5e84,
   0x4b5f,
   0x80, 0xe4, 0x01, 0x74, 0x1e, 0x81, 0xff, 0x10
);

// 49d3ac92-2a6c-4dcf-955f-1c3be009dd99
DEFINE_GUID(
   FWPM_CALLOUT_IPSEC_INBOUND_TRANSPORT_V6,
   0x49d3ac92,
   0x2a6c,
   0x4dcf,
   0x95, 0x5f, 0x1c, 0x3b, 0xe0, 0x09, 0xdd, 0x99
);

// 4b46bf0a-4523-4e57-aa38-a87987c910d9
DEFINE_GUID(
   FWPM_CALLOUT_IPSEC_OUTBOUND_TRANSPORT_V4,
   0x4b46bf0a,
   0x4523,
   0x4e57,
   0xaa, 0x38, 0xa8, 0x79, 0x87, 0xc9, 0x10, 0xd9
);

// 38d87722-ad83-4f11-a91f-df0fb077225b
DEFINE_GUID(
   FWPM_CALLOUT_IPSEC_OUTBOUND_TRANSPORT_V6,
   0x38d87722,
   0xad83,
   0x4f11,
   0xa9, 0x1f, 0xdf, 0x0f, 0xb0, 0x77, 0x22, 0x5b
);

// 191a8a46-0bf8-46cf-b045-4b45dfa6a324
DEFINE_GUID(
   FWPM_CALLOUT_IPSEC_INBOUND_TUNNEL_V4,
   0x191a8a46,
   0x0bf8,
   0x46cf,
   0xb0, 0x45, 0x4b, 0x45, 0xdf, 0xa6, 0xa3, 0x24
);

// 80c342e3-1e53-4d6f-9b44-03df5aeee154
DEFINE_GUID(
   FWPM_CALLOUT_IPSEC_INBOUND_TUNNEL_V6,
   0x80c342e3,
   0x1e53,
   0x4d6f,
   0x9b, 0x44, 0x03, 0xdf, 0x5a, 0xee, 0xe1, 0x54
);

// 70a4196c-835b-4fb0-98e8-075f4d977d46
DEFINE_GUID(
   FWPM_CALLOUT_IPSEC_OUTBOUND_TUNNEL_V4,
   0x70a4196c,
   0x835b,
   0x4fb0,
   0x98, 0xe8, 0x07, 0x5f, 0x4d, 0x97, 0x7d, 0x46
);

// f1835363-a6a5-4e62-b180-23db789d8da6
DEFINE_GUID(
   FWPM_CALLOUT_IPSEC_OUTBOUND_TUNNEL_V6,
   0xf1835363,
   0xa6a5,
   0x4e62,
   0xb1, 0x80, 0x23, 0xdb, 0x78, 0x9d, 0x8d, 0xa6
);

// 28829633-c4f0-4e66-873f-844db2a899c7
DEFINE_GUID(
   FWPM_CALLOUT_IPSEC_FORWARD_INBOUND_TUNNEL_V4,
   0x28829633,
   0xc4f0,
   0x4e66,
   0x87, 0x3f, 0x84, 0x4d, 0xb2, 0xa8, 0x99, 0xc7
);

// af50bec2-c686-429a-884d-b74443e7b0b4
DEFINE_GUID(
   FWPM_CALLOUT_IPSEC_FORWARD_INBOUND_TUNNEL_V6,
   0xaf50bec2,
   0xc686,
   0x429a,
   0x88, 0x4d, 0xb7, 0x44, 0x43, 0xe7, 0xb0, 0xb4
);

// fb532136-15cb-440b-937c-1717ca320c40
DEFINE_GUID(
   FWPM_CALLOUT_IPSEC_FORWARD_OUTBOUND_TUNNEL_V4,
   0xfb532136,
   0x15cb,
   0x440b,
   0x93, 0x7c, 0x17, 0x17, 0xca, 0x32, 0x0c, 0x40
);

// dae640cc-e021-4bee-9eb6-a48b275c8c1d
DEFINE_GUID(
   FWPM_CALLOUT_IPSEC_FORWARD_OUTBOUND_TUNNEL_V6,
   0xdae640cc,
   0xe021,
   0x4bee,
   0x9e, 0xb6, 0xa4, 0x8b, 0x27, 0x5c, 0x8c, 0x1d
);

// 7dff309b-ba7d-4aba-91aa-ae5c6640c944
DEFINE_GUID(
   FWPM_CALLOUT_IPSEC_INBOUND_INITIATE_SECURE_V4,
   0x7dff309b,
   0xba7d,
   0x4aba,
   0x91, 0xaa, 0xae, 0x5c, 0x66, 0x40, 0xc9, 0x44
);

// a9a0d6d9-c58c-474e-8aeb-3cfe99d6d53d
DEFINE_GUID(
   FWPM_CALLOUT_IPSEC_INBOUND_INITIATE_SECURE_V6,
   0xa9a0d6d9,
   0xc58c,
   0x474e,
   0x8a, 0xeb, 0x3c, 0xfe, 0x99, 0xd6, 0xd5, 0x3d
);

// 3df6e7de-fd20-48f2-9f26-f854444cba79
DEFINE_GUID(
   FWPM_CALLOUT_IPSEC_INBOUND_TUNNEL_ALE_ACCEPT_V4,
   0x3df6e7de,
   0xfd20,
   0x48f2,
   0x9f, 0x26, 0xf8, 0x54, 0x44, 0x4c, 0xba, 0x79
);

// a1e392d3-72ac-47bb-87a7-0122c69434ab
DEFINE_GUID(
   FWPM_CALLOUT_IPSEC_INBOUND_TUNNEL_ALE_ACCEPT_V6,
   0xa1e392d3,
   0x72ac,
   0x47bb,
   0x87, 0xa7, 0x01, 0x22, 0xc6, 0x94, 0x34, 0xab
);

// 6ac141fc-f75d-4203-b9c8-48e6149c2712
DEFINE_GUID(
   FWPM_CALLOUT_IPSEC_ALE_CONNECT_V4,
   0x6ac141fc,
   0xf75d,
   0x4203,
   0xb9,0xc8,0x48, 0xe6, 0x14, 0x9c, 0x27, 0x12
);

// 4c0dda05-e31f-4666-90b0-b3dfad34129a
DEFINE_GUID(
   FWPM_CALLOUT_IPSEC_ALE_CONNECT_V6,
   0x4c0dda05,
   0xe31f,
   0x4666,
   0x90, 0xb0, 0xb3, 0xdf, 0xad, 0x34, 0x12, 0x9a
);

// eda08606-2494-4d78-89bc-67837c03b969
DEFINE_GUID(
   FWPM_CALLOUT_WFP_TRANSPORT_LAYER_V4_SILENT_DROP,
   0xeda08606,
   0x2494,
   0x4d78,
   0x89, 0xbc, 0x67, 0x83, 0x7c, 0x03, 0xb9, 0x69
);

// 8693cc74-a075-4156-b476-9286eece814e
DEFINE_GUID(
   FWPM_CALLOUT_WFP_TRANSPORT_LAYER_V6_SILENT_DROP,
   0x8693cc74,
   0xa075,
   0x4156,
   0xb4, 0x76, 0x92, 0x86, 0xee, 0xce, 0x81, 0x4e
);

// f3e10ab3-2c25-4279-ac36-c30fc181bec4
DEFINE_GUID(
   FWPM_CALLOUT_TCP_CHIMNEY_CONNECT_LAYER_V4,
   0xf3e10ab3,
   0x2c25,
   0x4279,
   0xac, 0x36, 0xc3, 0x0f, 0xc1, 0x81, 0xbe, 0xc4
);

// 39e22085-a341-42fc-a279-aec94e689c56
DEFINE_GUID(
   FWPM_CALLOUT_TCP_CHIMNEY_CONNECT_LAYER_V6,
   0x39e22085,
   0xa341,
   0x42fc,
   0xa2, 0x79, 0xae, 0xc9, 0x4e, 0x68, 0x9c, 0x56
);

// e183ecb2-3a7f-4b54-8ad9-76050ed880ca
DEFINE_GUID(
   FWPM_CALLOUT_TCP_CHIMNEY_ACCEPT_LAYER_V4,
   0xe183ecb2,
   0x3a7f,
   0x4b54,
   0x8a, 0xd9, 0x76, 0x05, 0x0e, 0xd8, 0x80, 0xca
);

// 0378cf41-bf98-4603-81f2-7f12586079f6
DEFINE_GUID(
   FWPM_CALLOUT_TCP_CHIMNEY_ACCEPT_LAYER_V6,
   0x0378cf41,
   0xbf98,
   0x4603,
   0x81, 0xf2, 0x7f, 0x12, 0x58, 0x60, 0x79, 0xf6
);

// bc582280-1677-41e9-94ab-c2fcb15c2eeb
DEFINE_GUID(
   FWPM_CALLOUT_SET_OPTIONS_AUTH_CONNECT_LAYER_V4,
   0xbc582280,
   0x1677,
   0x41e9,
   0x94, 0xab, 0xc2, 0xfc, 0xb1, 0x5c, 0x2e, 0xeb
);

// 98e5373c-b884-490f-b65f-2f6a4a575195
DEFINE_GUID(
   FWPM_CALLOUT_SET_OPTIONS_AUTH_CONNECT_LAYER_V6,
   0x98e5373c,
   0xb884,
   0x490f,
   0xb6, 0x5f, 0x2f, 0x6a, 0x4a, 0x57, 0x51, 0x95
);

// 31b95392-066e-42a2-b7db-92f8acdd56f9
DEFINE_GUID(
   FWPM_CALLOUT_TEREDO_ALE_RESOURCE_ASSIGNMENT_V6,
   0x31b95392,
   0x066e,
   0x42a2,
   0xb7, 0xdb, 0x92, 0xf8, 0xac, 0xdd, 0x56, 0xf9
);

// 81a434e7-f60c-4378-bab8-c625a30f0197
DEFINE_GUID(
   FWPM_CALLOUT_TEREDO_ALE_LISTEN_V6,
   0x81a434e7,
   0xf60c,
   0x4378,
   0xba, 0xb8, 0xc6, 0x25, 0xa3, 0x0f, 0x01, 0x97
);

///////////////////////////////////////////////////////////////////////////////
//
// GUIDs for built-in provider contexts.
//
///////////////////////////////////////////////////////////////////////////////

// b25ea800-0d02-46ed-92bd-7fa84bb73e9d
DEFINE_GUID(
   FWPM_PROVIDER_CONTEXT_SECURE_SOCKET_AUTHIP,
   0xb25ea800,
   0x0d02,
   0x46ed,
   0x92, 0xbd, 0x7f, 0xa8, 0x4b, 0xb7, 0x3e, 0x9d
);


// 8c2d4144-f8e0-42c0-94ce-7ccfc63b2f9b
DEFINE_GUID(
   FWPM_PROVIDER_CONTEXT_SECURE_SOCKET_IPSEC,
   0x8c2d4144,
   0xf8e0,
   0x42c0,
   0x94, 0xce, 0x7c, 0xcf, 0xc6, 0x3b, 0x2f, 0x9b
);


///////////////////////////////////////////////////////////////////////////////
//
// GUIDs for built-in keying modules.
//
///////////////////////////////////////////////////////////////////////////////

// a9bbf787-82a8-45bb-a400-5d7e5952c7a9
DEFINE_GUID(
   FWPM_KEYING_MODULE_IKE,
   0xa9bbf787,
   0x82a8,
   0x45bb,
   0xa4, 0x00, 0x5d, 0x7e, 0x59, 0x52, 0xc7, 0xa9
);

// 11e3dae0-dd26-4590-857d-ab4b28d1a095
DEFINE_GUID(
   FWPM_KEYING_MODULE_AUTHIP,
   0x11e3dae0,
   0xdd26,
   0x4590,
   0x85, 0x7d, 0xab, 0x4b, 0x28, 0xd1, 0xa0, 0x95
);
#endif //GLOBUIDS

#ifndef GUID_DEFS_ONLY
#ifndef FWPMX_H
#define FWPMX_H

#include "fwpmtypes.h"

#ifdef __cplusplus
extern "C" {
#endif

///////////////////////////////////////////////////////////////////////////////
//
// Well-known filter weight ranges.
//
///////////////////////////////////////////////////////////////////////////////

// Number of bits used for auto-generated weights.
#define FWPM_AUTO_WEIGHT_BITS (60)
// Maximum auto-generated weight.
#define FWPM_AUTO_WEIGHT_MAX  (MAXUINT64 >> (64 - FWPM_AUTO_WEIGHT_BITS))
// Maximum allowed weight range.
#define FWPM_WEIGHT_RANGE_MAX (MAXUINT64 >> FWPM_AUTO_WEIGHT_BITS)

// IPsec policy
#define FWPM_WEIGHT_RANGE_IPSEC            (0x0)
// Filters to exempt IKE traffic from IPsec.
#define FWPM_WEIGHT_RANGE_IKE_EXEMPTIONS   (0xc)


///////////////////////////////////////////////////////////////////////////////
//
// IPsec transform constants.
//
///////////////////////////////////////////////////////////////////////////////

//////////
// Authentication transform constants
//////////

static const IPSEC_AUTH_TRANSFORM_ID0 IPSEC_AUTH_TRANSFORM_ID_HMAC_MD5_96 =
{
   IPSEC_AUTH_MD5,
   IPSEC_AUTH_CONFIG_HMAC_MD5_96
};

static const IPSEC_AUTH_TRANSFORM_ID0 IPSEC_AUTH_TRANSFORM_ID_HMAC_SHA_1_96 =
{
   IPSEC_AUTH_SHA_1,
   IPSEC_AUTH_CONFIG_HMAC_SHA_1_96
};

#if (NTDDI_VERSION >= NTDDI_WIN6SP1)

static const IPSEC_AUTH_TRANSFORM_ID0 IPSEC_AUTH_TRANSFORM_ID_HMAC_SHA_256_128 =
{
   IPSEC_AUTH_SHA_256,
   IPSEC_AUTH_CONFIG_HMAC_SHA_256_128
};

static const IPSEC_AUTH_TRANSFORM_ID0 IPSEC_AUTH_TRANSFORM_ID_GCM_AES_128 =
{
   IPSEC_AUTH_AES_128,
   IPSEC_AUTH_CONFIG_GCM_AES_128
};

static const IPSEC_AUTH_TRANSFORM_ID0 IPSEC_AUTH_TRANSFORM_ID_GCM_AES_192 =
{
   IPSEC_AUTH_AES_192,
   IPSEC_AUTH_CONFIG_GCM_AES_192
};

static const IPSEC_AUTH_TRANSFORM_ID0 IPSEC_AUTH_TRANSFORM_ID_GCM_AES_256 =
{
   IPSEC_AUTH_AES_256,
   IPSEC_AUTH_CONFIG_GCM_AES_256
};

#endif // (NTDDI_VERSION >= NTDDI_WIN6SP1)

//////////
// Cipher transform constants
//////////

static const IPSEC_CIPHER_TRANSFORM_ID0 IPSEC_CIPHER_TRANSFORM_ID_CBC_DES =
{
   IPSEC_CIPHER_TYPE_DES,
   IPSEC_CIPHER_CONFIG_CBC_DES
};

static const IPSEC_CIPHER_TRANSFORM_ID0 IPSEC_CIPHER_TRANSFORM_ID_CBC_3DES =
{
   IPSEC_CIPHER_TYPE_3DES,
   IPSEC_CIPHER_CONFIG_CBC_3DES
};

static const IPSEC_CIPHER_TRANSFORM_ID0 IPSEC_CIPHER_TRANSFORM_ID_AES_128 =
{
   IPSEC_CIPHER_TYPE_AES_128,
   IPSEC_CIPHER_CONFIG_CBC_AES_128
};

static const IPSEC_CIPHER_TRANSFORM_ID0 IPSEC_CIPHER_TRANSFORM_ID_AES_192 =
{
   IPSEC_CIPHER_TYPE_AES_192,
   IPSEC_CIPHER_CONFIG_CBC_AES_192
};

static const IPSEC_CIPHER_TRANSFORM_ID0 IPSEC_CIPHER_TRANSFORM_ID_AES_256 =
{
   IPSEC_CIPHER_TYPE_AES_256,
   IPSEC_CIPHER_CONFIG_CBC_AES_256
};

#if (NTDDI_VERSION >= NTDDI_WIN6SP1)

static const IPSEC_CIPHER_TRANSFORM_ID0 IPSEC_CIPHER_TRANSFORM_ID_GCM_AES_128 =
{
   IPSEC_CIPHER_TYPE_AES_128,
   IPSEC_CIPHER_CONFIG_GCM_AES_128
};

static const IPSEC_CIPHER_TRANSFORM_ID0 IPSEC_CIPHER_TRANSFORM_ID_GCM_AES_192 =
{
   IPSEC_CIPHER_TYPE_AES_192,
   IPSEC_CIPHER_CONFIG_GCM_AES_192
};

static const IPSEC_CIPHER_TRANSFORM_ID0 IPSEC_CIPHER_TRANSFORM_ID_GCM_AES_256 =
{
   IPSEC_CIPHER_TYPE_AES_256,
   IPSEC_CIPHER_CONFIG_GCM_AES_256
};

#endif // (NTDDI_VERSION >= NTDDI_WIN6SP1)

///////////////////////////////////////////////////////////////////////////////
//
// Well-known filter contexts.
//
///////////////////////////////////////////////////////////////////////////////

// IPSec transport filter contexts in inbound layer
#define FWPM_CONTEXT_IPSEC_INBOUND_PASSTHRU (0x1ui64)
#define FWPM_CONTEXT_IPSEC_INBOUND_PERSIST_CONNECTION_SECURITY (0x2ui64)
#define FWPM_CONTEXT_IPSEC_INBOUND_RESERVED (0xff00000000000000ui64)

// IPSec transport filter contexts in outbound layer
#define FWPM_CONTEXT_IPSEC_OUTBOUND_NEGOTIATE_DISCOVER (0x1ui64)

// Filter contexts used in the ALE connect layer
#define FWPM_CONTEXT_ALE_SET_CONNECTION_REQUIRE_IPSEC_SECURITY (0x2ui64)
#define FWPM_CONTEXT_ALE_SET_CONNECTION_LAZY_SD_EVALUATION (0x4ui64)

// Filter contexts used in the ALE connect or accept layer
#define FWPM_CONTEXT_ALE_SET_CONNECTION_REQUIRE_IPSEC_ENCRYPTION (0x8ui64)

// Contexts used by the TCP Chimney Offload callouts.
#define FWPM_CONTEXT_TCP_CHIMNEY_OFFLOAD_ENABLE (0x1ui64)
#define FWPM_CONTEXT_TCP_CHIMNEY_OFFLOAD_DISABLE (0x2ui64)

// Contexts used in the RPC audit sublayer
#define FWPM_CONTEXT_RPC_AUDIT_ENABLED (0x1ui64)

///////////////////////////////////////////////////////////////////////////////
//
// Access rights
//
///////////////////////////////////////////////////////////////////////////////

// Specific access rights.
#define FWPM_ACTRL_ADD               (0x00000001)
#define FWPM_ACTRL_ADD_LINK          (0x00000002)
#define FWPM_ACTRL_BEGIN_READ_TXN    (0x00000004)
#define FWPM_ACTRL_BEGIN_WRITE_TXN   (0x00000008)
#define FWPM_ACTRL_CLASSIFY          (0x00000010)
#define FWPM_ACTRL_ENUM              (0x00000020)
#define FWPM_ACTRL_OPEN              (0x00000040)
#define FWPM_ACTRL_READ              (0x00000080)
#define FWPM_ACTRL_READ_STATS        (0x00000100)
#define FWPM_ACTRL_SUBSCRIBE         (0x00000200)
#define FWPM_ACTRL_WRITE             (0x00000400)

// Generic access rights.
#define FWPM_GENERIC_READ \
      ( STANDARD_RIGHTS_READ       | \
        FWPM_ACTRL_BEGIN_READ_TXN  | \
        FWPM_ACTRL_CLASSIFY        | \
        FWPM_ACTRL_OPEN            | \
        FWPM_ACTRL_READ            | \
        FWPM_ACTRL_READ_STATS      )

#define FWPM_GENERIC_EXECUTE \
      ( STANDARD_RIGHTS_EXECUTE    | \
        FWPM_ACTRL_ENUM            | \
        FWPM_ACTRL_SUBSCRIBE       )

#define FWPM_GENERIC_WRITE \
      ( STANDARD_RIGHTS_WRITE      | \
        DELETE                     | \
        FWPM_ACTRL_ADD             | \
        FWPM_ACTRL_ADD_LINK        | \
        FWPM_ACTRL_BEGIN_WRITE_TXN | \
        FWPM_ACTRL_WRITE           )

#define FWPM_GENERIC_ALL \
      ( STANDARD_RIGHTS_REQUIRED   | \
        FWPM_ACTRL_ADD             | \
        FWPM_ACTRL_ADD_LINK        | \
        FWPM_ACTRL_BEGIN_READ_TXN  | \
        FWPM_ACTRL_BEGIN_WRITE_TXN | \
        FWPM_ACTRL_CLASSIFY        | \
        FWPM_ACTRL_ENUM            | \
        FWPM_ACTRL_OPEN            | \
        FWPM_ACTRL_READ            | \
        FWPM_ACTRL_READ_STATS      | \
        FWPM_ACTRL_SUBSCRIBE       | \
        FWPM_ACTRL_WRITE           )


///////////////////////////////////////////////////////////////////////////////
//
// Common utility functions.
//
///////////////////////////////////////////////////////////////////////////////

void WINAPI FwpmFreeMemory0(IN OUT void** p);


///////////////////////////////////////////////////////////////////////////////
//
// Functions for managing the engine.
//
///////////////////////////////////////////////////////////////////////////////

DWORD
WINAPI
FwpmEngineOpen0(
   IN OPTIONAL const wchar_t* serverName,
   IN UINT32 authnService,
   IN OPTIONAL SEC_WINNT_AUTH_IDENTITY_W* authIdentity,
   IN OPTIONAL const FWPM_SESSION0* session,
   OUT HANDLE* engineHandle
   );

DWORD
WINAPI
FwpmEngineClose0(IN HANDLE engineHandle);

DWORD
WINAPI
FwpmEngineGetOption0(
   IN HANDLE engineHandle,
   IN FWPM_ENGINE_OPTION option,
   OUT FWP_VALUE0** value
   );

DWORD
WINAPI
FwpmEngineSetOption0(
   IN HANDLE engineHandle,
   IN FWPM_ENGINE_OPTION option,
   IN const FWP_VALUE0* newValue
   );

DWORD
WINAPI
FwpmEngineGetSecurityInfo0(
   IN HANDLE engineHandle,
   IN SECURITY_INFORMATION securityInfo,
   OUT OPTIONAL PSID* sidOwner,
   OUT OPTIONAL PSID* sidGroup,
   OUT OPTIONAL PACL* dacl,
   OUT OPTIONAL PACL* sacl,
   OUT PSECURITY_DESCRIPTOR* securityDescriptor
   );

DWORD
WINAPI
FwpmEngineSetSecurityInfo0(
   IN HANDLE engineHandle,
   IN SECURITY_INFORMATION securityInfo,
   IN OPTIONAL const SID* sidOwner,
   IN OPTIONAL const SID* sidGroup,
   IN OPTIONAL const ACL* dacl,
   IN OPTIONAL const ACL* sacl
   );

DWORD
WINAPI
FwpmSessionCreateEnumHandle0(
   IN HANDLE engineHandle,
   IN OPTIONAL const FWPM_SESSION_ENUM_TEMPLATE0* enumTemplate,
   OUT HANDLE* enumHandle
   );

DWORD
WINAPI
FwpmSessionEnum0(
   IN HANDLE engineHandle,
   IN HANDLE enumHandle,
   IN UINT32 numEntriesRequested,
   OUT FWPM_SESSION0*** entries,
   OUT UINT32* numEntriesReturned
   );

DWORD
WINAPI
FwpmSessionDestroyEnumHandle0(
   IN HANDLE engineHandle,
   IN HANDLE enumHandle
   );


///////////////////////////////////////////////////////////////////////////////
//
// Functions for explicit transactions.
//
///////////////////////////////////////////////////////////////////////////////

#define FWPM_TXN_READ_ONLY (0x00000001)

DWORD
WINAPI
FwpmTransactionBegin0(
   IN HANDLE engineHandle,
   IN UINT32 flags
   );

DWORD
WINAPI
FwpmTransactionCommit0(IN HANDLE engineHandle);

DWORD
WINAPI
FwpmTransactionAbort0(IN HANDLE engineHandle);


///////////////////////////////////////////////////////////////////////////////
//
// Functions for managing providers.
//
///////////////////////////////////////////////////////////////////////////////

DWORD
WINAPI
FwpmProviderAdd0(
   IN HANDLE engineHandle,
   IN const FWPM_PROVIDER0* provider,
   IN OPTIONAL PSECURITY_DESCRIPTOR sd
   );

DWORD
WINAPI
FwpmProviderDeleteByKey0(
   IN HANDLE engineHandle,
   IN const GUID* key
   );

DWORD
WINAPI
FwpmProviderGetByKey0(
   IN HANDLE engineHandle,
   IN const GUID* key,
   OUT FWPM_PROVIDER0** provider
   );

DWORD
WINAPI
FwpmProviderCreateEnumHandle0(
   IN HANDLE engineHandle,
   IN OPTIONAL const FWPM_PROVIDER_ENUM_TEMPLATE0* enumTemplate,
   OUT HANDLE* enumHandle
   );

DWORD
WINAPI
FwpmProviderEnum0(
   IN HANDLE engineHandle,
   IN HANDLE enumHandle,
   IN UINT32 numEntriesRequested,
   OUT FWPM_PROVIDER0*** entries,
   OUT UINT32* numEntriesReturned
   );

DWORD
WINAPI
FwpmProviderDestroyEnumHandle0(
   IN HANDLE engineHandle,
   IN HANDLE enumHandle
   );

DWORD
WINAPI
FwpmProviderGetSecurityInfoByKey0(
   IN HANDLE engineHandle,
   IN OPTIONAL const GUID* key,
   IN SECURITY_INFORMATION securityInfo,
   OUT OPTIONAL PSID* sidOwner,
   OUT OPTIONAL PSID* sidGroup,
   OUT OPTIONAL PACL* dacl,
   OUT OPTIONAL PACL* sacl,
   OUT PSECURITY_DESCRIPTOR* securityDescriptor
   );

DWORD
WINAPI
FwpmProviderSetSecurityInfoByKey0(
   IN HANDLE engineHandle,
   IN OPTIONAL const GUID* key,
   IN SECURITY_INFORMATION securityInfo,
   IN OPTIONAL const SID* sidOwner,
   IN OPTIONAL const SID* sidGroup,
   IN OPTIONAL const ACL* dacl,
   IN OPTIONAL const ACL* sacl
   );

typedef void (CALLBACK *FWPM_PROVIDER_CHANGE_CALLBACK0)(
                           IN void* context,
                           IN const FWPM_PROVIDER_CHANGE0* change
                           );

DWORD
WINAPI
FwpmProviderSubscribeChanges0(
   IN HANDLE engineHandle,
   IN const FWPM_PROVIDER_SUBSCRIPTION0* subscription,
   IN FWPM_PROVIDER_CHANGE_CALLBACK0 callback,
   IN OPTIONAL void* context,
   OUT HANDLE* changeHandle
   );

DWORD
WINAPI
FwpmProviderUnsubscribeChanges0(
   IN HANDLE engineHandle,
   IN HANDLE changeHandle
   );

DWORD
WINAPI
FwpmProviderSubscriptionsGet0(
   IN HANDLE engineHandle,
   OUT FWPM_PROVIDER_SUBSCRIPTION0*** entries,
   OUT UINT32* numEntries
   );


///////////////////////////////////////////////////////////////////////////////
//
// Functions for managing provider contexts.
//
///////////////////////////////////////////////////////////////////////////////

DWORD
WINAPI
FwpmProviderContextAdd0(
   IN HANDLE engineHandle,
   IN const FWPM_PROVIDER_CONTEXT0* providerContext,
   IN OPTIONAL PSECURITY_DESCRIPTOR sd,
   OUT OPTIONAL UINT64* id
   );

DWORD
WINAPI
FwpmProviderContextDeleteById0(
   IN HANDLE engineHandle,
   IN UINT64 id
   );

DWORD
WINAPI
FwpmProviderContextDeleteByKey0(
   IN HANDLE engineHandle,
   IN const GUID* key
   );

DWORD
WINAPI
FwpmProviderContextGetById0(
   HANDLE engineHandle,
   IN UINT64 id,
   OUT FWPM_PROVIDER_CONTEXT0** providerContext
   );

DWORD
WINAPI
FwpmProviderContextGetByKey0(
   IN HANDLE engineHandle,
   IN const GUID* key,
   OUT FWPM_PROVIDER_CONTEXT0** providerContext
   );

DWORD
WINAPI
FwpmProviderContextCreateEnumHandle0(
   IN HANDLE engineHandle,
   IN OPTIONAL const FWPM_PROVIDER_CONTEXT_ENUM_TEMPLATE0* enumTemplate,
   OUT HANDLE* enumHandle
   );

DWORD
WINAPI
FwpmProviderContextEnum0(
   IN HANDLE engineHandle,
   IN HANDLE enumHandle,
   IN UINT32 numEntriesRequested,
   OUT FWPM_PROVIDER_CONTEXT0*** entries,
   OUT UINT32* numEntriesReturned
   );

DWORD
WINAPI
FwpmProviderContextDestroyEnumHandle0(
   IN HANDLE engineHandle,
   IN HANDLE enumHandle
   );

DWORD
WINAPI
FwpmProviderContextGetSecurityInfoByKey0(
   IN HANDLE engineHandle,
   IN OPTIONAL const GUID* key,
   IN SECURITY_INFORMATION securityInfo,
   OUT OPTIONAL PSID* sidOwner,
   OUT OPTIONAL PSID* sidGroup,
   OUT OPTIONAL PACL* dacl,
   OUT OPTIONAL PACL* sacl,
   OUT PSECURITY_DESCRIPTOR* securityDescriptor
   );

DWORD
WINAPI
FwpmProviderContextSetSecurityInfoByKey0(
   IN HANDLE engineHandle,
   IN OPTIONAL const GUID* key,
   IN SECURITY_INFORMATION securityInfo,
   IN OPTIONAL const SID* sidOwner,
   IN OPTIONAL const SID* sidGroup,
   IN OPTIONAL const ACL* dacl,
   IN OPTIONAL const ACL* sacl
   );

typedef void (CALLBACK *FWPM_PROVIDER_CONTEXT_CHANGE_CALLBACK0)(
                           IN void* context,
                           IN const FWPM_PROVIDER_CONTEXT_CHANGE0* change
                           );

DWORD
WINAPI
FwpmProviderContextSubscribeChanges0(
   IN HANDLE engineHandle,
   IN const FWPM_PROVIDER_CONTEXT_SUBSCRIPTION0* subscription,
   IN FWPM_PROVIDER_CONTEXT_CHANGE_CALLBACK0 callback,
   IN OPTIONAL void* context,
   OUT HANDLE* changeHandle
   );

DWORD
WINAPI
FwpmProviderContextUnsubscribeChanges0(
   IN HANDLE engineHandle,
   IN HANDLE changeHandle
   );

DWORD
WINAPI
FwpmProviderContextSubscriptionsGet0(
   IN HANDLE engineHandle,
   OUT FWPM_PROVIDER_CONTEXT_SUBSCRIPTION0*** entries,
   OUT UINT32* numEntries
   );


///////////////////////////////////////////////////////////////////////////////
//
// Functions for managing sub-layers.
//
///////////////////////////////////////////////////////////////////////////////

DWORD
WINAPI
FwpmSubLayerAdd0(
   IN HANDLE engineHandle,
   IN const FWPM_SUBLAYER0* subLayer,
   IN OPTIONAL PSECURITY_DESCRIPTOR sd
   );

DWORD
WINAPI
FwpmSubLayerDeleteByKey0(
   IN HANDLE engineHandle,
   IN const GUID* key
   );

DWORD
WINAPI
FwpmSubLayerGetByKey0(
   IN HANDLE engineHandle,
   IN const GUID* key,
   OUT FWPM_SUBLAYER0** subLayer
   );

DWORD
WINAPI
FwpmSubLayerCreateEnumHandle0(
   IN HANDLE engineHandle,
   IN OPTIONAL const FWPM_SUBLAYER_ENUM_TEMPLATE0* enumTemplate,
   OUT HANDLE* enumHandle
   );

DWORD
WINAPI
FwpmSubLayerEnum0(
   IN HANDLE engineHandle,
   IN HANDLE enumHandle,
   IN UINT32 numEntriesRequested,
   OUT FWPM_SUBLAYER0*** entries,
   OUT UINT32* numEntriesReturned
   );

DWORD
WINAPI
FwpmSubLayerDestroyEnumHandle0(
   IN HANDLE engineHandle,
   IN HANDLE enumHandle
   );

DWORD
WINAPI
FwpmSubLayerGetSecurityInfoByKey0(
   IN HANDLE engineHandle,
   IN OPTIONAL const GUID* key,
   IN SECURITY_INFORMATION securityInfo,
   OUT OPTIONAL PSID* sidOwner,
   OUT OPTIONAL PSID* sidGroup,
   OUT OPTIONAL PACL* dacl,
   OUT OPTIONAL PACL* sacl,
   OUT PSECURITY_DESCRIPTOR* securityDescriptor
   );

DWORD
WINAPI
FwpmSubLayerSetSecurityInfoByKey0(
   IN HANDLE engineHandle,
   IN OPTIONAL const GUID* key,
   IN SECURITY_INFORMATION securityInfo,
   IN OPTIONAL const SID* sidOwner,
   IN OPTIONAL const SID* sidGroup,
   IN OPTIONAL const ACL* dacl,
   IN OPTIONAL const ACL* sacl
   );

typedef void (CALLBACK *FWPM_SUBLAYER_CHANGE_CALLBACK0)(
                           IN void* context,
                           IN const FWPM_SUBLAYER_CHANGE0* change
                           );

DWORD
WINAPI
FwpmSubLayerSubscribeChanges0(
   IN HANDLE engineHandle,
   IN const FWPM_SUBLAYER_SUBSCRIPTION0* subscription,
   IN FWPM_SUBLAYER_CHANGE_CALLBACK0 callback,
   IN OPTIONAL void* context,
   OUT HANDLE* changeHandle
   );

DWORD
WINAPI
FwpmSubLayerUnsubscribeChanges0(
   IN HANDLE engineHandle,
   IN HANDLE changeHandle
   );

DWORD
WINAPI
FwpmSubLayerSubscriptionsGet0(
   IN HANDLE engineHandle,
   OUT FWPM_SUBLAYER_SUBSCRIPTION0*** entries,
   OUT UINT32* numEntries
   );


///////////////////////////////////////////////////////////////////////////////
//
// Functions for managing layers.
//
///////////////////////////////////////////////////////////////////////////////

DWORD
WINAPI
FwpmLayerGetById0(
   HANDLE engineHandle,
   IN UINT16 id,
   OUT FWPM_LAYER0** layer
   );

DWORD
WINAPI
FwpmLayerGetByKey0(
   IN HANDLE engineHandle,
   IN const GUID* key,
   OUT FWPM_LAYER0** layer
   );

DWORD
WINAPI
FwpmLayerCreateEnumHandle0(
   IN HANDLE engineHandle,
   IN OPTIONAL const FWPM_LAYER_ENUM_TEMPLATE0* enumTemplate,
   OUT HANDLE* enumHandle
   );

DWORD
WINAPI
FwpmLayerEnum0(
   IN HANDLE engineHandle,
   IN HANDLE enumHandle,
   IN UINT32 numEntriesRequested,
   OUT FWPM_LAYER0*** entries,
   OUT UINT32* numEntriesReturned
   );

DWORD
WINAPI
FwpmLayerDestroyEnumHandle0(
   IN HANDLE engineHandle,
   IN HANDLE enumHandle
   );

DWORD
WINAPI
FwpmLayerGetSecurityInfoByKey0(
   IN HANDLE engineHandle,
   IN OPTIONAL const GUID* key,
   IN SECURITY_INFORMATION securityInfo,
   OUT OPTIONAL PSID* sidOwner,
   OUT OPTIONAL PSID* sidGroup,
   OUT OPTIONAL PACL* dacl,
   OUT OPTIONAL PACL* sacl,
   OUT PSECURITY_DESCRIPTOR* securityDescriptor
   );

DWORD
WINAPI
FwpmLayerSetSecurityInfoByKey0(
   IN HANDLE engineHandle,
   IN OPTIONAL const GUID* key,
   IN SECURITY_INFORMATION securityInfo,
   IN OPTIONAL const SID* sidOwner,
   IN OPTIONAL const SID* sidGroup,
   IN OPTIONAL const ACL* dacl,
   IN OPTIONAL const ACL* sacl
   );


///////////////////////////////////////////////////////////////////////////////
//
// Functions for managing callouts.
//
///////////////////////////////////////////////////////////////////////////////

DWORD
WINAPI
FwpmCalloutAdd0(
   IN HANDLE engineHandle,
   IN const FWPM_CALLOUT0* callout,
   IN OPTIONAL PSECURITY_DESCRIPTOR sd,
   OUT OPTIONAL UINT32* id
   );

DWORD
WINAPI
FwpmCalloutDeleteById0(
   IN HANDLE engineHandle,
   IN UINT32 id
   );

DWORD
WINAPI
FwpmCalloutDeleteByKey0(
   IN HANDLE engineHandle,
   IN const GUID* key
   );

DWORD
WINAPI
FwpmCalloutGetById0(
   HANDLE engineHandle,
   IN UINT32 id,
   OUT FWPM_CALLOUT0** callout
   );

DWORD
WINAPI
FwpmCalloutGetByKey0(
   IN HANDLE engineHandle,
   IN const GUID* key,
   OUT FWPM_CALLOUT0** callout
   );

DWORD
WINAPI
FwpmCalloutCreateEnumHandle0(
   IN HANDLE engineHandle,
   IN OPTIONAL const FWPM_CALLOUT_ENUM_TEMPLATE0* enumTemplate,
   OUT HANDLE* enumHandle
   );

DWORD
WINAPI
FwpmCalloutEnum0(
   IN HANDLE engineHandle,
   IN HANDLE enumHandle,
   IN UINT32 numEntriesRequested,
   OUT FWPM_CALLOUT0*** entries,
   OUT UINT32* numEntriesReturned
   );

DWORD
WINAPI
FwpmCalloutDestroyEnumHandle0(
   IN HANDLE engineHandle,
   IN HANDLE enumHandle
   );

DWORD
WINAPI
FwpmCalloutGetSecurityInfoByKey0(
   IN HANDLE engineHandle,
   IN OPTIONAL const GUID* key,
   IN SECURITY_INFORMATION securityInfo,
   OUT OPTIONAL PSID* sidOwner,
   OUT OPTIONAL PSID* sidGroup,
   OUT OPTIONAL PACL* dacl,
   OUT OPTIONAL PACL* sacl,
   OUT PSECURITY_DESCRIPTOR* securityDescriptor
   );

DWORD
WINAPI
FwpmCalloutSetSecurityInfoByKey0(
   IN HANDLE engineHandle,
   IN OPTIONAL const GUID* key,
   IN SECURITY_INFORMATION securityInfo,
   IN OPTIONAL const SID* sidOwner,
   IN OPTIONAL const SID* sidGroup,
   IN OPTIONAL const ACL* dacl,
   IN OPTIONAL const ACL* sacl
   );

typedef void (CALLBACK *FWPM_CALLOUT_CHANGE_CALLBACK0)(
                           IN void* context,
                           IN const FWPM_CALLOUT_CHANGE0* change
                           );

DWORD
WINAPI
FwpmCalloutSubscribeChanges0(
   IN HANDLE engineHandle,
   IN const FWPM_CALLOUT_SUBSCRIPTION0* subscription,
   IN FWPM_CALLOUT_CHANGE_CALLBACK0 callback,
   IN OPTIONAL void* context,
   OUT HANDLE* changeHandle
   );

DWORD
WINAPI
FwpmCalloutUnsubscribeChanges0(
   IN HANDLE engineHandle,
   IN HANDLE changeHandle
   );

DWORD
WINAPI
FwpmCalloutSubscriptionsGet0(
   IN HANDLE engineHandle,
   OUT FWPM_CALLOUT_SUBSCRIPTION0*** entries,
   OUT UINT32* numEntries
   );


///////////////////////////////////////////////////////////////////////////////
//
// Functions for managing filters.
//
///////////////////////////////////////////////////////////////////////////////

DWORD
WINAPI
FwpmFilterAdd0(
   IN HANDLE engineHandle,
   IN const FWPM_FILTER0* filter,
   IN OPTIONAL PSECURITY_DESCRIPTOR sd,
   OUT OPTIONAL UINT64* id
   );

DWORD
WINAPI
FwpmFilterDeleteById0(
   IN HANDLE engineHandle,
   IN UINT64 id
   );

DWORD
WINAPI
FwpmFilterDeleteByKey0(
   IN HANDLE engineHandle,
   IN const GUID* key
   );

DWORD
WINAPI
FwpmFilterGetById0(
   HANDLE engineHandle,
   IN UINT64 id,
   OUT FWPM_FILTER0** filter
   );

DWORD
WINAPI
FwpmFilterGetByKey0(
   IN HANDLE engineHandle,
   IN const GUID* key,
   OUT FWPM_FILTER0** filter
   );

DWORD
WINAPI
FwpmFilterCreateEnumHandle0(
   IN HANDLE engineHandle,
   IN OPTIONAL const FWPM_FILTER_ENUM_TEMPLATE0* enumTemplate,
   OUT HANDLE* enumHandle
   );

DWORD
WINAPI
FwpmFilterEnum0(
   IN HANDLE engineHandle,
   IN HANDLE enumHandle,
   IN UINT32 numEntriesRequested,
   OUT FWPM_FILTER0*** entries,
   OUT UINT32* numEntriesReturned
   );

DWORD
WINAPI
FwpmFilterDestroyEnumHandle0(
   IN HANDLE engineHandle,
   IN HANDLE enumHandle
   );

DWORD
WINAPI
FwpmFilterGetSecurityInfoByKey0(
   IN HANDLE engineHandle,
   IN OPTIONAL const GUID* key,
   IN SECURITY_INFORMATION securityInfo,
   OUT OPTIONAL PSID* sidOwner,
   OUT OPTIONAL PSID* sidGroup,
   OUT OPTIONAL PACL* dacl,
   OUT OPTIONAL PACL* sacl,
   OUT PSECURITY_DESCRIPTOR* securityDescriptor
   );

DWORD
WINAPI
FwpmFilterSetSecurityInfoByKey0(
   IN HANDLE engineHandle,
   IN OPTIONAL const GUID* key,
   IN SECURITY_INFORMATION securityInfo,
   IN OPTIONAL const SID* sidOwner,
   IN OPTIONAL const SID* sidGroup,
   IN OPTIONAL const ACL* dacl,
   IN OPTIONAL const ACL* sacl
   );

typedef void (CALLBACK *FWPM_FILTER_CHANGE_CALLBACK0)(
                           IN void* context,
                           IN const FWPM_FILTER_CHANGE0* change
                           );

DWORD
WINAPI
FwpmFilterSubscribeChanges0(
   IN HANDLE engineHandle,
   IN const FWPM_FILTER_SUBSCRIPTION0* subscription,
   IN FWPM_FILTER_CHANGE_CALLBACK0 callback,
   IN OPTIONAL void* context,
   OUT HANDLE* changeHandle
   );

DWORD
WINAPI
FwpmFilterUnsubscribeChanges0(
   IN HANDLE engineHandle,
   IN HANDLE changeHandle
   );

DWORD
WINAPI
FwpmFilterSubscriptionsGet0(
   IN HANDLE engineHandle,
   OUT FWPM_FILTER_SUBSCRIPTION0*** entries,
   OUT UINT32* numEntries
   );

DWORD
WINAPI
FwpmGetAppIdFromFileName0(
   IN const wchar_t* fileName,
   OUT FWP_BYTE_BLOB** appId
   );


///////////////////////////////////////////////////////////////////////////////
//
// Helper functions for configuring an IPsec tunnel.
//
///////////////////////////////////////////////////////////////////////////////

// Create a point-to-point tunnel.
#define FWPM_TUNNEL_FLAG_POINT_TO_POINT (0x00000001)

DWORD
WINAPI
FwpmIPsecTunnelAdd0(
   IN HANDLE engineHandle,
   IN UINT32 flags,
   IN OPTIONAL const FWPM_PROVIDER_CONTEXT0* mainModePolicy,
   IN const FWPM_PROVIDER_CONTEXT0* tunnelPolicy,
   IN UINT32 numFilterConditions,
   IN const FWPM_FILTER_CONDITION0* filterConditions,
   IN OPTIONAL PSECURITY_DESCRIPTOR sd
   );

DWORD
WINAPI
FwpmIPsecTunnelDeleteByKey0(
   IN HANDLE engineHandle,
   IN const GUID* key
   );


///////////////////////////////////////////////////////////////////////////////
//
// Functions for managing IPsec.
//
///////////////////////////////////////////////////////////////////////////////

DWORD
WINAPI
IPsecGetStatistics0(
   IN HANDLE engineHandle,
   OUT IPSEC_STATISTICS0* ipsecStatistics
   );

DWORD
WINAPI
IPsecSaContextCreate0(
   IN HANDLE engineHandle,
   IN const IPSEC_TRAFFIC0* outboundTraffic,
   OUT OPTIONAL UINT64* inboundFilterId,
   OUT UINT64* id
   );

DWORD
WINAPI
IPsecSaContextDeleteById0(
   IN HANDLE engineHandle,
   IN UINT64 id
   );

DWORD
WINAPI
IPsecSaContextGetById0(
   HANDLE engineHandle,
   IN UINT64 id,
   OUT IPSEC_SA_CONTEXT0** saContext
   );

DWORD
WINAPI
IPsecSaContextGetSpi0(
   IN HANDLE engineHandle,
   IN UINT64 id,
   IN const IPSEC_GETSPI0* getSpi,
   OUT IPSEC_SA_SPI* inboundSpi
   );

DWORD
WINAPI
IPsecSaContextAddInbound0(
   IN HANDLE engineHandle,
   IN UINT64 id,
   IN const IPSEC_SA_BUNDLE0* inboundBundle
   );

DWORD
WINAPI
IPsecSaContextAddOutbound0(
   IN HANDLE engineHandle,
   IN UINT64 id,
   IN const IPSEC_SA_BUNDLE0* outboundBundle
   );

DWORD
WINAPI
IPsecSaContextExpire0(
   IN HANDLE engineHandle,
   IN UINT64 id
   );

DWORD
WINAPI
IPsecSaContextCreateEnumHandle0(
   IN HANDLE engineHandle,
   IN OPTIONAL const IPSEC_SA_CONTEXT_ENUM_TEMPLATE0* enumTemplate,
   OUT HANDLE* enumHandle
   );

DWORD
WINAPI
IPsecSaContextEnum0(
   IN HANDLE engineHandle,
   IN HANDLE enumHandle,
   IN UINT32 numEntriesRequested,
   OUT IPSEC_SA_CONTEXT0*** entries,
   OUT UINT32* numEntriesReturned
   );

DWORD
WINAPI
IPsecSaContextDestroyEnumHandle0(
   IN HANDLE engineHandle,
   IN HANDLE enumHandle
   );

DWORD
WINAPI
IPsecSaCreateEnumHandle0(
   IN HANDLE engineHandle,
   IN OPTIONAL const IPSEC_SA_ENUM_TEMPLATE0* enumTemplate,
   OUT HANDLE* enumHandle
   );

DWORD
WINAPI
IPsecSaEnum0(
   IN HANDLE engineHandle,
   IN HANDLE enumHandle,
   IN UINT32 numEntriesRequested,
   OUT IPSEC_SA_DETAILS0*** entries,
   OUT UINT32* numEntriesReturned
   );

DWORD
WINAPI
IPsecSaDestroyEnumHandle0(
   IN HANDLE engineHandle,
   IN HANDLE enumHandle
   );

DWORD
WINAPI
IPsecSaDbGetSecurityInfo0(
   IN HANDLE engineHandle,
   IN SECURITY_INFORMATION securityInfo,
   OUT OPTIONAL PSID* sidOwner,
   OUT OPTIONAL PSID* sidGroup,
   OUT OPTIONAL PACL* dacl,
   OUT OPTIONAL PACL* sacl,
   OUT PSECURITY_DESCRIPTOR* securityDescriptor
   );

DWORD
WINAPI
IPsecSaDbSetSecurityInfo0(
   IN HANDLE engineHandle,
   IN SECURITY_INFORMATION securityInfo,
   IN OPTIONAL const SID* sidOwner,
   IN OPTIONAL const SID* sidGroup,
   IN OPTIONAL const ACL* dacl,
   IN OPTIONAL const ACL* sacl
   );


///////////////////////////////////////////////////////////////////////////////
//
// Functions for managing IKE, Authip.
//
///////////////////////////////////////////////////////////////////////////////

DWORD
WINAPI
IkeextGetStatistics0(
   IN HANDLE engineHandle,
   OUT IKEEXT_STATISTICS0* ikeextStatistics
   );

DWORD
WINAPI
IkeextSaDeleteById0(
   IN HANDLE engineHandle,
   IN UINT64 id
   );

DWORD
WINAPI
IkeextSaGetById0(
   HANDLE engineHandle,
   IN UINT64 id,
   OUT IKEEXT_SA_DETAILS0** sa
   );

DWORD
WINAPI
IkeextSaCreateEnumHandle0(
   IN HANDLE engineHandle,
   IN OPTIONAL const IKEEXT_SA_ENUM_TEMPLATE0* enumTemplate,
   OUT HANDLE* enumHandle
   );

DWORD
WINAPI
IkeextSaEnum0(
   IN HANDLE engineHandle,
   IN HANDLE enumHandle,
   IN UINT32 numEntriesRequested,
   OUT IKEEXT_SA_DETAILS0*** entries,
   OUT UINT32* numEntriesReturned
   );

DWORD
WINAPI
IkeextSaDestroyEnumHandle0(
   IN HANDLE engineHandle,
   IN HANDLE enumHandle
   );

DWORD
WINAPI
IkeextSaDbGetSecurityInfo0(
   IN HANDLE engineHandle,
   IN SECURITY_INFORMATION securityInfo,
   OUT OPTIONAL PSID* sidOwner,
   OUT OPTIONAL PSID* sidGroup,
   OUT OPTIONAL PACL* dacl,
   OUT OPTIONAL PACL* sacl,
   OUT PSECURITY_DESCRIPTOR* securityDescriptor
   );

DWORD
WINAPI
IkeextSaDbSetSecurityInfo0(
   IN HANDLE engineHandle,
   IN SECURITY_INFORMATION securityInfo,
   IN OPTIONAL const SID* sidOwner,
   IN OPTIONAL const SID* sidGroup,
   IN OPTIONAL const ACL* dacl,
   IN OPTIONAL const ACL* sacl
   );

///////////////////////////////////////////////////////////////////////////////
//
// Functions for diagnostics.
//
///////////////////////////////////////////////////////////////////////////////

DWORD
WINAPI
FwpmNetEventCreateEnumHandle0(
   IN HANDLE engineHandle,
   IN OPTIONAL const FWPM_NET_EVENT_ENUM_TEMPLATE0* enumTemplate,
   OUT HANDLE* enumHandle
   );

DWORD
WINAPI
FwpmNetEventEnum0(
   IN HANDLE engineHandle,
   IN HANDLE enumHandle,
   IN UINT32 numEntriesRequested,
   OUT FWPM_NET_EVENT0*** entries,
   OUT UINT32* numEntriesReturned
   );

DWORD
WINAPI
FwpmNetEventDestroyEnumHandle0(
   IN HANDLE engineHandle,
   IN HANDLE enumHandle
   );

DWORD
WINAPI
FwpmNetEventsGetSecurityInfo0(
   IN HANDLE engineHandle,
   IN SECURITY_INFORMATION securityInfo,
   OUT OPTIONAL PSID* sidOwner,
   OUT OPTIONAL PSID* sidGroup,
   OUT OPTIONAL PACL* dacl,
   OUT OPTIONAL PACL* sacl,
   OUT PSECURITY_DESCRIPTOR* securityDescriptor
   );

DWORD
WINAPI
FwpmNetEventsSetSecurityInfo0(
   IN HANDLE engineHandle,
   IN SECURITY_INFORMATION securityInfo,
   IN OPTIONAL const SID* sidOwner,
   IN OPTIONAL const SID* sidGroup,
   IN OPTIONAL const ACL* dacl,
   IN OPTIONAL const ACL* sacl
   );

#ifdef UNDER_CE
//New function added to support MIW/Ipsec for CE 7.0
DWORD
WINAPI
BfeDisableWFPIPSec(
   IN HANDLE engineHandle
   );
#endif

#ifdef __cplusplus
}
#endif
#endif // FWPMX_H
#endif // GUID_DEFS_ONLY
#endif // (NTDDI_VERSION >= NTDDI_WIN6)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\fwpmtypes.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0543 */
/* Compiler settings for fwpmtypes.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __fwpmtypes_h__
#define __fwpmtypes_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

/* header files for imported files */
#include "fwptypes.h"
#include "iketypes.h"
#include "ipsectypes.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_fwpmtypes_0000_0000 */
/* [local] */ 

#if _MSC_VER >=  800
#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4201)
#endif
typedef struct FWPM_DISPLAY_DATA0_
    {
    wchar_t *name;
    wchar_t *description;
    } 	FWPM_DISPLAY_DATA0;

typedef /* [v1_enum] */ 
enum FWPM_CHANGE_TYPE_
    {	FWPM_CHANGE_ADD	= 1,
	FWPM_CHANGE_DELETE	= ( FWPM_CHANGE_ADD + 1 ) ,
	FWPM_CHANGE_TYPE_MAX	= ( FWPM_CHANGE_DELETE + 1 ) 
    } 	FWPM_CHANGE_TYPE;

#define FWPM_SUBSCRIPTION_FLAG_NOTIFY_ON_ADD    (0x00000001)
#define FWPM_SUBSCRIPTION_FLAG_NOTIFY_ON_DELETE (0x00000002)
typedef 
enum FWPM_SERVICE_STATE_
    {	FWPM_SERVICE_STOPPED	= 0,
	FWPM_SERVICE_START_PENDING	= ( FWPM_SERVICE_STOPPED + 1 ) ,
	FWPM_SERVICE_STOP_PENDING	= ( FWPM_SERVICE_START_PENDING + 1 ) ,
	FWPM_SERVICE_RUNNING	= ( FWPM_SERVICE_STOP_PENDING + 1 ) ,
	FWPM_SERVICE_STATE_MAX	= ( FWPM_SERVICE_RUNNING + 1 ) 
    } 	FWPM_SERVICE_STATE;

#define FWPM_NET_EVENT_KEYWORD_INBOUND_MCAST (0x00000001)
#define FWPM_NET_EVENT_KEYWORD_INBOUND_BCAST (0x00000002)
typedef 
enum FWPM_ENGINE_OPTION_
    {	FWPM_ENGINE_COLLECT_NET_EVENTS	= 0,
	FWPM_ENGINE_NET_EVENT_MATCH_ANY_KEYWORDS	= ( FWPM_ENGINE_COLLECT_NET_EVENTS + 1 ) ,
	FWPM_ENGINE_OPTION_MAX	= ( FWPM_ENGINE_NET_EVENT_MATCH_ANY_KEYWORDS + 1 ) 
    } 	FWPM_ENGINE_OPTION;

#define FWPM_SESSION_FLAG_DYNAMIC (0x00000001)
typedef struct FWPM_SESSION0_
    {
    GUID sessionKey;
    FWPM_DISPLAY_DATA0 displayData;
    UINT32 flags;
    UINT32 txnWaitTimeoutInMSec;
    DWORD processId;
    SID *sid;
    wchar_t *username;
    BOOL kernelMode;
    } 	FWPM_SESSION0;

typedef struct FWPM_SESSION_ENUM_TEMPLATE0_
    {
    UNALIGNEDUINT64 reserved;
    } 	FWPM_SESSION_ENUM_TEMPLATE0;

#define FWPM_PROVIDER_FLAG_PERSISTENT  (0x00000001)
#define FWPM_PROVIDER_FLAG_DISABLED    (0x00000010)
typedef struct FWPM_PROVIDER0_
    {
    GUID providerKey;
    FWPM_DISPLAY_DATA0 displayData;
    UINT32 flags;
    FWP_BYTE_BLOB providerData;
    wchar_t *serviceName;
    } 	FWPM_PROVIDER0;

typedef struct FWPM_PROVIDER_ENUM_TEMPLATE0_
    {
    UNALIGNEDUINT64 reserved;
    } 	FWPM_PROVIDER_ENUM_TEMPLATE0;

typedef struct FWPM_PROVIDER_CHANGE0_
    {
    FWPM_CHANGE_TYPE changeType;
    GUID providerKey;
    } 	FWPM_PROVIDER_CHANGE0;

typedef struct FWPM_PROVIDER_SUBSCRIPTION0_
    {
    FWPM_PROVIDER_ENUM_TEMPLATE0 *enumTemplate;
    UINT32 flags;
    GUID sessionKey;
    } 	FWPM_PROVIDER_SUBSCRIPTION0;

#define FWPM_PROVIDER_CONTEXT_FLAG_PERSISTENT  (0x00000001)
typedef struct FWPM_CLASSIFY_OPTION0_
    {
    FWP_CLASSIFY_OPTION_TYPE type;
    FWP_VALUE0 value;
    } 	FWPM_CLASSIFY_OPTION0;

typedef struct FWPM_CLASSIFY_OPTIONS0_
    {
    UINT32 numOptions;
    FWPM_CLASSIFY_OPTION0 *options;
    } 	FWPM_CLASSIFY_OPTIONS0;

typedef /* [v1_enum] */ 
enum FWPM_PROVIDER_CONTEXT_TYPE_
    {	FWPM_IPSEC_KEYING_CONTEXT	= 0,
	FWPM_IPSEC_IKE_QM_TRANSPORT_CONTEXT	= ( FWPM_IPSEC_KEYING_CONTEXT + 1 ) ,
	FWPM_IPSEC_IKE_QM_TUNNEL_CONTEXT	= ( FWPM_IPSEC_IKE_QM_TRANSPORT_CONTEXT + 1 ) ,
	FWPM_IPSEC_AUTHIP_QM_TRANSPORT_CONTEXT	= ( FWPM_IPSEC_IKE_QM_TUNNEL_CONTEXT + 1 ) ,
	FWPM_IPSEC_AUTHIP_QM_TUNNEL_CONTEXT	= ( FWPM_IPSEC_AUTHIP_QM_TRANSPORT_CONTEXT + 1 ) ,
	FWPM_IPSEC_IKE_MM_CONTEXT	= ( FWPM_IPSEC_AUTHIP_QM_TUNNEL_CONTEXT + 1 ) ,
	FWPM_IPSEC_AUTHIP_MM_CONTEXT	= ( FWPM_IPSEC_IKE_MM_CONTEXT + 1 ) ,
	FWPM_CLASSIFY_OPTIONS_CONTEXT	= ( FWPM_IPSEC_AUTHIP_MM_CONTEXT + 1 ) ,
	FWPM_GENERAL_CONTEXT	= ( FWPM_CLASSIFY_OPTIONS_CONTEXT + 1 ) ,
	FWPM_PROVIDER_CONTEXT_TYPE_MAX	= ( FWPM_GENERAL_CONTEXT + 1 ) 
    } 	FWPM_PROVIDER_CONTEXT_TYPE;

typedef struct FWPM_PROVIDER_CONTEXT0_
    {
    GUID providerContextKey;
    FWPM_DISPLAY_DATA0 displayData;
    UINT32 flags;
    GUID *providerKey;
    FWP_BYTE_BLOB providerData;
    FWPM_PROVIDER_CONTEXT_TYPE type;
    union 
        {
        IPSEC_KEYING_POLICY0 *keyingPolicy;
        IPSEC_TRANSPORT_POLICY0 *ikeQmTransportPolicy;
        IPSEC_TUNNEL_POLICY0 *ikeQmTunnelPolicy;
        IPSEC_TRANSPORT_POLICY0 *authipQmTransportPolicy;
        IPSEC_TUNNEL_POLICY0 *authipQmTunnelPolicy;
        IKEEXT_POLICY0 *ikeMmPolicy;
        IKEEXT_POLICY0 *authIpMmPolicy;
        FWP_BYTE_BLOB *dataBuffer;
        FWPM_CLASSIFY_OPTIONS0 *classifyOptions;
        } 	;
    UNALIGNEDUINT64 providerContextId;
    } 	FWPM_PROVIDER_CONTEXT0;

typedef struct FWPM_PROVIDER_CONTEXT_ENUM_TEMPLATE0_
    {
    GUID *providerKey;
    FWPM_PROVIDER_CONTEXT_TYPE providerContextType;
    } 	FWPM_PROVIDER_CONTEXT_ENUM_TEMPLATE0;

typedef struct FWPM_PROVIDER_CONTEXT_CHANGE0_
    {
    FWPM_CHANGE_TYPE changeType;
    GUID providerContextKey;
    UNALIGNEDUINT64 providerContextId;
    } 	FWPM_PROVIDER_CONTEXT_CHANGE0;

typedef struct FWPM_PROVIDER_CONTEXT_SUBSCRIPTION0_
    {
    FWPM_PROVIDER_CONTEXT_ENUM_TEMPLATE0 *enumTemplate;
    UINT32 flags;
    GUID sessionKey;
    } 	FWPM_PROVIDER_CONTEXT_SUBSCRIPTION0;

#define FWPM_SUBLAYER_FLAG_PERSISTENT       (0x00000001)
typedef struct FWPM_SUBLAYER0_
    {
    GUID subLayerKey;
    FWPM_DISPLAY_DATA0 displayData;
    UINT32 flags;
    GUID *providerKey;
    FWP_BYTE_BLOB providerData;
    UINT16 weight;
    } 	FWPM_SUBLAYER0;

typedef struct FWPM_SUBLAYER_ENUM_TEMPLATE0_
    {
    GUID *providerKey;
    } 	FWPM_SUBLAYER_ENUM_TEMPLATE0;

typedef struct FWPM_SUBLAYER_CHANGE0_
    {
    FWPM_CHANGE_TYPE changeType;
    GUID subLayerKey;
    } 	FWPM_SUBLAYER_CHANGE0;

typedef struct FWPM_SUBLAYER_SUBSCRIPTION0_
    {
    FWPM_SUBLAYER_ENUM_TEMPLATE0 *enumTemplate;
    UINT32 flags;
    GUID sessionKey;
    } 	FWPM_SUBLAYER_SUBSCRIPTION0;

#define FWPM_LAYER_FLAG_KERNEL           (0x00000001)
#define FWPM_LAYER_FLAG_BUILTIN          (0x00000002)
#define FWPM_LAYER_FLAG_CLASSIFY_MOSTLY  (0x00000004)
#define FWPM_LAYER_FLAG_BUFFERED         (0x00000008)
typedef /* [v1_enum] */ 
enum FWPM_FIELD_TYPE_
    {	FWPM_FIELD_RAW_DATA	= 0,
	FWPM_FIELD_IP_ADDRESS	= ( FWPM_FIELD_RAW_DATA + 1 ) ,
	FWPM_FIELD_FLAGS	= ( FWPM_FIELD_IP_ADDRESS + 1 ) ,
	FWPM_FIELD_TYPE_MAX	= ( FWPM_FIELD_FLAGS + 1 ) 
    } 	FWPM_FIELD_TYPE;

typedef struct FWPM_FIELD0_
    {
    GUID *fieldKey;
    FWPM_FIELD_TYPE type;
    FWP_DATA_TYPE dataType;
    } 	FWPM_FIELD0;

typedef struct FWPM_LAYER0_
    {
    GUID layerKey;
    FWPM_DISPLAY_DATA0 displayData;
    UINT32 flags;
    UINT32 numFields;
    FWPM_FIELD0 *field;
    GUID defaultSubLayerKey;
    UINT16 layerId;
    } 	FWPM_LAYER0;

typedef struct FWPM_LAYER_ENUM_TEMPLATE0_
    {
    UNALIGNEDUINT64 reserved;
    } 	FWPM_LAYER_ENUM_TEMPLATE0;

#define FWPM_CALLOUT_FLAG_PERSISTENT             (0x00010000)
#define FWPM_CALLOUT_FLAG_USES_PROVIDER_CONTEXT  (0x00020000)
#define FWPM_CALLOUT_FLAG_REGISTERED             (0x00040000)
typedef struct FWPM_CALLOUT0_
    {
    GUID calloutKey;
    FWPM_DISPLAY_DATA0 displayData;
    UINT32 flags;
    GUID *providerKey;
    FWP_BYTE_BLOB providerData;
    GUID applicableLayer;
    UINT32 calloutId;
    } 	FWPM_CALLOUT0;

typedef struct FWPM_CALLOUT_ENUM_TEMPLATE0_
    {
    GUID *providerKey;
    GUID layerKey;
    } 	FWPM_CALLOUT_ENUM_TEMPLATE0;

typedef struct FWPM_CALLOUT_CHANGE0_
    {
    FWPM_CHANGE_TYPE changeType;
    GUID calloutKey;
    UINT32 calloutId;
    } 	FWPM_CALLOUT_CHANGE0;

typedef struct FWPM_CALLOUT_SUBSCRIPTION0_
    {
    FWPM_CALLOUT_ENUM_TEMPLATE0 *enumTemplate;
    UINT32 flags;
    GUID sessionKey;
    } 	FWPM_CALLOUT_SUBSCRIPTION0;

typedef struct FWPM_ACTION0_
    {
    FWP_ACTION_TYPE type;
    /* [switch_type] */ union 
        {
        GUID filterType;
        GUID calloutKey;
        } 	;
    } 	FWPM_ACTION0;

typedef struct FWPM_FILTER_CONDITION0_
    {
    GUID fieldKey;
    FWP_MATCH_TYPE matchType;
    FWP_CONDITION_VALUE0 conditionValue;
    } 	FWPM_FILTER_CONDITION0;

#define FWPM_FILTER_FLAG_NONE (0x00000000)
#define FWPM_FILTER_FLAG_PERSISTENT (0x00000001)
#define FWPM_FILTER_FLAG_BOOTTIME (0x00000002)
#define FWPM_FILTER_FLAG_HAS_PROVIDER_CONTEXT  (0x00000004)
#define FWPM_FILTER_FLAG_CLEAR_ACTION_RIGHT (0x00000008)
#define FWPM_FILTER_FLAG_PERMIT_IF_CALLOUT_UNREGISTERED (0x00000010)
#define FWPM_FILTER_FLAG_DISABLED (0x00000020)
typedef struct FWPM_FILTER0_
    {
    GUID filterKey;
    FWPM_DISPLAY_DATA0 displayData;
    UINT32 flags;
    GUID *providerKey;
    FWP_BYTE_BLOB providerData;
    GUID layerKey;
    GUID subLayerKey;
    FWP_VALUE0 weight;
    UINT32 numFilterConditions;
    FWPM_FILTER_CONDITION0 *filterCondition;
    FWPM_ACTION0 action;
    /* [switch_type] */ union 
        {
        UNALIGNEDUINT64 rawContext;
        GUID providerContextKey;
        } 	;
    GUID *reserved;
    UNALIGNEDUINT64 filterId;
    FWP_VALUE0 effectiveWeight;
    } 	FWPM_FILTER0;

typedef struct FWPM_FILTER_ENUM_TEMPLATE0_
    {
    GUID *providerKey;
    GUID layerKey;
    FWP_FILTER_ENUM_TYPE enumType;
    UINT32 flags;
    FWPM_PROVIDER_CONTEXT_ENUM_TEMPLATE0 *providerContextTemplate;
    UINT32 numFilterConditions;
    FWPM_FILTER_CONDITION0 *filterCondition;
    UINT32 actionMask;
    GUID *calloutKey;
    } 	FWPM_FILTER_ENUM_TEMPLATE0;

typedef struct FWPM_FILTER_CHANGE0_
    {
    FWPM_CHANGE_TYPE changeType;
    GUID filterKey;
    UNALIGNEDUINT64 filterId;
    } 	FWPM_FILTER_CHANGE0;

typedef struct FWPM_FILTER_SUBSCRIPTION0_
    {
    FWPM_FILTER_ENUM_TEMPLATE0 *enumTemplate;
    UINT32 flags;
    GUID sessionKey;
    } 	FWPM_FILTER_SUBSCRIPTION0;

typedef struct FWPM_LAYER_STATISTICS0_
    {
    GUID layerId;
    UINT32 classifyPermitCount;
    UINT32 classifyBlockCount;
    UINT32 classifyVetoCount;
    UINT32 numCacheEntries;
    } 	FWPM_LAYER_STATISTICS0;

typedef struct FWPM_STATISTICS0_
    {
    UINT32 numLayerStatistics;
    FWPM_LAYER_STATISTICS0 *layerStatistics;
    UINT32 inboundAllowedConnectionsV4;
    UINT32 inboundBlockedConnectionsV4;
    UINT32 outboundAllowedConnectionsV4;
    UINT32 outboundBlockedConnectionsV4;
    UINT32 inboundAllowedConnectionsV6;
    UINT32 inboundBlockedConnectionsV6;
    UINT32 outboundAllowedConnectionsV6;
    UINT32 outboundBlockedConnectionsV6;
    UINT32 inboundActiveConnectionsV4;
    UINT32 outboundActiveConnectionsV4;
    UINT32 inboundActiveConnectionsV6;
    UINT32 outboundActiveConnectionsV6;
    } 	FWPM_STATISTICS0;

#define FWPM_NET_EVENT_FLAG_IP_PROTOCOL_SET (0x00000001)
#define FWPM_NET_EVENT_FLAG_LOCAL_ADDR_SET  (0x00000002)
#define FWPM_NET_EVENT_FLAG_REMOTE_ADDR_SET (0x00000004)
#define FWPM_NET_EVENT_FLAG_LOCAL_PORT_SET  (0x00000008)
#define FWPM_NET_EVENT_FLAG_REMOTE_PORT_SET (0x00000010)
#define FWPM_NET_EVENT_FLAG_APP_ID_SET      (0x00000020)
#define FWPM_NET_EVENT_FLAG_USER_ID_SET     (0x00000040)
#define FWPM_NET_EVENT_FLAG_SCOPE_ID_SET    (0x00000080)
#define FWPM_NET_EVENT_FLAG_IP_VERSION_SET  (0x00000100)
typedef struct FWPM_NET_EVENT_HEADER0_
    {
    FILETIME timeStamp;
    UINT32 flags;
    FWP_IP_VERSION ipVersion;
    UINT8 ipProtocol;
    union 
        {
        UINT32 localAddrV4;
        FWP_BYTE_ARRAY16 localAddrV6;
        } 	;
    union 
        {
        UINT32 remoteAddrV4;
        FWP_BYTE_ARRAY16 remoteAddrV6;
        } 	;
    UINT16 localPort;
    UINT16 remotePort;
    UINT32 scopeId;
    FWP_BYTE_BLOB appId;
    SID *userId;
    } 	FWPM_NET_EVENT_HEADER0;

typedef /* [v1_enum] */ 
enum FWPM_NET_EVENT_TYPE_
    {	FWPM_NET_EVENT_TYPE_IKEEXT_MM_FAILURE	= 0,
	FWPM_NET_EVENT_TYPE_IKEEXT_QM_FAILURE	= ( FWPM_NET_EVENT_TYPE_IKEEXT_MM_FAILURE + 1 ) ,
	FWPM_NET_EVENT_TYPE_IKEEXT_EM_FAILURE	= ( FWPM_NET_EVENT_TYPE_IKEEXT_QM_FAILURE + 1 ) ,
	FWPM_NET_EVENT_TYPE_CLASSIFY_DROP	= ( FWPM_NET_EVENT_TYPE_IKEEXT_EM_FAILURE + 1 ) ,
	FWPM_NET_EVENT_TYPE_IPSEC_KERNEL_DROP	= ( FWPM_NET_EVENT_TYPE_CLASSIFY_DROP + 1 ) ,
	FWPM_NET_EVENT_TYPE_MAX	= ( FWPM_NET_EVENT_TYPE_IPSEC_KERNEL_DROP + 1 ) 
    } 	FWPM_NET_EVENT_TYPE;

#define IKEEXT_CERT_HASH_LEN 20
#define FWPM_NET_EVENT_IKEEXT_MM_FAILURE_FLAG_BENIGN (0x00000001)
#define FWPM_NET_EVENT_IKEEXT_MM_FAILURE_FLAG_MULTIPLE (0x00000002)
typedef struct FWPM_NET_EVENT_IKEEXT_MM_FAILURE0_
    {
    UINT32 failureErrorCode;
    IPSEC_FAILURE_POINT failurePoint;
    UINT32 flags;
    IKEEXT_KEY_MODULE_TYPE keyingModuleType;
    IKEEXT_MM_SA_STATE mmState;
    IKEEXT_SA_ROLE saRole;
    IKEEXT_AUTHENTICATION_METHOD_TYPE mmAuthMethod;
    UINT8 endCertHash[ 20 ];
    UNALIGNEDUINT64 mmId;
    UNALIGNEDUINT64 mmFilterId;
    } 	FWPM_NET_EVENT_IKEEXT_MM_FAILURE0;

typedef struct FWPM_NET_EVENT_IKEEXT_QM_FAILURE0_
    {
    UINT32 failureErrorCode;
    IPSEC_FAILURE_POINT failurePoint;
    IKEEXT_KEY_MODULE_TYPE keyingModuleType;
    IKEEXT_QM_SA_STATE qmState;
    IKEEXT_SA_ROLE saRole;
    IPSEC_TRAFFIC_TYPE saTrafficType;
    union 
        {
         /* Empty union arm */ 
        FWP_CONDITION_VALUE0 localSubNet;
        } 	;
    union 
        {
         /* Empty union arm */ 
        FWP_CONDITION_VALUE0 remoteSubNet;
        } 	;
    UNALIGNEDUINT64 qmFilterId;
    } 	FWPM_NET_EVENT_IKEEXT_QM_FAILURE0;

#define FWPM_NET_EVENT_IKEEXT_EM_FAILURE_FLAG_MULTIPLE (0x00000001)
typedef struct FWPM_NET_EVENT_IKEEXT_EM_FAILURE0_
    {
    UINT32 failureErrorCode;
    IPSEC_FAILURE_POINT failurePoint;
    UINT32 flags;
    IKEEXT_EM_SA_STATE emState;
    IKEEXT_SA_ROLE saRole;
    IKEEXT_AUTHENTICATION_METHOD_TYPE emAuthMethod;
    UINT8 endCertHash[ 20 ];
    UNALIGNEDUINT64 mmId;
    UNALIGNEDUINT64 qmFilterId;
    } 	FWPM_NET_EVENT_IKEEXT_EM_FAILURE0;

typedef struct FWPM_NET_EVENT_CLASSIFY_DROP0_
    {
    UNALIGNEDUINT64 filterId;
    UINT16 layerId;
    } 	FWPM_NET_EVENT_CLASSIFY_DROP0;

typedef struct FWPM_NET_EVENT_IPSEC_KERNEL_DROP0_
    {
    INT32 failureStatus;
    FWP_DIRECTION direction;
    IPSEC_SA_SPI spi;
    UNALIGNEDUINT64 filterId;
    UINT16 layerId;
    } 	FWPM_NET_EVENT_IPSEC_KERNEL_DROP0;

typedef struct FWPM_NET_EVENT0_
    {
    FWPM_NET_EVENT_HEADER0 header;
    FWPM_NET_EVENT_TYPE type;
    union 
        {
        FWPM_NET_EVENT_IKEEXT_MM_FAILURE0 *ikeMmFailure;
        FWPM_NET_EVENT_IKEEXT_QM_FAILURE0 *ikeQmFailure;
        FWPM_NET_EVENT_IKEEXT_EM_FAILURE0 *ikeEmFailure;
        FWPM_NET_EVENT_CLASSIFY_DROP0 *classifyDrop;
        FWPM_NET_EVENT_IPSEC_KERNEL_DROP0 *ipsecDrop;
        } 	;
    } 	FWPM_NET_EVENT0;

typedef struct FWPM_NET_EVENT_ENUM_TEMPLATE0_
    {
    FILETIME startTime;
    FILETIME endTime;
    UINT32 numFilterConditions;
    FWPM_FILTER_CONDITION0 *filterCondition;
    } 	FWPM_NET_EVENT_ENUM_TEMPLATE0;

#if _MSC_VER >=  800
#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4201)
#endif
#endif


extern RPC_IF_HANDLE __MIDL_itf_fwpmtypes_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_fwpmtypes_0000_0000_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\fvec.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/**
*** Copyright (C) 1985-1999 Intel Corporation.  All rights reserved.
***
*** The information and source code contained herein is the exclusive
*** property of Intel Corporation and may not be disclosed, examined
*** or reproduced in whole or in part without explicit written authorization
*** from the company.
***
**/

/*
 *  Definition of a C++ class interface to Streaming SIMD Extension intrinsics.
 *
 *
 *	File name : fvec.h  Fvec class definitions
 *
 *	Concept: A C++ abstraction of Streaming SIMD Extensions designed to improve
 *
 *  programmer productivity.  Speed and accuracy are sacrificed for utility.
 *
 *	Facilitates an easy transition to compiler intrinsics
 *
 *	or assembly language.
 *
 *	F32vec4:	4 packed single precision
 *				32-bit floating point numbers
*/

#ifndef _FVEC_H_INCLUDED
#define _FVEC_H_INCLUDED
#ifndef RC_INVOKED

#if !defined __cplusplus
	#error ERROR: This file is only supported in C++ compilations!
#endif /* !__cplusplus */

#if defined(_M_CEE_PURE)
	#error ERROR: This file is not supported in the pure mode!
#else

#include <xmmintrin.h> /* Streaming SIMD Extensions Intrinsics include file */
#include <assert.h>
#include <ivec.h>
#include <crtdefs.h>

/* Define _ENABLE_VEC_DEBUG to enable std::ostream inserters for debug output */
#if defined(_ENABLE_VEC_DEBUG)
	#include <iostream>
#endif

#ifdef  _MSC_VER
#pragma pack(push,_CRT_PACKING)
#endif  /* _MSC_VER */

#pragma pack(push,16) /* Must ensure class & union 16-B aligned */

#define EXPLICIT explicit

class F32vec4
{
protected:
   	 __m128 vec;
public:

	/* Constructors: __m128, 4 floats, 1 float */
	F32vec4() {}

	/* initialize 4 SP FP with __m128 data type */
	F32vec4(__m128 m)					{ vec = m;}

	/* initialize 4 SP FPs with 4 floats */
	F32vec4(float f3, float f2, float f1, float f0)		{ vec= _mm_set_ps(f3,f2,f1,f0); }

	/* Explicitly initialize each of 4 SP FPs with same float */
	EXPLICIT F32vec4(float f)	{ vec = _mm_set_ps1(f); }

	/* Explicitly initialize each of 4 SP FPs with same double */
	EXPLICIT F32vec4(double d)	{ vec = _mm_set_ps1((float) d); }

	/* Assignment operations */

	F32vec4& operator =(float f) { vec = _mm_set_ps1(f); return *this; }

	F32vec4& operator =(double d) { vec = _mm_set_ps1((float) d); return *this; }

	/* Conversion functions */
	operator  __m128() const	{ return vec; }		/* Convert to __m128 */

 	/* Logical Operators */
	friend F32vec4 operator &(const F32vec4 &a, const F32vec4 &b) { return _mm_and_ps(a,b); }
	friend F32vec4 operator |(const F32vec4 &a, const F32vec4 &b) { return _mm_or_ps(a,b); }
	friend F32vec4 operator ^(const F32vec4 &a, const F32vec4 &b) { return _mm_xor_ps(a,b); }

	/* Arithmetic Operators */
	friend F32vec4 operator +(const F32vec4 &a, const F32vec4 &b) { return _mm_add_ps(a,b); }
	friend F32vec4 operator -(const F32vec4 &a, const F32vec4 &b) { return _mm_sub_ps(a,b); }
	friend F32vec4 operator *(const F32vec4 &a, const F32vec4 &b) { return _mm_mul_ps(a,b); }
	friend F32vec4 operator /(const F32vec4 &a, const F32vec4 &b) { return _mm_div_ps(a,b); }

	F32vec4& operator =(const F32vec4 &a) { vec = a.vec; return *this; }
	F32vec4& operator =(const __m128 &avec) { vec = avec; return *this; }
	F32vec4& operator +=(F32vec4 &a) { return *this = _mm_add_ps(vec,a); }
	F32vec4& operator -=(F32vec4 &a) { return *this = _mm_sub_ps(vec,a); }
	F32vec4& operator *=(F32vec4 &a) { return *this = _mm_mul_ps(vec,a); }
	F32vec4& operator /=(F32vec4 &a) { return *this = _mm_div_ps(vec,a); }
	F32vec4& operator &=(F32vec4 &a) { return *this = _mm_and_ps(vec,a); }
	F32vec4& operator |=(F32vec4 &a) { return *this = _mm_or_ps(vec,a); }
	F32vec4& operator ^=(F32vec4 &a) { return *this = _mm_xor_ps(vec,a); }

	/* Horizontal Add */
	friend float add_horizontal(F32vec4 &a)
	{
		F32vec4 ftemp = _mm_add_ss(a,_mm_add_ss(_mm_shuffle_ps(a, a, 1),_mm_add_ss(_mm_shuffle_ps(a, a, 2),_mm_shuffle_ps(a, a, 3))));
		return ftemp[0];
	}

	/* Square Root */
	friend F32vec4 sqrt(const F32vec4 &a)		{ return _mm_sqrt_ps(a); }
	/* Reciprocal */
	friend F32vec4 rcp(const F32vec4 &a)		{ return _mm_rcp_ps(a); }
	/* Reciprocal Square Root */
	friend F32vec4 rsqrt(const F32vec4 &a)		{ return _mm_rsqrt_ps(a); }

	/* NewtonRaphson Reciprocal
	   [2 * rcpps(x) - (x * rcpps(x) * rcpps(x))] */
	friend F32vec4 rcp_nr(const F32vec4 &a)
	{
		F32vec4 Ra0 = _mm_rcp_ps(a);
		return _mm_sub_ps(_mm_add_ps(Ra0, Ra0), _mm_mul_ps(_mm_mul_ps(Ra0, a), Ra0));
	}

	/*	NewtonRaphson Reciprocal Square Root
	  	0.5 * rsqrtps * (3 - x * rsqrtps(x) * rsqrtps(x)) */
#pragma warning(push)
#pragma warning(disable : 4640)
	friend F32vec4 rsqrt_nr(const F32vec4 &a)
	{
		static const F32vec4 fvecf0pt5(0.5f);
		static const F32vec4 fvecf3pt0(3.0f);
		F32vec4 Ra0 = _mm_rsqrt_ps(a);
		return (fvecf0pt5 * Ra0) * (fvecf3pt0 - (a * Ra0) * Ra0);
	}
#pragma warning(pop)

	/* Compares: Mask is returned  */
	/* Macros expand to all compare intrinsics.  Example:
	friend F32vec4 cmpeq(const F32vec4 &a, const F32vec4 &b)
	{ return _mm_cmpeq_ps(a,b);} */
	#define Fvec32s4_COMP(op) \
	friend F32vec4 cmp##op (const F32vec4 &a, const F32vec4 &b) { return _mm_cmp##op##_ps(a,b); }
		Fvec32s4_COMP(eq)					/* expanded to cmpeq(a,b) */
		Fvec32s4_COMP(lt)					/* expanded to cmplt(a,b) */
		Fvec32s4_COMP(le)					/* expanded to cmple(a,b) */
		Fvec32s4_COMP(gt)					/* expanded to cmpgt(a,b) */
		Fvec32s4_COMP(ge)					/* expanded to cmpge(a,b) */
		Fvec32s4_COMP(neq)					/* expanded to cmpneq(a,b) */
		Fvec32s4_COMP(nlt)					/* expanded to cmpnlt(a,b) */
		Fvec32s4_COMP(nle)					/* expanded to cmpnle(a,b) */
		Fvec32s4_COMP(ngt)					/* expanded to cmpngt(a,b) */
		Fvec32s4_COMP(nge)					/* expanded to cmpnge(a,b) */
	#undef Fvec32s4_COMP

	/* Min and Max */
	friend F32vec4 simd_min(const F32vec4 &a, const F32vec4 &b) { return _mm_min_ps(a,b); }
	friend F32vec4 simd_max(const F32vec4 &a, const F32vec4 &b) { return _mm_max_ps(a,b); }

	/* Debug Features */
#if defined(_ENABLE_VEC_DEBUG)
	/* Output */
	friend std::ostream & operator<<(std::ostream & os, const F32vec4 &a)
	{
	/* To use: cout << "Elements of F32vec4 fvec are: " << fvec; */
	  float *fp = (float*)&a;
	  	os << "[3]:" << *(fp+3)
			<< " [2]:" << *(fp+2)
			<< " [1]:" << *(fp+1)
			<< " [0]:" << *fp;
		return os;
	}
#endif
	/* Element Access Only, no modifications to elements*/
	const float& operator[](int i) const
	{
		/* Assert enabled only during debug /DDEBUG */
		assert((0 <= i) && (i <= 3));			/* User should only access elements 0-3 */
		float *fp = (float*)&vec;
		return *(fp+i);
	}
	/* Element Access and Modification*/
	float& operator[](int i)
	{
		/* Assert enabled only during debug /DDEBUG */
		assert((0 <= i) && (i <= 3));			/* User should only access elements 0-3 */
		float *fp = (float*)&vec;
		return *(fp+i);
	}
};

						/* Miscellaneous */

/* Interleave low order data elements of a and b into destination */
inline F32vec4 unpack_low(const F32vec4 &a, const F32vec4 &b)
{ return _mm_unpacklo_ps(a, b); }

/* Interleave high order data elements of a and b into target */
inline F32vec4 unpack_high(const F32vec4 &a, const F32vec4 &b)
{ return _mm_unpackhi_ps(a, b); }

/* Move Mask to Integer returns 4 bit mask formed of most significant bits of a */
inline int move_mask(const F32vec4 &a)
{ return _mm_movemask_ps(a);}

						/* Data Motion Functions */

/* Load Unaligned loadu_ps: Unaligned */
inline void loadu(F32vec4 &a, float *p)
{ a = _mm_loadu_ps(p); }

/* Store Temporal storeu_ps: Unaligned */
inline void storeu(float *p, const F32vec4 &a)
{ _mm_storeu_ps(p, a); }

						/* Cacheability Support */

/* Non-Temporal Store */
inline void store_nta(float *p, F32vec4 &a)
{ _mm_stream_ps(p,a);}

						/* Conditional Selects:*/
/*(a OP b)? c : d; where OP is any compare operator
Macros expand to conditional selects which use all compare intrinsics.
Example:
friend F32vec4 select_eq(const F32vec4 &a, const F32vec4 &b, const F32vec4 &c, const F32vec4 &d)
{
	F32vec4 mask = _mm_cmpeq_ps(a,b);
	return( (mask & c) | F32vec4((_mm_andnot_ps(mask,d))));
}
*/

#define Fvec32s4_SELECT(op) \
inline F32vec4 select_##op (const F32vec4 &a, const F32vec4 &b, const F32vec4 &c, const F32vec4 &d) 	   \
{																\
	F32vec4 mask = _mm_cmp##op##_ps(a,b);						\
	return( (mask & c) | F32vec4((_mm_andnot_ps(mask,d))));	\
}
Fvec32s4_SELECT(eq)			/* generates select_eq(a,b) */
Fvec32s4_SELECT(lt)			/* generates select_lt(a,b) */
Fvec32s4_SELECT(le)			/* generates select_le(a,b) */
Fvec32s4_SELECT(gt)			/* generates select_gt(a,b) */
Fvec32s4_SELECT(ge)			/* generates select_ge(a,b) */
Fvec32s4_SELECT(neq)		/* generates select_neq(a,b) */
Fvec32s4_SELECT(nlt)		/* generates select_nlt(a,b) */
Fvec32s4_SELECT(nle)		/* generates select_nle(a,b) */
Fvec32s4_SELECT(ngt)		/* generates select_ngt(a,b) */
Fvec32s4_SELECT(nge)		/* generates select_nge(a,b) */
#undef Fvec32s4_SELECT


/* Streaming SIMD Extensions Integer Intrinsics */

/* Max and Min */
inline Is16vec4 simd_max(const Is16vec4 &a, const Is16vec4 &b)		{ return _m_pmaxsw(a,b);}
inline Is16vec4 simd_min(const Is16vec4 &a, const Is16vec4 &b)		{ return _m_pminsw(a,b);}
inline Iu8vec8 simd_max(const Iu8vec8 &a, const Iu8vec8 &b)			{ return _m_pmaxub(a,b);}
inline Iu8vec8 simd_min(const Iu8vec8 &a, const Iu8vec8 &b)			{ return _m_pminub(a,b);}

/* Average */
inline Iu16vec4 simd_avg(const Iu16vec4 &a, const Iu16vec4 &b)		{ return _m_pavgw(a,b); }
inline Iu8vec8 simd_avg(const Iu8vec8 &a, const Iu8vec8 &b)			{ return _m_pavgb(a,b); }

/* Move ByteMask To Int: returns mask formed from most sig bits	of each vec of a */
inline int move_mask(const I8vec8 &a)								{ return _m_pmovmskb(a);}

/* Packed Multiply High Unsigned */
inline Iu16vec4 mul_high(const Iu16vec4 &a, const Iu16vec4 &b)		{ return _m_pmulhuw(a,b); }

/* Byte Mask Write: Write bytes if most significant bit in each corresponding byte is set */
inline void mask_move(const I8vec8 &a, const I8vec8 &b, char *addr)	{ _m_maskmovq(a, b, addr); }

/* Data Motion: Store Non Temporal */
inline void store_nta(__m64 *p, M64 &a) { _mm_stream_pi(p,a); }

/* Conversions between ivec <-> fvec */

/* Convert first element of F32vec4 to int with truncation */
inline int F32vec4ToInt(const F32vec4 &a)
{

	return _mm_cvtt_ss2si(a);

}

/* Convert two lower SP FP values of a to Is32vec2 with truncation */
inline Is32vec2 F32vec4ToIs32vec2 (const F32vec4 &a)
{

	__m64 result;
	result = _mm_cvtt_ps2pi(a);
	return Is32vec2(result);

}

/* Convert the 32-bit int i to an SP FP value; the upper three SP FP values are passed through from a. */
inline F32vec4 IntToF32vec4(const F32vec4 &a, int i)
{

	__m128 result;
	result = _mm_cvt_si2ss(a,i);
	return F32vec4(result);

}

/* Convert the two 32-bit integer values in b to two SP FP values; the upper two SP FP values are passed from a. */
inline F32vec4 Is32vec2ToF32vec4(const F32vec4 &a, const Is32vec2 &b)
{

	__m128 result;
	result = _mm_cvt_pi2ps(a,b);
	return F32vec4(result);
}

class F32vec1
{
protected:
   	 __m128 vec;
public:

	/* Constructors: 1 float */
	F32vec1() {}

	F32vec1(int i)		{ vec = _mm_cvt_si2ss(vec,i);};

	/* Initialize each of 4 SP FPs with same float */
	EXPLICIT F32vec1(float f)	{ vec = _mm_set_ss(f); }

	/* Initialize each of 4 SP FPs with same float */
	EXPLICIT F32vec1(double d)	{ vec = _mm_set_ss((float) d); }

	/* initialize with __m128 data type */
	F32vec1(__m128 m)	{ vec = m; }

	/* Conversion functions */
	operator  __m128() const	{ return vec; }		/* Convert to float */

 	/* Logical Operators */
	friend F32vec1 operator &(const F32vec1 &a, const F32vec1 &b) { return _mm_and_ps(a,b); }
	friend F32vec1 operator |(const F32vec1 &a, const F32vec1 &b) { return _mm_or_ps(a,b); }
	friend F32vec1 operator ^(const F32vec1 &a, const F32vec1 &b) { return _mm_xor_ps(a,b); }

	/* Arithmetic Operators */
	friend F32vec1 operator +(const F32vec1 &a, const F32vec1 &b) { return _mm_add_ss(a,b); }
	friend F32vec1 operator -(const F32vec1 &a, const F32vec1 &b) { return _mm_sub_ss(a,b); }
	friend F32vec1 operator *(const F32vec1 &a, const F32vec1 &b) { return _mm_mul_ss(a,b); }
	friend F32vec1 operator /(const F32vec1 &a, const F32vec1 &b) { return _mm_div_ss(a,b); }

	F32vec1& operator +=(F32vec1 &a) { return *this = _mm_add_ss(vec,a); }
	F32vec1& operator -=(F32vec1 &a) { return *this = _mm_sub_ss(vec,a); }
	F32vec1& operator *=(F32vec1 &a) { return *this = _mm_mul_ss(vec,a); }
	F32vec1& operator /=(F32vec1 &a) { return *this = _mm_div_ss(vec,a); }
	F32vec1& operator &=(F32vec1 &a) { return *this = _mm_and_ps(vec,a); }
	F32vec1& operator |=(F32vec1 &a) { return *this = _mm_or_ps(vec,a); }
	F32vec1& operator ^=(F32vec1 &a) { return *this = _mm_xor_ps(vec,a); }


	/* Square Root */
	friend F32vec1 sqrt(const F32vec1 &a)		{ return _mm_sqrt_ss(a); }
	/* Reciprocal */
	friend F32vec1 rcp(const F32vec1 &a)		{ return _mm_rcp_ss(a); }
	/* Reciprocal Square Root */
	friend F32vec1 rsqrt(const F32vec1 &a)		{ return _mm_rsqrt_ss(a); }

	/* NewtonRaphson Reciprocal
	   [2 * rcpss(x) - (x * rcpss(x) * rcpss(x))] */
	friend F32vec1 rcp_nr(const F32vec1 &a)
	{
		F32vec1 Ra0 = _mm_rcp_ss(a);
		return _mm_sub_ss(_mm_add_ss(Ra0, Ra0), _mm_mul_ss(_mm_mul_ss(Ra0, a), Ra0));
	}

	/*	NewtonRaphson Reciprocal Square Root
	  	0.5 * rsqrtss * (3 - x * rsqrtss(x) * rsqrtss(x)) */
#pragma warning(push)
#pragma warning(disable : 4640)
	friend F32vec1 rsqrt_nr(const F32vec1 &a)
	{
		static const F32vec1 fvecf0pt5(0.5f);
		static const F32vec1 fvecf3pt0(3.0f);
		F32vec1 Ra0 = _mm_rsqrt_ss(a);
		return (fvecf0pt5 * Ra0) * (fvecf3pt0 - (a * Ra0) * Ra0);
	}
#pragma warning(pop)

	/* Compares: Mask is returned  */
	/* Macros expand to all compare intrinsics.  Example:
	friend F32vec1 cmpeq(const F32vec1 &a, const F32vec1 &b)
	{ return _mm_cmpeq_ss(a,b);} */
	#define Fvec32s1_COMP(op) \
	friend F32vec1 cmp##op (const F32vec1 &a, const F32vec1 &b) { return _mm_cmp##op##_ss(a,b); }
		Fvec32s1_COMP(eq)					/* expanded to cmpeq(a,b) */
		Fvec32s1_COMP(lt)					/* expanded to cmplt(a,b) */
		Fvec32s1_COMP(le)					/* expanded to cmple(a,b) */
		Fvec32s1_COMP(gt)					/* expanded to cmpgt(a,b) */
		Fvec32s1_COMP(ge)					/* expanded to cmpge(a,b) */
		Fvec32s1_COMP(neq)					/* expanded to cmpneq(a,b) */
		Fvec32s1_COMP(nlt)					/* expanded to cmpnlt(a,b) */
		Fvec32s1_COMP(nle)					/* expanded to cmpnle(a,b) */
		Fvec32s1_COMP(ngt)					/* expanded to cmpngt(a,b) */
		Fvec32s1_COMP(nge)					/* expanded to cmpnge(a,b) */
	#undef Fvec32s1_COMP

	/* Min and Max */
	friend F32vec1 simd_min(const F32vec1 &a, const F32vec1 &b) { return _mm_min_ss(a,b); }
	friend F32vec1 simd_max(const F32vec1 &a, const F32vec1 &b) { return _mm_max_ss(a,b); }

	/* Debug Features */
#if defined(_ENABLE_VEC_DEBUG)
	/* Output */
	friend std::ostream & operator<<(std::ostream & os, const F32vec1 &a)
	{
	/* To use: cout << "Elements of F32vec1 fvec are: " << fvec; */
	  float *fp = (float*)&a;
	  	os << "float:" << *fp;
		return os;
	}
#endif

};

						/* Conditional Selects:*/
/*(a OP b)? c : d; where OP is any compare operator
Macros expand to conditional selects which use all compare intrinsics.
Example:
friend F32vec1 select_eq(const F32vec1 &a, const F32vec1 &b, const F32vec1 &c, const F32vec1 &d)
{
	F32vec1 mask = _mm_cmpeq_ss(a,b);
	return( (mask & c) | F32vec1((_mm_andnot_ps(mask,d))));
}
*/

#define Fvec32s1_SELECT(op) \
inline F32vec1 select_##op (const F32vec1 &a, const F32vec1 &b, const F32vec1 &c, const F32vec1 &d) 	   \
{													   \
	F32vec1 mask = _mm_cmp##op##_ss(a,b);						                   \
	return( (mask & c) | F32vec1((_mm_andnot_ps(mask,d))));	                                           \
}
Fvec32s1_SELECT(eq)			/* generates select_eq(a,b) */
Fvec32s1_SELECT(lt)			/* generates select_lt(a,b) */
Fvec32s1_SELECT(le)			/* generates select_le(a,b) */
Fvec32s1_SELECT(gt)			/* generates select_gt(a,b) */
Fvec32s1_SELECT(ge)			/* generates select_ge(a,b) */
Fvec32s1_SELECT(neq)		/* generates select_neq(a,b) */
Fvec32s1_SELECT(nlt)		/* generates select_nlt(a,b) */
Fvec32s1_SELECT(nle)		/* generates select_nle(a,b) */
Fvec32s1_SELECT(ngt)		/* generates select_ngt(a,b) */
Fvec32s1_SELECT(nge)		/* generates select_nge(a,b) */
#undef Fvec32s1_SELECT

/* Conversions between ivec <-> fvec */

/* Convert F32vec1 to int */
inline int F32vec1ToInt(const F32vec1 &a)
{
	return _mm_cvtt_ss2si(a);
}



#pragma pack(pop) /* 16-B aligned */

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif /* defined(_M_CEE_PURE) */

#endif /* RC_INVOKED */
#endif /* _FVEC_H_INCLUDED */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\fwpmk.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*
   Copyright (c) Microsoft Corporation

   SYNOPSIS

     Declares the management portion of the FWP API.
*/

#if (NTDDI_VERSION >= NTDDI_WIN6)

///////////////////////////////////////////////////////////////////////////////
//
// GUIDs for built-in layers.
//
///////////////////////////////////////////////////////////////////////////////
#pragma once

// c86fd1bf-21cd-497e-a0bb-17425c885c58
DEFINE_GUID(
   FWPM_LAYER_INBOUND_IPPACKET_V4,
   0xc86fd1bf,
   0x21cd,
   0x497e,
   0xa0, 0xbb, 0x17, 0x42, 0x5c, 0x88, 0x5c, 0x58
);

// b5a230d0-a8c0-44f2-916e-991b53ded1f7
DEFINE_GUID(
   FWPM_LAYER_INBOUND_IPPACKET_V4_DISCARD,
   0xb5a230d0,
   0xa8c0,
   0x44f2,
   0x91, 0x6e, 0x99, 0x1b, 0x53, 0xde, 0xd1, 0xf7
);

// f52032cb-991c-46e7-971d-2601459a91ca
DEFINE_GUID(
   FWPM_LAYER_INBOUND_IPPACKET_V6,
   0xf52032cb,
   0x991c,
   0x46e7,
   0x97, 0x1d, 0x26, 0x01, 0x45, 0x9a, 0x91, 0xca
);

// bb24c279-93b4-47a2-83ad-ae1698b50885
DEFINE_GUID(
   FWPM_LAYER_INBOUND_IPPACKET_V6_DISCARD,
   0xbb24c279,
   0x93b4,
   0x47a2,
   0x83, 0xad, 0xae, 0x16, 0x98, 0xb5, 0x08, 0x85
);

// 1e5c9fae-8a84-4135-a331-950b54229ecd
DEFINE_GUID(
   FWPM_LAYER_OUTBOUND_IPPACKET_V4,
   0x1e5c9fae,
   0x8a84,
   0x4135,
   0xa3, 0x31, 0x95, 0x0b, 0x54, 0x22, 0x9e, 0xcd
);

// 08e4bcb5-b647-48f3-953c-e5ddbd03937e
DEFINE_GUID(
   FWPM_LAYER_OUTBOUND_IPPACKET_V4_DISCARD,
   0x08e4bcb5,
   0xb647,
   0x48f3,
   0x95, 0x3c, 0xe5, 0xdd, 0xbd, 0x03, 0x93, 0x7e
);

// a3b3ab6b-3564-488c-9117-f34e82142763
DEFINE_GUID(
   FWPM_LAYER_OUTBOUND_IPPACKET_V6,
   0xa3b3ab6b,
   0x3564,
   0x488c,
   0x91, 0x17, 0xf3, 0x4e, 0x82, 0x14, 0x27, 0x63
);

// 9513d7c4-a934-49dc-91a7-6ccb80cc02e3
DEFINE_GUID(
   FWPM_LAYER_OUTBOUND_IPPACKET_V6_DISCARD,
   0x9513d7c4,
   0xa934,
   0x49dc,
   0x91, 0xa7, 0x6c, 0xcb, 0x80, 0xcc, 0x02, 0xe3
);

// a82acc24-4ee1-4ee1-b465-fd1d25cb10a4
DEFINE_GUID(
   FWPM_LAYER_IPFORWARD_V4,
   0xa82acc24,
   0x4ee1,
   0x4ee1,
   0xb4, 0x65, 0xfd, 0x1d, 0x25, 0xcb, 0x10, 0xa4
);

// 9e9ea773-2fae-4210-8f17-34129ef369eb
DEFINE_GUID(
   FWPM_LAYER_IPFORWARD_V4_DISCARD,
   0x9e9ea773,
   0x2fae,
   0x4210,
   0x8f, 0x17, 0x34, 0x12, 0x9e, 0xf3, 0x69, 0xeb
);

// 7b964818-19c7-493a-b71f-832c3684d28c
DEFINE_GUID(
   FWPM_LAYER_IPFORWARD_V6,
   0x7b964818,
   0x19c7,
   0x493a,
   0xb7, 0x1f, 0x83, 0x2c, 0x36, 0x84, 0xd2, 0x8c
);

// 31524a5d-1dfe-472f-bb93-518ee945d8a2
DEFINE_GUID(
   FWPM_LAYER_IPFORWARD_V6_DISCARD,
   0x31524a5d,
   0x1dfe,
   0x472f,
   0xbb, 0x93, 0x51, 0x8e, 0xe9, 0x45, 0xd8, 0xa2
);

// 5926dfc8-e3cf-4426-a283-dc393f5d0f9d
DEFINE_GUID(
   FWPM_LAYER_INBOUND_TRANSPORT_V4,
   0x5926dfc8,
   0xe3cf,
   0x4426,
   0xa2, 0x83, 0xdc, 0x39, 0x3f, 0x5d, 0x0f, 0x9d
);

// ac4a9833-f69d-4648-b261-6dc84835ef39
DEFINE_GUID(
   FWPM_LAYER_INBOUND_TRANSPORT_V4_DISCARD,
   0xac4a9833,
   0xf69d,
   0x4648,
   0xb2, 0x61, 0x6d, 0xc8, 0x48, 0x35, 0xef, 0x39
);

// 634a869f-fc23-4b90-b0c1-bf620a36ae6f
DEFINE_GUID(
   FWPM_LAYER_INBOUND_TRANSPORT_V6,
   0x634a869f,
   0xfc23,
   0x4b90,
   0xb0, 0xc1, 0xbf, 0x62, 0x0a, 0x36, 0xae, 0x6f
);

// 2a6ff955-3b2b-49d2-9848-ad9d72dcaab7
DEFINE_GUID(
   FWPM_LAYER_INBOUND_TRANSPORT_V6_DISCARD,
   0x2a6ff955,
   0x3b2b,
   0x49d2,
   0x98, 0x48, 0xad, 0x9d, 0x72, 0xdc, 0xaa, 0xb7
);

// 09e61aea-d214-46e2-9b21-b26b0b2f28c8
DEFINE_GUID(
   FWPM_LAYER_OUTBOUND_TRANSPORT_V4,
   0x09e61aea,
   0xd214,
   0x46e2,
   0x9b, 0x21, 0xb2, 0x6b, 0x0b, 0x2f, 0x28, 0xc8
);

// c5f10551-bdb0-43d7-a313-50e211f4d68a
DEFINE_GUID(
   FWPM_LAYER_OUTBOUND_TRANSPORT_V4_DISCARD,
   0xc5f10551,
   0xbdb0,
   0x43d7,
   0xa3, 0x13, 0x50, 0xe2, 0x11, 0xf4, 0xd6, 0x8a
);

// e1735bde-013f-4655-b351-a49e15762df0
DEFINE_GUID(
   FWPM_LAYER_OUTBOUND_TRANSPORT_V6,
   0xe1735bde,
   0x013f,
   0x4655,
   0xb3, 0x51, 0xa4, 0x9e, 0x15, 0x76, 0x2d, 0xf0
);

// f433df69-ccbd-482e-b9b2-57165658c3b3
DEFINE_GUID(
   FWPM_LAYER_OUTBOUND_TRANSPORT_V6_DISCARD,
   0xf433df69,
   0xccbd,
   0x482e,
   0xb9, 0xb2, 0x57, 0x16, 0x56, 0x58, 0xc3, 0xb3
);

// 3b89653c-c170-49e4-b1cd-e0eeeee19a3e
DEFINE_GUID(
   FWPM_LAYER_STREAM_V4,
   0x3b89653c,
   0xc170,
   0x49e4,
   0xb1, 0xcd, 0xe0, 0xee, 0xee, 0xe1, 0x9a, 0x3e
);

// 25c4c2c2-25ff-4352-82f9-c54a4a4726dc
DEFINE_GUID(
   FWPM_LAYER_STREAM_V4_DISCARD,
   0x25c4c2c2,
   0x25ff,
   0x4352,
   0x82, 0xf9, 0xc5, 0x4a, 0x4a, 0x47, 0x26, 0xdc
);

// 47c9137a-7ec4-46b3-b6e4-48e926b1eda4
DEFINE_GUID(
   FWPM_LAYER_STREAM_V6,
   0x47c9137a,
   0x7ec4,
   0x46b3,
   0xb6, 0xe4, 0x48, 0xe9, 0x26, 0xb1, 0xed, 0xa4
);

// 10a59fc7-b628-4c41-9eb8-cf37d55103cf
DEFINE_GUID(
   FWPM_LAYER_STREAM_V6_DISCARD,
   0x10a59fc7,
   0xb628,
   0x4c41,
   0x9e, 0xb8, 0xcf, 0x37, 0xd5, 0x51, 0x03, 0xcf
);

// 3d08bf4e-45f6-4930-a922-417098e20027
DEFINE_GUID(
   FWPM_LAYER_DATAGRAM_DATA_V4,
   0x3d08bf4e,
   0x45f6,
   0x4930,
   0xa9, 0x22, 0x41, 0x70, 0x98, 0xe2, 0x00, 0x27
);

// 18e330c6-7248-4e52-aaab-472ed67704fd
DEFINE_GUID(
   FWPM_LAYER_DATAGRAM_DATA_V4_DISCARD,
   0x18e330c6,
   0x7248,
   0x4e52,
   0xaa, 0xab, 0x47, 0x2e, 0xd6, 0x77, 0x04, 0xfd
);

// fa45fe2f-3cba-4427-87fc-57b9a4b10d00
DEFINE_GUID(
   FWPM_LAYER_DATAGRAM_DATA_V6,
   0xfa45fe2f,
   0x3cba,
   0x4427,
   0x87, 0xfc, 0x57, 0xb9, 0xa4, 0xb1, 0x0d, 0x00
);

// 09d1dfe1-9b86-4a42-be9d-8c315b92a5d0
DEFINE_GUID(
   FWPM_LAYER_DATAGRAM_DATA_V6_DISCARD,
   0x09d1dfe1,
   0x9b86,
   0x4a42,
   0xbe, 0x9d, 0x8c, 0x31, 0x5b, 0x92, 0xa5, 0xd0
);

// 61499990-3cb6-4e84-b950-53b94b6964f3
DEFINE_GUID(
   FWPM_LAYER_INBOUND_ICMP_ERROR_V4,
   0x61499990,
   0x3cb6,
   0x4e84,
   0xb9, 0x50, 0x53, 0xb9, 0x4b, 0x69, 0x64, 0xf3
);

// a6b17075-ebaf-4053-a4e7-213c8121ede5
DEFINE_GUID(
   FWPM_LAYER_INBOUND_ICMP_ERROR_V4_DISCARD,
   0xa6b17075,
   0xebaf,
   0x4053,
   0xa4, 0xe7, 0x21, 0x3c, 0x81, 0x21, 0xed, 0xe5
);

// 65f9bdff-3b2d-4e5d-b8c6-c720651fe898
DEFINE_GUID(
   FWPM_LAYER_INBOUND_ICMP_ERROR_V6,
   0x65f9bdff,
   0x3b2d,
   0x4e5d,
   0xb8, 0xc6, 0xc7, 0x20, 0x65, 0x1f, 0xe8, 0x98
);

// a6e7ccc0-08fb-468d-a472-9771d5595e09
DEFINE_GUID(
   FWPM_LAYER_INBOUND_ICMP_ERROR_V6_DISCARD,
   0xa6e7ccc0,
   0x08fb,
   0x468d,
   0xa4, 0x72, 0x97, 0x71, 0xd5, 0x59, 0x5e, 0x09
);

// 41390100-564c-4b32-bc1d-718048354d7c
DEFINE_GUID(
   FWPM_LAYER_OUTBOUND_ICMP_ERROR_V4,
   0x41390100,
   0x564c,
   0x4b32,
   0xbc, 0x1d, 0x71, 0x80, 0x48, 0x35, 0x4d, 0x7c
);

// b3598d36-0561-4588-a6bf-e955e3f6264b
DEFINE_GUID(
   FWPM_LAYER_OUTBOUND_ICMP_ERROR_V4_DISCARD,
   0xb3598d36,
   0x0561,
   0x4588,
   0xa6, 0xbf, 0xe9, 0x55, 0xe3, 0xf6, 0x26, 0x4b
);

// 7fb03b60-7b8d-4dfa-badd-980176fc4e12
DEFINE_GUID(
   FWPM_LAYER_OUTBOUND_ICMP_ERROR_V6,
   0x7fb03b60,
   0x7b8d,
   0x4dfa,
   0xba, 0xdd, 0x98, 0x01, 0x76, 0xfc, 0x4e, 0x12
);

// 65f2e647-8d0c-4f47-b19b-33a4d3f1357c
DEFINE_GUID(
   FWPM_LAYER_OUTBOUND_ICMP_ERROR_V6_DISCARD,
   0x65f2e647,
   0x8d0c,
   0x4f47,
   0xb1, 0x9b, 0x33, 0xa4, 0xd3, 0xf1, 0x35, 0x7c
);

// 1247d66d-0b60-4a15-8d44-7155d0f53a0c
DEFINE_GUID(
   FWPM_LAYER_ALE_RESOURCE_ASSIGNMENT_V4,
   0x1247d66d,
   0x0b60,
   0x4a15,
   0x8d, 0x44, 0x71, 0x55, 0xd0, 0xf5, 0x3a, 0x0c
);

// 0b5812a2-c3ff-4eca-b88d-c79e20ac6322
DEFINE_GUID(
   FWPM_LAYER_ALE_RESOURCE_ASSIGNMENT_V4_DISCARD,
   0x0b5812a2,
   0xc3ff,
   0x4eca,
   0xb8, 0x8d, 0xc7, 0x9e, 0x20, 0xac, 0x63, 0x22
);

// 55a650e1-5f0a-4eca-a653-88f53b26aa8c
DEFINE_GUID(
   FWPM_LAYER_ALE_RESOURCE_ASSIGNMENT_V6,
   0x55a650e1,
   0x5f0a,
   0x4eca,
   0xa6, 0x53, 0x88, 0xf5, 0x3b, 0x26, 0xaa, 0x8c
);

// cbc998bb-c51f-4c1a-bb4f-9775fcacab2f
DEFINE_GUID(
   FWPM_LAYER_ALE_RESOURCE_ASSIGNMENT_V6_DISCARD,
   0xcbc998bb,
   0xc51f,
   0x4c1a,
   0xbb, 0x4f, 0x97, 0x75, 0xfc, 0xac, 0xab, 0x2f
);

// 88bb5dad-76d7-4227-9c71-df0a3ed7be7e
DEFINE_GUID(
   FWPM_LAYER_ALE_AUTH_LISTEN_V4,
   0x88bb5dad,
   0x76d7,
   0x4227,
   0x9c, 0x71, 0xdf, 0x0a, 0x3e, 0xd7, 0xbe, 0x7e
);

// 371dfada-9f26-45fd-b4eb-c29eb212893f
DEFINE_GUID(
   FWPM_LAYER_ALE_AUTH_LISTEN_V4_DISCARD,
   0x371dfada,
   0x9f26,
   0x45fd,
   0xb4, 0xeb, 0xc2, 0x9e, 0xb2, 0x12, 0x89, 0x3f
);

// 7ac9de24-17dd-4814-b4bd-a9fbc95a321b
DEFINE_GUID(
   FWPM_LAYER_ALE_AUTH_LISTEN_V6,
   0x7ac9de24,
   0x17dd,
   0x4814,
   0xb4, 0xbd, 0xa9, 0xfb, 0xc9, 0x5a, 0x32, 0x1b
);

// 60703b07-63c8-48e9-ada3-12b1af40a617
DEFINE_GUID(
   FWPM_LAYER_ALE_AUTH_LISTEN_V6_DISCARD,
   0x60703b07,
   0x63c8,
   0x48e9,
   0xad, 0xa3, 0x12, 0xb1, 0xaf, 0x40, 0xa6, 0x17
);

// e1cd9fe7-f4b5-4273-96c0-592e487b8650
DEFINE_GUID(
   FWPM_LAYER_ALE_AUTH_RECV_ACCEPT_V4,
   0xe1cd9fe7,
   0xf4b5,
   0x4273,
   0x96, 0xc0, 0x59, 0x2e, 0x48, 0x7b, 0x86, 0x50
);

// 9eeaa99b-bd22-4227-919f-0073c63357b1
DEFINE_GUID(
   FWPM_LAYER_ALE_AUTH_RECV_ACCEPT_V4_DISCARD,
   0x9eeaa99b,
   0xbd22,
   0x4227,
   0x91, 0x9f, 0x00, 0x73, 0xc6, 0x33, 0x57, 0xb1
);

// a3b42c97-9f04-4672-b87e-cee9c483257f
DEFINE_GUID(
   FWPM_LAYER_ALE_AUTH_RECV_ACCEPT_V6,
   0xa3b42c97,
   0x9f04,
   0x4672,
   0xb8, 0x7e, 0xce, 0xe9, 0xc4, 0x83, 0x25, 0x7f
);

// 89455b97-dbe1-453f-a224-13da895af396
DEFINE_GUID(
   FWPM_LAYER_ALE_AUTH_RECV_ACCEPT_V6_DISCARD,
   0x89455b97,
   0xdbe1,
   0x453f,
   0xa2, 0x24, 0x13, 0xda, 0x89, 0x5a, 0xf3, 0x96
);

// c38d57d1-05a7-4c33-904f-7fbceee60e82
DEFINE_GUID(
   FWPM_LAYER_ALE_AUTH_CONNECT_V4,
   0xc38d57d1,
   0x05a7,
   0x4c33,
   0x90, 0x4f, 0x7f, 0xbc, 0xee, 0xe6, 0x0e, 0x82
);

// d632a801-f5ba-4ad6-96e3-607017d9836a
DEFINE_GUID(
   FWPM_LAYER_ALE_AUTH_CONNECT_V4_DISCARD,
   0xd632a801,
   0xf5ba,
   0x4ad6,
   0x96, 0xe3, 0x60, 0x70, 0x17, 0xd9, 0x83, 0x6a
);

// 4a72393b-319f-44bc-84c3-ba54dcb3b6b4
DEFINE_GUID(
   FWPM_LAYER_ALE_AUTH_CONNECT_V6,
   0x4a72393b,
   0x319f,
   0x44bc,
   0x84, 0xc3, 0xba, 0x54, 0xdc, 0xb3, 0xb6, 0xb4
);

// c97bc3b8-c9a3-4e33-8695-8e17aad4de09
DEFINE_GUID(
   FWPM_LAYER_ALE_AUTH_CONNECT_V6_DISCARD,
   0xc97bc3b8,
   0xc9a3,
   0x4e33,
   0x86, 0x95, 0x8e, 0x17, 0xaa, 0xd4, 0xde, 0x09
);

// af80470a-5596-4c13-9992-539e6fe57967
DEFINE_GUID(
   FWPM_LAYER_ALE_FLOW_ESTABLISHED_V4,
   0xaf80470a,
   0x5596,
   0x4c13,
   0x99, 0x92, 0x53, 0x9e, 0x6f, 0xe5, 0x79, 0x67
);

// 146ae4a9-a1d2-4d43-a31a-4c42682b8e4f
DEFINE_GUID(
   FWPM_LAYER_ALE_FLOW_ESTABLISHED_V4_DISCARD,
   0x146ae4a9,
   0xa1d2,
   0x4d43,
   0xa3, 0x1a, 0x4c, 0x42, 0x68, 0x2b, 0x8e, 0x4f
);

// 7021d2b3-dfa4-406e-afeb-6afaf7e70efd
DEFINE_GUID(
   FWPM_LAYER_ALE_FLOW_ESTABLISHED_V6,
   0x7021d2b3,
   0xdfa4,
   0x406e,
   0xaf, 0xeb, 0x6a, 0xfa, 0xf7, 0xe7, 0x0e, 0xfd
);

// 46928636-bbca-4b76-941d-0fa7f5d7d372
DEFINE_GUID(
   FWPM_LAYER_ALE_FLOW_ESTABLISHED_V6_DISCARD,
   0x46928636,
   0xbbca,
   0x4b76,
   0x94, 0x1d, 0x0f, 0xa7, 0xf5, 0xd7, 0xd3, 0x72
);

// f02b1526-a459-4a51-b9e3-759de52b9d2c
DEFINE_GUID(
   FWPM_LAYER_IPSEC_KM_DEMUX_V4,
   0xf02b1526,
   0xa459,
   0x4a51,
   0xb9, 0xe3, 0x75, 0x9d, 0xe5, 0x2b, 0x9d, 0x2c
);

// 2f755cf6-2fd4-4e88-b3e4-a91bca495235
DEFINE_GUID(
   FWPM_LAYER_IPSEC_KM_DEMUX_V6,
   0x2f755cf6,
   0x2fd4,
   0x4e88,
   0xb3, 0xe4, 0xa9, 0x1b, 0xca, 0x49, 0x52, 0x35
);

// eda65c74-610d-4bc5-948f-3c4f89556867
DEFINE_GUID(
   FWPM_LAYER_IPSEC_V4,
   0xeda65c74,
   0x610d,
   0x4bc5,
   0x94, 0x8f, 0x3c, 0x4f, 0x89, 0x55, 0x68, 0x67
);

// 13c48442-8d87-4261-9a29-59d2abc348b4
DEFINE_GUID(
   FWPM_LAYER_IPSEC_V6,
   0x13c48442,
   0x8d87,
   0x4261,
   0x9a, 0x29, 0x59, 0xd2, 0xab, 0xc3, 0x48, 0xb4
);

// b14b7bdb-dbbd-473e-bed4-8b4708d4f270
DEFINE_GUID(
   FWPM_LAYER_IKEEXT_V4,
   0xb14b7bdb,
   0xdbbd,
   0x473e,
   0xbe, 0xd4, 0x8b, 0x47, 0x08, 0xd4, 0xf2, 0x70
);

// b64786b3-f687-4eb9-89d2-8ef32acdabe2
DEFINE_GUID(
   FWPM_LAYER_IKEEXT_V6,
   0xb64786b3,
   0xf687,
   0x4eb9,
   0x89, 0xd2, 0x8e, 0xf3, 0x2a, 0xcd, 0xab, 0xe2
);

#ifndef UNDER_CE
//RPC UM layers are not supported in CE 7.0
// 75a89dda-95e4-40f3-adc7-7688a9c847e1
DEFINE_GUID(
   FWPM_LAYER_RPC_UM,
   0x75a89dda,
   0x95e4,
   0x40f3,
   0xad, 0xc7, 0x76, 0x88, 0xa9, 0xc8, 0x47, 0xe1
);

// 9247bc61-eb07-47ee-872c-bfd78bfd1616
DEFINE_GUID(
   FWPM_LAYER_RPC_EPMAP,
   0x9247bc61,
   0xeb07,
   0x47ee,
   0x87, 0x2c, 0xbf, 0xd7, 0x8b, 0xfd, 0x16, 0x16
);

// 618dffc7-c450-4943-95db-99b4c16a55d4
DEFINE_GUID(
   FWPM_LAYER_RPC_EP_ADD,
   0x618dffc7,
   0xc450,
   0x4943,
   0x95, 0xdb, 0x99, 0xb4, 0xc1, 0x6a, 0x55, 0xd4
);

// 94a4b50b-ba5c-4f27-907a-229fac0c2a7a
DEFINE_GUID(
   FWPM_LAYER_RPC_PROXY_CONN,
   0x94a4b50b,
   0xba5c,
   0x4f27,
   0x90, 0x7a, 0x22, 0x9f, 0xac, 0x0c, 0x2a, 0x7a
);

// f8a38615-e12c-41ac-98df-121ad981aade
DEFINE_GUID(
   FWPM_LAYER_RPC_PROXY_IF,
   0xf8a38615,
   0xe12c,
   0x41ac,
   0x98, 0xdf, 0x12, 0x1a, 0xd9, 0x81, 0xaa, 0xde
);
#endif //UNDER_CE

///////////////////////////////////////////////////////////////////////////////
//
// GUIDs for built-in sublayers.
//
///////////////////////////////////////////////////////////////////////////////

// 758c84f4-fb48-4de9-9aeb-3ed9551ab1fd
DEFINE_GUID(
   FWPM_SUBLAYER_RPC_AUDIT,
   0x758c84f4,
   0xfb48,
   0x4de9,
   0x9a, 0xeb, 0x3e, 0xd9, 0x55, 0x1a, 0xb1, 0xfd
);

// 83f299ed-9ff4-4967-aff4-c309f4dab827
DEFINE_GUID(
   FWPM_SUBLAYER_IPSEC_TUNNEL,
   0x83f299ed,
   0x9ff4,
   0x4967,
   0xaf, 0xf4, 0xc3, 0x09, 0xf4, 0xda, 0xb8, 0x27
);

// eebecc03-ced4-4380-819a-2734397b2b74
DEFINE_GUID(
   FWPM_SUBLAYER_UNIVERSAL,
   0xeebecc03,
   0xced4,
   0x4380,
   0x81, 0x9a, 0x27, 0x34, 0x39, 0x7b, 0x2b, 0x74
);

// 1b75c0ce-ff60-4711-a70f-b4958cc3b2d0
DEFINE_GUID(
   FWPM_SUBLAYER_LIPS,
   0x1b75c0ce,
   0xff60,
   0x4711,
   0xa7, 0x0f, 0xb4, 0x95, 0x8c, 0xc3, 0xb2, 0xd0
);

// 15a66e17-3f3c-4f7b-aa6c-812aa613dd82
DEFINE_GUID(
   FWPM_SUBLAYER_SECURE_SOCKET,
   0x15a66e17,
   0x3f3c,
   0x4f7b,
   0xaa, 0x6c, 0x81, 0x2a, 0xa6, 0x13, 0xdd, 0x82
);

// 337608b9-b7d5-4d5f-82f9-3618618bc058
DEFINE_GUID(
   FWPM_SUBLAYER_TCP_CHIMNEY_OFFLOAD,
   0x337608b9,
   0xb7d5,
   0x4d5f,
   0x82, 0xf9, 0x36, 0x18, 0x61, 0x8b, 0xc0, 0x58
);

// 877519e1-e6a9-41a5-81b4-8c4f118e4a60
DEFINE_GUID(
   FWPM_SUBLAYER_INSPECTION,
   0x877519e1,
   0xe6a9,
   0x41a5,
   0x81, 0xb4, 0x8c, 0x4f, 0x11, 0x8e, 0x4a, 0x60
);

// ba69dc66-5176-4979-9c89-26a7b46a8327
DEFINE_GUID(
   FWPM_SUBLAYER_TEREDO,
   0xba69dc66,
   0x5176,
   0x4979,
   0x9c, 0x89, 0x26, 0xa7, 0xb4, 0x6a, 0x83, 0x27
);

// c8e65357-78bf-4854-b583-336de103f2a6
DEFINE_GUID(
   FWPM_SUBLAYER_SECURITY_MODEL,
   0xc8e65357,
   0x78bf,
   0x4854,
   0xb5, 0x83, 0x33, 0x6d, 0xe1, 0x03, 0xf2, 0xa6
);

#if (NTDDI_VERSION >= NTDDI_WIN6SP1)

// a5082e73-8f71-4559-8a9a-101cea04ef87
DEFINE_GUID(
   FWPM_SUBLAYER_IPSEC_FORWARD_OUTBOUND_TUNNEL,
   0xa5082e73,
   0x8f71,
   0x4559,
   0x8a, 0x9a, 0x10, 0x1c, 0xea, 0x04, 0xef, 0x87
);

#endif // (NTDDI_VERSION >= NTDDI_WIN6SP1)

///////////////////////////////////////////////////////////////////////////////
//
// GUIDs for built-in conditions.
//
///////////////////////////////////////////////////////////////////////////////

// d9ee00de-c1ef-4617-bfe3-ffd8f5a08957
DEFINE_GUID(
   FWPM_CONDITION_IP_LOCAL_ADDRESS,
   0xd9ee00de,
   0xc1ef,
   0x4617,
   0xbf, 0xe3, 0xff, 0xd8, 0xf5, 0xa0, 0x89, 0x57
);

// b235ae9a-1d64-49b8-a44c-5ff3d9095045
DEFINE_GUID(
   FWPM_CONDITION_IP_REMOTE_ADDRESS,
   0xb235ae9a,
   0x1d64,
   0x49b8,
   0xa4, 0x4c, 0x5f, 0xf3, 0xd9, 0x09, 0x50, 0x45
);

// ae96897e-2e94-4bc9-b313-b27ee80e574d
DEFINE_GUID(
   FWPM_CONDITION_IP_SOURCE_ADDRESS,
   0xae96897e,
   0x2e94,
   0x4bc9,
   0xb3, 0x13, 0xb2, 0x7e, 0xe8, 0x0e, 0x57, 0x4d
);

// 2d79133b-b390-45c6-8699-acaceaafed33
DEFINE_GUID(
   FWPM_CONDITION_IP_DESTINATION_ADDRESS,
   0x2d79133b,
   0xb390,
   0x45c6,
   0x86, 0x99, 0xac, 0xac, 0xea, 0xaf, 0xed, 0x33
);

// 6ec7f6c4-376b-45d7-9e9c-d337cedcd237
DEFINE_GUID(
   FWPM_CONDITION_IP_LOCAL_ADDRESS_TYPE,
   0x6ec7f6c4,
   0x376b,
   0x45d7,
   0x9e, 0x9c, 0xd3, 0x37, 0xce, 0xdc, 0xd2, 0x37
);

// 1ec1b7c9-4eea-4f5e-b9ef-76beaaaf17ee
DEFINE_GUID(
   FWPM_CONDITION_IP_DESTINATION_ADDRESS_TYPE,
   0x1ec1b7c9,
   0x4eea,
   0x4f5e,
   0xb9, 0xef, 0x76, 0xbe, 0xaa, 0xaf, 0x17, 0xee
);

// 4cd62a49-59c3-4969-b7f3-bda5d32890a4
DEFINE_GUID(
   FWPM_CONDITION_IP_LOCAL_INTERFACE,
   0x4cd62a49,
   0x59c3,
   0x4969,
   0xb7, 0xf3, 0xbd, 0xa5, 0xd3, 0x28, 0x90, 0xa4
);


#if (NTDDI_VERSION >= NTDDI_WIN6SP1)

// 618a9b6d-386b-4136-ad6e-b51587cfb1cd
DEFINE_GUID(
   FWPM_CONDITION_IP_ARRIVAL_INTERFACE,
   0x618a9b6d,
   0x386b,
   0x4136,
   0xad, 0x6e, 0xb5, 0x15, 0x87, 0xcf, 0xb1, 0xcd 
);

// 89f990de-e798-4e6d-ab76-7c9558292e6f
DEFINE_GUID(
   FWPM_CONDITION_ARRIVAL_INTERFACE_TYPE,
   0x89f990de,
   0xe798,
   0x4e6d,
   0xab, 0x76, 0x7c, 0x95, 0x58, 0x29, 0x2e, 0x6f
);

// 511166dc-7a8c-4aa7-b533-95ab59fb0340
DEFINE_GUID(
   FWPM_CONDITION_ARRIVAL_TUNNEL_TYPE,
   0x511166dc,
   0x7a8c,
   0x4aa7,
   0xb5, 0x33, 0x95, 0xab, 0x59, 0xfb, 0x03, 0x40
);

// cc088db3-1792-4a71-b0f9-037d21cd828b
DEFINE_GUID(
   FWPM_CONDITION_ARRIVAL_INTERFACE_INDEX,
   0xcc088db3,
   0x1792,
   0x4a71,
   0xb0, 0xf9, 0x03, 0x7d, 0x21, 0xcd, 0x82, 0x8b
);

#endif // (NTDDI_VERSION >= NTDDI_WIN6SP1)

// daf8cd14-e09e-4c93-a5ae-c5c13b73ffca
DEFINE_GUID(
   FWPM_CONDITION_INTERFACE_TYPE,
   0xdaf8cd14,
   0xe09e,
   0x4c93,
   0xa5, 0xae, 0xc5, 0xc1, 0x3b, 0x73, 0xff, 0xca
);

#if (NTDDI_VERSION >= NTDDI_WIN6SP1)

#define FWPM_CONDITION_LOCAL_INTERFACE_TYPE FWPM_CONDITION_INTERFACE_TYPE

#endif // (NTDDI_VERSION >= NTDDI_WIN6SP1)

// 77a40437-8779-4868-a261-f5a902f1c0cd
DEFINE_GUID(
   FWPM_CONDITION_TUNNEL_TYPE,
   0x77a40437,
   0x8779,
   0x4868,
   0xa2, 0x61, 0xf5, 0xa9, 0x02, 0xf1, 0xc0, 0xcd
);

#if (NTDDI_VERSION >= NTDDI_WIN6SP1)

#define FWPM_CONDITION_LOCAL_TUNNEL_TYPE FWPM_CONDITION_TUNNEL_TYPE

#endif // (NTDDI_VERSION >= NTDDI_WIN6SP1)

// 1076b8a5-6323-4c5e-9810-e8d3fc9e6136
DEFINE_GUID(
   FWPM_CONDITION_IP_FORWARD_INTERFACE,
   0x1076b8a5,
   0x6323,
   0x4c5e,
   0x98, 0x10, 0xe8, 0xd3, 0xfc, 0x9e, 0x61, 0x36
);

// 3971ef2b-623e-4f9a-8cb1-6e79b806b9a7
DEFINE_GUID(
   FWPM_CONDITION_IP_PROTOCOL,
   0x3971ef2b,
   0x623e,
   0x4f9a,
   0x8c, 0xb1, 0x6e, 0x79, 0xb8, 0x06, 0xb9, 0xa7
);

// 0c1ba1af-5765-453f-af22-a8f791ac775b
DEFINE_GUID(
   FWPM_CONDITION_IP_LOCAL_PORT,
   0x0c1ba1af,
   0x5765,
   0x453f,
   0xaf, 0x22, 0xa8, 0xf7, 0x91, 0xac, 0x77, 0x5b
);

#define FWPM_CONDITION_ICMP_TYPE FWPM_CONDITION_IP_LOCAL_PORT

// c35a604d-d22b-4e1a-91b4-68f674ee674b
DEFINE_GUID(
   FWPM_CONDITION_IP_REMOTE_PORT,
   0xc35a604d,
   0xd22b,
   0x4e1a,
   0x91, 0xb4, 0x68, 0xf6, 0x74, 0xee, 0x67, 0x4b
);

#define FWPM_CONDITION_ICMP_CODE FWPM_CONDITION_IP_REMOTE_PORT

// 4672a468-8a0a-4202-abb4-849e92e66809
DEFINE_GUID(
   FWPM_CONDITION_EMBEDDED_LOCAL_ADDRESS_TYPE,
   0x4672a468,
   0x8a0a,
   0x4202,
   0xab, 0xb4, 0x84, 0x9e, 0x92, 0xe6, 0x68, 0x09
);

// 77ee4b39-3273-4671-b63b-ab6feb66eeb6
DEFINE_GUID(
   FWPM_CONDITION_EMBEDDED_REMOTE_ADDRESS,
   0x77ee4b39,
   0x3273,
   0x4671,
   0xb6, 0x3b, 0xab, 0x6f, 0xeb, 0x66, 0xee, 0xb6
);

// 07784107-a29e-4c7b-9ec7-29c44afafdbc
DEFINE_GUID(
   FWPM_CONDITION_EMBEDDED_PROTOCOL,
   0x07784107,
   0xa29e,
   0x4c7b,
   0x9e, 0xc7, 0x29, 0xc4, 0x4a, 0xfa, 0xfd, 0xbc
);

// bfca394d-acdb-484e-b8e6-2aff79757345
DEFINE_GUID(
   FWPM_CONDITION_EMBEDDED_LOCAL_PORT,
   0xbfca394d,
   0xacdb,
   0x484e,
   0xb8, 0xe6, 0x2a, 0xff, 0x79, 0x75, 0x73, 0x45
);

// cae4d6a1-2968-40ed-a4ce-547160dda88d
DEFINE_GUID(
   FWPM_CONDITION_EMBEDDED_REMOTE_PORT,
   0xcae4d6a1,
   0x2968,
   0x40ed,
   0xa4, 0xce, 0x54, 0x71, 0x60, 0xdd, 0xa8, 0x8d
);

// 632ce23b-5167-435c-86d7-e903684aa80c
DEFINE_GUID(
   FWPM_CONDITION_FLAGS,
   0x632ce23b,
   0x5167,
   0x435c,
   0x86, 0xd7, 0xe9, 0x03, 0x68, 0x4a, 0xa8, 0x0c
);

// 8784c146-ca97-44d6-9fd1-19fb1840cbf7
DEFINE_GUID(
   FWPM_CONDITION_DIRECTION,
   0x8784c146,
   0xca97,
   0x44d6,
   0x9f, 0xd1, 0x19, 0xfb, 0x18, 0x40, 0xcb, 0xf7
);

// 667fd755-d695-434a-8af5-d3835a1259bc
DEFINE_GUID(
   FWPM_CONDITION_INTERFACE_INDEX,
   0x667fd755,
   0xd695,
   0x434a,
   0x8a, 0xf5, 0xd3, 0x83, 0x5a, 0x12, 0x59, 0xbc
);

#if (NTDDI_VERSION >= NTDDI_WIN6SP1)

#define FWPM_CONDITION_LOCAL_INTERFACE_INDEX FWPM_CONDITION_INTERFACE_INDEX

#endif // (NTDDI_VERSION >= NTDDI_WIN6SP1)

// 0cd42473-d621-4be3-ae8c-72a348d283e1
DEFINE_GUID(
   FWPM_CONDITION_SUB_INTERFACE_INDEX,
   0x0cd42473,
   0xd621,
   0x4be3,
   0xae, 0x8c, 0x72, 0xa3, 0x48, 0xd2, 0x83, 0xe1
);

#if (NTDDI_VERSION >= NTDDI_WIN6SP1)

#define FWPM_CONDITION_ARRIVAL_SUB_INTERFACE_INDEX \
        FWPM_CONDITION_SUB_INTERFACE_INDEX

#endif // (NTDDI_VERSION >= NTDDI_WIN6SP1)

// 2311334d-c92d-45bf-9496-edf447820e2d
DEFINE_GUID(
   FWPM_CONDITION_SOURCE_INTERFACE_INDEX,
   0x2311334d,
   0xc92d,
   0x45bf,
   0x94, 0x96, 0xed, 0xf4, 0x47, 0x82, 0x0e, 0x2d
);

// 055edd9d-acd2-4361-8dab-f9525d97662f
DEFINE_GUID(
   FWPM_CONDITION_SOURCE_SUB_INTERFACE_INDEX,
   0x055edd9d,
   0xacd2,
   0x4361,
   0x8d, 0xab, 0xf9, 0x52, 0x5d, 0x97, 0x66, 0x2f
);

// 35cf6522-4139-45ee-a0d5-67b80949d879
DEFINE_GUID(
   FWPM_CONDITION_DESTINATION_INTERFACE_INDEX,
   0x35cf6522,
   0x4139,
   0x45ee,
   0xa0, 0xd5, 0x67, 0xb8, 0x09, 0x49, 0xd8, 0x79
);

// 2b7d4399-d4c7-4738-a2f5-e994b43da388
DEFINE_GUID(
   FWPM_CONDITION_DESTINATION_SUB_INTERFACE_INDEX,
   0x2b7d4399,
   0xd4c7,
   0x4738,
   0xa2, 0xf5, 0xe9, 0x94, 0xb4, 0x3d, 0xa3, 0x88
);

// d78e1e87-8644-4ea5-9437-d809ecefc971
DEFINE_GUID(
   FWPM_CONDITION_ALE_APP_ID,
   0xd78e1e87,
   0x8644,
   0x4ea5,
   0x94, 0x37, 0xd8, 0x09, 0xec, 0xef, 0xc9, 0x71
);

// af043a0a-b34d-4f86-979c-c90371af6e66
DEFINE_GUID(
   FWPM_CONDITION_ALE_USER_ID,
   0xaf043a0a,
   0xb34d,
   0x4f86,
   0x97, 0x9c, 0xc9, 0x03, 0x71, 0xaf, 0x6e, 0x66
);

// f63073b7-0189-4ab0-95a4-6123cbfab862
DEFINE_GUID(
   FWPM_CONDITION_ALE_REMOTE_USER_ID,
   0xf63073b7,
   0x0189,
   0x4ab0,
   0x95, 0xa4, 0x61, 0x23, 0xcb, 0xfa, 0xb8, 0x62
);

// 1aa47f51-7f93-4508-a271-81abb00c9cab
DEFINE_GUID(
   FWPM_CONDITION_ALE_REMOTE_MACHINE_ID,
   0x1aa47f51,
   0x7f93,
   0x4508,
   0xa2, 0x71, 0x81, 0xab, 0xb0, 0x0c, 0x9c, 0xab
);

// 1c974776-7182-46e9-afd3-b02910e30334
DEFINE_GUID(
   FWPM_CONDITION_ALE_PROMISCUOUS_MODE,
   0x1c974776,
   0x7182,
   0x46e9,
   0xaf, 0xd3, 0xb0, 0x29, 0x10, 0xe3, 0x03, 0x34
);

// b9f4e088-cb98-4efb-a2c7-ad07332643db
DEFINE_GUID(
   FWPM_CONDITION_ALE_SIO_FIREWALL_SYSTEM_PORT,
   0xb9f4e088,
   0xcb98,
   0x4efb,
   0xa2, 0xc7, 0xad, 0x07, 0x33, 0x26, 0x43, 0xdb
);

// 46275a9d-c03f-4d77-b784-1c57f4d02753
DEFINE_GUID(
   FWPM_CONDITION_ALE_NAP_CONTEXT,
   0x46275a9d,
   0xc03f,
   0x4d77,
   0xb7, 0x84, 0x1c, 0x57, 0xf4, 0xd0, 0x27, 0x53
);

// 9bf0ee66-06c9-41b9-84da-288cb43af51f
DEFINE_GUID(
    FWPM_CONDITION_REMOTE_USER_TOKEN,
    0x9bf0ee66,
    0x06c9,
    0x41b9,
    0x84, 0xda, 0x28, 0x8c, 0xb4, 0x3a, 0xf5, 0x1f
);

// 7c9c7d9f-0075-4d35-a0d1-8311c4cf6af1
DEFINE_GUID(
   FWPM_CONDITION_RPC_IF_UUID,
   0x7c9c7d9f,
   0x0075,
   0x4d35,
   0xa0, 0xd1, 0x83, 0x11, 0xc4, 0xcf, 0x6a, 0xf1
);

// eabfd9b7-1262-4a2e-adaa-5f96f6fe326d
DEFINE_GUID(
   FWPM_CONDITION_RPC_IF_VERSION,
   0xeabfd9b7,
   0x1262,
   0x4a2e,
   0xad, 0xaa, 0x5f, 0x96, 0xf6, 0xfe, 0x32, 0x6d
);

// 238a8a32-3199-467d-871c-272621ab3896
DEFINE_GUID(
    FWPM_CONDITION_RPC_IF_FLAG,
    0x238a8a32,
    0x3199,
    0x467d,
    0x87, 0x1c, 0x27, 0x26, 0x21, 0xab, 0x38, 0x96
);

// ff2e7b4d-3112-4770-b636-4d24ae3a6af2
DEFINE_GUID(
    FWPM_CONDITION_DCOM_APP_ID,
    0xff2e7b4d,
    0x3112,
    0x4770,
    0xb6, 0x36, 0x4d, 0x24, 0xae, 0x3a, 0x6a, 0xf2
);

// d024de4d-deaa-4317-9c85-e40ef6e140c3
DEFINE_GUID(
    FWPM_CONDITION_IMAGE_NAME,
    0xd024de4d,
    0xdeaa,
    0x4317,
    0x9c, 0x85, 0xe4, 0x0e, 0xf6, 0xe1, 0x40, 0xc3
);

// 2717bc74-3a35-4ce7-b7ef-c838fabdec45
DEFINE_GUID(
    FWPM_CONDITION_RPC_PROTOCOL,
    0x2717bc74,
    0x3a35,
    0x4ce7,
    0xb7, 0xef, 0xc8, 0x38, 0xfa, 0xbd, 0xec, 0x45
);

// daba74ab-0d67-43e7-986e-75b84f82f594
DEFINE_GUID(
   FWPM_CONDITION_RPC_AUTH_TYPE,
   0xdaba74ab,
   0x0d67,
   0x43e7,
   0x98, 0x6e, 0x75, 0xb8, 0x4f, 0x82, 0xf5, 0x94
);

// e5a0aed5-59ac-46ea-be05-a5f05ecf446e
DEFINE_GUID(
   FWPM_CONDITION_RPC_AUTH_LEVEL,
   0xe5a0aed5,
   0x59ac,
   0x46ea,
   0xbe, 0x05, 0xa5, 0xf0, 0x5e, 0xcf, 0x44, 0x6e
);

// 0d306ef0-e974-4f74-b5c7-591b0da7d562
DEFINE_GUID(
   FWPM_CONDITION_SEC_ENCRYPT_ALGORITHM,
   0x0d306ef0,
   0xe974,
   0x4f74,
   0xb5, 0xc7, 0x59, 0x1b, 0x0d, 0xa7, 0xd5, 0x62
);

// 4772183b-ccf8-4aeb-bce1-c6c6161c8fe4
DEFINE_GUID(
    FWPM_CONDITION_SEC_KEY_SIZE,
    0x4772183b,
    0xccf8,
    0x4aeb,
    0xbc, 0xe1, 0xc6, 0xc6, 0x16, 0x1c, 0x8f, 0xe4
);

// 03a629cb-6e52-49f8-9c41-5709633c09cf
DEFINE_GUID(
   FWPM_CONDITION_IP_LOCAL_ADDRESS_V4,
   0x03a629cb,
   0x6e52,
   0x49f8,
   0x9c, 0x41, 0x57, 0x09, 0x63, 0x3c, 0x09, 0xcf
);

// 2381be84-7524-45b3-a05b-1e637d9c7a6a
DEFINE_GUID(
   FWPM_CONDITION_IP_LOCAL_ADDRESS_V6,
   0x2381be84,
   0x7524,
   0x45b3,
   0xa0, 0x5b, 0x1e, 0x63, 0x7d, 0x9c, 0x7a, 0x6a
);

// 1bd0741d-e3df-4e24-8634-762046eef6eb
DEFINE_GUID(
    FWPM_CONDITION_PIPE,
    0x1bd0741d,
    0xe3df,
    0x4e24,
    0x86, 0x34, 0x76, 0x20, 0x46, 0xee, 0xf6, 0xeb
);

// 1febb610-3bcc-45e1-bc36-2e067e2cb186
DEFINE_GUID(
   FWPM_CONDITION_IP_REMOTE_ADDRESS_V4,
   0x1febb610,
   0x3bcc,
   0x45e1,
   0xbc, 0x36, 0x2e, 0x06, 0x7e, 0x2c, 0xb1, 0x86
);

// 246e1d8c-8bee-4018-9b98-31d4582f3361
DEFINE_GUID(
   FWPM_CONDITION_IP_REMOTE_ADDRESS_V6,
   0x246e1d8c,
   0x8bee,
   0x4018,
   0x9b, 0x98, 0x31, 0xd4, 0x58, 0x2f, 0x33, 0x61
);

// e31180a8-bbbd-4d14-a65e-7157b06233bb
DEFINE_GUID(
    FWPM_CONDITION_PROCESS_WITH_RPC_IF_UUID,
    0xe31180a8,
    0xbbbd,
    0x4d14,
    0xa6, 0x5e, 0x71, 0x57, 0xb0, 0x62, 0x33, 0xbb
);

// dccea0b9-0886-4360-9c6a-ab043a24fba9
DEFINE_GUID(
    FWPM_CONDITION_RPC_EP_VALUE,
    0xdccea0b9,
    0x0886,
    0x4360,
    0x9c, 0x6a, 0xab, 0x04, 0x3a, 0x24, 0xfb, 0xa9
);

// 218b814a-0a39-49b8-8e71-c20c39c7dd2e
DEFINE_GUID(
    FWPM_CONDITION_RPC_EP_FLAGS,
    0x218b814a,
    0x0a39,
    0x49b8,
    0x8e, 0x71, 0xc2, 0x0c, 0x39, 0xc7, 0xdd, 0x2e
);

// c228fc1e-403a-4478-be05-c9baa4c05ace
DEFINE_GUID(
    FWPM_CONDITION_CLIENT_TOKEN,
    0xc228fc1e,
    0x403a,
    0x4478,
    0xbe, 0x05, 0xc9, 0xba, 0xa4, 0xc0, 0x5a, 0xce
);

// b605a225-c3b3-48c7-9833-7aefa9527546
DEFINE_GUID(
    FWPM_CONDITION_RPC_SERVER_NAME,
    0xb605a225,
    0xc3b3,
    0x48c7,
    0x98, 0x33, 0x7a, 0xef, 0xa9, 0x52, 0x75, 0x46
);

// 8090f645-9ad5-4e3b-9f9f-8023ca097909
DEFINE_GUID(
    FWPM_CONDITION_RPC_SERVER_PORT,
    0x8090f645,
    0x9ad5,
    0x4e3b,
    0x9f, 0x9f, 0x80, 0x23, 0xca, 0x09, 0x79, 0x09
);

// 40953fe2-8565-4759-8488-1771b4b4b5db
DEFINE_GUID(
    FWPM_CONDITION_RPC_PROXY_AUTH_TYPE,
    0x40953fe2,
    0x8565,
    0x4759,
    0x84, 0x88, 0x17, 0x71, 0xb4, 0xb4, 0xb5, 0xdb
);

// a3ec00c7-05f4-4df7-91f2-5f60d91ff443
DEFINE_GUID(
    FWPM_CONDITION_CLIENT_CERT_KEY_LENGTH,
    0xa3ec00c7,
    0x05f4,
    0x4df7,
    0x91, 0xf2, 0x5f, 0x60, 0xd9, 0x1f, 0xf4, 0x43
);

// c491ad5e-f882-4283-b916-436b103ff4ad
DEFINE_GUID(
    FWPM_CONDITION_CLIENT_CERT_OID,
    0xc491ad5e,
    0xf882,
    0x4283,
    0xb9, 0x16, 0x43, 0x6b, 0x10, 0x3f, 0xf4, 0xad
);

// 056d336d-ca55-489f-94b9-a4962f8246e2
DEFINE_GUID(
   FWPM_CONDITION_SCOPE_ID,
   0x056d336d,
   0xca55,
   0x489f,
   0x94, 0xb9, 0xa4, 0x96, 0x2f, 0x82, 0x46, 0xe2
);


///////////////////////////////////////////////////////////////////////////////
//
// GUIDs for built-in providers.
//
///////////////////////////////////////////////////////////////////////////////

// 10ad9216-ccde-456c-8b16-e9f04e60a90b
DEFINE_GUID(
   FWPM_PROVIDER_IKEEXT,
   0x10ad9216,
   0xccde,
   0x456c,
   0x8b, 0x16, 0xe9, 0xf0, 0x4e, 0x60, 0xa9, 0x0b
);

// 896aa19e-9a34-4bcb-ae79-beb9127c84b9
DEFINE_GUID(
   FWPM_PROVIDER_TCP_CHIMNEY_OFFLOAD,
   0x896aa19e,
   0x9a34,
   0x4bcb,
   0xae, 0x79, 0xbe, 0xb9, 0x12, 0x7c, 0x84, 0xb9
);


///////////////////////////////////////////////////////////////////////////////
//
// GUIDs for built-in callouts.
//
///////////////////////////////////////////////////////////////////////////////

// 5132900d-5e84-4b5f-80e4-01741e81ff10
DEFINE_GUID(
   FWPM_CALLOUT_IPSEC_INBOUND_TRANSPORT_V4,
   0x5132900d,
   0x5e84,
   0x4b5f,
   0x80, 0xe4, 0x01, 0x74, 0x1e, 0x81, 0xff, 0x10
);

// 49d3ac92-2a6c-4dcf-955f-1c3be009dd99
DEFINE_GUID(
   FWPM_CALLOUT_IPSEC_INBOUND_TRANSPORT_V6,
   0x49d3ac92,
   0x2a6c,
   0x4dcf,
   0x95, 0x5f, 0x1c, 0x3b, 0xe0, 0x09, 0xdd, 0x99
);

// 4b46bf0a-4523-4e57-aa38-a87987c910d9
DEFINE_GUID(
   FWPM_CALLOUT_IPSEC_OUTBOUND_TRANSPORT_V4,
   0x4b46bf0a,
   0x4523,
   0x4e57,
   0xaa, 0x38, 0xa8, 0x79, 0x87, 0xc9, 0x10, 0xd9
);

// 38d87722-ad83-4f11-a91f-df0fb077225b
DEFINE_GUID(
   FWPM_CALLOUT_IPSEC_OUTBOUND_TRANSPORT_V6,
   0x38d87722,
   0xad83,
   0x4f11,
   0xa9, 0x1f, 0xdf, 0x0f, 0xb0, 0x77, 0x22, 0x5b
);

// 191a8a46-0bf8-46cf-b045-4b45dfa6a324
DEFINE_GUID(
   FWPM_CALLOUT_IPSEC_INBOUND_TUNNEL_V4,
   0x191a8a46,
   0x0bf8,
   0x46cf,
   0xb0, 0x45, 0x4b, 0x45, 0xdf, 0xa6, 0xa3, 0x24
);

// 80c342e3-1e53-4d6f-9b44-03df5aeee154
DEFINE_GUID(
   FWPM_CALLOUT_IPSEC_INBOUND_TUNNEL_V6,
   0x80c342e3,
   0x1e53,
   0x4d6f,
   0x9b, 0x44, 0x03, 0xdf, 0x5a, 0xee, 0xe1, 0x54
);

// 70a4196c-835b-4fb0-98e8-075f4d977d46
DEFINE_GUID(
   FWPM_CALLOUT_IPSEC_OUTBOUND_TUNNEL_V4,
   0x70a4196c,
   0x835b,
   0x4fb0,
   0x98, 0xe8, 0x07, 0x5f, 0x4d, 0x97, 0x7d, 0x46
);

// f1835363-a6a5-4e62-b180-23db789d8da6
DEFINE_GUID(
   FWPM_CALLOUT_IPSEC_OUTBOUND_TUNNEL_V6,
   0xf1835363,
   0xa6a5,
   0x4e62,
   0xb1, 0x80, 0x23, 0xdb, 0x78, 0x9d, 0x8d, 0xa6
);

// 28829633-c4f0-4e66-873f-844db2a899c7
DEFINE_GUID(
   FWPM_CALLOUT_IPSEC_FORWARD_INBOUND_TUNNEL_V4,
   0x28829633,
   0xc4f0,
   0x4e66,
   0x87, 0x3f, 0x84, 0x4d, 0xb2, 0xa8, 0x99, 0xc7
);

// af50bec2-c686-429a-884d-b74443e7b0b4
DEFINE_GUID(
   FWPM_CALLOUT_IPSEC_FORWARD_INBOUND_TUNNEL_V6,
   0xaf50bec2,
   0xc686,
   0x429a,
   0x88, 0x4d, 0xb7, 0x44, 0x43, 0xe7, 0xb0, 0xb4
);

// fb532136-15cb-440b-937c-1717ca320c40
DEFINE_GUID(
   FWPM_CALLOUT_IPSEC_FORWARD_OUTBOUND_TUNNEL_V4,
   0xfb532136,
   0x15cb,
   0x440b,
   0x93, 0x7c, 0x17, 0x17, 0xca, 0x32, 0x0c, 0x40
);

// dae640cc-e021-4bee-9eb6-a48b275c8c1d
DEFINE_GUID(
   FWPM_CALLOUT_IPSEC_FORWARD_OUTBOUND_TUNNEL_V6,
   0xdae640cc,
   0xe021,
   0x4bee,
   0x9e, 0xb6, 0xa4, 0x8b, 0x27, 0x5c, 0x8c, 0x1d
);

// 7dff309b-ba7d-4aba-91aa-ae5c6640c944
DEFINE_GUID(
   FWPM_CALLOUT_IPSEC_INBOUND_INITIATE_SECURE_V4,
   0x7dff309b,
   0xba7d,
   0x4aba,
   0x91, 0xaa, 0xae, 0x5c, 0x66, 0x40, 0xc9, 0x44
);

// a9a0d6d9-c58c-474e-8aeb-3cfe99d6d53d
DEFINE_GUID(
   FWPM_CALLOUT_IPSEC_INBOUND_INITIATE_SECURE_V6,
   0xa9a0d6d9,
   0xc58c,
   0x474e,
   0x8a, 0xeb, 0x3c, 0xfe, 0x99, 0xd6, 0xd5, 0x3d
);

// 3df6e7de-fd20-48f2-9f26-f854444cba79
DEFINE_GUID(
   FWPM_CALLOUT_IPSEC_INBOUND_TUNNEL_ALE_ACCEPT_V4,
   0x3df6e7de,
   0xfd20,
   0x48f2,
   0x9f, 0x26, 0xf8, 0x54, 0x44, 0x4c, 0xba, 0x79
);

// a1e392d3-72ac-47bb-87a7-0122c69434ab
DEFINE_GUID(
   FWPM_CALLOUT_IPSEC_INBOUND_TUNNEL_ALE_ACCEPT_V6,
   0xa1e392d3,
   0x72ac,
   0x47bb,
   0x87, 0xa7, 0x01, 0x22, 0xc6, 0x94, 0x34, 0xab
);

// 6ac141fc-f75d-4203-b9c8-48e6149c2712
DEFINE_GUID(
   FWPM_CALLOUT_IPSEC_ALE_CONNECT_V4,
   0x6ac141fc,
   0xf75d,
   0x4203,
   0xb9,0xc8,0x48, 0xe6, 0x14, 0x9c, 0x27, 0x12
);

// 4c0dda05-e31f-4666-90b0-b3dfad34129a
DEFINE_GUID(
   FWPM_CALLOUT_IPSEC_ALE_CONNECT_V6,
   0x4c0dda05,
   0xe31f,
   0x4666,
   0x90, 0xb0, 0xb3, 0xdf, 0xad, 0x34, 0x12, 0x9a
);

// eda08606-2494-4d78-89bc-67837c03b969
DEFINE_GUID(
   FWPM_CALLOUT_WFP_TRANSPORT_LAYER_V4_SILENT_DROP,
   0xeda08606,
   0x2494,
   0x4d78,
   0x89, 0xbc, 0x67, 0x83, 0x7c, 0x03, 0xb9, 0x69
);

// 8693cc74-a075-4156-b476-9286eece814e
DEFINE_GUID(
   FWPM_CALLOUT_WFP_TRANSPORT_LAYER_V6_SILENT_DROP,
   0x8693cc74,
   0xa075,
   0x4156,
   0xb4, 0x76, 0x92, 0x86, 0xee, 0xce, 0x81, 0x4e
);

// f3e10ab3-2c25-4279-ac36-c30fc181bec4
DEFINE_GUID(
   FWPM_CALLOUT_TCP_CHIMNEY_CONNECT_LAYER_V4,
   0xf3e10ab3,
   0x2c25,
   0x4279,
   0xac, 0x36, 0xc3, 0x0f, 0xc1, 0x81, 0xbe, 0xc4
);

// 39e22085-a341-42fc-a279-aec94e689c56
DEFINE_GUID(
   FWPM_CALLOUT_TCP_CHIMNEY_CONNECT_LAYER_V6,
   0x39e22085,
   0xa341,
   0x42fc,
   0xa2, 0x79, 0xae, 0xc9, 0x4e, 0x68, 0x9c, 0x56
);

// e183ecb2-3a7f-4b54-8ad9-76050ed880ca
DEFINE_GUID(
   FWPM_CALLOUT_TCP_CHIMNEY_ACCEPT_LAYER_V4,
   0xe183ecb2,
   0x3a7f,
   0x4b54,
   0x8a, 0xd9, 0x76, 0x05, 0x0e, 0xd8, 0x80, 0xca
);

// 0378cf41-bf98-4603-81f2-7f12586079f6
DEFINE_GUID(
   FWPM_CALLOUT_TCP_CHIMNEY_ACCEPT_LAYER_V6,
   0x0378cf41,
   0xbf98,
   0x4603,
   0x81, 0xf2, 0x7f, 0x12, 0x58, 0x60, 0x79, 0xf6
);

// bc582280-1677-41e9-94ab-c2fcb15c2eeb
DEFINE_GUID(
   FWPM_CALLOUT_SET_OPTIONS_AUTH_CONNECT_LAYER_V4,
   0xbc582280,
   0x1677,
   0x41e9,
   0x94, 0xab, 0xc2, 0xfc, 0xb1, 0x5c, 0x2e, 0xeb
);

// 98e5373c-b884-490f-b65f-2f6a4a575195
DEFINE_GUID(
   FWPM_CALLOUT_SET_OPTIONS_AUTH_CONNECT_LAYER_V6,
   0x98e5373c,
   0xb884,
   0x490f,
   0xb6, 0x5f, 0x2f, 0x6a, 0x4a, 0x57, 0x51, 0x95
);

// 31b95392-066e-42a2-b7db-92f8acdd56f9
DEFINE_GUID(
   FWPM_CALLOUT_TEREDO_ALE_RESOURCE_ASSIGNMENT_V6,
   0x31b95392,
   0x066e,
   0x42a2,
   0xb7, 0xdb, 0x92, 0xf8, 0xac, 0xdd, 0x56, 0xf9
);

// 81a434e7-f60c-4378-bab8-c625a30f0197
DEFINE_GUID(
   FWPM_CALLOUT_TEREDO_ALE_LISTEN_V6,
   0x81a434e7,
   0xf60c,
   0x4378,
   0xba, 0xb8, 0xc6, 0x25, 0xa3, 0x0f, 0x01, 0x97
);

///////////////////////////////////////////////////////////////////////////////
//
// GUIDs for built-in provider contexts.
//
///////////////////////////////////////////////////////////////////////////////

// b25ea800-0d02-46ed-92bd-7fa84bb73e9d
DEFINE_GUID(
   FWPM_PROVIDER_CONTEXT_SECURE_SOCKET_AUTHIP,
   0xb25ea800,
   0x0d02,
   0x46ed,
   0x92, 0xbd, 0x7f, 0xa8, 0x4b, 0xb7, 0x3e, 0x9d
);


// 8c2d4144-f8e0-42c0-94ce-7ccfc63b2f9b
DEFINE_GUID(
   FWPM_PROVIDER_CONTEXT_SECURE_SOCKET_IPSEC,
   0x8c2d4144,
   0xf8e0,
   0x42c0,
   0x94, 0xce, 0x7c, 0xcf, 0xc6, 0x3b, 0x2f, 0x9b
);


///////////////////////////////////////////////////////////////////////////////
//
// GUIDs for built-in keying modules.
//
///////////////////////////////////////////////////////////////////////////////

// a9bbf787-82a8-45bb-a400-5d7e5952c7a9
DEFINE_GUID(
   FWPM_KEYING_MODULE_IKE,
   0xa9bbf787,
   0x82a8,
   0x45bb,
   0xa4, 0x00, 0x5d, 0x7e, 0x59, 0x52, 0xc7, 0xa9
);

// 11e3dae0-dd26-4590-857d-ab4b28d1a095
DEFINE_GUID(
   FWPM_KEYING_MODULE_AUTHIP,
   0x11e3dae0,
   0xdd26,
   0x4590,
   0x85, 0x7d, 0xab, 0x4b, 0x28, 0xd1, 0xa0, 0x95
);

#ifndef GUID_DEFS_ONLY
#ifndef FWPMX_H
#define FWPMX_H

#ifndef _KRPCENV_
#define _KRPCENV_ 1
#endif

#include "fwpmtypes.h"

#ifdef __cplusplus
extern "C" {
#endif

///////////////////////////////////////////////////////////////////////////////
//
// Well-known filter weight ranges.
//
///////////////////////////////////////////////////////////////////////////////

// Number of bits used for auto-generated weights.
#define FWPM_AUTO_WEIGHT_BITS (60)
// Maximum auto-generated weight.
#define FWPM_AUTO_WEIGHT_MAX  (MAXUINT64 >> (64 - FWPM_AUTO_WEIGHT_BITS))
// Maximum allowed weight range.
#define FWPM_WEIGHT_RANGE_MAX (MAXUINT64 >> FWPM_AUTO_WEIGHT_BITS)

// IPsec policy
#define FWPM_WEIGHT_RANGE_IPSEC            (0x0)
// Filters to exempt IKE traffic from IPsec.
#define FWPM_WEIGHT_RANGE_IKE_EXEMPTIONS   (0xc)


///////////////////////////////////////////////////////////////////////////////
//
// IPsec transform constants.
//
///////////////////////////////////////////////////////////////////////////////

//////////
// Authentication transform constants
//////////

static const IPSEC_AUTH_TRANSFORM_ID0 IPSEC_AUTH_TRANSFORM_ID_HMAC_MD5_96 =
{
   IPSEC_AUTH_MD5,
   IPSEC_AUTH_CONFIG_HMAC_MD5_96
};

static const IPSEC_AUTH_TRANSFORM_ID0 IPSEC_AUTH_TRANSFORM_ID_HMAC_SHA_1_96 =
{
   IPSEC_AUTH_SHA_1,
   IPSEC_AUTH_CONFIG_HMAC_SHA_1_96
};

#if (NTDDI_VERSION >= NTDDI_WIN6SP1)

static const IPSEC_AUTH_TRANSFORM_ID0 IPSEC_AUTH_TRANSFORM_ID_HMAC_SHA_256_128 =
{
   IPSEC_AUTH_SHA_256,
   IPSEC_AUTH_CONFIG_HMAC_SHA_256_128
};

static const IPSEC_AUTH_TRANSFORM_ID0 IPSEC_AUTH_TRANSFORM_ID_GCM_AES_128 =
{
   IPSEC_AUTH_AES_128,
   IPSEC_AUTH_CONFIG_GCM_AES_128
};

static const IPSEC_AUTH_TRANSFORM_ID0 IPSEC_AUTH_TRANSFORM_ID_GCM_AES_192 =
{
   IPSEC_AUTH_AES_192,
   IPSEC_AUTH_CONFIG_GCM_AES_192
};

static const IPSEC_AUTH_TRANSFORM_ID0 IPSEC_AUTH_TRANSFORM_ID_GCM_AES_256 =
{
   IPSEC_AUTH_AES_256,
   IPSEC_AUTH_CONFIG_GCM_AES_256
};

#endif // (NTDDI_VERSION >= NTDDI_WIN6SP1)

//////////
// Cipher transform constants
//////////

static const IPSEC_CIPHER_TRANSFORM_ID0 IPSEC_CIPHER_TRANSFORM_ID_CBC_DES =
{
   IPSEC_CIPHER_TYPE_DES,
   IPSEC_CIPHER_CONFIG_CBC_DES
};

static const IPSEC_CIPHER_TRANSFORM_ID0 IPSEC_CIPHER_TRANSFORM_ID_CBC_3DES =
{
   IPSEC_CIPHER_TYPE_3DES,
   IPSEC_CIPHER_CONFIG_CBC_3DES
};

static const IPSEC_CIPHER_TRANSFORM_ID0 IPSEC_CIPHER_TRANSFORM_ID_AES_128 =
{
   IPSEC_CIPHER_TYPE_AES_128,
   IPSEC_CIPHER_CONFIG_CBC_AES_128
};

static const IPSEC_CIPHER_TRANSFORM_ID0 IPSEC_CIPHER_TRANSFORM_ID_AES_192 =
{
   IPSEC_CIPHER_TYPE_AES_192,
   IPSEC_CIPHER_CONFIG_CBC_AES_192
};

static const IPSEC_CIPHER_TRANSFORM_ID0 IPSEC_CIPHER_TRANSFORM_ID_AES_256 =
{
   IPSEC_CIPHER_TYPE_AES_256,
   IPSEC_CIPHER_CONFIG_CBC_AES_256
};

#if (NTDDI_VERSION >= NTDDI_WIN6SP1)

static const IPSEC_CIPHER_TRANSFORM_ID0 IPSEC_CIPHER_TRANSFORM_ID_GCM_AES_128 =
{
   IPSEC_CIPHER_TYPE_AES_128,
   IPSEC_CIPHER_CONFIG_GCM_AES_128
};

static const IPSEC_CIPHER_TRANSFORM_ID0 IPSEC_CIPHER_TRANSFORM_ID_GCM_AES_192 =
{
   IPSEC_CIPHER_TYPE_AES_192,
   IPSEC_CIPHER_CONFIG_GCM_AES_192
};

static const IPSEC_CIPHER_TRANSFORM_ID0 IPSEC_CIPHER_TRANSFORM_ID_GCM_AES_256 =
{
   IPSEC_CIPHER_TYPE_AES_256,
   IPSEC_CIPHER_CONFIG_GCM_AES_256
};

#endif // (NTDDI_VERSION >= NTDDI_WIN6SP1)

///////////////////////////////////////////////////////////////////////////////
//
// Well-known filter contexts.
//
///////////////////////////////////////////////////////////////////////////////

// IPSec transport filter contexts in inbound layer
#define FWPM_CONTEXT_IPSEC_INBOUND_PASSTHRU (0x1ui64)
#define FWPM_CONTEXT_IPSEC_INBOUND_PERSIST_CONNECTION_SECURITY (0x2ui64)
#define FWPM_CONTEXT_IPSEC_INBOUND_RESERVED (0xff00000000000000ui64)

// IPSec transport filter contexts in outbound layer
#define FWPM_CONTEXT_IPSEC_OUTBOUND_NEGOTIATE_DISCOVER (0x1ui64)

// Filter contexts used in the ALE connect layer
#define FWPM_CONTEXT_ALE_SET_CONNECTION_REQUIRE_IPSEC_SECURITY (0x2ui64)
#define FWPM_CONTEXT_ALE_SET_CONNECTION_LAZY_SD_EVALUATION (0x4ui64)

// Filter contexts used in the ALE connect or accept layer
#define FWPM_CONTEXT_ALE_SET_CONNECTION_REQUIRE_IPSEC_ENCRYPTION (0x8ui64)

// Contexts used by the TCP Chimney Offload callouts.
#define FWPM_CONTEXT_TCP_CHIMNEY_OFFLOAD_ENABLE (0x1ui64)
#define FWPM_CONTEXT_TCP_CHIMNEY_OFFLOAD_DISABLE (0x2ui64)

// Contexts used in the RPC audit sublayer
#define FWPM_CONTEXT_RPC_AUDIT_ENABLED (0x1ui64)


///////////////////////////////////////////////////////////////////////////////
//
// Access rights
//
///////////////////////////////////////////////////////////////////////////////

// Specific access rights.
#define FWPM_ACTRL_ADD               (0x00000001)
#define FWPM_ACTRL_ADD_LINK          (0x00000002)
#define FWPM_ACTRL_BEGIN_READ_TXN    (0x00000004)
#define FWPM_ACTRL_BEGIN_WRITE_TXN   (0x00000008)
#define FWPM_ACTRL_CLASSIFY          (0x00000010)
#define FWPM_ACTRL_ENUM              (0x00000020)
#define FWPM_ACTRL_OPEN              (0x00000040)
#define FWPM_ACTRL_READ              (0x00000080)
#define FWPM_ACTRL_READ_STATS        (0x00000100)
#define FWPM_ACTRL_SUBSCRIBE         (0x00000200)
#define FWPM_ACTRL_WRITE             (0x00000400)

// Generic access rights.
#define FWPM_GENERIC_READ \
      ( STANDARD_RIGHTS_READ       | \
        FWPM_ACTRL_BEGIN_READ_TXN  | \
        FWPM_ACTRL_CLASSIFY        | \
        FWPM_ACTRL_OPEN            | \
        FWPM_ACTRL_READ            | \
        FWPM_ACTRL_READ_STATS      )

#define FWPM_GENERIC_EXECUTE \
      ( STANDARD_RIGHTS_EXECUTE    | \
        FWPM_ACTRL_ENUM            | \
        FWPM_ACTRL_SUBSCRIBE       )

#define FWPM_GENERIC_WRITE \
      ( STANDARD_RIGHTS_WRITE      | \
        DELETE                     | \
        FWPM_ACTRL_ADD             | \
        FWPM_ACTRL_ADD_LINK        | \
        FWPM_ACTRL_BEGIN_WRITE_TXN | \
        FWPM_ACTRL_WRITE           )

#define FWPM_GENERIC_ALL \
      ( STANDARD_RIGHTS_REQUIRED   | \
        FWPM_ACTRL_ADD             | \
        FWPM_ACTRL_ADD_LINK        | \
        FWPM_ACTRL_BEGIN_READ_TXN  | \
        FWPM_ACTRL_BEGIN_WRITE_TXN | \
        FWPM_ACTRL_CLASSIFY        | \
        FWPM_ACTRL_ENUM            | \
        FWPM_ACTRL_OPEN            | \
        FWPM_ACTRL_READ            | \
        FWPM_ACTRL_READ_STATS      | \
        FWPM_ACTRL_SUBSCRIBE       | \
        FWPM_ACTRL_WRITE           )


///////////////////////////////////////////////////////////////////////////////
//
// Common utility functions.
//
///////////////////////////////////////////////////////////////////////////////

void NTAPI FwpmFreeMemory0(IN OUT void** p);


///////////////////////////////////////////////////////////////////////////////
//
// Functions for managing the engine.
//
///////////////////////////////////////////////////////////////////////////////

typedef void (CALLBACK *FWPM_SERVICE_STATE_CHANGE_CALLBACK0)(
                           IN OUT void* context,
                           IN FWPM_SERVICE_STATE newState
                           );

FWPM_SERVICE_STATE NTAPI FwpmBfeStateGet0(void);

NTSTATUS
NTAPI
FwpmBfeStateSubscribeChanges0(
   IN OUT void* deviceObject,
   IN FWPM_SERVICE_STATE_CHANGE_CALLBACK0 callback,
   IN OPTIONAL void* context,
   OUT HANDLE* changeHandle
   );

NTSTATUS
NTAPI
FwpmBfeStateUnsubscribeChanges0(
   IN HANDLE changeHandle
   );

NTSTATUS
NTAPI
FwpmEngineOpen0(
   IN OPTIONAL const wchar_t* serverName,
   IN UINT32 authnService,
   IN OPTIONAL SEC_WINNT_AUTH_IDENTITY_W* authIdentity,
   IN OPTIONAL const FWPM_SESSION0* session,
   OUT HANDLE* engineHandle
   );

NTSTATUS
NTAPI
FwpmEngineClose0(IN HANDLE engineHandle);

NTSTATUS
NTAPI
FwpmEngineGetOption0(
   IN HANDLE engineHandle,
   IN FWPM_ENGINE_OPTION option,
   OUT FWP_VALUE0** value
   );

NTSTATUS
NTAPI
FwpmEngineSetOption0(
   IN HANDLE engineHandle,
   IN FWPM_ENGINE_OPTION option,
   IN const FWP_VALUE0* newValue
   );

NTSTATUS
NTAPI
FwpmEngineGetSecurityInfo0(
   IN HANDLE engineHandle,
   IN SECURITY_INFORMATION securityInfo,
   OUT OPTIONAL PSID* sidOwner,
   OUT OPTIONAL PSID* sidGroup,
   OUT OPTIONAL PACL* dacl,
   OUT OPTIONAL PACL* sacl,
   OUT PSECURITY_DESCRIPTOR* securityDescriptor
   );

NTSTATUS
NTAPI
FwpmEngineSetSecurityInfo0(
   IN HANDLE engineHandle,
   IN SECURITY_INFORMATION securityInfo,
   IN OPTIONAL const SID* sidOwner,
   IN OPTIONAL const SID* sidGroup,
   IN OPTIONAL const ACL* dacl,
   IN OPTIONAL const ACL* sacl
   );

NTSTATUS
NTAPI
FwpmSessionCreateEnumHandle0(
   IN HANDLE engineHandle,
   IN OPTIONAL const FWPM_SESSION_ENUM_TEMPLATE0* enumTemplate,
   OUT HANDLE* enumHandle
   );

NTSTATUS
NTAPI
FwpmSessionEnum0(
   IN HANDLE engineHandle,
   IN HANDLE enumHandle,
   IN UINT32 numEntriesRequested,
   OUT FWPM_SESSION0*** entries,
   OUT UINT32* numEntriesReturned
   );

NTSTATUS
NTAPI
FwpmSessionDestroyEnumHandle0(
   IN HANDLE engineHandle,
   IN HANDLE enumHandle
   );


///////////////////////////////////////////////////////////////////////////////
//
// Functions for explicit transactions.
//
///////////////////////////////////////////////////////////////////////////////

#define FWPM_TXN_READ_ONLY (0x00000001)

NTSTATUS
NTAPI
FwpmTransactionBegin0(
   IN HANDLE engineHandle,
   IN UINT32 flags
   );

NTSTATUS
NTAPI
FwpmTransactionCommit0(IN HANDLE engineHandle);

NTSTATUS
NTAPI
FwpmTransactionAbort0(IN HANDLE engineHandle);


///////////////////////////////////////////////////////////////////////////////
//
// Functions for managing providers.
//
///////////////////////////////////////////////////////////////////////////////

NTSTATUS
NTAPI
FwpmProviderAdd0(
   IN HANDLE engineHandle,
   IN const FWPM_PROVIDER0* provider,
   IN OPTIONAL PSECURITY_DESCRIPTOR sd
   );

NTSTATUS
NTAPI
FwpmProviderDeleteByKey0(
   IN HANDLE engineHandle,
   IN const GUID* key
   );

NTSTATUS
NTAPI
FwpmProviderGetByKey0(
   IN HANDLE engineHandle,
   IN const GUID* key,
   OUT FWPM_PROVIDER0** provider
   );

NTSTATUS
NTAPI
FwpmProviderCreateEnumHandle0(
   IN HANDLE engineHandle,
   IN OPTIONAL const FWPM_PROVIDER_ENUM_TEMPLATE0* enumTemplate,
   OUT HANDLE* enumHandle
   );

NTSTATUS
NTAPI
FwpmProviderEnum0(
   IN HANDLE engineHandle,
   IN HANDLE enumHandle,
   IN UINT32 numEntriesRequested,
   OUT FWPM_PROVIDER0*** entries,
   OUT UINT32* numEntriesReturned
   );

NTSTATUS
NTAPI
FwpmProviderDestroyEnumHandle0(
   IN HANDLE engineHandle,
   IN HANDLE enumHandle
   );

NTSTATUS
NTAPI
FwpmProviderGetSecurityInfoByKey0(
   IN HANDLE engineHandle,
   IN OPTIONAL const GUID* key,
   IN SECURITY_INFORMATION securityInfo,
   OUT OPTIONAL PSID* sidOwner,
   OUT OPTIONAL PSID* sidGroup,
   OUT OPTIONAL PACL* dacl,
   OUT OPTIONAL PACL* sacl,
   OUT PSECURITY_DESCRIPTOR* securityDescriptor
   );

NTSTATUS
NTAPI
FwpmProviderSetSecurityInfoByKey0(
   IN HANDLE engineHandle,
   IN OPTIONAL const GUID* key,
   IN SECURITY_INFORMATION securityInfo,
   IN OPTIONAL const SID* sidOwner,
   IN OPTIONAL const SID* sidGroup,
   IN OPTIONAL const ACL* dacl,
   IN OPTIONAL const ACL* sacl
   );


///////////////////////////////////////////////////////////////////////////////
//
// Functions for managing provider contexts.
//
///////////////////////////////////////////////////////////////////////////////

NTSTATUS
NTAPI
FwpmProviderContextAdd0(
   IN HANDLE engineHandle,
   IN const FWPM_PROVIDER_CONTEXT0* providerContext,
   IN OPTIONAL PSECURITY_DESCRIPTOR sd,
   OUT OPTIONAL UINT64* id
   );

NTSTATUS
NTAPI
FwpmProviderContextDeleteById0(
   IN HANDLE engineHandle,
   IN UINT64 id
   );

NTSTATUS
NTAPI
FwpmProviderContextDeleteByKey0(
   IN HANDLE engineHandle,
   IN const GUID* key
   );

NTSTATUS
NTAPI
FwpmProviderContextGetById0(
   HANDLE engineHandle,
   IN UINT64 id,
   OUT FWPM_PROVIDER_CONTEXT0** providerContext
   );

NTSTATUS
NTAPI
FwpmProviderContextGetByKey0(
   IN HANDLE engineHandle,
   IN const GUID* key,
   OUT FWPM_PROVIDER_CONTEXT0** providerContext
   );

NTSTATUS
NTAPI
FwpmProviderContextCreateEnumHandle0(
   IN HANDLE engineHandle,
   IN OPTIONAL const FWPM_PROVIDER_CONTEXT_ENUM_TEMPLATE0* enumTemplate,
   OUT HANDLE* enumHandle
   );

NTSTATUS
NTAPI
FwpmProviderContextEnum0(
   IN HANDLE engineHandle,
   IN HANDLE enumHandle,
   IN UINT32 numEntriesRequested,
   OUT FWPM_PROVIDER_CONTEXT0*** entries,
   OUT UINT32* numEntriesReturned
   );

NTSTATUS
NTAPI
FwpmProviderContextDestroyEnumHandle0(
   IN HANDLE engineHandle,
   IN HANDLE enumHandle
   );

NTSTATUS
NTAPI
FwpmProviderContextGetSecurityInfoByKey0(
   IN HANDLE engineHandle,
   IN OPTIONAL const GUID* key,
   IN SECURITY_INFORMATION securityInfo,
   OUT OPTIONAL PSID* sidOwner,
   OUT OPTIONAL PSID* sidGroup,
   OUT OPTIONAL PACL* dacl,
   OUT OPTIONAL PACL* sacl,
   OUT PSECURITY_DESCRIPTOR* securityDescriptor
   );

NTSTATUS
NTAPI
FwpmProviderContextSetSecurityInfoByKey0(
   IN HANDLE engineHandle,
   IN OPTIONAL const GUID* key,
   IN SECURITY_INFORMATION securityInfo,
   IN OPTIONAL const SID* sidOwner,
   IN OPTIONAL const SID* sidGroup,
   IN OPTIONAL const ACL* dacl,
   IN OPTIONAL const ACL* sacl
   );


///////////////////////////////////////////////////////////////////////////////
//
// Functions for managing sub-layers.
//
///////////////////////////////////////////////////////////////////////////////

NTSTATUS
NTAPI
FwpmSubLayerAdd0(
   IN HANDLE engineHandle,
   IN const FWPM_SUBLAYER0* subLayer,
   IN OPTIONAL PSECURITY_DESCRIPTOR sd
   );

NTSTATUS
NTAPI
FwpmSubLayerDeleteByKey0(
   IN HANDLE engineHandle,
   IN const GUID* key
   );

NTSTATUS
NTAPI
FwpmSubLayerGetByKey0(
   IN HANDLE engineHandle,
   IN const GUID* key,
   OUT FWPM_SUBLAYER0** subLayer
   );

NTSTATUS
NTAPI
FwpmSubLayerCreateEnumHandle0(
   IN HANDLE engineHandle,
   IN OPTIONAL const FWPM_SUBLAYER_ENUM_TEMPLATE0* enumTemplate,
   OUT HANDLE* enumHandle
   );

NTSTATUS
NTAPI
FwpmSubLayerEnum0(
   IN HANDLE engineHandle,
   IN HANDLE enumHandle,
   IN UINT32 numEntriesRequested,
   OUT FWPM_SUBLAYER0*** entries,
   OUT UINT32* numEntriesReturned
   );

NTSTATUS
NTAPI
FwpmSubLayerDestroyEnumHandle0(
   IN HANDLE engineHandle,
   IN HANDLE enumHandle
   );

NTSTATUS
NTAPI
FwpmSubLayerGetSecurityInfoByKey0(
   IN HANDLE engineHandle,
   IN OPTIONAL const GUID* key,
   IN SECURITY_INFORMATION securityInfo,
   OUT OPTIONAL PSID* sidOwner,
   OUT OPTIONAL PSID* sidGroup,
   OUT OPTIONAL PACL* dacl,
   OUT OPTIONAL PACL* sacl,
   OUT PSECURITY_DESCRIPTOR* securityDescriptor
   );

NTSTATUS
NTAPI
FwpmSubLayerSetSecurityInfoByKey0(
   IN HANDLE engineHandle,
   IN OPTIONAL const GUID* key,
   IN SECURITY_INFORMATION securityInfo,
   IN OPTIONAL const SID* sidOwner,
   IN OPTIONAL const SID* sidGroup,
   IN OPTIONAL const ACL* dacl,
   IN OPTIONAL const ACL* sacl
   );


///////////////////////////////////////////////////////////////////////////////
//
// Functions for managing layers.
//
///////////////////////////////////////////////////////////////////////////////

NTSTATUS
NTAPI
FwpmLayerGetById0(
   HANDLE engineHandle,
   IN UINT16 id,
   OUT FWPM_LAYER0** layer
   );

NTSTATUS
NTAPI
FwpmLayerGetByKey0(
   IN HANDLE engineHandle,
   IN const GUID* key,
   OUT FWPM_LAYER0** layer
   );

NTSTATUS
NTAPI
FwpmLayerCreateEnumHandle0(
   IN HANDLE engineHandle,
   IN OPTIONAL const FWPM_LAYER_ENUM_TEMPLATE0* enumTemplate,
   OUT HANDLE* enumHandle
   );

NTSTATUS
NTAPI
FwpmLayerEnum0(
   IN HANDLE engineHandle,
   IN HANDLE enumHandle,
   IN UINT32 numEntriesRequested,
   OUT FWPM_LAYER0*** entries,
   OUT UINT32* numEntriesReturned
   );

NTSTATUS
NTAPI
FwpmLayerDestroyEnumHandle0(
   IN HANDLE engineHandle,
   IN HANDLE enumHandle
   );

NTSTATUS
NTAPI
FwpmLayerGetSecurityInfoByKey0(
   IN HANDLE engineHandle,
   IN OPTIONAL const GUID* key,
   IN SECURITY_INFORMATION securityInfo,
   OUT OPTIONAL PSID* sidOwner,
   OUT OPTIONAL PSID* sidGroup,
   OUT OPTIONAL PACL* dacl,
   OUT OPTIONAL PACL* sacl,
   OUT PSECURITY_DESCRIPTOR* securityDescriptor
   );

NTSTATUS
NTAPI
FwpmLayerSetSecurityInfoByKey0(
   IN HANDLE engineHandle,
   IN OPTIONAL const GUID* key,
   IN SECURITY_INFORMATION securityInfo,
   IN OPTIONAL const SID* sidOwner,
   IN OPTIONAL const SID* sidGroup,
   IN OPTIONAL const ACL* dacl,
   IN OPTIONAL const ACL* sacl
   );


///////////////////////////////////////////////////////////////////////////////
//
// Functions for managing callouts.
//
///////////////////////////////////////////////////////////////////////////////

NTSTATUS
NTAPI
FwpmCalloutAdd0(
   IN HANDLE engineHandle,
   IN const FWPM_CALLOUT0* callout,
   IN OPTIONAL PSECURITY_DESCRIPTOR sd,
   OUT OPTIONAL UINT32* id
   );

NTSTATUS
NTAPI
FwpmCalloutDeleteById0(
   IN HANDLE engineHandle,
   IN UINT32 id
   );

NTSTATUS
NTAPI
FwpmCalloutDeleteByKey0(
   IN HANDLE engineHandle,
   IN const GUID* key
   );

NTSTATUS
NTAPI
FwpmCalloutGetById0(
   HANDLE engineHandle,
   IN UINT32 id,
   OUT FWPM_CALLOUT0** callout
   );

NTSTATUS
NTAPI
FwpmCalloutGetByKey0(
   IN HANDLE engineHandle,
   IN const GUID* key,
   OUT FWPM_CALLOUT0** callout
   );

NTSTATUS
NTAPI
FwpmCalloutCreateEnumHandle0(
   IN HANDLE engineHandle,
   IN OPTIONAL const FWPM_CALLOUT_ENUM_TEMPLATE0* enumTemplate,
   OUT HANDLE* enumHandle
   );

NTSTATUS
NTAPI
FwpmCalloutEnum0(
   IN HANDLE engineHandle,
   IN HANDLE enumHandle,
   IN UINT32 numEntriesRequested,
   OUT FWPM_CALLOUT0*** entries,
   OUT UINT32* numEntriesReturned
   );

NTSTATUS
NTAPI
FwpmCalloutDestroyEnumHandle0(
   IN HANDLE engineHandle,
   IN HANDLE enumHandle
   );

NTSTATUS
NTAPI
FwpmCalloutGetSecurityInfoByKey0(
   IN HANDLE engineHandle,
   IN OPTIONAL const GUID* key,
   IN SECURITY_INFORMATION securityInfo,
   OUT OPTIONAL PSID* sidOwner,
   OUT OPTIONAL PSID* sidGroup,
   OUT OPTIONAL PACL* dacl,
   OUT OPTIONAL PACL* sacl,
   OUT PSECURITY_DESCRIPTOR* securityDescriptor
   );

NTSTATUS
NTAPI
FwpmCalloutSetSecurityInfoByKey0(
   IN HANDLE engineHandle,
   IN OPTIONAL const GUID* key,
   IN SECURITY_INFORMATION securityInfo,
   IN OPTIONAL const SID* sidOwner,
   IN OPTIONAL const SID* sidGroup,
   IN OPTIONAL const ACL* dacl,
   IN OPTIONAL const ACL* sacl
   );


///////////////////////////////////////////////////////////////////////////////
//
// Functions for managing filters.
//
///////////////////////////////////////////////////////////////////////////////

NTSTATUS
NTAPI
FwpmFilterAdd0(
   IN HANDLE engineHandle,
   IN const FWPM_FILTER0* filter,
   IN OPTIONAL PSECURITY_DESCRIPTOR sd,
   OUT OPTIONAL UINT64* id
   );

NTSTATUS
NTAPI
FwpmFilterDeleteById0(
   IN HANDLE engineHandle,
   IN UINT64 id
   );

NTSTATUS
NTAPI
FwpmFilterDeleteByKey0(
   IN HANDLE engineHandle,
   IN const GUID* key
   );

NTSTATUS
NTAPI
FwpmFilterGetById0(
   HANDLE engineHandle,
   IN UINT64 id,
   OUT FWPM_FILTER0** filter
   );

NTSTATUS
NTAPI
FwpmFilterGetByKey0(
   IN HANDLE engineHandle,
   IN const GUID* key,
   OUT FWPM_FILTER0** filter
   );

NTSTATUS
NTAPI
FwpmFilterCreateEnumHandle0(
   IN HANDLE engineHandle,
   IN OPTIONAL const FWPM_FILTER_ENUM_TEMPLATE0* enumTemplate,
   OUT HANDLE* enumHandle
   );

NTSTATUS
NTAPI
FwpmFilterEnum0(
   IN HANDLE engineHandle,
   IN HANDLE enumHandle,
   IN UINT32 numEntriesRequested,
   OUT FWPM_FILTER0*** entries,
   OUT UINT32* numEntriesReturned
   );

NTSTATUS
NTAPI
FwpmFilterDestroyEnumHandle0(
   IN HANDLE engineHandle,
   IN HANDLE enumHandle
   );

NTSTATUS
NTAPI
FwpmFilterGetSecurityInfoByKey0(
   IN HANDLE engineHandle,
   IN OPTIONAL const GUID* key,
   IN SECURITY_INFORMATION securityInfo,
   OUT OPTIONAL PSID* sidOwner,
   OUT OPTIONAL PSID* sidGroup,
   OUT OPTIONAL PACL* dacl,
   OUT OPTIONAL PACL* sacl,
   OUT PSECURITY_DESCRIPTOR* securityDescriptor
   );

NTSTATUS
NTAPI
FwpmFilterSetSecurityInfoByKey0(
   IN HANDLE engineHandle,
   IN OPTIONAL const GUID* key,
   IN SECURITY_INFORMATION securityInfo,
   IN OPTIONAL const SID* sidOwner,
   IN OPTIONAL const SID* sidGroup,
   IN OPTIONAL const ACL* dacl,
   IN OPTIONAL const ACL* sacl
   );


///////////////////////////////////////////////////////////////////////////////
//
// Helper functions for configuring an IPsec tunnel.
//
///////////////////////////////////////////////////////////////////////////////

// Create a point-to-point tunnel.
#define FWPM_TUNNEL_FLAG_POINT_TO_POINT (0x00000001)

NTSTATUS
NTAPI
FwpmIPsecTunnelAdd0(
   IN HANDLE engineHandle,
   IN UINT32 flags,
   IN OPTIONAL const FWPM_PROVIDER_CONTEXT0* mainModePolicy,
   IN const FWPM_PROVIDER_CONTEXT0* tunnelPolicy,
   IN UINT32 numFilterConditions,
   IN const FWPM_FILTER_CONDITION0* filterConditions,
   IN OPTIONAL PSECURITY_DESCRIPTOR sd
   );

NTSTATUS
NTAPI
FwpmIPsecTunnelDeleteByKey0(
   IN HANDLE engineHandle,
   IN const GUID* key
   );


///////////////////////////////////////////////////////////////////////////////
//
// Functions for managing IPsec.
//
///////////////////////////////////////////////////////////////////////////////

NTSTATUS
NTAPI
IPsecGetStatistics0(
   IN HANDLE engineHandle,
   OUT IPSEC_STATISTICS0* ipsecStatistics
   );

NTSTATUS
NTAPI
IPsecSaContextCreate0(
   IN HANDLE engineHandle,
   IN const IPSEC_TRAFFIC0* outboundTraffic,
   OUT OPTIONAL UINT64* inboundFilterId,
   OUT UINT64* id
   );

NTSTATUS
NTAPI
IPsecSaContextDeleteById0(
   IN HANDLE engineHandle,
   IN UINT64 id
   );

NTSTATUS
NTAPI
IPsecSaContextGetById0(
   HANDLE engineHandle,
   IN UINT64 id,
   OUT IPSEC_SA_CONTEXT0** saContext
   );

NTSTATUS
NTAPI
IPsecSaContextGetSpi0(
   IN HANDLE engineHandle,
   IN UINT64 id,
   IN const IPSEC_GETSPI0* getSpi,
   OUT IPSEC_SA_SPI* inboundSpi
   );

NTSTATUS
NTAPI
IPsecSaContextAddInbound0(
   IN HANDLE engineHandle,
   IN UINT64 id,
   IN const IPSEC_SA_BUNDLE0* inboundBundle
   );

NTSTATUS
NTAPI
IPsecSaContextAddOutbound0(
   IN HANDLE engineHandle,
   IN UINT64 id,
   IN const IPSEC_SA_BUNDLE0* outboundBundle
   );

NTSTATUS
NTAPI
IPsecSaContextExpire0(
   IN HANDLE engineHandle,
   IN UINT64 id
   );

NTSTATUS
NTAPI
IPsecSaContextCreateEnumHandle0(
   IN HANDLE engineHandle,
   IN OPTIONAL const IPSEC_SA_CONTEXT_ENUM_TEMPLATE0* enumTemplate,
   OUT HANDLE* enumHandle
   );

NTSTATUS
NTAPI
IPsecSaContextEnum0(
   IN HANDLE engineHandle,
   IN HANDLE enumHandle,
   IN UINT32 numEntriesRequested,
   OUT IPSEC_SA_CONTEXT0*** entries,
   OUT UINT32* numEntriesReturned
   );

NTSTATUS
NTAPI
IPsecSaContextDestroyEnumHandle0(
   IN HANDLE engineHandle,
   IN HANDLE enumHandle
   );

NTSTATUS
NTAPI
IPsecSaCreateEnumHandle0(
   IN HANDLE engineHandle,
   IN OPTIONAL const IPSEC_SA_ENUM_TEMPLATE0* enumTemplate,
   OUT HANDLE* enumHandle
   );

NTSTATUS
NTAPI
IPsecSaEnum0(
   IN HANDLE engineHandle,
   IN HANDLE enumHandle,
   IN UINT32 numEntriesRequested,
   OUT IPSEC_SA_DETAILS0*** entries,
   OUT UINT32* numEntriesReturned
   );

NTSTATUS
NTAPI
IPsecSaDestroyEnumHandle0(
   IN HANDLE engineHandle,
   IN HANDLE enumHandle
   );

NTSTATUS
NTAPI
IPsecSaDbGetSecurityInfo0(
   IN HANDLE engineHandle,
   IN SECURITY_INFORMATION securityInfo,
   OUT OPTIONAL PSID* sidOwner,
   OUT OPTIONAL PSID* sidGroup,
   OUT OPTIONAL PACL* dacl,
   OUT OPTIONAL PACL* sacl,
   OUT PSECURITY_DESCRIPTOR* securityDescriptor
   );

NTSTATUS
NTAPI
IPsecSaDbSetSecurityInfo0(
   IN HANDLE engineHandle,
   IN SECURITY_INFORMATION securityInfo,
   IN OPTIONAL const SID* sidOwner,
   IN OPTIONAL const SID* sidGroup,
   IN OPTIONAL const ACL* dacl,
   IN OPTIONAL const ACL* sacl
   );


///////////////////////////////////////////////////////////////////////////////
//
// Functions for managing IKE, Authip.
//
///////////////////////////////////////////////////////////////////////////////

NTSTATUS
NTAPI
IkeextGetStatistics0(
   IN HANDLE engineHandle,
   OUT IKEEXT_STATISTICS0* ikeextStatistics
   );

NTSTATUS
NTAPI
IkeextSaDeleteById0(
   IN HANDLE engineHandle,
   IN UINT64 id
   );

NTSTATUS
NTAPI
IkeextSaGetById0(
   HANDLE engineHandle,
   IN UINT64 id,
   OUT IKEEXT_SA_DETAILS0** sa
   );

NTSTATUS
NTAPI
IkeextSaCreateEnumHandle0(
   IN HANDLE engineHandle,
   IN OPTIONAL const IKEEXT_SA_ENUM_TEMPLATE0* enumTemplate,
   OUT HANDLE* enumHandle
   );

NTSTATUS
NTAPI
IkeextSaEnum0(
   IN HANDLE engineHandle,
   IN HANDLE enumHandle,
   IN UINT32 numEntriesRequested,
   OUT IKEEXT_SA_DETAILS0*** entries,
   OUT UINT32* numEntriesReturned
   );

NTSTATUS
NTAPI
IkeextSaDestroyEnumHandle0(
   IN HANDLE engineHandle,
   IN HANDLE enumHandle
   );

NTSTATUS
NTAPI
IkeextSaDbGetSecurityInfo0(
   IN HANDLE engineHandle,
   IN SECURITY_INFORMATION securityInfo,
   OUT OPTIONAL PSID* sidOwner,
   OUT OPTIONAL PSID* sidGroup,
   OUT OPTIONAL PACL* dacl,
   OUT OPTIONAL PACL* sacl,
   OUT PSECURITY_DESCRIPTOR* securityDescriptor
   );

NTSTATUS
NTAPI
IkeextSaDbSetSecurityInfo0(
   IN HANDLE engineHandle,
   IN SECURITY_INFORMATION securityInfo,
   IN OPTIONAL const SID* sidOwner,
   IN OPTIONAL const SID* sidGroup,
   IN OPTIONAL const ACL* dacl,
   IN OPTIONAL const ACL* sacl
   );

///////////////////////////////////////////////////////////////////////////////
//
// Functions for diagnostics.
//
///////////////////////////////////////////////////////////////////////////////

NTSTATUS
NTAPI
FwpmNetEventCreateEnumHandle0(
   IN HANDLE engineHandle,
   IN OPTIONAL const FWPM_NET_EVENT_ENUM_TEMPLATE0* enumTemplate,
   OUT HANDLE* enumHandle
   );

NTSTATUS
NTAPI
FwpmNetEventEnum0(
   IN HANDLE engineHandle,
   IN HANDLE enumHandle,
   IN UINT32 numEntriesRequested,
   OUT FWPM_NET_EVENT0*** entries,
   OUT UINT32* numEntriesReturned
   );

NTSTATUS
NTAPI
FwpmNetEventDestroyEnumHandle0(
   IN HANDLE engineHandle,
   IN HANDLE enumHandle
   );

NTSTATUS
NTAPI
FwpmNetEventsGetSecurityInfo0(
   IN HANDLE engineHandle,
   IN SECURITY_INFORMATION securityInfo,
   OUT OPTIONAL PSID* sidOwner,
   OUT OPTIONAL PSID* sidGroup,
   OUT OPTIONAL PACL* dacl,
   OUT OPTIONAL PACL* sacl,
   OUT PSECURITY_DESCRIPTOR* securityDescriptor
   );

NTSTATUS
NTAPI
FwpmNetEventsSetSecurityInfo0(
   IN HANDLE engineHandle,
   IN SECURITY_INFORMATION securityInfo,
   IN OPTIONAL const SID* sidOwner,
   IN OPTIONAL const SID* sidGroup,
   IN OPTIONAL const ACL* dacl,
   IN OPTIONAL const ACL* sacl
   );

#ifdef UNDER_CE
//New function added to support MIW/Ipsec for CE 7.0
NTSTATUS
NTAPI
BfeDisableWFPIPSec(
   IN HANDLE engineHandle
   );
#endif

#ifdef __cplusplus
}
#endif
#endif // FWPMX_H
#endif // GUID_DEFS_ONLY
#endif // (NTDDI_VERSION >= NTDDI_WIN6)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\fwpsu.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*
   Copyright (c) Microsoft Corporation

   SYNOPSIS

     Declares the system portion of the FWP API.
*/

#ifndef FWPSX_H
#define FWPSX_H
#if _MSC_VER >= 1020
#pragma once
#endif

#include "fwpstypes.h"
#include "ws2def.h"

#ifdef __cplusplus
extern "C" {
#endif

///////////////////////////////////////////////////////////////////////////////
//
// LUIDs for built-in layers.
//
///////////////////////////////////////////////////////////////////////////////

typedef enum FWPS_BUILTIN_LAYERS_
{
   // Kernel-mode layers
   FWPS_LAYER_INBOUND_IPPACKET_V4,
   FWPS_LAYER_INBOUND_IPPACKET_V4_DISCARD,
   FWPS_LAYER_INBOUND_IPPACKET_V6,
   FWPS_LAYER_INBOUND_IPPACKET_V6_DISCARD,
   FWPS_LAYER_OUTBOUND_IPPACKET_V4,
   FWPS_LAYER_OUTBOUND_IPPACKET_V4_DISCARD,
   FWPS_LAYER_OUTBOUND_IPPACKET_V6,
   FWPS_LAYER_OUTBOUND_IPPACKET_V6_DISCARD,
   FWPS_LAYER_IPFORWARD_V4,
   FWPS_LAYER_IPFORWARD_V4_DISCARD,
   FWPS_LAYER_IPFORWARD_V6,
   FWPS_LAYER_IPFORWARD_V6_DISCARD,
   FWPS_LAYER_INBOUND_TRANSPORT_V4,
   FWPS_LAYER_INBOUND_TRANSPORT_V4_DISCARD,
   FWPS_LAYER_INBOUND_TRANSPORT_V6,
   FWPS_LAYER_INBOUND_TRANSPORT_V6_DISCARD,
   FWPS_LAYER_OUTBOUND_TRANSPORT_V4,
   FWPS_LAYER_OUTBOUND_TRANSPORT_V4_DISCARD,
   FWPS_LAYER_OUTBOUND_TRANSPORT_V6,
   FWPS_LAYER_OUTBOUND_TRANSPORT_V6_DISCARD,
   FWPS_LAYER_STREAM_V4,
   FWPS_LAYER_STREAM_V4_DISCARD,
   FWPS_LAYER_STREAM_V6,
   FWPS_LAYER_STREAM_V6_DISCARD,
   FWPS_LAYER_DATAGRAM_DATA_V4,
   FWPS_LAYER_DATAGRAM_DATA_V4_DISCARD,
   FWPS_LAYER_DATAGRAM_DATA_V6,
   FWPS_LAYER_DATAGRAM_DATA_V6_DISCARD,
   FWPS_LAYER_INBOUND_ICMP_ERROR_V4,
   FWPS_LAYER_INBOUND_ICMP_ERROR_V4_DISCARD,
   FWPS_LAYER_INBOUND_ICMP_ERROR_V6,
   FWPS_LAYER_INBOUND_ICMP_ERROR_V6_DISCARD,
   FWPS_LAYER_OUTBOUND_ICMP_ERROR_V4,
   FWPS_LAYER_OUTBOUND_ICMP_ERROR_V4_DISCARD,
   FWPS_LAYER_OUTBOUND_ICMP_ERROR_V6,
   FWPS_LAYER_OUTBOUND_ICMP_ERROR_V6_DISCARD,
   FWPS_LAYER_ALE_RESOURCE_ASSIGNMENT_V4,
   FWPS_LAYER_ALE_RESOURCE_ASSIGNMENT_V4_DISCARD,
   FWPS_LAYER_ALE_RESOURCE_ASSIGNMENT_V6,
   FWPS_LAYER_ALE_RESOURCE_ASSIGNMENT_V6_DISCARD,
   FWPS_LAYER_ALE_AUTH_LISTEN_V4,
   FWPS_LAYER_ALE_AUTH_LISTEN_V4_DISCARD,
   FWPS_LAYER_ALE_AUTH_LISTEN_V6,
   FWPS_LAYER_ALE_AUTH_LISTEN_V6_DISCARD,
   FWPS_LAYER_ALE_AUTH_RECV_ACCEPT_V4,
   FWPS_LAYER_ALE_AUTH_RECV_ACCEPT_V4_DISCARD,
   FWPS_LAYER_ALE_AUTH_RECV_ACCEPT_V6,
   FWPS_LAYER_ALE_AUTH_RECV_ACCEPT_V6_DISCARD,
   FWPS_LAYER_ALE_AUTH_CONNECT_V4,
   FWPS_LAYER_ALE_AUTH_CONNECT_V4_DISCARD,
   FWPS_LAYER_ALE_AUTH_CONNECT_V6,
   FWPS_LAYER_ALE_AUTH_CONNECT_V6_DISCARD,
   FWPS_LAYER_ALE_FLOW_ESTABLISHED_V4,
   FWPS_LAYER_ALE_FLOW_ESTABLISHED_V4_DISCARD,
   FWPS_LAYER_ALE_FLOW_ESTABLISHED_V6,
   FWPS_LAYER_ALE_FLOW_ESTABLISHED_V6_DISCARD,

   // User-mode layers
   FWPS_LAYER_IPSEC_KM_DEMUX_V4,
   FWPS_LAYER_IPSEC_KM_DEMUX_V6,
   FWPS_LAYER_IPSEC_V4,
   FWPS_LAYER_IPSEC_V6,
   FWPS_LAYER_IKEEXT_V4,
   FWPS_LAYER_IKEEXT_V6,
#ifndef UNDER_CE
//Not supported in CE, commenting out to save on mem allocations
   FWPS_LAYER_RPC_UM,
   FWPS_LAYER_RPC_EPMAP,
   FWPS_LAYER_RPC_EP_ADD,
   FWPS_LAYER_RPC_PROXY_CONN,
   FWPS_LAYER_RPC_PROXY_IF,
#endif //UNDER_CE
   FWPS_BUILTIN_LAYER_MAX
} FWPS_BUILTIN_LAYERS;

#define FWPS_BUILTIN_KM_LAYER_MAX FWPS_LAYER_IPSEC_KM_DEMUX_V4

///////////////////////////////////////////////////////////////////////////////
//
// LUIDs for built-in fields.
//
///////////////////////////////////////////////////////////////////////////////

typedef enum FWPS_FIELDS_INBOUND_IPPACKET_V4_
{
   FWPS_FIELD_INBOUND_IPPACKET_V4_IP_LOCAL_ADDRESS,
   FWPS_FIELD_INBOUND_IPPACKET_V4_IP_REMOTE_ADDRESS,
   FWPS_FIELD_INBOUND_IPPACKET_V4_IP_LOCAL_ADDRESS_TYPE,
   FWPS_FIELD_INBOUND_IPPACKET_V4_IP_LOCAL_INTERFACE,
   FWPS_FIELD_INBOUND_IPPACKET_V4_INTERFACE_INDEX,
   FWPS_FIELD_INBOUND_IPPACKET_V4_SUB_INTERFACE_INDEX,
   FWPS_FIELD_INBOUND_IPPACKET_V4_FLAGS,
   FWPS_FIELD_INBOUND_IPPACKET_V4_INTERFACE_TYPE,
   FWPS_FIELD_INBOUND_IPPACKET_V4_TUNNEL_TYPE,
   FWPS_FIELD_INBOUND_IPPACKET_V4_MAX
} FWPS_FIELDS_INBOUND_IPPACKET_V4;

typedef enum FWPS_FIELDS_INBOUND_IPPACKET_V6_
{
   FWPS_FIELD_INBOUND_IPPACKET_V6_IP_LOCAL_ADDRESS,
   FWPS_FIELD_INBOUND_IPPACKET_V6_IP_REMOTE_ADDRESS,
   FWPS_FIELD_INBOUND_IPPACKET_V6_IP_LOCAL_ADDRESS_TYPE,
   FWPS_FIELD_INBOUND_IPPACKET_V6_IP_LOCAL_INTERFACE,
   FWPS_FIELD_INBOUND_IPPACKET_V6_INTERFACE_INDEX,
   FWPS_FIELD_INBOUND_IPPACKET_V6_SUB_INTERFACE_INDEX,
   FWPS_FIELD_INBOUND_IPPACKET_V6_FLAGS,
   FWPS_FIELD_INBOUND_IPPACKET_V6_INTERFACE_TYPE,
   FWPS_FIELD_INBOUND_IPPACKET_V6_TUNNEL_TYPE,
   FWPS_FIELD_INBOUND_IPPACKET_V6_MAX
} FWPS_FIELDS_INBOUND_IPPACKET_V6;

typedef enum FWPS_FIELDS_OUTBOUND_IPPACKET_V4_
{
   FWPS_FIELD_OUTBOUND_IPPACKET_V4_IP_LOCAL_ADDRESS,
   FWPS_FIELD_OUTBOUND_IPPACKET_V4_IP_LOCAL_ADDRESS_TYPE,
   FWPS_FIELD_OUTBOUND_IPPACKET_V4_IP_REMOTE_ADDRESS,
   FWPS_FIELD_OUTBOUND_IPPACKET_V4_IP_LOCAL_INTERFACE,
   FWPS_FIELD_OUTBOUND_IPPACKET_V4_INTERFACE_INDEX,
   FWPS_FIELD_OUTBOUND_IPPACKET_V4_SUB_INTERFACE_INDEX,
   FWPS_FIELD_OUTBOUND_IPPACKET_V4_FLAGS,
   FWPS_FIELD_OUTBOUND_IPPACKET_V4_INTERFACE_TYPE,
   FWPS_FIELD_OUTBOUND_IPPACKET_V4_TUNNEL_TYPE,
   FWPS_FIELD_OUTBOUND_IPPACKET_V4_MAX
} FWPS_FIELDS_OUTBOUND_IPPACKET_V4;

typedef enum FWPS_FIELDS_OUTBOUND_IPPACKET_V6_
{
   FWPS_FIELD_OUTBOUND_IPPACKET_V6_IP_LOCAL_ADDRESS,
   FWPS_FIELD_OUTBOUND_IPPACKET_V6_IP_LOCAL_ADDRESS_TYPE,
   FWPS_FIELD_OUTBOUND_IPPACKET_V6_IP_REMOTE_ADDRESS,
   FWPS_FIELD_OUTBOUND_IPPACKET_V6_IP_LOCAL_INTERFACE,
   FWPS_FIELD_OUTBOUND_IPPACKET_V6_INTERFACE_INDEX,
   FWPS_FIELD_OUTBOUND_IPPACKET_V6_SUB_INTERFACE_INDEX,
   FWPS_FIELD_OUTBOUND_IPPACKET_V6_FLAGS,
   FWPS_FIELD_OUTBOUND_IPPACKET_V6_INTERFACE_TYPE,
   FWPS_FIELD_OUTBOUND_IPPACKET_V6_TUNNEL_TYPE,
   FWPS_FIELD_OUTBOUND_IPPACKET_V6_MAX
} FWPS_FIELDS_OUTBOUND_IPPACKET_V6;

typedef enum FWPS_FIELDS_IPFORWARD_V4_
{
   FWPS_FIELD_IPFORWARD_V4_IP_SOURCE_ADDRESS,
   FWPS_FIELD_IPFORWARD_V4_IP_DESTINATION_ADDRESS,
   FWPS_FIELD_IPFORWARD_V4_IP_DESTINATION_ADDRESS_TYPE,
   FWPS_FIELD_IPFORWARD_V4_IP_LOCAL_INTERFACE,
   FWPS_FIELD_IPFORWARD_V4_IP_FORWARD_INTERFACE,
   FWPS_FIELD_IPFORWARD_V4_SOURCE_INTERFACE_INDEX,
   FWPS_FIELD_IPFORWARD_V4_SOURCE_SUB_INTERFACE_INDEX,
   FWPS_FIELD_IPFORWARD_V4_DESTINATION_INTERFACE_INDEX,
   FWPS_FIELD_IPFORWARD_V4_DESTINATION_SUB_INTERFACE_INDEX,
   FWPS_FIELD_IPFORWARD_V4_FLAGS,
   FWPS_FIELD_IPFORWARD_V4_MAX
} FWPS_FIELDS_IPFORWARD_V4;

typedef enum FWPS_FIELDS_IPFORWARD_V6_
{
   FWPS_FIELD_IPFORWARD_V6_IP_SOURCE_ADDRESS,
   FWPS_FIELD_IPFORWARD_V6_IP_DESTINATION_ADDRESS,
   FWPS_FIELD_IPFORWARD_V6_IP_DESTINATION_ADDRESS_TYPE,
   FWPS_FIELD_IPFORWARD_V6_IP_LOCAL_INTERFACE,
   FWPS_FIELD_IPFORWARD_V6_IP_FORWARD_INTERFACE,
   FWPS_FIELD_IPFORWARD_V6_SOURCE_INTERFACE_INDEX,
   FWPS_FIELD_IPFORWARD_V6_SOURCE_SUB_INTERFACE_INDEX,
   FWPS_FIELD_IPFORWARD_V6_DESTINATION_INTERFACE_INDEX,
   FWPS_FIELD_IPFORWARD_V6_DESTINATION_SUB_INTERFACE_INDEX,
   FWPS_FIELD_IPFORWARD_V6_FLAGS,
   FWPS_FIELD_IPFORWARD_V6_MAX
} FWPS_FIELDS_IPFORWARD_V6;

typedef enum FWPS_FIELDS_INBOUND_TRANSPORT_V4_
{
   FWPS_FIELD_INBOUND_TRANSPORT_V4_IP_PROTOCOL,
   FWPS_FIELD_INBOUND_TRANSPORT_V4_IP_LOCAL_ADDRESS,
   FWPS_FIELD_INBOUND_TRANSPORT_V4_IP_REMOTE_ADDRESS,
   FWPS_FIELD_INBOUND_TRANSPORT_V4_IP_LOCAL_ADDRESS_TYPE,
   FWPS_FIELD_INBOUND_TRANSPORT_V4_IP_LOCAL_PORT,
   FWPS_FIELD_INBOUND_TRANSPORT_V4_IP_REMOTE_PORT,
   FWPS_FIELD_INBOUND_TRANSPORT_V4_IP_LOCAL_INTERFACE,
   FWPS_FIELD_INBOUND_TRANSPORT_V4_INTERFACE_INDEX,
   FWPS_FIELD_INBOUND_TRANSPORT_V4_SUB_INTERFACE_INDEX,
   FWPS_FIELD_INBOUND_TRANSPORT_V4_FLAGS,
   FWPS_FIELD_INBOUND_TRANSPORT_V4_INTERFACE_TYPE,
   FWPS_FIELD_INBOUND_TRANSPORT_V4_TUNNEL_TYPE,
   FWPS_FIELD_INBOUND_TRANSPORT_V4_MAX
} FWPS_FIELDS_INBOUND_TRANSPORT_V4;

#define FWPS_FIELD_INBOUND_TRANSPORT_V4_ICMP_TYPE \
        FWPS_FIELD_INBOUND_TRANSPORT_V4_IP_LOCAL_PORT

#define FWPS_FIELD_INBOUND_TRANSPORT_V4_ICMP_CODE \
        FWPS_FIELD_INBOUND_TRANSPORT_V4_IP_REMOTE_PORT

typedef enum FWPS_FIELDS_INBOUND_TRANSPORT_V6_
{
   FWPS_FIELD_INBOUND_TRANSPORT_V6_IP_PROTOCOL,
   FWPS_FIELD_INBOUND_TRANSPORT_V6_IP_LOCAL_ADDRESS,
   FWPS_FIELD_INBOUND_TRANSPORT_V6_IP_REMOTE_ADDRESS,
   FWPS_FIELD_INBOUND_TRANSPORT_V6_IP_LOCAL_ADDRESS_TYPE,
   FWPS_FIELD_INBOUND_TRANSPORT_V6_IP_LOCAL_PORT,
   FWPS_FIELD_INBOUND_TRANSPORT_V6_IP_REMOTE_PORT,
   FWPS_FIELD_INBOUND_TRANSPORT_V6_IP_LOCAL_INTERFACE,
   FWPS_FIELD_INBOUND_TRANSPORT_V6_INTERFACE_INDEX,
   FWPS_FIELD_INBOUND_TRANSPORT_V6_SUB_INTERFACE_INDEX,
   FWPS_FIELD_INBOUND_TRANSPORT_V6_FLAGS,
   FWPS_FIELD_INBOUND_TRANSPORT_V6_INTERFACE_TYPE,
   FWPS_FIELD_INBOUND_TRANSPORT_V6_TUNNEL_TYPE,
   FWPS_FIELD_INBOUND_TRANSPORT_V6_MAX
} FWPS_FIELDS_INBOUND_TRANSPORT_V6;

#define FWPS_FIELD_INBOUND_TRANSPORT_V6_ICMP_TYPE \
        FWPS_FIELD_INBOUND_TRANSPORT_V6_IP_LOCAL_PORT

#define FWPS_FIELD_INBOUND_TRANSPORT_V6_ICMP_CODE \
        FWPS_FIELD_INBOUND_TRANSPORT_V6_IP_REMOTE_PORT

typedef enum FWPS_FIELDS_OUTBOUND_TRANSPORT_V4_
{
   FWPS_FIELD_OUTBOUND_TRANSPORT_V4_IP_PROTOCOL,
   FWPS_FIELD_OUTBOUND_TRANSPORT_V4_IP_LOCAL_ADDRESS,
   FWPS_FIELD_OUTBOUND_TRANSPORT_V4_IP_LOCAL_ADDRESS_TYPE,
   FWPS_FIELD_OUTBOUND_TRANSPORT_V4_IP_REMOTE_ADDRESS,
   FWPS_FIELD_OUTBOUND_TRANSPORT_V4_IP_LOCAL_PORT,
   FWPS_FIELD_OUTBOUND_TRANSPORT_V4_IP_REMOTE_PORT,
   FWPS_FIELD_OUTBOUND_TRANSPORT_V4_IP_LOCAL_INTERFACE,
   FWPS_FIELD_OUTBOUND_TRANSPORT_V4_INTERFACE_INDEX,
   FWPS_FIELD_OUTBOUND_TRANSPORT_V4_SUB_INTERFACE_INDEX,
   FWPS_FIELD_OUTBOUND_TRANSPORT_V4_IP_DESTINATION_ADDRESS_TYPE,
   FWPS_FIELD_OUTBOUND_TRANSPORT_V4_FLAGS,
   FWPS_FIELD_OUTBOUND_TRANSPORT_V4_INTERFACE_TYPE,
   FWPS_FIELD_OUTBOUND_TRANSPORT_V4_TUNNEL_TYPE,
   FWPS_FIELD_OUTBOUND_TRANSPORT_V4_MAX
} FWPS_FIELDS_OUTBOUND_TRANSPORT_V4;

#define FWPS_FIELD_OUTBOUND_TRANSPORT_V4_ICMP_TYPE \
        FWPS_FIELD_OUTBOUND_TRANSPORT_V4_IP_LOCAL_PORT

#define FWPS_FIELD_OUTBOUND_TRANSPORT_V4_ICMP_CODE \
        FWPS_FIELD_OUTBOUND_TRANSPORT_V4_IP_REMOTE_PORT

typedef enum FWPS_FIELDS_OUTBOUND_TRANSPORT_V6_
{
   FWPS_FIELD_OUTBOUND_TRANSPORT_V6_IP_PROTOCOL,
   FWPS_FIELD_OUTBOUND_TRANSPORT_V6_IP_LOCAL_ADDRESS,
   FWPS_FIELD_OUTBOUND_TRANSPORT_V6_IP_LOCAL_ADDRESS_TYPE,
   FWPS_FIELD_OUTBOUND_TRANSPORT_V6_IP_REMOTE_ADDRESS,
   FWPS_FIELD_OUTBOUND_TRANSPORT_V6_IP_LOCAL_PORT,
   FWPS_FIELD_OUTBOUND_TRANSPORT_V6_IP_REMOTE_PORT,
   FWPS_FIELD_OUTBOUND_TRANSPORT_V6_IP_LOCAL_INTERFACE,
   FWPS_FIELD_OUTBOUND_TRANSPORT_V6_INTERFACE_INDEX,
   FWPS_FIELD_OUTBOUND_TRANSPORT_V6_SUB_INTERFACE_INDEX,
   FWPS_FIELD_OUTBOUND_TRANSPORT_V6_IP_DESTINATION_ADDRESS_TYPE,
   FWPS_FIELD_OUTBOUND_TRANSPORT_V6_FLAGS,
   FWPS_FIELD_OUTBOUND_TRANSPORT_V6_INTERFACE_TYPE,
   FWPS_FIELD_OUTBOUND_TRANSPORT_V6_TUNNEL_TYPE,
   FWPS_FIELD_OUTBOUND_TRANSPORT_V6_MAX
} FWPS_FIELDS_OUTBOUND_TRANSPORT_V6;

#define FWPS_FIELD_OUTBOUND_TRANSPORT_V6_ICMP_TYPE \
        FWPS_FIELD_OUTBOUND_TRANSPORT_V6_IP_LOCAL_PORT

#define FWPS_FIELD_OUTBOUND_TRANSPORT_V6_ICMP_CODE \
        FWPS_FIELD_OUTBOUND_TRANSPORT_V6_IP_REMOTE_PORT

typedef enum FWPS_FIELDS_STREAM_V4_
{
   FWPS_FIELD_STREAM_V4_IP_LOCAL_ADDRESS,
   FWPS_FIELD_STREAM_V4_IP_LOCAL_ADDRESS_TYPE,
   FWPS_FIELD_STREAM_V4_IP_REMOTE_ADDRESS,
   FWPS_FIELD_STREAM_V4_IP_LOCAL_PORT,
   FWPS_FIELD_STREAM_V4_IP_REMOTE_PORT,
   FWPS_FIELD_STREAM_V4_DIRECTION,
   FWPS_FIELD_STREAM_V4_MAX
} FWPS_FIELDS_STREAM_V4;

typedef enum FWPS_FIELDS_STREAM_V6_
{
   FWPS_FIELD_STREAM_V6_IP_LOCAL_ADDRESS,
   FWPS_FIELD_STREAM_V6_IP_LOCAL_ADDRESS_TYPE,
   FWPS_FIELD_STREAM_V6_IP_REMOTE_ADDRESS,
   FWPS_FIELD_STREAM_V6_IP_LOCAL_PORT,
   FWPS_FIELD_STREAM_V6_IP_REMOTE_PORT,
   FWPS_FIELD_STREAM_V6_DIRECTION,
   FWPS_FIELD_STREAM_V6_MAX
} FWPS_FIELDS_STREAM_V6;

typedef enum FWPS_FIELDS_DATAGRAM_DATA_V4_
{
   FWPS_FIELD_DATAGRAM_DATA_V4_IP_PROTOCOL,
   FWPS_FIELD_DATAGRAM_DATA_V4_IP_LOCAL_ADDRESS,
   FWPS_FIELD_DATAGRAM_DATA_V4_IP_REMOTE_ADDRESS,
   FWPS_FIELD_DATAGRAM_DATA_V4_IP_LOCAL_ADDRESS_TYPE,
   FWPS_FIELD_DATAGRAM_DATA_V4_IP_LOCAL_PORT,
   FWPS_FIELD_DATAGRAM_DATA_V4_IP_REMOTE_PORT,
   FWPS_FIELD_DATAGRAM_DATA_V4_IP_LOCAL_INTERFACE,
   FWPS_FIELD_DATAGRAM_DATA_V4_INTERFACE_INDEX,
   FWPS_FIELD_DATAGRAM_DATA_V4_SUB_INTERFACE_INDEX,
   FWPS_FIELD_DATAGRAM_DATA_V4_DIRECTION,
   FWPS_FIELD_DATAGRAM_DATA_V4_FLAGS,
   FWPS_FIELD_DATAGRAM_DATA_V4_INTERFACE_TYPE,
   FWPS_FIELD_DATAGRAM_DATA_V4_TUNNEL_TYPE,
   FWPS_FIELD_DATAGRAM_DATA_V4_MAX
} FWPS_FIELDS_DATAGRAM_DATA_V4;

#define FWPS_FIELD_DATAGRAM_DATA_V4_ICMP_TYPE \
        FWPS_FIELD_DATAGRAM_DATA_V4_IP_LOCAL_PORT

#define FWPS_FIELD_DATAGRAM_DATA_V4_ICMP_CODE \
        FWPS_FIELD_DATAGRAM_DATA_V4_IP_REMOTE_PORT


typedef enum FWPS_FIELDS_DATAGRAM_DATA_V6_
{
   FWPS_FIELD_DATAGRAM_DATA_V6_IP_PROTOCOL,
   FWPS_FIELD_DATAGRAM_DATA_V6_IP_LOCAL_ADDRESS,
   FWPS_FIELD_DATAGRAM_DATA_V6_IP_REMOTE_ADDRESS,
   FWPS_FIELD_DATAGRAM_DATA_V6_IP_LOCAL_ADDRESS_TYPE,
   FWPS_FIELD_DATAGRAM_DATA_V6_IP_LOCAL_PORT,
   FWPS_FIELD_DATAGRAM_DATA_V6_IP_REMOTE_PORT,
   FWPS_FIELD_DATAGRAM_DATA_V6_IP_LOCAL_INTERFACE,
   FWPS_FIELD_DATAGRAM_DATA_V6_INTERFACE_INDEX,
   FWPS_FIELD_DATAGRAM_DATA_V6_SUB_INTERFACE_INDEX,
   FWPS_FIELD_DATAGRAM_DATA_V6_DIRECTION,
   FWPS_FIELD_DATAGRAM_DATA_V6_FLAGS,
   FWPS_FIELD_DATAGRAM_DATA_V6_INTERFACE_TYPE,
   FWPS_FIELD_DATAGRAM_DATA_V6_TUNNEL_TYPE,
   FWPS_FIELD_DATAGRAM_DATA_V6_MAX
} FWPS_FIELDS_DATAGRAM_DATA_V6;

#define FWPS_FIELD_DATAGRAM_DATA_V6_ICMP_TYPE \
        FWPS_FIELD_DATAGRAM_DATA_V6_IP_LOCAL_PORT

#define FWPS_FIELD_DATAGRAM_DATA_V6_ICMP_CODE \
        FWPS_FIELD_DATAGRAM_DATA_V6_IP_REMOTE_PORT

typedef enum FWPS_FIELDS_INBOUND_ICMP_ERROR_V4_
{
   FWPS_FIELD_INBOUND_ICMP_ERROR_V4_EMBEDDED_PROTOCOL,
   FWPS_FIELD_INBOUND_ICMP_ERROR_V4_IP_LOCAL_ADDRESS,
   FWPS_FIELD_INBOUND_ICMP_ERROR_V4_IP_REMOTE_ADDRESS,
   FWPS_FIELD_INBOUND_ICMP_ERROR_V4_EMBEDDED_REMOTE_ADDRESS,
   FWPS_FIELD_INBOUND_ICMP_ERROR_V4_EMBEDDED_LOCAL_ADDRESS_TYPE,
   FWPS_FIELD_INBOUND_ICMP_ERROR_V4_EMBEDDED_LOCAL_PORT,
   FWPS_FIELD_INBOUND_ICMP_ERROR_V4_EMBEDDED_REMOTE_PORT,
   FWPS_FIELD_INBOUND_ICMP_ERROR_V4_IP_LOCAL_INTERFACE,
   FWPS_FIELD_INBOUND_ICMP_ERROR_V4_ICMP_TYPE,
   FWPS_FIELD_INBOUND_ICMP_ERROR_V4_ICMP_CODE,
   FWPS_FIELD_INBOUND_ICMP_ERROR_V4_INTERFACE_INDEX,
   FWPS_FIELD_INBOUND_ICMP_ERROR_V4_SUB_INTERFACE_INDEX,
   FWPS_FIELD_INBOUND_ICMP_ERROR_V4_INTERFACE_TYPE,
   FWPS_FIELD_INBOUND_ICMP_ERROR_V4_TUNNEL_TYPE,
   FWPS_FIELD_INBOUND_ICMP_ERROR_V4_MAX
} FWPS_FIELDS_INBOUND_ICMP_ERROR_V4;

typedef enum FWPS_FIELDS_INBOUND_ICMP_ERROR_V6_
{
   FWPS_FIELD_INBOUND_ICMP_ERROR_V6_EMBEDDED_PROTOCOL,
   FWPS_FIELD_INBOUND_ICMP_ERROR_V6_IP_LOCAL_ADDRESS,
   FWPS_FIELD_INBOUND_ICMP_ERROR_V6_IP_REMOTE_ADDRESS,
   FWPS_FIELD_INBOUND_ICMP_ERROR_V6_EMBEDDED_REMOTE_ADDRESS,
   FWPS_FIELD_INBOUND_ICMP_ERROR_V6_EMBEDDED_LOCAL_ADDRESS_TYPE,
   FWPS_FIELD_INBOUND_ICMP_ERROR_V6_EMBEDDED_LOCAL_PORT,
   FWPS_FIELD_INBOUND_ICMP_ERROR_V6_EMBEDDED_REMOTE_PORT,
   FWPS_FIELD_INBOUND_ICMP_ERROR_V6_IP_LOCAL_INTERFACE,
   FWPS_FIELD_INBOUND_ICMP_ERROR_V6_ICMP_TYPE,
   FWPS_FIELD_INBOUND_ICMP_ERROR_V6_ICMP_CODE,
   FWPS_FIELD_INBOUND_ICMP_ERROR_V6_INTERFACE_INDEX,
   FWPS_FIELD_INBOUND_ICMP_ERROR_V6_SUB_INTERFACE_INDEX,
   FWPS_FIELD_INBOUND_ICMP_ERROR_V6_INTERFACE_TYPE,
   FWPS_FIELD_INBOUND_ICMP_ERROR_V6_TUNNEL_TYPE,
   FWPS_FIELD_INBOUND_ICMP_ERROR_V6_MAX
} FWPS_FIELDS_INBOUND_ICMP_ERROR_V6;

typedef enum FWPS_FIELDS_OUTBOUND_ICMP_ERROR_V4_
{
   FWPS_FIELD_OUTBOUND_ICMP_ERROR_V4_IP_LOCAL_ADDRESS,
   FWPS_FIELD_OUTBOUND_ICMP_ERROR_V4_IP_REMOTE_ADDRESS,
   FWPS_FIELD_OUTBOUND_ICMP_ERROR_V4_IP_LOCAL_ADDRESS_TYPE,
   FWPS_FIELD_OUTBOUND_ICMP_ERROR_V4_IP_LOCAL_INTERFACE,
   FWPS_FIELD_OUTBOUND_ICMP_ERROR_V4_ICMP_TYPE,
   FWPS_FIELD_OUTBOUND_ICMP_ERROR_V4_ICMP_CODE,
   FWPS_FIELD_OUTBOUND_ICMP_ERROR_V4_INTERFACE_INDEX,
   FWPS_FIELD_OUTBOUND_ICMP_ERROR_V4_SUB_INTERFACE_INDEX,
   FWPS_FIELD_OUTBOUND_ICMP_ERROR_V4_INTERFACE_TYPE,
   FWPS_FIELD_OUTBOUND_ICMP_ERROR_V4_TUNNEL_TYPE,
   FWPS_FIELD_OUTBOUND_ICMP_ERROR_V4_MAX
} FWPS_FIELDS_OUTBOUND_ICMP_ERROR_V4;

typedef enum FWPS_FIELDS_OUTBOUND_ICMP_ERROR_V6_
{
   FWPS_FIELD_OUTBOUND_ICMP_ERROR_V6_IP_LOCAL_ADDRESS,
   FWPS_FIELD_OUTBOUND_ICMP_ERROR_V6_IP_REMOTE_ADDRESS,
   FWPS_FIELD_OUTBOUND_ICMP_ERROR_V6_IP_LOCAL_ADDRESS_TYPE,
   FWPS_FIELD_OUTBOUND_ICMP_ERROR_V6_IP_LOCAL_INTERFACE,
   FWPS_FIELD_OUTBOUND_ICMP_ERROR_V6_IP_LOCAL_PORT,
   FWPS_FIELD_OUTBOUND_ICMP_ERROR_V6_IP_REMOTE_PORT,
   FWPS_FIELD_OUTBOUND_ICMP_ERROR_V6_INTERFACE_INDEX,
   FWPS_FIELD_OUTBOUND_ICMP_ERROR_V6_SUB_INTERFACE_INDEX,
   FWPS_FIELD_OUTBOUND_ICMP_ERROR_V6_INTERFACE_TYPE,
   FWPS_FIELD_OUTBOUND_ICMP_ERROR_V6_TUNNEL_TYPE,
   FWPS_FIELD_OUTBOUND_ICMP_ERROR_V6_MAX
} FWPS_FIELDS_OUTBOUND_ICMP_ERROR_V6;

#define FWPS_FIELD_OUTBOUND_ICMP_ERROR_V6_ICMP_TYPE \
        FWPS_FIELD_OUTBOUND_ICMP_ERROR_V6_IP_LOCAL_PORT

#define FWPS_FIELD_OUTBOUND_ICMP_ERROR_V6_ICMP_CODE \
        FWPS_FIELD_OUTBOUND_ICMP_ERROR_V6_IP_REMOTE_PORT

typedef enum FWPS_FIELDS_ALE_RESOURCE_ASSIGNMENT_V4_
{
   FWPS_FIELD_ALE_RESOURCE_ASSIGNMENT_V4_ALE_APP_ID,
   FWPS_FIELD_ALE_RESOURCE_ASSIGNMENT_V4_ALE_USER_ID,
   FWPS_FIELD_ALE_RESOURCE_ASSIGNMENT_V4_IP_LOCAL_ADDRESS,
   FWPS_FIELD_ALE_RESOURCE_ASSIGNMENT_V4_IP_LOCAL_ADDRESS_TYPE,
   FWPS_FIELD_ALE_RESOURCE_ASSIGNMENT_V4_IP_LOCAL_PORT,
   FWPS_FIELD_ALE_RESOURCE_ASSIGNMENT_V4_IP_PROTOCOL,
   FWPS_FIELD_ALE_RESOURCE_ASSIGNMENT_V4_ALE_PROMISCUOUS_MODE,
   FWPS_FIELD_ALE_RESOURCE_ASSIGNMENT_V4_IP_LOCAL_INTERFACE,
   FWPS_FIELD_ALE_RESOURCE_ASSIGNMENT_V4_FLAGS,
   FWPS_FIELD_ALE_RESOURCE_ASSIGNMENT_V4_INTERFACE_TYPE,
   FWPS_FIELD_ALE_RESOURCE_ASSIGNMENT_V4_TUNNEL_TYPE,
   FWPS_FIELD_ALE_RESOURCE_ASSIGNMENT_V4_MAX
} FWPS_FIELDS_ALE_RESOURCE_ASSIGNMENT_V4;

typedef enum FWPS_FIELDS_ALE_RESOURCE_ASSIGNMENT_V6_
{
   FWPS_FIELD_ALE_RESOURCE_ASSIGNMENT_V6_ALE_APP_ID,
   FWPS_FIELD_ALE_RESOURCE_ASSIGNMENT_V6_ALE_USER_ID,
   FWPS_FIELD_ALE_RESOURCE_ASSIGNMENT_V6_IP_LOCAL_ADDRESS,
   FWPS_FIELD_ALE_RESOURCE_ASSIGNMENT_V6_IP_LOCAL_ADDRESS_TYPE,
   FWPS_FIELD_ALE_RESOURCE_ASSIGNMENT_V6_IP_LOCAL_PORT,
   FWPS_FIELD_ALE_RESOURCE_ASSIGNMENT_V6_IP_PROTOCOL,
   FWPS_FIELD_ALE_RESOURCE_ASSIGNMENT_V6_ALE_PROMISCUOUS_MODE,
   FWPS_FIELD_ALE_RESOURCE_ASSIGNMENT_V6_IP_LOCAL_INTERFACE,
   FWPS_FIELD_ALE_RESOURCE_ASSIGNMENT_V6_FLAGS,
   FWPS_FIELD_ALE_RESOURCE_ASSIGNMENT_V6_INTERFACE_TYPE,
   FWPS_FIELD_ALE_RESOURCE_ASSIGNMENT_V6_TUNNEL_TYPE,
   FWPS_FIELD_ALE_RESOURCE_ASSIGNMENT_V6_MAX
} FWPS_FIELDS_ALE_RESOURCE_ASSIGNMENT_V6;

typedef enum FWPS_FIELDS_ALE_AUTH_LISTEN_V4_
{
   FWPS_FIELD_ALE_AUTH_LISTEN_V4_ALE_APP_ID,
   FWPS_FIELD_ALE_AUTH_LISTEN_V4_ALE_USER_ID,
   FWPS_FIELD_ALE_AUTH_LISTEN_V4_IP_LOCAL_ADDRESS,
   FWPS_FIELD_ALE_AUTH_LISTEN_V4_IP_LOCAL_ADDRESS_TYPE,
   FWPS_FIELD_ALE_AUTH_LISTEN_V4_IP_LOCAL_PORT,
   FWPS_FIELD_ALE_AUTH_LISTEN_V4_IP_LOCAL_INTERFACE,
   FWPS_FIELD_ALE_AUTH_LISTEN_V4_FLAGS,
   FWPS_FIELD_ALE_AUTH_LISTEN_V4_INTERFACE_TYPE,
   FWPS_FIELD_ALE_AUTH_LISTEN_V4_TUNNEL_TYPE,
   FWPS_FIELD_ALE_AUTH_LISTEN_V4_MAX
} FWPS_FIELDS_ALE_AUTH_LISTEN_V4;

typedef enum FWPS_FIELDS_ALE_AUTH_LISTEN_V6_
{
   FWPS_FIELD_ALE_AUTH_LISTEN_V6_ALE_APP_ID,
   FWPS_FIELD_ALE_AUTH_LISTEN_V6_ALE_USER_ID,
   FWPS_FIELD_ALE_AUTH_LISTEN_V6_IP_LOCAL_ADDRESS,
   FWPS_FIELD_ALE_AUTH_LISTEN_V6_IP_LOCAL_ADDRESS_TYPE,
   FWPS_FIELD_ALE_AUTH_LISTEN_V6_IP_LOCAL_PORT,
   FWPS_FIELD_ALE_AUTH_LISTEN_V6_IP_LOCAL_INTERFACE,
   FWPS_FIELD_ALE_AUTH_LISTEN_V6_FLAGS,
   FWPS_FIELD_ALE_AUTH_LISTEN_V6_INTERFACE_TYPE,
   FWPS_FIELD_ALE_AUTH_LISTEN_V6_TUNNEL_TYPE,
   FWPS_FIELD_ALE_AUTH_LISTEN_V6_MAX
} FWPS_FIELDS_ALE_AUTH_LISTEN_V6;

typedef enum FWPS_FIELDS_ALE_AUTH_RECV_ACCEPT_V4_
{
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_ALE_APP_ID,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_ALE_USER_ID,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_IP_LOCAL_ADDRESS,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_IP_LOCAL_ADDRESS_TYPE,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_IP_LOCAL_PORT,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_IP_PROTOCOL,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_IP_REMOTE_ADDRESS,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_IP_REMOTE_PORT,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_ALE_REMOTE_USER_ID,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_ALE_REMOTE_MACHINE_ID,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_IP_LOCAL_INTERFACE,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_FLAGS,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_SIO_FIREWALL_SYSTEM_PORT,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_NAP_CONTEXT,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_INTERFACE_TYPE,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_TUNNEL_TYPE,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_INTERFACE_INDEX,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_SUB_INTERFACE_INDEX,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_MAX
} FWPS_FIELDS_ALE_AUTH_RECV_ACCEPT_V4;

#define FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_ICMP_TYPE \
        FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_IP_LOCAL_PORT

#define FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_ICMP_CODE \
        FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_IP_REMOTE_PORT

typedef enum FWPS_FIELDS_ALE_AUTH_RECV_ACCEPT_V6_
{
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_ALE_APP_ID,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_ALE_USER_ID,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_IP_LOCAL_ADDRESS,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_IP_LOCAL_ADDRESS_TYPE,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_IP_LOCAL_PORT,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_IP_PROTOCOL,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_IP_REMOTE_ADDRESS,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_IP_REMOTE_PORT,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_ALE_REMOTE_USER_ID,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_ALE_REMOTE_MACHINE_ID,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_IP_LOCAL_INTERFACE,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_FLAGS,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_SIO_FIREWALL_SYSTEM_PORT,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_NAP_CONTEXT,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_INTERFACE_TYPE,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_TUNNEL_TYPE,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_INTERFACE_INDEX,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_SUB_INTERFACE_INDEX,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_MAX
} FWPS_FIELDS_ALE_AUTH_RECV_ACCEPT_V6;

#define FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_ICMP_TYPE \
        FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_IP_LOCAL_PORT

#define FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_ICMP_CODE \
        FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_IP_REMOTE_PORT

typedef enum FWPS_FIELDS_ALE_AUTH_CONNECT_V4_
{
   FWPS_FIELD_ALE_AUTH_CONNECT_V4_ALE_APP_ID,
   FWPS_FIELD_ALE_AUTH_CONNECT_V4_ALE_USER_ID,
   FWPS_FIELD_ALE_AUTH_CONNECT_V4_IP_LOCAL_ADDRESS,
   FWPS_FIELD_ALE_AUTH_CONNECT_V4_IP_LOCAL_ADDRESS_TYPE,
   FWPS_FIELD_ALE_AUTH_CONNECT_V4_IP_LOCAL_PORT,
   FWPS_FIELD_ALE_AUTH_CONNECT_V4_IP_PROTOCOL,
   FWPS_FIELD_ALE_AUTH_CONNECT_V4_IP_REMOTE_ADDRESS,
   FWPS_FIELD_ALE_AUTH_CONNECT_V4_IP_REMOTE_PORT,
   FWPS_FIELD_ALE_AUTH_CONNECT_V4_ALE_REMOTE_USER_ID,
   FWPS_FIELD_ALE_AUTH_CONNECT_V4_ALE_REMOTE_MACHINE_ID,
   FWPS_FIELD_ALE_AUTH_CONNECT_V4_IP_DESTINATION_ADDRESS_TYPE,
   FWPS_FIELD_ALE_AUTH_CONNECT_V4_IP_LOCAL_INTERFACE,
   FWPS_FIELD_ALE_AUTH_CONNECT_V4_FLAGS,
   FWPS_FIELD_ALE_AUTH_CONNECT_V4_INTERFACE_TYPE,
   FWPS_FIELD_ALE_AUTH_CONNECT_V4_TUNNEL_TYPE,
   FWPS_FIELD_ALE_AUTH_CONNECT_V4_MAX
} FWPS_FIELDS_ALE_AUTH_CONNECT_V4;

#define FWPS_FIELD_ALE_AUTH_CONNECT_V4_ICMP_TYPE \
        FWPS_FIELD_ALE_AUTH_CONNECT_V4_IP_LOCAL_PORT

#define FWPS_FIELD_ALE_AUTH_CONNECT_V4_ICMP_CODE \
        FWPS_FIELD_ALE_AUTH_CONNECT_V4_IP_REMOTE_PORT

typedef enum FWPS_FIELDS_ALE_AUTH_CONNECT_V6_
{
   FWPS_FIELD_ALE_AUTH_CONNECT_V6_ALE_APP_ID,
   FWPS_FIELD_ALE_AUTH_CONNECT_V6_ALE_USER_ID,
   FWPS_FIELD_ALE_AUTH_CONNECT_V6_IP_LOCAL_ADDRESS,
   FWPS_FIELD_ALE_AUTH_CONNECT_V6_IP_LOCAL_ADDRESS_TYPE,
   FWPS_FIELD_ALE_AUTH_CONNECT_V6_IP_LOCAL_PORT,
   FWPS_FIELD_ALE_AUTH_CONNECT_V6_IP_PROTOCOL,
   FWPS_FIELD_ALE_AUTH_CONNECT_V6_IP_REMOTE_ADDRESS,
   FWPS_FIELD_ALE_AUTH_CONNECT_V6_IP_REMOTE_PORT,
   FWPS_FIELD_ALE_AUTH_CONNECT_V6_ALE_REMOTE_USER_ID,
   FWPS_FIELD_ALE_AUTH_CONNECT_V6_ALE_REMOTE_MACHINE_ID,
   FWPS_FIELD_ALE_AUTH_CONNECT_V6_IP_DESTINATION_ADDRESS_TYPE,
   FWPS_FIELD_ALE_AUTH_CONNECT_V6_IP_LOCAL_INTERFACE,
   FWPS_FIELD_ALE_AUTH_CONNECT_V6_FLAGS,
   FWPS_FIELD_ALE_AUTH_CONNECT_V6_INTERFACE_TYPE,
   FWPS_FIELD_ALE_AUTH_CONNECT_V6_TUNNEL_TYPE,
   FWPS_FIELD_ALE_AUTH_CONNECT_V6_MAX
} FWPS_FIELDS_ALE_AUTH_CONNECT_V6;

#define FWPS_FIELD_ALE_AUTH_CONNECT_V6_ICMP_TYPE \
        FWPS_FIELD_ALE_AUTH_CONNECT_V6_IP_LOCAL_PORT

#define FWPS_FIELD_ALE_AUTH_CONNECT_V6_ICMP_CODE \
        FWPS_FIELD_ALE_AUTH_CONNECT_V6_IP_REMOTE_PORT

typedef enum FWPS_FIELDS_ALE_FLOW_ESTABLISHED_V4_
{
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V4_ALE_APP_ID,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V4_ALE_USER_ID,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V4_IP_LOCAL_ADDRESS,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V4_IP_LOCAL_ADDRESS_TYPE,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V4_IP_LOCAL_PORT,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V4_IP_PROTOCOL,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V4_IP_REMOTE_ADDRESS,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V4_IP_REMOTE_PORT,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V4_ALE_REMOTE_USER_ID,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V4_ALE_REMOTE_MACHINE_ID,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V4_IP_DESTINATION_ADDRESS_TYPE,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V4_IP_LOCAL_INTERFACE,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V4_DIRECTION,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V4_INTERFACE_TYPE,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V4_TUNNEL_TYPE,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V4_MAX
} FWPS_FIELDS_ALE_FLOW_ESTABLISHED_V4;

#define FWPS_FIELD_ALE_FLOW_ESTABLISHED_V4_ICMP_TYPE \
        FWPS_FIELD_ALE_FLOW_ESTABLISHED_V4_IP_LOCAL_PORT

#define FWPS_FIELD_ALE_FLOW_ESTABLISHED_V4_ICMP_CODE \
        FWPS_FIELD_ALE_FLOW_ESTABLISHED_V4_IP_REMOTE_PORT

typedef enum FWPS_FIELDS_ALE_FLOW_ESTABLISHED_V6_
{
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V6_ALE_APP_ID,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V6_ALE_USER_ID,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V6_IP_LOCAL_ADDRESS,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V6_IP_LOCAL_ADDRESS_TYPE,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V6_IP_LOCAL_PORT,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V6_IP_PROTOCOL,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V6_IP_REMOTE_ADDRESS,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V6_IP_REMOTE_PORT,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V6_ALE_REMOTE_USER_ID,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V6_ALE_REMOTE_MACHINE_ID,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V6_IP_DESTINATION_ADDRESS_TYPE,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V6_IP_LOCAL_INTERFACE,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V6_DIRECTION,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V6_INTERFACE_TYPE,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V6_TUNNEL_TYPE,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V6_MAX
} FWPS_FIELDS_ALE_FLOW_ESTABLISHED_V6;

#define FWPS_FIELD_ALE_FLOW_ESTABLISHED_V6_ICMP_TYPE \
        FWPS_FIELD_ALE_FLOW_ESTABLISHED_V6_IP_LOCAL_PORT

#define FWPS_FIELD_ALE_FLOW_ESTABLISHED_V6_ICMP_CODE \
        FWPS_FIELD_ALE_FLOW_ESTABLISHED_V6_IP_REMOTE_PORT

typedef enum FWPS_FIELDS_IPSEC_KM_DEMUX_V4_
{
   FWPS_FIELD_IPSEC_KM_DEMUX_V4_IP_LOCAL_ADDRESS,
   FWPS_FIELD_IPSEC_KM_DEMUX_V4_IP_REMOTE_ADDRESS,
   FWPS_FIELD_IPSEC_KM_DEMUX_V4_MAX
} FWPS_FIELDS_IPSEC_KM_DEMUX_V4;

typedef enum FWPS_FIELDS_IPSEC_KM_DEMUX_V6_
{
   FWPS_FIELD_IPSEC_KM_DEMUX_V6_IP_LOCAL_ADDRESS,
   FWPS_FIELD_IPSEC_KM_DEMUX_V6_IP_REMOTE_ADDRESS,
   FWPS_FIELD_IPSEC_KM_DEMUX_V6_MAX
} FWPS_FIELDS_IPSEC_KM_DEMUX_V6;

typedef enum FWPS_FIELDS_IPSEC_V4_
{
   FWPS_FIELD_IPSEC_V4_IP_PROTOCOL,
   FWPS_FIELD_IPSEC_V4_IP_LOCAL_ADDRESS,
   FWPS_FIELD_IPSEC_V4_IP_REMOTE_ADDRESS,
   FWPS_FIELD_IPSEC_V4_IP_LOCAL_PORT,
   FWPS_FIELD_IPSEC_V4_IP_REMOTE_PORT,
   FWPS_FIELD_IPSEC_V4_MAX
} FWPS_FIELDS_IPSEC_V4;

typedef enum FWPS_FIELDS_IPSEC_V6_
{
   FWPS_FIELD_IPSEC_V6_IP_PROTOCOL,
   FWPS_FIELD_IPSEC_V6_IP_LOCAL_ADDRESS,
   FWPS_FIELD_IPSEC_V6_IP_REMOTE_ADDRESS,
   FWPS_FIELD_IPSEC_V6_IP_LOCAL_PORT,
   FWPS_FIELD_IPSEC_V6_IP_REMOTE_PORT,
   FWPS_FIELD_IPSEC_V6_MAX
} FWPS_FIELDS_IPSEC_V6;

typedef enum FWPS_FIELDS_IKEEXT_V4_
{
   FWPS_FIELD_IKEEXT_V4_IP_LOCAL_ADDRESS,
   FWPS_FIELD_IKEEXT_V4_IP_REMOTE_ADDRESS,
   FWPS_FIELD_IKEEXT_V4_MAX
} FWPS_FIELDS_IKEEXT_V4;

typedef enum FWPS_FIELDS_IKEEXT_V6_
{
   FWPS_FIELD_IKEEXT_V6_IP_LOCAL_ADDRESS,
   FWPS_FIELD_IKEEXT_V6_IP_REMOTE_ADDRESS,
   FWPS_FIELD_IKEEXT_V6_MAX
} FWPS_FIELDS_IKEEXT_V6;

#ifndef UNDER_CE
typedef enum FWPS_FIELDS_RPC_UM_
{
   FWPS_FIELD_RPC_UM_REMOTE_USER_TOKEN,
   FWPS_FIELD_RPC_UM_IF_UUID,
   FWPS_FIELD_RPC_UM_IF_VERSION,
   FWPS_FIELD_RPC_UM_IF_FLAG,
   FWPS_FIELD_RPC_UM_DCOM_APP_ID,
   FWPS_FIELD_RPC_UM_IMAGE_NAME,
   FWPS_FIELD_RPC_UM_PROTOCOL,
   FWPS_FIELD_RPC_UM_AUTH_TYPE,
   FWPS_FIELD_RPC_UM_AUTH_LEVEL,
   FWPS_FIELD_RPC_UM_SEC_ENCRYPT_ALGORITHM,
   FWPS_FIELD_RPC_UM_SEC_KEY_SIZE,
   FWPS_FIELD_RPC_UM_LOCAL_ADDR_V4,
   FWPS_FIELD_RPC_UM_LOCAL_ADDR_V6,
   FWPS_FIELD_RPC_UM_LOCAL_PORT,
   FWPS_FIELD_RPC_UM_PIPE,
   FWPS_FIELD_RPC_UM_REMOTE_ADDR_V4,
   FWPS_FIELD_RPC_UM_REMOTE_ADDR_V6,
   FWPS_FIELD_RPC_UM_MAX
} FWPS_FIELDS_RPC_UM;

typedef enum FWPS_FIELDS_RPC_EPMAP_
{
   FWPS_FIELD_RPC_EPMAP_REMOTE_USER_TOKEN,
   FWPS_FIELD_RPC_EPMAP_IF_UUID,
   FWPS_FIELD_RPC_EPMAP_IF_VERSION,
   FWPS_FIELD_RPC_EPMAP_PROTOCOL,
   FWPS_FIELD_RPC_EPMAP_AUTH_TYPE,
   FWPS_FIELD_RPC_EPMAP_AUTH_LEVEL,
   FWPS_FIELD_RPC_EPMAP_SEC_ENCRYPT_ALGORITHM,
   FWPS_FIELD_RPC_EPMAP_SEC_KEY_SIZE,
   FWPS_FIELD_RPC_EPMAP_LOCAL_ADDR_V4,
   FWPS_FIELD_RPC_EPMAP_LOCAL_ADDR_V6,
   FWPS_FIELD_RPC_EPMAP_LOCAL_PORT,
   FWPS_FIELD_RPC_EPMAP_PIPE,
   FWPS_FIELD_RPC_EPMAP_REMOTE_ADDR_V4,
   FWPS_FIELD_RPC_EPMAP_REMOTE_ADDR_V6,
   FWPS_FIELD_RPC_EPMAP_MAX
} FWPS_FIELDS_RPC_EPMAP;

typedef enum FWPS_FIELDS_RPC_EP_ADD_
{
   FWPS_FIELD_RPC_EP_ADD_PROCESS_WITH_RPC_IF_UUID,
   FWPS_FIELD_RPC_EP_ADD_PROTOCOL,
   FWPS_FIELD_RPC_EP_ADD_EP_VALUE,
   FWPS_FIELD_RPC_EP_ADD_EP_FLAGS,
   FWPS_FIELD_RPC_EP_ADD_MAX
} FWPS_FIELDS_RPC_EP_ADD;

typedef enum FWPS_FIELDS_RPC_PROXY_CONN_
{
   FWPS_FIELD_RPC_PROXY_CONN_CLIENT_TOKEN,
   FWPS_FIELD_RPC_PROXY_CONN_SERVER_NAME,
   FWPS_FIELD_RPC_PROXY_CONN_SERVER_PORT,
   FWPS_FIELD_RPC_PROXY_CONN_PROXY_AUTH_TYPE,
   FWPS_FIELD_RPC_PROXY_CONN_CLIENT_CERT_KEY_LENGTH,
   FWPS_FIELD_RPC_PROXY_CONN_CLIENT_CERT_OID,
   FWPS_FIELD_RPC_PROXY_CONN_MAX
} FWPS_FIELDS_RPC_PROXY_CONN;

typedef enum FWPS_FIELDS_RPC_PROXY_IF_
{
   FWPS_FIELD_RPC_PROXY_IF_CLIENT_TOKEN,
   FWPS_FIELD_RPC_PROXY_IF_IF_UUID,
   FWPS_FIELD_RPC_PROXY_IF_IF_VERSION,
   FWPS_FIELD_RPC_PROXY_IF_SERVER_NAME,
   FWPS_FIELD_RPC_PROXY_IF_SERVER_PORT,
   FWPS_FIELD_RPC_PROXY_IF_PROXY_AUTH_TYPE,
   FWPS_FIELD_RPC_PROXY_IF_CLIENT_CERT_KEY_LENGTH,
   FWPS_FIELD_RPC_PROXY_IF_CLIENT_CERT_OID,
   FWPS_FIELD_RPC_PROXY_IF_MAX
} FWPS_FIELDS_RPC_PROXY_IF_IF;
#endif //UNDER_CE

#if (NTDDI_VERSION >= NTDDI_LONGHORN)

///////////////////////////////////////////////////////////////////////////////
//
// Network and transport discard reasons.
//
///////////////////////////////////////////////////////////////////////////////

//
// INET_DISCARD_REASON
//
// Define the reasons given by INET modules for discarding incoming datagrams.
//

#ifndef _INET_DISCARD_REASON_DEFINE_
#define _INET_DISCARD_REASON_DEFINE_

typedef enum {
    InetDiscardSourceUnspecified,
    InetDiscardDestinationMulticast,
    InetDiscardHeaderInvalid,
    InetDiscardChecksumInvalid,
    InetDiscardEndpointNotFound
} INET_DISCARD_REASON, *PINET_DISCARD_REASON;

#endif


#ifndef _IP_DISCARD_REASON_DEFINE_
#define _IP_DISCARD_REASON_DEFINE_

typedef enum {
    //
    // Receive path discard reasons.
    //
    IpDiscardBadSourceAddress = 1,
    IpDiscardNotLocallyDestined,
    IpDiscardProtocolUnreachable,
    IpDiscardPortUnreachable,
    IpDiscardBadLength,
    IpDiscardMalformedHeader,
    IpDiscardNoRoute,
    IpDiscardBeyondScope,
    IpDiscardInspectionDrop,
    IpDiscardTooManyDecapsulations,
    IpDiscardAdministrativelyProhibited,

    IpDiscardReceivePathMax = 127,

    //
    // Forward path discard reasons.
    //
    IpDiscardHopLimitExceeded,
    IpDiscardAddressUnreachable,
    IpDiscardForwardPathMax = 255,

    //
    // Internally used discard reasons.
    //
    IpDiscardArbitrationUnhandled,
    IpDiscardMax
} IP_DISCARD_REASON, *PIP_DISCARD_REASON;

#endif




///////////////////////////////////////////////////////////////////////////////
// 
// API for implementing a callout.
//
///////////////////////////////////////////////////////////////////////////////

//////////
// Flags that can specified which entries are present
// in the FWPS_INCOMING_METADATA_VALUES0 structure.
//////////

#define FWPS_METADATA_FIELD_DISCARD_REASON                   0x00000001
#define FWPS_METADATA_FIELD_FLOW_HANDLE                      0x00000002
#define FWPS_METADATA_FIELD_IP_HEADER_SIZE                   0x00000004
#define FWPS_METADATA_FIELD_PROCESS_PATH                     0x00000008
#define FWPS_METADATA_FIELD_TOKEN                            0x00000010
#define FWPS_METADATA_FIELD_PROCESS_ID                       0x00000020
#define FWPS_METADATA_FIELD_SYSTEM_FLAGS                     0x00000040
#define FWPS_METADATA_FIELD_RESERVED                         0x00000080
#define FWPS_METADATA_FIELD_SOURCE_INTERFACE_INDEX           0x00000100
#define FWPS_METADATA_FIELD_DESTINATION_INTERFACE_INDEX      0x00000200
#define FWPS_METADATA_FIELD_TRANSPORT_HEADER_SIZE            0x00000400
#define FWPS_METADATA_FIELD_COMPARTMENT_ID                   0x00000800
#define FWPS_METADATA_FIELD_FRAGMENT_DATA                    0x00001000
#define FWPS_METADATA_FIELD_PATH_MTU                         0x00002000
#define FWPS_METADATA_FIELD_COMPLETION_HANDLE                0x00004000
#define FWPS_METADATA_FIELD_TRANSPORT_ENDPOINT_HANDLE        0x00008000
#define FWPS_METADATA_FIELD_TRANSPORT_CONTROL_DATA           0x00010000
#define FWPS_METADATA_FIELD_REMOTE_SCOPE_ID                  0x00020000
#define FWPS_METADATA_FIELD_PACKET_DIRECTION                 0x00040000
#if (NTDDI_VERSION >= NTDDI_WIN6SP1)
#define FWPS_METADATA_FIELD_PACKET_SYSTEM_CRITICAL           0x00080000
#define FWPS_METADATA_FIELD_FORWARD_LAYER_OUTBOUND_PASS_THRU 0x00100000
#define FWPS_METADATA_FIELD_FORWARD_LAYER_INBOUND_PASS_THRU  0x00200000
#define FWPS_METADATA_FIELD_ALE_CLASSIFY_REQUIRED            0x00400000
#define FWPS_METADATA_FIELD_TRANSPORT_HEADER_INCLUDE_HEADER  0x00800000
#endif // (NTDDI_VERSION >= NTDDI_WIN6SP1)

// Provides additional meta-information to the filter engine. This information
// is not processed by the filter engine, but is supplied to the callouts.
// Unlike the FWPS_INCOMING_VALUES0, the schema of the meta-information is not
// fixed. Callouts should not assume that a given FWPS_METADATA_FIELD is
// present or that it is located at a given index in the array.

typedef struct FWPS_INCOMING_METADATA_VALUES0_
{
   // Bitmask representing which values are set.
   UINT32 currentMetadataValues;
   // Internal flags;
   UINT32 flags;
   // Reserved for system use.
   UINT64 reserved;
   // Discard module and reason.
   FWPS_DISCARD_METADATA0 discardMetadata;
   // Flow Handle.
   UINT64 flowHandle;
   // IP Header size.
   UINT32 ipHeaderSize;
   // Transport Header size
   UINT32 transportHeaderSize;
   // Process Path.
   FWP_BYTE_BLOB* processPath;
   // Token used for authorization.
   UINT64 token;
   // Process Id.
   UINT64 processId;
   // Source and Destination interface indices for discard indications.
   UINT32 sourceInterfaceIndex;
   UINT32 destinationInterfaceIndex;
   // Compartment Id for injection APIs.
   ULONG compartmentId;
   // Fragment data for inbound fragments.
   FWPS_INBOUND_FRAGMENT_METADATA0 fragmentMetadata;
   // Path MTU for outbound packets (to enable calculation of fragments).
   ULONG pathMtu;
   // Completion handle (required in order to be able to pend at this layer).
   HANDLE completionHandle;
   // Endpoint handle for use in outbound transport layer injection.
   UINT64 transportEndpointHandle;
   // Remote scope id for use in outbound transport layer injection.
   SCOPE_ID remoteScopeId;
   // Socket control data (and length) for use in outbound transport layer injection.
   WSACMSGHDR* controlData;
   ULONG controlDataLength;
   // Direction for the current packet. Only specified for ALE re-authorization.
   FWP_DIRECTION packetDirection;       
} FWPS_INCOMING_METADATA_VALUES0;

///////////////////////////////////////////////////////////////////////////////
//
// Macro for checking for metadata fields
//
///////////////////////////////////////////////////////////////////////////////

#define FWPS_IS_METADATA_FIELD_PRESENT(metadataValues, metadataField) \
   (((metadataValues)->currentMetadataValues & (metadataField)) == (metadataField))

// Invoked during classification when a callout filter matches.
typedef void (NTAPI *FWPS_CALLOUT_CLASSIFY_FN0)(
                        IN const FWPS_INCOMING_VALUES0* inFixedValues,
                        IN const FWPS_INCOMING_METADATA_VALUES0* inMetaValues,
                        IN OUT void* layerData,
                        IN const FWPS_FILTER0* filter,
                        IN UINT64 flowContext,
                        OUT FWPS_CLASSIFY_OUT0* classifyOut
                        );

// Notifies the callout that a filter invoking it has been added/deleted.
typedef NTSTATUS (NTAPI *FWPS_CALLOUT_NOTIFY_FN0)(
                            IN FWPS_CALLOUT_NOTIFY_TYPE notifyType,
                            IN const GUID* filterKey,
                            IN OUT FWPS_FILTER0* filter
                            );

// Notifies the callout that a flow has been deleted.
typedef void (NTAPI *FWPS_CALLOUT_FLOW_DELETE_NOTIFY_FN0)(
                        IN UINT16 layerId,
                        IN UINT32 calloutId,
                        IN UINT64 flowContext
                        );

// Notify callout that boottime callout has been removed
typedef void (NTAPI *FWPS_CALLOUT_BOOTTIME_CALLOUT_DELETE_NOTIFY_FN0)(
                        IN UINT32 calloutId
                        );
                        
#endif  // NTDDI_VERSION
#ifdef __cplusplus
}
#endif
#endif // FWPSX_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\fwpsk.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*
   Copyright (c) Microsoft Corporation

   SYNOPSIS

     Declares the system portion of the FWP API.
*/

#ifndef FWPSX_H
#define FWPSX_H
#if _MSC_VER >= 1020
#pragma once
#endif

#if (NTDDI_VERSION >= NTDDI_WIN6)

#ifndef _KRPCENV_
#define _KRPCENV_ 1
#endif

#include "fwpstypes.h"
#include "ws2def.h"
#include "ndis.h"

#ifdef __cplusplus
extern "C" {
#endif

///////////////////////////////////////////////////////////////////////////////
//
// LUIDs for built-in layers.
//
///////////////////////////////////////////////////////////////////////////////

typedef enum FWPS_BUILTIN_LAYERS_
{
   // Kernel-mode layers
   FWPS_LAYER_INBOUND_IPPACKET_V4,
   FWPS_LAYER_INBOUND_IPPACKET_V4_DISCARD,
   FWPS_LAYER_INBOUND_IPPACKET_V6,
   FWPS_LAYER_INBOUND_IPPACKET_V6_DISCARD,
   FWPS_LAYER_OUTBOUND_IPPACKET_V4,
   FWPS_LAYER_OUTBOUND_IPPACKET_V4_DISCARD,
   FWPS_LAYER_OUTBOUND_IPPACKET_V6,
   FWPS_LAYER_OUTBOUND_IPPACKET_V6_DISCARD,
   FWPS_LAYER_IPFORWARD_V4,
   FWPS_LAYER_IPFORWARD_V4_DISCARD,
   FWPS_LAYER_IPFORWARD_V6,
   FWPS_LAYER_IPFORWARD_V6_DISCARD,
   FWPS_LAYER_INBOUND_TRANSPORT_V4,
   FWPS_LAYER_INBOUND_TRANSPORT_V4_DISCARD,
   FWPS_LAYER_INBOUND_TRANSPORT_V6,
   FWPS_LAYER_INBOUND_TRANSPORT_V6_DISCARD,
   FWPS_LAYER_OUTBOUND_TRANSPORT_V4,
   FWPS_LAYER_OUTBOUND_TRANSPORT_V4_DISCARD,
   FWPS_LAYER_OUTBOUND_TRANSPORT_V6,
   FWPS_LAYER_OUTBOUND_TRANSPORT_V6_DISCARD,
   FWPS_LAYER_STREAM_V4,
   FWPS_LAYER_STREAM_V4_DISCARD,
   FWPS_LAYER_STREAM_V6,
   FWPS_LAYER_STREAM_V6_DISCARD,
   FWPS_LAYER_DATAGRAM_DATA_V4,
   FWPS_LAYER_DATAGRAM_DATA_V4_DISCARD,
   FWPS_LAYER_DATAGRAM_DATA_V6,
   FWPS_LAYER_DATAGRAM_DATA_V6_DISCARD,
   FWPS_LAYER_INBOUND_ICMP_ERROR_V4,
   FWPS_LAYER_INBOUND_ICMP_ERROR_V4_DISCARD,
   FWPS_LAYER_INBOUND_ICMP_ERROR_V6,
   FWPS_LAYER_INBOUND_ICMP_ERROR_V6_DISCARD,
   FWPS_LAYER_OUTBOUND_ICMP_ERROR_V4,
   FWPS_LAYER_OUTBOUND_ICMP_ERROR_V4_DISCARD,
   FWPS_LAYER_OUTBOUND_ICMP_ERROR_V6,
   FWPS_LAYER_OUTBOUND_ICMP_ERROR_V6_DISCARD,
   FWPS_LAYER_ALE_RESOURCE_ASSIGNMENT_V4,
   FWPS_LAYER_ALE_RESOURCE_ASSIGNMENT_V4_DISCARD,
   FWPS_LAYER_ALE_RESOURCE_ASSIGNMENT_V6,
   FWPS_LAYER_ALE_RESOURCE_ASSIGNMENT_V6_DISCARD,
   FWPS_LAYER_ALE_AUTH_LISTEN_V4,
   FWPS_LAYER_ALE_AUTH_LISTEN_V4_DISCARD,
   FWPS_LAYER_ALE_AUTH_LISTEN_V6,
   FWPS_LAYER_ALE_AUTH_LISTEN_V6_DISCARD,
   FWPS_LAYER_ALE_AUTH_RECV_ACCEPT_V4,
   FWPS_LAYER_ALE_AUTH_RECV_ACCEPT_V4_DISCARD,
   FWPS_LAYER_ALE_AUTH_RECV_ACCEPT_V6,
   FWPS_LAYER_ALE_AUTH_RECV_ACCEPT_V6_DISCARD,
   FWPS_LAYER_ALE_AUTH_CONNECT_V4,
   FWPS_LAYER_ALE_AUTH_CONNECT_V4_DISCARD,
   FWPS_LAYER_ALE_AUTH_CONNECT_V6,
   FWPS_LAYER_ALE_AUTH_CONNECT_V6_DISCARD,
   FWPS_LAYER_ALE_FLOW_ESTABLISHED_V4,
   FWPS_LAYER_ALE_FLOW_ESTABLISHED_V4_DISCARD,
   FWPS_LAYER_ALE_FLOW_ESTABLISHED_V6,
   FWPS_LAYER_ALE_FLOW_ESTABLISHED_V6_DISCARD,

   // User-mode layers
   FWPS_LAYER_IPSEC_KM_DEMUX_V4,
   FWPS_LAYER_IPSEC_KM_DEMUX_V6,
   FWPS_LAYER_IPSEC_V4,
   FWPS_LAYER_IPSEC_V6,
   FWPS_LAYER_IKEEXT_V4,
   FWPS_LAYER_IKEEXT_V6,
#ifndef UNDER_CE   
   FWPS_LAYER_RPC_UM,
   FWPS_LAYER_RPC_EPMAP,
   FWPS_LAYER_RPC_EP_ADD,
   FWPS_LAYER_RPC_PROXY_CONN,
   FWPS_LAYER_RPC_PROXY_IF,
#endif   //UNDER_CE
   FWPS_BUILTIN_LAYER_MAX
} FWPS_BUILTIN_LAYERS;

#define FWPS_BUILTIN_KM_LAYER_MAX FWPS_LAYER_IPSEC_KM_DEMUX_V4

///////////////////////////////////////////////////////////////////////////////
//
// LUIDs for built-in fields.
//
///////////////////////////////////////////////////////////////////////////////

typedef enum FWPS_FIELDS_INBOUND_IPPACKET_V4_
{
   FWPS_FIELD_INBOUND_IPPACKET_V4_IP_LOCAL_ADDRESS,
   FWPS_FIELD_INBOUND_IPPACKET_V4_IP_REMOTE_ADDRESS,
   FWPS_FIELD_INBOUND_IPPACKET_V4_IP_LOCAL_ADDRESS_TYPE,
   FWPS_FIELD_INBOUND_IPPACKET_V4_IP_LOCAL_INTERFACE,
   FWPS_FIELD_INBOUND_IPPACKET_V4_INTERFACE_INDEX,
   FWPS_FIELD_INBOUND_IPPACKET_V4_SUB_INTERFACE_INDEX,
   FWPS_FIELD_INBOUND_IPPACKET_V4_FLAGS,
   FWPS_FIELD_INBOUND_IPPACKET_V4_INTERFACE_TYPE,
   FWPS_FIELD_INBOUND_IPPACKET_V4_TUNNEL_TYPE,
   FWPS_FIELD_INBOUND_IPPACKET_V4_MAX
} FWPS_FIELDS_INBOUND_IPPACKET_V4;

typedef enum FWPS_FIELDS_INBOUND_IPPACKET_V6_
{
   FWPS_FIELD_INBOUND_IPPACKET_V6_IP_LOCAL_ADDRESS,
   FWPS_FIELD_INBOUND_IPPACKET_V6_IP_REMOTE_ADDRESS,
   FWPS_FIELD_INBOUND_IPPACKET_V6_IP_LOCAL_ADDRESS_TYPE,
   FWPS_FIELD_INBOUND_IPPACKET_V6_IP_LOCAL_INTERFACE,
   FWPS_FIELD_INBOUND_IPPACKET_V6_INTERFACE_INDEX,
   FWPS_FIELD_INBOUND_IPPACKET_V6_SUB_INTERFACE_INDEX,
   FWPS_FIELD_INBOUND_IPPACKET_V6_FLAGS,
   FWPS_FIELD_INBOUND_IPPACKET_V6_INTERFACE_TYPE,
   FWPS_FIELD_INBOUND_IPPACKET_V6_TUNNEL_TYPE,
   FWPS_FIELD_INBOUND_IPPACKET_V6_MAX
} FWPS_FIELDS_INBOUND_IPPACKET_V6;

typedef enum FWPS_FIELDS_OUTBOUND_IPPACKET_V4_
{
   FWPS_FIELD_OUTBOUND_IPPACKET_V4_IP_LOCAL_ADDRESS,
   FWPS_FIELD_OUTBOUND_IPPACKET_V4_IP_LOCAL_ADDRESS_TYPE,
   FWPS_FIELD_OUTBOUND_IPPACKET_V4_IP_REMOTE_ADDRESS,
   FWPS_FIELD_OUTBOUND_IPPACKET_V4_IP_LOCAL_INTERFACE,
   FWPS_FIELD_OUTBOUND_IPPACKET_V4_INTERFACE_INDEX,
   FWPS_FIELD_OUTBOUND_IPPACKET_V4_SUB_INTERFACE_INDEX,
   FWPS_FIELD_OUTBOUND_IPPACKET_V4_FLAGS,
   FWPS_FIELD_OUTBOUND_IPPACKET_V4_INTERFACE_TYPE,
   FWPS_FIELD_OUTBOUND_IPPACKET_V4_TUNNEL_TYPE,
   FWPS_FIELD_OUTBOUND_IPPACKET_V4_MAX
} FWPS_FIELDS_OUTBOUND_IPPACKET_V4;

typedef enum FWPS_FIELDS_OUTBOUND_IPPACKET_V6_
{
   FWPS_FIELD_OUTBOUND_IPPACKET_V6_IP_LOCAL_ADDRESS,
   FWPS_FIELD_OUTBOUND_IPPACKET_V6_IP_LOCAL_ADDRESS_TYPE,
   FWPS_FIELD_OUTBOUND_IPPACKET_V6_IP_REMOTE_ADDRESS,
   FWPS_FIELD_OUTBOUND_IPPACKET_V6_IP_LOCAL_INTERFACE,
   FWPS_FIELD_OUTBOUND_IPPACKET_V6_INTERFACE_INDEX,
   FWPS_FIELD_OUTBOUND_IPPACKET_V6_SUB_INTERFACE_INDEX,
   FWPS_FIELD_OUTBOUND_IPPACKET_V6_FLAGS,
   FWPS_FIELD_OUTBOUND_IPPACKET_V6_INTERFACE_TYPE,
   FWPS_FIELD_OUTBOUND_IPPACKET_V6_TUNNEL_TYPE,
   FWPS_FIELD_OUTBOUND_IPPACKET_V6_MAX
} FWPS_FIELDS_OUTBOUND_IPPACKET_V6;

typedef enum FWPS_FIELDS_IPFORWARD_V4_
{
   FWPS_FIELD_IPFORWARD_V4_IP_SOURCE_ADDRESS,
   FWPS_FIELD_IPFORWARD_V4_IP_DESTINATION_ADDRESS,
   FWPS_FIELD_IPFORWARD_V4_IP_DESTINATION_ADDRESS_TYPE,
   FWPS_FIELD_IPFORWARD_V4_IP_LOCAL_INTERFACE,
   FWPS_FIELD_IPFORWARD_V4_IP_FORWARD_INTERFACE,
   FWPS_FIELD_IPFORWARD_V4_SOURCE_INTERFACE_INDEX,
   FWPS_FIELD_IPFORWARD_V4_SOURCE_SUB_INTERFACE_INDEX,
   FWPS_FIELD_IPFORWARD_V4_DESTINATION_INTERFACE_INDEX,
   FWPS_FIELD_IPFORWARD_V4_DESTINATION_SUB_INTERFACE_INDEX,
   FWPS_FIELD_IPFORWARD_V4_FLAGS,
   FWPS_FIELD_IPFORWARD_V4_MAX
} FWPS_FIELDS_IPFORWARD_V4;

typedef enum FWPS_FIELDS_IPFORWARD_V6_
{
   FWPS_FIELD_IPFORWARD_V6_IP_SOURCE_ADDRESS,
   FWPS_FIELD_IPFORWARD_V6_IP_DESTINATION_ADDRESS,
   FWPS_FIELD_IPFORWARD_V6_IP_DESTINATION_ADDRESS_TYPE,
   FWPS_FIELD_IPFORWARD_V6_IP_LOCAL_INTERFACE,
   FWPS_FIELD_IPFORWARD_V6_IP_FORWARD_INTERFACE,
   FWPS_FIELD_IPFORWARD_V6_SOURCE_INTERFACE_INDEX,
   FWPS_FIELD_IPFORWARD_V6_SOURCE_SUB_INTERFACE_INDEX,
   FWPS_FIELD_IPFORWARD_V6_DESTINATION_INTERFACE_INDEX,
   FWPS_FIELD_IPFORWARD_V6_DESTINATION_SUB_INTERFACE_INDEX,
   FWPS_FIELD_IPFORWARD_V6_FLAGS,
   FWPS_FIELD_IPFORWARD_V6_MAX
} FWPS_FIELDS_IPFORWARD_V6;

typedef enum FWPS_FIELDS_INBOUND_TRANSPORT_V4_
{
   FWPS_FIELD_INBOUND_TRANSPORT_V4_IP_PROTOCOL,
   FWPS_FIELD_INBOUND_TRANSPORT_V4_IP_LOCAL_ADDRESS,
   FWPS_FIELD_INBOUND_TRANSPORT_V4_IP_REMOTE_ADDRESS,
   FWPS_FIELD_INBOUND_TRANSPORT_V4_IP_LOCAL_ADDRESS_TYPE,
   FWPS_FIELD_INBOUND_TRANSPORT_V4_IP_LOCAL_PORT,
   FWPS_FIELD_INBOUND_TRANSPORT_V4_IP_REMOTE_PORT,
   FWPS_FIELD_INBOUND_TRANSPORT_V4_IP_LOCAL_INTERFACE,
   FWPS_FIELD_INBOUND_TRANSPORT_V4_INTERFACE_INDEX,
   FWPS_FIELD_INBOUND_TRANSPORT_V4_SUB_INTERFACE_INDEX,
   FWPS_FIELD_INBOUND_TRANSPORT_V4_FLAGS,
   FWPS_FIELD_INBOUND_TRANSPORT_V4_INTERFACE_TYPE,
   FWPS_FIELD_INBOUND_TRANSPORT_V4_TUNNEL_TYPE,
   FWPS_FIELD_INBOUND_TRANSPORT_V4_MAX
} FWPS_FIELDS_INBOUND_TRANSPORT_V4;

#define FWPS_FIELD_INBOUND_TRANSPORT_V4_ICMP_TYPE \
        FWPS_FIELD_INBOUND_TRANSPORT_V4_IP_LOCAL_PORT

#define FWPS_FIELD_INBOUND_TRANSPORT_V4_ICMP_CODE \
        FWPS_FIELD_INBOUND_TRANSPORT_V4_IP_REMOTE_PORT

typedef enum FWPS_FIELDS_INBOUND_TRANSPORT_V6_
{
   FWPS_FIELD_INBOUND_TRANSPORT_V6_IP_PROTOCOL,
   FWPS_FIELD_INBOUND_TRANSPORT_V6_IP_LOCAL_ADDRESS,
   FWPS_FIELD_INBOUND_TRANSPORT_V6_IP_REMOTE_ADDRESS,
   FWPS_FIELD_INBOUND_TRANSPORT_V6_IP_LOCAL_ADDRESS_TYPE,
   FWPS_FIELD_INBOUND_TRANSPORT_V6_IP_LOCAL_PORT,
   FWPS_FIELD_INBOUND_TRANSPORT_V6_IP_REMOTE_PORT,
   FWPS_FIELD_INBOUND_TRANSPORT_V6_IP_LOCAL_INTERFACE,
   FWPS_FIELD_INBOUND_TRANSPORT_V6_INTERFACE_INDEX,
   FWPS_FIELD_INBOUND_TRANSPORT_V6_SUB_INTERFACE_INDEX,
   FWPS_FIELD_INBOUND_TRANSPORT_V6_FLAGS,
   FWPS_FIELD_INBOUND_TRANSPORT_V6_INTERFACE_TYPE,
   FWPS_FIELD_INBOUND_TRANSPORT_V6_TUNNEL_TYPE,
   FWPS_FIELD_INBOUND_TRANSPORT_V6_MAX
} FWPS_FIELDS_INBOUND_TRANSPORT_V6;

#define FWPS_FIELD_INBOUND_TRANSPORT_V6_ICMP_TYPE \
        FWPS_FIELD_INBOUND_TRANSPORT_V6_IP_LOCAL_PORT

#define FWPS_FIELD_INBOUND_TRANSPORT_V6_ICMP_CODE \
        FWPS_FIELD_INBOUND_TRANSPORT_V6_IP_REMOTE_PORT

typedef enum FWPS_FIELDS_OUTBOUND_TRANSPORT_V4_
{
   FWPS_FIELD_OUTBOUND_TRANSPORT_V4_IP_PROTOCOL,
   FWPS_FIELD_OUTBOUND_TRANSPORT_V4_IP_LOCAL_ADDRESS,
   FWPS_FIELD_OUTBOUND_TRANSPORT_V4_IP_LOCAL_ADDRESS_TYPE,
   FWPS_FIELD_OUTBOUND_TRANSPORT_V4_IP_REMOTE_ADDRESS,
   FWPS_FIELD_OUTBOUND_TRANSPORT_V4_IP_LOCAL_PORT,
   FWPS_FIELD_OUTBOUND_TRANSPORT_V4_IP_REMOTE_PORT,
   FWPS_FIELD_OUTBOUND_TRANSPORT_V4_IP_LOCAL_INTERFACE,
   FWPS_FIELD_OUTBOUND_TRANSPORT_V4_INTERFACE_INDEX,
   FWPS_FIELD_OUTBOUND_TRANSPORT_V4_SUB_INTERFACE_INDEX,
   FWPS_FIELD_OUTBOUND_TRANSPORT_V4_IP_DESTINATION_ADDRESS_TYPE,
   FWPS_FIELD_OUTBOUND_TRANSPORT_V4_FLAGS,
   FWPS_FIELD_OUTBOUND_TRANSPORT_V4_INTERFACE_TYPE,
   FWPS_FIELD_OUTBOUND_TRANSPORT_V4_TUNNEL_TYPE,
   FWPS_FIELD_OUTBOUND_TRANSPORT_V4_MAX
} FWPS_FIELDS_OUTBOUND_TRANSPORT_V4;

#define FWPS_FIELD_OUTBOUND_TRANSPORT_V4_ICMP_TYPE \
        FWPS_FIELD_OUTBOUND_TRANSPORT_V4_IP_LOCAL_PORT

#define FWPS_FIELD_OUTBOUND_TRANSPORT_V4_ICMP_CODE \
        FWPS_FIELD_OUTBOUND_TRANSPORT_V4_IP_REMOTE_PORT

typedef enum FWPS_FIELDS_OUTBOUND_TRANSPORT_V6_
{
   FWPS_FIELD_OUTBOUND_TRANSPORT_V6_IP_PROTOCOL,
   FWPS_FIELD_OUTBOUND_TRANSPORT_V6_IP_LOCAL_ADDRESS,
   FWPS_FIELD_OUTBOUND_TRANSPORT_V6_IP_LOCAL_ADDRESS_TYPE,
   FWPS_FIELD_OUTBOUND_TRANSPORT_V6_IP_REMOTE_ADDRESS,
   FWPS_FIELD_OUTBOUND_TRANSPORT_V6_IP_LOCAL_PORT,
   FWPS_FIELD_OUTBOUND_TRANSPORT_V6_IP_REMOTE_PORT,
   FWPS_FIELD_OUTBOUND_TRANSPORT_V6_IP_LOCAL_INTERFACE,
   FWPS_FIELD_OUTBOUND_TRANSPORT_V6_INTERFACE_INDEX,
   FWPS_FIELD_OUTBOUND_TRANSPORT_V6_SUB_INTERFACE_INDEX,
   FWPS_FIELD_OUTBOUND_TRANSPORT_V6_IP_DESTINATION_ADDRESS_TYPE,
   FWPS_FIELD_OUTBOUND_TRANSPORT_V6_FLAGS,
   FWPS_FIELD_OUTBOUND_TRANSPORT_V6_INTERFACE_TYPE,
   FWPS_FIELD_OUTBOUND_TRANSPORT_V6_TUNNEL_TYPE,
   FWPS_FIELD_OUTBOUND_TRANSPORT_V6_MAX
} FWPS_FIELDS_OUTBOUND_TRANSPORT_V6;

#define FWPS_FIELD_OUTBOUND_TRANSPORT_V6_ICMP_TYPE \
        FWPS_FIELD_OUTBOUND_TRANSPORT_V6_IP_LOCAL_PORT

#define FWPS_FIELD_OUTBOUND_TRANSPORT_V6_ICMP_CODE \
        FWPS_FIELD_OUTBOUND_TRANSPORT_V6_IP_REMOTE_PORT

typedef enum FWPS_FIELDS_STREAM_V4_
{
   FWPS_FIELD_STREAM_V4_IP_LOCAL_ADDRESS,
   FWPS_FIELD_STREAM_V4_IP_LOCAL_ADDRESS_TYPE,
   FWPS_FIELD_STREAM_V4_IP_REMOTE_ADDRESS,
   FWPS_FIELD_STREAM_V4_IP_LOCAL_PORT,
   FWPS_FIELD_STREAM_V4_IP_REMOTE_PORT,
   FWPS_FIELD_STREAM_V4_DIRECTION,
#if (NTDDI_VERSION >= NTDDI_WIN6SP1)
   FWPS_FIELD_STREAM_V4_FLAGS,
#endif // (NTDDI_VERSION >= NTDDI_WIN6SP1)         
   FWPS_FIELD_STREAM_V4_MAX
} FWPS_FIELDS_STREAM_V4;

typedef enum FWPS_FIELDS_STREAM_V6_
{
   FWPS_FIELD_STREAM_V6_IP_LOCAL_ADDRESS,
   FWPS_FIELD_STREAM_V6_IP_LOCAL_ADDRESS_TYPE,
   FWPS_FIELD_STREAM_V6_IP_REMOTE_ADDRESS,
   FWPS_FIELD_STREAM_V6_IP_LOCAL_PORT,
   FWPS_FIELD_STREAM_V6_IP_REMOTE_PORT,
   FWPS_FIELD_STREAM_V6_DIRECTION,
#if (NTDDI_VERSION >= NTDDI_WIN6SP1)
   FWPS_FIELD_STREAM_V6_FLAGS,
#endif // (NTDDI_VERSION >= NTDDI_WIN6SP1)    
   FWPS_FIELD_STREAM_V6_MAX
} FWPS_FIELDS_STREAM_V6;

typedef enum FWPS_FIELDS_DATAGRAM_DATA_V4_
{
   FWPS_FIELD_DATAGRAM_DATA_V4_IP_PROTOCOL,
   FWPS_FIELD_DATAGRAM_DATA_V4_IP_LOCAL_ADDRESS,
   FWPS_FIELD_DATAGRAM_DATA_V4_IP_REMOTE_ADDRESS,
   FWPS_FIELD_DATAGRAM_DATA_V4_IP_LOCAL_ADDRESS_TYPE,
   FWPS_FIELD_DATAGRAM_DATA_V4_IP_LOCAL_PORT,
   FWPS_FIELD_DATAGRAM_DATA_V4_IP_REMOTE_PORT,
   FWPS_FIELD_DATAGRAM_DATA_V4_IP_LOCAL_INTERFACE,
   FWPS_FIELD_DATAGRAM_DATA_V4_INTERFACE_INDEX,
   FWPS_FIELD_DATAGRAM_DATA_V4_SUB_INTERFACE_INDEX,
   FWPS_FIELD_DATAGRAM_DATA_V4_DIRECTION,
   FWPS_FIELD_DATAGRAM_DATA_V4_FLAGS,
   FWPS_FIELD_DATAGRAM_DATA_V4_INTERFACE_TYPE,
   FWPS_FIELD_DATAGRAM_DATA_V4_TUNNEL_TYPE,
   FWPS_FIELD_DATAGRAM_DATA_V4_MAX
} FWPS_FIELDS_DATAGRAM_DATA_V4;

#define FWPS_FIELD_DATAGRAM_DATA_V4_ICMP_TYPE \
        FWPS_FIELD_DATAGRAM_DATA_V4_IP_LOCAL_PORT

#define FWPS_FIELD_DATAGRAM_DATA_V4_ICMP_CODE \
        FWPS_FIELD_DATAGRAM_DATA_V4_IP_REMOTE_PORT


typedef enum FWPS_FIELDS_DATAGRAM_DATA_V6_
{
   FWPS_FIELD_DATAGRAM_DATA_V6_IP_PROTOCOL,
   FWPS_FIELD_DATAGRAM_DATA_V6_IP_LOCAL_ADDRESS,
   FWPS_FIELD_DATAGRAM_DATA_V6_IP_REMOTE_ADDRESS,
   FWPS_FIELD_DATAGRAM_DATA_V6_IP_LOCAL_ADDRESS_TYPE,
   FWPS_FIELD_DATAGRAM_DATA_V6_IP_LOCAL_PORT,
   FWPS_FIELD_DATAGRAM_DATA_V6_IP_REMOTE_PORT,
   FWPS_FIELD_DATAGRAM_DATA_V6_IP_LOCAL_INTERFACE,
   FWPS_FIELD_DATAGRAM_DATA_V6_INTERFACE_INDEX,
   FWPS_FIELD_DATAGRAM_DATA_V6_SUB_INTERFACE_INDEX,
   FWPS_FIELD_DATAGRAM_DATA_V6_DIRECTION,
   FWPS_FIELD_DATAGRAM_DATA_V6_FLAGS,
   FWPS_FIELD_DATAGRAM_DATA_V6_INTERFACE_TYPE,
   FWPS_FIELD_DATAGRAM_DATA_V6_TUNNEL_TYPE,
   FWPS_FIELD_DATAGRAM_DATA_V6_MAX
} FWPS_FIELDS_DATAGRAM_DATA_V6;

#define FWPS_FIELD_DATAGRAM_DATA_V6_ICMP_TYPE \
        FWPS_FIELD_DATAGRAM_DATA_V6_IP_LOCAL_PORT

#define FWPS_FIELD_DATAGRAM_DATA_V6_ICMP_CODE \
        FWPS_FIELD_DATAGRAM_DATA_V6_IP_REMOTE_PORT

typedef enum FWPS_FIELDS_INBOUND_ICMP_ERROR_V4_
{
   FWPS_FIELD_INBOUND_ICMP_ERROR_V4_EMBEDDED_PROTOCOL,
   FWPS_FIELD_INBOUND_ICMP_ERROR_V4_IP_LOCAL_ADDRESS,
   FWPS_FIELD_INBOUND_ICMP_ERROR_V4_IP_REMOTE_ADDRESS,
   FWPS_FIELD_INBOUND_ICMP_ERROR_V4_EMBEDDED_REMOTE_ADDRESS,
   FWPS_FIELD_INBOUND_ICMP_ERROR_V4_EMBEDDED_LOCAL_ADDRESS_TYPE,
   FWPS_FIELD_INBOUND_ICMP_ERROR_V4_EMBEDDED_LOCAL_PORT,
   FWPS_FIELD_INBOUND_ICMP_ERROR_V4_EMBEDDED_REMOTE_PORT,
   FWPS_FIELD_INBOUND_ICMP_ERROR_V4_IP_LOCAL_INTERFACE,
   FWPS_FIELD_INBOUND_ICMP_ERROR_V4_ICMP_TYPE,
   FWPS_FIELD_INBOUND_ICMP_ERROR_V4_ICMP_CODE,
   FWPS_FIELD_INBOUND_ICMP_ERROR_V4_INTERFACE_INDEX,      // of local/delivery interface
   FWPS_FIELD_INBOUND_ICMP_ERROR_V4_SUB_INTERFACE_INDEX,  // of arrival interface
   FWPS_FIELD_INBOUND_ICMP_ERROR_V4_INTERFACE_TYPE,       // of local/delivery interface
   FWPS_FIELD_INBOUND_ICMP_ERROR_V4_TUNNEL_TYPE,          // of local/delivery interface
#if (NTDDI_VERSION >= NTDDI_WIN6SP1)
   FWPS_FIELD_INBOUND_ICMP_ERROR_V4_IP_ARRIVAL_INTERFACE,   
   FWPS_FIELD_INBOUND_ICMP_ERROR_V4_ARRIVAL_INTERFACE_INDEX,
   FWPS_FIELD_INBOUND_ICMP_ERROR_V4_ARRIVAL_INTERFACE_TYPE,   
   FWPS_FIELD_INBOUND_ICMP_ERROR_V4_ARRIVAL_TUNNEL_TYPE,
   FWPS_FIELD_INBOUND_ICMP_ERROR_V4_FLAGS,
#endif // (NTDDI_VERSION >= NTDDI_WIN6SP1)
   FWPS_FIELD_INBOUND_ICMP_ERROR_V4_MAX
} FWPS_FIELDS_INBOUND_ICMP_ERROR_V4;

#if (NTDDI_VERSION >= NTDDI_WIN6SP1)

#define FWPS_FIELD_INBOUND_ICMP_ERROR_V4_LOCAL_INTERFACE_INDEX \
        FWPS_FIELD_INBOUND_ICMP_ERROR_V4_INTERFACE_INDEX

#define FWPS_FIELD_INBOUND_ICMP_ERROR_V4_ARRIVAL_SUB_INTERFACE_INDEX \
        FWPS_FIELD_INBOUND_ICMP_ERROR_V4_SUB_INTERFACE_INDEX

#define FWPS_FIELD_INBOUND_ICMP_ERROR_V4_LOCAL_INTERFACE_TYPE \
        FWPS_FIELD_INBOUND_ICMP_ERROR_V4_INTERFACE_TYPE

#define FWPS_FIELD_INBOUND_ICMP_ERROR_V4_LOCAL_TUNNEL_TYPE \
        FWPS_FIELD_INBOUND_ICMP_ERROR_V4_TUNNEL_TYPE

#endif // (NTDDI_VERSION >= NTDDI_WIN6SP1)

typedef enum FWPS_FIELDS_INBOUND_ICMP_ERROR_V6_
{
   FWPS_FIELD_INBOUND_ICMP_ERROR_V6_EMBEDDED_PROTOCOL,
   FWPS_FIELD_INBOUND_ICMP_ERROR_V6_IP_LOCAL_ADDRESS,
   FWPS_FIELD_INBOUND_ICMP_ERROR_V6_IP_REMOTE_ADDRESS,
   FWPS_FIELD_INBOUND_ICMP_ERROR_V6_EMBEDDED_REMOTE_ADDRESS,
   FWPS_FIELD_INBOUND_ICMP_ERROR_V6_EMBEDDED_LOCAL_ADDRESS_TYPE,
   FWPS_FIELD_INBOUND_ICMP_ERROR_V6_EMBEDDED_LOCAL_PORT,
   FWPS_FIELD_INBOUND_ICMP_ERROR_V6_EMBEDDED_REMOTE_PORT,
   FWPS_FIELD_INBOUND_ICMP_ERROR_V6_IP_LOCAL_INTERFACE,
   FWPS_FIELD_INBOUND_ICMP_ERROR_V6_ICMP_TYPE,
   FWPS_FIELD_INBOUND_ICMP_ERROR_V6_ICMP_CODE,
   FWPS_FIELD_INBOUND_ICMP_ERROR_V6_INTERFACE_INDEX,      // of local/delivery interface
   FWPS_FIELD_INBOUND_ICMP_ERROR_V6_SUB_INTERFACE_INDEX,  // of arrival interface
   FWPS_FIELD_INBOUND_ICMP_ERROR_V6_INTERFACE_TYPE,       // of local/delivery interface
   FWPS_FIELD_INBOUND_ICMP_ERROR_V6_TUNNEL_TYPE,          // of local/delivery interface
#if (NTDDI_VERSION >= NTDDI_WIN6SP1)   
   FWPS_FIELD_INBOUND_ICMP_ERROR_V6_IP_ARRIVAL_INTERFACE,   
   FWPS_FIELD_INBOUND_ICMP_ERROR_V6_ARRIVAL_INTERFACE_INDEX,
   FWPS_FIELD_INBOUND_ICMP_ERROR_V6_ARRIVAL_INTERFACE_TYPE,   
   FWPS_FIELD_INBOUND_ICMP_ERROR_V6_ARRIVAL_TUNNEL_TYPE,
   FWPS_FIELD_INBOUND_ICMP_ERROR_V6_FLAGS,
#endif // (NTDDI_VERSION >= NTDDI_WIN6SP1)
   FWPS_FIELD_INBOUND_ICMP_ERROR_V6_MAX
} FWPS_FIELDS_INBOUND_ICMP_ERROR_V6;

#if (NTDDI_VERSION >= NTDDI_WIN6SP1)   

#define FWPS_FIELD_INBOUND_ICMP_ERROR_V6_LOCAL_INTERFACE_INDEX \
        FWPS_FIELD_INBOUND_ICMP_ERROR_V6_INTERFACE_INDEX

#define FWPS_FIELD_INBOUND_ICMP_ERROR_V6_ARRIVAL_SUB_INTERFACE_INDEX \
        FWPS_FIELD_INBOUND_ICMP_ERROR_V6_SUB_INTERFACE_INDEX

#define FWPS_FIELD_INBOUND_ICMP_ERROR_V6_LOCAL_INTERFACE_TYPE \
        FWPS_FIELD_INBOUND_ICMP_ERROR_V6_INTERFACE_TYPE

#define FWPS_FIELD_INBOUND_ICMP_ERROR_V6_LOCAL_TUNNEL_TYPE \
        FWPS_FIELD_INBOUND_ICMP_ERROR_V6_TUNNEL_TYPE

#endif // (NTDDI_VERSION >= NTDDI_WIN6SP1)

typedef enum FWPS_FIELDS_OUTBOUND_ICMP_ERROR_V4_
{
   FWPS_FIELD_OUTBOUND_ICMP_ERROR_V4_IP_LOCAL_ADDRESS,
   FWPS_FIELD_OUTBOUND_ICMP_ERROR_V4_IP_REMOTE_ADDRESS,
   FWPS_FIELD_OUTBOUND_ICMP_ERROR_V4_IP_LOCAL_ADDRESS_TYPE,
   FWPS_FIELD_OUTBOUND_ICMP_ERROR_V4_IP_LOCAL_INTERFACE,
   FWPS_FIELD_OUTBOUND_ICMP_ERROR_V4_ICMP_TYPE,
   FWPS_FIELD_OUTBOUND_ICMP_ERROR_V4_ICMP_CODE,
   FWPS_FIELD_OUTBOUND_ICMP_ERROR_V4_INTERFACE_INDEX,
   FWPS_FIELD_OUTBOUND_ICMP_ERROR_V4_SUB_INTERFACE_INDEX,
   FWPS_FIELD_OUTBOUND_ICMP_ERROR_V4_INTERFACE_TYPE,
   FWPS_FIELD_OUTBOUND_ICMP_ERROR_V4_TUNNEL_TYPE,
#if (NTDDI_VERSION >= NTDDI_WIN6SP1)
   FWPS_FIELD_OUTBOUND_ICMP_ERROR_V4_FLAGS,
#endif // (NTDDI_VERSION >= NTDDI_WIN6SP1)
   FWPS_FIELD_OUTBOUND_ICMP_ERROR_V4_MAX
} FWPS_FIELDS_OUTBOUND_ICMP_ERROR_V4;

typedef enum FWPS_FIELDS_OUTBOUND_ICMP_ERROR_V6_
{
   FWPS_FIELD_OUTBOUND_ICMP_ERROR_V6_IP_LOCAL_ADDRESS,
   FWPS_FIELD_OUTBOUND_ICMP_ERROR_V6_IP_REMOTE_ADDRESS,
   FWPS_FIELD_OUTBOUND_ICMP_ERROR_V6_IP_LOCAL_ADDRESS_TYPE,
   FWPS_FIELD_OUTBOUND_ICMP_ERROR_V6_IP_LOCAL_INTERFACE,
   FWPS_FIELD_OUTBOUND_ICMP_ERROR_V6_IP_LOCAL_PORT,
   FWPS_FIELD_OUTBOUND_ICMP_ERROR_V6_IP_REMOTE_PORT,
   FWPS_FIELD_OUTBOUND_ICMP_ERROR_V6_INTERFACE_INDEX,
   FWPS_FIELD_OUTBOUND_ICMP_ERROR_V6_SUB_INTERFACE_INDEX,
   FWPS_FIELD_OUTBOUND_ICMP_ERROR_V6_INTERFACE_TYPE,
   FWPS_FIELD_OUTBOUND_ICMP_ERROR_V6_TUNNEL_TYPE,
#if (NTDDI_VERSION >= NTDDI_WIN6SP1)
   FWPS_FIELD_OUTBOUND_ICMP_ERROR_V6_FLAGS,
#endif // (NTDDI_VERSION >= NTDDI_WIN6SP1)
   FWPS_FIELD_OUTBOUND_ICMP_ERROR_V6_MAX
} FWPS_FIELDS_OUTBOUND_ICMP_ERROR_V6;

#define FWPS_FIELD_OUTBOUND_ICMP_ERROR_V6_ICMP_TYPE \
        FWPS_FIELD_OUTBOUND_ICMP_ERROR_V6_IP_LOCAL_PORT

#define FWPS_FIELD_OUTBOUND_ICMP_ERROR_V6_ICMP_CODE \
        FWPS_FIELD_OUTBOUND_ICMP_ERROR_V6_IP_REMOTE_PORT

typedef enum FWPS_FIELDS_ALE_RESOURCE_ASSIGNMENT_V4_
{
   FWPS_FIELD_ALE_RESOURCE_ASSIGNMENT_V4_ALE_APP_ID,
   FWPS_FIELD_ALE_RESOURCE_ASSIGNMENT_V4_ALE_USER_ID,
   FWPS_FIELD_ALE_RESOURCE_ASSIGNMENT_V4_IP_LOCAL_ADDRESS,
   FWPS_FIELD_ALE_RESOURCE_ASSIGNMENT_V4_IP_LOCAL_ADDRESS_TYPE,
   FWPS_FIELD_ALE_RESOURCE_ASSIGNMENT_V4_IP_LOCAL_PORT,
   FWPS_FIELD_ALE_RESOURCE_ASSIGNMENT_V4_IP_PROTOCOL,
   FWPS_FIELD_ALE_RESOURCE_ASSIGNMENT_V4_ALE_PROMISCUOUS_MODE,
   FWPS_FIELD_ALE_RESOURCE_ASSIGNMENT_V4_IP_LOCAL_INTERFACE,
   FWPS_FIELD_ALE_RESOURCE_ASSIGNMENT_V4_FLAGS,
   FWPS_FIELD_ALE_RESOURCE_ASSIGNMENT_V4_INTERFACE_TYPE,
   FWPS_FIELD_ALE_RESOURCE_ASSIGNMENT_V4_TUNNEL_TYPE,
   FWPS_FIELD_ALE_RESOURCE_ASSIGNMENT_V4_MAX
} FWPS_FIELDS_ALE_RESOURCE_ASSIGNMENT_V4;

typedef enum FWPS_FIELDS_ALE_RESOURCE_ASSIGNMENT_V6_
{
   FWPS_FIELD_ALE_RESOURCE_ASSIGNMENT_V6_ALE_APP_ID,
   FWPS_FIELD_ALE_RESOURCE_ASSIGNMENT_V6_ALE_USER_ID,
   FWPS_FIELD_ALE_RESOURCE_ASSIGNMENT_V6_IP_LOCAL_ADDRESS,
   FWPS_FIELD_ALE_RESOURCE_ASSIGNMENT_V6_IP_LOCAL_ADDRESS_TYPE,
   FWPS_FIELD_ALE_RESOURCE_ASSIGNMENT_V6_IP_LOCAL_PORT,
   FWPS_FIELD_ALE_RESOURCE_ASSIGNMENT_V6_IP_PROTOCOL,
   FWPS_FIELD_ALE_RESOURCE_ASSIGNMENT_V6_ALE_PROMISCUOUS_MODE,
   FWPS_FIELD_ALE_RESOURCE_ASSIGNMENT_V6_IP_LOCAL_INTERFACE,
   FWPS_FIELD_ALE_RESOURCE_ASSIGNMENT_V6_FLAGS,
   FWPS_FIELD_ALE_RESOURCE_ASSIGNMENT_V6_INTERFACE_TYPE,
   FWPS_FIELD_ALE_RESOURCE_ASSIGNMENT_V6_TUNNEL_TYPE,
   FWPS_FIELD_ALE_RESOURCE_ASSIGNMENT_V6_MAX
} FWPS_FIELDS_ALE_RESOURCE_ASSIGNMENT_V6;

typedef enum FWPS_FIELDS_ALE_AUTH_LISTEN_V4_
{
   FWPS_FIELD_ALE_AUTH_LISTEN_V4_ALE_APP_ID,
   FWPS_FIELD_ALE_AUTH_LISTEN_V4_ALE_USER_ID,
   FWPS_FIELD_ALE_AUTH_LISTEN_V4_IP_LOCAL_ADDRESS,
   FWPS_FIELD_ALE_AUTH_LISTEN_V4_IP_LOCAL_ADDRESS_TYPE,
   FWPS_FIELD_ALE_AUTH_LISTEN_V4_IP_LOCAL_PORT,
   FWPS_FIELD_ALE_AUTH_LISTEN_V4_IP_LOCAL_INTERFACE,
   FWPS_FIELD_ALE_AUTH_LISTEN_V4_FLAGS,
   FWPS_FIELD_ALE_AUTH_LISTEN_V4_INTERFACE_TYPE,
   FWPS_FIELD_ALE_AUTH_LISTEN_V4_TUNNEL_TYPE,
   FWPS_FIELD_ALE_AUTH_LISTEN_V4_MAX
} FWPS_FIELDS_ALE_AUTH_LISTEN_V4;

typedef enum FWPS_FIELDS_ALE_AUTH_LISTEN_V6_
{
   FWPS_FIELD_ALE_AUTH_LISTEN_V6_ALE_APP_ID,
   FWPS_FIELD_ALE_AUTH_LISTEN_V6_ALE_USER_ID,
   FWPS_FIELD_ALE_AUTH_LISTEN_V6_IP_LOCAL_ADDRESS,
   FWPS_FIELD_ALE_AUTH_LISTEN_V6_IP_LOCAL_ADDRESS_TYPE,
   FWPS_FIELD_ALE_AUTH_LISTEN_V6_IP_LOCAL_PORT,
   FWPS_FIELD_ALE_AUTH_LISTEN_V6_IP_LOCAL_INTERFACE,
   FWPS_FIELD_ALE_AUTH_LISTEN_V6_FLAGS,
   FWPS_FIELD_ALE_AUTH_LISTEN_V6_INTERFACE_TYPE,
   FWPS_FIELD_ALE_AUTH_LISTEN_V6_TUNNEL_TYPE,
   FWPS_FIELD_ALE_AUTH_LISTEN_V6_MAX
} FWPS_FIELDS_ALE_AUTH_LISTEN_V6;

typedef enum FWPS_FIELDS_ALE_AUTH_RECV_ACCEPT_V4_
{
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_ALE_APP_ID,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_ALE_USER_ID,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_IP_LOCAL_ADDRESS,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_IP_LOCAL_ADDRESS_TYPE,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_IP_LOCAL_PORT,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_IP_PROTOCOL,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_IP_REMOTE_ADDRESS,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_IP_REMOTE_PORT,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_ALE_REMOTE_USER_ID,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_ALE_REMOTE_MACHINE_ID,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_IP_LOCAL_INTERFACE,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_FLAGS,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_SIO_FIREWALL_SYSTEM_PORT,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_NAP_CONTEXT,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_INTERFACE_TYPE,      // of local/delivery interface
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_TUNNEL_TYPE,         // of local/delivery interface
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_INTERFACE_INDEX,     // of local/delivery interface   
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_SUB_INTERFACE_INDEX, // of arrival interface
#if (NTDDI_VERSION >= NTDDI_WIN6SP1)
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_IP_ARRIVAL_INTERFACE,   
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_ARRIVAL_INTERFACE_TYPE,   
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_ARRIVAL_TUNNEL_TYPE,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_ARRIVAL_INTERFACE_INDEX,
#endif // (NTDDI_VERSION >= NTDDI_WIN6SP1)
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_MAX
} FWPS_FIELDS_ALE_AUTH_RECV_ACCEPT_V4;

#define FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_ICMP_TYPE \
        FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_IP_LOCAL_PORT

#define FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_ICMP_CODE \
        FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_IP_REMOTE_PORT
        
#if (NTDDI_VERSION >= NTDDI_WIN6SP1)

#define FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_LOCAL_INTERFACE_TYPE \
        FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_INTERFACE_TYPE
        
#define FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_LOCAL_TUNNEL_TYPE \
        FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_TUNNEL_TYPE
        
#define FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_LOCAL_INTERFACE_INDEX \
        FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_INTERFACE_INDEX        

#define FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_ARRIVAL_SUB_INTERFACE_INDEX \
        FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V4_SUB_INTERFACE_INDEX        

#endif // (NTDDI_VERSION >= NTDDI_WIN6SP1)

typedef enum FWPS_FIELDS_ALE_AUTH_RECV_ACCEPT_V6_
{
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_ALE_APP_ID,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_ALE_USER_ID,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_IP_LOCAL_ADDRESS,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_IP_LOCAL_ADDRESS_TYPE,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_IP_LOCAL_PORT,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_IP_PROTOCOL,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_IP_REMOTE_ADDRESS,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_IP_REMOTE_PORT,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_ALE_REMOTE_USER_ID,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_ALE_REMOTE_MACHINE_ID,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_IP_LOCAL_INTERFACE,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_FLAGS,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_SIO_FIREWALL_SYSTEM_PORT,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_NAP_CONTEXT,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_INTERFACE_TYPE,      // of local/delivery interface
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_TUNNEL_TYPE,         // of local/delivery interface
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_INTERFACE_INDEX,     // of local/delivery interface
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_SUB_INTERFACE_INDEX, // of arrival interface
#if (NTDDI_VERSION >= NTDDI_WIN6SP1)
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_IP_ARRIVAL_INTERFACE,    
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_ARRIVAL_INTERFACE_TYPE,   
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_ARRIVAL_TUNNEL_TYPE,
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_ARRIVAL_INTERFACE_INDEX,
#endif // (NTDDI_VERSION >= NTDDI_WIN6SP1)
   FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_MAX
} FWPS_FIELDS_ALE_AUTH_RECV_ACCEPT_V6;

#define FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_ICMP_TYPE \
        FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_IP_LOCAL_PORT

#define FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_ICMP_CODE \
        FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_IP_REMOTE_PORT
        
#if (NTDDI_VERSION >= NTDDI_WIN6SP1)

#define FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_LOCAL_INTERFACE_TYPE \
        FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_INTERFACE_TYPE
        
#define FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_LOCAL_TUNNEL_TYPE \
        FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_TUNNEL_TYPE

#define FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_LOCAL_INTERFACE_INDEX \
        FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_INTERFACE_INDEX
        
#define FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_ARRIVAL_SUB_INTERFACE_INDEX \
        FWPS_FIELD_ALE_AUTH_RECV_ACCEPT_V6_SUB_INTERFACE_INDEX        

#endif // (NTDDI_VERSION >= NTDDI_WIN6SP1)

typedef enum FWPS_FIELDS_ALE_AUTH_CONNECT_V4_
{
   FWPS_FIELD_ALE_AUTH_CONNECT_V4_ALE_APP_ID,
   FWPS_FIELD_ALE_AUTH_CONNECT_V4_ALE_USER_ID,
   FWPS_FIELD_ALE_AUTH_CONNECT_V4_IP_LOCAL_ADDRESS,
   FWPS_FIELD_ALE_AUTH_CONNECT_V4_IP_LOCAL_ADDRESS_TYPE,
   FWPS_FIELD_ALE_AUTH_CONNECT_V4_IP_LOCAL_PORT,
   FWPS_FIELD_ALE_AUTH_CONNECT_V4_IP_PROTOCOL,
   FWPS_FIELD_ALE_AUTH_CONNECT_V4_IP_REMOTE_ADDRESS,
   FWPS_FIELD_ALE_AUTH_CONNECT_V4_IP_REMOTE_PORT,
   FWPS_FIELD_ALE_AUTH_CONNECT_V4_ALE_REMOTE_USER_ID,
   FWPS_FIELD_ALE_AUTH_CONNECT_V4_ALE_REMOTE_MACHINE_ID,
   FWPS_FIELD_ALE_AUTH_CONNECT_V4_IP_DESTINATION_ADDRESS_TYPE,
   FWPS_FIELD_ALE_AUTH_CONNECT_V4_IP_LOCAL_INTERFACE,
   FWPS_FIELD_ALE_AUTH_CONNECT_V4_FLAGS,
   FWPS_FIELD_ALE_AUTH_CONNECT_V4_INTERFACE_TYPE,
   FWPS_FIELD_ALE_AUTH_CONNECT_V4_TUNNEL_TYPE,
#if (NTDDI_VERSION >= NTDDI_WIN6SP1)
   FWPS_FIELD_ALE_AUTH_CONNECT_V4_INTERFACE_INDEX,
   FWPS_FIELD_ALE_AUTH_CONNECT_V4_SUB_INTERFACE_INDEX,
#endif // (NTDDI_VERSION >= NTDDI_WIN6SP1)
   FWPS_FIELD_ALE_AUTH_CONNECT_V4_MAX
} FWPS_FIELDS_ALE_AUTH_CONNECT_V4;

#define FWPS_FIELD_ALE_AUTH_CONNECT_V4_ICMP_TYPE \
        FWPS_FIELD_ALE_AUTH_CONNECT_V4_IP_LOCAL_PORT

#define FWPS_FIELD_ALE_AUTH_CONNECT_V4_ICMP_CODE \
        FWPS_FIELD_ALE_AUTH_CONNECT_V4_IP_REMOTE_PORT

typedef enum FWPS_FIELDS_ALE_AUTH_CONNECT_V6_
{
   FWPS_FIELD_ALE_AUTH_CONNECT_V6_ALE_APP_ID,
   FWPS_FIELD_ALE_AUTH_CONNECT_V6_ALE_USER_ID,
   FWPS_FIELD_ALE_AUTH_CONNECT_V6_IP_LOCAL_ADDRESS,
   FWPS_FIELD_ALE_AUTH_CONNECT_V6_IP_LOCAL_ADDRESS_TYPE,
   FWPS_FIELD_ALE_AUTH_CONNECT_V6_IP_LOCAL_PORT,
   FWPS_FIELD_ALE_AUTH_CONNECT_V6_IP_PROTOCOL,
   FWPS_FIELD_ALE_AUTH_CONNECT_V6_IP_REMOTE_ADDRESS,
   FWPS_FIELD_ALE_AUTH_CONNECT_V6_IP_REMOTE_PORT,
   FWPS_FIELD_ALE_AUTH_CONNECT_V6_ALE_REMOTE_USER_ID,
   FWPS_FIELD_ALE_AUTH_CONNECT_V6_ALE_REMOTE_MACHINE_ID,
   FWPS_FIELD_ALE_AUTH_CONNECT_V6_IP_DESTINATION_ADDRESS_TYPE,
   FWPS_FIELD_ALE_AUTH_CONNECT_V6_IP_LOCAL_INTERFACE,
   FWPS_FIELD_ALE_AUTH_CONNECT_V6_FLAGS,
   FWPS_FIELD_ALE_AUTH_CONNECT_V6_INTERFACE_TYPE,
   FWPS_FIELD_ALE_AUTH_CONNECT_V6_TUNNEL_TYPE,
#if (NTDDI_VERSION >= NTDDI_WIN6SP1)
   FWPS_FIELD_ALE_AUTH_CONNECT_V6_INTERFACE_INDEX,
   FWPS_FIELD_ALE_AUTH_CONNECT_V6_SUB_INTERFACE_INDEX,
#endif // (NTDDI_VERSION >= NTDDI_WIN6SP1)
   FWPS_FIELD_ALE_AUTH_CONNECT_V6_MAX
} FWPS_FIELDS_ALE_AUTH_CONNECT_V6;

#define FWPS_FIELD_ALE_AUTH_CONNECT_V6_ICMP_TYPE \
        FWPS_FIELD_ALE_AUTH_CONNECT_V6_IP_LOCAL_PORT

#define FWPS_FIELD_ALE_AUTH_CONNECT_V6_ICMP_CODE \
        FWPS_FIELD_ALE_AUTH_CONNECT_V6_IP_REMOTE_PORT

typedef enum FWPS_FIELDS_ALE_FLOW_ESTABLISHED_V4_
{
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V4_ALE_APP_ID,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V4_ALE_USER_ID,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V4_IP_LOCAL_ADDRESS,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V4_IP_LOCAL_ADDRESS_TYPE,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V4_IP_LOCAL_PORT,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V4_IP_PROTOCOL,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V4_IP_REMOTE_ADDRESS,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V4_IP_REMOTE_PORT,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V4_ALE_REMOTE_USER_ID,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V4_ALE_REMOTE_MACHINE_ID,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V4_IP_DESTINATION_ADDRESS_TYPE,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V4_IP_LOCAL_INTERFACE,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V4_DIRECTION,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V4_INTERFACE_TYPE,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V4_TUNNEL_TYPE,
#if (NTDDI_VERSION >= NTDDI_WIN6SP1)
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V4_FLAGS,
#endif // (NTDDI_VERSION >= NTDDI_WIN6SP1)   
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V4_MAX
} FWPS_FIELDS_ALE_FLOW_ESTABLISHED_V4;

#define FWPS_FIELD_ALE_FLOW_ESTABLISHED_V4_ICMP_TYPE \
        FWPS_FIELD_ALE_FLOW_ESTABLISHED_V4_IP_LOCAL_PORT

#define FWPS_FIELD_ALE_FLOW_ESTABLISHED_V4_ICMP_CODE \
        FWPS_FIELD_ALE_FLOW_ESTABLISHED_V4_IP_REMOTE_PORT

typedef enum FWPS_FIELDS_ALE_FLOW_ESTABLISHED_V6_
{
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V6_ALE_APP_ID,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V6_ALE_USER_ID,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V6_IP_LOCAL_ADDRESS,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V6_IP_LOCAL_ADDRESS_TYPE,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V6_IP_LOCAL_PORT,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V6_IP_PROTOCOL,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V6_IP_REMOTE_ADDRESS,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V6_IP_REMOTE_PORT,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V6_ALE_REMOTE_USER_ID,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V6_ALE_REMOTE_MACHINE_ID,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V6_IP_DESTINATION_ADDRESS_TYPE,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V6_IP_LOCAL_INTERFACE,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V6_DIRECTION,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V6_INTERFACE_TYPE,
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V6_TUNNEL_TYPE,
#if (NTDDI_VERSION >= NTDDI_WIN6SP1)
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V6_FLAGS,
#endif // (NTDDI_VERSION >= NTDDI_WIN6SP1)      
   FWPS_FIELD_ALE_FLOW_ESTABLISHED_V6_MAX
} FWPS_FIELDS_ALE_FLOW_ESTABLISHED_V6;

#define FWPS_FIELD_ALE_FLOW_ESTABLISHED_V6_ICMP_TYPE \
        FWPS_FIELD_ALE_FLOW_ESTABLISHED_V6_IP_LOCAL_PORT

#define FWPS_FIELD_ALE_FLOW_ESTABLISHED_V6_ICMP_CODE \
        FWPS_FIELD_ALE_FLOW_ESTABLISHED_V6_IP_REMOTE_PORT

typedef enum FWPS_FIELDS_IPSEC_KM_DEMUX_V4_
{
   FWPS_FIELD_IPSEC_KM_DEMUX_V4_IP_LOCAL_ADDRESS,
   FWPS_FIELD_IPSEC_KM_DEMUX_V4_IP_REMOTE_ADDRESS,
   FWPS_FIELD_IPSEC_KM_DEMUX_V4_MAX
} FWPS_FIELDS_IPSEC_KM_DEMUX_V4;

typedef enum FWPS_FIELDS_IPSEC_KM_DEMUX_V6_
{
   FWPS_FIELD_IPSEC_KM_DEMUX_V6_IP_LOCAL_ADDRESS,
   FWPS_FIELD_IPSEC_KM_DEMUX_V6_IP_REMOTE_ADDRESS,
   FWPS_FIELD_IPSEC_KM_DEMUX_V6_MAX
} FWPS_FIELDS_IPSEC_KM_DEMUX_V6;

typedef enum FWPS_FIELDS_IPSEC_V4_
{
   FWPS_FIELD_IPSEC_V4_IP_PROTOCOL,
   FWPS_FIELD_IPSEC_V4_IP_LOCAL_ADDRESS,
   FWPS_FIELD_IPSEC_V4_IP_REMOTE_ADDRESS,
   FWPS_FIELD_IPSEC_V4_IP_LOCAL_PORT,
   FWPS_FIELD_IPSEC_V4_IP_REMOTE_PORT,
   FWPS_FIELD_IPSEC_V4_MAX
} FWPS_FIELDS_IPSEC_V4;

typedef enum FWPS_FIELDS_IPSEC_V6_
{
   FWPS_FIELD_IPSEC_V6_IP_PROTOCOL,
   FWPS_FIELD_IPSEC_V6_IP_LOCAL_ADDRESS,
   FWPS_FIELD_IPSEC_V6_IP_REMOTE_ADDRESS,
   FWPS_FIELD_IPSEC_V6_IP_LOCAL_PORT,
   FWPS_FIELD_IPSEC_V6_IP_REMOTE_PORT,
   FWPS_FIELD_IPSEC_V6_MAX
} FWPS_FIELDS_IPSEC_V6;

typedef enum FWPS_FIELDS_IKEEXT_V4_
{
   FWPS_FIELD_IKEEXT_V4_IP_LOCAL_ADDRESS,
   FWPS_FIELD_IKEEXT_V4_IP_REMOTE_ADDRESS,
   FWPS_FIELD_IKEEXT_V4_MAX
} FWPS_FIELDS_IKEEXT_V4;

typedef enum FWPS_FIELDS_IKEEXT_V6_
{
   FWPS_FIELD_IKEEXT_V6_IP_LOCAL_ADDRESS,
   FWPS_FIELD_IKEEXT_V6_IP_REMOTE_ADDRESS,
   FWPS_FIELD_IKEEXT_V6_MAX
} FWPS_FIELDS_IKEEXT_V6;

#ifndef UNDER_CE
typedef enum FWPS_FIELDS_RPC_UM_
{
   FWPS_FIELD_RPC_UM_REMOTE_USER_TOKEN,
   FWPS_FIELD_RPC_UM_IF_UUID,
   FWPS_FIELD_RPC_UM_IF_VERSION,
   FWPS_FIELD_RPC_UM_IF_FLAG,
   FWPS_FIELD_RPC_UM_DCOM_APP_ID,
   FWPS_FIELD_RPC_UM_IMAGE_NAME,
   FWPS_FIELD_RPC_UM_PROTOCOL,
   FWPS_FIELD_RPC_UM_AUTH_TYPE,
   FWPS_FIELD_RPC_UM_AUTH_LEVEL,
   FWPS_FIELD_RPC_UM_SEC_ENCRYPT_ALGORITHM,
   FWPS_FIELD_RPC_UM_SEC_KEY_SIZE,
   FWPS_FIELD_RPC_UM_LOCAL_ADDR_V4,
   FWPS_FIELD_RPC_UM_LOCAL_ADDR_V6,
   FWPS_FIELD_RPC_UM_LOCAL_PORT,
   FWPS_FIELD_RPC_UM_PIPE,
   FWPS_FIELD_RPC_UM_REMOTE_ADDR_V4,
   FWPS_FIELD_RPC_UM_REMOTE_ADDR_V6,
   FWPS_FIELD_RPC_UM_MAX
} FWPS_FIELDS_RPC_UM;

typedef enum FWPS_FIELDS_RPC_EPMAP_
{
   FWPS_FIELD_RPC_EPMAP_REMOTE_USER_TOKEN,
   FWPS_FIELD_RPC_EPMAP_IF_UUID,
   FWPS_FIELD_RPC_EPMAP_IF_VERSION,
   FWPS_FIELD_RPC_EPMAP_PROTOCOL,
   FWPS_FIELD_RPC_EPMAP_AUTH_TYPE,
   FWPS_FIELD_RPC_EPMAP_AUTH_LEVEL,
   FWPS_FIELD_RPC_EPMAP_SEC_ENCRYPT_ALGORITHM,
   FWPS_FIELD_RPC_EPMAP_SEC_KEY_SIZE,
   FWPS_FIELD_RPC_EPMAP_LOCAL_ADDR_V4,
   FWPS_FIELD_RPC_EPMAP_LOCAL_ADDR_V6,
   FWPS_FIELD_RPC_EPMAP_LOCAL_PORT,
   FWPS_FIELD_RPC_EPMAP_PIPE,
   FWPS_FIELD_RPC_EPMAP_REMOTE_ADDR_V4,
   FWPS_FIELD_RPC_EPMAP_REMOTE_ADDR_V6,
   FWPS_FIELD_RPC_EPMAP_MAX
} FWPS_FIELDS_RPC_EPMAP;

typedef enum FWPS_FIELDS_RPC_EP_ADD_
{
   FWPS_FIELD_RPC_EP_ADD_PROCESS_WITH_RPC_IF_UUID,
   FWPS_FIELD_RPC_EP_ADD_PROTOCOL,
   FWPS_FIELD_RPC_EP_ADD_EP_VALUE,
   FWPS_FIELD_RPC_EP_ADD_EP_FLAGS,
   FWPS_FIELD_RPC_EP_ADD_MAX
} FWPS_FIELDS_RPC_EP_ADD;

typedef enum FWPS_FIELDS_RPC_PROXY_CONN_
{
   FWPS_FIELD_RPC_PROXY_CONN_CLIENT_TOKEN,
   FWPS_FIELD_RPC_PROXY_CONN_SERVER_NAME,
   FWPS_FIELD_RPC_PROXY_CONN_SERVER_PORT,
   FWPS_FIELD_RPC_PROXY_CONN_PROXY_AUTH_TYPE,
   FWPS_FIELD_RPC_PROXY_CONN_CLIENT_CERT_KEY_LENGTH,
   FWPS_FIELD_RPC_PROXY_CONN_CLIENT_CERT_OID,
   FWPS_FIELD_RPC_PROXY_CONN_MAX
} FWPS_FIELDS_RPC_PROXY_CONN;

typedef enum FWPS_FIELDS_RPC_PROXY_IF_
{
   FWPS_FIELD_RPC_PROXY_IF_CLIENT_TOKEN,
   FWPS_FIELD_RPC_PROXY_IF_IF_UUID,
   FWPS_FIELD_RPC_PROXY_IF_IF_VERSION,
   FWPS_FIELD_RPC_PROXY_IF_SERVER_NAME,
   FWPS_FIELD_RPC_PROXY_IF_SERVER_PORT,
   FWPS_FIELD_RPC_PROXY_IF_PROXY_AUTH_TYPE,
   FWPS_FIELD_RPC_PROXY_IF_CLIENT_CERT_KEY_LENGTH,
   FWPS_FIELD_RPC_PROXY_IF_CLIENT_CERT_OID,
   FWPS_FIELD_RPC_PROXY_IF_MAX
} FWPS_FIELDS_RPC_PROXY_IF_IF;
#endif //UNDER_CE

///////////////////////////////////////////////////////////////////////////////
//
// Network and transport discard reasons.
//
///////////////////////////////////////////////////////////////////////////////

//
// INET_DISCARD_REASON
//
// Define the reasons given by INET modules for discarding incoming datagrams.
//

#ifndef _INET_DISCARD_REASON_DEFINE_
#define _INET_DISCARD_REASON_DEFINE_

typedef enum {
    InetDiscardSourceUnspecified,
    InetDiscardDestinationMulticast,
    InetDiscardHeaderInvalid,
    InetDiscardChecksumInvalid,
    InetDiscardEndpointNotFound
} INET_DISCARD_REASON, *PINET_DISCARD_REASON;

#endif


#ifndef _IP_DISCARD_REASON_DEFINE_
#define _IP_DISCARD_REASON_DEFINE_

typedef enum {
    //
    // Receive path discard reasons.
    //
    IpDiscardBadSourceAddress = 1,
    IpDiscardNotLocallyDestined,
    IpDiscardProtocolUnreachable,
    IpDiscardPortUnreachable,
    IpDiscardBadLength,
    IpDiscardMalformedHeader,
    IpDiscardNoRoute,
    IpDiscardBeyondScope,
    IpDiscardInspectionDrop,  // Blocked by firewall, ICMP should not be sent.
    IpDiscardTooManyDecapsulations,
    IpDiscardAdministrativelyProhibited, // Blocked, ICMP should be sent.

    IpDiscardReceivePathMax = 127,

    //
    // Forward path discard reasons.
    //
    IpDiscardHopLimitExceeded,
    IpDiscardAddressUnreachable,
    IpDiscardForwardPathMax = 255,

    //
    // Internally used discard reasons.
    //
    IpDiscardArbitrationUnhandled,
    IpDiscardMax
} IP_DISCARD_REASON, *PIP_DISCARD_REASON;

#endif




///////////////////////////////////////////////////////////////////////////////
//
// API for implementing a callout.
//
///////////////////////////////////////////////////////////////////////////////

//////////
// Flags that can specified which entries are present
// in the FWPS_INCOMING_METADATA_VALUES0 structure.
//////////

#define FWPS_METADATA_FIELD_DISCARD_REASON                   0x00000001
#define FWPS_METADATA_FIELD_FLOW_HANDLE                      0x00000002
#define FWPS_METADATA_FIELD_IP_HEADER_SIZE                   0x00000004
#define FWPS_METADATA_FIELD_PROCESS_PATH                     0x00000008
#define FWPS_METADATA_FIELD_TOKEN                            0x00000010
#define FWPS_METADATA_FIELD_PROCESS_ID                       0x00000020
#define FWPS_METADATA_FIELD_SYSTEM_FLAGS                     0x00000040
#define FWPS_METADATA_FIELD_RESERVED                         0x00000080
#define FWPS_METADATA_FIELD_SOURCE_INTERFACE_INDEX           0x00000100
#define FWPS_METADATA_FIELD_DESTINATION_INTERFACE_INDEX      0x00000200
#define FWPS_METADATA_FIELD_TRANSPORT_HEADER_SIZE            0x00000400
#define FWPS_METADATA_FIELD_COMPARTMENT_ID                   0x00000800
#define FWPS_METADATA_FIELD_FRAGMENT_DATA                    0x00001000
#define FWPS_METADATA_FIELD_PATH_MTU                         0x00002000
#define FWPS_METADATA_FIELD_COMPLETION_HANDLE                0x00004000
#define FWPS_METADATA_FIELD_TRANSPORT_ENDPOINT_HANDLE        0x00008000
#define FWPS_METADATA_FIELD_TRANSPORT_CONTROL_DATA           0x00010000
#define FWPS_METADATA_FIELD_REMOTE_SCOPE_ID                  0x00020000
#define FWPS_METADATA_FIELD_PACKET_DIRECTION                 0x00040000
#if (NTDDI_VERSION >= NTDDI_WIN6SP1)
#define FWPS_METADATA_FIELD_PACKET_SYSTEM_CRITICAL           0x00080000
#define FWPS_METADATA_FIELD_FORWARD_LAYER_OUTBOUND_PASS_THRU 0x00100000
#define FWPS_METADATA_FIELD_FORWARD_LAYER_INBOUND_PASS_THRU  0x00200000
#define FWPS_METADATA_FIELD_ALE_CLASSIFY_REQUIRED            0x00400000
#define FWPS_METADATA_FIELD_TRANSPORT_HEADER_INCLUDE_HEADER  0x00800000
#endif // (NTDDI_VERSION >= NTDDI_WIN6SP1)

// Provides additional meta-information to the filter engine. This information
// is not processed by the filter engine, but is supplied to the callouts.
// Unlike the FWPS_INCOMING_VALUES0, the schema of the meta-information is not
// fixed. Callouts should not assume that a given FWPS_METADATA_FIELD is
// present or that it is located at a given index in the array.

typedef struct FWPS_INCOMING_METADATA_VALUES0_
{
   // Bitmask representing which values are set.
   UINT32 currentMetadataValues;
   // Internal flags;
   UINT32 flags;
   // Reserved for system use.
   UINT64 reserved;
   // Discard module and reason.
   FWPS_DISCARD_METADATA0 discardMetadata;
   // Flow Handle.
   UINT64 flowHandle;
   // IP Header size.
   UINT32 ipHeaderSize;
   // Transport Header size
   UINT32 transportHeaderSize;
   // Process Path.
   FWP_BYTE_BLOB* processPath;
   // Token used for authorization.
   UINT64 token;
   // Process Id.
   UINT64 processId;
   // Source and Destination interface indices for discard indications.
   UINT32 sourceInterfaceIndex;
   UINT32 destinationInterfaceIndex;
   // Compartment Id for injection APIs.
   ULONG compartmentId;
   // Fragment data for inbound fragments.
   FWPS_INBOUND_FRAGMENT_METADATA0 fragmentMetadata;
   // Path MTU for outbound packets (to enable calculation of fragments).
   ULONG pathMtu;
   // Completion handle (required in order to be able to pend at this layer).
   HANDLE completionHandle;
   // Endpoint handle for use in outbound transport layer injection.
   UINT64 transportEndpointHandle;
   // Remote scope id for use in outbound transport layer injection.
   SCOPE_ID remoteScopeId;
   // Socket control data (and length) for use in outbound transport layer injection.
   WSACMSGHDR* controlData;
   ULONG controlDataLength;
   // Direction for the current packet. Only specified for ALE re-authorization.
   FWP_DIRECTION packetDirection;
#if (NTDDI_VERSION >= NTDDI_WIN6SP1)
   // Raw IP header (and length) if the packet is sent with IP header from a RAW socket.
   PVOID headerIncludeHeader;
   ULONG headerIncludeHeaderLength;
#endif // (NTDDI_VERSION >= NTDDI_WIN6SP1)
} FWPS_INCOMING_METADATA_VALUES0;

///////////////////////////////////////////////////////////////////////////////
//
// Macro for checking for metadata fields
//
///////////////////////////////////////////////////////////////////////////////

#define FWPS_IS_METADATA_FIELD_PRESENT(metadataValues, metadataField) \
   (((metadataValues)->currentMetadataValues & (metadataField)) == (metadataField))

// Invoked during classification when a callout filter matches.
typedef void (NTAPI *FWPS_CALLOUT_CLASSIFY_FN0)(
                        IN const FWPS_INCOMING_VALUES0* inFixedValues,
                        IN const FWPS_INCOMING_METADATA_VALUES0* inMetaValues,
                        IN OUT void* layerData,
                        IN const FWPS_FILTER0* filter,
                        IN UINT64 flowContext,
                        OUT FWPS_CLASSIFY_OUT0* classifyOut
                        );

// Notifies the callout that a filter invoking it has been added/deleted.
typedef NTSTATUS (NTAPI *FWPS_CALLOUT_NOTIFY_FN0)(
                            IN FWPS_CALLOUT_NOTIFY_TYPE notifyType,
                            IN const GUID* filterKey,
                            IN OUT FWPS_FILTER0* filter
                            );

// Notifies the callout that a flow has been deleted.
typedef void (NTAPI *FWPS_CALLOUT_FLOW_DELETE_NOTIFY_FN0)(
                        IN UINT16 layerId,
                        IN UINT32 calloutId,
                        IN UINT64 flowContext
                        );

// Notify callout that boottime callout has been removed
typedef void (NTAPI *FWPS_CALLOUT_BOOTTIME_CALLOUT_DELETE_NOTIFY_FN0)(
                        IN UINT32 calloutId
                        );



// Run-time state necessary to invoke a callout.
typedef struct FWPS_CALLOUT0_
{
   // Uniquely identifies the callout. This must be the same GUID supplied to
   // FwpmCalloutAdd0.
   GUID calloutKey;
   // Flags
   UINT32 flags;
   // Pointer to the classification function.
   FWPS_CALLOUT_CLASSIFY_FN0 classifyFn;
   // Pointer to the notification function.
   FWPS_CALLOUT_NOTIFY_FN0 notifyFn;
   // Pointer to the flow delete function.
   FWPS_CALLOUT_FLOW_DELETE_NOTIFY_FN0 flowDeleteFn;
} FWPS_CALLOUT0;

// Register the function pointers for a callout.  The callout driver must call
// FwpsCalloutUnregisterById0 before unloading.
NTSTATUS
NTAPI
FwpsCalloutRegister0(
   IN OUT void* deviceObject,
   IN const FWPS_CALLOUT0* callout,
   OUT OPTIONAL UINT32* calloutId
   );

NTSTATUS
NTAPI
FwpsCalloutUnregisterById0(IN const UINT32 calloutId);

NTSTATUS
NTAPI
FwpsCalloutUnregisterByKey0(IN const GUID* calloutKey);

// Allows a callout to associate an opaque flowContext with a flow.
NTSTATUS
NTAPI
FwpsFlowAssociateContext0(
   IN UINT64 flowId,
   IN UINT16 layerId,
   IN UINT32 calloutId,
   IN UINT64 flowContext
   );

// Remote a flow context added with FwpsFlowAssociateContext0.
NTSTATUS
NTAPI
FwpsFlowRemoveContext0(
   IN UINT64 flowId,
   IN UINT16 layerId,
   IN UINT32 calloutId
   );


///////////////////////////////////////////////////////////////////////////////
//
// Declarations for Packet List Information.
//
///////////////////////////////////////////////////////////////////////////////

typedef struct FWPS_PACKET_LIST_INBOUND_IPSEC_INFORMATION0_
{
   unsigned isSecure:1;
   unsigned isTransportMode:1;
   unsigned isTunnelMode:1;
   unsigned isTransportModeVerified:1;
   unsigned isTunnelModeVerified:1;
   unsigned isDeTunneled:1;
}FWPS_PACKET_LIST_INBOUND_IPSEC_INFORMATION0;

typedef struct FWPS_PACKET_LIST_OUTBOUND_IPSEC_INFORMATION0_
{
   unsigned isIPsecPolicyMatch:1;
   unsigned isTransportPolicyMatch:1;
   unsigned isTunnelPolicyMatch:1;
   unsigned isTunnelIPinIP:1;
}FWPS_PACKET_LIST_OUTBOUND_IPSEC_INFORMATION0;

typedef struct FWPS_PACKET_LIST_IPSEC_INFORMATION0_
{
   union
   {
      FWPS_PACKET_LIST_INBOUND_IPSEC_INFORMATION0 inbound;
      FWPS_PACKET_LIST_OUTBOUND_IPSEC_INFORMATION0 outbound;
      UINT32 flags;
   };
} FWPS_PACKET_LIST_IPSEC_INFORMATION0;


typedef struct FWPS_PACKET_LIST_FWP_INFORMATION0_
{
   unsigned isReinjected:1;
} FWPS_PACKET_LIST_FWP_INFORMATION0;

#define FWPS_PACKET_LIST_INFORMATION_QUERY_INBOUND  0x00000001
#define FWPS_PACKET_LIST_INFORMATION_QUERY_OUTBOUND 0x00000002
#define FWPS_PACKET_LIST_INFORMATION_QUERY_IPSEC    0x00000004
#define FWPS_PACKET_LIST_INFORMATION_QUERY_FWP      0x00000008
#define FWPS_PACKET_LIST_INFORMATION_QUERY_ALL_INBOUND       0xfffffffd
#define FWPS_PACKET_LIST_INFORMATION_QUERY_ALL_OUTBOUND       0xfffffffe
#define FWPS_PACKET_LIST_INFORMATION_QUERY_INVALID_MASK     0x00000003


typedef struct FWPS_PACKET_LIST_INFORMATION0_
{
   FWPS_PACKET_LIST_IPSEC_INFORMATION0 ipsecInformation;
   FWPS_PACKET_LIST_FWP_INFORMATION0 fwpInformation;
} FWPS_PACKET_LIST_INFORMATION0;


NTSTATUS
NTAPI
FwpsGetPacketListSecurityInformation0(
   IN NET_BUFFER_LIST* packetList,
   IN UINT32 queryFlags,
   IN OUT FWPS_PACKET_LIST_INFORMATION0*  packetInformation
   );

///////////////////////////////////////////////////////////////////////////////
//
// Pend APIs for ALE layers.
//
///////////////////////////////////////////////////////////////////////////////

NTSTATUS
NTAPI
FwpsPendOperation0(
   IN HANDLE completionHandle,
   OUT HANDLE* completionContext
   );

void
NTAPI
FwpsCompleteOperation0(
   IN HANDLE completionContext,
   IN PNET_BUFFER_LIST netBufferList
   );

///////////////////////////////////////////////////////////////////////////////
//
// Functions for setting Classify Options
//
///////////////////////////////////////////////////////////////////////////////

NTSTATUS
NTAPI
FwpsClassifyOptionSet0(
   IN const FWPS_INCOMING_METADATA_VALUES0* inMetadataValues,
   IN const FWP_CLASSIFY_OPTION_TYPE option,
   IN const FWP_VALUE0* newValue
   );

///////////////////////////////////////////////////////////////////////////////
//
// Packet injection API.
//
///////////////////////////////////////////////////////////////////////////////

typedef struct FWPS_TRANSPORT_SEND_PARAMS0_
{
   UCHAR* remoteAddress;
   SCOPE_ID remoteScopeId;
   WSACMSGHDR* controlData OPTIONAL;
   ULONG controlDataLength OPTIONAL;
} FWPS_TRANSPORT_SEND_PARAMS0;

#define FWPS_INJECTION_TYPE_STREAM     0x00000001
#define FWPS_INJECTION_TYPE_TRANSPORT  0x00000002
#define FWPS_INJECTION_TYPE_NETWORK    0x00000004
#define FWPS_INJECTION_TYPE_FORWARD    0x00000008

NTSTATUS
NTAPI
FwpsInjectionHandleCreate0(
   IN OPTIONAL ADDRESS_FAMILY addressFamily,
   IN UINT32 flags,
   OUT HANDLE* injectionHandle
   );

NTSTATUS
NTAPI
FwpsInjectionHandleDestroy0(IN HANDLE injectionHandle);

typedef void (NTAPI *FWPS_INJECT_COMPLETE0)(
                        IN void* context,
                        IN OUT NET_BUFFER_LIST* netBufferList,
                        IN BOOLEAN dispatchLevel
                        );

NTSTATUS
NTAPI
FwpsAllocateNetBufferAndNetBufferList0(
   IN NDIS_HANDLE poolHandle,
   IN USHORT contextSize,
   IN USHORT contextBackFill,
   IN OPTIONAL MDL* mdlChain,
   IN ULONG dataOffset,
   IN SIZE_T dataLength,
   OUT NET_BUFFER_LIST** netBufferList
   );

void
NTAPI
FwpsFreeNetBufferList0(
   IN OUT NET_BUFFER_LIST* netBufferList
   );

NTSTATUS
NTAPI
FwpsAllocateCloneNetBufferList0(
   IN OUT NET_BUFFER_LIST* originalNetBufferList,
   IN OPTIONAL NDIS_HANDLE netBufferListPoolHandle,
   IN OPTIONAL NDIS_HANDLE netBufferPoolHandle,
   IN ULONG allocateCloneFlags,
   OUT NET_BUFFER_LIST** netBufferList
   );

void
NTAPI
FwpsFreeCloneNetBufferList0(
   IN OUT NET_BUFFER_LIST* netBufferList,
   IN ULONG freeCloneFlags
   );

#if (NTDDI_VERSION >= NTDDI_WIN6SP1)

NTSTATUS
NTAPI
FwpsReassembleForwardFragmentGroup0(
   IN ADDRESS_FAMILY addressFamily,
   IN OUT NET_BUFFER_LIST* fragmentGroupNblChain,
   IN NDIS_HANDLE netBufferAndNetBufferListPoolHandle OPTIONAL,
   IN ULONG dataBackFill,
   IN ULONG flags,
   OUT NET_BUFFER_LIST** reassembledNbl
   );

#endif // (NTDDI_VERSION >= NTDDI_WIN6SP1)

NTSTATUS
NTAPI
FwpsInjectNetworkSendAsync0(
   IN HANDLE injectionHandle,
   IN OPTIONAL HANDLE injectionContext,
   IN UINT32 flags,
   IN COMPARTMENT_ID compartmentId,
   IN OUT NET_BUFFER_LIST* netBufferList,
   IN FWPS_INJECT_COMPLETE0 completionFn,
   IN OPTIONAL HANDLE completionContext
   );

NTSTATUS
NTAPI
FwpsInjectForwardAsync0(
   IN HANDLE injectionHandle,
   IN OPTIONAL HANDLE injectionContext,
   IN UINT32 flags,
   IN ADDRESS_FAMILY addressFamily,
   IN COMPARTMENT_ID compartmentId,
   IN IF_INDEX interfaceIndex,
   IN OUT NET_BUFFER_LIST* netBufferList,
   IN FWPS_INJECT_COMPLETE0 completionFn,
   IN OPTIONAL HANDLE completionContext
   );

#if (NTDDI_VERSION >= NTDDI_WIN6SP1)

NTSTATUS
NTAPI
FwpsConstructIpHeaderForTransportPacket0(
   IN OUT NET_BUFFER_LIST* netBufferList,
   IN ULONG headerIncludeHeaderLength,
   IN ADDRESS_FAMILY addressFamily,
   IN const UCHAR* sourceAddress,
   IN const UCHAR* remoteAddress,
   IN IPPROTO nextProtocol,
   IN UINT64 endpointHandle OPTIONAL,
   IN const WSACMSGHDR* controlData OPTIONAL,
   IN ULONG controlDataLength,
   IN UINT32 flags,
   IN PVOID reserved,
   IN IF_INDEX interfaceIndex OPTIONAL,
   IN IF_INDEX subInterfaceIndex  OPTIONAL
   );

#endif // (NTDDI_VERSION >= NTDDI_WIN6SP1)

NTSTATUS
NTAPI
FwpsInjectTransportSendAsync0(
   IN HANDLE injectionHandle,
   IN OPTIONAL HANDLE injectionContext,
   IN UINT64 endpointHandle,
   IN UINT32 flags,
   IN OPTIONAL FWPS_TRANSPORT_SEND_PARAMS0* sendArgs,
   IN ADDRESS_FAMILY addressFamily,
   IN COMPARTMENT_ID compartmentId,
   IN OUT NET_BUFFER_LIST* netBufferList,
   IN FWPS_INJECT_COMPLETE0 completionFn,
   IN OPTIONAL HANDLE completionContext
   );

NTSTATUS
NTAPI
FwpsInjectTransportReceiveAsync0(
   IN HANDLE injectionHandle,
   IN OPTIONAL HANDLE injectionContext,
   IN PVOID reserved,
   IN UINT32 flags,
   IN ADDRESS_FAMILY addressFamily,
   IN COMPARTMENT_ID compartmentId,
   IN IF_INDEX interfaceIndex,
   IN IF_INDEX subInterfaceIndex,
   IN OUT NET_BUFFER_LIST* netBufferList,
   IN FWPS_INJECT_COMPLETE0 completionFn,
   IN OPTIONAL HANDLE completionContext
   );

NTSTATUS
NTAPI
FwpsInjectNetworkReceiveAsync0(
   IN HANDLE injectionHandle,
   IN OPTIONAL HANDLE injectionContext,
   IN UINT32 flags,
   IN COMPARTMENT_ID compartmentId,
   IN IF_INDEX interfaceIndex,
   IN IF_INDEX subInterfaceIndex,
   IN OUT NET_BUFFER_LIST* netBufferList,
   IN FWPS_INJECT_COMPLETE0 completionFn,
   IN OPTIONAL HANDLE completionContext
   );

void
NTAPI
FwpsReferenceNetBufferList0(
   IN OUT NET_BUFFER_LIST* netBufferList,
   IN BOOLEAN intendToModify
   );

void
NTAPI
FwpsDereferenceNetBufferList0(
   IN OUT NET_BUFFER_LIST* netBufferList,
   IN BOOLEAN dispatchLevel
   );

///////////////////////////////////////////////////////////////////////////////
//
// Packet injection state tracking API.
//
///////////////////////////////////////////////////////////////////////////////

typedef enum FWPS_PACKET_INJECTION_STATE_
{
   // Packet was not injected by the FwpsInject* APIs.
   FWPS_PACKET_NOT_INJECTED,
   // Packet was injected by the calling injection handle.
   FWPS_PACKET_INJECTED_BY_SELF,
   // Packet was injected by a different injection handle.
   FWPS_PACKET_INJECTED_BY_OTHER,
   // Packet was injected by the calling injection handle but later
   // cloned and re-injected by other injector(s).
   FWPS_PACKET_PREVIOUSLY_INJECTED_BY_SELF,
   FWPS_PACKET_INJECTION_STATE_MAX
} FWPS_PACKET_INJECTION_STATE;

FWPS_PACKET_INJECTION_STATE
NTAPI
FwpsQueryPacketInjectionState0(
   IN HANDLE injectionHandle,
   IN const NET_BUFFER_LIST* netBufferList,
   OUT OPTIONAL HANDLE* injectionContext
   );

///////////////////////////////////////////////////////////////////////////////
//
// API for stream processing.
//
///////////////////////////////////////////////////////////////////////////////


// The FWPS_STREAM_DATA_OFFSET0 specifies an offset into a data stream defined in
// an FWPS_STREAM_DATA0.  Generally, it is only necessary to know the byte
// offset, however this means searching for the NET_BUFFER_LIST, NET_BUFFER, MDL
// and offset into the MDL to find the byte of interest. FWPS_STREAM_DATA_OFFSET0
// helps by keeping track of this information.  The netBufferList, netBuffer, mdl,
// and mdlOffset and offset combined give the location of the byte of interest.
// netBufferOffset and streamBufferOffset are used internally to optimize
// computations.

typedef struct FWPS_STREAM_DATA_OFFSET0_
{
   // NET_BUFFER_LIST in which offset lies.
   NET_BUFFER_LIST* netBufferList;
   // NET_BUFFER in which offset lies.
   NET_BUFFER* netBuffer;
   // MDL in which offset lies.
   MDL* mdl;
   // Byte offset from the beginning of the MDL in which data lies.
   UINT32 mdlOffset;
   // Offset relative to the DataOffset of the NET_BUFFER.
   UINT32 netBufferOffset;
   // Offset from the beginning of the entire stream buffer.
   SIZE_T streamDataOffset;
}  FWPS_STREAM_DATA_OFFSET0;

// Flags set on receives (inbound stream layer).
#define FWPS_STREAM_FLAG_RECEIVE                (0x00000001)
// Received TCP urgent data.
#define FWPS_STREAM_FLAG_RECEIVE_EXPEDITED      (0x00000002)
#define FWPS_STREAM_FLAG_RECEIVE_DISCONNECT     (0x00000004)
#define FWPS_STREAM_FLAG_RECEIVE_ABORT          (0x00000008)
#if (NTDDI_VERSION >= NTDDI_WIN6SP1)
#define FWPS_STREAM_FLAG_RECEIVE_PUSH           (0x00000010)
#endif // (NTDDI_VERSION >= NTDDI_WIN6SP1)

// Flags set on sends (outbound stream layer).
#define FWPS_STREAM_FLAG_SEND                   (0x00010000)
#define FWPS_STREAM_FLAG_SEND_EXPEDITED         (0x00020000)
#define FWPS_STREAM_FLAG_SEND_NODELAY           (0x00040000)
#define FWPS_STREAM_FLAG_SEND_DISCONNECT        (0x00080000)
#define FWPS_STREAM_FLAG_SEND_ABORT             (0x00100000)

// FWPS_STREAM_DATA0 is used to store a section of the stream and provide it
// to a callout for processing.
typedef struct FWPS_STREAM_DATA0_
{
   UINT32 flags;
   FWPS_STREAM_DATA_OFFSET0 dataOffset;
   SIZE_T dataLength;

   NET_BUFFER_LIST* netBufferListChain;
}FWPS_STREAM_DATA0;

typedef enum FWPS_STREAM_ACTION_TYPE_
{
   FWPS_STREAM_ACTION_NONE,
   FWPS_STREAM_ACTION_NEED_MORE_DATA,
   FWPS_STREAM_ACTION_DROP_CONNECTION,
   FWPS_STREAM_ACTION_DEFER,
   FWPS_STREAM_ACTION_TYPE_MAX
} FWPS_STREAM_ACTION_TYPE;

typedef struct FWPS_STREAM_CALLOUT_IO_PACKET0_
{
   IN FWPS_STREAM_DATA0* streamData;
   IN SIZE_T missedBytes;
   OUT UINT32 countBytesRequired;
   OUT SIZE_T countBytesEnforced;
   OUT FWPS_STREAM_ACTION_TYPE streamAction;
} FWPS_STREAM_CALLOUT_IO_PACKET0;

NTSTATUS
NTAPI
FwpsStreamInjectAsync0(
   IN HANDLE injectionHandle,
   IN OPTIONAL HANDLE injectionContext,
   IN UINT32 flags,
   IN UINT64 flowId,
   IN UINT32 calloutId,
   IN UINT16 layerId,
   IN UINT32 streamFlags,
   IN OUT OPTIONAL NET_BUFFER_LIST* netBufferList,
   IN SIZE_T dataLength,
   IN FWPS_INJECT_COMPLETE0 completionFn,
   IN OPTIONAL HANDLE completionContext
   );

NTSTATUS
NTAPI
FwpsStreamContinue0(
    IN UINT64 flowId,
    IN UINT32 calloutId,
    IN UINT16 layerId,
    IN UINT32 streamFlags
    );

void
NTAPI
FwpsCopyStreamDataToBuffer0(
         IN const FWPS_STREAM_DATA0* calloutStreamData,
         IN OUT PVOID buffer,
         IN SIZE_T bytesToCopy,
         OUT SIZE_T* bytesCopied
         );

NTSTATUS
NTAPI
FwpsCloneStreamData0(
   IN OUT FWPS_STREAM_DATA0* calloutStreamData,
   IN OPTIONAL NDIS_HANDLE netBufferListPoolHandle,
   IN OPTIONAL NDIS_HANDLE netBufferPoolHandle,
   IN ULONG allocateCloneFlags,
   OUT NET_BUFFER_LIST** netBufferListChain
   );

void
NTAPI
FwpsDiscardClonedStreamData0(
   IN OUT NET_BUFFER_LIST* netBufferListChain,
   IN UINT32 allocateCloneFlags,
   IN BOOLEAN dispatchLevel
   );

#ifdef __cplusplus
}
#endif
#endif // (NTDDI_VERSION >= NTDDI_WIN6)
#endif // FWPSX_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\gdiplusenums.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//

#ifndef _GDIPLUSENUMS_H
#define _GDIPLUSENUMS_H

//--------------------------------------------------------------------------
// Default bezier flattening tolerance in device pixels.
//--------------------------------------------------------------------------

const float FlatnessDefault = 1.0f/4.0f;

//--------------------------------------------------------------------------
// Graphics and Container State cookies
//--------------------------------------------------------------------------

typedef UINT     GraphicsState;
typedef UINT     GraphicsContainer;

//--------------------------------------------------------------------------
// Fill mode constants
//--------------------------------------------------------------------------

enum FillMode
{
    FillModeAlternate,        // 0
    FillModeWinding           // 1
};

//--------------------------------------------------------------------------
// Quality mode constants
//--------------------------------------------------------------------------

enum QualityMode
{
    QualityModeInvalid   = -1,
    QualityModeDefault   = 0,
    QualityModeLow       = 1, // Best performance
    QualityModeHigh      = 2  // Best rendering quality
};

//--------------------------------------------------------------------------
// Alpha Compositing mode constants
//--------------------------------------------------------------------------

enum CompositingMode
{
    CompositingModeSourceOver,    // 0
    CompositingModeSourceCopy     // 1
};

//--------------------------------------------------------------------------
// Alpha Compositing quality constants
//--------------------------------------------------------------------------

enum CompositingQuality
{
    CompositingQualityInvalid          = QualityModeInvalid,
    CompositingQualityDefault          = QualityModeDefault,
    CompositingQualityHighSpeed        = QualityModeLow,
    CompositingQualityHighQuality      = QualityModeHigh,
    CompositingQualityGammaCorrected,
    CompositingQualityAssumeLinear
};

//--------------------------------------------------------------------------
// Unit constants
//--------------------------------------------------------------------------

enum Unit
{
    UnitWorld,      // 0 -- World coordinate (non-physical unit)
    UnitDisplay,    // 1 -- Variable -- for PageTransform only
    UnitPixel,      // 2 -- Each unit is one device pixel.
    UnitPoint,      // 3 -- Each unit is a printer's point, or 1/72 inch.
    UnitInch,       // 4 -- Each unit is 1 inch.
    UnitDocument,   // 5 -- Each unit is 1/300 inch.
    UnitMillimeter  // 6 -- Each unit is 1 millimeter.
};

//--------------------------------------------------------------------------
// MetafileFrameUnit
//
// The frameRect for creating a metafile can be specified in any of these
// units.  There is an extra frame unit value (MetafileFrameUnitGdi) so
// that units can be supplied in the same units that GDI expects for
// frame rects -- these units are in .01 (1/100ths) millimeter units
// as defined by GDI.
//--------------------------------------------------------------------------

enum MetafileFrameUnit
{
    MetafileFrameUnitPixel      = UnitPixel,
    MetafileFrameUnitPoint      = UnitPoint,
    MetafileFrameUnitInch       = UnitInch,
    MetafileFrameUnitDocument   = UnitDocument,
    MetafileFrameUnitMillimeter = UnitMillimeter,
    MetafileFrameUnitGdi                        // GDI compatible .01 MM units
};

//--------------------------------------------------------------------------
// Coordinate space identifiers
//--------------------------------------------------------------------------

enum CoordinateSpace
{
    CoordinateSpaceWorld,     // 0
    CoordinateSpacePage,      // 1
    CoordinateSpaceDevice     // 2
};

//--------------------------------------------------------------------------
// Various wrap modes for brushes
//--------------------------------------------------------------------------

enum WrapMode
{
    WrapModeTile,        // 0
    WrapModeTileFlipX,   // 1
    WrapModeTileFlipY,   // 2
    WrapModeTileFlipXY,  // 3
    WrapModeClamp        // 4
};

//--------------------------------------------------------------------------
// Various hatch styles
//--------------------------------------------------------------------------

enum HatchStyle
{
    HatchStyleHorizontal,                   // 0
    HatchStyleVertical,                     // 1
    HatchStyleForwardDiagonal,              // 2
    HatchStyleBackwardDiagonal,             // 3
    HatchStyleCross,                        // 4
    HatchStyleDiagonalCross,                // 5
    HatchStyle05Percent,                    // 6
    HatchStyle10Percent,                    // 7
    HatchStyle20Percent,                    // 8
    HatchStyle25Percent,                    // 9
    HatchStyle30Percent,                    // 10
    HatchStyle40Percent,                    // 11
    HatchStyle50Percent,                    // 12
    HatchStyle60Percent,                    // 13
    HatchStyle70Percent,                    // 14
    HatchStyle75Percent,                    // 15
    HatchStyle80Percent,                    // 16
    HatchStyle90Percent,                    // 17
    HatchStyleLightDownwardDiagonal,        // 18
    HatchStyleLightUpwardDiagonal,          // 19
    HatchStyleDarkDownwardDiagonal,         // 20
    HatchStyleDarkUpwardDiagonal,           // 21
    HatchStyleWideDownwardDiagonal,         // 22
    HatchStyleWideUpwardDiagonal,           // 23
    HatchStyleLightVertical,                // 24
    HatchStyleLightHorizontal,              // 25
    HatchStyleNarrowVertical,               // 26
    HatchStyleNarrowHorizontal,             // 27
    HatchStyleDarkVertical,                 // 28
    HatchStyleDarkHorizontal,               // 29
    HatchStyleDashedDownwardDiagonal,       // 30
    HatchStyleDashedUpwardDiagonal,         // 31
    HatchStyleDashedHorizontal,             // 32
    HatchStyleDashedVertical,               // 33
    HatchStyleSmallConfetti,                // 34
    HatchStyleLargeConfetti,                // 35
    HatchStyleZigZag,                       // 36
    HatchStyleWave,                         // 37
    HatchStyleDiagonalBrick,                // 38
    HatchStyleHorizontalBrick,              // 39
    HatchStyleWeave,                        // 40
    HatchStylePlaid,                        // 41
    HatchStyleDivot,                        // 42
    HatchStyleDottedGrid,                   // 43
    HatchStyleDottedDiamond,                // 44
    HatchStyleShingle,                      // 45
    HatchStyleTrellis,                      // 46
    HatchStyleSphere,                       // 47
    HatchStyleSmallGrid,                    // 48
    HatchStyleSmallCheckerBoard,            // 49
    HatchStyleLargeCheckerBoard,            // 50
    HatchStyleOutlinedDiamond,              // 51
    HatchStyleSolidDiamond,                 // 52

    HatchStyleTotal,   
    HatchStyleLargeGrid = HatchStyleCross,  // 4

    HatchStyleMin       = HatchStyleHorizontal,
    HatchStyleMax       = HatchStyleTotal - 1,
};

//--------------------------------------------------------------------------
// Dash style constants
//--------------------------------------------------------------------------

enum DashStyle
{
    DashStyleSolid,          // 0
    DashStyleDash,           // 1
    DashStyleDot,            // 2
    DashStyleDashDot,        // 3
    DashStyleDashDotDot,     // 4
    DashStyleCustom          // 5
};

//--------------------------------------------------------------------------
// Dash cap constants
//--------------------------------------------------------------------------

enum DashCap
{
    DashCapFlat             = 0,
    DashCapRound            = 2,
    DashCapTriangle         = 3
};

//--------------------------------------------------------------------------
// Line cap constants (only the lowest 8 bits are used).
//--------------------------------------------------------------------------

enum LineCap
{
    LineCapFlat             = 0,
    LineCapSquare           = 1,
    LineCapRound            = 2,
    LineCapTriangle         = 3,

    LineCapNoAnchor         = 0x10, // corresponds to flat cap
    LineCapSquareAnchor     = 0x11, // corresponds to square cap
    LineCapRoundAnchor      = 0x12, // corresponds to round cap
    LineCapDiamondAnchor    = 0x13, // corresponds to triangle cap
    LineCapArrowAnchor      = 0x14, // no correspondence

    LineCapCustom           = 0xff, // custom cap

    LineCapAnchorMask       = 0xf0  // mask to check for anchor or not.
};

//--------------------------------------------------------------------------
// Custom Line cap type constants
//--------------------------------------------------------------------------

enum CustomLineCapType
{
    CustomLineCapTypeDefault         = 0,
    CustomLineCapTypeAdjustableArrow = 1
};

//--------------------------------------------------------------------------
// Line join constants
//--------------------------------------------------------------------------

enum LineJoin
{
    LineJoinMiter        = 0,
    LineJoinBevel        = 1,
    LineJoinRound        = 2,
    LineJoinMiterClipped = 3
};

//--------------------------------------------------------------------------
// Path point types (only the lowest 8 bits are used.)
//  The lowest 3 bits are interpreted as point type
//  The higher 5 bits are reserved for flags.
//--------------------------------------------------------------------------

enum PathPointType
{
    PathPointTypeStart           = 0,    // move
    PathPointTypeLine            = 1,    // line
    PathPointTypeBezier          = 3,    // default Bezier (= cubic Bezier)
    PathPointTypePathTypeMask    = 0x07, // type mask (lowest 3 bits).
    PathPointTypeDashMode        = 0x10, // currently in dash mode.
    PathPointTypePathMarker      = 0x20, // a marker for the path.
    PathPointTypeCloseSubpath    = 0x80, // closed flag

    // Path types used for advanced path.

    PathPointTypeBezier3    = 3,         // cubic Bezier
};


//--------------------------------------------------------------------------
// WarpMode constants
//--------------------------------------------------------------------------

enum WarpMode
{
    WarpModePerspective,    // 0
    WarpModeBilinear        // 1
};

//--------------------------------------------------------------------------
// LineGradient Mode
//--------------------------------------------------------------------------

enum LinearGradientMode
{
    LinearGradientModeHorizontal,         // 0
    LinearGradientModeVertical,           // 1
    LinearGradientModeForwardDiagonal,    // 2
    LinearGradientModeBackwardDiagonal    // 3
};

//--------------------------------------------------------------------------
// Region Comine Modes
//--------------------------------------------------------------------------

enum CombineMode
{
    CombineModeReplace,     // 0
    CombineModeIntersect,   // 1
    CombineModeUnion,       // 2
    CombineModeXor,         // 3
    CombineModeExclude,     // 4
    CombineModeComplement   // 5 (Exclude From)
};

//--------------------------------------------------------------------------
 // Image types
//--------------------------------------------------------------------------

enum ImageType
{
    ImageTypeUnknown,   // 0
    ImageTypeBitmap,    // 1
    ImageTypeMetafile   // 2
};

//--------------------------------------------------------------------------
// Interpolation modes
//--------------------------------------------------------------------------

enum InterpolationMode
{
    InterpolationModeInvalid          = QualityModeInvalid,
    InterpolationModeDefault          = QualityModeDefault,
    InterpolationModeLowQuality       = QualityModeLow,
    InterpolationModeHighQuality      = QualityModeHigh,
    InterpolationModeBilinear,
    InterpolationModeBicubic,
    InterpolationModeNearestNeighbor,
    InterpolationModeHighQualityBilinear,
    InterpolationModeHighQualityBicubic
};

//--------------------------------------------------------------------------
// Pen types
//--------------------------------------------------------------------------

enum PenAlignment
{
    PenAlignmentCenter       = 0,
    PenAlignmentInset        = 1
};

//--------------------------------------------------------------------------
// Brush types
//--------------------------------------------------------------------------

enum BrushType
{
   BrushTypeSolidColor       = 0,
   BrushTypeHatchFill        = 1,
   BrushTypeTextureFill      = 2,
   BrushTypePathGradient     = 3,
   BrushTypeLinearGradient   = 4
};

//--------------------------------------------------------------------------
// Pen's Fill types
//--------------------------------------------------------------------------

enum PenType
{
   PenTypeSolidColor       = BrushTypeSolidColor,
   PenTypeHatchFill        = BrushTypeHatchFill,
   PenTypeTextureFill      = BrushTypeTextureFill,
   PenTypePathGradient     = BrushTypePathGradient,
   PenTypeLinearGradient   = BrushTypeLinearGradient,
   PenTypeUnknown          = -1
};

//--------------------------------------------------------------------------
// Matrix Order
//--------------------------------------------------------------------------

enum MatrixOrder
{
    MatrixOrderPrepend    = 0,
    MatrixOrderAppend     = 1
};

//--------------------------------------------------------------------------
// Generic font families
//--------------------------------------------------------------------------

enum GenericFontFamily
{
    GenericFontFamilySerif,
    GenericFontFamilySansSerif,
    GenericFontFamilyMonospace

};

//--------------------------------------------------------------------------
// FontStyle: face types and common styles
//--------------------------------------------------------------------------

enum FontStyle
{
    FontStyleRegular    = 0,
    FontStyleBold       = 1,
    FontStyleItalic     = 2,
    FontStyleBoldItalic = 3,
    FontStyleUnderline  = 4,
    FontStyleStrikeout  = 8
};

//---------------------------------------------------------------------------
// Smoothing Mode
//---------------------------------------------------------------------------

enum SmoothingMode
{
    SmoothingModeInvalid     = QualityModeInvalid,
    SmoothingModeDefault     = QualityModeDefault,
    SmoothingModeHighSpeed   = QualityModeLow,
    SmoothingModeHighQuality = QualityModeHigh,
    SmoothingModeNone,
    SmoothingModeAntiAlias
};

//---------------------------------------------------------------------------
// Pixel Format Mode
//---------------------------------------------------------------------------

enum PixelOffsetMode
{
    PixelOffsetModeInvalid     = QualityModeInvalid,
    PixelOffsetModeDefault     = QualityModeDefault,
    PixelOffsetModeHighSpeed   = QualityModeLow,
    PixelOffsetModeHighQuality = QualityModeHigh,
    PixelOffsetModeNone,    // No pixel offset
    PixelOffsetModeHalf     // Offset by -0.5, -0.5 for fast anti-alias perf
};

//---------------------------------------------------------------------------
// Text Rendering Hint
//---------------------------------------------------------------------------

enum TextRenderingHint
{
    TextRenderingHintSystemDefault = 0,            // Glyph with system default rendering hint
    TextRenderingHintSingleBitPerPixelGridFit,     // Glyph bitmap with hinting
    TextRenderingHintSingleBitPerPixel,            // Glyph bitmap without hinting
    TextRenderingHintAntiAliasGridFit,             // Glyph anti-alias bitmap with hinting
    TextRenderingHintAntiAlias,                    // Glyph anti-alias bitmap without hinting
    TextRenderingHintClearTypeGridFit              // Glyph CT bitmap with hinting
};

//---------------------------------------------------------------------------
// Metafile Types
//---------------------------------------------------------------------------

enum MetafileType
{
    MetafileTypeInvalid,            // Invalid metafile
    MetafileTypeWmf,                // Standard WMF
    MetafileTypeWmfPlaceable,       // Placeable WMF
    MetafileTypeEmf,                // EMF (not EMF+)
    MetafileTypeEmfPlusOnly,        // EMF+ without dual, down-level records
    MetafileTypeEmfPlusDual         // EMF+ with dual, down-level records
};

//---------------------------------------------------------------------------
// Specifies the type of EMF to record
//---------------------------------------------------------------------------

enum EmfType
{
    EmfTypeEmfOnly     = MetafileTypeEmf,          // no EMF+, only EMF
    EmfTypeEmfPlusOnly = MetafileTypeEmfPlusOnly,  // no EMF, only EMF+
    EmfTypeEmfPlusDual = MetafileTypeEmfPlusDual   // both EMF+ and EMF
};

//---------------------------------------------------------------------------
// EMF+ Persistent object types
//---------------------------------------------------------------------------

enum ObjectType
{
    ObjectTypeInvalid,
    ObjectTypeBrush,
    ObjectTypePen,
    ObjectTypePath,
    ObjectTypeRegion,
    ObjectTypeImage,
    ObjectTypeFont,
    ObjectTypeStringFormat,
    ObjectTypeImageAttributes,
    ObjectTypeCustomLineCap,

    ObjectTypeMax = ObjectTypeCustomLineCap,
    ObjectTypeMin = ObjectTypeBrush
};

inline BOOL
ObjectTypeIsValid(
    ObjectType      type
    )
{
    return ((type >= ObjectTypeMin) && (type <= ObjectTypeMax));
}

#ifndef _WIN32_WCE
//---------------------------------------------------------------------------
// EMF+ Records
//---------------------------------------------------------------------------

// We have to change the WMF record numbers so that they don't conflict with
// the EMF and EMF+ record numbers.

enum EmfPlusRecordType;

#define GDIP_EMFPLUS_RECORD_BASE        0x00004000
#define GDIP_WMF_RECORD_BASE            0x00010000
#define GDIP_WMF_RECORD_TO_EMFPLUS(n)   ((EmfPlusRecordType)((n) | GDIP_WMF_RECORD_BASE))
#define GDIP_EMFPLUS_RECORD_TO_WMF(n)   ((n) & (~GDIP_WMF_RECORD_BASE))
#define GDIP_IS_WMF_RECORDTYPE(n)       (((n) & GDIP_WMF_RECORD_BASE) != 0)

enum EmfPlusRecordType
{
   // Since we have to enumerate GDI records right along with GDI+ records,
   // We list all the GDI records here so that they can be part of the
   // same enumeration type which is used in the enumeration callback.

    WmfRecordTypeSetBkColor              = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETBKCOLOR),
    WmfRecordTypeSetBkMode               = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETBKMODE),
    WmfRecordTypeSetMapMode              = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETMAPMODE),
    WmfRecordTypeSetROP2                 = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETROP2),
    WmfRecordTypeSetRelAbs               = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETRELABS),
    WmfRecordTypeSetPolyFillMode         = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETPOLYFILLMODE),
    WmfRecordTypeSetStretchBltMode       = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETSTRETCHBLTMODE),
    WmfRecordTypeSetTextCharExtra        = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETTEXTCHAREXTRA),
    WmfRecordTypeSetTextColor            = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETTEXTCOLOR),
    WmfRecordTypeSetTextJustification    = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETTEXTJUSTIFICATION),
    WmfRecordTypeSetWindowOrg            = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETWINDOWORG),
    WmfRecordTypeSetWindowExt            = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETWINDOWEXT),
    WmfRecordTypeSetViewportOrg          = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETVIEWPORTORG),
    WmfRecordTypeSetViewportExt          = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETVIEWPORTEXT),
    WmfRecordTypeOffsetWindowOrg         = GDIP_WMF_RECORD_TO_EMFPLUS(META_OFFSETWINDOWORG),
    WmfRecordTypeScaleWindowExt          = GDIP_WMF_RECORD_TO_EMFPLUS(META_SCALEWINDOWEXT),
    WmfRecordTypeOffsetViewportOrg       = GDIP_WMF_RECORD_TO_EMFPLUS(META_OFFSETVIEWPORTORG),
    WmfRecordTypeScaleViewportExt        = GDIP_WMF_RECORD_TO_EMFPLUS(META_SCALEVIEWPORTEXT),
    WmfRecordTypeLineTo                  = GDIP_WMF_RECORD_TO_EMFPLUS(META_LINETO),
    WmfRecordTypeMoveTo                  = GDIP_WMF_RECORD_TO_EMFPLUS(META_MOVETO),
    WmfRecordTypeExcludeClipRect         = GDIP_WMF_RECORD_TO_EMFPLUS(META_EXCLUDECLIPRECT),
    WmfRecordTypeIntersectClipRect       = GDIP_WMF_RECORD_TO_EMFPLUS(META_INTERSECTCLIPRECT),
    WmfRecordTypeArc                     = GDIP_WMF_RECORD_TO_EMFPLUS(META_ARC),
    WmfRecordTypeEllipse                 = GDIP_WMF_RECORD_TO_EMFPLUS(META_ELLIPSE),
    WmfRecordTypeFloodFill               = GDIP_WMF_RECORD_TO_EMFPLUS(META_FLOODFILL),
    WmfRecordTypePie                     = GDIP_WMF_RECORD_TO_EMFPLUS(META_PIE),
    WmfRecordTypeRectangle               = GDIP_WMF_RECORD_TO_EMFPLUS(META_RECTANGLE),
    WmfRecordTypeRoundRect               = GDIP_WMF_RECORD_TO_EMFPLUS(META_ROUNDRECT),
    WmfRecordTypePatBlt                  = GDIP_WMF_RECORD_TO_EMFPLUS(META_PATBLT),
    WmfRecordTypeSaveDC                  = GDIP_WMF_RECORD_TO_EMFPLUS(META_SAVEDC),
    WmfRecordTypeSetPixel                = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETPIXEL),
    WmfRecordTypeOffsetClipRgn           = GDIP_WMF_RECORD_TO_EMFPLUS(META_OFFSETCLIPRGN),
    WmfRecordTypeTextOut                 = GDIP_WMF_RECORD_TO_EMFPLUS(META_TEXTOUT),
    WmfRecordTypeBitBlt                  = GDIP_WMF_RECORD_TO_EMFPLUS(META_BITBLT),
    WmfRecordTypeStretchBlt              = GDIP_WMF_RECORD_TO_EMFPLUS(META_STRETCHBLT),
    WmfRecordTypePolygon                 = GDIP_WMF_RECORD_TO_EMFPLUS(META_POLYGON),
    WmfRecordTypePolyline                = GDIP_WMF_RECORD_TO_EMFPLUS(META_POLYLINE),
    WmfRecordTypeEscape                  = GDIP_WMF_RECORD_TO_EMFPLUS(META_ESCAPE),
    WmfRecordTypeRestoreDC               = GDIP_WMF_RECORD_TO_EMFPLUS(META_RESTOREDC),
    WmfRecordTypeFillRegion              = GDIP_WMF_RECORD_TO_EMFPLUS(META_FILLREGION),
    WmfRecordTypeFrameRegion             = GDIP_WMF_RECORD_TO_EMFPLUS(META_FRAMEREGION),
    WmfRecordTypeInvertRegion            = GDIP_WMF_RECORD_TO_EMFPLUS(META_INVERTREGION),
    WmfRecordTypePaintRegion             = GDIP_WMF_RECORD_TO_EMFPLUS(META_PAINTREGION),
    WmfRecordTypeSelectClipRegion        = GDIP_WMF_RECORD_TO_EMFPLUS(META_SELECTCLIPREGION),
    WmfRecordTypeSelectObject            = GDIP_WMF_RECORD_TO_EMFPLUS(META_SELECTOBJECT),
    WmfRecordTypeSetTextAlign            = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETTEXTALIGN),
    WmfRecordTypeDrawText                = GDIP_WMF_RECORD_TO_EMFPLUS(0x062F),  // META_DRAWTEXT
    WmfRecordTypeChord                   = GDIP_WMF_RECORD_TO_EMFPLUS(META_CHORD),
    WmfRecordTypeSetMapperFlags          = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETMAPPERFLAGS),
    WmfRecordTypeExtTextOut              = GDIP_WMF_RECORD_TO_EMFPLUS(META_EXTTEXTOUT),
    WmfRecordTypeSetDIBToDev             = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETDIBTODEV),
    WmfRecordTypeSelectPalette           = GDIP_WMF_RECORD_TO_EMFPLUS(META_SELECTPALETTE),
    WmfRecordTypeRealizePalette          = GDIP_WMF_RECORD_TO_EMFPLUS(META_REALIZEPALETTE),
    WmfRecordTypeAnimatePalette          = GDIP_WMF_RECORD_TO_EMFPLUS(META_ANIMATEPALETTE),
    WmfRecordTypeSetPalEntries           = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETPALENTRIES),
    WmfRecordTypePolyPolygon             = GDIP_WMF_RECORD_TO_EMFPLUS(META_POLYPOLYGON),
    WmfRecordTypeResizePalette           = GDIP_WMF_RECORD_TO_EMFPLUS(META_RESIZEPALETTE),
    WmfRecordTypeDIBBitBlt               = GDIP_WMF_RECORD_TO_EMFPLUS(META_DIBBITBLT),
    WmfRecordTypeDIBStretchBlt           = GDIP_WMF_RECORD_TO_EMFPLUS(META_DIBSTRETCHBLT),
    WmfRecordTypeDIBCreatePatternBrush   = GDIP_WMF_RECORD_TO_EMFPLUS(META_DIBCREATEPATTERNBRUSH),
    WmfRecordTypeStretchDIB              = GDIP_WMF_RECORD_TO_EMFPLUS(META_STRETCHDIB),
    WmfRecordTypeExtFloodFill            = GDIP_WMF_RECORD_TO_EMFPLUS(META_EXTFLOODFILL),
    WmfRecordTypeSetLayout               = GDIP_WMF_RECORD_TO_EMFPLUS(0x0149),  // META_SETLAYOUT
    WmfRecordTypeResetDC                 = GDIP_WMF_RECORD_TO_EMFPLUS(0x014C),  // META_RESETDC
    WmfRecordTypeStartDoc                = GDIP_WMF_RECORD_TO_EMFPLUS(0x014D),  // META_STARTDOC
    WmfRecordTypeStartPage               = GDIP_WMF_RECORD_TO_EMFPLUS(0x004F),  // META_STARTPAGE
    WmfRecordTypeEndPage                 = GDIP_WMF_RECORD_TO_EMFPLUS(0x0050),  // META_ENDPAGE
    WmfRecordTypeAbortDoc                = GDIP_WMF_RECORD_TO_EMFPLUS(0x0052),  // META_ABORTDOC
    WmfRecordTypeEndDoc                  = GDIP_WMF_RECORD_TO_EMFPLUS(0x005E),  // META_ENDDOC
    WmfRecordTypeDeleteObject            = GDIP_WMF_RECORD_TO_EMFPLUS(META_DELETEOBJECT),
    WmfRecordTypeCreatePalette           = GDIP_WMF_RECORD_TO_EMFPLUS(META_CREATEPALETTE),
    WmfRecordTypeCreateBrush             = GDIP_WMF_RECORD_TO_EMFPLUS(0x00F8),  // META_CREATEBRUSH
    WmfRecordTypeCreatePatternBrush      = GDIP_WMF_RECORD_TO_EMFPLUS(META_CREATEPATTERNBRUSH),
    WmfRecordTypeCreatePenIndirect       = GDIP_WMF_RECORD_TO_EMFPLUS(META_CREATEPENINDIRECT),
    WmfRecordTypeCreateFontIndirect      = GDIP_WMF_RECORD_TO_EMFPLUS(META_CREATEFONTINDIRECT),
    WmfRecordTypeCreateBrushIndirect     = GDIP_WMF_RECORD_TO_EMFPLUS(META_CREATEBRUSHINDIRECT),
    WmfRecordTypeCreateBitmapIndirect    = GDIP_WMF_RECORD_TO_EMFPLUS(0x02FD),  // META_CREATEBITMAPINDIRECT
    WmfRecordTypeCreateBitmap            = GDIP_WMF_RECORD_TO_EMFPLUS(0x06FE),  // META_CREATEBITMAP
    WmfRecordTypeCreateRegion            = GDIP_WMF_RECORD_TO_EMFPLUS(META_CREATEREGION),

    EmfRecordTypeHeader                  = EMR_HEADER,
    EmfRecordTypePolyBezier              = EMR_POLYBEZIER,
    EmfRecordTypePolygon                 = EMR_POLYGON,
    EmfRecordTypePolyline                = EMR_POLYLINE,
    EmfRecordTypePolyBezierTo            = EMR_POLYBEZIERTO,
    EmfRecordTypePolyLineTo              = EMR_POLYLINETO,
    EmfRecordTypePolyPolyline            = EMR_POLYPOLYLINE,
    EmfRecordTypePolyPolygon             = EMR_POLYPOLYGON,
    EmfRecordTypeSetWindowExtEx          = EMR_SETWINDOWEXTEX,
    EmfRecordTypeSetWindowOrgEx          = EMR_SETWINDOWORGEX,
    EmfRecordTypeSetViewportExtEx        = EMR_SETVIEWPORTEXTEX,
    EmfRecordTypeSetViewportOrgEx        = EMR_SETVIEWPORTORGEX,
    EmfRecordTypeSetBrushOrgEx           = EMR_SETBRUSHORGEX,
    EmfRecordTypeEOF                     = EMR_EOF,
    EmfRecordTypeSetPixelV               = EMR_SETPIXELV,
    EmfRecordTypeSetMapperFlags          = EMR_SETMAPPERFLAGS,
    EmfRecordTypeSetMapMode              = EMR_SETMAPMODE,
    EmfRecordTypeSetBkMode               = EMR_SETBKMODE,
    EmfRecordTypeSetPolyFillMode         = EMR_SETPOLYFILLMODE,
    EmfRecordTypeSetROP2                 = EMR_SETROP2,
    EmfRecordTypeSetStretchBltMode       = EMR_SETSTRETCHBLTMODE,
    EmfRecordTypeSetTextAlign            = EMR_SETTEXTALIGN,
    EmfRecordTypeSetColorAdjustment      = EMR_SETCOLORADJUSTMENT,
    EmfRecordTypeSetTextColor            = EMR_SETTEXTCOLOR,
    EmfRecordTypeSetBkColor              = EMR_SETBKCOLOR,
    EmfRecordTypeOffsetClipRgn           = EMR_OFFSETCLIPRGN,
    EmfRecordTypeMoveToEx                = EMR_MOVETOEX,
    EmfRecordTypeSetMetaRgn              = EMR_SETMETARGN,
    EmfRecordTypeExcludeClipRect         = EMR_EXCLUDECLIPRECT,
    EmfRecordTypeIntersectClipRect       = EMR_INTERSECTCLIPRECT,
    EmfRecordTypeScaleViewportExtEx      = EMR_SCALEVIEWPORTEXTEX,
    EmfRecordTypeScaleWindowExtEx        = EMR_SCALEWINDOWEXTEX,
    EmfRecordTypeSaveDC                  = EMR_SAVEDC,
    EmfRecordTypeRestoreDC               = EMR_RESTOREDC,
    EmfRecordTypeSetWorldTransform       = EMR_SETWORLDTRANSFORM,
    EmfRecordTypeModifyWorldTransform    = EMR_MODIFYWORLDTRANSFORM,
    EmfRecordTypeSelectObject            = EMR_SELECTOBJECT,
    EmfRecordTypeCreatePen               = EMR_CREATEPEN,
    EmfRecordTypeCreateBrushIndirect     = EMR_CREATEBRUSHINDIRECT,
    EmfRecordTypeDeleteObject            = EMR_DELETEOBJECT,
    EmfRecordTypeAngleArc                = EMR_ANGLEARC,
    EmfRecordTypeEllipse                 = EMR_ELLIPSE,
    EmfRecordTypeRectangle               = EMR_RECTANGLE,
    EmfRecordTypeRoundRect               = EMR_ROUNDRECT,
    EmfRecordTypeArc                     = EMR_ARC,
    EmfRecordTypeChord                   = EMR_CHORD,
    EmfRecordTypePie                     = EMR_PIE,
    EmfRecordTypeSelectPalette           = EMR_SELECTPALETTE,
    EmfRecordTypeCreatePalette           = EMR_CREATEPALETTE,
    EmfRecordTypeSetPaletteEntries       = EMR_SETPALETTEENTRIES,
    EmfRecordTypeResizePalette           = EMR_RESIZEPALETTE,
    EmfRecordTypeRealizePalette          = EMR_REALIZEPALETTE,
    EmfRecordTypeExtFloodFill            = EMR_EXTFLOODFILL,
    EmfRecordTypeLineTo                  = EMR_LINETO,
    EmfRecordTypeArcTo                   = EMR_ARCTO,
    EmfRecordTypePolyDraw                = EMR_POLYDRAW,
    EmfRecordTypeSetArcDirection         = EMR_SETARCDIRECTION,
    EmfRecordTypeSetMiterLimit           = EMR_SETMITERLIMIT,
    EmfRecordTypeBeginPath               = EMR_BEGINPATH,
    EmfRecordTypeEndPath                 = EMR_ENDPATH,
    EmfRecordTypeCloseFigure             = EMR_CLOSEFIGURE,
    EmfRecordTypeFillPath                = EMR_FILLPATH,
    EmfRecordTypeStrokeAndFillPath       = EMR_STROKEANDFILLPATH,
    EmfRecordTypeStrokePath              = EMR_STROKEPATH,
    EmfRecordTypeFlattenPath             = EMR_FLATTENPATH,
    EmfRecordTypeWidenPath               = EMR_WIDENPATH,
    EmfRecordTypeSelectClipPath          = EMR_SELECTCLIPPATH,
    EmfRecordTypeAbortPath               = EMR_ABORTPATH,
    EmfRecordTypeReserved_069            = 69,  // Not Used
    EmfRecordTypeGdiComment              = EMR_GDICOMMENT,
    EmfRecordTypeFillRgn                 = EMR_FILLRGN,
    EmfRecordTypeFrameRgn                = EMR_FRAMERGN,
    EmfRecordTypeInvertRgn               = EMR_INVERTRGN,
    EmfRecordTypePaintRgn                = EMR_PAINTRGN,
    EmfRecordTypeExtSelectClipRgn        = EMR_EXTSELECTCLIPRGN,
    EmfRecordTypeBitBlt                  = EMR_BITBLT,
    EmfRecordTypeStretchBlt              = EMR_STRETCHBLT,
    EmfRecordTypeMaskBlt                 = EMR_MASKBLT,
    EmfRecordTypePlgBlt                  = EMR_PLGBLT,
    EmfRecordTypeSetDIBitsToDevice       = EMR_SETDIBITSTODEVICE,
    EmfRecordTypeStretchDIBits           = EMR_STRETCHDIBITS,
    EmfRecordTypeExtCreateFontIndirect   = EMR_EXTCREATEFONTINDIRECTW,
    EmfRecordTypeExtTextOutA             = EMR_EXTTEXTOUTA,
    EmfRecordTypeExtTextOutW             = EMR_EXTTEXTOUTW,
    EmfRecordTypePolyBezier16            = EMR_POLYBEZIER16,
    EmfRecordTypePolygon16               = EMR_POLYGON16,
    EmfRecordTypePolyline16              = EMR_POLYLINE16,
    EmfRecordTypePolyBezierTo16          = EMR_POLYBEZIERTO16,
    EmfRecordTypePolylineTo16            = EMR_POLYLINETO16,
    EmfRecordTypePolyPolyline16          = EMR_POLYPOLYLINE16,
    EmfRecordTypePolyPolygon16           = EMR_POLYPOLYGON16,
    EmfRecordTypePolyDraw16              = EMR_POLYDRAW16,
    EmfRecordTypeCreateMonoBrush         = EMR_CREATEMONOBRUSH,
    EmfRecordTypeCreateDIBPatternBrushPt = EMR_CREATEDIBPATTERNBRUSHPT,
    EmfRecordTypeExtCreatePen            = EMR_EXTCREATEPEN,
    EmfRecordTypePolyTextOutA            = EMR_POLYTEXTOUTA,
    EmfRecordTypePolyTextOutW            = EMR_POLYTEXTOUTW,
    EmfRecordTypeSetICMMode              = 98,  // EMR_SETICMMODE,
    EmfRecordTypeCreateColorSpace        = 99,  // EMR_CREATECOLORSPACE,
    EmfRecordTypeSetColorSpace           = 100, // EMR_SETCOLORSPACE,
    EmfRecordTypeDeleteColorSpace        = 101, // EMR_DELETECOLORSPACE,
    EmfRecordTypeGLSRecord               = 102, // EMR_GLSRECORD,
    EmfRecordTypeGLSBoundedRecord        = 103, // EMR_GLSBOUNDEDRECORD,
    EmfRecordTypePixelFormat             = 104, // EMR_PIXELFORMAT,
    EmfRecordTypeDrawEscape              = 105, // EMR_RESERVED_105,
    EmfRecordTypeExtEscape               = 106, // EMR_RESERVED_106,
    EmfRecordTypeStartDoc                = 107, // EMR_RESERVED_107,
    EmfRecordTypeSmallTextOut            = 108, // EMR_RESERVED_108,
    EmfRecordTypeForceUFIMapping         = 109, // EMR_RESERVED_109,
    EmfRecordTypeNamedEscape             = 110, // EMR_RESERVED_110,
    EmfRecordTypeColorCorrectPalette     = 111, // EMR_COLORCORRECTPALETTE,
    EmfRecordTypeSetICMProfileA          = 112, // EMR_SETICMPROFILEA,
    EmfRecordTypeSetICMProfileW          = 113, // EMR_SETICMPROFILEW,
    EmfRecordTypeAlphaBlend              = 114, // EMR_ALPHABLEND,
    EmfRecordTypeSetLayout               = 115, // EMR_SETLAYOUT,
    EmfRecordTypeTransparentBlt          = 116, // EMR_TRANSPARENTBLT,
    EmfRecordTypeReserved_117            = 117, // Not Used
    EmfRecordTypeGradientFill            = 118, // EMR_GRADIENTFILL,
    EmfRecordTypeSetLinkedUFIs           = 119, // EMR_RESERVED_119,
    EmfRecordTypeSetTextJustification    = 120, // EMR_RESERVED_120,
    EmfRecordTypeColorMatchToTargetW     = 121, // EMR_COLORMATCHTOTARGETW,
    EmfRecordTypeCreateColorSpaceW       = 122, // EMR_CREATECOLORSPACEW,
    EmfRecordTypeMax                     = 122,
    EmfRecordTypeMin                     = 1,

    // That is the END of the GDI EMF records.

    // Now we start the list of EMF+ records.  We leave quite
    // a bit of room here for the addition of any new GDI
    // records that may be added later.

    EmfPlusRecordTypeInvalid = GDIP_EMFPLUS_RECORD_BASE,
    EmfPlusRecordTypeHeader,
    EmfPlusRecordTypeEndOfFile,

    EmfPlusRecordTypeComment,

    EmfPlusRecordTypeGetDC,

    EmfPlusRecordTypeMultiFormatStart,
    EmfPlusRecordTypeMultiFormatSection,
    EmfPlusRecordTypeMultiFormatEnd,

    // For all persistent objects
    
    EmfPlusRecordTypeObject,

    // Drawing Records
    
    EmfPlusRecordTypeClear,
    EmfPlusRecordTypeFillRects,
    EmfPlusRecordTypeDrawRects,
    EmfPlusRecordTypeFillPolygon,
    EmfPlusRecordTypeDrawLines,
    EmfPlusRecordTypeFillEllipse,
    EmfPlusRecordTypeDrawEllipse,
    EmfPlusRecordTypeFillPie,
    EmfPlusRecordTypeDrawPie,
    EmfPlusRecordTypeDrawArc,
    EmfPlusRecordTypeFillRegion,
    EmfPlusRecordTypeFillPath,
    EmfPlusRecordTypeDrawPath,
    EmfPlusRecordTypeFillClosedCurve,
    EmfPlusRecordTypeDrawClosedCurve,
    EmfPlusRecordTypeDrawCurve,
    EmfPlusRecordTypeDrawBeziers,
    EmfPlusRecordTypeDrawImage,
    EmfPlusRecordTypeDrawImagePoints,
    EmfPlusRecordTypeDrawString,

    // Graphics State Records
    
    EmfPlusRecordTypeSetRenderingOrigin,
    EmfPlusRecordTypeSetAntiAliasMode,
    EmfPlusRecordTypeSetTextRenderingHint,
    EmfPlusRecordTypeSetTextContrast,
    EmfPlusRecordTypeSetInterpolationMode,
    EmfPlusRecordTypeSetPixelOffsetMode,
    EmfPlusRecordTypeSetCompositingMode,
    EmfPlusRecordTypeSetCompositingQuality,
    EmfPlusRecordTypeSave,
    EmfPlusRecordTypeRestore,
    EmfPlusRecordTypeBeginContainer,
    EmfPlusRecordTypeBeginContainerNoParams,
    EmfPlusRecordTypeEndContainer,
    EmfPlusRecordTypeSetWorldTransform,
    EmfPlusRecordTypeResetWorldTransform,
    EmfPlusRecordTypeMultiplyWorldTransform,
    EmfPlusRecordTypeTranslateWorldTransform,
    EmfPlusRecordTypeScaleWorldTransform,
    EmfPlusRecordTypeRotateWorldTransform,
    EmfPlusRecordTypeSetPageTransform,
    EmfPlusRecordTypeResetClip,
    EmfPlusRecordTypeSetClipRect,
    EmfPlusRecordTypeSetClipPath,
    EmfPlusRecordTypeSetClipRegion,
    EmfPlusRecordTypeOffsetClip,

    EmfPlusRecordTypeDrawDriverString,

    EmfPlusRecordTotal,

    EmfPlusRecordTypeMax = EmfPlusRecordTotal-1,
    EmfPlusRecordTypeMin = EmfPlusRecordTypeHeader,
};
#endif  // !_WIN32_WCE

//---------------------------------------------------------------------------
// StringFormatFlags
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// String format flags
//
//  DirectionRightToLeft          - For horizontal text, the reading order is
//                                  right to left. This value is called
//                                  the base embedding level by the Unicode
//                                  bidirectional engine.
//                                  For vertical text, columns are read from
//                                  right to left.
//                                  By default, horizontal or vertical text is
//                                  read from left to right.
//
//  DirectionVertical             - Individual lines of text are vertical. In
//                                  each line, characters progress from top to
//                                  bottom.
//                                  By default, lines of text are horizontal,
//                                  each new line below the previous line.
//
//  NoFitBlackBox                 - Allows parts of glyphs to overhang the
//                                  bounding rectangle.
//                                  By default glyphs are first aligned
//                                  inside the margines, then any glyphs which
//                                  still overhang the bounding box are
//                                  repositioned to avoid any overhang.
//                                  For example when an italic
//                                  lower case letter f in a font such as
//                                  Garamond is aligned at the far left of a
//                                  rectangle, the lower part of the f will
//                                  reach slightly further left than the left
//                                  edge of the rectangle. Setting this flag
//                                  will ensure the character aligns visually
//                                  with the lines above and below, but may
//                                  cause some pixels outside the formatting
//                                  rectangle to be clipped or painted.
//
//  DisplayFormatControl          - Causes control characters such as the
//                                  left-to-right mark to be shown in the
//                                  output with a representative glyph.
//
//  NoFontFallback                - Disables fallback to alternate fonts for
//                                  characters not supported in the requested
//                                  font. Any missing characters will be
//                                  be displayed with the fonts missing glyph,
//                                  usually an open square.
//
//  NoWrap                        - Disables wrapping of text between lines
//                                  when formatting within a rectangle.
//                                  NoWrap is implied when a point is passed
//                                  instead of a rectangle, or when the
//                                  specified rectangle has a zero line length.
//
//  NoClip                        - By default text is clipped to the
//                                  formatting rectangle. Setting NoClip
//                                  allows overhanging pixels to affect the
//                                  device outside the formatting rectangle.
//                                  Pixels at the end of the line may be
//                                  affected if the glyphs overhang their
//                                  cells, and either the NoFitBlackBox flag
//                                  has been set, or the glyph extends to far
//                                  to be fitted.
//                                  Pixels above/before the first line or
//                                  below/after the last line may be affected
//                                  if the glyphs extend beyond their cell
//                                  ascent / descent. This can occur rarely
//                                  with unusual diacritic mark combinations.

//---------------------------------------------------------------------------

enum StringFormatFlags
{
    StringFormatFlagsDirectionRightToLeft        = 0x00000001,
    StringFormatFlagsDirectionVertical           = 0x00000002,
    StringFormatFlagsNoFitBlackBox               = 0x00000004,
    StringFormatFlagsDisplayFormatControl        = 0x00000020,
    StringFormatFlagsNoFontFallback              = 0x00000400,
    StringFormatFlagsMeasureTrailingSpaces       = 0x00000800,
    StringFormatFlagsNoWrap                      = 0x00001000,
    StringFormatFlagsLineLimit                   = 0x00002000,

    StringFormatFlagsNoClip                      = 0x00004000
};

//---------------------------------------------------------------------------
// StringTrimming
//---------------------------------------------------------------------------

enum StringTrimming {
    StringTrimmingNone              = 0,
    StringTrimmingCharacter         = 1,
    StringTrimmingWord              = 2,
    StringTrimmingEllipsisCharacter = 3,
    StringTrimmingEllipsisWord      = 4,
    StringTrimmingEllipsisPath      = 5
};

//---------------------------------------------------------------------------
// National language digit substitution
//---------------------------------------------------------------------------

enum StringDigitSubstitute
{
    StringDigitSubstituteUser        = 0,  // As NLS setting
    StringDigitSubstituteNone        = 1,
    StringDigitSubstituteNational    = 2,
    StringDigitSubstituteTraditional = 3
};

//---------------------------------------------------------------------------
// Hotkey prefix interpretation
//---------------------------------------------------------------------------

enum HotkeyPrefix
{
    HotkeyPrefixNone        = 0,
    HotkeyPrefixShow        = 1,
    HotkeyPrefixHide        = 2
};

//---------------------------------------------------------------------------
// String alignment flags
//---------------------------------------------------------------------------

enum StringAlignment
{
    // Left edge for left-to-right text,
    // right for right-to-left text,
    // and top for vertical
    StringAlignmentNear   = 0,
    StringAlignmentCenter = 1,
    StringAlignmentFar    = 2
};

//---------------------------------------------------------------------------
// DriverStringOptions
//---------------------------------------------------------------------------

enum DriverStringOptions
{
    DriverStringOptionsCmapLookup             = 1,
    DriverStringOptionsVertical               = 2,
    DriverStringOptionsRealizedAdvance        = 4,
    DriverStringOptionsLimitSubpixel          = 8
};

//---------------------------------------------------------------------------
// Flush Intention flags
//---------------------------------------------------------------------------

enum FlushIntention
{
    FlushIntentionFlush = 0,        // Flush all batched rendering operations
    FlushIntentionSync = 1          // Flush all batched rendering operations
                                    // and wait for them to complete
};

//---------------------------------------------------------------------------
// Image encoder parameter related types
//---------------------------------------------------------------------------

enum EncoderParameterValueType
{
    EncoderParameterValueTypeByte           = 1,    // 8-bit unsigned int
    EncoderParameterValueTypeASCII          = 2,    // 8-bit byte containing one 7-bit ASCII
                                                    // code. NULL terminated.
    EncoderParameterValueTypeShort          = 3,    // 16-bit unsigned int
    EncoderParameterValueTypeLong           = 4,    // 32-bit unsigned int
    EncoderParameterValueTypeRational       = 5,    // Two Longs. The first Long is the
                                                    // numerator, the second Long expresses the
                                                    // denomintor.
    EncoderParameterValueTypeLongRange      = 6,    // Two longs which specify a range of
                                                    // integer values. The first Long specifies
                                                    // the lower end and the second one
                                                    // specifies the higher end. All values
                                                    // are inclusive at both ends
    EncoderParameterValueTypeUndefined      = 7,    // 8-bit byte that can take any value
                                                    // depending on field definition
    EncoderParameterValueTypeRationalRange  = 8     // Two Rationals. The first Rational
                                                    // specifies the lower end and the second
                                                    // specifies the higher end. All values
                                                    // are inclusive at both ends
};

//---------------------------------------------------------------------------
// Image encoder value types
//---------------------------------------------------------------------------

enum EncoderValue
{
    EncoderValueColorTypeCMYK,
    EncoderValueColorTypeYCCK,
    EncoderValueCompressionLZW,
    EncoderValueCompressionCCITT3,
    EncoderValueCompressionCCITT4,
    EncoderValueCompressionRle,
    EncoderValueCompressionNone,
    EncoderValueScanMethodInterlaced,
    EncoderValueScanMethodNonInterlaced,
    EncoderValueVersionGif87,
    EncoderValueVersionGif89,
    EncoderValueRenderProgressive,
    EncoderValueRenderNonProgressive,
    EncoderValueTransformRotate90,
    EncoderValueTransformRotate180,
    EncoderValueTransformRotate270,
    EncoderValueTransformFlipHorizontal,
    EncoderValueTransformFlipVertical,
    EncoderValueMultiFrame,
    EncoderValueLastFrame,
    EncoderValueFlush,
    EncoderValueFrameDimensionTime,
    EncoderValueFrameDimensionResolution,
    EncoderValueFrameDimensionPage
};

//---------------------------------------------------------------------------
// Conversion of Emf To WMF Bits flags
//---------------------------------------------------------------------------

enum EmfToWmfBitsFlags
{
    EmfToWmfBitsFlagsDefault          = 0x00000000,
    EmfToWmfBitsFlagsEmbedEmf         = 0x00000001,
    EmfToWmfBitsFlagsIncludePlaceable = 0x00000002,
    EmfToWmfBitsFlagsNoXORClip        = 0x00000004
};

#endif // !_GDIPLUSENUMS_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\gdiplusimaging.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//

#ifndef _GDIPLUSIMAGING_H
#define _GDIPLUSIMAGING_H

//---------------------------------------------------------------------------
// Image file format identifiers
//---------------------------------------------------------------------------

DEFINE_GUID(ImageFormatUndefined, 0xb96b3ca9,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(ImageFormatMemoryBMP, 0xb96b3caa,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(ImageFormatBMP, 0xb96b3cab,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(ImageFormatEMF, 0xb96b3cac,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(ImageFormatWMF, 0xb96b3cad,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(ImageFormatJPEG, 0xb96b3cae,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(ImageFormatPNG, 0xb96b3caf,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(ImageFormatGIF, 0xb96b3cb0,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(ImageFormatTIFF, 0xb96b3cb1,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(ImageFormatEXIF, 0xb96b3cb2,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(ImageFormatIcon, 0xb96b3cb5,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);

//---------------------------------------------------------------------------
// Predefined multi-frame dimension IDs
//---------------------------------------------------------------------------

DEFINE_GUID(FrameDimensionTime, 0x6aedbd6d,0x3fb5,0x418a,0x83,0xa6,0x7f,0x45,0x22,0x9d,0xc8,0x72);
DEFINE_GUID(FrameDimensionResolution, 0x84236f7b,0x3bd3,0x428f,0x8d,0xab,0x4e,0xa1,0x43,0x9c,0xa3,0x15);
DEFINE_GUID(FrameDimensionPage, 0x7462dc86,0x6180,0x4c7e,0x8e,0x3f,0xee,0x73,0x33,0xa7,0xa4,0x83);

//---------------------------------------------------------------------------
// Property sets
//---------------------------------------------------------------------------

DEFINE_GUID(FormatIDImageInformation, 0xe5836cbe,0x5eef,0x4f1d,0xac,0xde,0xae,0x4c,0x43,0xb6,0x08,0xce);
DEFINE_GUID(FormatIDJpegAppHeaders, 0x1c4afdcd,0x6177,0x43cf,0xab,0xc7,0x5f,0x51,0xaf,0x39,0xee,0x85);

//---------------------------------------------------------------------------
// Encoder parameter sets
//---------------------------------------------------------------------------

DEFINE_GUID(EncoderCompression, 0xe09d739d,0xccd4,0x44ee,0x8e,0xba,0x3f,0xbf,0x8b,0xe4,0xfc,0x58);
DEFINE_GUID(EncoderColorDepth, 0x66087055,0xad66,0x4c7c,0x9a,0x18,0x38,0xa2,0x31,0x0b,0x83,0x37);
DEFINE_GUID(EncoderScanMethod, 0x3a4e2661,0x3109,0x4e56,0x85,0x36,0x42,0xc1,0x56,0xe7,0xdc,0xfa);
DEFINE_GUID(EncoderVersion, 0x24d18c76,0x814a,0x41a4,0xbf,0x53,0x1c,0x21,0x9c,0xcc,0xf7,0x97);
DEFINE_GUID(EncoderRenderMethod, 0x6d42c53a,0x229a,0x4825,0x8b,0xb7,0x5c,0x99,0xe2,0xb9,0xa8,0xb8);
DEFINE_GUID(EncoderQuality, 0x1d5be4b5,0xfa4a,0x452d,0x9c,0xdd,0x5d,0xb3,0x51,0x05,0xe7,0xeb);
DEFINE_GUID(EncoderTransformation,0x8d0eb2d1,0xa58e,0x4ea8,0xaa,0x14,0x10,0x80,0x74,0xb7,0xb6,0xf9);
DEFINE_GUID(EncoderLuminanceTable,0xedb33bce,0x0266,0x4a77,0xb9,0x04,0x27,0x21,0x60,0x99,0xe7,0x17);
DEFINE_GUID(EncoderChrominanceTable,0xf2e455dc,0x09b3,0x4316,0x82,0x60,0x67,0x6a,0xda,0x32,0x48,0x1c);
DEFINE_GUID(EncoderSaveFlag,0x292266fc,0xac40,0x47bf,0x8c, 0xfc, 0xa8, 0x5b, 0x89, 0xa6, 0x55, 0xde);

DEFINE_GUID(CodecIImageBytes,0x025d1823,0x6c7d,0x447b,0xbb, 0xdb, 0xa3, 0xcb, 0xc3, 0xdf, 0xa2, 0xfc);

#ifdef _WIN32_WCE
interface DECLSPEC_UUID("025D1823-6C7D-447B-BBDB-A3CBC3DFA2FC")
#else
MIDL_INTERFACE("025D1823-6C7D-447B-BBDB-A3CBC3DFA2FC")
#endif  // _WIN32_WCE
IImageBytes : public IUnknown
{
public:
    // Return total number of bytes in the IStream

    STDMETHOD(CountBytes)(
        OUT UINT *pcb
        ) = 0;
    
    // Locks "cb" bytes, starting from "ulOffset" in the stream, and returns the
    // pointer to the beginning of the locked memory chunk in "ppvBytes"

    STDMETHOD(LockBytes)(
        IN UINT cb,
        IN ULONG ulOffset,
        OUT const VOID ** ppvBytes
        ) = 0;

    // Unlocks "cb" bytes, pointed by "pvBytes", starting from "ulOffset" in the
    // stream

    STDMETHOD(UnlockBytes)(
        IN const VOID *pvBytes,
        IN UINT cb,
        IN ULONG ulOffset
        ) = 0;
};

//--------------------------------------------------------------------------
// ImageCodecInfo structure
//--------------------------------------------------------------------------

class ImageCodecInfo
{
public:          
    CLSID Clsid;
    GUID  FormatID;
    const WCHAR* CodecName;
    const WCHAR* DllName;
    const WCHAR* FormatDescription;
    const WCHAR* FilenameExtension;
    const WCHAR* MimeType;
    DWORD Flags;
    DWORD Version;
    DWORD SigCount;
    DWORD SigSize;
    const BYTE* SigPattern;
    const BYTE* SigMask;
};

//--------------------------------------------------------------------------
// Information flags about image codecs
//--------------------------------------------------------------------------

enum ImageCodecFlags
{
    ImageCodecFlagsEncoder            = 0x00000001,
    ImageCodecFlagsDecoder            = 0x00000002,
    ImageCodecFlagsSupportBitmap      = 0x00000004,
    ImageCodecFlagsSupportVector      = 0x00000008,
    ImageCodecFlagsSeekableEncode     = 0x00000010,
    ImageCodecFlagsBlockingDecode     = 0x00000020,

    ImageCodecFlagsBuiltin            = 0x00010000,
    ImageCodecFlagsSystem             = 0x00020000,
    ImageCodecFlagsUser               = 0x00040000
};

//---------------------------------------------------------------------------
// Access modes used when calling Image::LockBits
//---------------------------------------------------------------------------

enum ImageLockMode
{
    ImageLockModeRead        = 0x0001,
    ImageLockModeWrite       = 0x0002,
    ImageLockModeUserInputBuf= 0x0004
};

//---------------------------------------------------------------------------
// Information about image pixel data
//---------------------------------------------------------------------------

class BitmapData
{
public:
    UINT Width;
    UINT Height;
    INT Stride;
    PixelFormat PixelFormat;
    VOID* Scan0;
    UINT_PTR Reserved;
};

//---------------------------------------------------------------------------
// Image flags
//---------------------------------------------------------------------------

enum ImageFlags
{
    ImageFlagsNone                = 0,

    // Low-word: shared with SINKFLAG_x

    ImageFlagsScalable            = 0x0001,
    ImageFlagsHasAlpha            = 0x0002,
    ImageFlagsHasTranslucent      = 0x0004,
    ImageFlagsPartiallyScalable   = 0x0008,

    // Low-word: color space definition

    ImageFlagsColorSpaceRGB       = 0x0010,
    ImageFlagsColorSpaceCMYK      = 0x0020,
    ImageFlagsColorSpaceGRAY      = 0x0040,
    ImageFlagsColorSpaceYCBCR     = 0x0080,
    ImageFlagsColorSpaceYCCK      = 0x0100,
 
    // Low-word: image size info

    ImageFlagsHasRealDPI          = 0x1000,
    ImageFlagsHasRealPixelSize    = 0x2000,

    // High-word

    ImageFlagsReadOnly            = 0x00010000,
    ImageFlagsCaching             = 0x00020000,
    ImageFlagsValid               = 0x00030000  //invalidate flag should be modified whenever a new flag is added
                                                // currently only these two can be set
};

enum RotateFlipType
{
    RotateNoneFlipNone = 0,
    Rotate90FlipNone   = 1,
    Rotate180FlipNone  = 2,
    Rotate270FlipNone  = 3,

    RotateNoneFlipX    = 4,
    Rotate90FlipX      = 5,
    Rotate180FlipX     = 6,
    Rotate270FlipX     = 7,

    RotateNoneFlipY    = Rotate180FlipX,
    Rotate90FlipY      = Rotate270FlipX,
    Rotate180FlipY     = RotateNoneFlipX,
    Rotate270FlipY     = Rotate90FlipX,

    RotateNoneFlipXY   = Rotate180FlipNone,
    Rotate90FlipXY     = Rotate270FlipNone,
    Rotate180FlipXY    = RotateNoneFlipNone,
    Rotate270FlipXY    = Rotate90FlipNone
};

//---------------------------------------------------------------------------
// Encoder Parameter structure
//---------------------------------------------------------------------------
class EncoderParameter
{
public:
    GUID    Guid;               // GUID of the parameter
    ULONG   NumberOfValues;     // Number of the parameter values
    ULONG   Type;               // Value type, like ValueTypeLONG  etc.
    VOID*   Value;              // A pointer to the parameter values
};

//---------------------------------------------------------------------------
// Encoder Parameters structure
//---------------------------------------------------------------------------
class EncoderParameters
{
public:
    UINT Count;                      // Number of parameters in this structure
    EncoderParameter Parameter[1];   // Parameter values
};

//---------------------------------------------------------------------------
// Property Item
//---------------------------------------------------------------------------
class PropertyItem
{
public:
    PROPID  id;                 // ID of this property
    ULONG   length;             // Length of the property value, in bytes
    WORD    type;               // Type of the value, as one of TAG_TYPE_XXX
                                // defined above
    UNALIGNED VOID * value;     // property value
};

//---------------------------------------------------------------------------
// Image property types 
//---------------------------------------------------------------------------
#define PropertyTagTypeByte        1
#define PropertyTagTypeASCII       2
#define PropertyTagTypeShort       3
#define PropertyTagTypeLong        4
#define PropertyTagTypeRational    5
#define PropertyTagTypeUndefined   7
#define PropertyTagTypeSLONG       9
#define PropertyTagTypeSRational  10

//---------------------------------------------------------------------------
// Image property ID tags
//---------------------------------------------------------------------------

#define PropertyTagExifIFD             0x8769
#define PropertyTagGpsIFD              0x8825

#define PropertyTagNewSubfileType      0x00FE
#define PropertyTagSubfileType         0x00FF
#define PropertyTagImageWidth          0x0100
#define PropertyTagImageHeight         0x0101
#define PropertyTagBitsPerSample       0x0102
#define PropertyTagCompression         0x0103
#define PropertyTagPhotometricInterp   0x0106
#define PropertyTagThreshHolding       0x0107
#define PropertyTagCellWidth           0x0108
#define PropertyTagCellHeight          0x0109
#define PropertyTagFillOrder           0x010A
#define PropertyTagDocumentName        0x010D
#define PropertyTagImageDescription    0x010E
#define PropertyTagEquipMake           0x010F
#define PropertyTagEquipModel          0x0110
#define PropertyTagStripOffsets        0x0111
#define PropertyTagOrientation         0x0112
#define PropertyTagSamplesPerPixel     0x0115
#define PropertyTagRowsPerStrip        0x0116
#define PropertyTagStripBytesCount     0x0117
#define PropertyTagMinSampleValue      0x0118
#define PropertyTagMaxSampleValue      0x0119
#define PropertyTagXResolution         0x011A   // Image resolution in width direction
#define PropertyTagYResolution         0x011B   // Image resolution in height direction
#define PropertyTagPlanarConfig        0x011C   // Image data arrangement
#define PropertyTagPageName            0x011D
#define PropertyTagXPosition           0x011E
#define PropertyTagYPosition           0x011F
#define PropertyTagFreeOffset          0x0120
#define PropertyTagFreeByteCounts      0x0121
#define PropertyTagGrayResponseUnit    0x0122
#define PropertyTagGrayResponseCurve   0x0123
#define PropertyTagT4Option            0x0124
#define PropertyTagT6Option            0x0125
#define PropertyTagResolutionUnit      0x0128   // Unit of X and Y resolution
#define PropertyTagPageNumber          0x0129
#define PropertyTagTransferFuncition   0x012D
#define PropertyTagSoftwareUsed        0x0131
#define PropertyTagDateTime            0x0132
#define PropertyTagArtist              0x013B
#define PropertyTagHostComputer        0x013C
#define PropertyTagPredictor           0x013D
#define PropertyTagWhitePoint          0x013E
#define PropertyTagPrimaryChromaticities 0x013F
#define PropertyTagColorMap            0x0140
#define PropertyTagHalftoneHints       0x0141
#define PropertyTagTileWidth           0x0142
#define PropertyTagTileLength          0x0143
#define PropertyTagTileOffset          0x0144
#define PropertyTagTileByteCounts      0x0145
#define PropertyTagInkSet              0x014C
#define PropertyTagInkNames            0x014D
#define PropertyTagNumberOfInks        0x014E
#define PropertyTagDotRange            0x0150
#define PropertyTagTargetPrinter       0x0151
#define PropertyTagExtraSamples        0x0152
#define PropertyTagSampleFormat        0x0153
#define PropertyTagSMinSampleValue     0x0154
#define PropertyTagSMaxSampleValue     0x0155
#define PropertyTagTransferRange       0x0156

#define PropertyTagJPEGProc            0x0200
#define PropertyTagJPEGInterFormat     0x0201
#define PropertyTagJPEGInterLength     0x0202
#define PropertyTagJPEGRestartInterval 0x0203
#define PropertyTagJPEGLosslessPredictors  0x0205
#define PropertyTagJPEGPointTransforms     0x0206
#define PropertyTagJPEGQTables         0x0207
#define PropertyTagJPEGDCTables        0x0208
#define PropertyTagJPEGACTables        0x0209

#define PropertyTagYCbCrCoefficients   0x0211
#define PropertyTagYCbCrSubsampling    0x0212
#define PropertyTagYCbCrPositioning    0x0213
#define PropertyTagREFBlackWhite       0x0214

#define PropertyTagICCProfile          0x8773   // This TAG is defined by ICC
                                                // for embedded ICC in TIFF
#define PropertyTagGamma               0x0301
#define PropertyTagICCProfileDescriptor 0x0302
#define PropertyTagSRGBRenderingIntent 0x0303

#define PropertyTagImageTitle          0x0320
#define PropertyTagCopyright           0x8298

// Extra TAGs (Like Adobe Image Information tags etc.)

#define PropertyTagResolutionXUnit           0x5001
#define PropertyTagResolutionYUnit           0x5002
#define PropertyTagResolutionXLengthUnit     0x5003
#define PropertyTagResolutionYLengthUnit     0x5004
#define PropertyTagPrintFlags                0x5005
#define PropertyTagPrintFlagsVersion         0x5006
#define PropertyTagPrintFlagsCrop            0x5007
#define PropertyTagPrintFlagsBleedWidth      0x5008
#define PropertyTagPrintFlagsBleedWidthScale 0x5009
#define PropertyTagHalftoneLPI               0x500A
#define PropertyTagHalftoneLPIUnit           0x500B
#define PropertyTagHalftoneDegree            0x500C
#define PropertyTagHalftoneShape             0x500D
#define PropertyTagHalftoneMisc              0x500E
#define PropertyTagHalftoneScreen            0x500F
#define PropertyTagJPEGQuality               0x5010
#define PropertyTagGridSize                  0x5011
#define PropertyTagThumbnailFormat           0x5012  // 1 = JPEG, 0 = RAW RGB
#define PropertyTagThumbnailWidth            0x5013
#define PropertyTagThumbnailHeight           0x5014
#define PropertyTagThumbnailColorDepth       0x5015
#define PropertyTagThumbnailPlanes           0x5016
#define PropertyTagThumbnailRawBytes         0x5017
#define PropertyTagThumbnailSize             0x5018
#define PropertyTagThumbnailCompressedSize   0x5019
#define PropertyTagColorTransferFunction     0x501A
#define PropertyTagThumbnailData             0x501B// RAW thumbnail bits in
                                                   // JPEG format or RGB format
                                                   // depends on
                                                   // PropertyTagThumbnailFormat

// Thumbnail related TAGs
                                                
#define PropertyTagThumbnailImageWidth       0x5020  // Thumbnail width
#define PropertyTagThumbnailImageHeight      0x5021  // Thumbnail height
#define PropertyTagThumbnailBitsPerSample    0x5022  // Number of bits per
                                                     // component
#define PropertyTagThumbnailCompression      0x5023  // Compression Scheme
#define PropertyTagThumbnailPhotometricInterp 0x5024 // Pixel composition
#define PropertyTagThumbnailImageDescription 0x5025  // Image Tile
#define PropertyTagThumbnailEquipMake        0x5026  // Manufacturer of Image
                                                     // Input equipment
#define PropertyTagThumbnailEquipModel       0x5027  // Model of Image input
                                                     // equipment
#define PropertyTagThumbnailStripOffsets     0x5028  // Image data location
#define PropertyTagThumbnailOrientation      0x5029  // Orientation of image
#define PropertyTagThumbnailSamplesPerPixel  0x502A  // Number of components
#define PropertyTagThumbnailRowsPerStrip     0x502B  // Number of rows per strip
#define PropertyTagThumbnailStripBytesCount  0x502C  // Bytes per compressed
                                                     // strip
#define PropertyTagThumbnailResolutionX      0x502D  // Resolution in width
                                                     // direction
#define PropertyTagThumbnailResolutionY      0x502E  // Resolution in height
                                                     // direction
#define PropertyTagThumbnailPlanarConfig     0x502F  // Image data arrangement
#define PropertyTagThumbnailResolutionUnit   0x5030  // Unit of X and Y
                                                     // Resolution
#define PropertyTagThumbnailTransferFunction 0x5031  // Transfer function
#define PropertyTagThumbnailSoftwareUsed     0x5032  // Software used
#define PropertyTagThumbnailDateTime         0x5033  // File change date and
                                                     // time
#define PropertyTagThumbnailArtist           0x5034  // Person who created the
                                                     // image
#define PropertyTagThumbnailWhitePoint       0x5035  // White point chromaticity
#define PropertyTagThumbnailPrimaryChromaticities 0x5036 
                                                     // Chromaticities of
                                                     // primaries
#define PropertyTagThumbnailYCbCrCoefficients 0x5037 // Color space transforma-
                                                     // tion coefficients
#define PropertyTagThumbnailYCbCrSubsampling 0x5038  // Subsampling ratio of Y
                                                     // to C
#define PropertyTagThumbnailYCbCrPositioning 0x5039  // Y and C position
#define PropertyTagThumbnailRefBlackWhite    0x503A  // Pair of black and white
                                                     // reference values
#define PropertyTagThumbnailCopyRight        0x503B  // CopyRight holder

#define PropertyTagLuminanceTable            0x5090
#define PropertyTagChrominanceTable          0x5091

#define PropertyTagFrameDelay                0x5100
#define PropertyTagLoopCount                 0x5101

#define PropertyTagPixelUnit         0x5110  // Unit specifier for pixel/unit
#define PropertyTagPixelPerUnitX     0x5111  // Pixels per unit in X
#define PropertyTagPixelPerUnitY     0x5112  // Pixels per unit in Y
#define PropertyTagPaletteHistogram  0x5113  // Palette histogram

// EXIF specific tag

#define PropertyTagExifExposureTime  0x829A
#define PropertyTagExifFNumber       0x829D

#define PropertyTagExifExposureProg  0x8822
#define PropertyTagExifSpectralSense 0x8824
#define PropertyTagExifISOSpeed      0x8827
#define PropertyTagExifOECF          0x8828

#define PropertyTagExifVer            0x9000
#define PropertyTagExifDTOrig         0x9003 // Date & time of original
#define PropertyTagExifDTDigitized    0x9004 // Date & time of digital data generation

#define PropertyTagExifCompConfig     0x9101
#define PropertyTagExifCompBPP        0x9102

#define PropertyTagExifShutterSpeed   0x9201
#define PropertyTagExifAperture       0x9202
#define PropertyTagExifBrightness     0x9203
#define PropertyTagExifExposureBias   0x9204
#define PropertyTagExifMaxAperture    0x9205
#define PropertyTagExifSubjectDist    0x9206
#define PropertyTagExifMeteringMode   0x9207
#define PropertyTagExifLightSource    0x9208
#define PropertyTagExifFlash          0x9209
#define PropertyTagExifFocalLength    0x920A
#define PropertyTagExifMakerNote      0x927C
#define PropertyTagExifUserComment    0x9286
#define PropertyTagExifDTSubsec       0x9290  // Date & Time subseconds
#define PropertyTagExifDTOrigSS       0x9291  // Date & Time original subseconds
#define PropertyTagExifDTDigSS        0x9292  // Date & TIme digitized subseconds

#define PropertyTagExifFPXVer         0xA000
#define PropertyTagExifColorSpace     0xA001
#define PropertyTagExifPixXDim        0xA002
#define PropertyTagExifPixYDim        0xA003
#define PropertyTagExifRelatedWav     0xA004  // related sound file
#define PropertyTagExifInterop        0xA005
#define PropertyTagExifFlashEnergy    0xA20B
#define PropertyTagExifSpatialFR      0xA20C  // Spatial Frequency Response
#define PropertyTagExifFocalXRes      0xA20E  // Focal Plane X Resolution
#define PropertyTagExifFocalYRes      0xA20F  // Focal Plane Y Resolution
#define PropertyTagExifFocalResUnit   0xA210  // Focal Plane Resolution Unit
#define PropertyTagExifSubjectLoc     0xA214
#define PropertyTagExifExposureIndex  0xA215
#define PropertyTagExifSensingMethod  0xA217
#define PropertyTagExifFileSource     0xA300
#define PropertyTagExifSceneType      0xA301
#define PropertyTagExifCfaPattern     0xA302

#define PropertyTagGpsVer             0x0000
#define PropertyTagGpsLatitudeRef     0x0001
#define PropertyTagGpsLatitude        0x0002
#define PropertyTagGpsLongitudeRef    0x0003
#define PropertyTagGpsLongitude       0x0004
#define PropertyTagGpsAltitudeRef     0x0005
#define PropertyTagGpsAltitude        0x0006
#define PropertyTagGpsGpsTime         0x0007
#define PropertyTagGpsGpsSatellites   0x0008
#define PropertyTagGpsGpsStatus       0x0009
#define PropertyTagGpsGpsMeasureMode  0x00A
#define PropertyTagGpsGpsDop          0x000B  // Measurement precision
#define PropertyTagGpsSpeedRef        0x000C
#define PropertyTagGpsSpeed           0x000D
#define PropertyTagGpsTrackRef        0x000E
#define PropertyTagGpsTrack           0x000F
#define PropertyTagGpsImgDirRef       0x0010
#define PropertyTagGpsImgDir          0x0011
#define PropertyTagGpsMapDatum        0x0012
#define PropertyTagGpsDestLatRef      0x0013
#define PropertyTagGpsDestLat         0x0014
#define PropertyTagGpsDestLongRef     0x0015
#define PropertyTagGpsDestLong        0x0016
#define PropertyTagGpsDestBearRef     0x0017
#define PropertyTagGpsDestBear        0x0018
#define PropertyTagGpsDestDistRef     0x0019
#define PropertyTagGpsDestDist        0x001A

// Exif v2.2 GPS tags
#define PropertyTagGpsGpsProcessingMethod   0x001B
#define PropertyTagGpsGpsArea         0x001C
#define PropertyTagGpsGpsDate         0x001D
#define PropertyTagGpsGpsDifferential 0x001E

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\fwptypes.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0543 */
/* Compiler settings for fwptypes.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __fwptypes_h__
#define __fwptypes_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

/* header files for imported files */
#include "wtypes.h"
#include "types.h"
#include "wfpalign.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_fwptypes_0000_0000 */
/* [local] */ 

#if _MSC_VER >=  800
#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4201)
#endif
#ifdef __midl
typedef struct _LUID
    {
    DWORD LowPart;
    LONG HighPart;
    } 	LUID;

typedef struct _LUID *PLUID;

#endif
typedef /* [v1_enum] */ 
enum FWP_DIRECTION_
    {	FWP_DIRECTION_OUTBOUND	= 0,
	FWP_DIRECTION_INBOUND	= ( FWP_DIRECTION_OUTBOUND + 1 ) ,
	FWP_DIRECTION_MAX	= ( FWP_DIRECTION_INBOUND + 1 ) 
    } 	FWP_DIRECTION;

typedef /* [v1_enum] */ 
enum FWP_IP_VERSION_
    {	FWP_IP_VERSION_V4	= 0,
	FWP_IP_VERSION_V6	= ( FWP_IP_VERSION_V4 + 1 ) ,
	FWP_IP_VERSION_MAX	= ( FWP_IP_VERSION_V6 + 1 ) 
    } 	FWP_IP_VERSION;

typedef /* [v1_enum] */ 
enum FWP_DATA_TYPE_
    {	FWP_EMPTY	= 0,
	FWP_UINT8	= ( FWP_EMPTY + 1 ) ,
	FWP_UINT16	= ( FWP_UINT8 + 1 ) ,
	FWP_UINT32	= ( FWP_UINT16 + 1 ) ,
	FWP_UINT64	= ( FWP_UINT32 + 1 ) ,
	FWP_INT8	= ( FWP_UINT64 + 1 ) ,
	FWP_INT16	= ( FWP_INT8 + 1 ) ,
	FWP_INT32	= ( FWP_INT16 + 1 ) ,
	FWP_INT64	= ( FWP_INT32 + 1 ) ,
	FWP_FLOAT	= ( FWP_INT64 + 1 ) ,
	FWP_DOUBLE	= ( FWP_FLOAT + 1 ) ,
	FWP_BYTE_ARRAY16_TYPE	= ( FWP_DOUBLE + 1 ) ,
	FWP_BYTE_BLOB_TYPE	= ( FWP_BYTE_ARRAY16_TYPE + 1 ) ,
	FWP_SID	= ( FWP_BYTE_BLOB_TYPE + 1 ) ,
	FWP_SECURITY_DESCRIPTOR_TYPE	= ( FWP_SID + 1 ) ,
	FWP_TOKEN_INFORMATION_TYPE	= ( FWP_SECURITY_DESCRIPTOR_TYPE + 1 ) ,
	FWP_TOKEN_ACCESS_INFORMATION_TYPE	= ( FWP_TOKEN_INFORMATION_TYPE + 1 ) ,
	FWP_UNICODE_STRING_TYPE	= ( FWP_TOKEN_ACCESS_INFORMATION_TYPE + 1 ) ,
	FWP_SINGLE_DATA_TYPE_MAX	= 0xff,
	FWP_V4_ADDR_MASK	= ( FWP_SINGLE_DATA_TYPE_MAX + 1 ) ,
	FWP_V6_ADDR_MASK	= ( FWP_V4_ADDR_MASK + 1 ) ,
	FWP_RANGE_TYPE	= ( FWP_V6_ADDR_MASK + 1 ) ,
	FWP_DATA_TYPE_MAX	= ( FWP_RANGE_TYPE + 1 ) 
    } 	FWP_DATA_TYPE;

typedef struct FWP_BYTE_ARRAY16_
    {
    UINT8 byteArray16[ 16 ];
    } 	FWP_BYTE_ARRAY16;

typedef struct FWP_BYTE_BLOB_
    {
    UINT32 size;
    UINT8 *data;
    } 	FWP_BYTE_BLOB;

typedef UNALIGNEDUINT64 FWP_TOKEN_INFORMATION;

typedef struct FWP_VALUE0_
    {
    FWP_DATA_TYPE type;
    union 
        {
         /* Empty union arm */ 
        UINT8 uint8;
        UINT16 uint16;
        UINT32 uint32;
        UNALIGNEDUINT64 *uint64;
        INT8 int8;
        INT16 int16;
        INT32 int32;
        INT64 *int64;
        float float32;
        double *double64;
        FWP_BYTE_ARRAY16 *byteArray16;
        FWP_BYTE_BLOB *byteBlob;
        SID *sid;
        FWP_BYTE_BLOB *sd;
        FWP_TOKEN_INFORMATION *tokenInformation;
        FWP_BYTE_BLOB *tokenAccessInformation;
        LPWSTR unicodeString;
        } 	;
    } 	FWP_VALUE0;

typedef /* [v1_enum] */ 
enum FWP_MATCH_TYPE_
    {	FWP_MATCH_EQUAL	= 0,
	FWP_MATCH_GREATER	= ( FWP_MATCH_EQUAL + 1 ) ,
	FWP_MATCH_LESS	= ( FWP_MATCH_GREATER + 1 ) ,
	FWP_MATCH_GREATER_OR_EQUAL	= ( FWP_MATCH_LESS + 1 ) ,
	FWP_MATCH_LESS_OR_EQUAL	= ( FWP_MATCH_GREATER_OR_EQUAL + 1 ) ,
	FWP_MATCH_RANGE	= ( FWP_MATCH_LESS_OR_EQUAL + 1 ) ,
	FWP_MATCH_FLAGS_ALL_SET	= ( FWP_MATCH_RANGE + 1 ) ,
	FWP_MATCH_FLAGS_ANY_SET	= ( FWP_MATCH_FLAGS_ALL_SET + 1 ) ,
	FWP_MATCH_FLAGS_NONE_SET	= ( FWP_MATCH_FLAGS_ANY_SET + 1 ) ,
	FWP_MATCH_EQUAL_CASE_INSENSITIVE	= ( FWP_MATCH_FLAGS_NONE_SET + 1 ) ,
	FWP_MATCH_TYPE_MAX	= ( FWP_MATCH_EQUAL_CASE_INSENSITIVE + 1 ) 
    } 	FWP_MATCH_TYPE;

typedef struct FWP_V4_ADDR_AND_MASK_
    {
    UINT32 addr;
    UINT32 mask;
    } 	FWP_V4_ADDR_AND_MASK;

#define FWP_V6_ADDR_SIZE (16)
typedef struct FWP_V6_ADDR_AND_MASK_
    {
    UINT8 addr[ 16 ];
    UINT8 prefixLength;
    } 	FWP_V6_ADDR_AND_MASK;

typedef struct FWP_RANGE0_
    {
    FWP_VALUE0 valueLow;
    FWP_VALUE0 valueHigh;
    } 	FWP_RANGE0;

#define FWP_ACTRL_MATCH_FILTER (0x00000001)

typedef struct FWP_CONDITION_VALUE0_
    {
    FWP_DATA_TYPE type;
    union 
        {
         /* Empty union arm */ 
        UINT8 uint8;
        UINT16 uint16;
        UINT32 uint32;
        UNALIGNEDUINT64 *uint64;
        INT8 int8;
        INT16 int16;
        INT32 int32;
        INT64 *int64;
        float float32;
        double *double64;
        FWP_BYTE_ARRAY16 *byteArray16;
        FWP_BYTE_BLOB *byteBlob;
        SID *sid;
        FWP_BYTE_BLOB *sd;
        FWP_TOKEN_INFORMATION *tokenInformation;
        FWP_BYTE_BLOB *tokenAccessInformation;
        LPWSTR unicodeString;
        FWP_V4_ADDR_AND_MASK *v4AddrMask;
        FWP_V6_ADDR_AND_MASK *v6AddrMask;
        FWP_RANGE0 *rangeValue;
        } 	;
    } 	FWP_CONDITION_VALUE0;

typedef /* [v1_enum] */ 
enum FWP_CLASSIFY_OPTION_TYPE_
    {	FWP_CLASSIFY_OPTION_MULTICAST_STATE	= 0,
	FWP_CLASSIFY_OPTION_LOOSE_SOURCE_MAPPING	= ( FWP_CLASSIFY_OPTION_MULTICAST_STATE + 1 ) ,
	FWP_CLASSIFY_OPTION_UNICAST_LIFETIME	= ( FWP_CLASSIFY_OPTION_LOOSE_SOURCE_MAPPING + 1 ) ,
	FWP_CLASSIFY_OPTION_MCAST_BCAST_LIFETIME	= ( FWP_CLASSIFY_OPTION_UNICAST_LIFETIME + 1 ) ,
	FWP_CLASSIFY_OPTION_MAX	= ( FWP_CLASSIFY_OPTION_MCAST_BCAST_LIFETIME + 1 ) 
    } 	FWP_CLASSIFY_OPTION_TYPE;

#define FWP_OPTION_VALUE_ALLOW_MULTICAST_STATE (0x00000000)
#define FWP_OPTION_VALUE_DENY_MULTICAST_STATE  (0x00000001)
#define FWP_OPTION_VALUE_ALLOW_GLOBAL_MULTICAST_STATE (0x00000002)
#define FWP_OPTION_VALUE_DISABLE_LOOSE_SOURCE (0x00000000)
#define FWP_OPTION_VALUE_ENABLE_LOOSE_SOURCE  (0x00000001)
#define FWP_ACTION_FLAG_TERMINATING     (0x00001000)
#define FWP_ACTION_FLAG_NON_TERMINATING (0x00002000)
#define FWP_ACTION_FLAG_CALLOUT         (0x00004000)
typedef UINT32 FWP_ACTION_TYPE;

#define FWP_ACTION_BLOCK \

   (0x00000001 | FWP_ACTION_FLAG_TERMINATING)
#define FWP_ACTION_PERMIT \

   (0x00000002 | FWP_ACTION_FLAG_TERMINATING)
#define FWP_ACTION_CALLOUT_TERMINATING \

   (0x00000003 | FWP_ACTION_FLAG_CALLOUT | FWP_ACTION_FLAG_TERMINATING)
#define FWP_ACTION_CALLOUT_INSPECTION \

   (0x00000004 | FWP_ACTION_FLAG_CALLOUT | FWP_ACTION_FLAG_NON_TERMINATING)
#define FWP_ACTION_CALLOUT_UNKNOWN \

   (0x00000005 | FWP_ACTION_FLAG_CALLOUT)
#define FWP_ACTION_CONTINUE \

   (0x00000006 | FWP_ACTION_FLAG_NON_TERMINATING)
#define FWP_ACTION_NONE \

   (0x00000007)
#define FWP_ACTION_NONE_NO_MATCH \

   (0x00000008)
#define FWP_CONDITION_FLAG_IS_LOOPBACK              (0x00000001)
#define FWP_CONDITION_FLAG_IS_IPSEC_SECURED         (0x00000002)
#define FWP_CONDITION_FLAG_IS_REAUTHORIZE           (0x00000004)
#define FWP_CONDITION_FLAG_IS_WILDCARD_BIND         (0x00000008)
#define FWP_CONDITION_FLAG_IS_RAW_ENDPOINT          (0x00000010)
#define FWP_CONDITION_FLAG_IS_FRAGMENT              (0x00000020)
#define FWP_CONDITION_FLAG_IS_FRAGMENT_GROUP        (0x00000040)
#define FWP_CONDITION_FLAG_IS_IPSEC_NATT_RECLASSIFY (0x00000080)
#define FWP_CONDITION_FLAG_REQUIRES_ALE_CLASSIFY    (0x00000100)
#define FWP_CONDITION_FLAG_IS_IMPLICIT_BIND         (0x00000200)
#if (NTDDI_VERSION >= NTDDI_WIN6SP1)
#define FWP_CONDITION_FLAG_IS_REASSEMBLED           (0x00000400)
#endif
typedef /* [v1_enum] */ 
enum FWP_FILTER_ENUM_TYPE_
    {	FWP_FILTER_ENUM_FULLY_CONTAINED	= 0,
	FWP_FILTER_ENUM_OVERLAPPING	= ( FWP_FILTER_ENUM_FULLY_CONTAINED + 1 ) ,
	FWP_FILTER_ENUM_TYPE_MAX	= ( FWP_FILTER_ENUM_OVERLAPPING + 1 ) 
    } 	FWP_FILTER_ENUM_TYPE;

#define FWP_FILTER_ENUM_FLAG_BEST_TERMINATING_MATCH (0x00000001)
#define FWP_FILTER_ENUM_FLAG_SORTED                 (0x00000002)
#define FWP_FILTER_ENUM_FLAG_BOOTTIME_ONLY          (0x00000004)
#define FWP_FILTER_ENUM_FLAG_INCLUDE_BOOTTIME       (0x00000008)
#define FWP_FILTER_ENUM_FLAG_INCLUDE_DISABLED       (0x00000010)
#define FWP_FILTER_ENUM_VALID_FLAGS \

   (FWP_FILTER_ENUM_FLAG_BEST_TERMINATING_MATCH | \

    FWP_FILTER_ENUM_FLAG_SORTED)
#define FWP_CALLOUT_FLAG_CONDITIONAL_ON_FLOW (0x00000001)
#define FWP_CALLOUT_FLAG_ALLOW_OFFLOAD       (0x00000002)
#if _MSC_VER >=  800
#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4201)
#endif
#endif


extern RPC_IF_HANDLE __MIDL_itf_fwptypes_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_fwptypes_0000_0000_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\getdeviceuniqueid.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//

#ifndef _GETDEVICEUNIQUEID_INC
#define _GETDEVICEUNIQUEID_INC


#ifdef __cplusplus
extern "C" {
#endif


#define GETDEVICEUNIQUEID_V1                1
#define GETDEVICEUNIQUEID_V1_MIN_APPDATA    8
#define GETDEVICEUNIQUEID_V1_OUTPUT         20


HRESULT
GetDeviceUniqueID(LPBYTE pbApplicationData, 
                  DWORD cbApplicationData, 
                  DWORD dwDeviceIDVersion,
                  LPBYTE pbDeviceIDOutput, 
                  DWORD *pcbDeviceIDOutput);


// GETDEVICEUNIQUEDEVICEID_V1               - constant which is passed as the dwDeviceIdVersion
// GETDEVICEUNIQUEDEVICEID_V1_MIN_APPDATA   - minimum length for pbApplicationData
// GETDEVICEUNIQUEDEVICEID_V1_OUTPUT        - minimum length for pbDeviceIDOutput, with no truncation
//
// This API returns an application specific hash of the device ID which is usable by an application for uniquely identifying 
// the device.  This is callable by untrusted processes.  
//
// The purpose of this API is to protect the privacy of the device.  Multiple applications need to use a device unique ID
// for communicating with servers, and from a privacy perspective, it is beneficial if those servers can not correlate data
// from the same device.  The API does not use any other information than the provided application data, so any one who passes
// in the same application data buffer will get the same hash.  The goal of this API is to make it easy for applications to 
// do the right thing, not to enforce security.  A "rogue" application which learns the application data that your application
// passes to this API can generate the same hash.  This is by design.
//
//      LPBYTE      pbApplicationData       - Application provided Salt data which is hashed with the DeviceID
//                                            As long as the same data is provided as this input, the same hash
//                                            will always be returned on the same device, even if the software is
//                                            reflashed and/or the device is cold booted.  This application data must
//                                            have a minimum length of 8 bytes and should be unique to the application.
//                                            If pbApplicationData is NULL, E_POINTER is returned.
//
//      DWORD       cbApplicationData       - Length of the application data provided above.  This length must be at least
//                                            8 bytes or the API will fail with E_INVALIDARG.
//      
//      DWORD       dwDeviceIDVersion       - This is the version number of the algorithm used for calculating 
//                                            the device id returned from this API.  Currently, the only defined 
//                                            version number is 1, and this parameter must have that value, or else
//                                            E_INVALIDARG will be returned.
//
//      LPBYTE      pbDeviceIDOutput        - Application provided output buffer for the device ID.  This buffer should be
//                                            at least GETDEVICEUNIQUEID_V1_OUTPUT bytes.  If the provided buffer is smaller
//                                            than the complete hash, the hash will be truncated and only the bytes that fit
//                                            will be copied into the output buffer.  If this pointer is NULL, the API returns
//                                            the maximum output hash length in pcbDeviceIDOutput.
//
//      DWORD *     pcbDeviceIDOutput       - In/Out paramater for the device ID length.  The input parameter is the length
//                                            of the application supplied buffer.  The output parameter is the number of bytes
//                                            written into the output buffer.  If this pointer is NULL, the API will fail with
//                                            E_POINTER.
//
// There are several possible combinations for pbDeviceIDOutput and pcbDeviceIDOutput, depending on how the application is
// using the method:
//
//      (determine size of required output buffer)
//      pbDeviceIDOutput is NULL
//      pcbDeviceIDOutput is non-NULL
//      *pcbDeviceIDOutput is (ignored)     - this returns S_OK, and places the required buffer size in *pcbDeviceIDOutput.
//
//      (output buffer is too small)
//      pbDeviceIDOutput is non-NULL
//      pcbDeviceIDOutput is non-NULL
//      *pcbDeviceIDOutput is too small     - this returns HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)), fills pbDeviceIDOutput with
//                                            as much data as will fit, and places the amount copied into *pcbDeviceIDOutput
//
//      (output buffer is large enough)
//      pbDeviceIDOutput is non-NULL
//      pcbDeviceIDOutput is non-NULL
//      *pcbDeviceIDOutput is large enough  - this returns S_OK, fills pbDeviceIDOutput with the output data, and places the amount
//                                            copied into *pcbDeviceIDOutput
//
// Sample call:
//
//  #define DEVICE_ID_LENGTH            20
//  #define APPLICATION_DATA            "@^!MyAppName!^@"
//  #define APPLICATION_DATA_LENGTH     15
//
//    HRESULT         hr              = NOERROR;
//    BYTE            rgDeviceId[DEVICE_ID_LENGTH];
//    DWORD           cbDeviceId      = sizeof(rgDeviceId);
//
//    hr = GetDeviceUniqueID(reinterpret_cast<PBYTE>(APPLICATION_DATA),
//                           APPLICATION_DATA_LENGTH,
//                           GETDEVICEUNIQUEID_V1,
//                           rgDeviceId,
//                           &cbDeviceId);
//    CHR(hr);
//
//    hr = DoSomethingWithDeviceId(rgDeviceId, cbDeviceId);
//        .
//        .
//        .


#ifdef __cplusplus
}
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\gpsapi.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
// ********************************************************
// GPS Intermediate Driver API
// ********************************************************

#ifndef _GPSAPI_H_
#define _GPSAPI_H_

#define GPS_MAX_SATELLITES      12
#define GPS_MAX_PREFIX_NAME     16
#define GPS_MAX_FRIENDLY_NAME   64

#define GPS_VERSION_1           1
#define GPS_VERSION_2           2
#define GPS_VERSION_CURRENT     GPS_VERSION_2

//
// Poll Version 1 drivers can handle some fields of GPS_POSITION structure
// Poll Version 2 drivers can handle all fields of GPS_POSITION structure
//
#define POLL_VERSION_1          1
#define POLL_VERSION_2          2

typedef enum {
    GPS_FIX_UNKNOWN = 0,
    GPS_FIX_2D,
    GPS_FIX_3D
}
GPS_FIX_TYPE;

typedef enum {
    GPS_FIX_SELECTION_UNKNOWN = 0,
    GPS_FIX_SELECTION_AUTO,
    GPS_FIX_SELECTION_MANUAL
}
GPS_FIX_SELECTION;

typedef enum {
    GPS_FIX_QUALITY_UNKNOWN = 0,
    GPS_FIX_QUALITY_GPS,
    GPS_FIX_QUALITY_DGPS
}
GPS_FIX_QUALITY;


//
// The following define the fix modes known to the operating system.
// The OEMs are free to define their own GPS_FIX_MODE starting with values
// greater than or equal to GPS_FIX_MODE_CUSTOM.
//
typedef enum {
    GPS_FIX_MODE_UNKNOWN = 0,
    GPS_FIX_MODE_MSA,
    GPS_FIX_MODE_MSB,        
    GPS_FIX_MODE_MSS,    
    
    // This must be the last entry for OS-supplied GPS_FIX_MODE_XXX values.
    // It's not an actual fix mode value - It's only a place holder
    // to keep count of values in the enum.
    GPS_FIX_MODE_COUNT
} 
GPS_FIX_MODE;

//
// This is the value which defines the start of the range where OEMs are 
// permitted to use their own fix mode values.
//
#define GPS_FIX_MODE_CUSTOM 256


//
// This structure contains the parameters to start the GPS device and trigger 
// a GPS fix operation. Pointer to this struct is used as pbParamData field in 
// calls to GPSSetDeviceParam function when dwParamName = GPS_START_FIX
//
typedef struct _GPS_START_FIX_CONFIG {
    DWORD dwFlags;
} GPS_START_FIX_CONFIG, *PGPS_START_FIX_CONFIG;



#define GPS_START_FIX          0
#define GPS_STOP_FIX           1
#define GPS_CONFIG_FIX_MODE    2
#define GPS_CONFIG_FIX_RATE    3
#define GPS_CONFIG_QOS         4
#define GPS_QUERY_FIX          5
#define GPS_CONFIG_COUNT       6 // Count of built-in GPS_PARAM values
#define GPS_CONFIG_CUSTOM    256 // This is the value which defines the start of 
                                 // the range where OEMs are permitted to use 
                                 // their own parameter values for use in 
                                 // GPSGetDeviceParam and GPSSetDeviceParam.

//
// This enumeration contains values that specify the current GPS Hardware state.
//
typedef enum {
    GPS_HW_STATE_UNKNOWN = 0,
    GPS_HW_STATE_ON,
    GPS_HW_STATE_IDLE
} GPS_HW_STATE;


//
// GPS_VALID_XXX bit flags in GPS_POSITION structure are valid.
//
#define GPS_VALID_UTC_TIME                                 0x00000001
#define GPS_VALID_LATITUDE                                 0x00000002
#define GPS_VALID_LONGITUDE                                0x00000004
#define GPS_VALID_SPEED                                    0x00000008
#define GPS_VALID_HEADING                                  0x00000010
#define GPS_VALID_MAGNETIC_VARIATION                       0x00000020
#define GPS_VALID_ALTITUDE_WRT_SEA_LEVEL                   0x00000040
#define GPS_VALID_ALTITUDE_WRT_ELLIPSOID                   0x00000080
#define GPS_VALID_POSITION_DILUTION_OF_PRECISION           0x00000100
#define GPS_VALID_HORIZONTAL_DILUTION_OF_PRECISION         0x00000200
#define GPS_VALID_VERTICAL_DILUTION_OF_PRECISION           0x00000400
#define GPS_VALID_SATELLITE_COUNT                          0x00000800
#define GPS_VALID_SATELLITES_USED_PRNS                     0x00001000
#define GPS_VALID_SATELLITES_IN_VIEW                       0x00002000
#define GPS_VALID_SATELLITES_IN_VIEW_PRNS                  0x00004000
#define GPS_VALID_SATELLITES_IN_VIEW_ELEVATION             0x00008000
#define GPS_VALID_SATELLITES_IN_VIEW_AZIMUTH               0x00010000
#define GPS_VALID_SATELLITES_IN_VIEW_SIGNAL_TO_NOISE_RATIO 0x00020000
#define GPS_VALID_POSITION_UNCERTAINTY_ERROR               0x00040000
#define GPS_VALID_FIX_MODE                                 0x00080000
#define GPS_VALID_FIX_ERROR                                0x00100000


//
// GPS_DEV_VALID_XXX bit flags in GPS_DEVICE_STATUS structure are valid. 
//
#define GPS_DEV_VALID_HW_STATE                             0x00000001 
#define GPS_DEV_VALID_EPH_SV_MASK                          0x00000002
#define GPS_DEV_VALID_ALM_SV_MASK                          0x00000004 
#define GPS_DEV_VALID_SAT_IN_VIEW_PRN                      0x00000008
#define GPS_DEV_VALID_SAT_IN_VIEW_CARRIER_TO_NOISE_RATIO   0x00000010
#define GPS_DEV_VALID_DEV_ERROR                            0x00000020


//
// GPS_DATA_FLAGS_XXX bit flags set in GPS_POSITION dwFlags field
// provide additional information about the state of the query.
// 

// Set when GPS hardware is not connected to GPSID and we 
// are returning cached data.
#define GPS_DATA_FLAGS_HARDWARE_OFF                        0x00000001


//
// GPSOpenDevice flags
//
#define GPS_OPEN_NO_HARDWARE_INIT                          0x00000001


//
// This structure contains estimated position error information returned in GPS_POSITION
// structure with dwVersion = GPS_VERSION_2. 
//
typedef struct _GPS_POSITION_ERROR
{
    //
    // Horizontal position uncertainty in meters of axis aligned with the angle 
    // specified in dWHorizontalErrorAngle of a two-dimension horizontal error ellipse. 
    // The value dwHorizontalConfidence gives the percentage of positions expected to 
    // fall within this ellipse, e.g. dwHorizontalConfidence = 39 indicates a 1-sigma 
    // error ellipse is given.
    //
    DWORD dwHorizontalErrorAlong;

    //
    // Angle of horizontal axis, with respect to true north, for a two-dimension 
    // horizontal error ellipse.
    //
    DWORD dwHorizontalErrorAngle;

    //
    // Horizontal position uncertainty in meters of axis perpendicular to angle 
    // specified in dwHorizontalErrorAngle of a two-dimension horizontal error ellipse. 
    // The value dwHorizontalConfidence gives the percentage of positions expected to 
    // fall within this ellipse, e.g. dwHorizontalConfidence = 39 indicates a 1-sigma 
    // error ellipse is given.
    //
    DWORD dwHorizontalErrorPerp;

    //
    // Vertical position uncertainty in meters with 1 sigma uncertainty. 
    // This value is always given as the 1-sigma estimate of vertical position error. 
    // It is not adjusted based on the value of  dwHorizontalConfidence.
    //
    DWORD dwVerticalError;

    //
    // Identifies the calculated probability in percent that the position estimate 
    // resides within the two dimension horizontal error ellipse specified by the 
    // three horizontal error values above. Note that appropriate rescaling of the 
    // ellipse dimensions can be used to achieve other confidence values. The special 
    // case where dwHorizontalErrorAlong are dwHorizontalErrorPerp set to the estimated 
    // 1 dimension standard deviation values will yield a confidence value of 39%. 
    // (2.45 sigma yield 95% confidence, 3.03 x sigma yields 99% confidence).
    //
    DWORD dwHorizontalConfidence;
} GPS_POSITION_ERROR, *PGPS_POSITION_ERROR;



//
// GPS_POSITION contains our latest physical coordinates, the time, 
// and satellites used in determining these coordinates. 
// dwVersion = GPS_VERSION_1 uses the fields upto (but NOT including) PositionUncertaintyError field.
// dwVersion = GPS_VERSION_2 uses all the defined fields upto (and including) dwFixError field.
// 
typedef struct _GPS_POSITION {
    DWORD dwVersion;             // Current version of GPSID client is using.
    DWORD dwSize;                // sizeof(_GPS_POSITION)

    // Not all fields in the structure below are guaranteed to be valid.  
    // Which fields are valid depend on GPS device being used, how stale the API allows
    // the data to be, and current signal.
    // Valid fields are specified in dwValidFields, based on GPS_VALID_XXX flags.
    DWORD dwValidFields;

    // Additional information about this location structure (GPS_DATA_FLAGS_XXX)
    DWORD dwFlags;
    
    //** Time related
    SYSTEMTIME stUTCTime;   //  UTC according to GPS clock.
    
    //** Position + heading related
    double dblLatitude;            // Degrees latitude.  North is positive
    double dblLongitude;           // Degrees longitude.  East is positive
    float  flSpeed;                // Speed in knots
    float  flHeading;              // Degrees heading (course made good).  True North=0
    double dblMagneticVariation;   // Magnetic variation.  East is positive
    float  flAltitudeWRTSeaLevel;  // Altitute with regards to sea level, in meters
    float  flAltitudeWRTEllipsoid; // Altitude with regards to ellipsoid, in meters

    //** Quality of this fix
    GPS_FIX_QUALITY     FixQuality;        // Where did we get fix from?
    GPS_FIX_TYPE        FixType;           // Is this 2d or 3d fix?
    GPS_FIX_SELECTION   SelectionType;     // Auto or manual selection between 2d or 3d mode
    float flPositionDilutionOfPrecision;   // Position Dilution Of Precision
    float flHorizontalDilutionOfPrecision; // Horizontal Dilution Of Precision
    float flVerticalDilutionOfPrecision;   // Vertical Dilution Of Precision

    //** Satellite information
    DWORD dwSatelliteCount;                                            // Number of satellites used in solution
    DWORD rgdwSatellitesUsedPRNs[GPS_MAX_SATELLITES];                  // PRN numbers of satellites used in the solution

    DWORD dwSatellitesInView;                                          // Number of satellites in view.  From 0-GPS_MAX_SATELLITES
    DWORD rgdwSatellitesInViewPRNs[GPS_MAX_SATELLITES];                // PRN numbers of satellites in view
    DWORD rgdwSatellitesInViewElevation[GPS_MAX_SATELLITES];           // Elevation of each satellite in view
    DWORD rgdwSatellitesInViewAzimuth[GPS_MAX_SATELLITES];             // Azimuth of each satellite in view
    DWORD rgdwSatellitesInViewSignalToNoiseRatio[GPS_MAX_SATELLITES];  // Signal to noise ratio of each satellite in view

    //** GPS API Extended fields (API v2)
    GPS_POSITION_ERROR PositionUncertaintyError;                       // Estimated position uncertainty error 
    GPS_FIX_MODE       FixMode;                                        // Fix mode used by the GPS hardware to calculate the position
    DWORD              dwFixError;                                     // GPS fix session error reported by GPS hardware
} GPS_POSITION, *PGPS_POSITION;


//
// This structure contains the status information about GPS Hardware used by GPSID. 
//
typedef struct _GPS_DEVICE_STATUS {
    DWORD        dwValidFields;
    GPS_HW_STATE ghsHardwareState;
    DWORD        dwEphSVMask;
    DWORD        dwAlmSVMask;
    DWORD        rgdwSatellitesInViewPRNs[GPS_MAX_SATELLITES];
    DWORD        rgdwSatellitesInViewCarrierToNoiseRatio[GPS_MAX_SATELLITES];
    DWORD        dwDeviceError;
} GPS_DEVICE_STATUS, *PGPS_DEVICE_STATUS;


//
// GPS_DEVICE contains information about the device driver and the
// service itself and is returned on a call to GPSGetDeviceState().
// States are indicated with SERVICE_STATE_XXX flags defined in service.h
// dwVersion = GPS_VERSION_1 uses the first 8 fields, upto gdsDeviceStatus. 
// dwVersion = GPS_VERSION_2 uses the first 9 fields, including gdsDeviceStatus.
// 
typedef struct _GPS_DEVICE {
    DWORD             dwVersion;                                 // Current version of GPSID client is using.
    DWORD             dwSize;                                    // sizeof this structure
    DWORD             dwServiceState;                            // State of the GPS Intermediate Driver service.  
    DWORD             dwDeviceState;                             // Status of the actual GPS device driver.
    FILETIME          ftLastDataReceived;                        // Last time that the actual GPS device sent information to the intermediate driver.
    WCHAR             szGPSDriverPrefix[GPS_MAX_PREFIX_NAME];    // Prefix name we are using to communicate to the base GPS driver
    WCHAR             szGPSMultiplexPrefix[GPS_MAX_PREFIX_NAME]; // Prefix name that GPS Intermediate Driver Multiplexer is running on
    WCHAR             szGPSFriendlyName[GPS_MAX_FRIENDLY_NAME];  // Friendly name real GPS device we are currently using
    GPS_DEVICE_STATUS gdsDeviceStatus;                           // Information about GPS Hardware
} *PGPS_DEVICE, GPS_DEVICE;

typedef struct _GPS_FIX_RATE {
    DWORD dwNumFixes;
    DWORD dwTimeBetweenFixes;
} GPS_FIX_RATE, *PGPS_FIX_RATE;


typedef struct _GPS_QOS {
    DWORD dwAccuracy;
    DWORD dwPerformance;
} GPS_QOS, *PGPS_QOS;


#ifdef __cplusplus
extern "C" {
#endif

HANDLE GPSOpenDevice(HANDLE hNewLocationData, HANDLE hDeviceStateChange, const WCHAR *szDeviceName, DWORD dwFlags);
DWORD  GPSCloseDevice(HANDLE hGPSDevice);
DWORD  GPSGetPosition(HANDLE hGPSDevice, GPS_POSITION *pGPSPosition, DWORD dwMaximumAge, DWORD dwFlags);
DWORD  GPSGetDeviceState(GPS_DEVICE *pGPSDevice);
DWORD  GPSGetDeviceParam(HANDLE hGPSDevice, DWORD dwParamName, PBYTE pbParamData, PDWORD pcbDataLen);
DWORD  GPSSetDeviceParam(HANDLE hGPSDevice, DWORD dwParamName, PBYTE pbParamData, DWORD cbDataLen);

#ifdef __cplusplus
}
#endif

#endif // _GPSAPI_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\gdipluspixelformats.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
#ifndef _GDIPLUSPIXELFORMATS_H
#define _GDIPLUSPIXELFORMATS_H

typedef DWORD ARGB;
typedef DWORDLONG ARGB64;

#define ALPHA_SHIFT 24
#define RED_SHIFT   16
#define GREEN_SHIFT 8
#define BLUE_SHIFT  0
#define ALPHA_MASK  ((ARGB) 0xff << ALPHA_SHIFT)

// In-memory pixel data formats:
// bits 0-7 = format index
// bits 8-15 = pixel size (in bits)
// bits 16-23 = flags
// bits 24-31 = reserved

typedef INT PixelFormat;

#define    PixelFormatIndexed      0x00010000 // Indexes into a palette
#define    PixelFormatGDI          0x00020000 // Is a GDI-supported format
#define    PixelFormatAlpha        0x00040000 // Has an alpha component
#define    PixelFormatPAlpha       0x00080000 // Pre-multiplied alpha
#define    PixelFormatExtended     0x00100000 // Extended color 16 bits/channel
#define    PixelFormatCanonical    0x00200000 

#define    PixelFormatUndefined       0
#define    PixelFormatDontCare        0

#define    PixelFormat1bppIndexed     (1 | ( 1 << 8) | PixelFormatIndexed | PixelFormatGDI)
#define    PixelFormat4bppIndexed     (2 | ( 4 << 8) | PixelFormatIndexed | PixelFormatGDI)
#define    PixelFormat8bppIndexed     (3 | ( 8 << 8) | PixelFormatIndexed | PixelFormatGDI)
#define    PixelFormat16bppRGB555     (5 | (16 << 8) | PixelFormatGDI)
#define    PixelFormat16bppRGB565     (6 | (16 << 8) | PixelFormatGDI)
#define    PixelFormat16bppARGB1555   (7 | (16 << 8) | PixelFormatAlpha | PixelFormatGDI)
#define    PixelFormat24bppRGB        (8 | (24 << 8) | PixelFormatGDI)
#define    PixelFormat32bppRGB        (9 | (32 << 8) | PixelFormatGDI)
#define    PixelFormat32bppARGB       (10 | (32 << 8) | PixelFormatAlpha | PixelFormatGDI | PixelFormatCanonical)
#define    PixelFormat32bppPARGB      (11 | (32 << 8) | PixelFormatAlpha | PixelFormatPAlpha | PixelFormatGDI)
#define    PixelFormat48bppRGB        (12 | (48 << 8) | PixelFormatExtended)
#define    PixelFormat64bppARGB       (13 | (64 << 8) | PixelFormatAlpha  | PixelFormatCanonical | PixelFormatExtended)
#define    PixelFormat64bppPARGB      (14 | (64 << 8) | PixelFormatAlpha  | PixelFormatPAlpha | PixelFormatExtended)
#define    PixelFormatMax             15

inline UINT
GetPixelFormatSize(
                   PixelFormat pixfmt
    )
{
    return (pixfmt >> 8) & 0xff;
}

inline BOOL
IsIndexedPixelFormat(
                     PixelFormat pixfmt
    )
{
    return (pixfmt & PixelFormatIndexed) != 0;
}

inline BOOL
IsAlphaPixelFormat(
                     PixelFormat pixfmt
)
{
   return (pixfmt & PixelFormatAlpha) != 0;
}

inline BOOL
IsExtendedPixelFormat(
                     PixelFormat pixfmt
    )
{
   return (pixfmt & PixelFormatExtended) != 0;
}

//--------------------------------------------------------------------------
// Determine if the Pixel Format is Canonical format:
//   PixelFormat32bppARGB
//   PixelFormat32bppPARGB
//   PixelFormat64bppARGB
//   PixelFormat64bppPARGB
//--------------------------------------------------------------------------

inline BOOL
IsCanonicalPixelFormat(
                     PixelFormat pixfmt
    )
{
   return (pixfmt & PixelFormatCanonical) != 0;
}

enum PaletteFlags
{
    PaletteFlagsHasAlpha    = 0x0001,
    PaletteFlagsGrayScale   = 0x0002,
    PaletteFlagsHalftone    = 0x0004
};

struct ColorPalette
{
public:
    UINT Flags;             // Palette flags
    UINT Count;             // Number of color entries
    ARGB Entries[1];        // Palette color entries
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\htmlhelp.h ===
/****************************************************************************
*                                                                           *
* HtmlHelp.h                                                                *
*                                                                           *
* Copyright (c) 1996-1997, Microsoft Corp. All rights reserved.             *
*                                                                           *
****************************************************************************/

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef __HTMLHELP_H__
#define __HTMLHELP_H__

#ifdef __cplusplus
extern "C" {
#endif  // __cplusplus

#if _MSC_VER < 1200
// Defines for Win64
#ifndef _WIN64
#define DWORD_PTR DWORD
#endif
#endif

// Commands to pass to HtmlHelp()

#define HH_DISPLAY_TOPIC        0x0000
#define HH_HELP_FINDER          0x0000  // WinHelp equivalent
#define HH_DISPLAY_TOC          0x0001  
#define HH_DISPLAY_INDEX        0x0002  
#define HH_DISPLAY_SEARCH       0x0003  
#define HH_SET_WIN_TYPE         0x0004
#define HH_GET_WIN_TYPE         0x0005
#define HH_GET_WIN_HANDLE       0x0006
#define HH_ENUM_INFO_TYPE       0x0007  // Get Info type name, call repeatedly to enumerate, -1 at end
#define HH_SET_INFO_TYPE        0x0008  // Add Info type to filter.
#define HH_SYNC                 0x0009
#define HH_RESERVED1            0x000A
#define HH_RESERVED2            0x000B
#define HH_RESERVED3            0x000C
#define HH_KEYWORD_LOOKUP       0x000D
#define HH_DISPLAY_TEXT_POPUP   0x000E  // display string resource id or text in a popup window
#define HH_HELP_CONTEXT         0x000F  // display mapped numeric value in dwData
#define HH_TP_HELP_CONTEXTMENU  0x0010  // text popup help, same as WinHelp HELP_CONTEXTMENU
#define HH_TP_HELP_WM_HELP      0x0011  // text popup help, same as WinHelp HELP_WM_HELP
#define HH_CLOSE_ALL            0x0012  // close all windows opened directly or indirectly by the caller
#define HH_ALINK_LOOKUP         0x0013  // ALink version of HH_KEYWORD_LOOKUP
#define HH_GET_LAST_ERROR       0x0014  // not currently implemented // See HHERROR.h
#define HH_ENUM_CATEGORY        0x0015	// Get category name, call repeatedly to enumerate, -1 at end
#define HH_ENUM_CATEGORY_IT     0x0016  // Get category info type members, call repeatedly to enumerate, -1 at end
#define HH_RESET_IT_FILTER      0x0017  // Clear the info type filter of all info types.
#define HH_SET_INCLUSIVE_FILTER 0x0018  // set inclusive filtering method for untyped topics to be included in display
#define HH_SET_EXCLUSIVE_FILTER 0x0019  // set exclusive filtering method for untyped topics to be excluded from display
#define HH_INITIALIZE            0x001C  // Initializes the help system.
#define HH_UNINITIALIZE          0x001D  // Uninitializes the help system.
#define HH_SET_QUERYSERVICE     0x001E  // Set the Host IQueryService interface
#define HH_PRETRANSLATEMESSAGE  0x00fd  // Pumps messages. (NULL, NULL, MSG*). 
#define HH_SET_GLOBAL_PROPERTY  0x00fc  // Set a global property. (NULL, NULL, HH_GPROP)
#define HH_SAFE_DISPLAY_TOPIC   0x0020  // private addition to the interface for InternetExplorer.

#define HHWIN_PROP_TAB_AUTOHIDESHOW (1 << 0)    // Automatically hide/show tri-pane window
#define HHWIN_PROP_ONTOP            (1 << 1)    // Top-most window
#define HHWIN_PROP_NOTITLEBAR       (1 << 2)    // no title bar
#define HHWIN_PROP_NODEF_STYLES     (1 << 3)    // no default window styles (only HH_WINTYPE.dwStyles)
#define HHWIN_PROP_NODEF_EXSTYLES   (1 << 4)    // no default extended window styles (only HH_WINTYPE.dwExStyles)
#define HHWIN_PROP_TRI_PANE         (1 << 5)    // use a tri-pane window
#define HHWIN_PROP_NOTB_TEXT        (1 << 6)    // no text on toolbar buttons
#define HHWIN_PROP_POST_QUIT        (1 << 7)    // post WM_QUIT message when window closes
#define HHWIN_PROP_AUTO_SYNC        (1 << 8)    // automatically ssync contents and index
#define HHWIN_PROP_TRACKING         (1 << 9)    // send tracking notification messages
#define HHWIN_PROP_TAB_SEARCH       (1 << 10)   // include search tab in navigation pane
#define HHWIN_PROP_TAB_HISTORY      (1 << 11)   // include history tab in navigation pane
#define HHWIN_PROP_TAB_FAVORITES    (1 << 12)   // include favorites tab in navigation pane
#define HHWIN_PROP_CHANGE_TITLE     (1 << 13)   // Put current HTML title in title bar
#define HHWIN_PROP_NAV_ONLY_WIN     (1 << 14)   // Only display the navigation window
#define HHWIN_PROP_NO_TOOLBAR       (1 << 15)   // Don't display a toolbar
#define HHWIN_PROP_MENU             (1 << 16)   // Menu
#define HHWIN_PROP_TAB_ADVSEARCH    (1 << 17)   // Advanced FTS UI.
#define HHWIN_PROP_USER_POS         (1 << 18)   // After initial creation, user controls window size/position
#define HHWIN_PROP_TAB_CUSTOM1      (1 << 19)   // Use custom tab #1
#define HHWIN_PROP_TAB_CUSTOM2      (1 << 20)   // Use custom tab #2
#define HHWIN_PROP_TAB_CUSTOM3      (1 << 21)   // Use custom tab #3
#define HHWIN_PROP_TAB_CUSTOM4      (1 << 22)   // Use custom tab #4
#define HHWIN_PROP_TAB_CUSTOM5      (1 << 23)   // Use custom tab #5
#define HHWIN_PROP_TAB_CUSTOM6      (1 << 24)   // Use custom tab #6
#define HHWIN_PROP_TAB_CUSTOM7      (1 << 25)   // Use custom tab #7
#define HHWIN_PROP_TAB_CUSTOM8      (1 << 26)   // Use custom tab #8
#define HHWIN_PROP_TAB_CUSTOM9      (1 << 27)   // Use custom tab #9
#define HHWIN_TB_MARGIN             (1 << 28)   // the window type has a margin

#define HHWIN_PARAM_PROPERTIES      (1 << 1)    // valid fsWinProperties
#define HHWIN_PARAM_STYLES          (1 << 2)    // valid dwStyles
#define HHWIN_PARAM_EXSTYLES        (1 << 3)    // valid dwExStyles
#define HHWIN_PARAM_RECT            (1 << 4)    // valid rcWindowPos
#define HHWIN_PARAM_NAV_WIDTH       (1 << 5)    // valid iNavWidth
#define HHWIN_PARAM_SHOWSTATE       (1 << 6)    // valid nShowState
#define HHWIN_PARAM_INFOTYPES       (1 << 7)    // valid apInfoTypes
#define HHWIN_PARAM_TB_FLAGS        (1 << 8)    // valid fsToolBarFlags
#define HHWIN_PARAM_EXPANSION       (1 << 9)    // valid fNotExpanded
#define HHWIN_PARAM_TABPOS          (1 << 10)   // valid tabpos
#define HHWIN_PARAM_TABORDER        (1 << 11)   // valid taborder
#define HHWIN_PARAM_HISTORY_COUNT   (1 << 12)   // valid cHistory
#define HHWIN_PARAM_CUR_TAB         (1 << 13)   // valid curNavType

#define HHWIN_BUTTON_EXPAND         (1 << 1)    // Expand/contract button
#define HHWIN_BUTTON_BACK           (1 << 2)    // Back button
#define HHWIN_BUTTON_FORWARD        (1 << 3)    // Forward button
#define HHWIN_BUTTON_STOP           (1 << 4)    // Stop button
#define HHWIN_BUTTON_REFRESH        (1 << 5)    // Refresh button
#define HHWIN_BUTTON_HOME           (1 << 6)    // Home button
#define HHWIN_BUTTON_BROWSE_FWD     (1 << 7)    // not implemented
#define HHWIN_BUTTON_BROWSE_BCK     (1 << 8)    // not implemented
#define HHWIN_BUTTON_NOTES          (1 << 9)    // not implemented
#define HHWIN_BUTTON_CONTENTS       (1 << 10)   // not implemented
#define HHWIN_BUTTON_SYNC           (1 << 11)   // Sync button
#define HHWIN_BUTTON_OPTIONS        (1 << 12)   // Options button
#define HHWIN_BUTTON_PRINT          (1 << 13)   // Print button
#define HHWIN_BUTTON_INDEX          (1 << 14)   // not implemented
#define HHWIN_BUTTON_SEARCH         (1 << 15)   // not implemented
#define HHWIN_BUTTON_HISTORY        (1 << 16)   // not implemented
#define HHWIN_BUTTON_FAVORITES      (1 << 17)   // not implemented
#define HHWIN_BUTTON_JUMP1          (1 << 18)
#define HHWIN_BUTTON_JUMP2          (1 << 19)
#define HHWIN_BUTTON_ZOOM           (1 << 20)
#define HHWIN_BUTTON_TOC_NEXT       (1 << 21)
#define HHWIN_BUTTON_TOC_PREV       (1 << 22)

#define HHWIN_DEF_BUTTONS           \
            (HHWIN_BUTTON_EXPAND |  \
             HHWIN_BUTTON_BACK |    \
             HHWIN_BUTTON_OPTIONS | \
             HHWIN_BUTTON_PRINT)

// Button IDs

#define IDTB_EXPAND             200
#define IDTB_CONTRACT           201
#define IDTB_STOP               202
#define IDTB_REFRESH            203
#define IDTB_BACK               204
#define IDTB_HOME               205
#define IDTB_SYNC               206
#define IDTB_PRINT              207
#define IDTB_OPTIONS            208
#define IDTB_FORWARD            209
#define IDTB_NOTES              210 // not implemented
#define IDTB_BROWSE_FWD         211
#define IDTB_BROWSE_BACK        212
#define IDTB_CONTENTS           213 // not implemented
#define IDTB_INDEX              214 // not implemented
#define IDTB_SEARCH             215 // not implemented
#define IDTB_HISTORY            216 // not implemented
#define IDTB_FAVORITES          217 // not implemented
#define IDTB_JUMP1              218
#define IDTB_JUMP2              219
#define IDTB_CUSTOMIZE          221
#define IDTB_ZOOM               222
#define IDTB_TOC_NEXT           223
#define IDTB_TOC_PREV           224

// Notification codes

#define HHN_FIRST       (0U-860U)
#define HHN_LAST        (0U-879U)

#define HHN_NAVCOMPLETE   (HHN_FIRST-0)
#define HHN_TRACK         (HHN_FIRST-1)
#define HHN_WINDOW_CREATE (HHN_FIRST-2)

typedef struct tagHHN_NOTIFY
{
    NMHDR   hdr;
    PCSTR   pszUrl; // Multi-byte, null-terminated string
} HHN_NOTIFY;

typedef struct tagHH_POPUP
{
    int       cbStruct;      // sizeof this structure
    HINSTANCE hinst;         // instance handle for string resource
    UINT      idString;      // string resource id, or text id if pszFile is specified in HtmlHelp call
    LPCTSTR   pszText;       // used if idString is zero
    POINT     pt;            // top center of popup window
    COLORREF  clrForeground; // use -1 for default
    COLORREF  clrBackground; // use -1 for default
    RECT      rcMargins;     // amount of space between edges of window and text, -1 for each member to ignore
    LPCTSTR   pszFont;       // facename, point size, char set, BOLD ITALIC UNDERLINE
} HH_POPUP;

typedef struct tagHH_AKLINK
{
    int       cbStruct;     // sizeof this structure
    BOOL      fReserved;    // must be FALSE (really!)
    LPCTSTR   pszKeywords;  // semi-colon separated keywords
    LPCTSTR   pszUrl;       // URL to jump to if no keywords found (may be NULL)
    LPCTSTR   pszMsgText;   // Message text to display in MessageBox if pszUrl is NULL and no keyword match
    LPCTSTR   pszMsgTitle;  // Message text to display in MessageBox if pszUrl is NULL and no keyword match
    LPCTSTR   pszWindow;    // Window to display URL in
    BOOL      fIndexOnFail; // Displays index if keyword lookup fails.
} HH_AKLINK;

enum {
    HHWIN_NAVTYPE_TOC,
    HHWIN_NAVTYPE_INDEX,
    HHWIN_NAVTYPE_SEARCH,
    HHWIN_NAVTYPE_FAVORITES,
    HHWIN_NAVTYPE_HISTORY,   // not implemented
    HHWIN_NAVTYPE_AUTHOR,
    HHWIN_NAVTYPE_CUSTOM_FIRST = 11
};

enum {
    IT_INCLUSIVE,
    IT_EXCLUSIVE,
    IT_HIDDEN,
};

typedef struct tagHH_ENUM_IT
{
    int       cbStruct;          // size of this structure
    int       iType;             // the type of the information type ie. Inclusive, Exclusive, or Hidden
    LPCSTR    pszCatName;        // Set to the name of the Category to enumerate the info types in a category; else NULL
    LPCSTR    pszITName;         // volitile pointer to the name of the infotype. Allocated by call. Caller responsible for freeing
    LPCSTR    pszITDescription;  // volitile pointer to the description of the infotype.
} HH_ENUM_IT, *PHH_ENUM_IT;

typedef struct tagHH_ENUM_CAT
{
    int       cbStruct;          // size of this structure
    LPCSTR    pszCatName;        // volitile pointer to the category name
    LPCSTR    pszCatDescription; // volitile pointer to the category description
} HH_ENUM_CAT, *PHH_ENUM_CAT;

typedef struct tagHH_SET_INFOTYPE
{
    int       cbStruct;          // the size of this structure
    LPCSTR    pszCatName;        // the name of the category, if any, the InfoType is a member of.
    LPCSTR    pszInfoTypeName;   // the name of the info type to add to the filter
} HH_SET_INFOTYPE, *PHH_SET_INFOTYPE;

typedef DWORD HH_INFOTYPE;
typedef HH_INFOTYPE* PHH_INFOTYPE;

enum {
    HHWIN_NAVTAB_TOP,
    HHWIN_NAVTAB_LEFT,
    HHWIN_NAVTAB_BOTTOM,
};

#define HH_MAX_TABS 19  // maximum number of tabs

enum {
    HH_TAB_CONTENTS,
    HH_TAB_INDEX,
    HH_TAB_SEARCH,
    HH_TAB_FAVORITES,
    HH_TAB_HISTORY,
    HH_TAB_AUTHOR,

    HH_TAB_CUSTOM_FIRST = 11,
    HH_TAB_CUSTOM_LAST = HH_MAX_TABS
};

#define HH_MAX_TABS_CUSTOM (HH_TAB_CUSTOM_LAST - HH_TAB_CUSTOM_FIRST + 1)

// HH_DISPLAY_SEARCH Command Related Structures and Constants

#define HH_FTS_DEFAULT_PROXIMITY (-1)

typedef struct tagHH_FTS_QUERY
{
    int cbStruct;            // Sizeof structure in bytes.
    BOOL fUniCodeStrings;    // TRUE if all strings are unicode.
    LPCTSTR pszSearchQuery;  // String containing the search query.
    LONG iProximity;         // Word proximity.
    BOOL fStemmedSearch;     // TRUE for StemmedSearch only.
    BOOL fTitleOnly;         // TRUE for Title search only.
    BOOL fExecute;           // TRUE to initiate the search.
    LPCTSTR pszWindow;       // Window to display in
} HH_FTS_QUERY;

// HH_WINTYPE Structure

typedef struct tagHH_WINTYPE {
    int     cbStruct;        // IN: size of this structure including all Information Types
    BOOL    fUniCodeStrings; // IN/OUT: TRUE if all strings are in UNICODE
    LPCTSTR pszType;         // IN/OUT: Name of a type of window
    DWORD   fsValidMembers;  // IN: Bit flag of valid members (HHWIN_PARAM_)
    DWORD   fsWinProperties; // IN/OUT: Properties/attributes of the window (HHWIN_)

    LPCTSTR pszCaption;      // IN/OUT: Window title
    DWORD   dwStyles;        // IN/OUT: Window styles
    DWORD   dwExStyles;      // IN/OUT: Extended Window styles
    RECT    rcWindowPos;     // IN: Starting position, OUT: current position
    int     nShowState;      // IN: show state (e.g., SW_SHOW)

    HWND  hwndHelp;          // OUT: window handle
    HWND  hwndCaller;        // OUT: who called this window

    HH_INFOTYPE* paInfoTypes;  // IN: Pointer to an array of Information Types

    // The following members are only valid if HHWIN_PROP_TRI_PANE is set

    HWND  hwndToolBar;      // OUT: toolbar window in tri-pane window
    HWND  hwndNavigation;   // OUT: navigation window in tri-pane window
    HWND  hwndHTML;         // OUT: window displaying HTML in tri-pane window
    int   iNavWidth;        // IN/OUT: width of navigation window
    RECT  rcHTML;           // OUT: HTML window coordinates

    LPCTSTR pszToc;         // IN: Location of the table of contents file
    LPCTSTR pszIndex;       // IN: Location of the index file
    LPCTSTR pszFile;        // IN: Default location of the html file
    LPCTSTR pszHome;        // IN/OUT: html file to display when Home button is clicked
    DWORD   fsToolBarFlags; // IN: flags controling the appearance of the toolbar
    BOOL    fNotExpanded;   // IN: TRUE/FALSE to contract or expand, OUT: current state
    int     curNavType;     // IN/OUT: UI to display in the navigational pane
    int     tabpos;         // IN/OUT: HHWIN_NAVTAB_TOP, HHWIN_NAVTAB_LEFT, or HHWIN_NAVTAB_BOTTOM
    int     idNotify;       // IN: ID to use for WM_NOTIFY messages
    BYTE    tabOrder[HH_MAX_TABS + 1];    // IN/OUT: tab order: Contents, Index, Search, History, Favorites, Reserved 1-5, Custom tabs
    int     cHistory;       // IN/OUT: number of history items to keep (default is 30)
    LPCTSTR pszJump1;       // Text for HHWIN_BUTTON_JUMP1
    LPCTSTR pszJump2;       // Text for HHWIN_BUTTON_JUMP2
    LPCTSTR pszUrlJump1;    // URL for HHWIN_BUTTON_JUMP1
    LPCTSTR pszUrlJump2;    // URL for HHWIN_BUTTON_JUMP2
    RECT    rcMinSize;      // Minimum size for window (ignored in version 1)
    int     cbInfoTypes;    // size of paInfoTypes;
    LPCTSTR pszCustomTabs;  // multiple zero-terminated strings
} HH_WINTYPE, *PHH_WINTYPE;

enum {
    HHACT_TAB_CONTENTS,
    HHACT_TAB_INDEX,
    HHACT_TAB_SEARCH,
    HHACT_TAB_HISTORY,
    HHACT_TAB_FAVORITES,

    HHACT_EXPAND,
    HHACT_CONTRACT,
    HHACT_BACK,
    HHACT_FORWARD,
    HHACT_STOP,
    HHACT_REFRESH,
    HHACT_HOME,
    HHACT_SYNC,
    HHACT_OPTIONS,
    HHACT_PRINT,
    HHACT_HIGHLIGHT,
    HHACT_CUSTOMIZE,
    HHACT_JUMP1,
    HHACT_JUMP2,
    HHACT_ZOOM,
    HHACT_TOC_NEXT,
    HHACT_TOC_PREV,
    HHACT_NOTES,

    HHACT_LAST_ENUM,
};

typedef struct tagHHNTRACK
{
    NMHDR   hdr;
    PCSTR   pszCurUrl;      // Multi-byte, null-terminated string
    int     idAction;       // HHACT_ value
    HH_WINTYPE* phhWinType; // Current window type structure
} HHNTRACK;

HWND
WINAPI
HtmlHelpA(
    HWND hwndCaller,
    LPCSTR pszFile,
    UINT uCommand,
    DWORD_PTR dwData
    );

HWND
WINAPI
HtmlHelpW(
    HWND hwndCaller,
    LPCWSTR pszFile,
    UINT uCommand,
    DWORD_PTR dwData
    );
#ifdef UNICODE
#define HtmlHelp  HtmlHelpW
#else
#define HtmlHelp  HtmlHelpA
#endif // !UNICODE

// Use the following for GetProcAddress to load from hhctrl.ocx

#define ATOM_HTMLHELP_API_ANSI    (LPTSTR)((DWORD)((WORD)(14)))
#define ATOM_HTMLHELP_API_UNICODE (LPTSTR)((DWORD)((WORD)(15)))

///////////////////////////////////////////////////////////////////////////////
//
// Global Control Properties. 
//
typedef enum tagHH_GPROPID
{
    HH_GPROPID_SINGLETHREAD=1,      // VARIANT_BOOL: True for single thread
    HH_GPROPID_TOOLBAR_MARGIN=2,    // long: Provides a left/right margin around the toolbar.
    HH_GPROPID_UI_LANGUAGE=3,       // long: LangId of the UI.
    HH_GPROPID_CURRENT_SUBSET=4,    // BSTR: Current subset.
    HH_GPROPID_CONTENT_LANGUAGE=5   // long: LandId for desired content.
} HH_GPROPID;

///////////////////////////////////////////////////////////////////////////////
//
// Global Property structure
//
#ifdef __oaidl_h__

#pragma pack(push, 8)

typedef struct tagHH_GLOBAL_PROPERTY
{
    HH_GPROPID  id;
    VARIANT     var;
} HH_GLOBAL_PROPERTY ;

#pragma pack(pop)
#endif

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // __HTMLHELP_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\guiddef.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  File:       guiddef.h
//
//  Contents:   GUID definition
//
//----------------------------------------------------------------------------

#pragma once

#ifndef GUID_DEFINED
#define GUID_DEFINED
#if defined(__midl)
typedef struct {
    unsigned long  Data1;
    unsigned short Data2;
    unsigned short Data3;
    byte           Data4[ 8 ];
} GUID;
#else
typedef struct _GUID {
    unsigned long  Data1;
    unsigned short Data2;
    unsigned short Data3;
    unsigned char  Data4[ 8 ];
} GUID;
#endif
#endif

#ifndef FAR
#ifdef _WIN32
#define FAR
#else
#define FAR _far
#endif
#endif

#include <initguid.h>

#define DEFINE_OLEGUID(name, l, w1, w2) DEFINE_GUID(name, l, w1, w2, 0xC0,0,0,0,0,0,0,0x46)

#ifndef _GUIDDEF_H_
#define _GUIDDEF_H_

#ifndef __LPGUID_DEFINED__
#define __LPGUID_DEFINED__
typedef GUID *LPGUID;
#endif

#ifndef __LPCGUID_DEFINED__
#define __LPCGUID_DEFINED__
typedef const GUID *LPCGUID;
#endif

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef GUID IID;
typedef IID *LPIID;
#define IID_NULL            GUID_NULL
#define IsEqualIID(riid1, riid2) IsEqualGUID(riid1, riid2)
typedef GUID CLSID;
typedef CLSID *LPCLSID;
#define CLSID_NULL          GUID_NULL
#define IsEqualCLSID(rclsid1, rclsid2) IsEqualGUID(rclsid1, rclsid2)
typedef GUID FMTID;
typedef FMTID *LPFMTID;
#define FMTID_NULL          GUID_NULL
#define IsEqualFMTID(rfmtid1, rfmtid2) IsEqualGUID(rfmtid1, rfmtid2)

#ifdef __midl_proxy
#define __MIDL_CONST
#else
#define __MIDL_CONST const
#endif

#ifndef _REFGUID_DEFINED
#define _REFGUID_DEFINED
#ifdef __cplusplus
#define REFGUID const GUID &
#else
#define REFGUID const GUID * __MIDL_CONST
#endif
#endif

#ifndef _REFIID_DEFINED
#define _REFIID_DEFINED
#ifdef __cplusplus
#define REFIID const IID &
#else
#define REFIID const IID * __MIDL_CONST
#endif
#endif

#ifndef _REFCLSID_DEFINED
#define _REFCLSID_DEFINED
#ifdef __cplusplus
#define REFCLSID const IID &
#else
#define REFCLSID const IID * __MIDL_CONST
#endif
#endif

#ifndef _REFFMTID_DEFINED
#define _REFFMTID_DEFINED
#ifdef __cplusplus
#define REFFMTID const IID &
#else
#define REFFMTID const IID * __MIDL_CONST
#endif
#endif

#endif // !__IID_DEFINED__

#if !defined (__midl)
#if !defined (_SYS_GUID_OPERATORS_)
#define _SYS_GUID_OPERATORS_
#include <string.h>

// Faster (but makes code fatter) inline version...use sparingly
#ifdef __cplusplus
#ifndef __INLINEISEQUALGUID__
#define __INLINEISEQUALGUID__
__inline int InlineIsEqualGUID(REFGUID rguid1, REFGUID rguid2)
{
   return (
      ((unsigned long *) &rguid1)[0] == ((unsigned long *) &rguid2)[0] &&
      ((unsigned long *) &rguid1)[1] == ((unsigned long *) &rguid2)[1] &&
      ((unsigned long *) &rguid1)[2] == ((unsigned long *) &rguid2)[2] &&
      ((unsigned long *) &rguid1)[3] == ((unsigned long *) &rguid2)[3]);
}
#endif
__inline int IsEqualGUID(REFGUID rguid1, REFGUID rguid2)
{
    return !memcmp(&rguid1, &rguid2, sizeof(GUID));
}

#else   // ! __cplusplus

#define InlineIsEqualGUID(rguid1, rguid2)  \
        (((unsigned long *) rguid1)[0] == ((unsigned long *) rguid2)[0] &&   \
        ((unsigned long *) rguid1)[1] == ((unsigned long *) rguid2)[1] &&    \
        ((unsigned long *) rguid1)[2] == ((unsigned long *) rguid2)[2] &&    \
        ((unsigned long *) rguid1)[3] == ((unsigned long *) rguid2)[3])

#define IsEqualGUID(rguid1, rguid2) (!memcmp(rguid1, rguid2, sizeof(GUID)))

#endif  // __cplusplus

#ifdef __INLINE_ISEQUAL_GUID
#undef IsEqualGUID
#define IsEqualGUID(rguid1, rguid2) InlineIsEqualGUID(rguid1, rguid2)
#endif

// Same type, different name

#define IsEqualIID(riid1, riid2) IsEqualGUID(riid1, riid2)
#define IsEqualCLSID(rclsid1, rclsid2) IsEqualGUID(rclsid1, rclsid2)


#if !defined _SYS_GUID_OPERATOR_EQ_ && !defined _NO_SYS_GUID_OPERATOR_EQ_
#define _SYS_GUID_OPERATOR_EQ_
// A couple of C++ helpers

#ifdef __cplusplus

__inline int operator==(REFGUID guidOne, REFGUID guidOther)
{
    return IsEqualGUID(guidOne,guidOther);
}

__inline int operator!=(REFGUID guidOne, REFGUID guidOther)
{
    return !(guidOne == guidOther);
}

#endif
#endif  // _SYS_GUID_OPERATOR_EQ_
#endif  // _SYS_GUID_OPERATORS_
#endif  // __midl
#endif  // _GUIDDEF_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\htmlctrl.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/////////////////////////////////////////////////////////////////////////////
// Copyright (c) Microsoft Corporation.  All rights reserved.
/////////////////////////////////////////////////////////////////////////////

#pragma once

#define DTM_ADDTEXT             (WM_USER + 101)
#define DTM_ADDTEXTW            (WM_USER + 102)
#define DTM_SETIMAGE            (WM_USER + 103)
#define DTM_ENDOFSOURCE         (WM_USER + 104)
#define DTM_ANCHOR              (WM_USER + 105)
#define DTM_ANCHORW             (WM_USER + 106)
#define DTM_ENABLESHRINK        (WM_USER + 107)
#define DTM_FITTOWINDOW         (WM_USER + 107)
#define DTM_SCROLLINTOVIEW      (WM_USER + 108)
#define DTM_IMAGEFAIL           (WM_USER + 109)
#define DTM_ENABLECONTEXTMENU   (WM_USER + 110)
#define DTM_SELECTALL           (WM_USER + 111)
#define DTM_ISSELECTION         (WM_USER + 112)
#define DTM_CLEAR               (WM_USER + 113)
#define DTM_ENABLECLEARTYPE     (WM_USER + 114)
#define DTM_ENABLESCRIPTING     (WM_USER + 115)
#define DTM_ZOOMLEVEL           (WM_USER + 116)
#define DTM_LAYOUTWIDTH         (WM_USER + 117)
#define DTM_LAYOUTHEIGHT        (WM_USER + 118)
#define DTM_COPYSELECTIONTONEWISTREAM   (WM_USER + 119)
#define DTM_NAVIGATE            (WM_USER + 120)
#define DTM_INTEGRALPAGING      (WM_USER + 121)
#define DTM_SCRIPTDISPATCH      (WM_USER + 122)
#define DTM_DOCUMENTDISPATCH    (WM_USER + 123)
#define DTM_BROWSERDISPATCH     (WM_USER + 124)
#define DTM_STOP                (WM_USER + 125)
#define DTM_ADDSTYLE            (WM_USER + 126)
#define DTM_SETIMAGE_EX         (WM_USER + 127)


#define NM_HOTSPOT              (WM_USER + 101)
#define NM_INLINE_IMAGE         (WM_USER + 102)
#define NM_INLINE_SOUND         (WM_USER + 103)
#define NM_TITLE                (WM_USER + 104)
#define NM_META                 (WM_USER + 105)
#define NM_BASE                 (WM_USER + 106)
#define NM_CONTEXTMENU          (WM_USER + 107)
#define NM_INLINE_XML           (WM_USER + 108)
#define NM_BEFORENAVIGATE       (WM_USER + 109)
#define NM_DOCUMENTCOMPLETE     (WM_USER + 110)
#define NM_NAVIGATECOMPLETE     (WM_USER + 111)
#define NM_TITLECHANGE          (WM_USER + 112)
#define NM_INLINE_STYLE         (WM_USER + 113)
#define NM_INLINE_FRAME         (WM_USER + 114)
#define NM_INLINE_IFRAME        (WM_USER + 115)
#define NM_IMAGE_FAILED         (WM_USER + 116)

#define DISPLAYCLASS    TEXT("DISPLAYCLASS")
#define WC_HTML         DISPLAYCLASS

#define HS_NOFITTOWINDOW        0x0001  // Disable "fit to window" feature
#define HS_CONTEXTMENU          0x0002  // Enable default context menus
#define HS_CLEARTYPE            0x0004  // Enable ClearType
#define HS_NOSCRIPTING          0x0008  // Disable scripting
#define HS_INTEGRALPAGING       0x0010  // Enable "ingeral paging" feature (last 'screen' always the height of the control)
#define HS_NOSCROLL             0x0020  // Disable scrolling
#define HS_NOIMAGES             0x0040  // Disable loading of images
#define HS_NOSOUNDS             0x0080  // Disable loading and playing sounds
#define HS_NOACTIVEX            0x0100  // Disable ActiveX controls
#define HS_NOSELECTION          0x0200  // Disable content selection
#define HS_NOFOCUSRECT          0x0400  // Disable the focus rectangle
#define HS_NOPUMPMESSAGES       0x8000  // Don't allow HTML control to pump messages on load

#define FRAME_SCROLLING_AUTO    1
#define FRAME_SCROLLING_YES     2
#define FRAME_SCROLLING_NO      3

// DTM_NAVIGATE flags
#define NAVIGATEFLAG_REFRESH            0x0020
#define NAVIGATEFLAG_RELATIVE           0x0040
#define NAVIGATEFLAG_ENTERED            0x0080
#define NAVIGATEFLAG_INTRADOCUMENT      0x0100
#define NAVIGATEFLAG_IGNORETARGET       0x0200
#define NAVIGATEFLAG_GETFROMCACHE       0x0400
#define NAVIGATEFLAG_NOCACHE            0x1000
#define NAVIGATEFLAG_RESYNCHRONIZE      0x2000
#define NAVIGATEFLAG_RELOAD             0x4000

EXTERN_C BOOL InitHTMLControl(HINSTANCE hinst);

typedef struct tagNM_HTMLVIEWA
{
    NMHDR   hdr;
    LPCSTR  szTarget;
    LPCSTR  szData;

    union
    {
        DWORD dwCookie;
        DWORD dwFlags;
    };

    LPCSTR  szExInfo;
} NM_HTMLVIEWA;

typedef struct tagNM_HTMLVIEWW
{
    NMHDR   hdr;
    LPCWSTR szTarget;
    LPCWSTR szData;

    union
    {
        DWORD dwCookie;
        DWORD dwFlags;
    };

    LPCWSTR szExInfo;
} NM_HTMLVIEWW;

#ifdef UNICODE
#define NM_HTMLVIEW NM_HTMLVIEWW
#else
#define NM_HTMLVIEW NM_HTMLVIEWA
#endif  // UNICODE

typedef struct tagINLINEIMAGEINFO
{
    DWORD       dwCookie;
    int         iOrigHeight;
    int         iOrigWidth;
    HBITMAP     hbm;
    BOOL        bOwnBitmap;
} INLINEIMAGEINFO;

#include <objidl.h>

#define IIIEXF_ORIG_SIZE    0x0001 // Whether iOrigHeight and Width were set by caller
#define IIIEXF_STGMEDIUM    0x0002 // Whether we're using STGMEDIUM to specify image data

typedef struct tagINLINEIMAGEINFOEX
{
    DWORD       dwFlags;
    DWORD       dwCookie;
    int         iOrigHeight;
    int         iOrigWidth;
    BOOL        bOwnImage;
    
    STGMEDIUM   stgmImage;
} INLINEIMAGEINFOEX;


#define HTMLCONTEXT_BACKGROUND          0x00
#define HTMLCONTEXT_LINK                0x01
#define HTMLCONTEXT_IMAGE               0x02
#define HTMLCONTEXT_IMAGENOTLOADED      0x04
#define HTMLCONTEXT_TEXT                0x08

typedef struct tagNM_HTMLCONTEXT
{
    NMHDR           hdr; 
    POINT           pt;
    UINT            uTypeFlags;
    LPTSTR          szLinkHREF;
    LPTSTR          szLinkName;
    DWORD           dwReserved1;
    DWORD           dwImageCookie;
    DWORD           dwReserved2;
} NM_HTMLCONTEXT;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\htmlfilter.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES.
//

#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0286 */
/* at Mon Jan 22 12:13:41 2007
 */
/* Compiler settings for ..\htmlfilter.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __htmlfilter_h__
#define __htmlfilter_h__

/* Forward Declarations */ 

#ifndef __IHTMLViewFilter_FWD_DEFINED__
#define __IHTMLViewFilter_FWD_DEFINED__
typedef interface IHTMLViewFilter IHTMLViewFilter;
#endif 	/* __IHTMLViewFilter_FWD_DEFINED__ */


#ifndef __IHTMLViewFilterSite_FWD_DEFINED__
#define __IHTMLViewFilterSite_FWD_DEFINED__
typedef interface IHTMLViewFilterSite IHTMLViewFilterSite;
#endif 	/* __IHTMLViewFilterSite_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "oleidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_htmlfilter_0000 */
/* [local] */ 



// GetStatusBits Flags
#define FILTER_STATUS_OPAQUE    (0x00000001)
#define FILTER_STATUS_INVISIBLE (0x00000002)
#define FILTER_STATUS_SURFACE   (0x00000004)
#define FILTER_STATUS_3DSURFACE (0x00000008)


extern RPC_IF_HANDLE __MIDL_itf_htmlfilter_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_htmlfilter_0000_v0_0_s_ifspec;

#ifndef __IHTMLViewFilter_INTERFACE_DEFINED__
#define __IHTMLViewFilter_INTERFACE_DEFINED__

/* interface IHTMLViewFilter */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_IHTMLViewFilter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f2f1-98b5-11cf-bb82-00aa00bdce0b")
    IHTMLViewFilter : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetSource( 
            /* [in] */ IHTMLViewFilter __RPC_FAR *pFilter) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSource( 
            /* [out] */ IHTMLViewFilter __RPC_FAR *__RPC_FAR *ppFilter) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSite( 
            /* [in] */ IHTMLViewFilterSite __RPC_FAR *pSink) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSite( 
            /* [out] */ IHTMLViewFilterSite __RPC_FAR *__RPC_FAR *ppSink) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPosition( 
            LPCRECT prc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Draw( 
            /* [in] */ HDC hdc,
            /* [in] */ LPCRECT prcBounds) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStatusBits( 
            /* [out] */ DWORD __RPC_FAR *pdwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHTMLViewFilterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IHTMLViewFilter __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IHTMLViewFilter __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IHTMLViewFilter __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetSource )( 
            IHTMLViewFilter __RPC_FAR * This,
            /* [in] */ IHTMLViewFilter __RPC_FAR *pFilter);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSource )( 
            IHTMLViewFilter __RPC_FAR * This,
            /* [out] */ IHTMLViewFilter __RPC_FAR *__RPC_FAR *ppFilter);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetSite )( 
            IHTMLViewFilter __RPC_FAR * This,
            /* [in] */ IHTMLViewFilterSite __RPC_FAR *pSink);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSite )( 
            IHTMLViewFilter __RPC_FAR * This,
            /* [out] */ IHTMLViewFilterSite __RPC_FAR *__RPC_FAR *ppSink);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPosition )( 
            IHTMLViewFilter __RPC_FAR * This,
            LPCRECT prc);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Draw )( 
            IHTMLViewFilter __RPC_FAR * This,
            /* [in] */ HDC hdc,
            /* [in] */ LPCRECT prcBounds);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStatusBits )( 
            IHTMLViewFilter __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwFlags);
        
        END_INTERFACE
    } IHTMLViewFilterVtbl;

    interface IHTMLViewFilter
    {
        CONST_VTBL struct IHTMLViewFilterVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHTMLViewFilter_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHTMLViewFilter_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHTMLViewFilter_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHTMLViewFilter_SetSource(This,pFilter)	\
    (This)->lpVtbl -> SetSource(This,pFilter)

#define IHTMLViewFilter_GetSource(This,ppFilter)	\
    (This)->lpVtbl -> GetSource(This,ppFilter)

#define IHTMLViewFilter_SetSite(This,pSink)	\
    (This)->lpVtbl -> SetSite(This,pSink)

#define IHTMLViewFilter_GetSite(This,ppSink)	\
    (This)->lpVtbl -> GetSite(This,ppSink)

#define IHTMLViewFilter_SetPosition(This,prc)	\
    (This)->lpVtbl -> SetPosition(This,prc)

#define IHTMLViewFilter_Draw(This,hdc,prcBounds)	\
    (This)->lpVtbl -> Draw(This,hdc,prcBounds)

#define IHTMLViewFilter_GetStatusBits(This,pdwFlags)	\
    (This)->lpVtbl -> GetStatusBits(This,pdwFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IHTMLViewFilter_SetSource_Proxy( 
    IHTMLViewFilter __RPC_FAR * This,
    /* [in] */ IHTMLViewFilter __RPC_FAR *pFilter);


void __RPC_STUB IHTMLViewFilter_SetSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLViewFilter_GetSource_Proxy( 
    IHTMLViewFilter __RPC_FAR * This,
    /* [out] */ IHTMLViewFilter __RPC_FAR *__RPC_FAR *ppFilter);


void __RPC_STUB IHTMLViewFilter_GetSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLViewFilter_SetSite_Proxy( 
    IHTMLViewFilter __RPC_FAR * This,
    /* [in] */ IHTMLViewFilterSite __RPC_FAR *pSink);


void __RPC_STUB IHTMLViewFilter_SetSite_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLViewFilter_GetSite_Proxy( 
    IHTMLViewFilter __RPC_FAR * This,
    /* [out] */ IHTMLViewFilterSite __RPC_FAR *__RPC_FAR *ppSink);


void __RPC_STUB IHTMLViewFilter_GetSite_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLViewFilter_SetPosition_Proxy( 
    IHTMLViewFilter __RPC_FAR * This,
    LPCRECT prc);


void __RPC_STUB IHTMLViewFilter_SetPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLViewFilter_Draw_Proxy( 
    IHTMLViewFilter __RPC_FAR * This,
    /* [in] */ HDC hdc,
    /* [in] */ LPCRECT prcBounds);


void __RPC_STUB IHTMLViewFilter_Draw_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLViewFilter_GetStatusBits_Proxy( 
    IHTMLViewFilter __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwFlags);


void __RPC_STUB IHTMLViewFilter_GetStatusBits_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHTMLViewFilter_INTERFACE_DEFINED__ */


#ifndef __IHTMLViewFilterSite_INTERFACE_DEFINED__
#define __IHTMLViewFilterSite_INTERFACE_DEFINED__

/* interface IHTMLViewFilterSite */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_IHTMLViewFilterSite;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f2f4-98b5-11cf-bb82-00aa00bdce0b")
    IHTMLViewFilterSite : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDC( 
            /* [in] */ LPCRECT prc,
            /* [in] */ DWORD dwFlags,
            /* [out] */ HDC __RPC_FAR *phdc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReleaseDC( 
            /* [in] */ HDC hdc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InvalidateRect( 
            /* [in] */ LPCRECT prc,
            /* [in] */ BOOL fErase) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InvalidateRgn( 
            /* [in] */ HRGN hrgn,
            /* [in] */ BOOL fErase) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnStatusBitsChange( 
            /* [in] */ DWORD dwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHTMLViewFilterSiteVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IHTMLViewFilterSite __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IHTMLViewFilterSite __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IHTMLViewFilterSite __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDC )( 
            IHTMLViewFilterSite __RPC_FAR * This,
            /* [in] */ LPCRECT prc,
            /* [in] */ DWORD dwFlags,
            /* [out] */ HDC __RPC_FAR *phdc);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReleaseDC )( 
            IHTMLViewFilterSite __RPC_FAR * This,
            /* [in] */ HDC hdc);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InvalidateRect )( 
            IHTMLViewFilterSite __RPC_FAR * This,
            /* [in] */ LPCRECT prc,
            /* [in] */ BOOL fErase);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InvalidateRgn )( 
            IHTMLViewFilterSite __RPC_FAR * This,
            /* [in] */ HRGN hrgn,
            /* [in] */ BOOL fErase);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnStatusBitsChange )( 
            IHTMLViewFilterSite __RPC_FAR * This,
            /* [in] */ DWORD dwFlags);
        
        END_INTERFACE
    } IHTMLViewFilterSiteVtbl;

    interface IHTMLViewFilterSite
    {
        CONST_VTBL struct IHTMLViewFilterSiteVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHTMLViewFilterSite_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHTMLViewFilterSite_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHTMLViewFilterSite_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHTMLViewFilterSite_GetDC(This,prc,dwFlags,phdc)	\
    (This)->lpVtbl -> GetDC(This,prc,dwFlags,phdc)

#define IHTMLViewFilterSite_ReleaseDC(This,hdc)	\
    (This)->lpVtbl -> ReleaseDC(This,hdc)

#define IHTMLViewFilterSite_InvalidateRect(This,prc,fErase)	\
    (This)->lpVtbl -> InvalidateRect(This,prc,fErase)

#define IHTMLViewFilterSite_InvalidateRgn(This,hrgn,fErase)	\
    (This)->lpVtbl -> InvalidateRgn(This,hrgn,fErase)

#define IHTMLViewFilterSite_OnStatusBitsChange(This,dwFlags)	\
    (This)->lpVtbl -> OnStatusBitsChange(This,dwFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IHTMLViewFilterSite_GetDC_Proxy( 
    IHTMLViewFilterSite __RPC_FAR * This,
    /* [in] */ LPCRECT prc,
    /* [in] */ DWORD dwFlags,
    /* [out] */ HDC __RPC_FAR *phdc);


void __RPC_STUB IHTMLViewFilterSite_GetDC_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLViewFilterSite_ReleaseDC_Proxy( 
    IHTMLViewFilterSite __RPC_FAR * This,
    /* [in] */ HDC hdc);


void __RPC_STUB IHTMLViewFilterSite_ReleaseDC_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLViewFilterSite_InvalidateRect_Proxy( 
    IHTMLViewFilterSite __RPC_FAR * This,
    /* [in] */ LPCRECT prc,
    /* [in] */ BOOL fErase);


void __RPC_STUB IHTMLViewFilterSite_InvalidateRect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLViewFilterSite_InvalidateRgn_Proxy( 
    IHTMLViewFilterSite __RPC_FAR * This,
    /* [in] */ HRGN hrgn,
    /* [in] */ BOOL fErase);


void __RPC_STUB IHTMLViewFilterSite_InvalidateRgn_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLViewFilterSite_OnStatusBitsChange_Proxy( 
    IHTMLViewFilterSite __RPC_FAR * This,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IHTMLViewFilterSite_OnStatusBitsChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHTMLViewFilterSite_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\iaccess.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES.
//
#include <accctrl.h>

#ifndef __IAccessControl_INTERFACE_DEFINED__
#define __IAccessControl_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: __MIDL__intf_0077
 * at Tue Oct 29 15:38:21 1996
 * using MIDL 3.00.44
 ****************************************/
/* [local] */


typedef /* [allocate] */ PACTRL_ACCESSW PACTRL_ACCESSW_ALLOCATE_ALL_NODES;

typedef /* [allocate] */ PACTRL_AUDITW PACTRL_AUDITW_ALLOCATE_ALL_NODES;





/****************************************
 * Generated header for interface: IAccessControl
 * at Tue Oct 29 15:38:21 1996
 * using MIDL 3.00.44
 ****************************************/
/* [unique][uuid][object] */



EXTERN_C const IID IID_IAccessControl;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface IAccessControl : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GrantAccessRights(
            /* [in] */ PACTRL_ACCESSW pAccessList) = 0;

        virtual HRESULT STDMETHODCALLTYPE SetAccessRights(
            /* [in] */ PACTRL_ACCESSW pAccessList) = 0;

        virtual HRESULT STDMETHODCALLTYPE SetOwner(
            /* [in] */ PTRUSTEEW pOwner,
            /* [in] */ PTRUSTEEW pGroup) = 0;

        virtual HRESULT STDMETHODCALLTYPE RevokeAccessRights(
            /* [in] */ LPWSTR lpProperty,
            /* [in] */ ULONG cTrustees,
            /* [size_is][in] */ TRUSTEEW __RPC_FAR prgTrustees[  ]) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetAllAccessRights(
            /* [in] */ LPWSTR lpProperty,
            /* [out] */ PACTRL_ACCESSW_ALLOCATE_ALL_NODES __RPC_FAR *ppAccessList,
            /* [out] */ PTRUSTEEW __RPC_FAR *ppOwner,
            /* [out] */ PTRUSTEEW __RPC_FAR *ppGroup) = 0;

        virtual HRESULT STDMETHODCALLTYPE IsAccessAllowed(
            /* [in] */ PTRUSTEEW pTrustee,
            /* [in] */ LPWSTR lpProperty,
            /* [in] */ ACCESS_RIGHTS AccessRights,
            /* [out] */ BOOL __RPC_FAR *pfAccessAllowed) = 0;

    };

#else   /* C style interface */

    typedef struct IAccessControlVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )(
            IAccessControl __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )(
            IAccessControl __RPC_FAR * This);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )(
            IAccessControl __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GrantAccessRights )(
            IAccessControl __RPC_FAR * This,
            /* [in] */ PACTRL_ACCESSW pAccessList);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAccessRights )(
            IAccessControl __RPC_FAR * This,
            /* [in] */ PACTRL_ACCESSW pAccessList);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetOwner )(
            IAccessControl __RPC_FAR * This,
            /* [in] */ PTRUSTEEW pOwner,
            /* [in] */ PTRUSTEEW pGroup);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RevokeAccessRights )(
            IAccessControl __RPC_FAR * This,
            /* [in] */ LPWSTR lpProperty,
            /* [in] */ ULONG cTrustees,
            /* [size_is][in] */ TRUSTEEW __RPC_FAR prgTrustees[  ]);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAllAccessRights )(
            IAccessControl __RPC_FAR * This,
            /* [in] */ LPWSTR lpProperty,
            /* [out] */ PACTRL_ACCESSW_ALLOCATE_ALL_NODES __RPC_FAR *ppAccessList,
            /* [out] */ PTRUSTEEW __RPC_FAR *ppOwner,
            /* [out] */ PTRUSTEEW __RPC_FAR *ppGroup);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsAccessAllowed )(
            IAccessControl __RPC_FAR * This,
            /* [in] */ PTRUSTEEW pTrustee,
            /* [in] */ LPWSTR lpProperty,
            /* [in] */ ACCESS_RIGHTS AccessRights,
            /* [out] */ BOOL __RPC_FAR *pfAccessAllowed);

        END_INTERFACE
    } IAccessControlVtbl;

    interface IAccessControl
    {
        CONST_VTBL struct IAccessControlVtbl __RPC_FAR *lpVtbl;
    };



#ifdef COBJMACROS


#define IAccessControl_QueryInterface(This,riid,ppvObject)      \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAccessControl_AddRef(This)     \
    (This)->lpVtbl -> AddRef(This)

#define IAccessControl_Release(This)    \
    (This)->lpVtbl -> Release(This)


#define IAccessControl_GrantAccessRights(This,pAccessList)      \
    (This)->lpVtbl -> GrantAccessRights(This,pAccessList)

#define IAccessControl_SetAccessRights(This,pAccessList)        \
    (This)->lpVtbl -> SetAccessRights(This,pAccessList)

#define IAccessControl_SetOwner(This,pOwner,pGroup)     \
    (This)->lpVtbl -> SetOwner(This,pOwner,pGroup)

#define IAccessControl_RevokeAccessRights(This,lpProperty,cTrustees,prgTrustees)        \
    (This)->lpVtbl -> RevokeAccessRights(This,lpProperty,cTrustees,prgTrustees)

#define IAccessControl_GetAllAccessRights(This,lpProperty,ppAccessList,ppOwner,ppGroup) \
    (This)->lpVtbl -> GetAllAccessRights(This,lpProperty,ppAccessList,ppOwner,ppGroup)

#define IAccessControl_IsAccessAllowed(This,pTrustee,lpProperty,AccessRights,pfAccessAllowed)   \
    (This)->lpVtbl -> IsAccessAllowed(This,pTrustee,lpProperty,AccessRights,pfAccessAllowed)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IAccessControl_GrantAccessRights_Proxy(
    IAccessControl __RPC_FAR * This,
    /* [in] */ PACTRL_ACCESSW pAccessList);


void __RPC_STUB IAccessControl_GrantAccessRights_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAccessControl_SetAccessRights_Proxy(
    IAccessControl __RPC_FAR * This,
    /* [in] */ PACTRL_ACCESSW pAccessList);


void __RPC_STUB IAccessControl_SetAccessRights_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAccessControl_SetOwner_Proxy(
    IAccessControl __RPC_FAR * This,
    /* [in] */ PTRUSTEEW pOwner,
    /* [in] */ PTRUSTEEW pGroup);


void __RPC_STUB IAccessControl_SetOwner_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAccessControl_RevokeAccessRights_Proxy(
    IAccessControl __RPC_FAR * This,
    /* [in] */ LPWSTR lpProperty,
    /* [in] */ ULONG cTrustees,
    /* [size_is][in] */ TRUSTEEW __RPC_FAR prgTrustees[  ]);


void __RPC_STUB IAccessControl_RevokeAccessRights_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAccessControl_GetAllAccessRights_Proxy(
    IAccessControl __RPC_FAR * This,
    /* [in] */ LPWSTR lpProperty,
    /* [out] */ PACTRL_ACCESSW_ALLOCATE_ALL_NODES __RPC_FAR *ppAccessList,
    /* [out] */ PTRUSTEEW __RPC_FAR *ppOwner,
    /* [out] */ PTRUSTEEW __RPC_FAR *ppGroup);


void __RPC_STUB IAccessControl_GetAllAccessRights_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAccessControl_IsAccessAllowed_Proxy(
    IAccessControl __RPC_FAR * This,
    /* [in] */ PTRUSTEEW pTrustee,
    /* [in] */ LPWSTR lpProperty,
    /* [in] */ ACCESS_RIGHTS AccessRights,
    /* [out] */ BOOL __RPC_FAR *pfAccessAllowed);


void __RPC_STUB IAccessControl_IsAccessAllowed_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IAccessControl_INTERFACE_DEFINED__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\hlinkez.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES.
//
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright 1995-1998 Microsoft Corporation. All Rights Reserved.
//
//  File: hlinkez.h
//
//--------------------------------------------------------------------------

struct IBindStatusCallback;

HRESULT HlinkSimpleNavigateToString(
    /* [in] */ LPCWSTR szTarget,      // required - target document - null if local jump w/in doc
    /* [in] */ LPCWSTR szLocation,    // optional, for navigation into middle of a doc
    /* [in] */ LPCWSTR szAdditionalParams,   // optional, for targeting frame-sets
    /* [in] */ IUnknown *pUnk,        // required - we'll search this for other necessary interfaces
    /* [in] */ IBindCtx *pbc,         // optional. caller may register an IBSC in this
	/* [in] */ IBindStatusCallback *,
    /* [in] */ DWORD grfHLNF,         // flags (TBD - HadiP needs to define this correctly?)
    /* [in] */ DWORD dwReserved       // for future use, must be NULL
);

HRESULT HlinkSimpleNavigateToMoniker(
    /* [in] */ IMoniker *pmkTarget,   // required - target document - (may be null if local jump w/in doc)
    /* [in] */ LPCWSTR szLocation,    // optional, for navigation into middle of a doc
    /* [in] */ LPCWSTR szAddParams,   // optional, for targeting frame-sets
    /* [in] */ IUnknown *pUnk,        // required - we'll search this for other necessary interfaces
    /* [in] */ IBindCtx *pbc,         // optional. caller may register an IBSC in this
	/* [in] */ IBindStatusCallback *,
    /* [in] */ DWORD grfHLNF,         // flags (TBD - HadiP needs to define this correctly?)
    /* [in] */ DWORD dwReserved       // for future use, must be NULL
);

HRESULT HlinkGoBack(IUnknown *pUnk);
HRESULT HlinkGoForward(IUnknown *pUnk);
HRESULT HlinkNavigateString(IUnknown *pUnk, LPCWSTR szTarget);
HRESULT HlinkNavigateMoniker(IUnknown *pUnk, IMoniker *pmkTarget);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\httpext.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/********
*
*  Copyright (c) 1995  Process Software Corporation
*
*
*
*  Module Name  : HttpExt.h
*
*  Abstract :
*
*     This module contains  the structure definitions and prototypes for the
*      HTTP Server Extension interface used to build ISAPI Applications
*
******************/

#ifndef _HTTPEXT_H_
#define _HTTPEXT_H_

#include <windows.h>

#ifdef __cplusplus
extern "C" {
#endif


/************************************************************
 *   Manifest Constants
 ************************************************************/

#define   HSE_VERSION_MAJOR           4      // major version of this spec
#define   HSE_VERSION_MINOR           0      // minor version of this spec
#define   HSE_LOG_BUFFER_LEN         80
#define   HSE_MAX_EXT_DLL_NAME_LEN  256

#define   HSE_VERSION     MAKELONG( HSE_VERSION_MINOR, HSE_VERSION_MAJOR )

//
// the following are the status codes returned by the Extension DLL
//

#define   HSE_STATUS_SUCCESS                       1
#define   HSE_STATUS_SUCCESS_AND_KEEP_CONN         2
#define   HSE_STATUS_PENDING                       3
#define   HSE_STATUS_ERROR                         4

//
// The following are the values to request services with the
//   ServerSupportFunction().
//  Values from 0 to 1000 are reserved for future versions of the interface

#define   HSE_REQ_BASE                             0
#define   HSE_REQ_SEND_URL_REDIRECT_RESP           ( HSE_REQ_BASE + 1 )
#define   HSE_REQ_SEND_URL                         ( HSE_REQ_BASE + 2 )
#define   HSE_REQ_SEND_RESPONSE_HEADER             ( HSE_REQ_BASE + 3 )
#define   HSE_REQ_DONE_WITH_SESSION                ( HSE_REQ_BASE + 4 )
#define   HSE_REQ_END_RESERVED                     1000

//
//  These are Microsoft specific extensions
//

#define   HSE_REQ_MAP_URL_TO_PATH                  (HSE_REQ_END_RESERVED+1)
#define   HSE_REQ_GET_SSPI_INFO                    (HSE_REQ_END_RESERVED+2)
#define   HSE_APPEND_LOG_PARAMETER                 (HSE_REQ_END_RESERVED+3)
#define   HSE_REQ_IO_COMPLETION                    (HSE_REQ_END_RESERVED+5)
#define   HSE_REQ_TRANSMIT_FILE                    (HSE_REQ_END_RESERVED+6)
#define   HSE_REQ_REFRESH_ISAPI_ACL                (HSE_REQ_END_RESERVED+7)
#define   HSE_REQ_IS_KEEP_CONN                     (HSE_REQ_END_RESERVED+8)
#define   HSE_REQ_ASYNC_READ_CLIENT                (HSE_REQ_END_RESERVED+10)
#define   HSE_REQ_GET_IMPERSONATION_TOKEN          (HSE_REQ_END_RESERVED+11)
#define   HSE_REQ_MAP_URL_TO_PATH_EX               (HSE_REQ_END_RESERVED+12)
#define   HSE_REQ_ABORTIVE_CLOSE                   (HSE_REQ_END_RESERVED+14)
#define   HSE_REQ_GET_CERT_INFO_EX                 (HSE_REQ_END_RESERVED+15)
#define   HSE_REQ_SEND_RESPONSE_HEADER_EX          (HSE_REQ_END_RESERVED+16)

#ifdef UNDER_CE
// These are WinCE specific extensions
#define   HSE_REQ_WINCE_BASE                       500
#define   HSE_REQ_GET_LOCAL_SOCKADDR               (HSE_REQ_WINCE_BASE+1)
#define   HSE_REQ_GET_REMOTE_SOCKADDR              (HSE_REQ_WINCE_BASE+2)
#endif

//
//  Bit Flags for TerminateExtension
//
//    HSE_TERM_ADVISORY_UNLOAD - Server wants to unload the extension,
//          extension can return TRUE if OK, FALSE if the server should not
//          unload the extension
//
//    HSE_TERM_MUST_UNLOAD - Server indicating the extension is about to be
//          unloaded, the extension cannot refuse.
//

#define HSE_TERM_ADVISORY_UNLOAD                   0x00000001
#define HSE_TERM_MUST_UNLOAD                       0x00000002

//
// Flags for IO Functions, supported for IO Funcs.
//  TF means ServerSupportFunction( HSE_REQ_TRANSMIT_FILE)
//

# define HSE_IO_SYNC                      0x00000001   // for WriteClient
# define HSE_IO_ASYNC                     0x00000002   // for WriteClient/TF
# define HSE_IO_DISCONNECT_AFTER_SEND     0x00000004   // for TF
# define HSE_IO_SEND_HEADERS              0x00000008   // for TF


/************************************************************
 *   Type Definitions
 ************************************************************/

typedef   LPVOID          HCONN;

//
// structure passed to GetExtensionVersion()
//

typedef struct   _HSE_VERSION_INFO {

    DWORD  dwExtensionVersion;
    CHAR   lpszExtensionDesc[HSE_MAX_EXT_DLL_NAME_LEN];

} HSE_VERSION_INFO, *LPHSE_VERSION_INFO;


//
// structure passed to extension procedure on a new request
//
typedef struct _EXTENSION_CONTROL_BLOCK {

    DWORD     cbSize;                 // size of this struct.
    DWORD     dwVersion;              // version info of this spec
    HCONN     ConnID;                 // Context number not to be modified!
    DWORD     dwHttpStatusCode;       // HTTP Status code
    CHAR      lpszLogData[HSE_LOG_BUFFER_LEN];// null terminated log info specific to this Extension DLL

    LPSTR     lpszMethod;             // REQUEST_METHOD
    LPSTR     lpszQueryString;        // QUERY_STRING
    LPSTR     lpszPathInfo;           // PATH_INFO
    LPSTR     lpszPathTranslated;     // PATH_TRANSLATED

    DWORD     cbTotalBytes;           // Total bytes indicated from client
    DWORD     cbAvailable;            // Available number of bytes
    LPBYTE    lpbData;                // pointer to cbAvailable bytes

    LPSTR     lpszContentType;        // Content type of client data

    BOOL (WINAPI * GetServerVariable) ( HCONN       hConn,
                                        LPSTR       lpszVariableName,
                                        LPVOID      lpvBuffer,
                                        LPDWORD     lpdwSize );

    BOOL (WINAPI * WriteClient)  ( HCONN      ConnID,
                                   LPVOID     Buffer,
                                   LPDWORD    lpdwBytes,
                                   DWORD      dwReserved );

    BOOL (WINAPI * ReadClient)  ( HCONN      ConnID,
                                  LPVOID     lpvBuffer,
                                  LPDWORD    lpdwSize );

    BOOL (WINAPI * ServerSupportFunction)( HCONN      hConn,
                                           DWORD      dwHSERequest,
                                           LPVOID     lpvBuffer,
                                           LPDWORD    lpdwSize,
                                           LPDWORD    lpdwDataType );

} EXTENSION_CONTROL_BLOCK, *LPEXTENSION_CONTROL_BLOCK;




//
//  Bit field of flags that can be on a virtual directory
//

#define HSE_URL_FLAGS_READ          0x00000001    // Allow for Read
#define HSE_URL_FLAGS_WRITE         0x00000002    // Allow for Write
#define HSE_URL_FLAGS_EXECUTE       0x00000004    // Allow for Execute
#define HSE_URL_FLAGS_SSL           0x00000008    // Require SSL
#define HSE_URL_FLAGS_DONT_CACHE    0x00000010    // Don't cache (vroot only)
#define HSE_URL_FLAGS_NEGO_CERT     0x00000020    // Allow client SSL certs
#define HSE_URL_FLAGS_REQUIRE_CERT  0x00000040    // Require client SSL certs
#define HSE_URL_FLAGS_MAP_CERT      0x00000080    // Map SSL cert to NT account
#define HSE_URL_FLAGS_SSL128        0x00000100    // Require 128 bit SSL
#define HSE_URL_FLAGS_SCRIPT        0x00000200    // Allow for Script execution

#if defined (UNDER_CE)
#define HSE_URL_FLAGS_SCRIPT_SOURCE 0x00000400    // Allow client to access script source
#define HSE_URL_FLAGS_MASK          0x000007ff
#else
#define HSE_URL_FLAGS_MASK          0x000003ff
#endif



//
//  Structure for extended information on a URL mapping
//

typedef struct _HSE_URL_MAPEX_INFO {

    CHAR   lpszPath[MAX_PATH]; // Physical path root mapped to
    DWORD  dwFlags;            // Flags associated with this URL path
    DWORD  cchMatchingPath;    // Number of matching characters in physical path
    DWORD  cchMatchingURL;     // Number of matching characters in URL

    DWORD  dwReserved1;
    DWORD  dwReserved2;

} HSE_URL_MAPEX_INFO, * LPHSE_URL_MAPEX_INFO;



//
// PFN_HSE_IO_COMPLETION - callback function for the Async I/O Completion.
//

typedef VOID
  (WINAPI * PFN_HSE_IO_COMPLETION)(
                                   IN EXTENSION_CONTROL_BLOCK * pECB,
                                   IN PVOID    pContext,
                                   IN DWORD    cbIO,
                                   IN DWORD    dwError
                                   );



//
// HSE_TF_INFO defines the type for HTTP SERVER EXTENSION support for
//  ISAPI applications to send files using TransmitFile.
// A pointer to this object should be used with ServerSupportFunction()
//  for HSE_REQ_TRANSMIT_FILE.
//

typedef struct _HSE_TF_INFO  {

    //
    // callback and context information
    // the callback function will be called when IO is completed.
    // the context specified will be used during such callback.
    //
    // These values (if non-NULL) will override the one set by calling
    //  ServerSupportFunction() with HSE_REQ_IO_COMPLETION
    //
    PFN_HSE_IO_COMPLETION   pfnHseIO;
    PVOID  pContext;

    // file should have been opened with FILE_FLAG_SEQUENTIAL_SCAN
    HANDLE hFile;

    //
    // HTTP header and status code
    // These fields are used only if HSE_IO_SEND_HEADERS is present in dwFlags
    //

    LPCSTR pszStatusCode; // HTTP Status Code  eg: "200 OK"

    DWORD  BytesToWrite;  // special value of "0" means write entire file.
    DWORD  Offset;        // offset value within the file to start from

    PVOID  pHead;         // Head buffer to be sent before file data
    DWORD  HeadLength;    // header length
    PVOID  pTail;         // Tail buffer to be sent after file data
    DWORD  TailLength;    // tail length

    DWORD  dwFlags;       // includes HSE_IO_DISCONNECT_AFTER_SEND, ...

} HSE_TF_INFO, * LPHSE_TF_INFO;


//
//	HSE_SEND_HEADER_EX_INFO allows an ISAPI application to send headers
//	and specify keep-alive behavior in the same call.
//

typedef struct _HSE_SEND_HEADER_EX_INFO  {

    //
    // HTTP status code and header
    //

    LPCSTR  pszStatus;  // HTTP status code  eg: "200 OK"
    LPCSTR  pszHeader;  // HTTP header

    DWORD   cchStatus;  // number of characters in status code
    DWORD   cchHeader;  // number of characters in header

    BOOL    fKeepConn;  // keep client connection alive?

} HSE_SEND_HEADER_EX_INFO, * LPHSE_SEND_HEADER_EX_INFO;


#if(_WIN32_WINNT >= 0x400)
#include <wincrypt.h>
//
//	CERT_CONTEXT_EX is passed as an an argument to 
//  ServerSupportFunction( HSE_REQ_GET_CERT_INFO_EX )
//

typedef struct _CERT_CONTEXT_EX {
    CERT_CONTEXT    CertContext;
    DWORD           cbAllocated;
    DWORD           dwCertificateFlags;
} CERT_CONTEXT_EX;
#endif



/************************************************************
 *   Function Prototypes 
 *   o  for functions exported from the ISAPI Application DLL
 ************************************************************/

BOOL  WINAPI   GetExtensionVersion( HSE_VERSION_INFO  *pVer );
DWORD WINAPI   HttpExtensionProc(  EXTENSION_CONTROL_BLOCK *pECB );
BOOL  WINAPI   TerminateExtension( DWORD dwFlags );

// the following type declarations is for use in the server side

typedef BOOL
    (WINAPI * PFN_GETEXTENSIONVERSION)( HSE_VERSION_INFO  *pVer );

typedef DWORD 
    (WINAPI * PFN_HTTPEXTENSIONPROC )( EXTENSION_CONTROL_BLOCK * pECB );

typedef BOOL  (WINAPI * PFN_TERMINATEEXTENSION )( DWORD dwFlags );

#ifdef UNDER_CE
// The functionality to stop and restart the server.  Either link to
// httpd.lib or do a LoadLibrary on httpd.dll to access this function.
// Note that this only refreshes the web server, use httpdsvc or the
// control panel applet to turn it on or off.
void HttpdStopAndRestart();

// Flags associated with IOCTL_SERVICE_SUPPORTED_OPTIONS.  A calling application
// supplies a DWORD buffer to write to, and web server sets which of the following
// options are included.  These flags indicate what modules the web server has been
// linked with, not necessarily which options are currently enabled.  For instance
// the web server would set HTTPD_OPTION_SSL if it could theoretically support
// SSL operations, even if SSL weren't configured at the moment.

#define HTTPD_OPTION_ISAPI_EXTENSIONS              0x0000001
#define HTTPD_OPTION_ISAPI_FILTERS                 0x0000002
#define HTTPD_OPTION_AUTHENTICATION                0x0000004
#define HTTPD_OPTION_SSL                           0x0000008
#define HTTPD_OPTION_WEBDAV                        0x0000010

// IOCTL_HTTPD_REFRESH_VROOTS causes the Web Server virtual root table to
// be refreshed without requiring IOCTL_SERVICE_REFRESH, which would force
// all open connections to be terminated.
#define IOCTL_HTTPD_REFRESH_VROOTS                 CTL_CODE(0, 16, METHOD_BUFFERED, 1)

// IOCTL_HTTPD_ADD_SECURE_PORT makes the TCP port set in the in paramater to be SSL.
// Port should be in big endian representation.
#define IOCTL_HTTPD_SET_PORT_SECURE                CTL_CODE(0, 17, METHOD_BUFFERED, 1)

// IOCTL_HTTPD_SET_PORT_NON_SECURE makes the TCP port set in the in paramater to be non-SSL
// Note that the default secure port for the Web Server (almost always 443) 
// cannot be made non-secure using this IOCTL.  Port should be in big endian representation.
#define IOCTL_HTTPD_SET_PORT_NON_SECURE            CTL_CODE(0, 18, METHOD_BUFFERED, 1)


#endif


#ifdef __cplusplus
}
#endif


#endif  // end definition _HTTPEXT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\httpfilt.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES.
//
/*++


Module Name:

    httpfilt.h

Abstract:

    This module contains the Microsoft HTTP filter extension info

Revision History:

--*/

#ifndef _HTTPFILT_H_
#define _HTTPFILT_H_

#ifdef __cplusplus
extern "C" {
#endif


//
//  Current version of the filter spec is 4.0
//

#define HTTP_FILTER_REVISION    MAKELONG( 0, 4);

#define SF_MAX_USERNAME         (256+1)
#define SF_MAX_PASSWORD         (256+1)
#define SF_MAX_AUTH_TYPE        (32+1)

#define SF_MAX_FILTER_DESC_LEN  (256+1)


//
//  These values can be used with the pfnSFCallback function supplied in
//  the filter context structure
//

enum SF_REQ_TYPE
{
    //
    //  Sends a complete HTTP server response header including
    //  the status, server version, message time and MIME version.
    //
    //  Server extensions should append other information at the end,
    //  such as Content-type, Content-length etc followed by an extra
    //  '\r\n'.
    //
    //  pData - Zero terminated string pointing to optional
    //      status string (i.e., "401 Access Denied") or NULL for
    //      the default response of "200 OK".
    //
    //  ul1 - Zero terminated string pointing to optional data to be
    //      appended and set with the header.  If NULL, the header will
    //      be terminated with an empty line.
    //

    SF_REQ_SEND_RESPONSE_HEADER,

    //
    //  If the server denies the HTTP request, add the specified headers
    //  to the server error response.
    //
    //  This allows an authentication filter to advertise its services
    //  w/o filtering every request.  Generally the headers will be
    //  WWW-Authenticate headers with custom authentication schemes but
    //  no restriction is placed on what headers may be specified.
    //
    //  pData - Zero terminated string pointing to one or more header lines
    //      with terminating '\r\n'.
    //

    SF_REQ_ADD_HEADERS_ON_DENIAL,

    //
    //  Only used by raw data filters that return SF_STATUS_READ_NEXT
    //
    //  ul1 - size in bytes for the next read
    //

    SF_REQ_SET_NEXT_READ_SIZE,

    //
    //  Used to indicate this request is a proxy request
    //
    //  ul1 - The proxy flags to set
    //      0x00000001 - This is a HTTP proxy request
    //
    //

    SF_REQ_SET_PROXY_INFO,

    //
    //  Returns the connection ID contained in the ConnID field of an
    //  ISAPI Application's Extension Control Block.  This value can be used
    //  as a key to cooridinate shared data between Filters and Applications.
    //
    //  pData - Pointer to DWORD that receives the connection ID.
    //

    SF_REQ_GET_CONNID,

    //
    // Used to set a SSPI security context + impersonation token
    // derived from a client certificate.
    //
    // pData - certificate info ( PHTTP_FILTER_CERTIFICATE_INFO )
    // ul1 - CtxtHandle*
    // ul2 - impersonation handle
    //

    SF_REQ_SET_CERTIFICATE_INFO,

    //
    // Used to get an IIS property
    // as defined in SF_PROPERTY_IIS
    //
    // ul1 - Property ID
    //

    SF_REQ_GET_PROPERTY,

    //
    // Used to normalize an URL
    //
    // pData - URL to normalize
    //

    SF_REQ_NORMALIZE_URL,

    //
    // Disable Notifications
    //
    // ul1 - notifications to disable
    //

    SF_REQ_DISABLE_NOTIFICATIONS,
} ;


enum SF_PROPERTY_IIS
{
    SF_PROPERTY_SSL_CTXT,
    SF_PROPERTY_INSTANCE_NUM_ID
} ;


//
//  These values are returned by the filter entry point when a new request is
//  received indicating their interest in this particular request
//

enum SF_STATUS_TYPE
{
    //
    //  The filter has handled the HTTP request.  The server should disconnect
    //  the session.
    //

    SF_STATUS_REQ_FINISHED = 0x8000000,

    //
    //  Same as SF_STATUS_FINISHED except the server should keep the TCP
    //  session open if the option was negotiated
    //

    SF_STATUS_REQ_FINISHED_KEEP_CONN,

    //
    //  The next filter in the notification chain should be called
    //

    SF_STATUS_REQ_NEXT_NOTIFICATION,

    //
    //  This filter handled the notification.  No other handles should be
    //  called for this particular notification type
    //

    SF_STATUS_REQ_HANDLED_NOTIFICATION,

    //
    //  An error occurred.  The server should use GetLastError() and indicate
    //  the error to the client
    //

    SF_STATUS_REQ_ERROR,

    //
    //  The filter is an opaque stream filter and we're negotiating the
    //  session parameters.  Only valid for raw read notification.
    //

    SF_STATUS_REQ_READ_NEXT
};

//
//  pvNotification points to this structure for all request notification types
//

typedef struct _HTTP_FILTER_CONTEXT
{
    DWORD          cbSize;

    //
    //  This is the structure revision level.
    //

    DWORD          Revision;

    //
    //  Private context information for the server.
    //

    PVOID          ServerContext;
    DWORD          ulReserved;

    //
    //  TRUE if this request is coming over a secure port
    //

    BOOL           fIsSecurePort;

    //
    //  A context that can be used by the filter
    //

    PVOID          pFilterContext;

    //
    //  Server callbacks
    //

    BOOL (WINAPI * GetServerVariable) (
        struct _HTTP_FILTER_CONTEXT * pfc,
        LPSTR                         lpszVariableName,
        LPVOID                        lpvBuffer,
        LPDWORD                       lpdwSize
        );

    BOOL (WINAPI * AddResponseHeaders) (
        struct _HTTP_FILTER_CONTEXT * pfc,
        LPSTR                         lpszHeaders,
        DWORD                         dwReserved
        );

    BOOL (WINAPI * WriteClient)  (
        struct _HTTP_FILTER_CONTEXT * pfc,
        LPVOID                        Buffer,
        LPDWORD                       lpdwBytes,
        DWORD                         dwReserved
        );

    VOID * (WINAPI * AllocMem) (
        struct _HTTP_FILTER_CONTEXT * pfc,
        DWORD                         cbSize,
        DWORD                         dwReserved
        );

    BOOL (WINAPI * ServerSupportFunction) (
        struct _HTTP_FILTER_CONTEXT * pfc,
        enum SF_REQ_TYPE              sfReq,
        PVOID                         pData,
        DWORD                         ul1,
        DWORD                         ul2
        );

} HTTP_FILTER_CONTEXT, *PHTTP_FILTER_CONTEXT;

//
//  This structure is the notification info for the read and send raw data
//  notification types
//

typedef struct _HTTP_FILTER_RAW_DATA
{
    //
    //  This is a pointer to the data for the filter to process.
    //

    PVOID         pvInData;
    DWORD         cbInData;       // Number of valid data bytes
    DWORD         cbInBuffer;     // Total size of buffer

    DWORD         dwReserved;

} HTTP_FILTER_RAW_DATA, *PHTTP_FILTER_RAW_DATA;

//
//  This structure is the notification info for when the server is about to
//  process the client headers
//

typedef struct _HTTP_FILTER_PREPROC_HEADERS
{
    //
    //  For SF_NOTIFY_PREPROC_HEADERS, retrieves the specified header value.
    //  Header names should include the trailing ':'.  The special values
    //  'method', 'url' and 'version' can be used to retrieve the individual
    //  portions of the request line
    //

    BOOL (WINAPI * GetHeader) (
        struct _HTTP_FILTER_CONTEXT * pfc,
        LPSTR                         lpszName,
        LPVOID                        lpvBuffer,
        LPDWORD                       lpdwSize
        );

    //
    //  Replaces this header value to the specified value.  To delete a header,
    //  specified a value of '\0'.
    //

    BOOL (WINAPI * SetHeader) (
        struct _HTTP_FILTER_CONTEXT * pfc,
        LPSTR                         lpszName,
        LPSTR                         lpszValue
        );

    //
    //  Adds the specified header and value
    //

    BOOL (WINAPI * AddHeader) (
        struct _HTTP_FILTER_CONTEXT * pfc,
        LPSTR                         lpszName,
        LPSTR                         lpszValue
        );

    DWORD HttpStatus;               // New in 4.0, status for SEND_RESPONSE
    DWORD dwReserved;               // New in 4.0

} HTTP_FILTER_PREPROC_HEADERS, *PHTTP_FILTER_PREPROC_HEADERS;

typedef HTTP_FILTER_PREPROC_HEADERS HTTP_FILTER_SEND_RESPONSE;
typedef HTTP_FILTER_PREPROC_HEADERS *PHTTP_FILTER_SEND_RESPONSE;

//
//  Authentication information for this request.
//

typedef struct _HTTP_FILTER_AUTHENT
{
    //
    //  Pointer to username and password, empty strings for the anonymous user
    //
    //  Client's can overwrite these buffers which are guaranteed to be at
    //  least SF_MAX_USERNAME and SF_MAX_PASSWORD bytes large.
    //

    CHAR * pszUser;
    DWORD  cbUserBuff;

    CHAR * pszPassword;
    DWORD  cbPasswordBuff;

} HTTP_FILTER_AUTHENT, *PHTTP_FILTER_AUTHENT;



//
//  Indicates the server is going to use the specific physical mapping for
//  the specified URL.  Filters can modify the physical path in place.
//

typedef struct _HTTP_FILTER_URL_MAP
{
    const CHAR * pszURL;

    CHAR *       pszPhysicalPath;
    DWORD        cbPathBuff;

} HTTP_FILTER_URL_MAP, *PHTTP_FILTER_URL_MAP;


//
//  Bitfield indicating the requested resource has been denied by the server due
//  to a logon failure, an ACL on a resource, an ISAPI Filter or an
//  ISAPI Application/CGI Application.
//
//  SF_DENIED_BY_CONFIG can appear with SF_DENIED_LOGON if the server
//  configuration did not allow the user to logon.
//

#define SF_DENIED_LOGON             0x00000001
#define SF_DENIED_RESOURCE          0x00000002
#define SF_DENIED_FILTER            0x00000004
#define SF_DENIED_APPLICATION       0x00000008

#define SF_DENIED_BY_CONFIG         0x00010000

typedef struct _HTTP_FILTER_ACCESS_DENIED
{
    const CHAR * pszURL;            // Requesting URL
    const CHAR * pszPhysicalPath;   // Physical path of resource
    DWORD        dwReason;          // Bitfield of SF_DENIED flags

} HTTP_FILTER_ACCESS_DENIED, *PHTTP_FILTER_ACCESS_DENIED;


//
//  The log information about to be written to the server log file.  The
//  string pointers can be replaced but the memory must remain valid until
//  the next notification
//

typedef struct _HTTP_FILTER_LOG
{
    const CHAR * pszClientHostName;
    const CHAR * pszClientUserName;
    const CHAR * pszServerName;
    const CHAR * pszOperation;
    const CHAR * pszTarget;
    const CHAR * pszParameters;

    DWORD  dwHttpStatus;
    DWORD  dwWin32Status;

    DWORD  dwBytesSent;             // IIS 4.0 and later
    DWORD  dwBytesRecvd;            // IIS 4.0 and later
    DWORD  msTimeForProcessing;     // IIS 4.0 and later

} HTTP_FILTER_LOG, *PHTTP_FILTER_LOG;

//
//  Notification Flags
//
//  SF_NOTIFY_SECURE_PORT
//  SF_NOTIFY_NONSECURE_PORT
//
//      Indicates whether the application wants to be notified for transactions
//      that are happenning on the server port(s) that support data encryption
//      (such as PCT and SSL), on only the non-secure port(s) or both.
//
//  SF_NOTIFY_READ_RAW_DATA
//
//      Applications are notified after the server reads a block of memory
//      from the client but before the server does any processing on the
//      block.  The data block may contain HTTP headers and entity data.
//
//
//

#define SF_NOTIFY_SECURE_PORT               0x00000001
#define SF_NOTIFY_NONSECURE_PORT            0x00000002

#define SF_NOTIFY_READ_RAW_DATA             0x00008000
#define SF_NOTIFY_PREPROC_HEADERS           0x00004000
#define SF_NOTIFY_AUTHENTICATION            0x00002000
#define SF_NOTIFY_URL_MAP                   0x00001000
#define SF_NOTIFY_ACCESS_DENIED             0x00000800
#define SF_NOTIFY_SEND_RESPONSE             0x00000040
#define SF_NOTIFY_SEND_RAW_DATA             0x00000400
#define SF_NOTIFY_LOG                       0x00000200
#define SF_NOTIFY_END_OF_REQUEST            0x00000080
#define SF_NOTIFY_END_OF_NET_SESSION        0x00000100


//
//  Filter ordering flags
//
//  Filters will tend to be notified by their specified
//  ordering.  For ties, notification order is determined by load order.
//
//  SF_NOTIFY_ORDER_HIGH - Authentication or data transformation filters
//  SF_NOTIFY_ORDER_MEDIUM
//  SF_NOTIFY_ORDER_LOW  - Logging filters that want the results of any other
//                      filters might specify this order.
//

#define SF_NOTIFY_ORDER_HIGH               0x00080000
#define SF_NOTIFY_ORDER_MEDIUM             0x00040000
#define SF_NOTIFY_ORDER_LOW                0x00020000
#define SF_NOTIFY_ORDER_DEFAULT            SF_NOTIFY_ORDER_LOW

#define SF_NOTIFY_ORDER_MASK               (SF_NOTIFY_ORDER_HIGH   |    \
                                            SF_NOTIFY_ORDER_MEDIUM |    \
                                            SF_NOTIFY_ORDER_LOW)

//
//  Filter version information, passed to GetFilterVersion
//

typedef struct _HTTP_FILTER_VERSION
{
    //
    //  Version of the spec the server is using
    //

    DWORD  dwServerFilterVersion;

    //
    //  Fields specified by the client
    //

    DWORD  dwFilterVersion;
    CHAR   lpszFilterDesc[SF_MAX_FILTER_DESC_LEN];
    DWORD  dwFlags;


} HTTP_FILTER_VERSION, *PHTTP_FILTER_VERSION;



//
//  A filter DLL's entry point looks like this.  The return code should be
//  an SF_STATUS_TYPE
//
//  NotificationType - Type of notification
//  pvNotification - Pointer to notification specific data
//

DWORD
WINAPI
HttpFilterProc(
    HTTP_FILTER_CONTEXT *      pfc,
    DWORD                      NotificationType,
    VOID *                     pvNotification
    );

BOOL
WINAPI
GetFilterVersion(
    HTTP_FILTER_VERSION * pVer
    );

BOOL
WINAPI
TerminateFilter(
    DWORD dwFlags
    );

#ifdef __cplusplus
}
#endif


#endif //_HTTPFILT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\icontact.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES.
//

#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0286 */
/* at Mon Jan 22 12:13:56 2007
 */
/* Compiler settings for ..\icontact.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __icontact_h__
#define __icontact_h__

/* Forward Declarations */ 

#ifndef __IContactManager_FWD_DEFINED__
#define __IContactManager_FWD_DEFINED__
typedef interface IContactManager IContactManager;
#endif 	/* __IContactManager_FWD_DEFINED__ */


#ifndef __IContactCollection_FWD_DEFINED__
#define __IContactCollection_FWD_DEFINED__
typedef interface IContactCollection IContactCollection;
#endif 	/* __IContactCollection_FWD_DEFINED__ */


#ifndef __IContactProperties_FWD_DEFINED__
#define __IContactProperties_FWD_DEFINED__
typedef interface IContactProperties IContactProperties;
#endif 	/* __IContactProperties_FWD_DEFINED__ */


#ifndef __IContact_FWD_DEFINED__
#define __IContact_FWD_DEFINED__
typedef interface IContact IContact;
#endif 	/* __IContact_FWD_DEFINED__ */


#ifndef __IContactPropertyCollection_FWD_DEFINED__
#define __IContactPropertyCollection_FWD_DEFINED__
typedef interface IContactPropertyCollection IContactPropertyCollection;
#endif 	/* __IContactPropertyCollection_FWD_DEFINED__ */


#ifndef __Contact_FWD_DEFINED__
#define __Contact_FWD_DEFINED__

#ifdef __cplusplus
typedef class Contact Contact;
#else
typedef struct Contact Contact;
#endif /* __cplusplus */

#endif 	/* __Contact_FWD_DEFINED__ */


#ifndef __ContactManager_FWD_DEFINED__
#define __ContactManager_FWD_DEFINED__

#ifdef __cplusplus
typedef class ContactManager ContactManager;
#else
typedef struct ContactManager ContactManager;
#endif /* __cplusplus */

#endif 	/* __ContactManager_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_icontact_0000 */
/* [local] */ 







extern RPC_IF_HANDLE __MIDL_itf_icontact_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_icontact_0000_v0_0_s_ifspec;

#ifndef __IContactManager_INTERFACE_DEFINED__
#define __IContactManager_INTERFACE_DEFINED__

/* interface IContactManager */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IContactManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ad553d98-deb1-474a-8e17-fc0c2075b738")
    IContactManager : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [unique][string][in] */ LPCWSTR pszAppName,
            /* [unique][string][in] */ LPCWSTR pszAppVersion) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Load( 
            /* [unique][string][in] */ LPCWSTR pszContactID,
            /* [out] */ IContact __RPC_FAR *__RPC_FAR *ppContact) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MergeContactIDs( 
            /* [unique][string][in] */ LPCWSTR pszNewContactID,
            /* [unique][string][in] */ LPCWSTR pszOldContactID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMeContact( 
            /* [out] */ IContact __RPC_FAR *__RPC_FAR *ppMeContact) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMeContact( 
            /* [in] */ IContact __RPC_FAR *pMeContact) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetContactCollection( 
            /* [out] */ IContactCollection __RPC_FAR *__RPC_FAR *ppContactCollection) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IContactManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IContactManager __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IContactManager __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IContactManager __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Initialize )( 
            IContactManager __RPC_FAR * This,
            /* [unique][string][in] */ LPCWSTR pszAppName,
            /* [unique][string][in] */ LPCWSTR pszAppVersion);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Load )( 
            IContactManager __RPC_FAR * This,
            /* [unique][string][in] */ LPCWSTR pszContactID,
            /* [out] */ IContact __RPC_FAR *__RPC_FAR *ppContact);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MergeContactIDs )( 
            IContactManager __RPC_FAR * This,
            /* [unique][string][in] */ LPCWSTR pszNewContactID,
            /* [unique][string][in] */ LPCWSTR pszOldContactID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMeContact )( 
            IContactManager __RPC_FAR * This,
            /* [out] */ IContact __RPC_FAR *__RPC_FAR *ppMeContact);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetMeContact )( 
            IContactManager __RPC_FAR * This,
            /* [in] */ IContact __RPC_FAR *pMeContact);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetContactCollection )( 
            IContactManager __RPC_FAR * This,
            /* [out] */ IContactCollection __RPC_FAR *__RPC_FAR *ppContactCollection);
        
        END_INTERFACE
    } IContactManagerVtbl;

    interface IContactManager
    {
        CONST_VTBL struct IContactManagerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IContactManager_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IContactManager_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IContactManager_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IContactManager_Initialize(This,pszAppName,pszAppVersion)	\
    (This)->lpVtbl -> Initialize(This,pszAppName,pszAppVersion)

#define IContactManager_Load(This,pszContactID,ppContact)	\
    (This)->lpVtbl -> Load(This,pszContactID,ppContact)

#define IContactManager_MergeContactIDs(This,pszNewContactID,pszOldContactID)	\
    (This)->lpVtbl -> MergeContactIDs(This,pszNewContactID,pszOldContactID)

#define IContactManager_GetMeContact(This,ppMeContact)	\
    (This)->lpVtbl -> GetMeContact(This,ppMeContact)

#define IContactManager_SetMeContact(This,pMeContact)	\
    (This)->lpVtbl -> SetMeContact(This,pMeContact)

#define IContactManager_GetContactCollection(This,ppContactCollection)	\
    (This)->lpVtbl -> GetContactCollection(This,ppContactCollection)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IContactManager_Initialize_Proxy( 
    IContactManager __RPC_FAR * This,
    /* [unique][string][in] */ LPCWSTR pszAppName,
    /* [unique][string][in] */ LPCWSTR pszAppVersion);


void __RPC_STUB IContactManager_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IContactManager_Load_Proxy( 
    IContactManager __RPC_FAR * This,
    /* [unique][string][in] */ LPCWSTR pszContactID,
    /* [out] */ IContact __RPC_FAR *__RPC_FAR *ppContact);


void __RPC_STUB IContactManager_Load_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IContactManager_MergeContactIDs_Proxy( 
    IContactManager __RPC_FAR * This,
    /* [unique][string][in] */ LPCWSTR pszNewContactID,
    /* [unique][string][in] */ LPCWSTR pszOldContactID);


void __RPC_STUB IContactManager_MergeContactIDs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IContactManager_GetMeContact_Proxy( 
    IContactManager __RPC_FAR * This,
    /* [out] */ IContact __RPC_FAR *__RPC_FAR *ppMeContact);


void __RPC_STUB IContactManager_GetMeContact_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IContactManager_SetMeContact_Proxy( 
    IContactManager __RPC_FAR * This,
    /* [in] */ IContact __RPC_FAR *pMeContact);


void __RPC_STUB IContactManager_SetMeContact_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IContactManager_GetContactCollection_Proxy( 
    IContactManager __RPC_FAR * This,
    /* [out] */ IContactCollection __RPC_FAR *__RPC_FAR *ppContactCollection);


void __RPC_STUB IContactManager_GetContactCollection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IContactManager_INTERFACE_DEFINED__ */


#ifndef __IContactCollection_INTERFACE_DEFINED__
#define __IContactCollection_INTERFACE_DEFINED__

/* interface IContactCollection */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IContactCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b6afa338-d779-11d9-8bde-f66bad1e3f3a")
    IContactCollection : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrent( 
            /* [out] */ IContact __RPC_FAR *__RPC_FAR *ppContact) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IContactCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IContactCollection __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IContactCollection __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IContactCollection __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IContactCollection __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IContactCollection __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCurrent )( 
            IContactCollection __RPC_FAR * This,
            /* [out] */ IContact __RPC_FAR *__RPC_FAR *ppContact);
        
        END_INTERFACE
    } IContactCollectionVtbl;

    interface IContactCollection
    {
        CONST_VTBL struct IContactCollectionVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IContactCollection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IContactCollection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IContactCollection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IContactCollection_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IContactCollection_Next(This)	\
    (This)->lpVtbl -> Next(This)

#define IContactCollection_GetCurrent(This,ppContact)	\
    (This)->lpVtbl -> GetCurrent(This,ppContact)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IContactCollection_Reset_Proxy( 
    IContactCollection __RPC_FAR * This);


void __RPC_STUB IContactCollection_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IContactCollection_Next_Proxy( 
    IContactCollection __RPC_FAR * This);


void __RPC_STUB IContactCollection_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IContactCollection_GetCurrent_Proxy( 
    IContactCollection __RPC_FAR * This,
    /* [out] */ IContact __RPC_FAR *__RPC_FAR *ppContact);


void __RPC_STUB IContactCollection_GetCurrent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IContactCollection_INTERFACE_DEFINED__ */


#ifndef __IContactProperties_INTERFACE_DEFINED__
#define __IContactProperties_INTERFACE_DEFINED__

/* interface IContactProperties */
/* [unique][helpstring][uuid][object] */ 

#define CGD_DEFAULT                      0x00000000

EXTERN_C const IID IID_IContactProperties;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("70dd27dd-5cbd-46e8-bef0-23b6b346288f")
    IContactProperties : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetString( 
            /* [unique][string][in] */ LPCWSTR pszPropertyName,
            DWORD dwFlags,
            /* [size_is][unique][string][out][in] */ LPWSTR pszValue,
            /* [in] */ DWORD cchValue,
            /* [unique][out][in] */ DWORD __RPC_FAR *pdwcchPropertyValueRequired) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDate( 
            /* [unique][string][in] */ LPCWSTR pszPropertyName,
            DWORD dwFlags,
            /* [unique][out][in] */ FILETIME __RPC_FAR *pftDateTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBinary( 
            /* [unique][string][in] */ LPCWSTR pszPropertyName,
            DWORD dwFlags,
            /* [size_is][unique][out][in] */ LPWSTR pszContentType,
            /* [in] */ DWORD cchContentType,
            /* [unique][out][in] */ DWORD __RPC_FAR *pdwcchContentTypeRequired,
            /* [out] */ IStream __RPC_FAR *__RPC_FAR *ppStream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLabels( 
            /* [unique][string][in] */ LPCWSTR pszArrayElementName,
            DWORD dwFlags,
            /* [size_is][unique][out][in] */ LPWSTR pszLabels,
            /* [in] */ DWORD cchLabels,
            /* [unique][out][in] */ DWORD __RPC_FAR *pdwcchLabelsRequired) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetString( 
            /* [unique][string][in] */ LPCWSTR pszPropertyName,
            DWORD dwFlags,
            /* [unique][string][in] */ LPCWSTR pszValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDate( 
            /* [unique][string][in] */ LPCWSTR pszPropertyName,
            DWORD dwFlags,
            /* [in] */ FILETIME ftDateTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBinary( 
            /* [unique][string][in] */ LPCWSTR pszPropertyName,
            DWORD dwFlags,
            /* [unique][string][in] */ LPCWSTR pszContentType,
            /* [unique][in] */ IStream __RPC_FAR *pStream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLabels( 
            /* [unique][string][in] */ LPCWSTR pszArrayElementName,
            DWORD dwFlags,
            /* [in] */ DWORD dwLabelCount,
            /* [unique][size_is][in] */ LPCWSTR __RPC_FAR ppszLabels[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateArrayNode( 
            /* [unique][string][in] */ LPCWSTR pszArrayName,
            DWORD dwFlags,
            BOOL fAppend,
            /* [size_is][string][unique][out][in] */ LPWSTR pszNewArrayElementName,
            DWORD cchNewArrayElementName,
            /* [unique][out][in] */ DWORD __RPC_FAR *pdwcchNewArrayElementNameRequired) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteProperty( 
            /* [unique][string][in] */ LPCWSTR pszPropertyName,
            DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteArrayNode( 
            /* [unique][string][in] */ LPCWSTR pszArrayElementName,
            DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteLabels( 
            /* [unique][string][in] */ LPCWSTR pszArrayElementName,
            DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPropertyCollection( 
            /* [out] */ IContactPropertyCollection __RPC_FAR *__RPC_FAR *ppPropertyCollection,
            DWORD dwFlags,
            /* [unique][string][in] */ LPCWSTR pszMultiValueName,
            /* [in] */ DWORD dwLabelCount,
            /* [unique][size_is][in] */ LPCWSTR __RPC_FAR ppszLabels[  ],
            BOOL fAnyLabelMatches) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IContactPropertiesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IContactProperties __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IContactProperties __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IContactProperties __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetString )( 
            IContactProperties __RPC_FAR * This,
            /* [unique][string][in] */ LPCWSTR pszPropertyName,
            DWORD dwFlags,
            /* [size_is][unique][string][out][in] */ LPWSTR pszValue,
            /* [in] */ DWORD cchValue,
            /* [unique][out][in] */ DWORD __RPC_FAR *pdwcchPropertyValueRequired);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDate )( 
            IContactProperties __RPC_FAR * This,
            /* [unique][string][in] */ LPCWSTR pszPropertyName,
            DWORD dwFlags,
            /* [unique][out][in] */ FILETIME __RPC_FAR *pftDateTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBinary )( 
            IContactProperties __RPC_FAR * This,
            /* [unique][string][in] */ LPCWSTR pszPropertyName,
            DWORD dwFlags,
            /* [size_is][unique][out][in] */ LPWSTR pszContentType,
            /* [in] */ DWORD cchContentType,
            /* [unique][out][in] */ DWORD __RPC_FAR *pdwcchContentTypeRequired,
            /* [out] */ IStream __RPC_FAR *__RPC_FAR *ppStream);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLabels )( 
            IContactProperties __RPC_FAR * This,
            /* [unique][string][in] */ LPCWSTR pszArrayElementName,
            DWORD dwFlags,
            /* [size_is][unique][out][in] */ LPWSTR pszLabels,
            /* [in] */ DWORD cchLabels,
            /* [unique][out][in] */ DWORD __RPC_FAR *pdwcchLabelsRequired);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetString )( 
            IContactProperties __RPC_FAR * This,
            /* [unique][string][in] */ LPCWSTR pszPropertyName,
            DWORD dwFlags,
            /* [unique][string][in] */ LPCWSTR pszValue);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDate )( 
            IContactProperties __RPC_FAR * This,
            /* [unique][string][in] */ LPCWSTR pszPropertyName,
            DWORD dwFlags,
            /* [in] */ FILETIME ftDateTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBinary )( 
            IContactProperties __RPC_FAR * This,
            /* [unique][string][in] */ LPCWSTR pszPropertyName,
            DWORD dwFlags,
            /* [unique][string][in] */ LPCWSTR pszContentType,
            /* [unique][in] */ IStream __RPC_FAR *pStream);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetLabels )( 
            IContactProperties __RPC_FAR * This,
            /* [unique][string][in] */ LPCWSTR pszArrayElementName,
            DWORD dwFlags,
            /* [in] */ DWORD dwLabelCount,
            /* [unique][size_is][in] */ LPCWSTR __RPC_FAR ppszLabels[  ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateArrayNode )( 
            IContactProperties __RPC_FAR * This,
            /* [unique][string][in] */ LPCWSTR pszArrayName,
            DWORD dwFlags,
            BOOL fAppend,
            /* [size_is][string][unique][out][in] */ LPWSTR pszNewArrayElementName,
            DWORD cchNewArrayElementName,
            /* [unique][out][in] */ DWORD __RPC_FAR *pdwcchNewArrayElementNameRequired);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteProperty )( 
            IContactProperties __RPC_FAR * This,
            /* [unique][string][in] */ LPCWSTR pszPropertyName,
            DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteArrayNode )( 
            IContactProperties __RPC_FAR * This,
            /* [unique][string][in] */ LPCWSTR pszArrayElementName,
            DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteLabels )( 
            IContactProperties __RPC_FAR * This,
            /* [unique][string][in] */ LPCWSTR pszArrayElementName,
            DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPropertyCollection )( 
            IContactProperties __RPC_FAR * This,
            /* [out] */ IContactPropertyCollection __RPC_FAR *__RPC_FAR *ppPropertyCollection,
            DWORD dwFlags,
            /* [unique][string][in] */ LPCWSTR pszMultiValueName,
            /* [in] */ DWORD dwLabelCount,
            /* [unique][size_is][in] */ LPCWSTR __RPC_FAR ppszLabels[  ],
            BOOL fAnyLabelMatches);
        
        END_INTERFACE
    } IContactPropertiesVtbl;

    interface IContactProperties
    {
        CONST_VTBL struct IContactPropertiesVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IContactProperties_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IContactProperties_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IContactProperties_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IContactProperties_GetString(This,pszPropertyName,dwFlags,pszValue,cchValue,pdwcchPropertyValueRequired)	\
    (This)->lpVtbl -> GetString(This,pszPropertyName,dwFlags,pszValue,cchValue,pdwcchPropertyValueRequired)

#define IContactProperties_GetDate(This,pszPropertyName,dwFlags,pftDateTime)	\
    (This)->lpVtbl -> GetDate(This,pszPropertyName,dwFlags,pftDateTime)

#define IContactProperties_GetBinary(This,pszPropertyName,dwFlags,pszContentType,cchContentType,pdwcchContentTypeRequired,ppStream)	\
    (This)->lpVtbl -> GetBinary(This,pszPropertyName,dwFlags,pszContentType,cchContentType,pdwcchContentTypeRequired,ppStream)

#define IContactProperties_GetLabels(This,pszArrayElementName,dwFlags,pszLabels,cchLabels,pdwcchLabelsRequired)	\
    (This)->lpVtbl -> GetLabels(This,pszArrayElementName,dwFlags,pszLabels,cchLabels,pdwcchLabelsRequired)

#define IContactProperties_SetString(This,pszPropertyName,dwFlags,pszValue)	\
    (This)->lpVtbl -> SetString(This,pszPropertyName,dwFlags,pszValue)

#define IContactProperties_SetDate(This,pszPropertyName,dwFlags,ftDateTime)	\
    (This)->lpVtbl -> SetDate(This,pszPropertyName,dwFlags,ftDateTime)

#define IContactProperties_SetBinary(This,pszPropertyName,dwFlags,pszContentType,pStream)	\
    (This)->lpVtbl -> SetBinary(This,pszPropertyName,dwFlags,pszContentType,pStream)

#define IContactProperties_SetLabels(This,pszArrayElementName,dwFlags,dwLabelCount,ppszLabels)	\
    (This)->lpVtbl -> SetLabels(This,pszArrayElementName,dwFlags,dwLabelCount,ppszLabels)

#define IContactProperties_CreateArrayNode(This,pszArrayName,dwFlags,fAppend,pszNewArrayElementName,cchNewArrayElementName,pdwcchNewArrayElementNameRequired)	\
    (This)->lpVtbl -> CreateArrayNode(This,pszArrayName,dwFlags,fAppend,pszNewArrayElementName,cchNewArrayElementName,pdwcchNewArrayElementNameRequired)

#define IContactProperties_DeleteProperty(This,pszPropertyName,dwFlags)	\
    (This)->lpVtbl -> DeleteProperty(This,pszPropertyName,dwFlags)

#define IContactProperties_DeleteArrayNode(This,pszArrayElementName,dwFlags)	\
    (This)->lpVtbl -> DeleteArrayNode(This,pszArrayElementName,dwFlags)

#define IContactProperties_DeleteLabels(This,pszArrayElementName,dwFlags)	\
    (This)->lpVtbl -> DeleteLabels(This,pszArrayElementName,dwFlags)

#define IContactProperties_GetPropertyCollection(This,ppPropertyCollection,dwFlags,pszMultiValueName,dwLabelCount,ppszLabels,fAnyLabelMatches)	\
    (This)->lpVtbl -> GetPropertyCollection(This,ppPropertyCollection,dwFlags,pszMultiValueName,dwLabelCount,ppszLabels,fAnyLabelMatches)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IContactProperties_GetString_Proxy( 
    IContactProperties __RPC_FAR * This,
    /* [unique][string][in] */ LPCWSTR pszPropertyName,
    DWORD dwFlags,
    /* [size_is][unique][string][out][in] */ LPWSTR pszValue,
    /* [in] */ DWORD cchValue,
    /* [unique][out][in] */ DWORD __RPC_FAR *pdwcchPropertyValueRequired);


void __RPC_STUB IContactProperties_GetString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IContactProperties_GetDate_Proxy( 
    IContactProperties __RPC_FAR * This,
    /* [unique][string][in] */ LPCWSTR pszPropertyName,
    DWORD dwFlags,
    /* [unique][out][in] */ FILETIME __RPC_FAR *pftDateTime);


void __RPC_STUB IContactProperties_GetDate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IContactProperties_GetBinary_Proxy( 
    IContactProperties __RPC_FAR * This,
    /* [unique][string][in] */ LPCWSTR pszPropertyName,
    DWORD dwFlags,
    /* [size_is][unique][out][in] */ LPWSTR pszContentType,
    /* [in] */ DWORD cchContentType,
    /* [unique][out][in] */ DWORD __RPC_FAR *pdwcchContentTypeRequired,
    /* [out] */ IStream __RPC_FAR *__RPC_FAR *ppStream);


void __RPC_STUB IContactProperties_GetBinary_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IContactProperties_GetLabels_Proxy( 
    IContactProperties __RPC_FAR * This,
    /* [unique][string][in] */ LPCWSTR pszArrayElementName,
    DWORD dwFlags,
    /* [size_is][unique][out][in] */ LPWSTR pszLabels,
    /* [in] */ DWORD cchLabels,
    /* [unique][out][in] */ DWORD __RPC_FAR *pdwcchLabelsRequired);


void __RPC_STUB IContactProperties_GetLabels_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IContactProperties_SetString_Proxy( 
    IContactProperties __RPC_FAR * This,
    /* [unique][string][in] */ LPCWSTR pszPropertyName,
    DWORD dwFlags,
    /* [unique][string][in] */ LPCWSTR pszValue);


void __RPC_STUB IContactProperties_SetString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IContactProperties_SetDate_Proxy( 
    IContactProperties __RPC_FAR * This,
    /* [unique][string][in] */ LPCWSTR pszPropertyName,
    DWORD dwFlags,
    /* [in] */ FILETIME ftDateTime);


void __RPC_STUB IContactProperties_SetDate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IContactProperties_SetBinary_Proxy( 
    IContactProperties __RPC_FAR * This,
    /* [unique][string][in] */ LPCWSTR pszPropertyName,
    DWORD dwFlags,
    /* [unique][string][in] */ LPCWSTR pszContentType,
    /* [unique][in] */ IStream __RPC_FAR *pStream);


void __RPC_STUB IContactProperties_SetBinary_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IContactProperties_SetLabels_Proxy( 
    IContactProperties __RPC_FAR * This,
    /* [unique][string][in] */ LPCWSTR pszArrayElementName,
    DWORD dwFlags,
    /* [in] */ DWORD dwLabelCount,
    /* [unique][size_is][in] */ LPCWSTR __RPC_FAR ppszLabels[  ]);


void __RPC_STUB IContactProperties_SetLabels_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IContactProperties_CreateArrayNode_Proxy( 
    IContactProperties __RPC_FAR * This,
    /* [unique][string][in] */ LPCWSTR pszArrayName,
    DWORD dwFlags,
    BOOL fAppend,
    /* [size_is][string][unique][out][in] */ LPWSTR pszNewArrayElementName,
    DWORD cchNewArrayElementName,
    /* [unique][out][in] */ DWORD __RPC_FAR *pdwcchNewArrayElementNameRequired);


void __RPC_STUB IContactProperties_CreateArrayNode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IContactProperties_DeleteProperty_Proxy( 
    IContactProperties __RPC_FAR * This,
    /* [unique][string][in] */ LPCWSTR pszPropertyName,
    DWORD dwFlags);


void __RPC_STUB IContactProperties_DeleteProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IContactProperties_DeleteArrayNode_Proxy( 
    IContactProperties __RPC_FAR * This,
    /* [unique][string][in] */ LPCWSTR pszArrayElementName,
    DWORD dwFlags);


void __RPC_STUB IContactProperties_DeleteArrayNode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IContactProperties_DeleteLabels_Proxy( 
    IContactProperties __RPC_FAR * This,
    /* [unique][string][in] */ LPCWSTR pszArrayElementName,
    DWORD dwFlags);


void __RPC_STUB IContactProperties_DeleteLabels_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IContactProperties_GetPropertyCollection_Proxy( 
    IContactProperties __RPC_FAR * This,
    /* [out] */ IContactPropertyCollection __RPC_FAR *__RPC_FAR *ppPropertyCollection,
    DWORD dwFlags,
    /* [unique][string][in] */ LPCWSTR pszMultiValueName,
    /* [in] */ DWORD dwLabelCount,
    /* [unique][size_is][in] */ LPCWSTR __RPC_FAR ppszLabels[  ],
    BOOL fAnyLabelMatches);


void __RPC_STUB IContactProperties_GetPropertyCollection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IContactProperties_INTERFACE_DEFINED__ */


#ifndef __IContact_INTERFACE_DEFINED__
#define __IContact_INTERFACE_DEFINED__

/* interface IContact */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IContact;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F941B671-BDA7-4f77-884A-F46462F226A7")
    IContact : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetContactID( 
            /* [size_is][string][out][in] */ LPWSTR pszContactID,
            /* [in] */ DWORD cchContactID,
            /* [unique][out][in] */ DWORD __RPC_FAR *pdwcchContactIDRequired) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPath( 
            /* [size_is][string][out][in] */ LPWSTR pszPath,
            /* [in] */ DWORD cchPath,
            /* [unique][out][in] */ DWORD __RPC_FAR *pdwcchPathRequired) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CommitChanges( 
            /* [in] */ DWORD dwCommitFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IContactVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IContact __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IContact __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IContact __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetContactID )( 
            IContact __RPC_FAR * This,
            /* [size_is][string][out][in] */ LPWSTR pszContactID,
            /* [in] */ DWORD cchContactID,
            /* [unique][out][in] */ DWORD __RPC_FAR *pdwcchContactIDRequired);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPath )( 
            IContact __RPC_FAR * This,
            /* [size_is][string][out][in] */ LPWSTR pszPath,
            /* [in] */ DWORD cchPath,
            /* [unique][out][in] */ DWORD __RPC_FAR *pdwcchPathRequired);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CommitChanges )( 
            IContact __RPC_FAR * This,
            /* [in] */ DWORD dwCommitFlags);
        
        END_INTERFACE
    } IContactVtbl;

    interface IContact
    {
        CONST_VTBL struct IContactVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IContact_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IContact_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IContact_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IContact_GetContactID(This,pszContactID,cchContactID,pdwcchContactIDRequired)	\
    (This)->lpVtbl -> GetContactID(This,pszContactID,cchContactID,pdwcchContactIDRequired)

#define IContact_GetPath(This,pszPath,cchPath,pdwcchPathRequired)	\
    (This)->lpVtbl -> GetPath(This,pszPath,cchPath,pdwcchPathRequired)

#define IContact_CommitChanges(This,dwCommitFlags)	\
    (This)->lpVtbl -> CommitChanges(This,dwCommitFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IContact_GetContactID_Proxy( 
    IContact __RPC_FAR * This,
    /* [size_is][string][out][in] */ LPWSTR pszContactID,
    /* [in] */ DWORD cchContactID,
    /* [unique][out][in] */ DWORD __RPC_FAR *pdwcchContactIDRequired);


void __RPC_STUB IContact_GetContactID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IContact_GetPath_Proxy( 
    IContact __RPC_FAR * This,
    /* [size_is][string][out][in] */ LPWSTR pszPath,
    /* [in] */ DWORD cchPath,
    /* [unique][out][in] */ DWORD __RPC_FAR *pdwcchPathRequired);


void __RPC_STUB IContact_GetPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IContact_CommitChanges_Proxy( 
    IContact __RPC_FAR * This,
    /* [in] */ DWORD dwCommitFlags);


void __RPC_STUB IContact_CommitChanges_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IContact_INTERFACE_DEFINED__ */


#ifndef __IContactPropertyCollection_INTERFACE_DEFINED__
#define __IContactPropertyCollection_INTERFACE_DEFINED__

/* interface IContactPropertyCollection */
/* [unique][helpstring][uuid][object] */ 

#define CGD_UNKNOWN_PROPERTY     0x00000000
#define CGD_STRING_PROPERTY      0x00000001
#define CGD_DATE_PROPERTY        0x00000002
#define CGD_BINARY_PROPERTY      0x00000004
#define CGD_ARRAY_NODE           0x00000008

EXTERN_C const IID IID_IContactPropertyCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ffd3adf8-fa64-4328-b1b6-2e0db509cb3c")
    IContactPropertyCollection : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPropertyName( 
            /* [unique][size_is][string][unique][out][in] */ LPWSTR pszPropertyName,
            /* [in] */ DWORD cchPropertyName,
            /* [unique][out][in] */ DWORD __RPC_FAR *pdwcchPropertyNameRequired) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPropertyType( 
            /* [unique][out][in] */ DWORD __RPC_FAR *pdwType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPropertyVersion( 
            /* [unique][out][in] */ DWORD __RPC_FAR *pdwVersion) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPropertyModificationDate( 
            /* [unique][out][in] */ FILETIME __RPC_FAR *pftModificationDate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPropertyArrayElementID( 
            /* [unique][size_is][string][unique][out][in] */ LPWSTR pszArrayElementID,
            /* [in] */ DWORD cchArrayElementID,
            /* [unique][out][in] */ DWORD __RPC_FAR *pdwcchArrayElementIDRequired) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IContactPropertyCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IContactPropertyCollection __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IContactPropertyCollection __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IContactPropertyCollection __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IContactPropertyCollection __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IContactPropertyCollection __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPropertyName )( 
            IContactPropertyCollection __RPC_FAR * This,
            /* [unique][size_is][string][unique][out][in] */ LPWSTR pszPropertyName,
            /* [in] */ DWORD cchPropertyName,
            /* [unique][out][in] */ DWORD __RPC_FAR *pdwcchPropertyNameRequired);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPropertyType )( 
            IContactPropertyCollection __RPC_FAR * This,
            /* [unique][out][in] */ DWORD __RPC_FAR *pdwType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPropertyVersion )( 
            IContactPropertyCollection __RPC_FAR * This,
            /* [unique][out][in] */ DWORD __RPC_FAR *pdwVersion);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPropertyModificationDate )( 
            IContactPropertyCollection __RPC_FAR * This,
            /* [unique][out][in] */ FILETIME __RPC_FAR *pftModificationDate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPropertyArrayElementID )( 
            IContactPropertyCollection __RPC_FAR * This,
            /* [unique][size_is][string][unique][out][in] */ LPWSTR pszArrayElementID,
            /* [in] */ DWORD cchArrayElementID,
            /* [unique][out][in] */ DWORD __RPC_FAR *pdwcchArrayElementIDRequired);
        
        END_INTERFACE
    } IContactPropertyCollectionVtbl;

    interface IContactPropertyCollection
    {
        CONST_VTBL struct IContactPropertyCollectionVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IContactPropertyCollection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IContactPropertyCollection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IContactPropertyCollection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IContactPropertyCollection_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IContactPropertyCollection_Next(This)	\
    (This)->lpVtbl -> Next(This)

#define IContactPropertyCollection_GetPropertyName(This,pszPropertyName,cchPropertyName,pdwcchPropertyNameRequired)	\
    (This)->lpVtbl -> GetPropertyName(This,pszPropertyName,cchPropertyName,pdwcchPropertyNameRequired)

#define IContactPropertyCollection_GetPropertyType(This,pdwType)	\
    (This)->lpVtbl -> GetPropertyType(This,pdwType)

#define IContactPropertyCollection_GetPropertyVersion(This,pdwVersion)	\
    (This)->lpVtbl -> GetPropertyVersion(This,pdwVersion)

#define IContactPropertyCollection_GetPropertyModificationDate(This,pftModificationDate)	\
    (This)->lpVtbl -> GetPropertyModificationDate(This,pftModificationDate)

#define IContactPropertyCollection_GetPropertyArrayElementID(This,pszArrayElementID,cchArrayElementID,pdwcchArrayElementIDRequired)	\
    (This)->lpVtbl -> GetPropertyArrayElementID(This,pszArrayElementID,cchArrayElementID,pdwcchArrayElementIDRequired)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IContactPropertyCollection_Reset_Proxy( 
    IContactPropertyCollection __RPC_FAR * This);


void __RPC_STUB IContactPropertyCollection_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IContactPropertyCollection_Next_Proxy( 
    IContactPropertyCollection __RPC_FAR * This);


void __RPC_STUB IContactPropertyCollection_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IContactPropertyCollection_GetPropertyName_Proxy( 
    IContactPropertyCollection __RPC_FAR * This,
    /* [unique][size_is][string][unique][out][in] */ LPWSTR pszPropertyName,
    /* [in] */ DWORD cchPropertyName,
    /* [unique][out][in] */ DWORD __RPC_FAR *pdwcchPropertyNameRequired);


void __RPC_STUB IContactPropertyCollection_GetPropertyName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IContactPropertyCollection_GetPropertyType_Proxy( 
    IContactPropertyCollection __RPC_FAR * This,
    /* [unique][out][in] */ DWORD __RPC_FAR *pdwType);


void __RPC_STUB IContactPropertyCollection_GetPropertyType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IContactPropertyCollection_GetPropertyVersion_Proxy( 
    IContactPropertyCollection __RPC_FAR * This,
    /* [unique][out][in] */ DWORD __RPC_FAR *pdwVersion);


void __RPC_STUB IContactPropertyCollection_GetPropertyVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IContactPropertyCollection_GetPropertyModificationDate_Proxy( 
    IContactPropertyCollection __RPC_FAR * This,
    /* [unique][out][in] */ FILETIME __RPC_FAR *pftModificationDate);


void __RPC_STUB IContactPropertyCollection_GetPropertyModificationDate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IContactPropertyCollection_GetPropertyArrayElementID_Proxy( 
    IContactPropertyCollection __RPC_FAR * This,
    /* [unique][size_is][string][unique][out][in] */ LPWSTR pszArrayElementID,
    /* [in] */ DWORD cchArrayElementID,
    /* [unique][out][in] */ DWORD __RPC_FAR *pdwcchArrayElementIDRequired);


void __RPC_STUB IContactPropertyCollection_GetPropertyArrayElementID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IContactPropertyCollection_INTERFACE_DEFINED__ */



#ifndef __CONTACT_LIBRARY_DEFINED__
#define __CONTACT_LIBRARY_DEFINED__

/* library CONTACT */
/* [version][lcid][helpstring][uuid] */ 


EXTERN_C const IID LIBID_CONTACT;

EXTERN_C const CLSID CLSID_Contact;

#ifdef __cplusplus

class DECLSPEC_UUID("61b68808-8eee-4fd1-acb8-3d804c8db056")
Contact;
#endif

EXTERN_C const CLSID CLSID_ContactManager;

#ifdef __cplusplus

class DECLSPEC_UUID("7165c8ab-af88-42bd-86fd-5310b4285a02")
ContactManager;
#endif
#endif /* __CONTACT_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\icontactproperties.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES.
//
/**************************************************************************\
    Copyright Microsoft Corporation. All Rights Reserved.
\**************************************************************************/


#ifndef _CONTACT_PROPERTIES_H_
#define _CONTACT_PROPERTIES_H_


// ===================================================================
// Windows contact schema
//
// DESCRIPTION:
//      This defines how the contact schema is used to read and write
//  contact properties via IContactProperties.
//
//
// STRUCTURE:
//      Contact properties fall into one of two categories:
//
//  Category 1 - Single Value: These properties have a single simple value
//                      and don't require a hierarchy structure.
//
//  Category 2 - Hierarchical: These properties have multiple values for any contact
//                      and require labeling to differentiate individual values.
//
//                      PhoneNumber is one example of this type of property
//                      Any given contact can have one or more home, work, and mobile phone numbers.
//
//
// PROPERTY EXTENSIBILITY:
//      All applications that use contacts need to have additional data available
//      on contacts that the base schema does not provide for.
//
//      There are two ways supported by IContactProperties to extend the contact schema.
//
//      1) Labels (arbitrary strings) can be applied to any existing OS contact array node.
//          Ex: phoneNumbers/PhoneNumber[1] can be labeled with the two labels: Preferred and Business.
//
//              The set of built-in labels for all multi value properties are:
//                    Preferred
//                    Personal
//                    Business
//                    Other
//
//                Some collections can have more labels set (PhoneNumber can have Mobile, Fax, ...)
//
//              Additional labels can be set.  Custom labels must be in the form of URIs.
//
//              Manipulation of labels can be done with IContactProperties::GetLabel / SetLabel / DeleteLabels
//
//              Filtering of data contact can be done with IContactProperties::GetPropertyCollection
//
//      2) New contact properties and array nodes can be defined by an application.
//            The data contained in these properties can be enumerated by other users of IContactProperties
//
//          To create a new property for an application, the same interface is used as standard properties.
//            Use the same property Set functions as built in properties.  The caller must prepend
//            a string with a namespace (in braces) for the contact property.
//
//              **NB: make sure the selected namespace is unique to avoid conflicts with other applications**
//
//           For the application custom.exe to Get or Set a new string property, use:
//              ex:   [CustomNameSpace]CustomStringProperty
//
//           Creating new multivalue properties is also supported.
//            The above syntax is extended to include an array node name
//            for the the call to IContactProperties::CreateArrayNode
//
//              ex:   [CustomNameSpace:CustomArrayNodeName]customArrayName
//
//            CreateArrayNode will return the new property name (as always) in the outbound arguments.
//
//===================================================================

// ===================================================================
// Single Value properties
//
// DESCRIPTION:
//      These properties are simple and have no hierarchy.
//

//
// String properties
//

// free text content
#define CONTACTPROP_PUB_NOTES                       L"Notes"

// contact's email program
#define CONTACTPROP_PUB_MAILER                      L"Mailer"
// ProgID
#define CONTACTPROP_PUB_PROGID                      L"ProgID"

// gender of contact
// Chooose one of L"Male", L"Female", L"Unspecified" (default)
#define CONTACTPROP_PUB_GENDER                      L"Gender"

#define     CONTACTPROP_PUB_GENDER_UNSPECIFIED          L"Unspecified"
#define     CONTACTPROP_PUB_GENDER_MALE                 L"Male"
#define     CONTACTPROP_PUB_GENDER_FEMALE               L"Female"

//
// DateTime Properties
//

// The date and time the contact was created in the system
#define CONTACTPROP_PUB_CREATIONDATE                L"CreationDate"



// ===================================================================
// Hierarchical properties
//
// DESCRIPTION:
//      These properties contain many values differentiated by labels
//
//      Individual properties are accessed via IContactProperties by index
//
//      examples property names include:
//          PhoneNumberCollection/PhoneNumber[1]/Number
//              for the 1st phone number on the contact
//
//          EmailAddressCollection/EmailAddress[4]/Address
//              for the 4th email address on the contact
//
//      Labels differentiate second level entries(L2) entries.
//          Programmatic access for labels is via IContactProperties (see icontact.idl)
//

//
// collection of ContactIDs associated with this contact
//
#define CONTACTPROP_PUB_L1_CONTACTIDCOLLECTION      L"ContactIDCollection"
// an entry in the collection of IDs
#define     CONTACTPROP_PUB_L2_CONTACTID                L"/ContactID"
// one of the unique identifiers for this contact (as a string)
#define         CONTACTPROP_PUB_L3_VALUE                    L"/Value"

//
// collection of names associated with this contact
//
#define CONTACTPROP_PUB_L1_NAMECOLLECTION           L"NameCollection"
// an entry in the collection of names
#define     CONTACTPROP_PUB_L2_NAME                     L"/Name"

//
// Contact data related to names
//

// as displayed
#define CONTACTPROP_PUB_L3_FORMATTEDNAME                    L"/FormattedName"
// as pronounced
#define CONTACTPROP_PUB_L3_PHONETIC                         L"/Phonetic"

#define CONTACTPROP_PUB_L3_PREFIX                           L"/Prefix"
#define CONTACTPROP_PUB_L3_TITLE                            L"/Title"
#define CONTACTPROP_PUB_L3_GIVENNAME                        L"/GivenName"
#define CONTACTPROP_PUB_L3_FAMILYNAME                       L"/FamilyName"
#define CONTACTPROP_PUB_L3_MIDDLENAME                       L"/MiddleName"
#define CONTACTPROP_PUB_L3_GENERATION                       L"/Generation"
#define CONTACTPROP_PUB_L3_SUFFIX                           L"/Suffix"
#define CONTACTPROP_PUB_L3_NICKNAME                         L"/NickName"

//
// Contact data relating to positions a contact holds
//
#define CONTACTPROP_PUB_L1_POSITIONCOLLECTION       L"PositionCollection"
// an entry in the collection of names
#define     CONTACTPROP_PUB_L2_POSITION                 L"/Position"

// the organization ex: IEEE
#define CONTACTPROP_PUB_L3_ORGANIZATION                     L"/Organization"
// the company ex: Microsoft
#define CONTACTPROP_PUB_L3_COMPANY                          L"/Company"
// the department ex: Windows
#define CONTACTPROP_PUB_L3_DEPARTMENT                       L"/Department"
// the office ex: Building A / Office 1234
#define CONTACTPROP_PUB_L3_OFFICE                           L"/Office"
// any job title ex: Software Engineer
#define CONTACTPROP_PUB_L3_JOB_TITLE                        L"/JobTitle"
// the line of work ex: Engineering
#define CONTACTPROP_PUB_L3_PROFESSION                       L"/Profession"
// the role in the organization ex: Quality Assurance
#define CONTACTPROP_PUB_L3_ROLE                             L"/Role"



//
// people associated with the contact
//
#define CONTACTPROP_PUB_L1_PERSONCOLLECTION         L"PersonCollection"
// entry in the collection
#define     CONTACTPROP_PUB_L2_PERSON                   L"/Person"
//
// Use labels to indicate the relationship to contact
// ex:
//      wab:Spouse
//      wab:Child
//      wab:Manager
//      wab:Assistant

// person's formatted (display) name - (as string)
#define CONTACTPROP_PUB_L3_FORMATTEDNAME                    L"/FormattedName"

// a unique identifier for this person (optional),
// which may be one of the ContactIDs contained in an IContact 
#define CONTACTPROP_PUB_L3_PERSONID                        L"/PersonID"

//
// calendar dates associated with the contact
//
#define CONTACTPROP_PUB_L1_DATECOLLECTION           L"DateCollection"
// entry in the collection
#define     CONTACTPROP_PUB_L2_DATE                     L"/Date"
//
// Use labels to indicate the type of data being expressed.
// ex: 
//    wab:Birthday - the date of birth for the contact
//    wab:Anniversary - the spouse anniversary date for the contact

// value for this date, as a DateTime
#define         CONTACTPROP_PUB_L3_VALUE                    L"/Value"


//
// email addresses
//
#define CONTACTPROP_PUB_L1_EMAILADDRESSCOLLECTION       L"EmailAddressCollection"
// entry in the collection
#define     CONTACTPROP_PUB_L2_EMAILADDRESS                 L"/EmailAddress"
// example@microsoft.com (as string)
#define             CONTACTPROP_PUB_L3_ADDRESS                  L"/Address"
// type of address (e.g. SMTP, x509)
#define             CONTACTPROP_PUB_L3_TYPE                     L"/Type"


//
// certificate data and thumbprints
//

#define CONTACTPROP_PUB_L1_CERTIFICATECOLLECTION        L"CertificateCollection"
// entry in the collection
#define     CONTACTPROP_PUB_L2_CERTIFICATE                  L"/Certificate"
// certificate value
#define         CONTACTPROP_PUB_L3_VALUE                        L"/Value"
// thumbprint value
#define         CONTACTPROP_PUB_L3_THUMBPRINT                   L"/ThumbPrint"

//
// phone numbers
//
#define CONTACTPROP_PUB_L1_PHONENUMBERCOLLECTION    L"PhoneNumberCollection"
// entry in the collection
#define     CONTACTPROP_PUB_L2_PHONENUMBER              L"/PhoneNumber"
// normal number to display (as string)
#define             CONTACTPROP_PUB_L3_NUMBER               L"/Number"
// alternate number (tty) (as string)
#define             CONTACTPROP_PUB_L3_ALTERNATE            L"/Alternate"


//
// physical addresses
//
#define CONTACTPROP_PUB_L1_PHYSICALADDRESSCOLLECTION    L"PhysicalAddressCollection"
// entry in the collection
#define     CONTACTPROP_PUB_L2_PHYSICALADDRESS              L"/PhysicalAddress"
// the exact data that a mailing label should have
#define             CONTACTPROP_PUB_L3_ADDRESSLABEL             L"/AddressLabel"
// number and street
#define             CONTACTPROP_PUB_L3_STREET                   L"/Street"
// City
#define             CONTACTPROP_PUB_L3_LOCALITY                 L"/Locality"
// State/Providence
#define             CONTACTPROP_PUB_L3_REGION                   L"/Region"
// Zip / PostalCode
#define             CONTACTPROP_PUB_L3_POSTALCODE               L"/PostalCode"
// the country
#define             CONTACTPROP_PUB_L3_COUNTRY                  L"/Country"
// any POBox number
#define             CONTACTPROP_PUB_L3_POBOX                    L"/POBox"
// any extra information
#define             CONTACTPROP_PUB_L3_EXTENDEDADDRESS          L"/ExtendedAddress"

//
// Instant Messaging Addresess and protocols
//
#define CONTACTPROP_PUB_L1_IMADDRESSCOLLECTION              L"IMAddressCollection"
#define     CONTACTPROP_PUB_L2_IMADDRESSENTRY                   L"/IMAddress"
// the identifing data for this ImAddress (ex: username@microsoft.com)
#define         CONTACTPROP_PUB_L3_VALUE                        L"/Value"
// the string protocol used for this ImAddress (ex: Messenger Protocol)
#define         CONTACTPROP_PUB_L3_PROTOCOL                     L"/Protocol"

//
// collection of URLs associated with this contact
//
#define CONTACTPROP_PUB_L1_URLCOLLECTION            L"UrlCollection"
// an entry in the collection of url
#define     CONTACTPROP_PUB_L2_URL                      L"/Url"
// the actual URL data
#define         CONTACTPROP_PUB_L3_VALUE                    L"/Value"

//
// collection of images associated with this contact
//
#define CONTACTPROP_PUB_L1_PHOTOCOLLECTION          L"PhotoCollection"
// an entry in the collection of photos
#define CONTACTPROP_PUB_L2_PHOTO                        L"/Photo"
// an image to use for representing the contact - as binary, with MIME type
#define CONTACTPROP_PUB_L3_VALUE                            L"/Value"
// a URL for retrieving the image - as a string
#define CONTACTPROP_PUB_L3_URL                              L"/Url"



// ===================================================================
//
// Common Labels that may be associated with any contact properties.
//

//
// Labels can also be URIs.  See comment at beginning of this file
//

// NOTE: many entries in a set may have this "Preferred" label set
#define CONTACTLABEL_PUB_PREFERRED                   L"Preferred"

// Home related data
#define CONTACTLABEL_PUB_PERSONAL                    L"Personal"

// Work related data
#define CONTACTLABEL_PUB_BUSINESS                    L"Business"

// other, non specified label
#define CONTACTLABEL_PUB_OTHER                       L"Other"

//
// Labels that can be associated with PhoneNumber elements
//

// number supports voice conversation
#define CONTACTLABEL_PUB_VOICE                       L"Voice"

// mobile phone number
#define CONTACTLABEL_PUB_MOBILE                      L"Mobile"

// PCS support
#define CONTACTLABEL_PUB_PCS                         L"PCS"

// cell phone support
#define CONTACTLABEL_PUB_CELLULAR                    L"Cellular"

// number travel with the Car
#define CONTACTLABEL_PUB_CAR                         L"Car"

// pager number
#define CONTACTLABEL_PUB_PAGER                       L"Pager"

// tty machine
#define CONTACTLABEL_PUB_TTY                         L"TTY"

// fax machine
#define CONTACTLABEL_PUB_FAX                         L"Fax"

// number supports video conversation
#define CONTACTLABEL_PUB_VIDEO                       L"Video"

// number for modem connection
#define CONTACTLABEL_PUB_MODEM                       L"Modem"

// number for BBS connection
#define CONTACTLABEL_PUB_BBS                         L"BBS"

// number for ISDN
#define CONTACTLABEL_PUB_ISDN                        L"ISDN"


//
// Labels that can be associated with Person elements
//

// to indicate this person is allowed to work on behalf of the contact
#define CONTACTLABEL_PUB_AGENT                       L"Agent"

//
// Labels that can be associated with PhysicalAddress elements
//

// a domestic mailing address
#define CONTACTLABEL_PUB_DOMESTIC                    L"Domestic"

// an international mailing address
#define CONTACTLABEL_PUB_INTERNATIONAL               L"International"

// a mailing address which accepts mail
#define CONTACTLABEL_PUB_POSTAL                      L"Postal"

// a mailing address that accepts packages
#define CONTACTLABEL_PUB_PARCEL                      L"Parcel"


//
// Labels that can be associated with Photo elements
//

// an image used to represent the contact
#define CONTACTLABEL_PUB_USERTILE                    L"UserTile"

// a logo associated with the contact (ex: image for organization)
#define CONTACTLABEL_PUB_LOGO                        L"Logo"

//
// windows address book specific labels
//

// for PersonCollection
#define CONTACTLABEL_WAB_SPOUSE                      L"wab:Spouse"
#define CONTACTLABEL_WAB_CHILD                       L"wab:Child"
#define CONTACTLABEL_WAB_MANAGER                     L"wab:Manager"
#define CONTACTLABEL_WAB_ASSISTANT                   L"wab:Assistant"

// for DateCollection 
#define CONTACTLABEL_WAB_BIRTHDAY                    L"wab:Birthday"
#define CONTACTLABEL_WAB_ANNIVERSARY                 L"wab:Anniversary"

// for UrlCollection
#define CONTACTLABEL_WAB_SOCIALNETWORK               L"wab:SocialNetwork"
#define CONTACTLABEL_WAB_SCHOOL                      L"wab:School"
#define CONTACTLABEL_WAB_WISHLIST                    L"wab:WishList"


#endif // _CONTACT_PROPERTIES_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\icwcfg.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES.
//
/********************************************************************

  ICWCFG.H

  Copyright(c) Microsoft Corporation, 1996-1998

  *** N O T   F O R   E X T E R N A L   R E L E A S E *******
  *
  * This header file is not intended for distribution outside Microsoft.
  *
  ***********************************************************

  Header file for Internet Connection Wizard external configuration
  routines found in INETCFG.DLL.

  Routines:

  CheckConnectionWizard - Checks which parts of ICW are installed
		and if it has been run before.  It optionally will start
		either the full or manual path of ICW if it is insalled
		but has not been run before.

  History:	10/22/96	Created
		10/24/96	Added defines and typedefs
		2/25/97		Added CreateDirectoryService -- jmazner
		4/24/97		Removed InetCreate*, these are now owned
					by the Account Manager -- jmazner

  Support:	This header file (and INETCFG.DLL) is supported by the
			Internet Connection Wizard team (alias icwcore).  Please
			do not modify this directly.

*********************************************************************/

#ifndef _ICWCFG_H_

//
// defines
//

// ICW registry settings

// HKEY_CURRENT_USER
#define ICW_REGPATHSETTINGS	"Software\\Microsoft\\Internet Connection Wizard"
#define ICW_REGKEYCOMPLETED	"Completed"

// Maximum field lengths
#define ICW_MAX_ACCTNAME	256
#define ICW_MAX_PASSWORD	256	// PWLEN
#define ICW_MAX_LOGONNAME	256	// UNLEN
#define ICW_MAX_SERVERNAME	64
#define ICW_MAX_RASNAME		256	// RAS_MaxEntryName
#define ICW_MAX_EMAILNAME	64
#define ICW_MAX_EMAILADDR	128

// Bit-mapped flags

// CheckConnectionWizard input flags
#define ICW_CHECKSTATUS		0x0001

#define ICW_LAUNCHFULL		0x0100
#define ICW_LAUNCHMANUAL	0x0200
#define ICW_USE_SHELLNEXT	0x0400
#define ICW_FULL_SMARTSTART	0x0800

// CheckConnectionWizard output flags
#define ICW_FULLPRESENT		0x0001
#define ICW_MANUALPRESENT	0x0002
#define ICW_ALREADYRUN		0x0004

#define ICW_LAUNCHEDFULL	0x0100
#define ICW_LAUNCHEDMANUAL	0x0200

// InetCreateMailNewsAccount input flags
#define ICW_USEDEFAULTS		0x0001

#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus


//
// external function typedefs
//
typedef DWORD	(WINAPI *PFNCHECKCONNECTIONWIZARD) (DWORD, LPDWORD);
typedef DWORD	(WINAPI *PFNSETSHELLNEXT) (__in PSTR);

//
// external function declarations
//
DWORD WINAPI CheckConnectionWizard(DWORD, LPDWORD);

DWORD
WINAPI
SetShellNext(
    __in PSTR szShellNext
    );


#ifdef __cplusplus
}
#endif // __cplusplus

#endif // _ICWCFG_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\icmpapi.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*++


Module Name:

    icmpapi.h

Abstract:

    Declarations for the Win32 ICMP Echo request API.

Author:

    Portable Systems Group 30-December-1993

Revision History:


Notes:

--*/

#ifndef _ICMP_INCLUDED_
#define _ICMP_INCLUDED_

#include "ipexport.h"

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// Exported Routines.
//

//++
//
// Routine Name:
//
//     IcmpCreateFile
//
// Routine Description:
//
//     Opens a handle on which ICMP Echo Requests can be issued.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     An open file handle or INVALID_HANDLE_VALUE. Extended error information
//     is available by calling GetLastError().
//
//--

HANDLE
WINAPI
IcmpCreateFile(
    VOID
    );

//++
//
// Routine Name:
//
//     Icmp6CreateFile
//
// Routine Description:
//
//     Opens a handle on which ICMPv6 Echo Requests can be issued.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     An open file handle or INVALID_HANDLE_VALUE. Extended error information
//     is available by calling GetLastError().
//
//--

HANDLE
WINAPI
Icmp6CreateFile(
    VOID
    );


//++
//
// Routine Name:
//
//     IcmpCloseHandle
//
// Routine Description:
//
//     Closes a handle opened by ICMPOpenFile.
//
// Arguments:
//
//     IcmpHandle  - The handle to close.
//
// Return Value:
//
//     TRUE if the handle was closed successfully, otherwise FALSE. Extended
//     error information is available by calling GetLastError().
//
//--

BOOL
WINAPI
IcmpCloseHandle(
    HANDLE  IcmpHandle
    );



//++
//
// Routine Name:
//
//     IcmpSendEcho
//
// Routine Description:
//
//     Sends an ICMP Echo request and returns any replies. The
//     call returns when the timeout has expired or the reply buffer
//     is filled.
//
// Arguments:
//
//     IcmpHandle           - An open handle returned by ICMPCreateFile.
//
//     DestinationAddress   - The destination of the echo request.
//
//     RequestData          - A buffer containing the data to send in the
//                            request.
//
//     RequestSize          - The number of bytes in the request data buffer.
//
//     RequestOptions       - Pointer to the IP header options for the request.
//                            May be NULL.
//
//     ReplyBuffer          - A buffer to hold any replies to the request.
//                            On return, the buffer will contain an array of
//                            ICMP_ECHO_REPLY structures followed by the
//                            options and data for the replies. The buffer
//                            should be large enough to hold at least one
//                            ICMP_ECHO_REPLY structure plus
//                            MAX(RequestSize, 8) bytes of data since an ICMP
//                            error message contains 8 bytes of data.
//
//     ReplySize            - The size in bytes of the reply buffer.
//
//     Timeout              - The time in milliseconds to wait for replies.
//
// Return Value:
//
//     Returns the number of ICMP_ECHO_REPLY structures stored in ReplyBuffer.
//     The status of each reply is contained in the structure. If the return
//     value is zero, extended error information is available via
//     GetLastError().
//
//--

DWORD
WINAPI
IcmpSendEcho(
    HANDLE                   IcmpHandle,
    IPAddr                   DestinationAddress,
    LPVOID                   RequestData,
    WORD                     RequestSize,
    PIP_OPTION_INFORMATION   RequestOptions,
    LPVOID                   ReplyBuffer,
    DWORD                    ReplySize,
    DWORD                    Timeout
    );


//++
//
// Routine Description:
//
//    Sends an ICMP Echo request and the call returns either immediately
//    (if Event or ApcRoutine is NonNULL) or returns after the specified
//    timeout.   The ReplyBuffer contains the ICMP responses, if any.
//
// Arguments:
//
//    IcmpHandle           - An open handle returned by ICMPCreateFile.
//
//    Event                - This is the event to be signalled whenever an IcmpResponse
//                           comes in.
//
//    ApcRoutine           - This routine would be called when the calling thread
//                           is in an alertable thread and an ICMP reply comes in.
//
//    ApcContext           - This optional parameter is given to the ApcRoutine when
//                           this call succeeds.
//
//    DestinationAddress   - The destination of the echo request.
//
//    RequestData          - A buffer containing the data to send in the
//                           request.
//
//    RequestSize          - The number of bytes in the request data buffer.
//
//    RequestOptions       - Pointer to the IP header options for the request.
//                           May be NULL.
//
//    ReplyBuffer          - A buffer to hold any replies to the request.
//                           On return, the buffer will contain an array of
//                           ICMP_ECHO_REPLY structures followed by options
//                           and data. The buffer must be large enough to
//                           hold at least one ICMP_ECHO_REPLY structure.
//                           It should be large enough to also hold
//                           8 more bytes of data - this is the size of
//                           an ICMP error message.
//
//    ReplySize            - The size in bytes of the reply buffer.
//
//    Timeout              - The time in milliseconds to wait for replies.
//                           This is NOT used if ApcRoutine is not NULL or if Event
//                           is not NULL.
//
// Return Value:
//
//    Returns the number of replies received and stored in ReplyBuffer. If
//    the return value is zero, extended error information is available
//    via GetLastError().
//
// Remarks:
//
//    On NT platforms,
//    If used Asynchronously (either ApcRoutine or Event is specified), then
//    ReplyBuffer and ReplySize are still needed.  This is where the response
//    comes in.
//    ICMP Response data is copied to the ReplyBuffer provided, and the caller of
//    this function has to parse it asynchronously.  The function IcmpParseReply
//    is provided for this purpose.
//
//    On non-NT platforms,
//    Event, ApcRoutine and ApcContext are IGNORED.
//
//--


DWORD
WINAPI
IcmpSendEcho2(
    HANDLE                   IcmpHandle,
    HANDLE                   Event,
#ifdef PIO_APC_ROUTINE_DEFINED
    PIO_APC_ROUTINE          ApcRoutine,
#else
    FARPROC                  ApcRoutine,
#endif
    PVOID                    ApcContext,
    IPAddr                   DestinationAddress,
    LPVOID                   RequestData,
    WORD                     RequestSize,
    PIP_OPTION_INFORMATION   RequestOptions,
    LPVOID                   ReplyBuffer,
    DWORD                    ReplySize,
    DWORD                    Timeout
    );

DWORD
WINAPI
Icmp6SendEcho2(
    HANDLE                   IcmpHandle,
    HANDLE                   Event,
#ifdef PIO_APC_ROUTINE_DEFINED
    PIO_APC_ROUTINE          ApcRoutine,
#else
    FARPROC                  ApcRoutine,
#endif
    PVOID                    ApcContext,
    struct sockaddr_in6     *SourceAddress,
    struct sockaddr_in6     *DestinationAddress,
    LPVOID                   RequestData,
    WORD                     RequestSize,
    PIP_OPTION_INFORMATION   RequestOptions,
    LPVOID                   ReplyBuffer,
    DWORD                    ReplySize,
    DWORD                    Timeout
    );


//++
//
// Routine Description:
//
//    Parses the reply buffer provided and returns the number of ICMP responses found.
//
// Arguments:
//
//    ReplyBuffer            - This must be the same buffer that was passed to IcmpSendEcho2
//                             This is rewritten to hold an array of ICMP_ECHO_REPLY structures.
//                             (i.e. the type is PICMP_ECHO_REPLY).
//
//    ReplySize              - This must be the size of the above buffer.
//
// Return Value:
//    Returns the number of ICMP responses found.  If there is an errors, return value is
//    zero.  The error can be determined by a call to GetLastError.
//
// Remarks:
//    This function SHOULD NOT BE USED on a reply buffer that was passed to SendIcmpEcho.
//    SendIcmpEcho actually parses the buffer before returning back to the user.  This function
//    is meant to be used only with SendIcmpEcho2.
//--

DWORD
IcmpParseReplies(
    LPVOID                   ReplyBuffer,
    DWORD                    ReplySize
    );

DWORD
Icmp6ParseReplies(
    LPVOID                   ReplyBuffer,
    DWORD                    ReplySize
    );

#ifdef __cplusplus
}
#endif

#endif // _ICMP_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\idispids.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES.
//
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright 1995-1998 Microsoft Corporation. All Rights Reserved.
//
//  File: idispids.h
//
//--------------------------------------------------------------------------

#define DISPID_READYSTATE                             (-525)
#define DISPID_READYSTATECHANGE                       (-609)
#define DISPID_AMBIENT_TRANSFERPRIORITY               (-728)
#define DISPID_AMBIENT_OFFLINEIFNOTCONNECTED          (-5501)
#define DISPID_AMBIENT_SILENT                         (-5502)

// Until these appear in OLECTL.H
#ifndef DISPID_AMBIENT_CODEPAGE
#define DISPID_AMBIENT_CODEPAGE         (-725)
#define DISPID_AMBIENT_CHARSET          (-727)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\iedial.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES.
//

#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0286 */
/* at Mon Jan 22 12:14:04 2007
 */
/* Compiler settings for ..\iedial.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __iedial_h__
#define __iedial_h__

/* Forward Declarations */ 

#ifndef __IDialEventSink_FWD_DEFINED__
#define __IDialEventSink_FWD_DEFINED__
typedef interface IDialEventSink IDialEventSink;
#endif 	/* __IDialEventSink_FWD_DEFINED__ */


#ifndef __IDialEngine_FWD_DEFINED__
#define __IDialEngine_FWD_DEFINED__
typedef interface IDialEngine IDialEngine;
#endif 	/* __IDialEngine_FWD_DEFINED__ */


#ifndef __IDialBranding_FWD_DEFINED__
#define __IDialBranding_FWD_DEFINED__
typedef interface IDialBranding IDialBranding;
#endif 	/* __IDialBranding_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_iedial_0000 */
/* [local] */ 

//=--------------------------------------------------------------------------=
// iedial.h
//=--------------------------------------------------------------------------=
// (C) Copyright 1995-1999 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=

#pragma comment(lib,"uuid.lib")

//---------------------------------------------------------------------------=
// Channel Manager Interfaces.



extern RPC_IF_HANDLE __MIDL_itf_iedial_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_iedial_0000_v0_0_s_ifspec;

#ifndef __IDialEventSink_INTERFACE_DEFINED__
#define __IDialEventSink_INTERFACE_DEFINED__

/* interface IDialEventSink */
/* [object][helpstring][version][uuid] */ 


EXTERN_C const IID IID_IDialEventSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2d86f4ff-6e2d-4488-b2e9-6934afd41bea")
    IDialEventSink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnEvent( 
            /* [in] */ DWORD dwEvent,
            /* [in] */ DWORD dwStatus) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDialEventSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDialEventSink __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDialEventSink __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDialEventSink __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnEvent )( 
            IDialEventSink __RPC_FAR * This,
            /* [in] */ DWORD dwEvent,
            /* [in] */ DWORD dwStatus);
        
        END_INTERFACE
    } IDialEventSinkVtbl;

    interface IDialEventSink
    {
        CONST_VTBL struct IDialEventSinkVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDialEventSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDialEventSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDialEventSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDialEventSink_OnEvent(This,dwEvent,dwStatus)	\
    (This)->lpVtbl -> OnEvent(This,dwEvent,dwStatus)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDialEventSink_OnEvent_Proxy( 
    IDialEventSink __RPC_FAR * This,
    /* [in] */ DWORD dwEvent,
    /* [in] */ DWORD dwStatus);


void __RPC_STUB IDialEventSink_OnEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDialEventSink_INTERFACE_DEFINED__ */


#ifndef __IDialEngine_INTERFACE_DEFINED__
#define __IDialEngine_INTERFACE_DEFINED__

/* interface IDialEngine */
/* [object][helpstring][version][uuid] */ 


EXTERN_C const IID IID_IDialEngine;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("39fd782b-7905-40d5-9148-3c9b190423d5")
    IDialEngine : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ LPCWSTR pwzConnectoid,
            /* [in] */ IDialEventSink __RPC_FAR *pIDES) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProperty( 
            /* [in] */ LPCWSTR pwzProperty,
            /* [in] */ LPWSTR pwzValue,
            /* [in] */ DWORD dwBufSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProperty( 
            /* [in] */ LPCWSTR pwzProperty,
            /* [in] */ LPCWSTR pwzValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Dial( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HangUp( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConnectedState( 
            /* [out] */ DWORD __RPC_FAR *pdwState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConnectHandle( 
            /* [out] */ DWORD_PTR __RPC_FAR *pdwHandle) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDialEngineVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDialEngine __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDialEngine __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDialEngine __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Initialize )( 
            IDialEngine __RPC_FAR * This,
            /* [in] */ LPCWSTR pwzConnectoid,
            /* [in] */ IDialEventSink __RPC_FAR *pIDES);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProperty )( 
            IDialEngine __RPC_FAR * This,
            /* [in] */ LPCWSTR pwzProperty,
            /* [in] */ LPWSTR pwzValue,
            /* [in] */ DWORD dwBufSize);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetProperty )( 
            IDialEngine __RPC_FAR * This,
            /* [in] */ LPCWSTR pwzProperty,
            /* [in] */ LPCWSTR pwzValue);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Dial )( 
            IDialEngine __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *HangUp )( 
            IDialEngine __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetConnectedState )( 
            IDialEngine __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwState);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetConnectHandle )( 
            IDialEngine __RPC_FAR * This,
            /* [out] */ DWORD_PTR __RPC_FAR *pdwHandle);
        
        END_INTERFACE
    } IDialEngineVtbl;

    interface IDialEngine
    {
        CONST_VTBL struct IDialEngineVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDialEngine_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDialEngine_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDialEngine_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDialEngine_Initialize(This,pwzConnectoid,pIDES)	\
    (This)->lpVtbl -> Initialize(This,pwzConnectoid,pIDES)

#define IDialEngine_GetProperty(This,pwzProperty,pwzValue,dwBufSize)	\
    (This)->lpVtbl -> GetProperty(This,pwzProperty,pwzValue,dwBufSize)

#define IDialEngine_SetProperty(This,pwzProperty,pwzValue)	\
    (This)->lpVtbl -> SetProperty(This,pwzProperty,pwzValue)

#define IDialEngine_Dial(This)	\
    (This)->lpVtbl -> Dial(This)

#define IDialEngine_HangUp(This)	\
    (This)->lpVtbl -> HangUp(This)

#define IDialEngine_GetConnectedState(This,pdwState)	\
    (This)->lpVtbl -> GetConnectedState(This,pdwState)

#define IDialEngine_GetConnectHandle(This,pdwHandle)	\
    (This)->lpVtbl -> GetConnectHandle(This,pdwHandle)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDialEngine_Initialize_Proxy( 
    IDialEngine __RPC_FAR * This,
    /* [in] */ LPCWSTR pwzConnectoid,
    /* [in] */ IDialEventSink __RPC_FAR *pIDES);


void __RPC_STUB IDialEngine_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDialEngine_GetProperty_Proxy( 
    IDialEngine __RPC_FAR * This,
    /* [in] */ LPCWSTR pwzProperty,
    /* [in] */ LPWSTR pwzValue,
    /* [in] */ DWORD dwBufSize);


void __RPC_STUB IDialEngine_GetProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDialEngine_SetProperty_Proxy( 
    IDialEngine __RPC_FAR * This,
    /* [in] */ LPCWSTR pwzProperty,
    /* [in] */ LPCWSTR pwzValue);


void __RPC_STUB IDialEngine_SetProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDialEngine_Dial_Proxy( 
    IDialEngine __RPC_FAR * This);


void __RPC_STUB IDialEngine_Dial_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDialEngine_HangUp_Proxy( 
    IDialEngine __RPC_FAR * This);


void __RPC_STUB IDialEngine_HangUp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDialEngine_GetConnectedState_Proxy( 
    IDialEngine __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwState);


void __RPC_STUB IDialEngine_GetConnectedState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDialEngine_GetConnectHandle_Proxy( 
    IDialEngine __RPC_FAR * This,
    /* [out] */ DWORD_PTR __RPC_FAR *pdwHandle);


void __RPC_STUB IDialEngine_GetConnectHandle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDialEngine_INTERFACE_DEFINED__ */


#ifndef __IDialBranding_INTERFACE_DEFINED__
#define __IDialBranding_INTERFACE_DEFINED__

/* interface IDialBranding */
/* [object][helpstring][version][uuid] */ 


EXTERN_C const IID IID_IDialBranding;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8aecafa9-4306-43cc-8c5a-765f2979cc16")
    IDialBranding : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ LPCWSTR pwzConnectoid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBitmap( 
            /* [in] */ DWORD dwIndex,
            /* [out] */ HBITMAP __RPC_FAR *phBitmap) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDialBrandingVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDialBranding __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDialBranding __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDialBranding __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Initialize )( 
            IDialBranding __RPC_FAR * This,
            /* [in] */ LPCWSTR pwzConnectoid);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBitmap )( 
            IDialBranding __RPC_FAR * This,
            /* [in] */ DWORD dwIndex,
            /* [out] */ HBITMAP __RPC_FAR *phBitmap);
        
        END_INTERFACE
    } IDialBrandingVtbl;

    interface IDialBranding
    {
        CONST_VTBL struct IDialBrandingVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDialBranding_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDialBranding_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDialBranding_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDialBranding_Initialize(This,pwzConnectoid)	\
    (This)->lpVtbl -> Initialize(This,pwzConnectoid)

#define IDialBranding_GetBitmap(This,dwIndex,phBitmap)	\
    (This)->lpVtbl -> GetBitmap(This,dwIndex,phBitmap)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDialBranding_Initialize_Proxy( 
    IDialBranding __RPC_FAR * This,
    /* [in] */ LPCWSTR pwzConnectoid);


void __RPC_STUB IDialBranding_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDialBranding_GetBitmap_Proxy( 
    IDialBranding __RPC_FAR * This,
    /* [in] */ DWORD dwIndex,
    /* [out] */ HBITMAP __RPC_FAR *phBitmap);


void __RPC_STUB IDialBranding_GetBitmap_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDialBranding_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_iedial_0151 */
/* [local] */ 

#define DIALPROP_USERNAME       L"UserName"        
#define DIALPROP_PASSWORD       L"Password"        
#define DIALPROP_DOMAIN         L"Domain"          
#define DIALPROP_SAVEPASSWORD   L"SavePassword"    
#define DIALPROP_REDIALCOUNT    L"RedialCount"     
#define DIALPROP_REDIALINTERVAL L"RedialInterval"  
#define DIALPROP_PHONENUMBER    L"PhoneNumber"     
#define DIALPROP_LASTERROR      L"LastError"       
#define DIALPROP_RESOLVEDPHONE  L"ResolvedPhone"   

#define DIALENG_OperationComplete   0x10000          
#define DIALENG_RedialAttempt       0x10001          
#define DIALENG_RedialWait          0x10002          


extern RPC_IF_HANDLE __MIDL_itf_iedial_0151_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_iedial_0151_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  HBITMAP_UserSize(     unsigned long __RPC_FAR *, unsigned long            , HBITMAP __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  HBITMAP_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, HBITMAP __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  HBITMAP_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, HBITMAP __RPC_FAR * ); 
void                      __RPC_USER  HBITMAP_UserFree(     unsigned long __RPC_FAR *, HBITMAP __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\iert.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES.
//
// iert.h - Definitions, and Prototypes for the Internet Explorer 
//          implementation of the c-runtime library.
//
// History:
//     Created on 16-May-1997 by Vince Roggero (vincentr)
//

#ifdef __cplusplus
extern "C" 
{
#endif

/***
*char *StrTokEx(pstring, control) - tokenize string with delimiter in control
*
*Purpose:
*       StrTokEx considers the string to consist of a sequence of zero or more
*       text tokens separated by spans of one or more control chars. the first
*       call, with string specified, returns a pointer to the first char of the
*       first token, and will write a null char into pstring immediately
*       following the returned token. when no tokens remain
*       in pstring a NULL pointer is returned. remember the control chars with a
*       bit map, one bit per ascii char. the null char is always a control char.
*
*Entry:
*       char **pstring - ptr to ptr to string to tokenize
*       char *control - string of characters to use as delimiters
*
*Exit:
*       returns pointer to first token in string,
*       returns NULL when no more tokens remain.
*       pstring points to the beginning of the next token.
*
*WARNING!!!
*       upon exit, the first delimiter in the input string will be replaced with '\0'
*
*******************************************************************************/
char* __cdecl StrTokEx (char ** pstring, const char * control);


/***
* double StrToDbl(const char *str, char **strStop) - convert string to double
*
* Purpose:
*           To convert a string into a double.  This function supports
*           simple double representations like '1.234', '.5678'.  It also support
*           the a killobyte computaion by appending 'k' to the end of the string
*           as in '1.5k' or '.5k'.  The results would then become 1536 and 512.5.
*
* Return:
*           The double representation of the string.
*           strStop points to the character that caused the scan to stop.
*
*******************************************************************************/
double __cdecl StrToDbl(const char *strIn, char **strStop);

#ifdef __cplusplus
}   // extern "C"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\iehelpid.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES.
//
//+-------------------------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997
//
//
//  Contents:   Helpids for iexplore.hlp.  iexplore.hlp only contains help for the binaries
//  distributed with a browser-only install of IE, such as:
//
//      shdocvw.dll
//      browseui.dll
//      inetcpl.cpl
//
//  Pure shell components, such as shell32.dll, use other .hlp files, such as shell.hlp,
//  and have their help ids defined in other headers (see shellids.h and help.h).
//+-------------------------------------------------------------------------------------------

#ifndef _IEHELPID_H__
#define _IEHELPID_H__

#define IDH_IE_RUN_COMMAND              50000 // was 0x3000

// For Add To Favorites
#define IDH_BROWSELIST                  50001 // was 0x3001
#define IDH_NEWFOLDER                   50002 // was 0x3002
#define IDH_CREATEIN                    50003 // was 0x3003
#define IDH_NAMEEDIT                    50004 // was 0x3004

// For Open dialog
#define IDH_RUNBROWSE                   50005 // was 0x3005

// For Organize Favorites
#define IDH_ORG_FAVORITES_MOVE          50006 // was 0x3050
#define IDH_ORG_FAVORITES_RENAME        50007 // was 0x3051
#define IDH_ORG_FAVORITES_DELETE        50008 // was 0x3052
#define IDH_ORG_FAVORITES_OPEN          50009 // was 0x3053
#define IDH_ORG_FAVORITES_CLOSE         50010 // was 0x3054

//For Volvo QFE
#define IDH_AUTOCONFIG_BUTTON           50011 // was 0x3055
#define IDH_AUTOCONFIG_TEXT             50012 // was 0x3056
#define IDH_OPTS_CONNX_AUTOCNCT_REFRESH 50013 // was 0x3070

//Trident print features
#define IDH_PRINT_SCREEN                50014 // was 0x3057
#define IDH_PRINT_SEL_FRAME             50015 // was 0x3058
#define IDH_PRINT_ALL_FRAME             50016 // was 0x3059
#define IDH_PRINT_LINKS                 50017 // was 0x3060
#define IDH_PRINT_SHORTCUTS             50020 // was 5002



//Find Text dialog box
#define IDH_FIND_WHOLEA                  50022 // was 0x3063
#define IDH_FIND_CASEA                   50023 // was 0x3064
#define IDH_FIND_UPA                     50024 // was 0x3065
#define IDH_FIND_DOWNA                   50025 // was 0x3066
#define IDH_FIND_NEXTA                   50026 // was 0x3067
#define IDH_FIND_WHATA                   50027 // was 0x3068


//General Tab, Language button
#define IDH_OPTS_GEN_LANG_BUT           50028 // was 0x3071

//Language Preferences dialog box
#define IDH_LANG_PREFS_LIST             50029 // was 0x3075 //Language label and list box
#define IDH_LANG_PREFS_UP               50030 // was 0x3076 //Move up button
#define IDH_LANG_PREFS_DOWN             50031 // was 0x3077 //Move Down button
#define IDH_LANG_PREFS_REMOVE           50032 // was 0x3078 //Remove button
#define IDH_LANG_PREFS_ADD              50033 // was 0x3070 //Add button




//Content tab, Personal Information: Personal Profile and Microsoft Wallet
#define IDH_EDIT_PROFILE_BTN            50198 // Edit Profiles button

#define IDH_ADD_LANGUAGE_LANGUAGE_LIST  50037 // was 0x3102 //in Add Languages dialog box, Language list
#define IDH_ADD_LANGUAGE_USER_DEFINED   50038 // was 0x3103  //in Add Languages dialog box, User Defined label and text box

//Client Authentication dialog box
#define  IDH_CLIENT_AUTHENTICATION_LIST 50039 // was 0x3100         //Identification label, text, and list area
#define IDH_CLIENT_AUTHENTICATION_CERT_PROPS    50040  // was 0x3101 //View button

#define IDH_GROUPBOX                    50041 // was 1

///////////////////******************       Advanced tab, Advanced list


//Advanced Tab, Advanced List
//Multimedia
#define IDH_MM_PIC                      50042 // was 3 //Show Pictures
#define IDH_MM_ANIM                     50176 //Play animations
#define IDH_MM_SOUND                    50043 // was 4 //Play Sounds
#define IDH_MM_VIDEO                    50044 // was 5 //play videos
#define IDH_APPEAR_COLOR                50045 // was 6
#define IDH_SMART_DITH                  50177 //Smart dithering
#define IDH_MB_NO_ONLINE_CONTENT        50194 // MediaBar: Don't display online media content in the media bar 
//Browsing
#define IDH_DOWNLOAD_COMP                 50492 //Notify when downloads complete
#define IDH_AUTOCOMP                    50180 //Use AutoComplete
#define IDH_ADD_URL                     50111 // was 79//show friendly urls
#define IDH_ADD_SMOOTH                  50107 // was 75//use smooth scrolling
#define IDH_ADD_LINK                    50112 // was 80//highlight links
#define IDH_NEW_PROCESS                 50178 //Browse in a new process
#define IDH_CHANNELLOG                  50179 //Enable page hit counting
#define IDH_ENABLE_SUB_UPDATES          50181 //Enable scheduled subscription updates
#define IDH_UPDATE_SUB_NEW_PROC         50182 //Update subscriptions in a new process
//Security
#define IDH_PCT_ALLOW                   50130 // was 99//pct 1.0
#define IDH_SSL2_ALLOW                  50128 // was 97//ssl 3.0
#define IDH_SSL3_ALLOW                  50129 // was 98// ssl 3.0
#define IDH_CRYPT_NOSAVE_SSL            50127 // was 96//do not save pages to disk
#define IDH_PRIV_VIEW                   50089 // was 54//warn if changing between secure and unsecure
#define IDH_CHK_CERT_REVOC              50184 // Check for publisher'scertificate revocation
#define IDH_PRIV_INVALID                50119 // was 87//Warn about invalid site certs
#define IDH_TAKE_COOKIES_ALWAYS         50189 //Always accept cookies// Now: Allow cookies that are stored on your computer
#define IDH_PRIV_COOKIE                 50090 // was 55// prompt before accepting cookies //Now: Allow per-session cookies (not stored)
#define IDH_DISABLE_COOKIES             50190 //Disable all cookies// obsolete

//Java VM
#define IDH_ADD_JAVA_COMP               50110 // was 78//JAVA JIT complier enabled
#define IDH_ADD_JAVA_LOG                50109 // was 77//java logging enabled

//Printing
#define IDH_PRINT_BKGRND                50191 //Print background colors and images

//Searching
#define IDH_AUTOSCAN                    50192 //Autoscan common root domains
#define IDH_SEARCH_URL_FAILS            50193 //Search when URL fails; never, always, always

//Toolbar
#define IDH_TOOL_STD                    50048 // was 9 //small icons




#define IDH_RESTORE_DEFS            50196 //Restore Defaults button at bottom of advanced tab

////////////////******       End of Advanced tab **********////////////////////////////

#define IDH_APPEAR_OPTION               50046 // was 7
#define IDH_APPEAR_LINK                 50047 // was 8
#define IDH_FONT_INT                    50055 // was 16
#define IDH_FONT_MIME                   50056 // was 17
#define IDH_OPTS_GEN_FONTS_FONTSIZE     50057 // was 5003
#define IDH_CHAR_SET                    50058 // was 18
#define IDH_INTL_DEFAULT                50059 // was 19
#define IDH_INTL_FONT_PROP              50060 // was 21
#define IDH_INTL_FONT_FIXED             50061 // was 22
#define IDH_DIAL_CON                    50062 // was 24
#define IDH_DIAL_USE                    50063 // connection tab, checkbox: dial the default connection when needed
#define IDH_DIAL_PROP                   50064 // dialup server properties, properties button
#define IDH_DIAL_DIS                    50065 // was 27
#define IDH_DIAL_ADD                    50066 // Add button in connections tab
#define IDH_DIAL_SYS                    50067 // was 29
#define IDH_PROX_SERV                   50068 // proxy server group box, Manual Proxy Server option
#define IDH_PROX_SETTINGS               50069 // LAN Settings button
#define IDH_SERV_INFO                   50070 // was 34
#define IDH_SERV_SAME                   50071 // was 35
#define IDH_EXCEPT_PROX                 50072 // was 37
#define IDH_EXCEPT_LOCAL                50073 // was 38
#define IDH_CUST_ADDRESS                50076 // was 41
#define IDH_CUST_DEF                    50077 // was 42
#define IDH_CUST_CURR                   50078 // was 43
#define IDH_HIST_NUM                    50079 // was 44
#define IDH_HIST_CLEAR                  50080 // was 45
#define IDH_MAIL                        50082 // was 47
#define IDH_NEWS                        50083 // was 48
#define IDH_IE_DEF                      50085 // was 50

#define IDH_CERT_PERS                   50091 // was 56
#define IDH_CERT_SITE                   50092 // was 57
#define IDH_CERT_PUB                    50093 // was 58
#define IDH_ACT_CONTENT                 50097 // was 62
#define IDH_SAFE_EXPERT                 50099 // was 67
#define IDH_SAFE_NORM                   50100 // was 68
#define IDH_SAFE_NONE                   50101 // was 69
#define IDH_RATE_TOGGLE                 50102 // was 70
#define IDH_RATE_PROP                   50103 // was 71
#define IDH_TIF_VIEW                    50104 // was 72
#define IDH_TIF_SETTINGS                50105 // was 73


//Settings dialog
#define IDH_TEMP_EVERY                  50113 // was 81
#define IDH_TEMP_START                  50114 // was 82
#define IDH_TEMP_NEVER                  50115 // was 83
#define IDH_TEMP_AMOUNT                 50116 // was 84
#define IDH_TEMP_EMPTY                  50117 // was 85
#define IDH_TEMP_MOVE                   50118 // was 86
#define IDH_TEMP_AUTO           50491 // New for ie5

#define IDH_VIEW_CERT                   50124 // was 93
#define IDH_DEL_CERT                    50125 // was 94
#define IDH_LIST_CERT                   50126 // was 95



#define IDH_PAGESETUP_HEADER_LEFT       50136 // was      4129       // Page Setup dialog box, header and footer
#define IDH_CPL_GEN_USEBLANK            50137 // was    5100// Use Blank button
#define IDH_CPL_SEC_ZONE_DROPLIST       50138 // was    5110// Zone dropdown list
#define IDH_CPL_SEC_ADDSITES            50139 // was    5115// Add Sites button
#define IDH_CPL_SEC_CUSTOM_LEVEL        50140 // was    5140// Custom for expert users
#define IDH_CPL_SEC_SETTINGS            50141 // was    5135// Settings button
#define IDH_CPL_WEB_SITES_LIST          50142 // was    5145// Trusted Web sites list
#define IDH_CPL_WEB_SITES_REMOVE        50143 // was    5150// Web sites in- Remove button
#define IDH_CPL_REQ_VERIFICATION_CHKBOX 50144 // was    5155// Require server verification for all sites in this zone
#define IDH_CPL_WEB_SITES_ADD_THIS_TXT  50145 // was    5160// Add this web site text box
#define IDH_CPL_WEB_SITES_ADD_BUTTON    50146 // was    5165// Add button
#define IDH_CPL_SEC_SETTINGS_CURRENT    50147 // was    5170// Security: Current settings list box
#define IDH_CPL_SEC_SETTINGS_RESET      50148 // was    5175// Security: Reset to: text box

#define IDH_CPL_CNX_WIZARD              50149 // was    5230// Wizard button in Connection tab/Connection groupbox
#define IDH_CPL_CNX_SETTINGS            50150 // was    5235// Connection settings button
#define IDH_CPL_CNX_ACCESSBYLAN         50151 // was    5240// Access the Internet via a local area network
#define IDH_CPL_CNX_PROXY_ADDR_PORT     50152 // was    5180// Proxy server address and port
#define IDH_CPL_DUN_ATTEMPT_X_TIMES     50153 // was    5200// Dial-Up Settings: Attempt to connect x times
#define IDH_CPL_DUN_WAIT_X_SECS         50154 // was    5205// DUN: Wait x seconds between each attempt
#define IDH_CPL_DUN_SEND_MY_LOGIN       50155 // Do not allow Internet applications to use this connection
#define IDH_CPL_DUN_USERNAME            50156 // was    5215// DUN: User
#define IDH_CPL_DUN_PASSWORD            50157 // was    5220// DUN: Password
#define IDH_CPL_DUN_DOMAIN              50158 // was    5225// DUN: Domain
#define IDH_CPL_PROGRAMS_CAL            50159 // was    5250// Programs: Calendar
#define IDH_CPL_PROGRAMS_CONTACTS       50160 // was    5255// Programs: Contact List
#define IDH_CPL_PROGRAMS_INTERNET_CALL  50161 // was    5260// Programs: Internet Call
#define IDH_CPL_ADV_COLORS              50162 // was    5270// Colors button
#define IDH_CPL_ADV_ACCESSIBILITY       50163 // was    5275// Accessibility button
#define IDH_CPL_ACCESS_USE_MY_COLORS    50164 // was    5290// Accessibility: Always use my color settings
#define IDH_CPL_ACCESS_USE_MY_F_STYLE   50165 // was    5295// Accessibility: Always use my font style settings
#define IDH_CPL_ACCESS_USE_MY_F_SIZE    50166 // was    5300// Accessibility: Always use my font size settings
#define IDH_CPL_ACCESS_USE_MY_STYLESHEETS 50167 // was  5305// Accessibility: User Stylesheet check box and text box

//Security dialog box help
#define IDH_SEC_ENTER_SSL               50168 //Entering a secure site
#define IDH_SEC_ENTER_SSL_W_INVALIDCERT 50169 //Entering a secure site with an invalid certificate
#define IDH_SEC_SEND_N_REC_COOKIES      50171 //Sending and Receiving Information About Your Browsing
#define IDH_SEC_SIGNED_N_INVALID        50173 //Signed and Invalid ActiveX/Java Download
#define IDH_SEC_MIXED_DOWNLOAD_FROM_SSL 50175 //Insecure content download from a secure Web site
#define IDH_SEC_ENTER_NON_SECURE_SITE   50226 //Entering non-secure Web site without a cert, from a secure web site



//CERTIFICATE PROPERTIES DIALOG BOX
#define IDH_CERTVWPROP_GEN_FINEPRINT          50228
#define IDH_CERTVWPROP_DET_ISSUER_CERT        50229
#define IDH_CERTVWPROP_DET_FRIENDLY           50230
#define IDH_CERTVWPROP_DET_STATUS             50231
#define IDH_CERTVWPROP_TRUST_PURPOSE          50232
#define IDH_CERTVWPROP_TRUST_HIERAR           50233
#define IDH_CERTVWPROP_TRUST_VIEWCERT         50234
#define IDH_CERTVWPROP_TRUST_INHERIT          50235
#define IDH_CERTVWPROP_TRUST_EXPLICIT_TRUST   50236
#define IDH_CERTVWPROP_TRUST_EXPLICIT_DISTRUST 50237
#define IDH_CERTVWPROP_ADV_FIELD              50238
#define IDH_CERTVWPROP_ADV_DETAILS            50239

#define IDH_HOVERCOLOR                        50240//color dialog box
#define IDH_JAVA_PERMISSIONS                  50241//security tab, custom settings list

#define IDH_ENABLE_TRANSITIONS                50242//Advanced tab, inetcpl
#define IDH_UNDERLINE_LINKS                   50243//advanced tab, inetcpl
#define IDH_SECURITY_RESET_ZONE_DEFAULTS      50244//security tab, zones
#define IDH_SECURITY_RESET_LEVEL_DEFAULTS     50245//security tab, security settings, Reset custom settings

//Profile Assistant confirmation dialog box
#define IDH_PA_OPS_REQUEST                    50246//name and url of site making request
#define IDH_PA_OPS_LIST                       50247//Profile information requested--label and listbox
#define IDH_PA_USAGE_STRING                   50248//Usage label and text area
#define IDH_PA_VIEW_CERT                      50249//View Certificate button
#define IDH_PA_CONNECTION_SECURITY            50250//Connection Security label and text
#define IDH_PA_ALWAYS_SHARE                   50251//Always share text box

#define IDH_DISABLE_SCRIPT_DEBUG              50252//Advanced tab, intecpl

#define IDH_TEMP_INTERNET_VIEW_OBJECTS_BTN  50254 //Temporary Internet Files settings dialog, View Objects button

//download objects folder properties
#define IDH_DLOAD_TYPE                    50255
#define IDH_DLOAD_CREATED                 50256
#define IDH_DLOAD_LASTACC                 50257
#define IDH_DLOAD_TOTALSIZE               50258
#define IDH_DLOAD_ID                      50259
#define IDH_DLOAD_STATUS                  50260
#define IDH_DLOAD_CODEBASE                50261
#define IDH_DLOAD_FILE_DEP                50262
#define IDH_DLOAD_JAVAPKG_DEP             50263
#define IDH_DLOAD_VERSION                 50264
#define IDH_DLOAD_DESC                    50265
#define IDH_DLOAD_COMPANY                 50266
#define IDH_DLOAD_LANG                    50267
#define IDH_DLOAD_COPYRIGHT               50268

//Local Internet sites
#define IDH_ADD_SITES_ADVANCED_BTN                      50269
#define IDH_LOCAL_INTRA_INCLUDE_ALL_NOT_LISTED          50270
#define IDH_LOCAL_INTRA_INCLUDE_ALL_THAT_BYPASS_PROXY   50271
#define IDH_LOCAL_INTRA_INCLUDE_ALL_UNCS                50272

#define IDH_SITE_CERTS_ISSUER_TYPE        50273  //Site Certificates dialog box, Issuer Type drop down

#define IDH_JAVA_CUST_SETTINGS_BTN        50274  //security custom settings, Java Custom Settings button

//Add
#define IDH_SUBSCR_TO                     50021 //Favorites full subscription
#define IDH_SUBSCR_TO_CHANNEL             50275 //channel full subscription
#define IDH_SUBSCR_ADDTO_FAVS             50276 //Favorites no subscription
#define IDH_SUBSCR_PARTIAL                50278 //Favorites partial subscription
#define IDH_CHANNEL_ADDTO_CHANNELS        50279 //channels not subscription
#define IDH_CHANNEL_PARTIAL               50280 //channels partial subscription
#define IDH_CHANNEL_SUBSCR_CUST_BUTTON    50281 //Customization button

#define IDH_SOFTWARE_CHANNEL_PERMISSIONS  50282

#define IDH_USER_AUTHENTICATION           50283

#define IDH_DLOAD_OBJNAME                 50284

#define IDH_RESET_SHARING_OPS             50285 //Content tab
#define IDH_ADV_PROFILE_ASSISTANT         50286 //Advanced tab

#define IDH_ALWAYS_LAUNCH_FULL_SCREEN     50287 //Advanced tab, Browser, Always launch fullscreen browser
#define IDH_WARN_IF_FORMS_REDIRECTED      50288 //Advanced tab, Security, Warn if forms submit is being redirected
#define IDH_SHOW_FONT_BUTTON              50289 //Advanced tab, Toolbar, Show font button


//fixes for IE 4.01, New context-sensitive help topics for advanced tab and client authentication personal certificates import and export buttons
#define IDH_SHOW_IE_ON_DESKTOP   50290
#define IDH_SHOW_WELCOME_EACH_LOGON      50291
#define IDH_LAUNCH_CHANNELSIN_FULL             50292
#define IDH_DELETE_HISTORY_WHEN_CLOSING    50293
#define IDH_CLIENTAUTH_IMPORT                          50294
#define IDH_CLIENTAUTH_EXPORT                       50295
#define IDH_USEHTTP11_THRU_PROXY              50296
#define IDH_USEHTTP11                                     50297
#define IDH_ALWAYS_EXPAND_ALT_TEXT    50298
#define IDH_MOVE_SYSTEM_CARET                 50299
#define IDH_CHANNEL_ON_WITHOUT_ACT_DTP     50300
#define IDH_ENABLE_JAVA_CONSOLE             50301

//50302 to 50399 reserved for IEUNIX

#define IDH_MATCH_DIACRITIC 50401 //find dialog box
#define IDH_MATCH_KASHIDA 50402 //find dialog box
#define IDH_MATCH_ALEF_HAMZA 50403 //find dialog box



#define IDH_SUBPROPS_SCHEDTAB_CUSTOM_SCHEDULE 50412
#define IDH_SUBPROPS_SCHEDTAB_MANUAL_SCHEDULE 50414
#define IDH_SUBPROPS_SCHEDTAB_SCHEDDESC 50415
#define IDH_SUBPROPS_SCHED_DONTUPDATE 50417
#define IDH_SUBPROPS_RECTAB_ADVANCED 50420
#define IDH_SUBPROPS_RECTAB_EMAIL_NOTIFICATION 50421
#define IDH_SUBPROPS_RECTAB_MAILOPTS_EMAIL_ADDRESS 50423
#define IDH_SUBPROPS_RECTAB_MAILOPTS_EMAIL_SERVER 50424
#define IDH_SUBPROPS_RECTAB_CHANNEL_LOGIN 50425
#define IDH_SUBPROPS_RECTAB_LOGINOPTS_USER_ID 50426
#define IDH_SUBPROPS_RECTAB_LOGINOPTS_PASSWORD 50427
#define IDH_SUBPROPS_RECTAB_ADVOPTS_DOWNLOAD_PAGES_DEEP 50428
#define IDH_SUBPROPS_RECTAB_ADVOPTS_FOLLOW_LINKS  50429
#define IDH_SUBPROPS_RECTAB_ADVOPTS_DOWNLOAD_IMAGES 50430
#define IDH_SUBPROPS_RECTAB_ADVOPTS_DOWNLOAD_SOUND 50431
#define IDH_SUBPROPS_RECTAB_ADVOPTS_DOWNLOAD_ACTIVEX 50432
#define IDH_SUBPROPS_RECTAB_ADVOPTS_MAX_DOWNLOAD 50433


#define IDH_CONNECTION_TAB_CONNECTOID_LIST  50434 //Dial-up connection list in connection tab
#define IDH_CONNECTION_TAB_REMOVE_CONNECTOID  50435 //Remove button in connection tab
#define IDH_BYPASS_AUTOCFG  50436
#define IDH_DISCONNECT_ON_IEEXIT  50437 //advanced dialup dialog box, checkbox: disconnect when all internet applications exit
#define IDH_USE_THIS_CNX_FOR_INTRANETS  50438
#define IDH_USETHIS_CNX_4_INTERNET  50439
#define IDH_FORTEZZA_ALLOW  50440

#define IDH_EDIT_OFFLINE_SCHED  50441
#define IDH_MAKE_AVAIL_OFFLINE  50442
#define IDH_NEWSCHED_EVERY_AT_TIME  50443
#define IDH_NEWSCHED_NAME   50444
#define IDH_NEW_OFFLINE_SCHED   50445
#define IDH_REMOVE_OFFLINE_SCHED    50446

#define IDH_CHANNEL_DOWNLOAD_ALL    50447
#define IDH_CHANNEL_DOWNLOAD_COVER_N_TOC    50448
#define IDH_SUBPROPS_SUBTAB_SUBSCRIBED_NAME 50449
#define IDH_SUBPROPS_SUBTAB_SUBSCRIBED_URL  50450
#define IDH_WEBDOC_HOTKEY   50451
#define IDH_WEBDOC_VISITS   50452
#define IDH_SUBPROPS_SUBTAB_LAST    50453
#define IDH_SUBPROPS_DLSIZE 50454
#define IDH_SUBPROPS_SUBTAB_RESULT  50455

//#define IDH_JIT_COMPONENT 50456
#define IDH_JIT_SIZE    50457
#define IDH_JIT_DOWNLOAD_TIME   50458
#define IDH_JIT_NEVER_DOWNLOAD_THESE_COMPONENTS 50459
//#define IDH_JIT_PROGRESS_INDICATOR    50460
#define IDH_JIT_DOWNLOAD_BUTTON 50461
#define IDH_JIT_CANCEL_BUTTON   50462
#define IDH_JIT_VRML    50463
#define IDH_JIT_JAVAVMJIT   50464
#define IDH_JIT_IELPKJA 50465
#define IDH_JIT_IELPKKO 50466
#define IDH_JIT_IELPKPE 50467
#define IDH_JIT_IELPKZHT    50468
#define IDH_JIT_IELPKZHC    50469
#define IDH_JIT_IELPKTH 50470
#define IDH_JIT_IELPKIW 50471
#define IDH_JIT_IELPKVI 50472
#define IDH_JIT_IELPKAR 50473
#define IDH_JIT_IELPKAD 50474
#define IDH_JIT_MEDIAPLAYER 50475
#define IDH_JIT_MEDIAFILTER 50476
#define IDH_JIT_ACTIVEPAYMENT   50477
#define IDH_JIT_AOLSUPP 50478
#define IDH_JIT_MOBILEPK    50479
#define IDH_JIT_ICW 50480
#define IDH_JIT_USP10   50481

//organize favorites new UI
#define IDH_ORGFAVS_UP  50482
#define IDH_ORGFAVS_DOWN    50483
#define IDH_ORGFAVS_NEW_FOLDER  50484
#define IDH_ORGFAVS_SORT    50485
#define IDH_ORGFAVS_SYNCHRO 50486
#define IDH_ORGFAVS_IMPORT  50487
#define IDH_ORGFAVS_EXPORT  50488
#define IDH_ORGFAVS_PROPERTIES  50489
#define IDH_ORGFAVS_LIST    50490
#define IDH_SAVEAS_TYPE 50493 //FileSave, Save As Type
#define IDH_CHAR_SET_SAVE_AS    50494//FileSave, Language

#define IDH_AUTH_SAVE_PASSWORD     50495 //client authentication login
#define IDH_AUTH_REALM     50496 //client authentication login
#define IDH_AUTH_DOMAIN     50497 //client authentication login
#define IDH_AUTH_SERVER_FIREWALL     50498 //client authentication login
#define IDH_CPL_SEC_SETTINGS_CURRENT_ADMINAPPROVED     50499 //Active X security settings
#define IDH_SUBPROPS_RECTAB_ADVOPTS_ONLY_HTML_LINKS   50500 // Advanced tab,
#define IDH_ADV_NOTIFY_DWNLD_COMPLETE     50501//Advanced tab: Notify when downloads complete
#define IDH_ADV_DISABLE_JIT     50502//Advanced tab: Enable Install on demand
#define IDH_ADV_DISABLE_CZECH_4NEWER_IE     50503//Advanced tab: Automatically check for Internet Explorer updates

//New JIT topics:
#define IDH_JIT_DIRECTANIMATION   50504
#define IDH_JIT_DIRECTOR   50505
#define IDH_JIT_HELPCONT   50506
#define IDH_JIT_MSN_AUTH   50507
#define IDH_JIT_TRIDATA   50508
#define IDH_JIT_EXTRAPACK   50509
#define IDH_JIT_OK_BUTTON   50510

#define IDH_TLS_PROTOCOL   50511 //Advanced tab, Transport Layer Security protocol checkbox

//New language ids, Yutakan
#define IDH_COMBO_UILANG   50512 // The dropdown listbox on the Menus and Dialogs dialog.
#define IDH_LANG_ADDSPK    50513 // Add satellite pack button: This button leads to the satellite pack downloading web site.
#define IDH_LANG_UI_PREF   50514 //the Change button on the Language Preference dialog, which invokes the Menus and Dialogs dialog.

//New Security tab ids, Lorenk
#define IDH_SEC_LVL_SLIDER 50515 //hook up to the description bullets text also
#define IDH_SEC_ZONE_LIST 50516  //the list of icons at the top of the security tab.

//Content tab,
#define IDH_OPTS_PROG_AUTOSUGGEST_BUT 50517 //Autosuggest button
#define IDH_INTELLIFORM 50524 //Autosuggest forms option//See 50180 for autosuggest address options
#define IDH_CLEAR_INTELLIFORM  50525 //Autosuggest forms clear history button

#define IDH_OPTS_PROG_WALLET_BUT 50518  //Wallet button

//Proxy server settings
#define IDH_PROX_SERV_AUTO  50519 //In proxy server group box (dialup settings) or Lan settings proxy server dialog box: Automatic discovery of proxy server
#define IDH_PROX_SERV_NONE  50520 //In proxy server group box (dialup settings) or Lan settings proxy server dialog box: No proxy server
#define IDH_PROX_SETTINGS_ADV 50521 ////In proxy server group box (dialup settings) or Lan settings proxy server dialog box: Advanced button
#define IDH_DIAL_PROP_ADV  50522 //In dial-up settings group box, Advanced button (for connection attempts and disconnecting settings

//Connections tab

#define IDH_DIAL_DEFAULT  50523 //Set Default button, makes selected connection your default


//advanced tab
#define IDH_ADV_ENABLE_SCRIPTERROR_NOTIFICATION 50526
#define IDH_ADV_ENABLE_SYNC_OF_OFFLINEITEMS_PER_SCHED 50527
#define IDH_ADV_CLOSE_UNUSED_FOLDERS 50528
#define IDH_AUTODISC_DET_ONCE 50529
#define IDH_AUTODISC_DET_DISABLE 50530
#define IDH_AUTODISC_DET_AFTER_NET_CHG 50531
#define IDH_AUTODISC_DET_FOR_ANY_SETTINGS_CHGS 50532

//web folders
#define IDH_WEB_FOLDERS_CKBOX   50533  //in FileOpen dialog box

//Programs tab
#define IDH_HTML_EDITOR 50534 //HTML Editor default

#define IDH_SENDURLS_AS_UTF8 50535 //Send URLS as UTF-8, Advanced tab

#define IDH_SHOW_GO_IN_ADDRESSBAR  50536

#define IDH_SHOW_FRIENDLY_HTTP_ERROR_MESSAGES  50537
#define IDH_INLINE_AUTOCOMP_WEB_ADDRESSES 50538
#define IDH_INLINE_AUTOCOMP_PATHS_N_SHARES 50539
#define IDH_INTELLIFORM_PW 50540
#define IDH_CLEAR_INTELLIFORM_PW 50541
#define IDH_CONNECT_TAB_PERFORM_SECUR_CHECKB4_DIALING 50542

#define IDH_ADD_COMP_RADIO 50543
#define IDH_REPAIR_CURRENT_INSTALLATION 50544
#define IDH_RESTORE_PREVIOUS_IE 50545
#define IDH_MAINT_ADV_BUT 50546
#define IDH_RESTORE_COMPONENT_LIST 50547
#define IDH_DELETE_BACKUP 50548
#define IDH_REMOVE_IE6_SETUP_FILES 50549

#define IDH_CHK_SITE_CERT_REVOC 50550 //Check for server certificate revocation

#define IDH_BROWSEUI_TB_TEXTOPTNS                           50551
#define IDH_BROWSEUI_TB_ICONOPTNS                           50552

#define IDH_JIT_FLASH     50553
#define IDH_JIT_WEBFLDRS     50554
#define IDH_JIT_MESSNGR    50555
#define IDH_JIT_VBSCRIPT    50556
#define IDH_JIT_VML     50557
#define IDH_JIT_WAB    50558

#define IDH_SHOW_PLACEHOLDERS     50559
#define IDH_WEBFTP_ON    50560
#define IDH_CNX_CURRENT_DEFAULT_LBL_N_DISP   50561

#define IDH_INTELLIFORM_PW_PROMPT   50562

//Outlook Express Fonts dialog box
#define IDH_INTL_DEFAULT_OE   50563
#define IDH_CHAR_SET_OE   50564
#define IDH_INTL_FONT_PROP_OE   50565
#define IDH_INTL_FONT_FIXED_OE   50566
#define IDH_FONT_MIME_OE   50567

//New connection radio buttons
#define IDH_NEVERDIAL   50568
#define IDH_DIALIF_NETCNX_GONE   50569

//New Autosearch options in advanced tab
#define IDH_ADDBAR_SRCH_GOTOBEST   50570
#define IDH_ADDBAR_SRCH_RESULTS_ONLY   50571
#define IDH_ADDBAR_DONT_SRCH   50572
#define IDH_ADDBAR_DISP_RESULTS_WHERE   50573

#define IDH_RESET_WEBSTGS_BUTTON 50574

//More Search Settings dialog box
#define IDH_MORESRCH_AVAIL_PROVIDERS  50575 // Available providers list
#define IDH_MORESRCH_PREFERREDPROVIDERS  50576 //Preferred providers list
#define IDH_MORESRCH_ADD_PROVID  50577 //Add button
#define IDH_MORESRCH_REMOVE_PROVID  50578 //Remove button
#define IDH_MORESRCH_PREFRD_MOVEUP  50579  //Move up button
#define IDH_MORESRCH_PREFRD_MOVEDN  50580//Move down button
#define IDH_MORESRCH_RESET  50581 //Reset button

//New IE5.01 Reuse Windows for launching shortcuts option and
//enable personalized favorites menu

#define IDH_REUSE_WINDOWS_FOR_SHORTCUTS 50582
#define IDH_ENABLE_PERSONALIZED_FAVORITES_MENU 50583

#define IDH_SUBPROPS_RECTAB_LOGINOPTS_PASSWORD_CONFIRM 50584 //Displaycpl, Web tab, My current Home page properties, Download tab, Login dialog box, password confirmation text box
#define IDH_SUBPROPS_NEW_SCHEDULE_AUTOCONNECT 50585 //Displaycpl, Web tab, My current home page properties, Schedule tab, Add, If my computer is not connected...checkbox
#define IDH_CONNECTION_SHARING 50586 //inetcpl, Connection tab, Sharing button for Internet Connection manager
#define IDH_RADIO_TOOLBAR_OPTION  50587  //inetcpl, Advanced tab, option to always display the internet radio toolbar.

#define IDH_DEL_COOKIE_THIRD_PARTY     50591 
#define IDH_COOKIE_THIRD_PARTY  50593
#define IDH_COOKIE_FIRST_PARTY  50594

//New help for INETCPL -> Privacy tab
#define IDH_PRIVACY_SLIDER 50601  //Privacy settings slider
#define IDH_PRIVACY_IMPORT 50602  //Import button
#define IDH_PRIVACY_RESET_DEFAULTS 50603  //Reset Defaults button
#define IDH_PRIVACY_ADVANCED 50612 //Advanced button

//New help for INETCPL ->Priv tab -> Adv
#define IDH_PRIVADV_OVERRIDE 50607 //check box
#define IDH_PRIVACYADV_ALLOW_SESSION 50608 //check box
#define IDH_PRIVADV_FIRST_PARTY 50609 //first-party settings radio buttons
#define IDH_PRIVACYADV_THIRD_PARTY 50610 //third-party settings radio buttons
#define IDH_PRIVACYADV_EDIT 50611 //edit button

//New help for INETCPL ->Priv tab -> Adv -> Edit
#define IDH_PRIVADV_ALLOW 50613 //Allow button
#define IDH_PRIVADV_REJECT 50614 //Reject button
#define IDH_PRIVADV_REMOVE 50615 //Remove button
#define IDH_PRIVADV_ADDRESS 50616 //Web site text box
#define IDH_PRIVADV_WEBSITES 50617 //Web site list
#define IDH_PRIVADV_REMOVE_ALL 50619 // Remove all button

//New help for INETCPL ->Content
#define IDH_ADV_CLEAR_SSL_CACHE 50623 //Clear SSL State button


//Enum containing IDs to all the SQMs and Helplinks
//These IDs must be continous and match index into g_sqmData array found in inetcore\lib\stock\util.cpp

typedef enum HelpEnum
{
    HELP_ID_HELP_ENTRY_ID_DANGEROUS_CONTROLS_LEARN_MORE,               
    HELP_ID_WEB_BROWSER_CPL_GENERAL_HELP_BUTTON,                       
    HELP_ID_WEB_BROWSER_CPL_SECURITY_HELP_BUTTON,                      
    HELP_ID_WEB_BROWSER_CPL_PRIVACY_HELP_BUTTON,                       
    HELP_ID_WEB_BROWSER_CPL_CONTENT_HELP_BUTTON,                       
    HELP_ID_WEB_BROWSER_CPL_CONNECTIONS_HELP_BUTTON,                   
    HELP_ID_WEB_BROWSER_CPL_PROGRAMS_HELP_BUTTON,                      
    HELP_ID_WEB_BROWSER_CPL_ADVANCED_HELP_BUTTON,                      
    HELP_ID_WEB_BROWSER_CPL_GENERAL_HELP_BUTTON_DL,                    
    HELP_ID_WEB_BROWSER_CPL_SECURITY_HELP_BUTTON_DL,                   
    HELP_ID_WEB_BROWSER_CPL_PRIVACY_HELP_BUTTON_DL,                    
    HELP_ID_WEB_BROWSER_CPL_CONTENT_HELP_BUTTON_DL,                    
    HELP_ID_WEB_BROWSER_CPL_CONNECTIONS_HELP_BUTTON_DL,                
    HELP_ID_WEB_BROWSER_CPL_PROGRAMS_HELP_BUTTON_DL,                   
    HELP_ID_WEB_BROWSER_CPL_ADVANCED_HELP_BUTTON_DL,                   
    HELP_ID_HELP_ENTRY_ID_BROWSER_INFOBAR_HELP,                        
    HELP_ID_HELP_ENTRY_ID_BROWSER_INFOBAR_ACTIVE_CONTENT,              
    HELP_ID_HELP_ENTRY_ID_BROWSER_INFOBAR_ACTIVEX_CONTROLS,           
    HELP_ID_IE_GENERIC_HELP_F1,       
    HELP_ID_IE_GENERIC_HELP_MENU,              
    HELP_ID_IE_MORE_INFO_ABOUT_ADDONS,                                 
    HELP_ID_HELP_ENTRY_ID_BROWSER_PHISHING_FILTER_REPORT,              
    HELP_ID_HELP_ENTRY_ID_BROWSER_PHISHING_FILTER_FIRST_EXPERIENCE,    
    HELP_ID_HELP_ENTRY_ID_BROWSER_PHISHING_FILTER_CHECK_SITE_DIALOG,   
    HELP_ID_HELP_ENTRY_ID_BROWSER_PHISHING_FILTER_PROGRESS_BAR_DIALOG, 
    HELP_ID_HELP_ENTRY_ID_BROWSER_PHISHING_FILTER_UNAVAILABLE,         
    HELP_ID_IE_SUSPICIOUS_PHISHING_SITE_SECURITY_REPORT,
    HELP_ID_IE_REPORTED_PHISHING_SITE_SECURITY_REPORT,
    HELP_ID_HELP_ENTRY_ID_BROWSER_POPUP_BLOCKER_FAQ,                   
    HELP_ID_IE_MIXED_CONTENT_INFOBAR_WHATS_THE_RISK,                   
    HELP_ID_IE_DELETE_BROWSING_HISTORY_ABOUT,                          
    HELP_ID_IE_RSS_SUBSCRIBE_LEARN_MORE,                               
    HELP_ID_IE_HOW_DOES_RESETTING_AFFECT,                              
    HELP_ID_IE_CERT_ERROR_WHATS_THE_RISK,                              
    HELP_ID_IE_HOW_TO_IGNORE_PRESET_COLORS,                            
    HELP_ID_IE_HOW_TO_IGNORE_PRESET_FONTS,                             
    HELP_ID_IE_LEARN_ABOUT_COOKIES,                                    
    HELP_ID_IE_MANAGE_ADDONS_LEARN_MORE,                               
    HELP_ID_IE_PROTECTED_MODE_DIALOG_WHATS_THE_RISK,                                                      
    HELP_ID_IE_AUTOCOMPLETE_PASSWORD,                                  
    HELP_ID_IE_ADD_ONS_DISABLED_GOLDBAR,                               
    HELP_ID_IE_FIX_SECURITY_SETTINGS,                                  
    HELP_ID_IE_INTRANET_SETTINGS,                                      
    HELP_ID_IE_IDN_WHY_SEE_THIS,                                       
    HELP_ID_IE_GROUP_POLICY_BANNER, 
    HELP_ID_TRUSTBADGE_VALID_CERT,                                                  
    HELP_ID_GB_DOWNLOAD_BLOCKED,                                                                           
    HELP_ID_GB_MIME,        
    HELP_ID_WHAT_WEB_FEED,
    HELP_ID_IE_PARENTAL_CONTROL_INFOBAR_WHATS_THE_RISK,
    HELP_ID_IE_WHY_RESET_FAILED, 
    HELP_ID_IE_RIED_CLOSE_WINDOWS,
    HELP_ID_HELP_ENTRY_IE_WHAT_ARE_IDN,
    HELP_ID_DANGEROUS_DOWNLOAD,
    HELP_ID_NOT_DANGEROUS_DOWNLOAD,
    HELP_ID_BADTRUST_EMAIL_MESSAGE,
    HELP_ID_VALIDTRUST_EMAIL_MESSAGE,
    HELP_ID_PUBISHER_BLOCKED,
    HELP_ID_SHELL_EXE,
    HELP_ID_VALID_SIGNATURE,
    HELP_ID_VALID_PUBLISHER,
    HELP_ID_INVALID_SIGNATURE,
    HELP_ID_INVALID_PUBLISHER,
    HELP_ID_NO_SIGNATURE_BLOCK,
    HELP_ID_TRUSTBADGE_INVALID_CERT,
    HELP_ID_LOCKDOWNZONE,
    HELP_ID_MAX                                           
} HELP_ID;

STDAPI_(HRESULT) IELaunchPlatformHelp(HWND hwnd, HELP_ID helpID);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\ifdef.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    ifdef.h

Abstract:

    This module contains IF_* definitions.

Author:

@@BEGIN_DDKSPLIT
    Dave Thaler (dthaler) 12-Apr-2001
@@END_DDKSPLIT

Environment:

    user mode or kernel mode

--*/

#ifndef _IFDEF_
#define _IFDEF_
#pragma once


typedef ULONG32 NET_IF_OBJECT_ID, *PNET_IF_OBJECT_ID;


typedef enum _NET_IF_ADMIN_STATUS   // ifAdminStatus
{
    NET_IF_ADMIN_STATUS_UP = 1,
    NET_IF_ADMIN_STATUS_DOWN = 2,
    NET_IF_ADMIN_STATUS_TESTING = 3
} NET_IF_ADMIN_STATUS, *PNET_IF_ADMIN_STATUS;

typedef enum _NET_IF_OPER_STATUS   // ifOperStatus
{
    NET_IF_OPER_STATUS_UP = 1,
    NET_IF_OPER_STATUS_DOWN = 2,
    NET_IF_OPER_STATUS_TESTING = 3,
    NET_IF_OPER_STATUS_UNKNOWN = 4,
    NET_IF_OPER_STATUS_DORMANT = 5,
    NET_IF_OPER_STATUS_NOT_PRESENT = 6,
    NET_IF_OPER_STATUS_LOWER_LAYER_DOWN = 7
} NET_IF_OPER_STATUS, *PNET_IF_OPER_STATUS;

//
// Flags to extend operational status
//
#define NET_IF_OPER_STATUS_DOWN_NOT_AUTHENTICATED        0x00000001
#define NET_IF_OPER_STATUS_DOWN_NOT_MEDIA_CONNECTED      0x00000002
#define NET_IF_OPER_STATUS_DORMANT_PAUSED                0x00000004
#define NET_IF_OPER_STATUS_DORMANT_LOW_POWER             0x00000008

typedef UINT32 NET_IF_COMPARTMENT_ID, *PNET_IF_COMPARTMENT_ID;

//
// Define compartment ID type:
//
#define NET_IF_COMPARTMENT_ID_UNSPECIFIED   (NET_IF_COMPARTMENT_ID)0
#define NET_IF_COMPARTMENT_ID_PRIMARY       (NET_IF_COMPARTMENT_ID)1

#define NET_IF_OID_IF_ALIAS             0x00000001  // identifies the ifAlias string for an interface
#define NET_IF_OID_COMPARTMENT_ID       0x00000002  // identifies the compartment ID for an interface.
#define NET_IF_OID_NETWORK_GUID         0x00000003  // identifies the NetworkGuid for an interface.
#define NET_IF_OID_IF_ENTRY             0x00000004  // identifies statistics for an interface.

//
// Define NetworkGUID type:
//
typedef GUID NET_IF_NETWORK_GUID, *PNET_IF_NETWORK_GUID;

//
// Define macros for an "unspecified" NetworkGUID value to be used in structures
// that haven't had the NET_LUID field filled in yet.
//
#define NET_SET_UNSPECIFIED_NETWORK_GUID(_pNetworkGuid)
#define NET_IS_UNSPECIFIED_NETWORK_GUID(_NetworkGuidValue)

//
// To prevent collisions between user-assigned and system-assigend site-ids,
// we partition the site-id space into two:
// 1. User-Assigned: NET_SITEID_UNSPECIFIED < SiteId < NET_SITEID_MAXUSER
// 2. System-Assigned: NET_SITEID_MAXUSER < SiteId < NET_SITEID_MAXSYSTEM
//
// Note: A network's SiteId doesn't really need to be settable.
// 1. The network profile manager creates a network per network profile.
// 2. NDIS/IF assigns a unique SiteId to each network.
//
#define NET_SITEID_UNSPECIFIED (0)
#define NET_SITEID_MAXUSER (0x07ffffff)
#define NET_SITEID_MAXSYSTEM (0x0fffffff)
#ifndef UNDER_CE
C_ASSERT(NET_SITEID_MAXUSER < NET_SITEID_MAXSYSTEM);
#endif

typedef enum _NET_IF_RCV_ADDRESS_TYPE // ifRcvAddressType
{
    NET_IF_RCV_ADDRESS_TYPE_OTHER = 1,
    NET_IF_RCV_ADDRESS_TYPE_VOLATILE = 2,
    NET_IF_RCV_ADDRESS_TYPE_NON_VOLATILE = 3
} NET_IF_RCV_ADDRESS_TYPE, *PNET_IF_RCV_ADDRESS_TYPE;

typedef struct _NET_IF_RCV_ADDRESS_LH
{
    NET_IF_RCV_ADDRESS_TYPE ifRcvAddressType;
    USHORT                  ifRcvAddressLength;
    USHORT                  ifRcvAddressOffset; // from beginning of this struct
} NET_IF_RCV_ADDRESS_LH, *PNET_IF_RCV_ADDRESS_LH;

typedef struct _NET_IF_ALIAS_LH
{
    USHORT  ifAliasLength;  // in bytes, of ifAlias string
    USHORT  ifAliasOffset;  // in bytes, from beginning of this struct
} NET_IF_ALIAS_LH, *PNET_IF_ALIAS_LH;

#pragma warning(push)
#pragma warning(disable:4214) // bit field types other than int
typedef union _NET_LUID_LH
{
    ULONG64     Value;
    struct
    {
        ULONG64     Reserved:24;
        ULONG64     NetLuidIndex:24;
        ULONG64     IfType:16;                  // equal to IANA IF type
    }Info;
} NET_LUID_LH, *PNET_LUID_LH;
#pragma warning(pop)

#if (NTDDI_VERSION >= NTDDI_LONGHORN)
typedef NET_IF_RCV_ADDRESS_LH NET_IF_RCV_ADDRESS;
typedef NET_IF_RCV_ADDRESS* PNET_IF_RCV_ADDRESS;

typedef NET_IF_ALIAS_LH NET_IF_ALIAS;
typedef NET_IF_ALIAS* PNET_IF_ALIAS;
#endif //NTDDI_LONGHORN

//
// Need to make this visible on all platforms (for the purpose of IF_LUID).
//
typedef NET_LUID_LH NET_LUID;
typedef NET_LUID* PNET_LUID;

//
// IF_LUID
//
// Define the locally unique datalink interface identifier type.
// This type is persistable.
//
typedef NET_LUID IF_LUID, *PIF_LUID;

typedef ULONG NET_IFINDEX, *PNET_IFINDEX;       // Interface Index (ifIndex)
typedef UINT16 NET_IFTYPE, *PNET_IFTYPE;        // Interface Type (IANA ifType)

#define NET_IFINDEX_UNSPECIFIED (NET_IFINDEX)(0)    // Not a valid ifIndex
#define NET_IFLUID_UNSPECIFIED (0)    // Not a valid if Luid

//
// Definitions for NET_IF_INFORMATION.Flags
//
#define NIIF_HARDWARE_INTERFACE         0x00000001  // Set iff hardware
#define NIIF_FILTER_INTERFACE           0x00000002
#define NIIF_NDIS_RESERVED1             0x00000004
#define NIIF_NDIS_RESERVED2             0x00000008
#define NIIF_NDIS_RESERVED3             0x00000010
#define NIIF_NDIS_WDM_INTERFACE         0x00000020
#define NIIF_NDIS_ENDPOINT_INTERFACE    0x00000040

#define NIIF_WAN_TUNNEL_TYPE_UNKNOWN    ((ULONG)(-1))

//
// Define datalink interface access types.
//
typedef enum _NET_IF_ACCESS_TYPE
{
    NET_IF_ACCESS_LOOPBACK = 1,
    NET_IF_ACCESS_BROADCAST = 2,
    NET_IF_ACCESS_POINT_TO_POINT = 3,
    NET_IF_ACCESS_POINT_TO_MULTI_POINT = 4,
    NET_IF_ACCESS_MAXIMUM = 5
} NET_IF_ACCESS_TYPE, *PNET_IF_ACCESS_TYPE;


//
// Define datalink interface direction types.
//
typedef enum _NET_IF_DIRECTION_TYPE
{
    NET_IF_DIRECTION_SENDRECEIVE,
    NET_IF_DIRECTION_SENDONLY,
    NET_IF_DIRECTION_RECEIVEONLY,
    NET_IF_DIRECTION_MAXIMUM
} NET_IF_DIRECTION_TYPE, *PNET_IF_DIRECTION_TYPE;


typedef enum _NET_IF_CONNECTION_TYPE
{
   NET_IF_CONNECTION_DEDICATED = 1,
   NET_IF_CONNECTION_PASSIVE = 2,
   NET_IF_CONNECTION_DEMAND = 3,
   NET_IF_CONNECTION_MAXIMUM = 4
} NET_IF_CONNECTION_TYPE, *PNET_IF_CONNECTION_TYPE;


typedef enum _NET_IF_MEDIA_CONNECT_STATE
{
    MediaConnectStateUnknown,
    MediaConnectStateConnected,
    MediaConnectStateDisconnected
} NET_IF_MEDIA_CONNECT_STATE, *PNET_IF_MEDIA_CONNECT_STATE;

#define NET_IF_LINK_SPEED_UNKNOWN   ((ULONG64)(-1))

//
// Defines the duplex state of media
//
typedef enum _NET_IF_MEDIA_DUPLEX_STATE
{
    MediaDuplexStateUnknown,
    MediaDuplexStateHalf,
    MediaDuplexStateFull
} NET_IF_MEDIA_DUPLEX_STATE, *PNET_IF_MEDIA_DUPLEX_STATE;


// Special values for fields in NET_PHYSICAL_LOCATION
#define NIIF_BUS_NUMBER_UNKNOWN         ((ULONG)(-1))
#define NIIF_SLOT_NUMBER_UNKNOWN        ((ULONG)(-1))
#define NIIF_FUNCTION_NUMBER_UNKNOWN    ((ULONG)(-1))

typedef struct _NET_PHYSICAL_LOCATION_LH
{
    ULONG                   BusNumber;          // Physical location
    ULONG                   SlotNumber;         // ... for hardware
    ULONG                   FunctionNumber;     // ... devices.
} NET_PHYSICAL_LOCATION_LH, *PNET_PHYSICAL_LOCATION_LH;

//
// maximum string size in -wchar- units
//
#define IF_MAX_STRING_SIZE 256

typedef struct _IF_COUNTED_STRING_LH
{
    USHORT      Length; // in -Bytes-
    WCHAR       String[IF_MAX_STRING_SIZE + 1];
} IF_COUNTED_STRING_LH, *PIF_COUNTED_STRING_LH;

#define IF_MAX_PHYS_ADDRESS_LENGTH 32

typedef struct _IF_PHYSICAL_ADDRESS_LH
{
    USHORT      Length;
    UCHAR       Address[IF_MAX_PHYS_ADDRESS_LENGTH];
} IF_PHYSICAL_ADDRESS_LH, *PIF_PHYSICAL_ADDRESS_LH;

#if (NTDDI_VERSION >= NTDDI_LONGHORN)
typedef NET_PHYSICAL_LOCATION_LH NET_PHYSICAL_LOCATION;
typedef NET_PHYSICAL_LOCATION* PNET_PHYSICAL_LOCATION;

typedef IF_COUNTED_STRING_LH IF_COUNTED_STRING;
typedef IF_COUNTED_STRING* PIF_COUNTED_STRING;

typedef IF_PHYSICAL_ADDRESS_LH IF_PHYSICAL_ADDRESS;
typedef IF_PHYSICAL_ADDRESS* PIF_PHYSICAL_ADDRESS;
#endif


//
// IF_INDEX
//
// Define the interface index type.
// This type is not persistable.
// This must be unsigned (not an enum) to replace previous uses of
// an index that used a DWORD type.
//

typedef NET_IFINDEX IF_INDEX, *PIF_INDEX;
#define IFI_UNSPECIFIED NET_IFINDEX_UNSPECIFIED


//
// Get definitions for IFTYPE and IF_ACCESS_TYPE.
//
#include <ipifcons.h>


//
// Types of tunnels (sub-type of IF_TYPE when IF_TYPE is IF_TYPE_TUNNEL).
// See http://www.iana.org/assignments/ianaiftype-mib.
//
typedef enum {
    TUNNEL_TYPE_NONE = 0,
    TUNNEL_TYPE_OTHER = 1,
    TUNNEL_TYPE_DIRECT = 2,
    TUNNEL_TYPE_6TO4 = 11,
    TUNNEL_TYPE_ISATAP = 13,
    TUNNEL_TYPE_TEREDO = 14,
} TUNNEL_TYPE, *PTUNNEL_TYPE;

//
// IF_ADMINISTRATIVE_STATE
//
// Datalink Interface Administrative State.
// Indicates whether the interface has been administratively enabled.
//

typedef enum _IF_ADMINISTRATIVE_STATE {
    IF_ADMINISTRATIVE_DISABLED,
    IF_ADMINISTRATIVE_ENABLED,
    IF_ADMINISTRATIVE_DEMANDDIAL,
} IF_ADMINISTRATIVE_STATE, *PIF_ADMINISTRATIVE_STATE;


//
// Note: Interface is Operational iff
// ((MediaSense is Connected) and (AdministrativeState is Enabled))
// or
// ((MediaSense is Connected) and (AdministrativeState is OnDemand))
//
// !Operational iff
// ((MediaSense != Connected) or (AdministrativeState is Disabled))
//

//
// OperStatus values from RFC 2863
//
typedef enum {
    IfOperStatusUp = 1,
    IfOperStatusDown,
    IfOperStatusTesting,
    IfOperStatusUnknown,
    IfOperStatusDormant,
    IfOperStatusNotPresent,
    IfOperStatusLowerLayerDown
} IF_OPER_STATUS;

typedef struct _NDIS_INTERFACE_INFORMATION
{
    //
    //  rod fields
    //
    NET_IF_OPER_STATUS          ifOperStatus;
    ULONG                       ifOperStatusFlags;
    NET_IF_MEDIA_CONNECT_STATE  MediaConnectState;
    NET_IF_MEDIA_DUPLEX_STATE   MediaDuplexState;
    ULONG                       ifMtu;
    BOOLEAN                     ifPromiscuousMode;
    BOOLEAN                     ifDeviceWakeUpEnable;
    ULONG64                     XmitLinkSpeed;
    ULONG64                     RcvLinkSpeed;

    ULONG64                     ifLastChange;
    ULONG64                     ifCounterDiscontinuityTime;
    ULONG64                     ifInUnknownProtos;

    //
    // OID_GEN_STATISTICS
    //
    ULONG64                     ifInDiscards;           // OID_GEN_RCV_DISCARDS = OID_GEN_RCV_ERROR + OID_GEN_RCV_NO_BUFFER
    ULONG64                     ifInErrors;             // OID_GEN_RCV_ERROR
    ULONG64                     ifHCInOctets;           // OID_GEN_BYTES_RCV = OID_GEN_DIRECTED_BYTES_RCV + OID_GEN_MULTICAST_BYTES_RCV + OID_GEN_BROADCAST_BYTES_RCV
    ULONG64                     ifHCInUcastPkts;        // OID_GEN_DIRECTED_FRAMES_RCV
    ULONG64                     ifHCInMulticastPkts;    // OID_GEN_MULTICAST_FRAMES_RCV
    ULONG64                     ifHCInBroadcastPkts;    // OID_GEN_BROADCAST_FRAMES_RCV
    ULONG64                     ifHCOutOctets;          // OID_GEN_BYTES_XMIT = OID_GEN_DIRECTED_BYTES_XMIT + OID_GEN_MULTICAST_BYTES_XMIT + OID_GEN_BROADCAST_BYTES_XMIT
    ULONG64                     ifHCOutUcastPkts;       // OID_GEN_DIRECTED_FRAMES_XMIT
    ULONG64                     ifHCOutMulticastPkts;   // OID_GEN_MULTICAST_FRAMES_XMIT
    ULONG64                     ifHCOutBroadcastPkts;   // OID_GEN_BROADCAST_FRAMES_XMIT
    ULONG64                     ifOutErrors;            // OID_GEN_XMIT_ERROR
    ULONG64                     ifOutDiscards;          // OID_GEN_XMIT_DISCARDS
    ULONG64                     ifHCInUcastOctets;      // OID_GEN_DIRECTED_BYTES_RCV
    ULONG64                     ifHCInMulticastOctets;  // OID_GEN_MULTICAST_BYTES_RCV
    ULONG64                     ifHCInBroadcastOctets;  // OID_GEN_BROADCAST_BYTES_RCV
    ULONG64                     ifHCOutUcastOctets;     // OID_GEN_DIRECTED_BYTES_XMIT
    ULONG64                     ifHCOutMulticastOctets; // OID_GEN_MULTICAST_BYTES_XMIT
    ULONG64                     ifHCOutBroadcastOctets; // OID_GEN_BROADCAST_BYTES_XMIT
    NET_IF_COMPARTMENT_ID       CompartmentId;
    ULONG                       SupportedStatistics;
}NDIS_INTERFACE_INFORMATION, *PNDIS_INTERFACE_INFORMATION;

#endif // _IFDEF_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\iketypes.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0543 */
/* Compiler settings for iketypes.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __iketypes_h__
#define __iketypes_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

/* header files for imported files */
#include "fwptypes.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_iketypes_0000_0000 */
/* [local] */ 

#if _MSC_VER >=  800
#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4201)
#endif
typedef struct IPSEC_V4_UDP_ENCAPSULATION0_ IPSEC_V4_UDP_ENCAPSULATION0;

typedef /* [v1_enum] */ 
enum IKEEXT_KEY_MODULE_TYPE_
    {	IKEEXT_KEY_MODULE_IKE	= 0,
	IKEEXT_KEY_MODULE_AUTHIP	= ( IKEEXT_KEY_MODULE_IKE + 1 ) ,
	IKEEXT_KEY_MODULE_MAX	= ( IKEEXT_KEY_MODULE_AUTHIP + 1 ) 
    } 	IKEEXT_KEY_MODULE_TYPE;

typedef /* [v1_enum] */ 
enum IKEEXT_AUTHENTICATION_METHOD_TYPE_
    {	IKEEXT_PRESHARED_KEY	= 0,
	IKEEXT_CERTIFICATE	= ( IKEEXT_PRESHARED_KEY + 1 ) ,
	IKEEXT_KERBEROS	= ( IKEEXT_CERTIFICATE + 1 ) ,
	IKEEXT_ANONYMOUS	= ( IKEEXT_KERBEROS + 1 ) ,
	IKEEXT_SSL	= ( IKEEXT_ANONYMOUS + 1 ) ,
	IKEEXT_NTLM_V2	= ( IKEEXT_SSL + 1 ) ,
	IKEEXT_IPV6_CGA	= ( IKEEXT_NTLM_V2 + 1 ) ,
	IKEEXT_CERTIFICATE_ECDSA_P256	= ( IKEEXT_IPV6_CGA + 1 ) ,
	IKEEXT_CERTIFICATE_ECDSA_P384	= ( IKEEXT_CERTIFICATE_ECDSA_P256 + 1 ) ,
	IKEEXT_SSL_ECDSA_P256	= ( IKEEXT_CERTIFICATE_ECDSA_P384 + 1 ) ,
	IKEEXT_SSL_ECDSA_P384	= ( IKEEXT_SSL_ECDSA_P256 + 1 ) ,
	IKEEXT_AUTHENTICATION_METHOD_TYPE_MAX	= ( IKEEXT_SSL_ECDSA_P384 + 1 ) 
    } 	IKEEXT_AUTHENTICATION_METHOD_TYPE;

typedef /* [v1_enum] */ 
enum IKEEXT_AUTHENTICATION_IMPERSONATION_TYPE_
    {	IKEEXT_IMPERSONATION_NONE	= 0,
	IKEEXT_IMPERSONATION_SOCKET_PRINCIPAL	= ( IKEEXT_IMPERSONATION_NONE + 1 ) ,
	IKEEXT_IMPERSONATION_MAX	= ( IKEEXT_IMPERSONATION_SOCKET_PRINCIPAL + 1 ) 
    } 	IKEEXT_AUTHENTICATION_IMPERSONATION_TYPE;

typedef struct IKEEXT_PRESHARED_KEY_AUTHENTICATION0__
    {
    FWP_BYTE_BLOB presharedKey;
    } 	IKEEXT_PRESHARED_KEY_AUTHENTICATION0;

#define IKEEXT_CERT_FLAG_ENABLE_ACCOUNT_MAPPING  (0x00000001)
#define IKEEXT_CERT_FLAG_DISABLE_REQUEST_PAYLOAD (0x00000002)
#define IKEEXT_CERT_FLAG_USE_NAP_CERTIFICATE     (0x00000004)
#define IKEEXT_CERT_FLAG_INTERMEDIATE_CA         (0x00000008)
typedef struct IKEEXT_CERT_ROOT_CONFIG0_
    {
    FWP_BYTE_BLOB certData;
    UINT32 flags;
    } 	IKEEXT_CERT_ROOT_CONFIG0;

#define IKEEXT_CERT_AUTH_FLAG_SSL_ONE_WAY              (0x00000001)
#define IKEEXT_CERT_AUTH_FLAG_DISABLE_CRL_CHECK        (0x00000002)
#define IKEEXT_CERT_AUTH_ENABLE_CRL_CHECK_STRONG       (0x00000004)
#define IKEEXT_CERT_AUTH_DISABLE_SSL_CERT_VALIDATION (0x00000008)
typedef /* [v1_enum] */ 
enum IKEEXT_CERT_CONFIG_TYPE_
    {	IKEEXT_CERT_CONFIG_EXPLICIT_TRUST_LIST	= 0,
	IKEEXT_CERT_CONFIG_ENTERPRISE_STORE	= ( IKEEXT_CERT_CONFIG_EXPLICIT_TRUST_LIST + 1 ) ,
	IKEEXT_CERT_CONFIG_TRUSTED_ROOT_STORE	= ( IKEEXT_CERT_CONFIG_ENTERPRISE_STORE + 1 ) ,
	IKEEXT_CERT_CONFIG_TYPE_MAX	= ( IKEEXT_CERT_CONFIG_TRUSTED_ROOT_STORE + 1 ) 
    } 	IKEEXT_CERT_CONFIG_TYPE;

typedef struct IKEEXT_CERTIFICATE_AUTHENTICATION0_
    {
    IKEEXT_CERT_CONFIG_TYPE inboundConfigType;
    union 
        {
        struct 
            {
            UINT32 inboundRootArraySize;
            IKEEXT_CERT_ROOT_CONFIG0 *inboundRootArray;
            } 	;
        IKEEXT_CERT_ROOT_CONFIG0 *inboundEnterpriseStoreConfig;
        IKEEXT_CERT_ROOT_CONFIG0 *inboundTrustedRootStoreConfig;
        } 	;
    IKEEXT_CERT_CONFIG_TYPE outboundConfigType;
    union 
        {
        struct 
            {
            UINT32 outboundRootArraySize;
            IKEEXT_CERT_ROOT_CONFIG0 *outboundRootArray;
            } 	;
        IKEEXT_CERT_ROOT_CONFIG0 *outboundEnterpriseStoreConfig;
        IKEEXT_CERT_ROOT_CONFIG0 *outboundTrustedRootStoreConfig;
        } 	;
    UINT32 flags;
    } 	IKEEXT_CERTIFICATE_AUTHENTICATION0;

typedef struct IKEEXT_IPV6_CGA_AUTHENTICATION0_
    {
    wchar_t *keyContainerName;
    wchar_t *cspName;
    UINT32 cspType;
    FWP_BYTE_ARRAY16 cgaModifier;
    BYTE cgaCollisionCount;
    } 	IKEEXT_IPV6_CGA_AUTHENTICATION0;

#define IKEEXT_KERB_AUTH_DISABLE_INITIATOR_TOKEN_GENERATION (0x00000001)
#define IKEEXT_KERB_AUTH_DONT_ACCEPT_EXPLICIT_CREDENTIALS (0x00000002)
typedef struct IKEEXT_KERBEROS_AUTHENTICATION0__
    {
    UINT32 flags;
    } 	IKEEXT_KERBEROS_AUTHENTICATION0;

#define IKEEXT_NTLM_V2_AUTH_DONT_ACCEPT_EXPLICIT_CREDENTIALS (0x00000001)
typedef struct IKEEXT_NTLM_V2_AUTHENTICATION0__
    {
    UINT32 flags;
    } 	IKEEXT_NTLM_V2_AUTHENTICATION0;

typedef struct IKEEXT_AUTHENTICATION_METHOD0_
    {
    IKEEXT_AUTHENTICATION_METHOD_TYPE authenticationMethodType;
    union 
        {
        IKEEXT_PRESHARED_KEY_AUTHENTICATION0 presharedKeyAuthentication;
        IKEEXT_CERTIFICATE_AUTHENTICATION0 certificateAuthentication;
        IKEEXT_KERBEROS_AUTHENTICATION0 kerberosAuthentication;
        IKEEXT_NTLM_V2_AUTHENTICATION0 ntlmV2Authentication;
         /* Empty union arm */ 
        IKEEXT_CERTIFICATE_AUTHENTICATION0 sslAuthentication;
        IKEEXT_IPV6_CGA_AUTHENTICATION0 cgaAuthentication;
        } 	;
    } 	IKEEXT_AUTHENTICATION_METHOD0;

typedef /* [v1_enum] */ 
enum IKEEXT_CIPHER_TYPE_
    {	IKEEXT_CIPHER_DES	= 0,
	IKEEXT_CIPHER_3DES	= ( IKEEXT_CIPHER_DES + 1 ) ,
	IKEEXT_CIPHER_AES_128	= ( IKEEXT_CIPHER_3DES + 1 ) ,
	IKEEXT_CIPHER_AES_192	= ( IKEEXT_CIPHER_AES_128 + 1 ) ,
	IKEEXT_CIPHER_AES_256	= ( IKEEXT_CIPHER_AES_192 + 1 ) ,
	IKEEXT_CIPHER_TYPE_MAX	= ( IKEEXT_CIPHER_AES_256 + 1 ) 
    } 	IKEEXT_CIPHER_TYPE;

typedef struct IKEEXT_CIPHER_ALGORITHM0_
    {
    IKEEXT_CIPHER_TYPE algoIdentifier;
    UINT32 keyLen;
    UINT32 rounds;
    } 	IKEEXT_CIPHER_ALGORITHM0;

typedef /* [v1_enum] */ 
enum IKEEXT_INTEGRITY_TYPE_
    {	IKEEXT_INTEGRITY_MD5	= 0,
	IKEEXT_INTEGRITY_SHA1	= ( IKEEXT_INTEGRITY_MD5 + 1 ) ,
	IKEEXT_INTEGRITY_SHA_256	= ( IKEEXT_INTEGRITY_SHA1 + 1 ) ,
	IKEEXT_INTEGRITY_SHA_384	= ( IKEEXT_INTEGRITY_SHA_256 + 1 ) ,
	IKEEXT_INTEGRITY_TYPE_MAX	= ( IKEEXT_INTEGRITY_SHA_384 + 1 ) 
    } 	IKEEXT_INTEGRITY_TYPE;

typedef struct IKEEXT_INTEGRITY_ALGORITHM0_
    {
    IKEEXT_INTEGRITY_TYPE algoIdentifier;
    } 	IKEEXT_INTEGRITY_ALGORITHM0;

typedef /* [v1_enum] */ 
enum IKEEXT_DH_GROUP_
    {	IKEEXT_DH_GROUP_NONE	= 0,
	IKEEXT_DH_GROUP_1	= ( IKEEXT_DH_GROUP_NONE + 1 ) ,
	IKEEXT_DH_GROUP_2	= ( IKEEXT_DH_GROUP_1 + 1 ) ,
	IKEEXT_DH_GROUP_2048	= ( IKEEXT_DH_GROUP_2 + 1 ) ,
	IKEEXT_DH_ECP_256	= ( IKEEXT_DH_GROUP_2048 + 1 ) ,
	IKEEXT_DH_ECP_384	= ( IKEEXT_DH_ECP_256 + 1 ) ,
	IKEEXT_DH_GROUP_MAX	= ( IKEEXT_DH_ECP_384 + 1 ) 
    } 	IKEEXT_DH_GROUP;

typedef struct IKEEXT_PROPOSAL0_
    {
    IKEEXT_CIPHER_ALGORITHM0 cipherAlgorithm;
    IKEEXT_INTEGRITY_ALGORITHM0 integrityAlgorithm;
    UINT32 maxLifetimeSeconds;
    IKEEXT_DH_GROUP dhGroup;
    UINT32 quickModeLimit;
    } 	IKEEXT_PROPOSAL0;

#define IKEEXT_POLICY_FLAG_DISABLE_DIAGNOSTICS (0x00000001)
#define IKEEXT_POLICY_FLAG_NO_MACHINE_LUID_VERIFY (0x00000002)
#define IKEEXT_POLICY_FLAG_NO_IMPERSONATION_LUID_VERIFY (0x00000004)
#define IKEEXT_POLICY_FLAG_ENABLE_OPTIONAL_DH (0x00000008)
typedef struct IKEEXT_POLICY0_
    {
    UINT32 softExpirationTime;
    UINT32 numAuthenticationMethods;
    IKEEXT_AUTHENTICATION_METHOD0 *authenticationMethods;
    IKEEXT_AUTHENTICATION_IMPERSONATION_TYPE initiatorImpersonationType;
    UINT32 numIkeProposals;
    IKEEXT_PROPOSAL0 *ikeProposals;
    UINT32 flags;
    UINT32 maxDynamicFilters;
    } 	IKEEXT_POLICY0;

typedef struct IKEEXT_EM_POLICY0_
    {
    UINT32 numAuthenticationMethods;
    IKEEXT_AUTHENTICATION_METHOD0 *authenticationMethods;
    IKEEXT_AUTHENTICATION_IMPERSONATION_TYPE initiatorImpersonationType;
    } 	IKEEXT_EM_POLICY0;

#define IKEEXT_ERROR_CODE_COUNT  \

(ERROR_IPSEC_IKE_NEG_STATUS_END - ERROR_IPSEC_IKE_NEG_STATUS_BEGIN)
typedef struct IKEEXT_IP_VERSION_SPECIFIC_KEYMODULE_STATISTICS0_
    {
    UINT32 currentActiveMainModes;
    UINT32 totalMainModesStarted;
    UINT32 totalSuccessfulMainModes;
    UINT32 totalFailedMainModes;
    UINT32 totalResponderMainModes;
    UINT32 currentNewResponderMainModes;
    UINT32 currentActiveQuickModes;
    UINT32 totalQuickModesStarted;
    UINT32 totalSuccessfulQuickModes;
    UINT32 totalFailedQuickModes;
    UINT32 totalAcquires;
    UINT32 totalReinitAcquires;
    UINT32 currentActiveExtendedModes;
    UINT32 totalExtendedModesStarted;
    UINT32 totalSuccessfulExtendedModes;
    UINT32 totalFailedExtendedModes;
    UINT32 totalImpersonationExtendedModes;
    UINT32 totalImpersonationMainModes;
    } 	IKEEXT_IP_VERSION_SPECIFIC_KEYMODULE_STATISTICS0;

typedef struct IKEEXT_KEYMODULE_STATISTICS0_
    {
    IKEEXT_IP_VERSION_SPECIFIC_KEYMODULE_STATISTICS0 v4Statistics;
    IKEEXT_IP_VERSION_SPECIFIC_KEYMODULE_STATISTICS0 v6Statistics;
    UINT32 errorFrequencyTable[ 84 ];
    UINT32 mainModeNegotiationTime;
    UINT32 quickModeNegotiationTime;
    UINT32 extendedModeNegotiationTime;
    } 	IKEEXT_KEYMODULE_STATISTICS0;

typedef struct IKEEXT_IP_VERSION_SPECIFIC_COMMON_STATISTICS0_
    {
    UINT32 totalSocketReceiveFailures;
    UINT32 totalSocketSendFailures;
    } 	IKEEXT_IP_VERSION_SPECIFIC_COMMON_STATISTICS0;

typedef struct IKEEXT_COMMON_STATISTICS0_
    {
    IKEEXT_IP_VERSION_SPECIFIC_COMMON_STATISTICS0 v4Statistics;
    IKEEXT_IP_VERSION_SPECIFIC_COMMON_STATISTICS0 v6Statistics;
    UINT32 totalPacketsReceived;
    UINT32 totalInvalidPacketsReceived;
    UINT32 currentQueuedWorkitems;
    } 	IKEEXT_COMMON_STATISTICS0;

typedef struct IKEEXT_STATISTICS0_
    {
    IKEEXT_KEYMODULE_STATISTICS0 ikeStatistics;
    IKEEXT_KEYMODULE_STATISTICS0 authipStatistics;
    IKEEXT_COMMON_STATISTICS0 commonStatistics;
    } 	IKEEXT_STATISTICS0;

typedef struct IKEEXT_TRAFFIC0_
    {
    FWP_IP_VERSION ipVersion;
    union 
        {
        UINT32 localV4Address;
        UINT8 localV6Address[ 16 ];
        } 	;
    union 
        {
        UINT32 remoteV4Address;
        UINT8 remoteV6Address[ 16 ];
        } 	;
    UNALIGNEDUINT64 authIpFilterId;
    } 	IKEEXT_TRAFFIC0;

typedef UNALIGNEDUINT64 IKEEXT_COOKIE;

typedef struct IKEEXT_COOKIE_PAIR0_
    {
    IKEEXT_COOKIE initiator;
    IKEEXT_COOKIE responder;
    } 	IKEEXT_COOKIE_PAIR0;

#define IKEEXT_CERT_CREDENTIAL_FLAG_NAP_CERT     (0x00000001)
typedef struct IKEEXT_CERTIFICATE_CREDENTIAL0_
    {
    FWP_BYTE_BLOB subjectName;
    FWP_BYTE_BLOB certHash;
    UINT32 flags;
    } 	IKEEXT_CERTIFICATE_CREDENTIAL0;

typedef struct IKEEXT_NAME_CREDENTIAL0_
    {
    wchar_t *principalName;
    } 	IKEEXT_NAME_CREDENTIAL0;

typedef struct IKEEXT_CREDENTIAL0_
    {
    IKEEXT_AUTHENTICATION_METHOD_TYPE authenticationMethodType;
    IKEEXT_AUTHENTICATION_IMPERSONATION_TYPE impersonationType;
    union 
        {
        IKEEXT_PRESHARED_KEY_AUTHENTICATION0 *presharedKey;
        IKEEXT_CERTIFICATE_CREDENTIAL0 *certificate;
        IKEEXT_NAME_CREDENTIAL0 *name;
         /* Empty union arm */ 
         /* Empty union arm */ 
        } 	;
    } 	IKEEXT_CREDENTIAL0;

typedef struct IKEEXT_CREDENTIAL_PAIR0_
    {
    IKEEXT_CREDENTIAL0 localCredentials;
    IKEEXT_CREDENTIAL0 peerCredentials;
    } 	IKEEXT_CREDENTIAL_PAIR0;

typedef struct IKEEXT_CREDENTIALS0_
    {
    UINT32 numCredentials;
    IKEEXT_CREDENTIAL_PAIR0 *credentials;
    } 	IKEEXT_CREDENTIALS0;

typedef struct IKEEXT_SA_DETAILS0_
    {
    UNALIGNEDUINT64 saId;
    IKEEXT_KEY_MODULE_TYPE keyModuleType;
    FWP_IP_VERSION ipVersion;
    union 
        {
        IPSEC_V4_UDP_ENCAPSULATION0 *v4UdpEncapsulation;
         /* Empty union arm */ 
        } 	;
    IKEEXT_TRAFFIC0 ikeTraffic;
    IKEEXT_PROPOSAL0 ikeProposal;
    IKEEXT_COOKIE_PAIR0 cookiePair;
    IKEEXT_CREDENTIALS0 ikeCredentials;
    GUID ikePolicyKey;
    } 	IKEEXT_SA_DETAILS0;

typedef struct IKEEXT_SA_ENUM_TEMPLATE0_
    {
    FWP_CONDITION_VALUE0 localSubNet;
    FWP_CONDITION_VALUE0 remoteSubNet;
    FWP_BYTE_BLOB localMainModeCertHash;
    } 	IKEEXT_SA_ENUM_TEMPLATE0;

typedef /* [v1_enum] */ 
enum IKEEXT_MM_SA_STATE_
    {	IKEEXT_MM_SA_STATE_NONE	= 0,
	IKEEXT_MM_SA_STATE_SA_SENT	= ( IKEEXT_MM_SA_STATE_NONE + 1 ) ,
	IKEEXT_MM_SA_STATE_SSPI_SENT	= ( IKEEXT_MM_SA_STATE_SA_SENT + 1 ) ,
	IKEEXT_MM_SA_STATE_FINAL	= ( IKEEXT_MM_SA_STATE_SSPI_SENT + 1 ) ,
	IKEEXT_MM_SA_STATE_FINAL_SENT	= ( IKEEXT_MM_SA_STATE_FINAL + 1 ) ,
	IKEEXT_MM_SA_STATE_COMPLETE	= ( IKEEXT_MM_SA_STATE_FINAL_SENT + 1 ) ,
	IKEEXT_MM_SA_STATE_MAX	= ( IKEEXT_MM_SA_STATE_COMPLETE + 1 ) 
    } 	IKEEXT_MM_SA_STATE;

typedef /* [v1_enum] */ 
enum IKEEXT_QM_SA_STATE_
    {	IKEEXT_QM_SA_STATE_NONE	= 0,
	IKEEXT_QM_SA_STATE_INITIAL	= ( IKEEXT_QM_SA_STATE_NONE + 1 ) ,
	IKEEXT_QM_SA_STATE_FINAL	= ( IKEEXT_QM_SA_STATE_INITIAL + 1 ) ,
	IKEEXT_QM_SA_STATE_COMPLETE	= ( IKEEXT_QM_SA_STATE_FINAL + 1 ) ,
	IKEEXT_QM_SA_STATE_MAX	= ( IKEEXT_QM_SA_STATE_COMPLETE + 1 ) 
    } 	IKEEXT_QM_SA_STATE;

typedef /* [v1_enum] */ 
enum IKEEXT_EM_SA_STATE_
    {	IKEEXT_EM_SA_STATE_NONE	= 0,
	IKEEXT_EM_SA_STATE_SENT_ATTS	= ( IKEEXT_EM_SA_STATE_NONE + 1 ) ,
	IKEEXT_EM_SA_STATE_SSPI_SENT	= ( IKEEXT_EM_SA_STATE_SENT_ATTS + 1 ) ,
	IKEEXT_EM_SA_STATE_AUTH_COMPLETE	= ( IKEEXT_EM_SA_STATE_SSPI_SENT + 1 ) ,
	IKEEXT_EM_SA_STATE_FINAL	= ( IKEEXT_EM_SA_STATE_AUTH_COMPLETE + 1 ) ,
	IKEEXT_EM_SA_STATE_COMPLETE	= ( IKEEXT_EM_SA_STATE_FINAL + 1 ) ,
	IKEEXT_EM_SA_STATE_MAX	= ( IKEEXT_EM_SA_STATE_COMPLETE + 1 ) 
    } 	IKEEXT_EM_SA_STATE;

typedef /* [v1_enum] */ 
enum IKEEXT_SA_ROLE_
    {	IKEEXT_SA_ROLE_INITIATOR	= 0,
	IKEEXT_SA_ROLE_RESPONDER	= ( IKEEXT_SA_ROLE_INITIATOR + 1 ) ,
	IKEEXT_SA_ROLE_MAX	= ( IKEEXT_SA_ROLE_RESPONDER + 1 ) 
    } 	IKEEXT_SA_ROLE;

#if _MSC_VER >=  800
#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4201)
#endif
#endif


extern RPC_IF_HANDLE __MIDL_itf_iketypes_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_iketypes_0000_0000_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\iepmapi.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES.
//
//+-------------------------------------------------------------------------
//
//  iepmapi.h -- This module defines the IE Protected Mode APIs
// 
//  Copyright (c) Microsoft Corp. All rights reserved.
//
//--------------------------------------------------------------------------
#ifndef _IEPMAPI_
#define _IEPMAPI_


#if _MSC_VER > 1000
#pragma once
#endif

// Remap old API names to new ones.
#define IEGetWriteableHKCU      IEGetWriteableLowHKCU

//+-------------------------------------------------------------------------
//
// Structure:   IELAUNCHURLINFO
//
// Members:
//              cbSize - Size of the structure, in bytes.
//              dwCreationFlags - Process Creation flags used by CreateProcess 
//                                and CreateProcessAsUser functions.
//
//--------------------------------------------------------------------------
typedef struct _IELAUNCHURLINFO {
    DWORD cbSize;
    DWORD dwCreationFlags;
} IELAUNCHURLINFO, *LPIELAUNCHURLINFO;

//+-------------------------------------------------------------------------
//
//  Method:     IESaveFile
// 
//  Synopsis:   Saves the file to the location selected by the user in a 
//              previous call to IEShowSaveFileDialog
//
//--------------------------------------------------------------------------
STDAPI IESaveFile(                                   
    __in HANDLE    hState,                           
    __in LPCWSTR   lpwstrSourceFile                  
    );                          


//+-------------------------------------------------------------------------
//
//  Method:     IECancelSaveFile
// 
//  Synopsis:   Cancels the save operation and releases the resources 
//              allocated for the previous call to IEShowSaveFileDialog
//
//--------------------------------------------------------------------------
STDAPI IECancelSaveFile(
    __in HANDLE    hState
    );


//+-------------------------------------------------------------------------
//
//  Method:     IEShowSaveFileDialog
// 
//  Synopsis:   Shows the standard SaveFile dialog from a higher integrity 
//              user context
//
//  Remarks:    When no longer needed, call CoTaskMemFree to release
//              lppwstrDestinationFilePath 
//
//--------------------------------------------------------------------------
STDAPI IEShowSaveFileDialog(                         
    __in        HWND     hwnd,                       
    __in        LPCWSTR  lpwstrInitialFileName,      
    __in_opt    LPCWSTR  lpwstrInitialDir,           
    __in_opt    LPCWSTR  lpwstrFilter,               
    __in_opt    LPCWSTR  lpwstrDefExt,               
    __in        DWORD    dwFilterIndex,              
    __in        DWORD    dwFlags,                    
    __deref_out LPWSTR   *lppwstrDestinationFilePath,
    __out       HANDLE   *phState                    
    );                                               


//+-------------------------------------------------------------------------
//
//  Method:     IEGetWriteableLowHKCU
// 
//  Synopsis:   Returns a handle to a write accessible location under 
//              HKEY_CURRENT_USER for MIC Low process
//
//  Remarks:    When no longer needed, call RegCloseKey function to close 
//              the HKEY
//
//--------------------------------------------------------------------------
STDAPI IEGetWriteableLowHKCU(                           
    __out HKEY    *pHKey                             
    );                                               


//+-------------------------------------------------------------------------
//
//  Method:     IEGetWriteableFolderPath
// 
//  Synopsis:   Returns the current location of the specified folder. 
//              In protected mode, the path points to a location where 
//              the user has write permissions
//
//  Remarks:    When no longer needed, call CoTaskMemFree to release the
//              lppwstrPath
//
//--------------------------------------------------------------------------
STDAPI IEGetWriteableFolderPath(                     
    __in        REFGUID clsidFolderID,               
    __deref_out LPWSTR   *lppwstrPath                
    );                                               


//+-------------------------------------------------------------------------
//
//  Method:     IEIsProtectedModeProcess
// 
//  Synopsis:   Determines if Internet Explorer is running in protected mode
//
//--------------------------------------------------------------------------
STDAPI IEIsProtectedModeProcess(                     
    __out BOOL     *pbResult                         
    );                                               


//+-------------------------------------------------------------------------
//
//  Method:     IEIsProtectedModeURL
// 
//  Synopsis:   Determines if the URL runs in Protected Mode or not
//
//--------------------------------------------------------------------------
STDAPI IEIsProtectedModeURL(                     
    __in LPCWSTR lpwstrUrl
    );

//+-------------------------------------------------------------------------
//
//  Method:     IELaunchURL
// 
//  Synopsis:   Launches the appropriate IE to handle the navigation to 
//              the URL
//
//--------------------------------------------------------------------------
STDAPI IELaunchURL(                     
    __in        LPCWSTR lpwstrUrl,
    __inout     PROCESS_INFORMATION *lpProcInfo,
    __in_opt    VOID *lpInfo
    );

#endif //_IEPMAPI_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\ifmib.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*++

Copyright (c) Microsoft Corporation

Module Name:

    ifmib.h

Abstract:

    This module contains the public definitions and structures for the
    non-TCP/IP specific parts of MIB-II.  These definitions were previously
    in iprtrmib.h, which now includes this file.

--*/

#ifndef _IFMIB_
#define _IFMIB_
#pragma once

#include <ifdef.h>

#ifndef ANY_SIZE
#define ANY_SIZE 1
#endif

typedef struct _MIB_IFNUMBER
{
    DWORD    dwValue;
} MIB_IFNUMBER, *PMIB_IFNUMBER;


//
// $REVIEW: This has always been defined as 8.  However, this is not 
// sufficient for all media types.
//
#define MAXLEN_PHYSADDR 8

#define MAXLEN_IFDESCR 256

#define MAX_INTERFACE_NAME_LEN 256

typedef struct _MIB_IFROW {
    WCHAR wszName[MAX_INTERFACE_NAME_LEN];
    IF_INDEX dwIndex;
    IFTYPE dwType;
    DWORD dwMtu;
    DWORD dwSpeed;
    DWORD dwPhysAddrLen;
    UCHAR bPhysAddr[MAXLEN_PHYSADDR];
    DWORD dwAdminStatus;
    INTERNAL_IF_OPER_STATUS dwOperStatus;
    DWORD dwLastChange;
    DWORD dwInOctets;
    DWORD dwInUcastPkts;
    DWORD dwInNUcastPkts;
    DWORD dwInDiscards;
    DWORD dwInErrors;
    DWORD dwInUnknownProtos;
    DWORD dwOutOctets;
    DWORD dwOutUcastPkts;
    DWORD dwOutNUcastPkts;
    DWORD dwOutDiscards;
    DWORD dwOutErrors;
    DWORD dwOutQLen;
    DWORD dwDescrLen;
    UCHAR bDescr[MAXLEN_IFDESCR];
} MIB_IFROW, *PMIB_IFROW;

typedef struct _MIB_IFTABLE {
    DWORD dwNumEntries;
    MIB_IFROW table[ANY_SIZE];
} MIB_IFTABLE, *PMIB_IFTABLE;

#define SIZEOF_IFTABLE(X) (FIELD_OFFSET(MIB_IFTABLE,table[0]) + \
                           ((X) * sizeof(MIB_IFROW)) + ALIGN_SIZE)

#endif // _IFMIB_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\iextag.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES.
//

#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0286 */
/* at Mon Jan 22 12:14:07 2007
 */
/* Compiler settings for ..\iextag.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __iextag_h__
#define __iextag_h__

/* Forward Declarations */ 

#ifndef __IPeerFactory_FWD_DEFINED__
#define __IPeerFactory_FWD_DEFINED__
typedef interface IPeerFactory IPeerFactory;
#endif 	/* __IPeerFactory_FWD_DEFINED__ */


#ifndef __IHomePage_FWD_DEFINED__
#define __IHomePage_FWD_DEFINED__
typedef interface IHomePage IHomePage;
#endif 	/* __IHomePage_FWD_DEFINED__ */


#ifndef __IClientCaps_FWD_DEFINED__
#define __IClientCaps_FWD_DEFINED__
typedef interface IClientCaps IClientCaps;
#endif 	/* __IClientCaps_FWD_DEFINED__ */


#ifndef __IIntelliForms_FWD_DEFINED__
#define __IIntelliForms_FWD_DEFINED__
typedef interface IIntelliForms IIntelliForms;
#endif 	/* __IIntelliForms_FWD_DEFINED__ */


#ifndef __Iwfolders_FWD_DEFINED__
#define __Iwfolders_FWD_DEFINED__
typedef interface Iwfolders Iwfolders;
#endif 	/* __Iwfolders_FWD_DEFINED__ */


#ifndef __IAnchorClick_FWD_DEFINED__
#define __IAnchorClick_FWD_DEFINED__
typedef interface IAnchorClick IAnchorClick;
#endif 	/* __IAnchorClick_FWD_DEFINED__ */


#ifndef __HTMLPersistEvents_FWD_DEFINED__
#define __HTMLPersistEvents_FWD_DEFINED__
typedef interface HTMLPersistEvents HTMLPersistEvents;
#endif 	/* __HTMLPersistEvents_FWD_DEFINED__ */


#ifndef __IHTMLUserDataOM_FWD_DEFINED__
#define __IHTMLUserDataOM_FWD_DEFINED__
typedef interface IHTMLUserDataOM IHTMLUserDataOM;
#endif 	/* __IHTMLUserDataOM_FWD_DEFINED__ */


#ifndef __IHTMLPersistDataOM_FWD_DEFINED__
#define __IHTMLPersistDataOM_FWD_DEFINED__
typedef interface IHTMLPersistDataOM IHTMLPersistDataOM;
#endif 	/* __IHTMLPersistDataOM_FWD_DEFINED__ */


#ifndef __IHTMLPersistData_FWD_DEFINED__
#define __IHTMLPersistData_FWD_DEFINED__
typedef interface IHTMLPersistData IHTMLPersistData;
#endif 	/* __IHTMLPersistData_FWD_DEFINED__ */


#ifndef __IDownloadBehavior_FWD_DEFINED__
#define __IDownloadBehavior_FWD_DEFINED__
typedef interface IDownloadBehavior IDownloadBehavior;
#endif 	/* __IDownloadBehavior_FWD_DEFINED__ */


#ifndef __LayoutRectEvents_FWD_DEFINED__
#define __LayoutRectEvents_FWD_DEFINED__
typedef interface LayoutRectEvents LayoutRectEvents;
#endif 	/* __LayoutRectEvents_FWD_DEFINED__ */


#ifndef __ILayoutRect_FWD_DEFINED__
#define __ILayoutRect_FWD_DEFINED__
typedef interface ILayoutRect ILayoutRect;
#endif 	/* __ILayoutRect_FWD_DEFINED__ */


#ifndef __IDeviceRect_FWD_DEFINED__
#define __IDeviceRect_FWD_DEFINED__
typedef interface IDeviceRect IDeviceRect;
#endif 	/* __IDeviceRect_FWD_DEFINED__ */


#ifndef __ITemplatePrinter_FWD_DEFINED__
#define __ITemplatePrinter_FWD_DEFINED__
typedef interface ITemplatePrinter ITemplatePrinter;
#endif 	/* __ITemplatePrinter_FWD_DEFINED__ */


#ifndef __ITemplatePrinter2_FWD_DEFINED__
#define __ITemplatePrinter2_FWD_DEFINED__
typedef interface ITemplatePrinter2 ITemplatePrinter2;
#endif 	/* __ITemplatePrinter2_FWD_DEFINED__ */


#ifndef __IHeaderFooter_FWD_DEFINED__
#define __IHeaderFooter_FWD_DEFINED__
typedef interface IHeaderFooter IHeaderFooter;
#endif 	/* __IHeaderFooter_FWD_DEFINED__ */


#ifndef __PeerFactory_FWD_DEFINED__
#define __PeerFactory_FWD_DEFINED__

#ifdef __cplusplus
typedef class PeerFactory PeerFactory;
#else
typedef struct PeerFactory PeerFactory;
#endif /* __cplusplus */

#endif 	/* __PeerFactory_FWD_DEFINED__ */


#ifndef __ClientCaps_FWD_DEFINED__
#define __ClientCaps_FWD_DEFINED__

#ifdef __cplusplus
typedef class ClientCaps ClientCaps;
#else
typedef struct ClientCaps ClientCaps;
#endif /* __cplusplus */

#endif 	/* __ClientCaps_FWD_DEFINED__ */


#ifndef __IntelliForms_FWD_DEFINED__
#define __IntelliForms_FWD_DEFINED__

#ifdef __cplusplus
typedef class IntelliForms IntelliForms;
#else
typedef struct IntelliForms IntelliForms;
#endif /* __cplusplus */

#endif 	/* __IntelliForms_FWD_DEFINED__ */


#ifndef __HomePage_FWD_DEFINED__
#define __HomePage_FWD_DEFINED__

#ifdef __cplusplus
typedef class HomePage HomePage;
#else
typedef struct HomePage HomePage;
#endif /* __cplusplus */

#endif 	/* __HomePage_FWD_DEFINED__ */


#ifndef __CPersistUserData_FWD_DEFINED__
#define __CPersistUserData_FWD_DEFINED__

#ifdef __cplusplus
typedef class CPersistUserData CPersistUserData;
#else
typedef struct CPersistUserData CPersistUserData;
#endif /* __cplusplus */

#endif 	/* __CPersistUserData_FWD_DEFINED__ */


#ifndef __CPersistDataPeer_FWD_DEFINED__
#define __CPersistDataPeer_FWD_DEFINED__

#ifdef __cplusplus
typedef class CPersistDataPeer CPersistDataPeer;
#else
typedef struct CPersistDataPeer CPersistDataPeer;
#endif /* __cplusplus */

#endif 	/* __CPersistDataPeer_FWD_DEFINED__ */


#ifndef __CPersistShortcut_FWD_DEFINED__
#define __CPersistShortcut_FWD_DEFINED__

#ifdef __cplusplus
typedef class CPersistShortcut CPersistShortcut;
#else
typedef struct CPersistShortcut CPersistShortcut;
#endif /* __cplusplus */

#endif 	/* __CPersistShortcut_FWD_DEFINED__ */


#ifndef __CPersistHistory_FWD_DEFINED__
#define __CPersistHistory_FWD_DEFINED__

#ifdef __cplusplus
typedef class CPersistHistory CPersistHistory;
#else
typedef struct CPersistHistory CPersistHistory;
#endif /* __cplusplus */

#endif 	/* __CPersistHistory_FWD_DEFINED__ */


#ifndef __CPersistSnapshot_FWD_DEFINED__
#define __CPersistSnapshot_FWD_DEFINED__

#ifdef __cplusplus
typedef class CPersistSnapshot CPersistSnapshot;
#else
typedef struct CPersistSnapshot CPersistSnapshot;
#endif /* __cplusplus */

#endif 	/* __CPersistSnapshot_FWD_DEFINED__ */


#ifndef __CDownloadBehavior_FWD_DEFINED__
#define __CDownloadBehavior_FWD_DEFINED__

#ifdef __cplusplus
typedef class CDownloadBehavior CDownloadBehavior;
#else
typedef struct CDownloadBehavior CDownloadBehavior;
#endif /* __cplusplus */

#endif 	/* __CDownloadBehavior_FWD_DEFINED__ */


#ifndef __wfolders_FWD_DEFINED__
#define __wfolders_FWD_DEFINED__

#ifdef __cplusplus
typedef class wfolders wfolders;
#else
typedef struct wfolders wfolders;
#endif /* __cplusplus */

#endif 	/* __wfolders_FWD_DEFINED__ */


#ifndef __AnchorClick_FWD_DEFINED__
#define __AnchorClick_FWD_DEFINED__

#ifdef __cplusplus
typedef class AnchorClick AnchorClick;
#else
typedef struct AnchorClick AnchorClick;
#endif /* __cplusplus */

#endif 	/* __AnchorClick_FWD_DEFINED__ */


#ifndef __CLayoutRect_FWD_DEFINED__
#define __CLayoutRect_FWD_DEFINED__

#ifdef __cplusplus
typedef class CLayoutRect CLayoutRect;
#else
typedef struct CLayoutRect CLayoutRect;
#endif /* __cplusplus */

#endif 	/* __CLayoutRect_FWD_DEFINED__ */


#ifndef __CDeviceRect_FWD_DEFINED__
#define __CDeviceRect_FWD_DEFINED__

#ifdef __cplusplus
typedef class CDeviceRect CDeviceRect;
#else
typedef struct CDeviceRect CDeviceRect;
#endif /* __cplusplus */

#endif 	/* __CDeviceRect_FWD_DEFINED__ */


#ifndef __CTemplatePrinter_FWD_DEFINED__
#define __CTemplatePrinter_FWD_DEFINED__

#ifdef __cplusplus
typedef class CTemplatePrinter CTemplatePrinter;
#else
typedef struct CTemplatePrinter CTemplatePrinter;
#endif /* __cplusplus */

#endif 	/* __CTemplatePrinter_FWD_DEFINED__ */


#ifndef __CHeaderFooter_FWD_DEFINED__
#define __CHeaderFooter_FWD_DEFINED__

#ifdef __cplusplus
typedef class CHeaderFooter CHeaderFooter;
#else
typedef struct CHeaderFooter CHeaderFooter;
#endif /* __cplusplus */

#endif 	/* __CHeaderFooter_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __IPeerFactory_INTERFACE_DEFINED__
#define __IPeerFactory_INTERFACE_DEFINED__

/* interface IPeerFactory */
/* [object][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IPeerFactory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6663F9D3-B482-11d1-89C6-00C04FB6BFC4")
    IPeerFactory : public IUnknown
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IPeerFactoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IPeerFactory __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IPeerFactory __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IPeerFactory __RPC_FAR * This);
        
        END_INTERFACE
    } IPeerFactoryVtbl;

    interface IPeerFactory
    {
        CONST_VTBL struct IPeerFactoryVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPeerFactory_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPeerFactory_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPeerFactory_Release(This)	\
    (This)->lpVtbl -> Release(This)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPeerFactory_INTERFACE_DEFINED__ */


#ifndef __IHomePage_INTERFACE_DEFINED__
#define __IHomePage_INTERFACE_DEFINED__

/* interface IHomePage */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IHomePage;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("766BF2AF-D650-11d1-9811-00C04FC31D2E")
    IHomePage : public IDispatch
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE navigateHomePage( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE setHomePage( 
            /* [in] */ BSTR bstrURL) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE isHomePage( 
            /* [in] */ BSTR bstrURL,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *p) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHomePageVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IHomePage __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IHomePage __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IHomePage __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IHomePage __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IHomePage __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IHomePage __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IHomePage __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *navigateHomePage )( 
            IHomePage __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *setHomePage )( 
            IHomePage __RPC_FAR * This,
            /* [in] */ BSTR bstrURL);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *isHomePage )( 
            IHomePage __RPC_FAR * This,
            /* [in] */ BSTR bstrURL,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *p);
        
        END_INTERFACE
    } IHomePageVtbl;

    interface IHomePage
    {
        CONST_VTBL struct IHomePageVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHomePage_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHomePage_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHomePage_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHomePage_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IHomePage_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IHomePage_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IHomePage_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IHomePage_navigateHomePage(This)	\
    (This)->lpVtbl -> navigateHomePage(This)

#define IHomePage_setHomePage(This,bstrURL)	\
    (This)->lpVtbl -> setHomePage(This,bstrURL)

#define IHomePage_isHomePage(This,bstrURL,p)	\
    (This)->lpVtbl -> isHomePage(This,bstrURL,p)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id] */ HRESULT STDMETHODCALLTYPE IHomePage_navigateHomePage_Proxy( 
    IHomePage __RPC_FAR * This);


void __RPC_STUB IHomePage_navigateHomePage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IHomePage_setHomePage_Proxy( 
    IHomePage __RPC_FAR * This,
    /* [in] */ BSTR bstrURL);


void __RPC_STUB IHomePage_setHomePage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IHomePage_isHomePage_Proxy( 
    IHomePage __RPC_FAR * This,
    /* [in] */ BSTR bstrURL,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *p);


void __RPC_STUB IHomePage_isHomePage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHomePage_INTERFACE_DEFINED__ */


#ifndef __IClientCaps_INTERFACE_DEFINED__
#define __IClientCaps_INTERFACE_DEFINED__

/* interface IClientCaps */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IClientCaps;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7E8BC44D-AEFF-11D1-89C2-00C04FB6BFC4")
    IClientCaps : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_javaEnabled( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_cookieEnabled( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_cpuClass( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_systemLanguage( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_userLanguage( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_platform( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_connectionSpeed( 
            /* [out][retval] */ long __RPC_FAR *p) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_onLine( 
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_colorDepth( 
            /* [out][retval] */ long __RPC_FAR *p) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_bufferDepth( 
            /* [out][retval] */ long __RPC_FAR *p) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_width( 
            /* [out][retval] */ long __RPC_FAR *p) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_height( 
            /* [out][retval] */ long __RPC_FAR *p) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_availHeight( 
            /* [out][retval] */ long __RPC_FAR *p) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_availWidth( 
            /* [out][retval] */ long __RPC_FAR *p) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_connectionType( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE isComponentInstalled( 
            /* [in] */ BSTR bstrName,
            /* [in] */ BSTR bstrType,
            /* [in][defaultvalue] */ BSTR bStrVer,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *p) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE getComponentVersion( 
            /* [in] */ BSTR bstrName,
            /* [in] */ BSTR bstrType,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrVer) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE compareVersions( 
            /* [in] */ BSTR bstrVer1,
            /* [in] */ BSTR bstrVer2,
            /* [retval][out] */ long __RPC_FAR *p) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE addComponentRequest( 
            /* [in] */ BSTR bstrName,
            /* [in] */ BSTR bstrType,
            /* [in][defaultvalue] */ BSTR bstrVer = L"") = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE doComponentRequest( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *p) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE clearComponentRequest( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IClientCapsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IClientCaps __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IClientCaps __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IClientCaps __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IClientCaps __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IClientCaps __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IClientCaps __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IClientCaps __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_javaEnabled )( 
            IClientCaps __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_cookieEnabled )( 
            IClientCaps __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_cpuClass )( 
            IClientCaps __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_systemLanguage )( 
            IClientCaps __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_userLanguage )( 
            IClientCaps __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_platform )( 
            IClientCaps __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_connectionSpeed )( 
            IClientCaps __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_onLine )( 
            IClientCaps __RPC_FAR * This,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_colorDepth )( 
            IClientCaps __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_bufferDepth )( 
            IClientCaps __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_width )( 
            IClientCaps __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_height )( 
            IClientCaps __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_availHeight )( 
            IClientCaps __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_availWidth )( 
            IClientCaps __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_connectionType )( 
            IClientCaps __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *isComponentInstalled )( 
            IClientCaps __RPC_FAR * This,
            /* [in] */ BSTR bstrName,
            /* [in] */ BSTR bstrType,
            /* [in][defaultvalue] */ BSTR bStrVer,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *p);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getComponentVersion )( 
            IClientCaps __RPC_FAR * This,
            /* [in] */ BSTR bstrName,
            /* [in] */ BSTR bstrType,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrVer);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *compareVersions )( 
            IClientCaps __RPC_FAR * This,
            /* [in] */ BSTR bstrVer1,
            /* [in] */ BSTR bstrVer2,
            /* [retval][out] */ long __RPC_FAR *p);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *addComponentRequest )( 
            IClientCaps __RPC_FAR * This,
            /* [in] */ BSTR bstrName,
            /* [in] */ BSTR bstrType,
            /* [in][defaultvalue] */ BSTR bstrVer);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *doComponentRequest )( 
            IClientCaps __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *p);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *clearComponentRequest )( 
            IClientCaps __RPC_FAR * This);
        
        END_INTERFACE
    } IClientCapsVtbl;

    interface IClientCaps
    {
        CONST_VTBL struct IClientCapsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IClientCaps_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IClientCaps_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IClientCaps_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IClientCaps_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IClientCaps_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IClientCaps_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IClientCaps_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IClientCaps_get_javaEnabled(This,pVal)	\
    (This)->lpVtbl -> get_javaEnabled(This,pVal)

#define IClientCaps_get_cookieEnabled(This,pVal)	\
    (This)->lpVtbl -> get_cookieEnabled(This,pVal)

#define IClientCaps_get_cpuClass(This,p)	\
    (This)->lpVtbl -> get_cpuClass(This,p)

#define IClientCaps_get_systemLanguage(This,p)	\
    (This)->lpVtbl -> get_systemLanguage(This,p)

#define IClientCaps_get_userLanguage(This,p)	\
    (This)->lpVtbl -> get_userLanguage(This,p)

#define IClientCaps_get_platform(This,p)	\
    (This)->lpVtbl -> get_platform(This,p)

#define IClientCaps_get_connectionSpeed(This,p)	\
    (This)->lpVtbl -> get_connectionSpeed(This,p)

#define IClientCaps_get_onLine(This,p)	\
    (This)->lpVtbl -> get_onLine(This,p)

#define IClientCaps_get_colorDepth(This,p)	\
    (This)->lpVtbl -> get_colorDepth(This,p)

#define IClientCaps_get_bufferDepth(This,p)	\
    (This)->lpVtbl -> get_bufferDepth(This,p)

#define IClientCaps_get_width(This,p)	\
    (This)->lpVtbl -> get_width(This,p)

#define IClientCaps_get_height(This,p)	\
    (This)->lpVtbl -> get_height(This,p)

#define IClientCaps_get_availHeight(This,p)	\
    (This)->lpVtbl -> get_availHeight(This,p)

#define IClientCaps_get_availWidth(This,p)	\
    (This)->lpVtbl -> get_availWidth(This,p)

#define IClientCaps_get_connectionType(This,p)	\
    (This)->lpVtbl -> get_connectionType(This,p)

#define IClientCaps_isComponentInstalled(This,bstrName,bstrType,bStrVer,p)	\
    (This)->lpVtbl -> isComponentInstalled(This,bstrName,bstrType,bStrVer,p)

#define IClientCaps_getComponentVersion(This,bstrName,bstrType,pbstrVer)	\
    (This)->lpVtbl -> getComponentVersion(This,bstrName,bstrType,pbstrVer)

#define IClientCaps_compareVersions(This,bstrVer1,bstrVer2,p)	\
    (This)->lpVtbl -> compareVersions(This,bstrVer1,bstrVer2,p)

#define IClientCaps_addComponentRequest(This,bstrName,bstrType,bstrVer)	\
    (This)->lpVtbl -> addComponentRequest(This,bstrName,bstrType,bstrVer)

#define IClientCaps_doComponentRequest(This,p)	\
    (This)->lpVtbl -> doComponentRequest(This,p)

#define IClientCaps_clearComponentRequest(This)	\
    (This)->lpVtbl -> clearComponentRequest(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IClientCaps_get_javaEnabled_Proxy( 
    IClientCaps __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);


void __RPC_STUB IClientCaps_get_javaEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IClientCaps_get_cookieEnabled_Proxy( 
    IClientCaps __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);


void __RPC_STUB IClientCaps_get_cookieEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IClientCaps_get_cpuClass_Proxy( 
    IClientCaps __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IClientCaps_get_cpuClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IClientCaps_get_systemLanguage_Proxy( 
    IClientCaps __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IClientCaps_get_systemLanguage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IClientCaps_get_userLanguage_Proxy( 
    IClientCaps __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IClientCaps_get_userLanguage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IClientCaps_get_platform_Proxy( 
    IClientCaps __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IClientCaps_get_platform_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IClientCaps_get_connectionSpeed_Proxy( 
    IClientCaps __RPC_FAR * This,
    /* [out][retval] */ long __RPC_FAR *p);


void __RPC_STUB IClientCaps_get_connectionSpeed_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IClientCaps_get_onLine_Proxy( 
    IClientCaps __RPC_FAR * This,
    /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);


void __RPC_STUB IClientCaps_get_onLine_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IClientCaps_get_colorDepth_Proxy( 
    IClientCaps __RPC_FAR * This,
    /* [out][retval] */ long __RPC_FAR *p);


void __RPC_STUB IClientCaps_get_colorDepth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IClientCaps_get_bufferDepth_Proxy( 
    IClientCaps __RPC_FAR * This,
    /* [out][retval] */ long __RPC_FAR *p);


void __RPC_STUB IClientCaps_get_bufferDepth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IClientCaps_get_width_Proxy( 
    IClientCaps __RPC_FAR * This,
    /* [out][retval] */ long __RPC_FAR *p);


void __RPC_STUB IClientCaps_get_width_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IClientCaps_get_height_Proxy( 
    IClientCaps __RPC_FAR * This,
    /* [out][retval] */ long __RPC_FAR *p);


void __RPC_STUB IClientCaps_get_height_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IClientCaps_get_availHeight_Proxy( 
    IClientCaps __RPC_FAR * This,
    /* [out][retval] */ long __RPC_FAR *p);


void __RPC_STUB IClientCaps_get_availHeight_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IClientCaps_get_availWidth_Proxy( 
    IClientCaps __RPC_FAR * This,
    /* [out][retval] */ long __RPC_FAR *p);


void __RPC_STUB IClientCaps_get_availWidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IClientCaps_get_connectionType_Proxy( 
    IClientCaps __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IClientCaps_get_connectionType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IClientCaps_isComponentInstalled_Proxy( 
    IClientCaps __RPC_FAR * This,
    /* [in] */ BSTR bstrName,
    /* [in] */ BSTR bstrType,
    /* [in][defaultvalue] */ BSTR bStrVer,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *p);


void __RPC_STUB IClientCaps_isComponentInstalled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IClientCaps_getComponentVersion_Proxy( 
    IClientCaps __RPC_FAR * This,
    /* [in] */ BSTR bstrName,
    /* [in] */ BSTR bstrType,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrVer);


void __RPC_STUB IClientCaps_getComponentVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IClientCaps_compareVersions_Proxy( 
    IClientCaps __RPC_FAR * This,
    /* [in] */ BSTR bstrVer1,
    /* [in] */ BSTR bstrVer2,
    /* [retval][out] */ long __RPC_FAR *p);


void __RPC_STUB IClientCaps_compareVersions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IClientCaps_addComponentRequest_Proxy( 
    IClientCaps __RPC_FAR * This,
    /* [in] */ BSTR bstrName,
    /* [in] */ BSTR bstrType,
    /* [in][defaultvalue] */ BSTR bstrVer);


void __RPC_STUB IClientCaps_addComponentRequest_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IClientCaps_doComponentRequest_Proxy( 
    IClientCaps __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *p);


void __RPC_STUB IClientCaps_doComponentRequest_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IClientCaps_clearComponentRequest_Proxy( 
    IClientCaps __RPC_FAR * This);


void __RPC_STUB IClientCaps_clearComponentRequest_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IClientCaps_INTERFACE_DEFINED__ */


#ifndef __IIntelliForms_INTERFACE_DEFINED__
#define __IIntelliForms_INTERFACE_DEFINED__

/* interface IIntelliForms */
/* [unique][dual][uuid][object] */ 


EXTERN_C const IID IID_IIntelliForms;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9B9F68E6-1AAA-11d2-BCA5-00C04FD929DB")
    IIntelliForms : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_enabled( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_enabled( 
            /* [in] */ VARIANT_BOOL bVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IIntelliFormsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IIntelliForms __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IIntelliForms __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IIntelliForms __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IIntelliForms __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IIntelliForms __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IIntelliForms __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IIntelliForms __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_enabled )( 
            IIntelliForms __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_enabled )( 
            IIntelliForms __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL bVal);
        
        END_INTERFACE
    } IIntelliFormsVtbl;

    interface IIntelliForms
    {
        CONST_VTBL struct IIntelliFormsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IIntelliForms_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IIntelliForms_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IIntelliForms_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IIntelliForms_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IIntelliForms_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IIntelliForms_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IIntelliForms_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IIntelliForms_get_enabled(This,pVal)	\
    (This)->lpVtbl -> get_enabled(This,pVal)

#define IIntelliForms_put_enabled(This,bVal)	\
    (This)->lpVtbl -> put_enabled(This,bVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IIntelliForms_get_enabled_Proxy( 
    IIntelliForms __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);


void __RPC_STUB IIntelliForms_get_enabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IIntelliForms_put_enabled_Proxy( 
    IIntelliForms __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL bVal);


void __RPC_STUB IIntelliForms_put_enabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IIntelliForms_INTERFACE_DEFINED__ */


#ifndef __Iwfolders_INTERFACE_DEFINED__
#define __Iwfolders_INTERFACE_DEFINED__

/* interface Iwfolders */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_Iwfolders;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("BAE31F98-1B81-11D2-A97A-00C04F8ECB02")
    Iwfolders : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE navigate( 
            /* [in] */ BSTR bstrUrl,
            /* [out][retval] */ BSTR __RPC_FAR *pbstrRetVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE navigateFrame( 
            /* [in] */ BSTR bstrUrl,
            /* [in] */ BSTR bstrTargetFrame,
            /* [out][retval] */ BSTR __RPC_FAR *pbstrRetVal) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE navigateNoSite( 
            /* [in] */ BSTR bstrUrl,
            /* [in] */ BSTR bstrTargetFrame,
            /* [in] */ DWORD dwhwnd,
            /* [in] */ IUnknown __RPC_FAR *pwb) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IwfoldersVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            Iwfolders __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            Iwfolders __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            Iwfolders __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            Iwfolders __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            Iwfolders __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            Iwfolders __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            Iwfolders __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *navigate )( 
            Iwfolders __RPC_FAR * This,
            /* [in] */ BSTR bstrUrl,
            /* [out][retval] */ BSTR __RPC_FAR *pbstrRetVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *navigateFrame )( 
            Iwfolders __RPC_FAR * This,
            /* [in] */ BSTR bstrUrl,
            /* [in] */ BSTR bstrTargetFrame,
            /* [out][retval] */ BSTR __RPC_FAR *pbstrRetVal);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *navigateNoSite )( 
            Iwfolders __RPC_FAR * This,
            /* [in] */ BSTR bstrUrl,
            /* [in] */ BSTR bstrTargetFrame,
            /* [in] */ DWORD dwhwnd,
            /* [in] */ IUnknown __RPC_FAR *pwb);
        
        END_INTERFACE
    } IwfoldersVtbl;

    interface Iwfolders
    {
        CONST_VTBL struct IwfoldersVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define Iwfolders_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define Iwfolders_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define Iwfolders_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define Iwfolders_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define Iwfolders_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define Iwfolders_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define Iwfolders_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define Iwfolders_navigate(This,bstrUrl,pbstrRetVal)	\
    (This)->lpVtbl -> navigate(This,bstrUrl,pbstrRetVal)

#define Iwfolders_navigateFrame(This,bstrUrl,bstrTargetFrame,pbstrRetVal)	\
    (This)->lpVtbl -> navigateFrame(This,bstrUrl,bstrTargetFrame,pbstrRetVal)

#define Iwfolders_navigateNoSite(This,bstrUrl,bstrTargetFrame,dwhwnd,pwb)	\
    (This)->lpVtbl -> navigateNoSite(This,bstrUrl,bstrTargetFrame,dwhwnd,pwb)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Iwfolders_navigate_Proxy( 
    Iwfolders __RPC_FAR * This,
    /* [in] */ BSTR bstrUrl,
    /* [out][retval] */ BSTR __RPC_FAR *pbstrRetVal);


void __RPC_STUB Iwfolders_navigate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Iwfolders_navigateFrame_Proxy( 
    Iwfolders __RPC_FAR * This,
    /* [in] */ BSTR bstrUrl,
    /* [in] */ BSTR bstrTargetFrame,
    /* [out][retval] */ BSTR __RPC_FAR *pbstrRetVal);


void __RPC_STUB Iwfolders_navigateFrame_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE Iwfolders_navigateNoSite_Proxy( 
    Iwfolders __RPC_FAR * This,
    /* [in] */ BSTR bstrUrl,
    /* [in] */ BSTR bstrTargetFrame,
    /* [in] */ DWORD dwhwnd,
    /* [in] */ IUnknown __RPC_FAR *pwb);


void __RPC_STUB Iwfolders_navigateNoSite_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __Iwfolders_INTERFACE_DEFINED__ */


#ifndef __IAnchorClick_INTERFACE_DEFINED__
#define __IAnchorClick_INTERFACE_DEFINED__

/* interface IAnchorClick */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IAnchorClick;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("13D5413B-33B9-11D2-95A7-00C04F8ECB02")
    IAnchorClick : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ProcOnClick( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAnchorClickVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IAnchorClick __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IAnchorClick __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IAnchorClick __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IAnchorClick __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IAnchorClick __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IAnchorClick __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IAnchorClick __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ProcOnClick )( 
            IAnchorClick __RPC_FAR * This);
        
        END_INTERFACE
    } IAnchorClickVtbl;

    interface IAnchorClick
    {
        CONST_VTBL struct IAnchorClickVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAnchorClick_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAnchorClick_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAnchorClick_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAnchorClick_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IAnchorClick_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IAnchorClick_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IAnchorClick_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IAnchorClick_ProcOnClick(This)	\
    (This)->lpVtbl -> ProcOnClick(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IAnchorClick_ProcOnClick_Proxy( 
    IAnchorClick __RPC_FAR * This);


void __RPC_STUB IAnchorClick_ProcOnClick_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAnchorClick_INTERFACE_DEFINED__ */


#ifndef __IHTMLUserDataOM_INTERFACE_DEFINED__
#define __IHTMLUserDataOM_INTERFACE_DEFINED__

/* interface IHTMLUserDataOM */
/* [object][uuid][dual][oleautomation] */ 


EXTERN_C const IID IID_IHTMLUserDataOM;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f48f-98b5-11cf-bb82-00aa00bdce0b")
    IHTMLUserDataOM : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_XMLDocument( 
            /* [out][retval] */ IDispatch __RPC_FAR *__RPC_FAR *p) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE save( 
            /* [in] */ BSTR strName) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE load( 
            /* [in] */ BSTR strName) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE getAttribute( 
            /* [in] */ BSTR name,
            /* [out][retval] */ VARIANT __RPC_FAR *pValue) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE setAttribute( 
            /* [in] */ BSTR name,
            /* [in] */ VARIANT value) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE removeAttribute( 
            /* [in] */ BSTR name) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_expires( 
            /* [in] */ BSTR bstr) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_expires( 
            /* [out][retval] */ BSTR __RPC_FAR *pbstr) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHTMLUserDataOMVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IHTMLUserDataOM __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IHTMLUserDataOM __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IHTMLUserDataOM __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IHTMLUserDataOM __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IHTMLUserDataOM __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IHTMLUserDataOM __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IHTMLUserDataOM __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_XMLDocument )( 
            IHTMLUserDataOM __RPC_FAR * This,
            /* [out][retval] */ IDispatch __RPC_FAR *__RPC_FAR *p);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *save )( 
            IHTMLUserDataOM __RPC_FAR * This,
            /* [in] */ BSTR strName);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *load )( 
            IHTMLUserDataOM __RPC_FAR * This,
            /* [in] */ BSTR strName);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getAttribute )( 
            IHTMLUserDataOM __RPC_FAR * This,
            /* [in] */ BSTR name,
            /* [out][retval] */ VARIANT __RPC_FAR *pValue);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *setAttribute )( 
            IHTMLUserDataOM __RPC_FAR * This,
            /* [in] */ BSTR name,
            /* [in] */ VARIANT value);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *removeAttribute )( 
            IHTMLUserDataOM __RPC_FAR * This,
            /* [in] */ BSTR name);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_expires )( 
            IHTMLUserDataOM __RPC_FAR * This,
            /* [in] */ BSTR bstr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_expires )( 
            IHTMLUserDataOM __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *pbstr);
        
        END_INTERFACE
    } IHTMLUserDataOMVtbl;

    interface IHTMLUserDataOM
    {
        CONST_VTBL struct IHTMLUserDataOMVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHTMLUserDataOM_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHTMLUserDataOM_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHTMLUserDataOM_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHTMLUserDataOM_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IHTMLUserDataOM_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IHTMLUserDataOM_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IHTMLUserDataOM_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IHTMLUserDataOM_get_XMLDocument(This,p)	\
    (This)->lpVtbl -> get_XMLDocument(This,p)

#define IHTMLUserDataOM_save(This,strName)	\
    (This)->lpVtbl -> save(This,strName)

#define IHTMLUserDataOM_load(This,strName)	\
    (This)->lpVtbl -> load(This,strName)

#define IHTMLUserDataOM_getAttribute(This,name,pValue)	\
    (This)->lpVtbl -> getAttribute(This,name,pValue)

#define IHTMLUserDataOM_setAttribute(This,name,value)	\
    (This)->lpVtbl -> setAttribute(This,name,value)

#define IHTMLUserDataOM_removeAttribute(This,name)	\
    (This)->lpVtbl -> removeAttribute(This,name)

#define IHTMLUserDataOM_put_expires(This,bstr)	\
    (This)->lpVtbl -> put_expires(This,bstr)

#define IHTMLUserDataOM_get_expires(This,pbstr)	\
    (This)->lpVtbl -> get_expires(This,pbstr)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IHTMLUserDataOM_get_XMLDocument_Proxy( 
    IHTMLUserDataOM __RPC_FAR * This,
    /* [out][retval] */ IDispatch __RPC_FAR *__RPC_FAR *p);


void __RPC_STUB IHTMLUserDataOM_get_XMLDocument_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IHTMLUserDataOM_save_Proxy( 
    IHTMLUserDataOM __RPC_FAR * This,
    /* [in] */ BSTR strName);


void __RPC_STUB IHTMLUserDataOM_save_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IHTMLUserDataOM_load_Proxy( 
    IHTMLUserDataOM __RPC_FAR * This,
    /* [in] */ BSTR strName);


void __RPC_STUB IHTMLUserDataOM_load_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IHTMLUserDataOM_getAttribute_Proxy( 
    IHTMLUserDataOM __RPC_FAR * This,
    /* [in] */ BSTR name,
    /* [out][retval] */ VARIANT __RPC_FAR *pValue);


void __RPC_STUB IHTMLUserDataOM_getAttribute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IHTMLUserDataOM_setAttribute_Proxy( 
    IHTMLUserDataOM __RPC_FAR * This,
    /* [in] */ BSTR name,
    /* [in] */ VARIANT value);


void __RPC_STUB IHTMLUserDataOM_setAttribute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IHTMLUserDataOM_removeAttribute_Proxy( 
    IHTMLUserDataOM __RPC_FAR * This,
    /* [in] */ BSTR name);


void __RPC_STUB IHTMLUserDataOM_removeAttribute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IHTMLUserDataOM_put_expires_Proxy( 
    IHTMLUserDataOM __RPC_FAR * This,
    /* [in] */ BSTR bstr);


void __RPC_STUB IHTMLUserDataOM_put_expires_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IHTMLUserDataOM_get_expires_Proxy( 
    IHTMLUserDataOM __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *pbstr);


void __RPC_STUB IHTMLUserDataOM_get_expires_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHTMLUserDataOM_INTERFACE_DEFINED__ */


#ifndef __IHTMLPersistDataOM_INTERFACE_DEFINED__
#define __IHTMLPersistDataOM_INTERFACE_DEFINED__

/* interface IHTMLPersistDataOM */
/* [object][uuid][dual][oleautomation] */ 


EXTERN_C const IID IID_IHTMLPersistDataOM;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f4c0-98b5-11cf-bb82-00aa00bdce0b")
    IHTMLPersistDataOM : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_XMLDocument( 
            /* [out][retval] */ IDispatch __RPC_FAR *__RPC_FAR *p) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE getAttribute( 
            /* [in] */ BSTR name,
            /* [out][retval] */ VARIANT __RPC_FAR *pValue) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE setAttribute( 
            /* [in] */ BSTR name,
            /* [in] */ VARIANT value) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE removeAttribute( 
            /* [in] */ BSTR name) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHTMLPersistDataOMVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IHTMLPersistDataOM __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IHTMLPersistDataOM __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IHTMLPersistDataOM __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IHTMLPersistDataOM __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IHTMLPersistDataOM __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IHTMLPersistDataOM __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IHTMLPersistDataOM __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_XMLDocument )( 
            IHTMLPersistDataOM __RPC_FAR * This,
            /* [out][retval] */ IDispatch __RPC_FAR *__RPC_FAR *p);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getAttribute )( 
            IHTMLPersistDataOM __RPC_FAR * This,
            /* [in] */ BSTR name,
            /* [out][retval] */ VARIANT __RPC_FAR *pValue);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *setAttribute )( 
            IHTMLPersistDataOM __RPC_FAR * This,
            /* [in] */ BSTR name,
            /* [in] */ VARIANT value);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *removeAttribute )( 
            IHTMLPersistDataOM __RPC_FAR * This,
            /* [in] */ BSTR name);
        
        END_INTERFACE
    } IHTMLPersistDataOMVtbl;

    interface IHTMLPersistDataOM
    {
        CONST_VTBL struct IHTMLPersistDataOMVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHTMLPersistDataOM_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHTMLPersistDataOM_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHTMLPersistDataOM_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHTMLPersistDataOM_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IHTMLPersistDataOM_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IHTMLPersistDataOM_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IHTMLPersistDataOM_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IHTMLPersistDataOM_get_XMLDocument(This,p)	\
    (This)->lpVtbl -> get_XMLDocument(This,p)

#define IHTMLPersistDataOM_getAttribute(This,name,pValue)	\
    (This)->lpVtbl -> getAttribute(This,name,pValue)

#define IHTMLPersistDataOM_setAttribute(This,name,value)	\
    (This)->lpVtbl -> setAttribute(This,name,value)

#define IHTMLPersistDataOM_removeAttribute(This,name)	\
    (This)->lpVtbl -> removeAttribute(This,name)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IHTMLPersistDataOM_get_XMLDocument_Proxy( 
    IHTMLPersistDataOM __RPC_FAR * This,
    /* [out][retval] */ IDispatch __RPC_FAR *__RPC_FAR *p);


void __RPC_STUB IHTMLPersistDataOM_get_XMLDocument_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IHTMLPersistDataOM_getAttribute_Proxy( 
    IHTMLPersistDataOM __RPC_FAR * This,
    /* [in] */ BSTR name,
    /* [out][retval] */ VARIANT __RPC_FAR *pValue);


void __RPC_STUB IHTMLPersistDataOM_getAttribute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IHTMLPersistDataOM_setAttribute_Proxy( 
    IHTMLPersistDataOM __RPC_FAR * This,
    /* [in] */ BSTR name,
    /* [in] */ VARIANT value);


void __RPC_STUB IHTMLPersistDataOM_setAttribute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IHTMLPersistDataOM_removeAttribute_Proxy( 
    IHTMLPersistDataOM __RPC_FAR * This,
    /* [in] */ BSTR name);


void __RPC_STUB IHTMLPersistDataOM_removeAttribute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHTMLPersistDataOM_INTERFACE_DEFINED__ */


#ifndef __IHTMLPersistData_INTERFACE_DEFINED__
#define __IHTMLPersistData_INTERFACE_DEFINED__

/* interface IHTMLPersistData */
/* [object][uuid][dual][oleautomation] */ 


EXTERN_C const IID IID_IHTMLPersistData;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f4c5-98b5-11cf-bb82-00aa00bdce0b")
    IHTMLPersistData : public IUnknown
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE save( 
            /* [in] */ IUnknown __RPC_FAR *pUnk,
            /* [in] */ long lType,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *fContinueBroacast) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE load( 
            /* [in] */ IUnknown __RPC_FAR *pUnk,
            /* [in] */ long lType,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *fDoDefault) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE queryType( 
            /* [in] */ long lType,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *pfSupportsType) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHTMLPersistDataVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IHTMLPersistData __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IHTMLPersistData __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IHTMLPersistData __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *save )( 
            IHTMLPersistData __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *pUnk,
            /* [in] */ long lType,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *fContinueBroacast);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *load )( 
            IHTMLPersistData __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *pUnk,
            /* [in] */ long lType,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *fDoDefault);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *queryType )( 
            IHTMLPersistData __RPC_FAR * This,
            /* [in] */ long lType,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *pfSupportsType);
        
        END_INTERFACE
    } IHTMLPersistDataVtbl;

    interface IHTMLPersistData
    {
        CONST_VTBL struct IHTMLPersistDataVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHTMLPersistData_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHTMLPersistData_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHTMLPersistData_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHTMLPersistData_save(This,pUnk,lType,fContinueBroacast)	\
    (This)->lpVtbl -> save(This,pUnk,lType,fContinueBroacast)

#define IHTMLPersistData_load(This,pUnk,lType,fDoDefault)	\
    (This)->lpVtbl -> load(This,pUnk,lType,fDoDefault)

#define IHTMLPersistData_queryType(This,lType,pfSupportsType)	\
    (This)->lpVtbl -> queryType(This,lType,pfSupportsType)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id] */ HRESULT STDMETHODCALLTYPE IHTMLPersistData_save_Proxy( 
    IHTMLPersistData __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *pUnk,
    /* [in] */ long lType,
    /* [out][retval] */ VARIANT_BOOL __RPC_FAR *fContinueBroacast);


void __RPC_STUB IHTMLPersistData_save_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IHTMLPersistData_load_Proxy( 
    IHTMLPersistData __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *pUnk,
    /* [in] */ long lType,
    /* [out][retval] */ VARIANT_BOOL __RPC_FAR *fDoDefault);


void __RPC_STUB IHTMLPersistData_load_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IHTMLPersistData_queryType_Proxy( 
    IHTMLPersistData __RPC_FAR * This,
    /* [in] */ long lType,
    /* [out][retval] */ VARIANT_BOOL __RPC_FAR *pfSupportsType);


void __RPC_STUB IHTMLPersistData_queryType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHTMLPersistData_INTERFACE_DEFINED__ */


#ifndef __IDownloadBehavior_INTERFACE_DEFINED__
#define __IDownloadBehavior_INTERFACE_DEFINED__

/* interface IDownloadBehavior */
/* [object][uuid][dual][oleautomation] */ 


EXTERN_C const IID IID_IDownloadBehavior;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f5bd-98b5-11cf-bb82-00aa00bdce0b")
    IDownloadBehavior : public IDispatch
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE startDownload( 
            /* [in] */ BSTR bstrUrl,
            /* [in] */ IDispatch __RPC_FAR *pdispCallback) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDownloadBehaviorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDownloadBehavior __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDownloadBehavior __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDownloadBehavior __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDownloadBehavior __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDownloadBehavior __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDownloadBehavior __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDownloadBehavior __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *startDownload )( 
            IDownloadBehavior __RPC_FAR * This,
            /* [in] */ BSTR bstrUrl,
            /* [in] */ IDispatch __RPC_FAR *pdispCallback);
        
        END_INTERFACE
    } IDownloadBehaviorVtbl;

    interface IDownloadBehavior
    {
        CONST_VTBL struct IDownloadBehaviorVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDownloadBehavior_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDownloadBehavior_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDownloadBehavior_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDownloadBehavior_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDownloadBehavior_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDownloadBehavior_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDownloadBehavior_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDownloadBehavior_startDownload(This,bstrUrl,pdispCallback)	\
    (This)->lpVtbl -> startDownload(This,bstrUrl,pdispCallback)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id] */ HRESULT STDMETHODCALLTYPE IDownloadBehavior_startDownload_Proxy( 
    IDownloadBehavior __RPC_FAR * This,
    /* [in] */ BSTR bstrUrl,
    /* [in] */ IDispatch __RPC_FAR *pdispCallback);


void __RPC_STUB IDownloadBehavior_startDownload_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDownloadBehavior_INTERFACE_DEFINED__ */


#ifndef __ILayoutRect_INTERFACE_DEFINED__
#define __ILayoutRect_INTERFACE_DEFINED__

/* interface ILayoutRect */
/* [object][uuid][dual][oleautomation] */ 


EXTERN_C const IID IID_ILayoutRect;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f665-98b5-11cf-bb82-00aa00bdce0b")
    ILayoutRect : public IDispatch
    {
    public:
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_nextRect( 
            /* [in] */ BSTR bstrElementId) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_nextRect( 
            /* [out][retval] */ BSTR __RPC_FAR *pbstrElementId) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_contentSrc( 
            /* [in] */ VARIANT varContentSrc) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_contentSrc( 
            /* [out][retval] */ VARIANT __RPC_FAR *pvarContentSrc) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_honorPageBreaks( 
            /* [in] */ VARIANT_BOOL v) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_honorPageBreaks( 
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_honorPageRules( 
            /* [in] */ VARIANT_BOOL v) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_honorPageRules( 
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_nextRectElement( 
            /* [in] */ IDispatch __RPC_FAR *pElem) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_nextRectElement( 
            /* [out][retval] */ IDispatch __RPC_FAR *__RPC_FAR *ppElem) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_contentDocument( 
            /* [out][retval] */ IDispatch __RPC_FAR *__RPC_FAR *pDoc) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ILayoutRectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ILayoutRect __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ILayoutRect __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ILayoutRect __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ILayoutRect __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ILayoutRect __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ILayoutRect __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ILayoutRect __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_nextRect )( 
            ILayoutRect __RPC_FAR * This,
            /* [in] */ BSTR bstrElementId);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nextRect )( 
            ILayoutRect __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *pbstrElementId);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_contentSrc )( 
            ILayoutRect __RPC_FAR * This,
            /* [in] */ VARIANT varContentSrc);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_contentSrc )( 
            ILayoutRect __RPC_FAR * This,
            /* [out][retval] */ VARIANT __RPC_FAR *pvarContentSrc);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_honorPageBreaks )( 
            ILayoutRect __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_honorPageBreaks )( 
            ILayoutRect __RPC_FAR * This,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_honorPageRules )( 
            ILayoutRect __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_honorPageRules )( 
            ILayoutRect __RPC_FAR * This,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_nextRectElement )( 
            ILayoutRect __RPC_FAR * This,
            /* [in] */ IDispatch __RPC_FAR *pElem);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nextRectElement )( 
            ILayoutRect __RPC_FAR * This,
            /* [out][retval] */ IDispatch __RPC_FAR *__RPC_FAR *ppElem);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_contentDocument )( 
            ILayoutRect __RPC_FAR * This,
            /* [out][retval] */ IDispatch __RPC_FAR *__RPC_FAR *pDoc);
        
        END_INTERFACE
    } ILayoutRectVtbl;

    interface ILayoutRect
    {
        CONST_VTBL struct ILayoutRectVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ILayoutRect_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ILayoutRect_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ILayoutRect_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ILayoutRect_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ILayoutRect_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ILayoutRect_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ILayoutRect_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ILayoutRect_put_nextRect(This,bstrElementId)	\
    (This)->lpVtbl -> put_nextRect(This,bstrElementId)

#define ILayoutRect_get_nextRect(This,pbstrElementId)	\
    (This)->lpVtbl -> get_nextRect(This,pbstrElementId)

#define ILayoutRect_put_contentSrc(This,varContentSrc)	\
    (This)->lpVtbl -> put_contentSrc(This,varContentSrc)

#define ILayoutRect_get_contentSrc(This,pvarContentSrc)	\
    (This)->lpVtbl -> get_contentSrc(This,pvarContentSrc)

#define ILayoutRect_put_honorPageBreaks(This,v)	\
    (This)->lpVtbl -> put_honorPageBreaks(This,v)

#define ILayoutRect_get_honorPageBreaks(This,p)	\
    (This)->lpVtbl -> get_honorPageBreaks(This,p)

#define ILayoutRect_put_honorPageRules(This,v)	\
    (This)->lpVtbl -> put_honorPageRules(This,v)

#define ILayoutRect_get_honorPageRules(This,p)	\
    (This)->lpVtbl -> get_honorPageRules(This,p)

#define ILayoutRect_put_nextRectElement(This,pElem)	\
    (This)->lpVtbl -> put_nextRectElement(This,pElem)

#define ILayoutRect_get_nextRectElement(This,ppElem)	\
    (This)->lpVtbl -> get_nextRectElement(This,ppElem)

#define ILayoutRect_get_contentDocument(This,pDoc)	\
    (This)->lpVtbl -> get_contentDocument(This,pDoc)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propput] */ HRESULT STDMETHODCALLTYPE ILayoutRect_put_nextRect_Proxy( 
    ILayoutRect __RPC_FAR * This,
    /* [in] */ BSTR bstrElementId);


void __RPC_STUB ILayoutRect_put_nextRect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ILayoutRect_get_nextRect_Proxy( 
    ILayoutRect __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *pbstrElementId);


void __RPC_STUB ILayoutRect_get_nextRect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ILayoutRect_put_contentSrc_Proxy( 
    ILayoutRect __RPC_FAR * This,
    /* [in] */ VARIANT varContentSrc);


void __RPC_STUB ILayoutRect_put_contentSrc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ILayoutRect_get_contentSrc_Proxy( 
    ILayoutRect __RPC_FAR * This,
    /* [out][retval] */ VARIANT __RPC_FAR *pvarContentSrc);


void __RPC_STUB ILayoutRect_get_contentSrc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ILayoutRect_put_honorPageBreaks_Proxy( 
    ILayoutRect __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL v);


void __RPC_STUB ILayoutRect_put_honorPageBreaks_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ILayoutRect_get_honorPageBreaks_Proxy( 
    ILayoutRect __RPC_FAR * This,
    /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);


void __RPC_STUB ILayoutRect_get_honorPageBreaks_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ILayoutRect_put_honorPageRules_Proxy( 
    ILayoutRect __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL v);


void __RPC_STUB ILayoutRect_put_honorPageRules_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ILayoutRect_get_honorPageRules_Proxy( 
    ILayoutRect __RPC_FAR * This,
    /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);


void __RPC_STUB ILayoutRect_get_honorPageRules_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ILayoutRect_put_nextRectElement_Proxy( 
    ILayoutRect __RPC_FAR * This,
    /* [in] */ IDispatch __RPC_FAR *pElem);


void __RPC_STUB ILayoutRect_put_nextRectElement_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ILayoutRect_get_nextRectElement_Proxy( 
    ILayoutRect __RPC_FAR * This,
    /* [out][retval] */ IDispatch __RPC_FAR *__RPC_FAR *ppElem);


void __RPC_STUB ILayoutRect_get_nextRectElement_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ILayoutRect_get_contentDocument_Proxy( 
    ILayoutRect __RPC_FAR * This,
    /* [out][retval] */ IDispatch __RPC_FAR *__RPC_FAR *pDoc);


void __RPC_STUB ILayoutRect_get_contentDocument_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ILayoutRect_INTERFACE_DEFINED__ */


#ifndef __IDeviceRect_INTERFACE_DEFINED__
#define __IDeviceRect_INTERFACE_DEFINED__

/* interface IDeviceRect */
/* [object][uuid][dual][oleautomation] */ 


EXTERN_C const IID IID_IDeviceRect;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f6d5-98b5-11cf-bb82-00aa00bdce0b")
    IDeviceRect : public IDispatch
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IDeviceRectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDeviceRect __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDeviceRect __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDeviceRect __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDeviceRect __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDeviceRect __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDeviceRect __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDeviceRect __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        END_INTERFACE
    } IDeviceRectVtbl;

    interface IDeviceRect
    {
        CONST_VTBL struct IDeviceRectVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDeviceRect_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDeviceRect_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDeviceRect_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDeviceRect_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDeviceRect_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDeviceRect_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDeviceRect_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDeviceRect_INTERFACE_DEFINED__ */


#ifndef __ITemplatePrinter_INTERFACE_DEFINED__
#define __ITemplatePrinter_INTERFACE_DEFINED__

/* interface ITemplatePrinter */
/* [object][uuid][dual][oleautomation] */ 


EXTERN_C const IID IID_ITemplatePrinter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f6b4-98b5-11cf-bb82-00aa00bdce0b")
    ITemplatePrinter : public IDispatch
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE startDoc( 
            /* [in] */ BSTR bstrTitle,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE stopDoc( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE printBlankPage( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE printPage( 
            /* [in] */ IDispatch __RPC_FAR *pElemDisp) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE ensurePrintDialogDefaults( 
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE showPrintDialog( 
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE showPageSetupDialog( 
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE printNonNative( 
            /* [in] */ IUnknown __RPC_FAR *pMarkup,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE printNonNativeFrames( 
            /* [in] */ IUnknown __RPC_FAR *pMarkup,
            /* [in] */ VARIANT_BOOL fActiveFrame) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_framesetDocument( 
            /* [in] */ VARIANT_BOOL v) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_framesetDocument( 
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_frameActive( 
            /* [in] */ VARIANT_BOOL v) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_frameActive( 
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_frameAsShown( 
            /* [in] */ VARIANT_BOOL v) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_frameAsShown( 
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_selection( 
            /* [in] */ VARIANT_BOOL v) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_selection( 
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_selectedPages( 
            /* [in] */ VARIANT_BOOL v) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_selectedPages( 
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_currentPage( 
            /* [in] */ VARIANT_BOOL v) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_currentPage( 
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_currentPageAvail( 
            /* [in] */ VARIANT_BOOL v) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_currentPageAvail( 
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_collate( 
            /* [in] */ VARIANT_BOOL v) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_collate( 
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_duplex( 
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_copies( 
            /* [in] */ WORD v) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_copies( 
            /* [out][retval] */ WORD __RPC_FAR *p) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_pageFrom( 
            /* [in] */ WORD v) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_pageFrom( 
            /* [out][retval] */ WORD __RPC_FAR *p) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_pageTo( 
            /* [in] */ WORD v) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_pageTo( 
            /* [out][retval] */ WORD __RPC_FAR *p) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_tableOfLinks( 
            /* [in] */ VARIANT_BOOL v) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_tableOfLinks( 
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_allLinkedDocuments( 
            /* [in] */ VARIANT_BOOL v) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_allLinkedDocuments( 
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_header( 
            /* [in] */ BSTR bstrHeader) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_header( 
            /* [out][retval] */ BSTR __RPC_FAR *bstrHeader) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_footer( 
            /* [in] */ BSTR bstrFooter) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_footer( 
            /* [out][retval] */ BSTR __RPC_FAR *bstrFooter) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_marginLeft( 
            /* [in] */ long v) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_marginLeft( 
            /* [out][retval] */ long __RPC_FAR *p) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_marginRight( 
            /* [in] */ long v) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_marginRight( 
            /* [out][retval] */ long __RPC_FAR *p) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_marginTop( 
            /* [in] */ long v) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_marginTop( 
            /* [out][retval] */ long __RPC_FAR *p) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_marginBottom( 
            /* [in] */ long v) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_marginBottom( 
            /* [out][retval] */ long __RPC_FAR *p) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_pageWidth( 
            /* [out][retval] */ long __RPC_FAR *p) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_pageHeight( 
            /* [out][retval] */ long __RPC_FAR *p) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_unprintableLeft( 
            /* [out][retval] */ long __RPC_FAR *p) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_unprintableTop( 
            /* [out][retval] */ long __RPC_FAR *p) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_unprintableRight( 
            /* [out][retval] */ long __RPC_FAR *p) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_unprintableBottom( 
            /* [out][retval] */ long __RPC_FAR *p) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE updatePageStatus( 
            /* [in] */ long __RPC_FAR *p) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITemplatePrinterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITemplatePrinter __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITemplatePrinter __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITemplatePrinter __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ITemplatePrinter __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ITemplatePrinter __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ITemplatePrinter __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ITemplatePrinter __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *startDoc )( 
            ITemplatePrinter __RPC_FAR * This,
            /* [in] */ BSTR bstrTitle,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *stopDoc )( 
            ITemplatePrinter __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *printBlankPage )( 
            ITemplatePrinter __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *printPage )( 
            ITemplatePrinter __RPC_FAR * This,
            /* [in] */ IDispatch __RPC_FAR *pElemDisp);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ensurePrintDialogDefaults )( 
            ITemplatePrinter __RPC_FAR * This,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *showPrintDialog )( 
            ITemplatePrinter __RPC_FAR * This,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *showPageSetupDialog )( 
            ITemplatePrinter __RPC_FAR * This,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *printNonNative )( 
            ITemplatePrinter __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *pMarkup,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *printNonNativeFrames )( 
            ITemplatePrinter __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *pMarkup,
            /* [in] */ VARIANT_BOOL fActiveFrame);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_framesetDocument )( 
            ITemplatePrinter __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_framesetDocument )( 
            ITemplatePrinter __RPC_FAR * This,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_frameActive )( 
            ITemplatePrinter __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_frameActive )( 
            ITemplatePrinter __RPC_FAR * This,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_frameAsShown )( 
            ITemplatePrinter __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_frameAsShown )( 
            ITemplatePrinter __RPC_FAR * This,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_selection )( 
            ITemplatePrinter __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_selection )( 
            ITemplatePrinter __RPC_FAR * This,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_selectedPages )( 
            ITemplatePrinter __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_selectedPages )( 
            ITemplatePrinter __RPC_FAR * This,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_currentPage )( 
            ITemplatePrinter __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_currentPage )( 
            ITemplatePrinter __RPC_FAR * This,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_currentPageAvail )( 
            ITemplatePrinter __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_currentPageAvail )( 
            ITemplatePrinter __RPC_FAR * This,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_collate )( 
            ITemplatePrinter __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_collate )( 
            ITemplatePrinter __RPC_FAR * This,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_duplex )( 
            ITemplatePrinter __RPC_FAR * This,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_copies )( 
            ITemplatePrinter __RPC_FAR * This,
            /* [in] */ WORD v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_copies )( 
            ITemplatePrinter __RPC_FAR * This,
            /* [out][retval] */ WORD __RPC_FAR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_pageFrom )( 
            ITemplatePrinter __RPC_FAR * This,
            /* [in] */ WORD v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_pageFrom )( 
            ITemplatePrinter __RPC_FAR * This,
            /* [out][retval] */ WORD __RPC_FAR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_pageTo )( 
            ITemplatePrinter __RPC_FAR * This,
            /* [in] */ WORD v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_pageTo )( 
            ITemplatePrinter __RPC_FAR * This,
            /* [out][retval] */ WORD __RPC_FAR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_tableOfLinks )( 
            ITemplatePrinter __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_tableOfLinks )( 
            ITemplatePrinter __RPC_FAR * This,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_allLinkedDocuments )( 
            ITemplatePrinter __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_allLinkedDocuments )( 
            ITemplatePrinter __RPC_FAR * This,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_header )( 
            ITemplatePrinter __RPC_FAR * This,
            /* [in] */ BSTR bstrHeader);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_header )( 
            ITemplatePrinter __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *bstrHeader);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_footer )( 
            ITemplatePrinter __RPC_FAR * This,
            /* [in] */ BSTR bstrFooter);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_footer )( 
            ITemplatePrinter __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *bstrFooter);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_marginLeft )( 
            ITemplatePrinter __RPC_FAR * This,
            /* [in] */ long v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_marginLeft )( 
            ITemplatePrinter __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_marginRight )( 
            ITemplatePrinter __RPC_FAR * This,
            /* [in] */ long v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_marginRight )( 
            ITemplatePrinter __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_marginTop )( 
            ITemplatePrinter __RPC_FAR * This,
            /* [in] */ long v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_marginTop )( 
            ITemplatePrinter __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_marginBottom )( 
            ITemplatePrinter __RPC_FAR * This,
            /* [in] */ long v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_marginBottom )( 
            ITemplatePrinter __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_pageWidth )( 
            ITemplatePrinter __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_pageHeight )( 
            ITemplatePrinter __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_unprintableLeft )( 
            ITemplatePrinter __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_unprintableTop )( 
            ITemplatePrinter __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_unprintableRight )( 
            ITemplatePrinter __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_unprintableBottom )( 
            ITemplatePrinter __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *updatePageStatus )( 
            ITemplatePrinter __RPC_FAR * This,
            /* [in] */ long __RPC_FAR *p);
        
        END_INTERFACE
    } ITemplatePrinterVtbl;

    interface ITemplatePrinter
    {
        CONST_VTBL struct ITemplatePrinterVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITemplatePrinter_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITemplatePrinter_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITemplatePrinter_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITemplatePrinter_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITemplatePrinter_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITemplatePrinter_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITemplatePrinter_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITemplatePrinter_startDoc(This,bstrTitle,p)	\
    (This)->lpVtbl -> startDoc(This,bstrTitle,p)

#define ITemplatePrinter_stopDoc(This)	\
    (This)->lpVtbl -> stopDoc(This)

#define ITemplatePrinter_printBlankPage(This)	\
    (This)->lpVtbl -> printBlankPage(This)

#define ITemplatePrinter_printPage(This,pElemDisp)	\
    (This)->lpVtbl -> printPage(This,pElemDisp)

#define ITemplatePrinter_ensurePrintDialogDefaults(This,p)	\
    (This)->lpVtbl -> ensurePrintDialogDefaults(This,p)

#define ITemplatePrinter_showPrintDialog(This,p)	\
    (This)->lpVtbl -> showPrintDialog(This,p)

#define ITemplatePrinter_showPageSetupDialog(This,p)	\
    (This)->lpVtbl -> showPageSetupDialog(This,p)

#define ITemplatePrinter_printNonNative(This,pMarkup,p)	\
    (This)->lpVtbl -> printNonNative(This,pMarkup,p)

#define ITemplatePrinter_printNonNativeFrames(This,pMarkup,fActiveFrame)	\
    (This)->lpVtbl -> printNonNativeFrames(This,pMarkup,fActiveFrame)

#define ITemplatePrinter_put_framesetDocument(This,v)	\
    (This)->lpVtbl -> put_framesetDocument(This,v)

#define ITemplatePrinter_get_framesetDocument(This,p)	\
    (This)->lpVtbl -> get_framesetDocument(This,p)

#define ITemplatePrinter_put_frameActive(This,v)	\
    (This)->lpVtbl -> put_frameActive(This,v)

#define ITemplatePrinter_get_frameActive(This,p)	\
    (This)->lpVtbl -> get_frameActive(This,p)

#define ITemplatePrinter_put_frameAsShown(This,v)	\
    (This)->lpVtbl -> put_frameAsShown(This,v)

#define ITemplatePrinter_get_frameAsShown(This,p)	\
    (This)->lpVtbl -> get_frameAsShown(This,p)

#define ITemplatePrinter_put_selection(This,v)	\
    (This)->lpVtbl -> put_selection(This,v)

#define ITemplatePrinter_get_selection(This,p)	\
    (This)->lpVtbl -> get_selection(This,p)

#define ITemplatePrinter_put_selectedPages(This,v)	\
    (This)->lpVtbl -> put_selectedPages(This,v)

#define ITemplatePrinter_get_selectedPages(This,p)	\
    (This)->lpVtbl -> get_selectedPages(This,p)

#define ITemplatePrinter_put_currentPage(This,v)	\
    (This)->lpVtbl -> put_currentPage(This,v)

#define ITemplatePrinter_get_currentPage(This,p)	\
    (This)->lpVtbl -> get_currentPage(This,p)

#define ITemplatePrinter_put_currentPageAvail(This,v)	\
    (This)->lpVtbl -> put_currentPageAvail(This,v)

#define ITemplatePrinter_get_currentPageAvail(This,p)	\
    (This)->lpVtbl -> get_currentPageAvail(This,p)

#define ITemplatePrinter_put_collate(This,v)	\
    (This)->lpVtbl -> put_collate(This,v)

#define ITemplatePrinter_get_collate(This,p)	\
    (This)->lpVtbl -> get_collate(This,p)

#define ITemplatePrinter_get_duplex(This,p)	\
    (This)->lpVtbl -> get_duplex(This,p)

#define ITemplatePrinter_put_copies(This,v)	\
    (This)->lpVtbl -> put_copies(This,v)

#define ITemplatePrinter_get_copies(This,p)	\
    (This)->lpVtbl -> get_copies(This,p)

#define ITemplatePrinter_put_pageFrom(This,v)	\
    (This)->lpVtbl -> put_pageFrom(This,v)

#define ITemplatePrinter_get_pageFrom(This,p)	\
    (This)->lpVtbl -> get_pageFrom(This,p)

#define ITemplatePrinter_put_pageTo(This,v)	\
    (This)->lpVtbl -> put_pageTo(This,v)

#define ITemplatePrinter_get_pageTo(This,p)	\
    (This)->lpVtbl -> get_pageTo(This,p)

#define ITemplatePrinter_put_tableOfLinks(This,v)	\
    (This)->lpVtbl -> put_tableOfLinks(This,v)

#define ITemplatePrinter_get_tableOfLinks(This,p)	\
    (This)->lpVtbl -> get_tableOfLinks(This,p)

#define ITemplatePrinter_put_allLinkedDocuments(This,v)	\
    (This)->lpVtbl -> put_allLinkedDocuments(This,v)

#define ITemplatePrinter_get_allLinkedDocuments(This,p)	\
    (This)->lpVtbl -> get_allLinkedDocuments(This,p)

#define ITemplatePrinter_put_header(This,bstrHeader)	\
    (This)->lpVtbl -> put_header(This,bstrHeader)

#define ITemplatePrinter_get_header(This,bstrHeader)	\
    (This)->lpVtbl -> get_header(This,bstrHeader)

#define ITemplatePrinter_put_footer(This,bstrFooter)	\
    (This)->lpVtbl -> put_footer(This,bstrFooter)

#define ITemplatePrinter_get_footer(This,bstrFooter)	\
    (This)->lpVtbl -> get_footer(This,bstrFooter)

#define ITemplatePrinter_put_marginLeft(This,v)	\
    (This)->lpVtbl -> put_marginLeft(This,v)

#define ITemplatePrinter_get_marginLeft(This,p)	\
    (This)->lpVtbl -> get_marginLeft(This,p)

#define ITemplatePrinter_put_marginRight(This,v)	\
    (This)->lpVtbl -> put_marginRight(This,v)

#define ITemplatePrinter_get_marginRight(This,p)	\
    (This)->lpVtbl -> get_marginRight(This,p)

#define ITemplatePrinter_put_marginTop(This,v)	\
    (This)->lpVtbl -> put_marginTop(This,v)

#define ITemplatePrinter_get_marginTop(This,p)	\
    (This)->lpVtbl -> get_marginTop(This,p)

#define ITemplatePrinter_put_marginBottom(This,v)	\
    (This)->lpVtbl -> put_marginBottom(This,v)

#define ITemplatePrinter_get_marginBottom(This,p)	\
    (This)->lpVtbl -> get_marginBottom(This,p)

#define ITemplatePrinter_get_pageWidth(This,p)	\
    (This)->lpVtbl -> get_pageWidth(This,p)

#define ITemplatePrinter_get_pageHeight(This,p)	\
    (This)->lpVtbl -> get_pageHeight(This,p)

#define ITemplatePrinter_get_unprintableLeft(This,p)	\
    (This)->lpVtbl -> get_unprintableLeft(This,p)

#define ITemplatePrinter_get_unprintableTop(This,p)	\
    (This)->lpVtbl -> get_unprintableTop(This,p)

#define ITemplatePrinter_get_unprintableRight(This,p)	\
    (This)->lpVtbl -> get_unprintableRight(This,p)

#define ITemplatePrinter_get_unprintableBottom(This,p)	\
    (This)->lpVtbl -> get_unprintableBottom(This,p)

#define ITemplatePrinter_updatePageStatus(This,p)	\
    (This)->lpVtbl -> updatePageStatus(This,p)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id] */ HRESULT STDMETHODCALLTYPE ITemplatePrinter_startDoc_Proxy( 
    ITemplatePrinter __RPC_FAR * This,
    /* [in] */ BSTR bstrTitle,
    /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);


void __RPC_STUB ITemplatePrinter_startDoc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITemplatePrinter_stopDoc_Proxy( 
    ITemplatePrinter __RPC_FAR * This);


void __RPC_STUB ITemplatePrinter_stopDoc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITemplatePrinter_printBlankPage_Proxy( 
    ITemplatePrinter __RPC_FAR * This);


void __RPC_STUB ITemplatePrinter_printBlankPage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITemplatePrinter_printPage_Proxy( 
    ITemplatePrinter __RPC_FAR * This,
    /* [in] */ IDispatch __RPC_FAR *pElemDisp);


void __RPC_STUB ITemplatePrinter_printPage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITemplatePrinter_ensurePrintDialogDefaults_Proxy( 
    ITemplatePrinter __RPC_FAR * This,
    /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);


void __RPC_STUB ITemplatePrinter_ensurePrintDialogDefaults_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITemplatePrinter_showPrintDialog_Proxy( 
    ITemplatePrinter __RPC_FAR * This,
    /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);


void __RPC_STUB ITemplatePrinter_showPrintDialog_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITemplatePrinter_showPageSetupDialog_Proxy( 
    ITemplatePrinter __RPC_FAR * This,
    /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);


void __RPC_STUB ITemplatePrinter_showPageSetupDialog_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITemplatePrinter_printNonNative_Proxy( 
    ITemplatePrinter __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *pMarkup,
    /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);


void __RPC_STUB ITemplatePrinter_printNonNative_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITemplatePrinter_printNonNativeFrames_Proxy( 
    ITemplatePrinter __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *pMarkup,
    /* [in] */ VARIANT_BOOL fActiveFrame);


void __RPC_STUB ITemplatePrinter_printNonNativeFrames_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ITemplatePrinter_put_framesetDocument_Proxy( 
    ITemplatePrinter __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL v);


void __RPC_STUB ITemplatePrinter_put_framesetDocument_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ITemplatePrinter_get_framesetDocument_Proxy( 
    ITemplatePrinter __RPC_FAR * This,
    /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);


void __RPC_STUB ITemplatePrinter_get_framesetDocument_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ITemplatePrinter_put_frameActive_Proxy( 
    ITemplatePrinter __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL v);


void __RPC_STUB ITemplatePrinter_put_frameActive_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ITemplatePrinter_get_frameActive_Proxy( 
    ITemplatePrinter __RPC_FAR * This,
    /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);


void __RPC_STUB ITemplatePrinter_get_frameActive_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ITemplatePrinter_put_frameAsShown_Proxy( 
    ITemplatePrinter __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL v);


void __RPC_STUB ITemplatePrinter_put_frameAsShown_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ITemplatePrinter_get_frameAsShown_Proxy( 
    ITemplatePrinter __RPC_FAR * This,
    /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);


void __RPC_STUB ITemplatePrinter_get_frameAsShown_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ITemplatePrinter_put_selection_Proxy( 
    ITemplatePrinter __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL v);


void __RPC_STUB ITemplatePrinter_put_selection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ITemplatePrinter_get_selection_Proxy( 
    ITemplatePrinter __RPC_FAR * This,
    /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);


void __RPC_STUB ITemplatePrinter_get_selection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ITemplatePrinter_put_selectedPages_Proxy( 
    ITemplatePrinter __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL v);


void __RPC_STUB ITemplatePrinter_put_selectedPages_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ITemplatePrinter_get_selectedPages_Proxy( 
    ITemplatePrinter __RPC_FAR * This,
    /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);


void __RPC_STUB ITemplatePrinter_get_selectedPages_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ITemplatePrinter_put_currentPage_Proxy( 
    ITemplatePrinter __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL v);


void __RPC_STUB ITemplatePrinter_put_currentPage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ITemplatePrinter_get_currentPage_Proxy( 
    ITemplatePrinter __RPC_FAR * This,
    /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);


void __RPC_STUB ITemplatePrinter_get_currentPage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ITemplatePrinter_put_currentPageAvail_Proxy( 
    ITemplatePrinter __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL v);


void __RPC_STUB ITemplatePrinter_put_currentPageAvail_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ITemplatePrinter_get_currentPageAvail_Proxy( 
    ITemplatePrinter __RPC_FAR * This,
    /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);


void __RPC_STUB ITemplatePrinter_get_currentPageAvail_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ITemplatePrinter_put_collate_Proxy( 
    ITemplatePrinter __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL v);


void __RPC_STUB ITemplatePrinter_put_collate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ITemplatePrinter_get_collate_Proxy( 
    ITemplatePrinter __RPC_FAR * This,
    /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);


void __RPC_STUB ITemplatePrinter_get_collate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ITemplatePrinter_get_duplex_Proxy( 
    ITemplatePrinter __RPC_FAR * This,
    /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);


void __RPC_STUB ITemplatePrinter_get_duplex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ITemplatePrinter_put_copies_Proxy( 
    ITemplatePrinter __RPC_FAR * This,
    /* [in] */ WORD v);


void __RPC_STUB ITemplatePrinter_put_copies_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ITemplatePrinter_get_copies_Proxy( 
    ITemplatePrinter __RPC_FAR * This,
    /* [out][retval] */ WORD __RPC_FAR *p);


void __RPC_STUB ITemplatePrinter_get_copies_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ITemplatePrinter_put_pageFrom_Proxy( 
    ITemplatePrinter __RPC_FAR * This,
    /* [in] */ WORD v);


void __RPC_STUB ITemplatePrinter_put_pageFrom_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ITemplatePrinter_get_pageFrom_Proxy( 
    ITemplatePrinter __RPC_FAR * This,
    /* [out][retval] */ WORD __RPC_FAR *p);


void __RPC_STUB ITemplatePrinter_get_pageFrom_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ITemplatePrinter_put_pageTo_Proxy( 
    ITemplatePrinter __RPC_FAR * This,
    /* [in] */ WORD v);


void __RPC_STUB ITemplatePrinter_put_pageTo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ITemplatePrinter_get_pageTo_Proxy( 
    ITemplatePrinter __RPC_FAR * This,
    /* [out][retval] */ WORD __RPC_FAR *p);


void __RPC_STUB ITemplatePrinter_get_pageTo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ITemplatePrinter_put_tableOfLinks_Proxy( 
    ITemplatePrinter __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL v);


void __RPC_STUB ITemplatePrinter_put_tableOfLinks_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ITemplatePrinter_get_tableOfLinks_Proxy( 
    ITemplatePrinter __RPC_FAR * This,
    /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);


void __RPC_STUB ITemplatePrinter_get_tableOfLinks_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ITemplatePrinter_put_allLinkedDocuments_Proxy( 
    ITemplatePrinter __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL v);


void __RPC_STUB ITemplatePrinter_put_allLinkedDocuments_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ITemplatePrinter_get_allLinkedDocuments_Proxy( 
    ITemplatePrinter __RPC_FAR * This,
    /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);


void __RPC_STUB ITemplatePrinter_get_allLinkedDocuments_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ITemplatePrinter_put_header_Proxy( 
    ITemplatePrinter __RPC_FAR * This,
    /* [in] */ BSTR bstrHeader);


void __RPC_STUB ITemplatePrinter_put_header_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ITemplatePrinter_get_header_Proxy( 
    ITemplatePrinter __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *bstrHeader);


void __RPC_STUB ITemplatePrinter_get_header_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ITemplatePrinter_put_footer_Proxy( 
    ITemplatePrinter __RPC_FAR * This,
    /* [in] */ BSTR bstrFooter);


void __RPC_STUB ITemplatePrinter_put_footer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ITemplatePrinter_get_footer_Proxy( 
    ITemplatePrinter __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *bstrFooter);


void __RPC_STUB ITemplatePrinter_get_footer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ITemplatePrinter_put_marginLeft_Proxy( 
    ITemplatePrinter __RPC_FAR * This,
    /* [in] */ long v);


void __RPC_STUB ITemplatePrinter_put_marginLeft_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ITemplatePrinter_get_marginLeft_Proxy( 
    ITemplatePrinter __RPC_FAR * This,
    /* [out][retval] */ long __RPC_FAR *p);


void __RPC_STUB ITemplatePrinter_get_marginLeft_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ITemplatePrinter_put_marginRight_Proxy( 
    ITemplatePrinter __RPC_FAR * This,
    /* [in] */ long v);


void __RPC_STUB ITemplatePrinter_put_marginRight_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ITemplatePrinter_get_marginRight_Proxy( 
    ITemplatePrinter __RPC_FAR * This,
    /* [out][retval] */ long __RPC_FAR *p);


void __RPC_STUB ITemplatePrinter_get_marginRight_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ITemplatePrinter_put_marginTop_Proxy( 
    ITemplatePrinter __RPC_FAR * This,
    /* [in] */ long v);


void __RPC_STUB ITemplatePrinter_put_marginTop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ITemplatePrinter_get_marginTop_Proxy( 
    ITemplatePrinter __RPC_FAR * This,
    /* [out][retval] */ long __RPC_FAR *p);


void __RPC_STUB ITemplatePrinter_get_marginTop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ITemplatePrinter_put_marginBottom_Proxy( 
    ITemplatePrinter __RPC_FAR * This,
    /* [in] */ long v);


void __RPC_STUB ITemplatePrinter_put_marginBottom_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ITemplatePrinter_get_marginBottom_Proxy( 
    ITemplatePrinter __RPC_FAR * This,
    /* [out][retval] */ long __RPC_FAR *p);


void __RPC_STUB ITemplatePrinter_get_marginBottom_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ITemplatePrinter_get_pageWidth_Proxy( 
    ITemplatePrinter __RPC_FAR * This,
    /* [out][retval] */ long __RPC_FAR *p);


void __RPC_STUB ITemplatePrinter_get_pageWidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ITemplatePrinter_get_pageHeight_Proxy( 
    ITemplatePrinter __RPC_FAR * This,
    /* [out][retval] */ long __RPC_FAR *p);


void __RPC_STUB ITemplatePrinter_get_pageHeight_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ITemplatePrinter_get_unprintableLeft_Proxy( 
    ITemplatePrinter __RPC_FAR * This,
    /* [out][retval] */ long __RPC_FAR *p);


void __RPC_STUB ITemplatePrinter_get_unprintableLeft_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ITemplatePrinter_get_unprintableTop_Proxy( 
    ITemplatePrinter __RPC_FAR * This,
    /* [out][retval] */ long __RPC_FAR *p);


void __RPC_STUB ITemplatePrinter_get_unprintableTop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ITemplatePrinter_get_unprintableRight_Proxy( 
    ITemplatePrinter __RPC_FAR * This,
    /* [out][retval] */ long __RPC_FAR *p);


void __RPC_STUB ITemplatePrinter_get_unprintableRight_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ITemplatePrinter_get_unprintableBottom_Proxy( 
    ITemplatePrinter __RPC_FAR * This,
    /* [out][retval] */ long __RPC_FAR *p);


void __RPC_STUB ITemplatePrinter_get_unprintableBottom_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITemplatePrinter_updatePageStatus_Proxy( 
    ITemplatePrinter __RPC_FAR * This,
    /* [in] */ long __RPC_FAR *p);


void __RPC_STUB ITemplatePrinter_updatePageStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITemplatePrinter_INTERFACE_DEFINED__ */


#ifndef __ITemplatePrinter2_INTERFACE_DEFINED__
#define __ITemplatePrinter2_INTERFACE_DEFINED__

/* interface ITemplatePrinter2 */
/* [object][uuid][dual][oleautomation] */ 


EXTERN_C const IID IID_ITemplatePrinter2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f83f-98b5-11cf-bb82-00aa00bdce0b")
    ITemplatePrinter2 : public ITemplatePrinter
    {
    public:
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_selectionEnabled( 
            /* [in] */ VARIANT_BOOL v) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_selectionEnabled( 
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_frameActiveEnabled( 
            /* [in] */ VARIANT_BOOL v) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_frameActiveEnabled( 
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_orientation( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_orientation( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_usePrinterCopyCollate( 
            /* [in] */ VARIANT_BOOL v) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_usePrinterCopyCollate( 
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE deviceSupports( 
            /* [in] */ BSTR bstrProperty,
            /* [out][retval] */ VARIANT __RPC_FAR *pvar) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITemplatePrinter2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITemplatePrinter2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITemplatePrinter2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITemplatePrinter2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ITemplatePrinter2 __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ITemplatePrinter2 __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ITemplatePrinter2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ITemplatePrinter2 __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *startDoc )( 
            ITemplatePrinter2 __RPC_FAR * This,
            /* [in] */ BSTR bstrTitle,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *stopDoc )( 
            ITemplatePrinter2 __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *printBlankPage )( 
            ITemplatePrinter2 __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *printPage )( 
            ITemplatePrinter2 __RPC_FAR * This,
            /* [in] */ IDispatch __RPC_FAR *pElemDisp);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ensurePrintDialogDefaults )( 
            ITemplatePrinter2 __RPC_FAR * This,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *showPrintDialog )( 
            ITemplatePrinter2 __RPC_FAR * This,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *showPageSetupDialog )( 
            ITemplatePrinter2 __RPC_FAR * This,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *printNonNative )( 
            ITemplatePrinter2 __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *pMarkup,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *printNonNativeFrames )( 
            ITemplatePrinter2 __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *pMarkup,
            /* [in] */ VARIANT_BOOL fActiveFrame);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_framesetDocument )( 
            ITemplatePrinter2 __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_framesetDocument )( 
            ITemplatePrinter2 __RPC_FAR * This,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_frameActive )( 
            ITemplatePrinter2 __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_frameActive )( 
            ITemplatePrinter2 __RPC_FAR * This,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_frameAsShown )( 
            ITemplatePrinter2 __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_frameAsShown )( 
            ITemplatePrinter2 __RPC_FAR * This,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_selection )( 
            ITemplatePrinter2 __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_selection )( 
            ITemplatePrinter2 __RPC_FAR * This,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_selectedPages )( 
            ITemplatePrinter2 __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_selectedPages )( 
            ITemplatePrinter2 __RPC_FAR * This,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_currentPage )( 
            ITemplatePrinter2 __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_currentPage )( 
            ITemplatePrinter2 __RPC_FAR * This,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_currentPageAvail )( 
            ITemplatePrinter2 __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_currentPageAvail )( 
            ITemplatePrinter2 __RPC_FAR * This,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_collate )( 
            ITemplatePrinter2 __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_collate )( 
            ITemplatePrinter2 __RPC_FAR * This,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_duplex )( 
            ITemplatePrinter2 __RPC_FAR * This,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_copies )( 
            ITemplatePrinter2 __RPC_FAR * This,
            /* [in] */ WORD v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_copies )( 
            ITemplatePrinter2 __RPC_FAR * This,
            /* [out][retval] */ WORD __RPC_FAR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_pageFrom )( 
            ITemplatePrinter2 __RPC_FAR * This,
            /* [in] */ WORD v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_pageFrom )( 
            ITemplatePrinter2 __RPC_FAR * This,
            /* [out][retval] */ WORD __RPC_FAR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_pageTo )( 
            ITemplatePrinter2 __RPC_FAR * This,
            /* [in] */ WORD v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_pageTo )( 
            ITemplatePrinter2 __RPC_FAR * This,
            /* [out][retval] */ WORD __RPC_FAR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_tableOfLinks )( 
            ITemplatePrinter2 __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_tableOfLinks )( 
            ITemplatePrinter2 __RPC_FAR * This,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_allLinkedDocuments )( 
            ITemplatePrinter2 __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_allLinkedDocuments )( 
            ITemplatePrinter2 __RPC_FAR * This,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_header )( 
            ITemplatePrinter2 __RPC_FAR * This,
            /* [in] */ BSTR bstrHeader);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_header )( 
            ITemplatePrinter2 __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *bstrHeader);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_footer )( 
            ITemplatePrinter2 __RPC_FAR * This,
            /* [in] */ BSTR bstrFooter);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_footer )( 
            ITemplatePrinter2 __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *bstrFooter);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_marginLeft )( 
            ITemplatePrinter2 __RPC_FAR * This,
            /* [in] */ long v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_marginLeft )( 
            ITemplatePrinter2 __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_marginRight )( 
            ITemplatePrinter2 __RPC_FAR * This,
            /* [in] */ long v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_marginRight )( 
            ITemplatePrinter2 __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_marginTop )( 
            ITemplatePrinter2 __RPC_FAR * This,
            /* [in] */ long v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_marginTop )( 
            ITemplatePrinter2 __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_marginBottom )( 
            ITemplatePrinter2 __RPC_FAR * This,
            /* [in] */ long v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_marginBottom )( 
            ITemplatePrinter2 __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_pageWidth )( 
            ITemplatePrinter2 __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_pageHeight )( 
            ITemplatePrinter2 __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_unprintableLeft )( 
            ITemplatePrinter2 __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_unprintableTop )( 
            ITemplatePrinter2 __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_unprintableRight )( 
            ITemplatePrinter2 __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_unprintableBottom )( 
            ITemplatePrinter2 __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *updatePageStatus )( 
            ITemplatePrinter2 __RPC_FAR * This,
            /* [in] */ long __RPC_FAR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_selectionEnabled )( 
            ITemplatePrinter2 __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_selectionEnabled )( 
            ITemplatePrinter2 __RPC_FAR * This,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_frameActiveEnabled )( 
            ITemplatePrinter2 __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_frameActiveEnabled )( 
            ITemplatePrinter2 __RPC_FAR * This,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_orientation )( 
            ITemplatePrinter2 __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_orientation )( 
            ITemplatePrinter2 __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_usePrinterCopyCollate )( 
            ITemplatePrinter2 __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_usePrinterCopyCollate )( 
            ITemplatePrinter2 __RPC_FAR * This,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *deviceSupports )( 
            ITemplatePrinter2 __RPC_FAR * This,
            /* [in] */ BSTR bstrProperty,
            /* [out][retval] */ VARIANT __RPC_FAR *pvar);
        
        END_INTERFACE
    } ITemplatePrinter2Vtbl;

    interface ITemplatePrinter2
    {
        CONST_VTBL struct ITemplatePrinter2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITemplatePrinter2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITemplatePrinter2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITemplatePrinter2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITemplatePrinter2_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITemplatePrinter2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITemplatePrinter2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITemplatePrinter2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITemplatePrinter2_startDoc(This,bstrTitle,p)	\
    (This)->lpVtbl -> startDoc(This,bstrTitle,p)

#define ITemplatePrinter2_stopDoc(This)	\
    (This)->lpVtbl -> stopDoc(This)

#define ITemplatePrinter2_printBlankPage(This)	\
    (This)->lpVtbl -> printBlankPage(This)

#define ITemplatePrinter2_printPage(This,pElemDisp)	\
    (This)->lpVtbl -> printPage(This,pElemDisp)

#define ITemplatePrinter2_ensurePrintDialogDefaults(This,p)	\
    (This)->lpVtbl -> ensurePrintDialogDefaults(This,p)

#define ITemplatePrinter2_showPrintDialog(This,p)	\
    (This)->lpVtbl -> showPrintDialog(This,p)

#define ITemplatePrinter2_showPageSetupDialog(This,p)	\
    (This)->lpVtbl -> showPageSetupDialog(This,p)

#define ITemplatePrinter2_printNonNative(This,pMarkup,p)	\
    (This)->lpVtbl -> printNonNative(This,pMarkup,p)

#define ITemplatePrinter2_printNonNativeFrames(This,pMarkup,fActiveFrame)	\
    (This)->lpVtbl -> printNonNativeFrames(This,pMarkup,fActiveFrame)

#define ITemplatePrinter2_put_framesetDocument(This,v)	\
    (This)->lpVtbl -> put_framesetDocument(This,v)

#define ITemplatePrinter2_get_framesetDocument(This,p)	\
    (This)->lpVtbl -> get_framesetDocument(This,p)

#define ITemplatePrinter2_put_frameActive(This,v)	\
    (This)->lpVtbl -> put_frameActive(This,v)

#define ITemplatePrinter2_get_frameActive(This,p)	\
    (This)->lpVtbl -> get_frameActive(This,p)

#define ITemplatePrinter2_put_frameAsShown(This,v)	\
    (This)->lpVtbl -> put_frameAsShown(This,v)

#define ITemplatePrinter2_get_frameAsShown(This,p)	\
    (This)->lpVtbl -> get_frameAsShown(This,p)

#define ITemplatePrinter2_put_selection(This,v)	\
    (This)->lpVtbl -> put_selection(This,v)

#define ITemplatePrinter2_get_selection(This,p)	\
    (This)->lpVtbl -> get_selection(This,p)

#define ITemplatePrinter2_put_selectedPages(This,v)	\
    (This)->lpVtbl -> put_selectedPages(This,v)

#define ITemplatePrinter2_get_selectedPages(This,p)	\
    (This)->lpVtbl -> get_selectedPages(This,p)

#define ITemplatePrinter2_put_currentPage(This,v)	\
    (This)->lpVtbl -> put_currentPage(This,v)

#define ITemplatePrinter2_get_currentPage(This,p)	\
    (This)->lpVtbl -> get_currentPage(This,p)

#define ITemplatePrinter2_put_currentPageAvail(This,v)	\
    (This)->lpVtbl -> put_currentPageAvail(This,v)

#define ITemplatePrinter2_get_currentPageAvail(This,p)	\
    (This)->lpVtbl -> get_currentPageAvail(This,p)

#define ITemplatePrinter2_put_collate(This,v)	\
    (This)->lpVtbl -> put_collate(This,v)

#define ITemplatePrinter2_get_collate(This,p)	\
    (This)->lpVtbl -> get_collate(This,p)

#define ITemplatePrinter2_get_duplex(This,p)	\
    (This)->lpVtbl -> get_duplex(This,p)

#define ITemplatePrinter2_put_copies(This,v)	\
    (This)->lpVtbl -> put_copies(This,v)

#define ITemplatePrinter2_get_copies(This,p)	\
    (This)->lpVtbl -> get_copies(This,p)

#define ITemplatePrinter2_put_pageFrom(This,v)	\
    (This)->lpVtbl -> put_pageFrom(This,v)

#define ITemplatePrinter2_get_pageFrom(This,p)	\
    (This)->lpVtbl -> get_pageFrom(This,p)

#define ITemplatePrinter2_put_pageTo(This,v)	\
    (This)->lpVtbl -> put_pageTo(This,v)

#define ITemplatePrinter2_get_pageTo(This,p)	\
    (This)->lpVtbl -> get_pageTo(This,p)

#define ITemplatePrinter2_put_tableOfLinks(This,v)	\
    (This)->lpVtbl -> put_tableOfLinks(This,v)

#define ITemplatePrinter2_get_tableOfLinks(This,p)	\
    (This)->lpVtbl -> get_tableOfLinks(This,p)

#define ITemplatePrinter2_put_allLinkedDocuments(This,v)	\
    (This)->lpVtbl -> put_allLinkedDocuments(This,v)

#define ITemplatePrinter2_get_allLinkedDocuments(This,p)	\
    (This)->lpVtbl -> get_allLinkedDocuments(This,p)

#define ITemplatePrinter2_put_header(This,bstrHeader)	\
    (This)->lpVtbl -> put_header(This,bstrHeader)

#define ITemplatePrinter2_get_header(This,bstrHeader)	\
    (This)->lpVtbl -> get_header(This,bstrHeader)

#define ITemplatePrinter2_put_footer(This,bstrFooter)	\
    (This)->lpVtbl -> put_footer(This,bstrFooter)

#define ITemplatePrinter2_get_footer(This,bstrFooter)	\
    (This)->lpVtbl -> get_footer(This,bstrFooter)

#define ITemplatePrinter2_put_marginLeft(This,v)	\
    (This)->lpVtbl -> put_marginLeft(This,v)

#define ITemplatePrinter2_get_marginLeft(This,p)	\
    (This)->lpVtbl -> get_marginLeft(This,p)

#define ITemplatePrinter2_put_marginRight(This,v)	\
    (This)->lpVtbl -> put_marginRight(This,v)

#define ITemplatePrinter2_get_marginRight(This,p)	\
    (This)->lpVtbl -> get_marginRight(This,p)

#define ITemplatePrinter2_put_marginTop(This,v)	\
    (This)->lpVtbl -> put_marginTop(This,v)

#define ITemplatePrinter2_get_marginTop(This,p)	\
    (This)->lpVtbl -> get_marginTop(This,p)

#define ITemplatePrinter2_put_marginBottom(This,v)	\
    (This)->lpVtbl -> put_marginBottom(This,v)

#define ITemplatePrinter2_get_marginBottom(This,p)	\
    (This)->lpVtbl -> get_marginBottom(This,p)

#define ITemplatePrinter2_get_pageWidth(This,p)	\
    (This)->lpVtbl -> get_pageWidth(This,p)

#define ITemplatePrinter2_get_pageHeight(This,p)	\
    (This)->lpVtbl -> get_pageHeight(This,p)

#define ITemplatePrinter2_get_unprintableLeft(This,p)	\
    (This)->lpVtbl -> get_unprintableLeft(This,p)

#define ITemplatePrinter2_get_unprintableTop(This,p)	\
    (This)->lpVtbl -> get_unprintableTop(This,p)

#define ITemplatePrinter2_get_unprintableRight(This,p)	\
    (This)->lpVtbl -> get_unprintableRight(This,p)

#define ITemplatePrinter2_get_unprintableBottom(This,p)	\
    (This)->lpVtbl -> get_unprintableBottom(This,p)

#define ITemplatePrinter2_updatePageStatus(This,p)	\
    (This)->lpVtbl -> updatePageStatus(This,p)


#define ITemplatePrinter2_put_selectionEnabled(This,v)	\
    (This)->lpVtbl -> put_selectionEnabled(This,v)

#define ITemplatePrinter2_get_selectionEnabled(This,p)	\
    (This)->lpVtbl -> get_selectionEnabled(This,p)

#define ITemplatePrinter2_put_frameActiveEnabled(This,v)	\
    (This)->lpVtbl -> put_frameActiveEnabled(This,v)

#define ITemplatePrinter2_get_frameActiveEnabled(This,p)	\
    (This)->lpVtbl -> get_frameActiveEnabled(This,p)

#define ITemplatePrinter2_put_orientation(This,v)	\
    (This)->lpVtbl -> put_orientation(This,v)

#define ITemplatePrinter2_get_orientation(This,p)	\
    (This)->lpVtbl -> get_orientation(This,p)

#define ITemplatePrinter2_put_usePrinterCopyCollate(This,v)	\
    (This)->lpVtbl -> put_usePrinterCopyCollate(This,v)

#define ITemplatePrinter2_get_usePrinterCopyCollate(This,p)	\
    (This)->lpVtbl -> get_usePrinterCopyCollate(This,p)

#define ITemplatePrinter2_deviceSupports(This,bstrProperty,pvar)	\
    (This)->lpVtbl -> deviceSupports(This,bstrProperty,pvar)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propput] */ HRESULT STDMETHODCALLTYPE ITemplatePrinter2_put_selectionEnabled_Proxy( 
    ITemplatePrinter2 __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL v);


void __RPC_STUB ITemplatePrinter2_put_selectionEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ITemplatePrinter2_get_selectionEnabled_Proxy( 
    ITemplatePrinter2 __RPC_FAR * This,
    /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);


void __RPC_STUB ITemplatePrinter2_get_selectionEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ITemplatePrinter2_put_frameActiveEnabled_Proxy( 
    ITemplatePrinter2 __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL v);


void __RPC_STUB ITemplatePrinter2_put_frameActiveEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ITemplatePrinter2_get_frameActiveEnabled_Proxy( 
    ITemplatePrinter2 __RPC_FAR * This,
    /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);


void __RPC_STUB ITemplatePrinter2_get_frameActiveEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ITemplatePrinter2_put_orientation_Proxy( 
    ITemplatePrinter2 __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB ITemplatePrinter2_put_orientation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ITemplatePrinter2_get_orientation_Proxy( 
    ITemplatePrinter2 __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB ITemplatePrinter2_get_orientation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ITemplatePrinter2_put_usePrinterCopyCollate_Proxy( 
    ITemplatePrinter2 __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL v);


void __RPC_STUB ITemplatePrinter2_put_usePrinterCopyCollate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ITemplatePrinter2_get_usePrinterCopyCollate_Proxy( 
    ITemplatePrinter2 __RPC_FAR * This,
    /* [out][retval] */ VARIANT_BOOL __RPC_FAR *p);


void __RPC_STUB ITemplatePrinter2_get_usePrinterCopyCollate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITemplatePrinter2_deviceSupports_Proxy( 
    ITemplatePrinter2 __RPC_FAR * This,
    /* [in] */ BSTR bstrProperty,
    /* [out][retval] */ VARIANT __RPC_FAR *pvar);


void __RPC_STUB ITemplatePrinter2_deviceSupports_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITemplatePrinter2_INTERFACE_DEFINED__ */


#ifndef __IHeaderFooter_INTERFACE_DEFINED__
#define __IHeaderFooter_INTERFACE_DEFINED__

/* interface IHeaderFooter */
/* [object][uuid][dual][oleautomation] */ 


EXTERN_C const IID IID_IHeaderFooter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f6ce-98b5-11cf-bb82-00aa00bdce0b")
    IHeaderFooter : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_htmlHead( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_htmlFoot( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_textHead( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_textHead( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_textFoot( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_textFoot( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_page( 
            /* [in] */ DWORD v) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_page( 
            /* [out][retval] */ DWORD __RPC_FAR *p) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_pageTotal( 
            /* [in] */ DWORD v) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_pageTotal( 
            /* [out][retval] */ DWORD __RPC_FAR *p) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_URL( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_URL( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_title( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_title( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_dateShort( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_dateShort( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_dateLong( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_dateLong( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_timeShort( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_timeShort( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_timeLong( 
            /* [in] */ BSTR v) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_timeLong( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHeaderFooterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IHeaderFooter __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IHeaderFooter __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IHeaderFooter __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IHeaderFooter __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IHeaderFooter __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IHeaderFooter __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IHeaderFooter __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_htmlHead )( 
            IHeaderFooter __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_htmlFoot )( 
            IHeaderFooter __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_textHead )( 
            IHeaderFooter __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_textHead )( 
            IHeaderFooter __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_textFoot )( 
            IHeaderFooter __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_textFoot )( 
            IHeaderFooter __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_page )( 
            IHeaderFooter __RPC_FAR * This,
            /* [in] */ DWORD v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_page )( 
            IHeaderFooter __RPC_FAR * This,
            /* [out][retval] */ DWORD __RPC_FAR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_pageTotal )( 
            IHeaderFooter __RPC_FAR * This,
            /* [in] */ DWORD v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_pageTotal )( 
            IHeaderFooter __RPC_FAR * This,
            /* [out][retval] */ DWORD __RPC_FAR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_URL )( 
            IHeaderFooter __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_URL )( 
            IHeaderFooter __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_title )( 
            IHeaderFooter __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_title )( 
            IHeaderFooter __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_dateShort )( 
            IHeaderFooter __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_dateShort )( 
            IHeaderFooter __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_dateLong )( 
            IHeaderFooter __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_dateLong )( 
            IHeaderFooter __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_timeShort )( 
            IHeaderFooter __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_timeShort )( 
            IHeaderFooter __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_timeLong )( 
            IHeaderFooter __RPC_FAR * This,
            /* [in] */ BSTR v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_timeLong )( 
            IHeaderFooter __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        END_INTERFACE
    } IHeaderFooterVtbl;

    interface IHeaderFooter
    {
        CONST_VTBL struct IHeaderFooterVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHeaderFooter_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHeaderFooter_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHeaderFooter_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHeaderFooter_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IHeaderFooter_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IHeaderFooter_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IHeaderFooter_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IHeaderFooter_get_htmlHead(This,p)	\
    (This)->lpVtbl -> get_htmlHead(This,p)

#define IHeaderFooter_get_htmlFoot(This,p)	\
    (This)->lpVtbl -> get_htmlFoot(This,p)

#define IHeaderFooter_put_textHead(This,v)	\
    (This)->lpVtbl -> put_textHead(This,v)

#define IHeaderFooter_get_textHead(This,p)	\
    (This)->lpVtbl -> get_textHead(This,p)

#define IHeaderFooter_put_textFoot(This,v)	\
    (This)->lpVtbl -> put_textFoot(This,v)

#define IHeaderFooter_get_textFoot(This,p)	\
    (This)->lpVtbl -> get_textFoot(This,p)

#define IHeaderFooter_put_page(This,v)	\
    (This)->lpVtbl -> put_page(This,v)

#define IHeaderFooter_get_page(This,p)	\
    (This)->lpVtbl -> get_page(This,p)

#define IHeaderFooter_put_pageTotal(This,v)	\
    (This)->lpVtbl -> put_pageTotal(This,v)

#define IHeaderFooter_get_pageTotal(This,p)	\
    (This)->lpVtbl -> get_pageTotal(This,p)

#define IHeaderFooter_put_URL(This,v)	\
    (This)->lpVtbl -> put_URL(This,v)

#define IHeaderFooter_get_URL(This,p)	\
    (This)->lpVtbl -> get_URL(This,p)

#define IHeaderFooter_put_title(This,v)	\
    (This)->lpVtbl -> put_title(This,v)

#define IHeaderFooter_get_title(This,p)	\
    (This)->lpVtbl -> get_title(This,p)

#define IHeaderFooter_put_dateShort(This,v)	\
    (This)->lpVtbl -> put_dateShort(This,v)

#define IHeaderFooter_get_dateShort(This,p)	\
    (This)->lpVtbl -> get_dateShort(This,p)

#define IHeaderFooter_put_dateLong(This,v)	\
    (This)->lpVtbl -> put_dateLong(This,v)

#define IHeaderFooter_get_dateLong(This,p)	\
    (This)->lpVtbl -> get_dateLong(This,p)

#define IHeaderFooter_put_timeShort(This,v)	\
    (This)->lpVtbl -> put_timeShort(This,v)

#define IHeaderFooter_get_timeShort(This,p)	\
    (This)->lpVtbl -> get_timeShort(This,p)

#define IHeaderFooter_put_timeLong(This,v)	\
    (This)->lpVtbl -> put_timeLong(This,v)

#define IHeaderFooter_get_timeLong(This,p)	\
    (This)->lpVtbl -> get_timeLong(This,p)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IHeaderFooter_get_htmlHead_Proxy( 
    IHeaderFooter __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IHeaderFooter_get_htmlHead_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IHeaderFooter_get_htmlFoot_Proxy( 
    IHeaderFooter __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IHeaderFooter_get_htmlFoot_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IHeaderFooter_put_textHead_Proxy( 
    IHeaderFooter __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB IHeaderFooter_put_textHead_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IHeaderFooter_get_textHead_Proxy( 
    IHeaderFooter __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IHeaderFooter_get_textHead_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IHeaderFooter_put_textFoot_Proxy( 
    IHeaderFooter __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB IHeaderFooter_put_textFoot_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IHeaderFooter_get_textFoot_Proxy( 
    IHeaderFooter __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IHeaderFooter_get_textFoot_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IHeaderFooter_put_page_Proxy( 
    IHeaderFooter __RPC_FAR * This,
    /* [in] */ DWORD v);


void __RPC_STUB IHeaderFooter_put_page_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IHeaderFooter_get_page_Proxy( 
    IHeaderFooter __RPC_FAR * This,
    /* [out][retval] */ DWORD __RPC_FAR *p);


void __RPC_STUB IHeaderFooter_get_page_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IHeaderFooter_put_pageTotal_Proxy( 
    IHeaderFooter __RPC_FAR * This,
    /* [in] */ DWORD v);


void __RPC_STUB IHeaderFooter_put_pageTotal_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IHeaderFooter_get_pageTotal_Proxy( 
    IHeaderFooter __RPC_FAR * This,
    /* [out][retval] */ DWORD __RPC_FAR *p);


void __RPC_STUB IHeaderFooter_get_pageTotal_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IHeaderFooter_put_URL_Proxy( 
    IHeaderFooter __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB IHeaderFooter_put_URL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IHeaderFooter_get_URL_Proxy( 
    IHeaderFooter __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IHeaderFooter_get_URL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IHeaderFooter_put_title_Proxy( 
    IHeaderFooter __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB IHeaderFooter_put_title_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IHeaderFooter_get_title_Proxy( 
    IHeaderFooter __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IHeaderFooter_get_title_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IHeaderFooter_put_dateShort_Proxy( 
    IHeaderFooter __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB IHeaderFooter_put_dateShort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IHeaderFooter_get_dateShort_Proxy( 
    IHeaderFooter __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IHeaderFooter_get_dateShort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IHeaderFooter_put_dateLong_Proxy( 
    IHeaderFooter __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB IHeaderFooter_put_dateLong_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IHeaderFooter_get_dateLong_Proxy( 
    IHeaderFooter __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IHeaderFooter_get_dateLong_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IHeaderFooter_put_timeShort_Proxy( 
    IHeaderFooter __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB IHeaderFooter_put_timeShort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IHeaderFooter_get_timeShort_Proxy( 
    IHeaderFooter __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IHeaderFooter_get_timeShort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IHeaderFooter_put_timeLong_Proxy( 
    IHeaderFooter __RPC_FAR * This,
    /* [in] */ BSTR v);


void __RPC_STUB IHeaderFooter_put_timeLong_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IHeaderFooter_get_timeLong_Proxy( 
    IHeaderFooter __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IHeaderFooter_get_timeLong_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHeaderFooter_INTERFACE_DEFINED__ */



#ifndef __IEXTagLib_LIBRARY_DEFINED__
#define __IEXTagLib_LIBRARY_DEFINED__

/* library IEXTagLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_IEXTagLib;

EXTERN_C const CLSID CLSID_PeerFactory;

#ifdef __cplusplus

class DECLSPEC_UUID("3050F4CF-98B5-11CF-BB82-00AA00BDCE0B")
PeerFactory;
#endif

EXTERN_C const CLSID CLSID_ClientCaps;

#ifdef __cplusplus

class DECLSPEC_UUID("7E8BC44E-AEFF-11D1-89C2-00C04FB6BFC4")
ClientCaps;
#endif

EXTERN_C const CLSID CLSID_IntelliForms;

#ifdef __cplusplus

class DECLSPEC_UUID("613AB92E-16BF-11d2-BCA5-00C04FD929DB")
IntelliForms;
#endif

EXTERN_C const CLSID CLSID_HomePage;

#ifdef __cplusplus

class DECLSPEC_UUID("766BF2AE-D650-11d1-9811-00C04FC31D2E")
HomePage;
#endif

EXTERN_C const CLSID CLSID_CPersistUserData;

#ifdef __cplusplus

class DECLSPEC_UUID("3050f48e-98b5-11cf-bb82-00aa00bdce0b")
CPersistUserData;
#endif

EXTERN_C const CLSID CLSID_CPersistDataPeer;

#ifdef __cplusplus

class DECLSPEC_UUID("3050f487-98b5-11cf-bb82-00aa00bdce0b")
CPersistDataPeer;
#endif

EXTERN_C const CLSID CLSID_CPersistShortcut;

#ifdef __cplusplus

class DECLSPEC_UUID("3050f4c6-98b5-11cf-bb82-00aa00bdce0b")
CPersistShortcut;
#endif

EXTERN_C const CLSID CLSID_CPersistHistory;

#ifdef __cplusplus

class DECLSPEC_UUID("3050f4c8-98b5-11cf-bb82-00aa00bdce0b")
CPersistHistory;
#endif

EXTERN_C const CLSID CLSID_CPersistSnapshot;

#ifdef __cplusplus

class DECLSPEC_UUID("3050f4c9-98b5-11cf-bb82-00aa00bdce0b")
CPersistSnapshot;
#endif

EXTERN_C const CLSID CLSID_CDownloadBehavior;

#ifdef __cplusplus

class DECLSPEC_UUID("3050f5be-98b5-11cf-bb82-00aa00bdce0b")
CDownloadBehavior;
#endif

EXTERN_C const CLSID CLSID_wfolders;

#ifdef __cplusplus

class DECLSPEC_UUID("BAE31F9A-1B81-11D2-A97A-00C04F8ECB02")
wfolders;
#endif

EXTERN_C const CLSID CLSID_AnchorClick;

#ifdef __cplusplus

class DECLSPEC_UUID("13D5413C-33B9-11D2-95A7-00C04F8ECB02")
AnchorClick;
#endif

EXTERN_C const CLSID CLSID_CLayoutRect;

#ifdef __cplusplus

class DECLSPEC_UUID("3050f664-98b5-11cf-bb82-00aa00bdce0b")
CLayoutRect;
#endif

EXTERN_C const CLSID CLSID_CDeviceRect;

#ifdef __cplusplus

class DECLSPEC_UUID("3050f6d4-98b5-11cf-bb82-00aa00bdce0b")
CDeviceRect;
#endif

EXTERN_C const CLSID CLSID_CTemplatePrinter;

#ifdef __cplusplus

class DECLSPEC_UUID("3050f6b3-98b5-11cf-bb82-00aa00bdce0b")
CTemplatePrinter;
#endif

EXTERN_C const CLSID CLSID_CHeaderFooter;

#ifdef __cplusplus

class DECLSPEC_UUID("3050f6cd-98b5-11cf-bb82-00aa00bdce0b")
CHeaderFooter;
#endif
#endif /* __IEXTagLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long __RPC_FAR *, unsigned long            , VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long __RPC_FAR *, VARIANT __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\il21dec.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this source code is subject to the terms of the Microsoft end-user
// license agreement (EULA) under which you licensed this SOFTWARE PRODUCT.
// If you did not accept the terms of the EULA, you are not authorized to use
// this source code. For a copy of the EULA, please see the LICENSE.RTF on your
// install media.
//
//------------------------------------------------------------------------------
// File: IL21Dec.h
//
// Desc: Line 21 Decoder related definitions and interfaces for ActiveMovie.
//
//------------------------------------------------------------------------------


#ifndef __IL21DEC__
#define __IL21DEC__


//
//  Some enum data types used as line 21 decoder params by the interface
//
typedef enum _AM_LINE21_CCLEVEL {  // should we use TC1, TC2 in stead?
    AM_L21_CCLEVEL_TC2 = 0
} AM_LINE21_CCLEVEL, *PAM_LINE21_CCLEVEL ;

typedef enum _AM_LINE21_CCSERVICE {
    AM_L21_CCSERVICE_None = 0,
    AM_L21_CCSERVICE_Caption1,
    AM_L21_CCSERVICE_Caption2,
    AM_L21_CCSERVICE_Text1,
    AM_L21_CCSERVICE_Text2,
    AM_L21_CCSERVICE_XDS,
    AM_L21_CCSERVICE_DefChannel = 10,
    AM_L21_CCSERVICE_Invalid
} AM_LINE21_CCSERVICE, *PAM_LINE21_CCSERVICE ;

typedef enum _AM_LINE21_CCSTATE {
    AM_L21_CCSTATE_Off = 0,
    AM_L21_CCSTATE_On
} AM_LINE21_CCSTATE, *PAM_LINE21_CCSTATE ;

typedef enum _AM_LINE21_CCSTYLE {
    AM_L21_CCSTYLE_None = 0,
    AM_L21_CCSTYLE_PopOn,
    AM_L21_CCSTYLE_PaintOn,
    AM_L21_CCSTYLE_RollUp
} AM_LINE21_CCSTYLE, *PAM_LINE21_CCSTYLE ;

typedef enum _AM_LINE21_DRAWBGMODE {
    AM_L21_DRAWBGMODE_Opaque,
    AM_L21_DRAWBGMODE_Transparent
} AM_LINE21_DRAWBGMODE, *PAM_LINE21_DRAWBGMODE ;


#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

//
//  Line 21 Decoder standard COM interface
//
DECLARE_INTERFACE_(IAMLine21Decoder, IUnknown)
{
    public:
        //
        // Decoder options to be used by apps
        //

        // What is the decoder's level
        STDMETHOD(GetDecoderLevel)(THIS_ AM_LINE21_CCLEVEL *lpLevel) PURE ;  
        // supported level value is AM_L21Level_TC2 only
        // skipping the SetDecoderLevel( )

        // Which of the services is being currently used
        STDMETHOD(GetCurrentService)(THIS_ AM_LINE21_CCSERVICE *lpService) PURE ;  
        STDMETHOD(SetCurrentService)(THIS_ AM_LINE21_CCSERVICE Service) PURE ;  
        // supported service values are AM_L21Service_Caption1, 
        // AM_L21Service_Caption2, AM_L21Service_Text1, AM_L21Service_Text2, 
        // AM_L21Service_XDS, AM_L21Service_None)

        // Query/Set the service state (On/Off)
        // supported state values are AM_L21State_On and AM_L21State_Off
        STDMETHOD(GetServiceState)(THIS_ AM_LINE21_CCSTATE *lpState) PURE ;  
        STDMETHOD(SetServiceState)(THIS_ AM_LINE21_CCSTATE State) PURE ;  

        //
        // Output options to be used by downstream filters
        //

        // What size, bitdepth etc should the output video be
        STDMETHOD(GetOutputFormat)(THIS_ LPBITMAPINFOHEADER lpbmih) PURE ;
        // GetOutputFormat() method, if successful, returns 
        // 1.  S_FALSE if no output format has so far been defined by downstream filters
        // 2.  S_OK if an output format has already been defined by downstream filters
        STDMETHOD(SetOutputFormat)(THIS_ LPBITMAPINFO lpbmi) PURE ;

        // Specify physical color to be used in colorkeying the background 
        // for overlay mixing
        STDMETHOD(GetBackgroundColor)(THIS_ DWORD *pdwPhysColor) PURE ;
        STDMETHOD(SetBackgroundColor)(THIS_ DWORD dwPhysColor) PURE ;

        // Specify if whole output bitmap should be redrawn for each sample
        STDMETHOD(GetRedrawAlways)(THIS_ LPBOOL lpbOption) PURE ;
        STDMETHOD(SetRedrawAlways)(THIS_ BOOL bOption) PURE ;

        // Specify if the caption text background should be opaque/transparent
        STDMETHOD(GetDrawBackgroundMode)(THIS_ AM_LINE21_DRAWBGMODE *lpMode) PURE ;
        STDMETHOD(SetDrawBackgroundMode)(THIS_ AM_LINE21_DRAWBGMODE Mode) PURE ;
        // supported mode values are AM_L21_DrawBGMode_Opaque and
        // AM_L21_DrawBGMode_Transparent

} ;

#ifdef __cplusplus
}
#endif // __cplusplus
#endif // __IL21DEC__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\imgguids.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
//
// Image file format identifiers
//

#pragma once

DEFINE_GUID(IMGFMT_UNDEFINED, 0xb96b3ca9,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IMGFMT_MEMORYBMP, 0xb96b3caa,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IMGFMT_BMP, 0xb96b3cab,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IMGFMT_EMF, 0xb96b3cac,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IMGFMT_WMF, 0xb96b3cad,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IMGFMT_JPEG, 0xb96b3cae,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IMGFMT_PNG, 0xb96b3caf,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IMGFMT_GIF, 0xb96b3cb0,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IMGFMT_TIFF, 0xb96b3cb1,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IMGFMT_EXIF, 0xb96b3cb2,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IMGFMT_PHOTOCD, 0xb96b3cb3,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IMGFMT_FLASHPIX, 0xb96b3cb4,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IMGFMT_ICO, 0xb96b3cb5,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);

//
// Interface and class identifiers
//

DEFINE_GUID(IID_IImagingFactory, 0x327abda7,0x072b,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(CLSID_ImagingFactory, 0x327abda8,0x072b,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IID_IImage, 0x327abda9,0x072b,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IID_IBitmapImage, 0x327abdaa,0x072b,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IID_IImageDecoder, 0x327abdab,0x072b,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IID_IImageEncoder, 0x327abdac,0x072b,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IID_IImageSink, 0x327abdae,0x072b,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IID_IBasicBitmapOps, 0x327abdaf,0x072b,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IID_IImageBytes,0x025d1823,0x6c7d,0x447b,0xbb, 0xdb, 0xa3, 0xcb, 0xc3, 0xdf, 0xa2, 0xfc);

//
// Predefined multi-frame dimension IDs
//

DEFINE_GUID(FRAMEDIM_TIME, 0x6aedbd6d,0x3fb5,0x418a,0x83,0xa6,0x7f,0x45,0x22,0x9d,0xc8,0x72);
DEFINE_GUID(FRAMEDIM_RESOLUTION, 0x84236f7b,0x3bd3,0x428f,0x8d,0xab,0x4e,0xa1,0x43,0x9c,0xa3,0x15);
DEFINE_GUID(FRAMEDIM_PAGE, 0x7462dc86,0x6180,0x4c7e,0x8e,0x3f,0xee,0x73,0x33,0xa7,0xa4,0x83);

//
// Property sets
//

DEFINE_GUID(FMTID_ImageInformation, 0xe5836cbe,0x5eef,0x4f1d,0xac,0xde,0xae,0x4c,0x43,0xb6,0x08,0xce);
DEFINE_GUID(FMTID_JpegAppHeaders, 0x1c4afdcd,0x6177,0x43cf,0xab,0xc7,0x5f,0x51,0xaf,0x39,0xee,0x85);

//
// Decoder parameter sets
//
DEFINE_GUID(DECODER_TRANSCOLOR, 0xb7a98c8f,0xdce7,0x457d,0xbf,0xa5,0xce,0xa7,0x1b,0xd1,0x4d,0xd6);
DEFINE_GUID(DECODER_TRANSRANGE, 0xabeed189,0xd988,0x4d03,0xb4,0x25,0x57,0x10,0x55,0xc7,0x6a,0xd1);
DEFINE_GUID(DECODER_OUTPUTCHANNEL, 0x2ff8f51e,0x724d,0x45fe,0x86,0xce,0x17,0x77,0xa0,0x56,0xda,0x60);
DEFINE_GUID(DECODER_ICONRES, 0x5c656eec,0xe94f,0x45ba,0xa6,0xf6,0x10,0x62,0xe8,0x5f,0x4a,0x7f);
DEFINE_GUID(DECODER_USEICC,  0x1d6347c4,0x5ec2,0x4070,0x81,0x4d,0x7a,0x6e,0x39,0xa4,0x23,0xa2);

//
// Encoder parameter sets
//
DEFINE_GUID(ENCODER_COMPRESSION, 0xe09d739d,0xccd4,0x44ee,0x8e,0xba,0x3f,0xbf,0x8b,0xe4,0xfc,0x58);
DEFINE_GUID(ENCODER_COLORDEPTH, 0x66087055,0xad66,0x4c7c,0x9a,0x18,0x38,0xa2,0x31,0x0b,0x83,0x37);
DEFINE_GUID(ENCODER_SCANMETHOD, 0x3a4e2661,0x3109,0x4e56,0x85,0x36,0x42,0xc1,0x56,0xe7,0xdc,0xfa);
DEFINE_GUID(ENCODER_VERSION, 0x24d18c76,0x814a,0x41a4,0xbf,0x53,0x1c,0x21,0x9c,0xcc,0xf7,0x97);
DEFINE_GUID(ENCODER_RENDERMETHOD, 0x6d42c53a,0x229a,0x4825,0x8b,0xb7,0x5c,0x99,0xe2,0xb9,0xa8,0xb8);
DEFINE_GUID(ENCODER_QUALITY, 0x1d5be4b5,0xfa4a,0x452d,0x9c,0xdd,0x5d,0xb3,0x51,0x05,0xe7,0xeb);
DEFINE_GUID(ENCODER_ROTATION,0x109555d4,0x2ab6,0x4379,0xa8,0x3f,0x5d,0x78,0xfa,0x53,0x8c,0x45);
DEFINE_GUID(ENCODER_TRANSFORMATION,0x8d0eb2d1,0xa58e,0x4ea8,0xaa,0x14,0x10,0x80,0x74,0xb7,0xb6,0xf9);
DEFINE_GUID(ENCODER_LUMINANCE_TABLE,0xedb33bce,0x0266,0x4a77,0xb9,0x04,0x27,0x21,0x60,0x99,0xe7,0x17);
DEFINE_GUID(ENCODER_CHROMINANCE_TABLE,0xf2e455dc,0x09b3,0x4316,0x82,0x60,0x67,0x6a,0xda,0x32,0x48,0x1c);
DEFINE_GUID(ENCODER_SAVE_FLAG,0x292266fc,0xac40,0x47bf,0x8c, 0xfc, 0xa8, 0x5b, 0x89, 0xa6, 0x55, 0xde);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\imaging.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//

#ifndef _IMAGING_H
#define _IMAGING_H

#include <GdiplusPixelFormats.h>
#include <GdiplusImaging.h>

//
// Imaging library GUIDS:
//  image file format identifiers
//  interface and class identifers
//

#include <imgguids.h>

// Default bitmap resolution

#define DEFAULT_RESOLUTION 96   // most display screens are set to 96 dpi

// Default thumbnail image size in pixels

#define DEFAULT_THUMBNAIL_SIZE 120


//
// Image Property types
//

#define TAG_TYPE_BYTE       1   // 8-bit unsigned int
#define TAG_TYPE_ASCII      2   // 8-bit byte containing one 7-bit ASCII code.
                                // NULL terminated.
#define TAG_TYPE_SHORT      3   // 16-bit unsigned int
#define TAG_TYPE_LONG       4   // 32-bit unsigned int
#define TAG_TYPE_RATIONAL   5   // Two LONGs.  The first LONG is the numerator,
                                // the second LONG expresses the denomintor.
#define TAG_TYPE_UNDEFINED  7   // 8-bit byte that can take any value depending
                                // on field definition
#define TAG_TYPE_SLONG      9   // 32-bit singed integer (2's compliment
                                // notation)
#define TAG_TYPE_SRATIONAL  10  // Two SLONGs. First is numerator, second is
                                // denominator.


//
// Image property ID tags (PROPID's from the EXIF tags)
//

#define TAG_EXIF_IFD            0x8769
#define TAG_GPS_IFD             0x8825

#define TAG_NEW_SUBFILE_TYPE    0x00FE
#define TAG_SUBFILE_TYPE        0x00FF
#define TAG_IMAGE_WIDTH         0x0100
#define TAG_IMAGE_HEIGHT        0x0101
#define TAG_BITS_PER_SAMPLE     0x0102
#define TAG_COMPRESSION         0x0103
#define TAG_PHOTOMETRIC_INTERP  0x0106
#define TAG_THRESH_HOLDING      0x0107
#define TAG_CELL_WIDTH          0x0108
#define TAG_CELL_HEIGHT         0x0109
#define TAG_FILL_ORDER          0x010A
#define TAG_DOCUMENT_NAME       0x010D
#define TAG_IMAGE_DESCRIPTION   0x010E
#define TAG_EQUIP_MAKE          0x010F
#define TAG_EQUIP_MODEL         0x0110
#define TAG_STRIP_OFFSETS       0x0111
#define TAG_ORIENTATION         0x0112
#define TAG_SAMPLES_PER_PIXEL   0x0115
#define TAG_ROWS_PER_STRIP      0x0116
#define TAG_STRIP_BYTES_COUNT   0x0117
#define TAG_MIN_SAMPLE_VALUE    0x0118
#define TAG_MAX_SAMPLE_VALUE    0x0119
#define TAG_X_RESOLUTION        0x011A  // Image resolution in width direction
#define TAG_Y_RESOLUTION        0x011B  // Image resolution in height direction
#define TAG_PLANAR_CONFIG       0x011C  // Image data arrangement
#define TAG_PAGE_NAME           0x011D
#define TAG_X_POSITION          0x011E
#define TAG_Y_POSITION          0x011F
#define TAG_FREE_OFFSET         0x0120
#define TAG_FREE_BYTE_COUNTS    0x0121
#define TAG_GRAY_RESPONSE_UNIT  0x0122
#define TAG_GRAY_RESPONSE_CURVE 0x0123
#define TAG_T4_OPTION           0x0124
#define TAG_T6_OPTION           0x0125
#define TAG_RESOLUTION_UNIT     0x0128  // Unit of X and Y resolution
#define TAG_PAGE_NUMBER         0x0129
#define TAG_TRANSFER_FUNCTION   0x012D
#define TAG_SOFTWARE_USED       0x0131
#define TAG_DATE_TIME           0x0132
#define TAG_ARTIST              0x013B
#define TAG_HOST_COMPUTER       0x013C
#define TAG_PREDICTOR           0x013D
#define TAG_WHITE_POINT         0x013E
#define TAG_PRIMAY_CHROMATICS   0x013F
#define TAG_COLOR_MAP           0x0140
#define TAG_HALFTONE_HINTS      0x0141
#define TAG_TILE_WIDTH          0x0142
#define TAG_TILE_LENGTH         0x0143
#define TAG_TILE_OFFSET         0x0144
#define TAG_TILE_BYTE_COUNTS    0x0145
#define TAG_INK_SET             0x014C
#define TAG_INK_NAMES           0x014D
#define TAG_NUMBER_OF_INKS      0x014E
#define TAG_DOT_RANGE           0x0150
#define TAG_TARGET_PRINTER      0x0151
#define TAG_EXTRA_SAMPLES       0x0152
#define TAG_SAMPLE_FORMAT       0x0153
#define TAG_SMIN_SAMPLE_VALUE   0x0154
#define TAG_SMAX_SAMPLE_VALUE   0x0155
#define TAG_TRANSFER_RANGE      0x0156

#define TAG_JPEG_PROC           0x0200
#define TAG_JPEG_INTER_FORMAT   0x0201
#define TAG_JPEG_INTER_LENGTH   0x0202
#define TAG_JPEG_RESTART_INTERVAL     0x0203
#define TAG_JPEG_LOSSLESS_PREDICTORS  0x0205
#define TAG_JPEG_POINT_TRANSFORMS     0x0206
#define TAG_JPEG_Q_TABLES       0x0207
#define TAG_JPEG_DC_TABLES      0x0208
#define TAG_JPEG_AC_TABLES      0x0209

#define TAG_YCbCr_COEFFICIENTS  0x0211
#define TAG_YCbCr_SUBSAMPLING   0x0212
#define TAG_YCbCr_POSITIONING   0x0213
#define TAG_REF_BLACK_WHITE     0x0214

// ICC profile and gamma
#define TAG_ICC_PROFILE         0x8773      // This TAG is defined by ICC
                                            // for embedded ICC in TIFF
#define TAG_GAMMA               0x0301
#define TAG_ICC_PROFILE_DESCRIPTOR  0x0302
#define TAG_SRGB_RENDERING_INTENT   0x0303

#define TAG_IMAGE_TITLE         0x0320

#define TAG_COPYRIGHT           0x8298

// Extra TAGs (Like Adobe Image Information tags etc.)

#define TAG_RESOLUTION_X_UNIT           0x5001
#define TAG_RESOLUTION_Y_UNIT           0x5002
#define TAG_RESOLUTION_X_LENGTH_UNIT    0x5003
#define TAG_RESOLUTION_Y_LENGTH_UNIT    0x5004
#define TAG_PRINT_FLAGS                 0x5005
#define TAG_PRINT_FLAGS_VERSION         0x5006
#define TAG_PRINT_FLAGS_CROP            0x5007
#define TAG_PRINT_FLAGS_BLEEDWIDTH      0x5008
#define TAG_PRINT_FLAGS_BLEEDWIDTHSCALE 0x5009
#define TAG_HALFTONE_LPI                0x500A
#define TAG_HALFTONE_LPI_UNIT           0x500B
#define TAG_HALFTONE_DEGREE             0x500C
#define TAG_HALFTONE_SHAPE              0x500D
#define TAG_HALFTONE_MISC               0x500E
#define TAG_HALFTONE_SCREEN             0x500F
#define TAG_JPEG_QUALITY                0x5010
#define TAG_GRID_SIZE                   0x5011
#define TAG_THUMBNAIL_FORMAT            0x5012  // 1 = JPEG, 0 = RAW RGB
#define TAG_THUMBNAIL_WIDTH             0x5013
#define TAG_THUMBNAIL_HEIGHT            0x5014
#define TAG_THUMBNAIL_COLORDEPTH        0x5015
#define TAG_THUMBNAIL_PLANES            0x5016
#define TAG_THUMBNAIL_RAWBYTES          0x5017
#define TAG_THUMBNAIL_SIZE              0x5018
#define TAG_THUMBNAIL_COMPRESSED_SIZE   0x5019
#define TAG_COLORTRANSFER_FUNCTION      0x501A
#define TAG_THUMBNAIL_DATA              0x501B  // RAW thumbnail bits in JPEG
                                                // format or RGB format depends
                                                // on TAG_THUMBNAIL_FORMAT

// Thumbnail related TAGs
                                                
#define TAG_THUMBNAIL_IMAGE_WIDTH       0x5020  // Thumbnail width
#define TAG_THUMBNAIL_IMAGE_HEIGHT      0x5021  // Thumbnail height
#define TAG_THUMBNAIL_BITS_PER_SAMPLE   0x5022  // Number of bits per component
#define TAG_THUMBNAIL_COMPRESSION       0x5023  // Compression Scheme
#define TAG_THUMBNAIL_PHOTOMETRIC_INTERP 0x5024 // Pixel composition
#define TAG_THUMBNAIL_IMAGE_DESCRIPTION 0x5025  // Image Tile
#define TAG_THUMBNAIL_EQUIP_MAKE        0x5026  // Manufacturer of Image Input
                                                // equipment
#define TAG_THUMBNAIL_EQUIP_MODEL       0x5027  // Model of Image input
                                                // equipment
#define TAG_THUMBNAIL_STRIP_OFFSETS     0x5028  // Image data location
#define TAG_THUMBNAIL_ORIENTATION       0x5029  // Orientation of image
#define TAG_THUMBNAIL_SAMPLES_PER_PIXEL 0x502A  // Number of components
#define TAG_THUMBNAIL_ROWS_PER_STRIP    0x502B  // Number of rows per strip
#define TAG_THUMBNAIL_STRIP_BYTES_COUNT 0x502C  // Bytes per compressed strip
#define TAG_THUMBNAIL_RESOLUTION_X      0x502D  // Resolution in width direction
#define TAG_THUMBNAIL_RESOLUTION_Y      0x502E  // Resolution in height direc
#define TAG_THUMBNAIL_PLANAR_CONFIG     0x502F  // Image data arrangement
#define TAG_THUMBNAIL_RESOLUTION_UNIT   0x5030  // Unit of X and Y Resolution
#define TAG_THUMBNAIL_TRANSFER_FUNCTION 0x5031  // Transfer function
#define TAG_THUMBNAIL_SOFTWARE_USED     0x5032  // Software used
#define TAG_THUMBNAIL_DATE_TIME         0x5033  // File change date and time
#define TAG_THUMBNAIL_ARTIST            0x5034  // Person who created the image
#define TAG_THUMBNAIL_WHITE_POINT       0x5035  // White point chromaticity
#define TAG_THUMBNAIL_PRIMAY_CHROMATICS 0x5036  // Chromaticities of primaries
#define TAG_THUMBNAIL_YCbCr_COEFFICIENTS 0x5037 // Color space transformation
                                                // coefficients
#define TAG_THUMBNAIL_YCbCr_SUBSAMPLING 0x5038  // Subsampling ratio of Y to C
#define TAG_THUMBNAIL_YCbCr_POSITIONING 0x5039  // Y and C position
#define TAG_THUMBNAIL_REF_BLACK_WHITE   0x503A  // Pair of black and white
                                                // reference values
#define TAG_THUMBNAIL_COPYRIGHT         0x503B  // CopyRight holder

// Special JPEG internal values

#define TAG_LUMINANCE_TABLE             0x5090
#define TAG_CHROMINANCE_TABLE           0x5091

// GIF image

#define TAG_FRAMEDELAY                  0x5100
#define TAG_LOOPCOUNT                   0x5101

// PNG Image

#define TAG_PIXEL_UNIT                  0x5110  // Unit specifier for pixel/unit
#define TAG_PIXEL_PER_UNIT_X            0x5111  // Pixels per unit in X
#define TAG_PIXEL_PER_UNIT_Y            0x5112  // Pixels per unit in Y
#define TAG_PALETTE_HISTOGRAM           0x5113  // Palette histogram

// EXIF specific tag

#define EXIF_TAG_EXPOSURE_TIME  0x829A
#define EXIF_TAG_F_NUMBER       0x829D

#define EXIF_TAG_EXPOSURE_PROG  0x8822
#define EXIF_TAG_SPECTRAL_SENSE 0x8824
#define EXIF_TAG_ISO_SPEED      0x8827
#define EXIF_TAG_OECF           0x8828

#define EXIF_TAG_VER            0x9000
#define EXIF_TAG_D_T_ORIG       0x9003 // Date & time of original
#define EXIF_TAG_D_T_DIGITIZED  0x9004 // Date & time of digital data generation

#define EXIF_TAG_COMP_CONFIG    0x9101
#define EXIF_TAG_COMP_BPP       0x9102

#define EXIF_TAG_SHUTTER_SPEED  0x9201
#define EXIF_TAG_APERATURE      0x9202
#define EXIF_TAG_BRIGHTNESS     0x9203
#define EXIF_TAG_EXPOSURE_BIAS  0x9204
#define EXIF_TAG_MAX_APERATURE  0x9205
#define EXIF_TAG_SUBJECT_DIST   0x9206
#define EXIF_TAG_METERING_MODE  0x9207
#define EXIF_TAG_LIGHT_SOURCE   0x9208
#define EXIF_TAG_FLASH          0x9209
#define EXIF_TAG_FOCAL_LENGTH   0x920A
#define EXIF_TAG_MAKER_NOTE     0x927C
#define EXIF_TAG_USER_COMMENT   0x9286
#define EXIF_TAG_D_T_SUBSEC     0x9290  // Date & Time subseconds
#define EXIF_TAG_D_T_ORIG_SS    0x9291  // Date & Time original subseconds
#define EXIF_TAG_D_T_DIG_SS     0x9292  // Date & TIme digitized subseconds

#define EXIF_TAG_FPX_VER        0xA000
#define EXIF_TAG_COLOR_SPACE    0xA001
#define EXIF_TAG_PIX_X_DIM      0xA002
#define EXIF_TAG_PIX_Y_DIM      0xA003
#define EXIF_TAG_RELATED_WAV    0xA004  // related sound file
#define EXIF_TAG_INTEROP        0xA005
#define EXIF_TAG_FLASH_ENERGY   0xA20B
#define EXIF_TAG_SPATIAL_FR     0xA20C  // Spatial Frequency Response
#define EXIF_TAG_FOCAL_X_RES    0xA20E  // Focal Plane X Resolution
#define EXIF_TAG_FOCAL_Y_RES    0xA20F  // Focal Plane Y Resolution
#define EXIF_TAG_FOCAL_RES_UNIT 0xA210  // Focal Plane Resolution Unit
#define EXIF_TAG_SUBJECT_LOC    0xA214
#define EXIF_TAG_EXPOSURE_INDEX 0xA215
#define EXIF_TAG_SENSING_METHOD 0xA217
#define EXIF_TAG_FILE_SOURCE    0xA300
#define EXIF_TAG_SCENE_TYPE     0xA301
#define EXIF_TAG_CFA_PATTERN    0xA302

#define GPS_TAG_VER             0x0000
#define GPS_TAG_LATTITUDE_REF   0x0001
#define GPS_TAG_LATTITUDE       0x0002
#define GPS_TAG_LONGITUDE_REF   0x0003
#define GPS_TAG_LONGITUDE       0x0004
#define GPS_TAG_ALTITUDE_REF    0x0005
#define GPS_TAG_ALTITUDE        0x0006
#define GPS_TAG_GPS_TIME        0x0007
#define GPS_TAG_GPS_SATELLITES  0x0008
#define GPS_TAG_GPS_STATUS      0x0009
#define GPS_TAG_GPS_MEASURE_MODE 0x00A
#define GPS_TAG_GPS_DOP         0x000B  // Measurement precision
#define GPS_TAG_SPEED_REF       0x000C
#define GPS_TAG_SPEED           0x000D
#define GPS_TAG_TRACK_REF       0x000E
#define GPS_TAG_TRACK           0x000F
#define GPS_TAG_IMG_DIR_REF     0x0010
#define GPS_TAG_IMG_DIR         0x0011
#define GPS_TAG_MAP_DATUM       0x0012
#define GPS_TAG_DEST_LAT_REF    0x0013
#define GPS_TAG_DEST_LAT        0x0014
#define GPS_TAG_DEST_LONG_REF   0x0015
#define GPS_TAG_DEST_LONG       0x0016
#define GPS_TAG_DEST_BEAR_REF   0x0017
#define GPS_TAG_DEST_BEAR       0x0018
#define GPS_TAG_DEST_DIST_REF   0x0019
#define GPS_TAG_DEST_DIST       0x001A

// Exif v2.2 GPS tags
#define GPS_TAG_GPS_PROCESSING_METHOD   0x001B
#define GPS_TAG_GPS_AREA        0x001C
#define GPS_TAG_GPS_DATE        0x001D
#define GPS_TAG_GPS_DIFFERENTIAL    0x001E

#define MAKEARGB(a, r, g, b) \
        (((ARGB) ((a) & 0xff) << ALPHA_SHIFT) | \
         ((ARGB) ((r) & 0xff) <<   RED_SHIFT) | \
         ((ARGB) ((g) & 0xff) << GREEN_SHIFT) | \
         ((ARGB) ((b) & 0xff) <<  BLUE_SHIFT))

typedef PixelFormat PixelFormatID;

// Map COM Flags to GDI+ Flags
#define PIXFMTFLAG_INDEXED      PixelFormatIndexed
#define PIXFMTFLAG_GDI          PixelFormatGDI
#define PIXFMTFLAG_ALPHA        PixelFormatAlpha
#define PIXFMTFLAG_PALPHA       PixelFormatPAlpha
#define PIXFMTFLAG_EXTENDED     PixelFormatExtended
#define PIXFMTFLAG_CANONICAL    PixelFormatCanonical
#define PIXFMT_UNDEFINED        PixelFormatUndefined
#define PIXFMT_DONTCARE         PixelFormatDontCare
#define PIXFMT_1BPP_INDEXED     PixelFormat1bppIndexed
#define PIXFMT_4BPP_INDEXED     PixelFormat4bppIndexed
#define PIXFMT_8BPP_INDEXED     PixelFormat8bppIndexed
#define PIXFMT_16BPP_RGB555     PixelFormat16bppRGB555
#define PIXFMT_16BPP_RGB565     PixelFormat16bppRGB565
#define PIXFMT_16BPP_ARGB1555   PixelFormat16bppARGB1555
#define PIXFMT_24BPP_RGB        PixelFormat24bppRGB
#define PIXFMT_32BPP_RGB        PixelFormat32bppRGB
#define PIXFMT_32BPP_ARGB       PixelFormat32bppARGB
#define PIXFMT_32BPP_PARGB      PixelFormat32bppPARGB
#define PIXFMT_48BPP_RGB        PixelFormat48bppRGB
#define PIXFMT_64BPP_ARGB       PixelFormat64bppARGB
#define PIXFMT_64BPP_PARGB      PixelFormat64bppPARGB

#define PIXFMT_24BPP_BGR        (15 | (24 << 8) | PixelFormatGDI)
#define PIXFMT_MAX              PixelFormatMax + 1

#define PALFLAG_HASALPHA        PaletteFlagsHasAlpha
#define PALFLAG_GRAYSCALE       PaletteFlagsGrayScale
#define PALFLAG_HALFTONE        PaletteFlagsHalftone

#define IMGLOCK_READ              ImageLockModeRead
#define IMGLOCK_WRITE             ImageLockModeWrite
#define IMGLOCK_USERINPUTBUF      ImageLockModeUserInputBuf

#define IMGFLAG_NONE                ImageFlagsNone
#define IMGFLAG_SCALABLE            ImageFlagsScalable
#define IMGFLAG_HASALPHA            ImageFlagsHasAlpha
#define IMGFLAG_HASTRANSLUCENT      ImageFlagsHasTranslucent
#define IMGFLAG_PARTIALLY_SCALABLE  ImageFlagsPartiallyScalable
#define IMGFLAG_COLORSPACE_RGB      ImageFlagsColorSpaceRGB
#define IMGFLAG_COLORSPACE_CMYK     ImageFlagsColorSpaceCMYK
#define IMGFLAG_COLORSPACE_GRAY     ImageFlagsColorSpaceGRAY
#define IMGFLAG_COLORSPACE_YCBCR    ImageFlagsColorSpaceYCBCR
#define IMGFLAG_COLORSPACE_YCCK     ImageFlagsColorSpaceYCCK
#define IMGFLAG_HASREALDPI          ImageFlagsHasRealDPI
#define IMGFLAG_HASREALPIXELSIZE    ImageFlagsHasRealPixelSize
#define IMGFLAG_READONLY            ImageFlagsReadOnly
#define IMGFLAG_CACHING             ImageFlagsCaching
#define IMGFLAGS_VALID              ImageFlagsValid

#define ImageFlag                   ImageFlags


//
// Decoder flags
//

/* Only used in COM interface */
enum DecoderInitFlag
{
    DecoderInitFlagNone        = 0,

    // NOBLOCK indicates that the caller requires non-blocking
    // behavior.  This will be honored only by non-blocking decoders, that
    // is, decoders that don't have the IMGCODEC_BLOCKING_DECODE flag.

    DecoderInitFlagNoBlock     = 0x0001,

    // Choose built-in decoders first before looking at any
    // installed plugin decoders.

    DecoderInitFlagBuiltIn1st  = 0x0002
};

#define DECODERINIT_NONE          DecoderInitFlagNone
#define DECODERINIT_NOBLOCK       DecoderInitFlagNoBlock
#define DECODERINIT_BUILTIN1ST    DecoderInitFlagBuiltIn1st

/* Only used in COM interface */
enum BufferDisposalFlag
{
    BufferDisposalFlagNone,
    BufferDisposalFlagGlobalFree,
    BufferDisposalFlagCoTaskMemFree,
    BufferDisposalFlagUnmapView
};
    
#define DISPOSAL_NONE            BufferDisposalFlagNone
#define DISPOSAL_GLOBALFREE      BufferDisposalFlagGlobalFree
#define DISPOSAL_COTASKMEMFREE   BufferDisposalFlagCoTaskMemFree
#define DISPOSAL_UNMAPVIEW       BufferDisposalFlagUnmapView

//---------------------------------------------------------------------------
// Intepolation hints used by resize/rotation operations
//---------------------------------------------------------------------------
enum InterpolationHint
{
    InterpolationHintDefault,
    InterpolationHintNearestNeighbor,
    InterpolationHintBilinear,
    InterpolationHintAveraging,
    InterpolationHintBicubic
};

#define INTERP_DEFAULT              InterpolationHintDefault
#define INTERP_NEAREST_NEIGHBOR     InterpolationHintNearestNeighbor
#define INTERP_BILINEAR             InterpolationHintBilinear
#define INTERP_AVERAGING            InterpolationHintAveraging
#define INTERP_BICUBIC              InterpolationHintBicubic

#define IMGCODEC_ENCODER          ImageCodecFlagsEncoder
#define IMGCODEC_DECODER          ImageCodecFlagsDecoder
#define IMGCODEC_SUPPORT_BITMAP   ImageCodecFlagsSupportBitmap
#define IMGCODEC_SUPPORT_VECTOR   ImageCodecFlagsSupportVector
#define IMGCODEC_SEEKABLE_ENCODE  ImageCodecFlagsSeekableEncode
#define IMGCODEC_BLOCKING_DECODE  ImageCodecFlagsBlockingDecode

#define IMGCODEC_BUILTIN          ImageCodecFlagsBuiltin
#define IMGCODEC_SYSTEM           ImageCodecFlagsSystem
#define IMGCODEC_USER             ImageCodecFlagsUser

//
// Identifier for channel(s) in a pixel
//
/* Only used internally */
enum ChannelID
{
    ChannelID_Alpha      = 0x00000001,
    ChannelID_Red        = 0x00000002,
    ChannelID_Green      = 0x00000004,
    ChannelID_Blue       = 0x00000008,
    ChannelID_Color      = ChannelID_Red|ChannelID_Green|ChannelID_Blue,
    ChannelID_All        = ChannelID_Color|ChannelID_Alpha,
    
    ChannelID_Intensity  = 0x00010000
};

//
// Data structure for communicating to an image sink
//

/* Only used internally */
enum SinkFlags
{
    // Low-word: shared with ImgFlagx

    SinkFlagsScalable          = ImageFlagsScalable,
    SinkFlagsHasAlpha          = ImageFlagsHasAlpha,
    SinkFlagsPartiallyScalable = ImageFlagsPartiallyScalable,
    
    // High-word

    SinkFlagsTopDown    = 0x00010000,
    SinkFlagsBottomUp   = 0x00020000,
    SinkFlagsFullWidth  = 0x00040000,
    SinkFlagsMultipass  = 0x00080000,
    SinkFlagsComposite  = 0x00100000,
    SinkFlagsWantProps  = 0x00200000
};

#define SINKFLAG_SCALABLE           SinkFlagsScalable
#define SINKFLAG_HASALPHA           SinkFlagsHasAlpha
#define SINKFLAG_PARTIALLY_SCALABLE SinkFlagsPartiallyScalable
#define SINKFLAG_TOPDOWN    SinkFlagsTopDown
#define SINKFLAG_BOTTOMUP   SinkFlagsBottomUp
#define SINKFLAG_FULLWIDTH  SinkFlagsFullWidth
#define SINKFLAG_MULTIPASS  SinkFlagsMultipass
#define SINKFLAG_COMPOSITE  SinkFlagsComposite
#define SINKFLAG_WANTPROPS  SinkFlagsWantProps

/* Only used internally */
struct ImageInfo
{
    GUID RawDataFormat;
    PixelFormat PixelFormat;
    UINT Width, Height;
    UINT TileWidth, TileHeight;
    double Xdpi, Ydpi;
    UINT Flags;
};

//
// Interface and class identifiers
//

interface IImagingFactory;
interface IImage;
interface IBitmapImage;
interface IImageDecoder;
interface IImageEncoder;
interface IImageSink;
interface IBasicBitmapOps;


//--------------------------------------------------------------------------
// Imaging utility factory object
//  This is a CoCreate-able object.
//--------------------------------------------------------------------------

#ifdef _WIN32_WCE
interface DECLSPEC_UUID("327ABDA7-072B-11D3-9D7B-0000F81EF32E")
#else
MIDL_INTERFACE("327ABDA7-072B-11D3-9D7B-0000F81EF32E")
#endif  // _WIN32_WCE
IImagingFactory : public IUnknown
{
public:

    // Create an image object from an input stream
    //  stream doesn't have to seekable
    //  caller should Release the stream if call is successful

    STDMETHOD(CreateImageFromStream)(
        IN IStream* stream,
        OUT IImage** image
        ) = 0;

    // Create an image object from a file

    STDMETHOD(CreateImageFromFile)(
        IN const WCHAR* filename,
        OUT IImage** image
        ) = 0;
    
    // Create an image object from a memory buffer

    STDMETHOD(CreateImageFromBuffer)(
        IN const VOID* buf,
        IN UINT size,
        IN BufferDisposalFlag disposalFlag,
        OUT IImage** image
        ) = 0;

    // Create a new bitmap image object

    STDMETHOD(CreateNewBitmap)(
        IN UINT width,
        IN UINT height,
        IN PixelFormatID pixelFormat,
        OUT IBitmapImage** bitmap
        ) = 0;

    // Create a bitmap image from an IImage object

    STDMETHOD(CreateBitmapFromImage)(
        IN IImage* image,
        IN OPTIONAL UINT width,
        IN OPTIONAL UINT height,
        IN OPTIONAL PixelFormatID pixelFormat,
        IN InterpolationHint hints,
        OUT IBitmapImage** bitmap
        ) = 0;

    // Create a new bitmap image object on user-supplied memory buffer

    STDMETHOD(CreateBitmapFromBuffer)(
        IN BitmapData* bitmapData,
        OUT IBitmapImage** bitmap
        ) = 0;

    // Create an image decoder object to process the given input stream

    STDMETHOD(CreateImageDecoder)(
        IN IStream* stream,
        IN DecoderInitFlag flags,
        OUT IImageDecoder** decoder
        ) = 0;

    // Create an image encoder object that can output data in the
    // specified image file format.

    STDMETHOD(CreateImageEncoderToStream)(
        IN const CLSID* clsid,
        IN IStream* stream,
        OUT IImageEncoder** encoder
        ) = 0;

    STDMETHOD(CreateImageEncoderToFile)(
        IN const CLSID* clsid,
        IN const WCHAR* filename,
        OUT IImageEncoder** encoder
        ) = 0;

    // Get a list of all currently installed image decoders

    STDMETHOD(GetInstalledDecoders)(
        OUT UINT* count,
        OUT ImageCodecInfo** decoders
        ) = 0;

    // Get a list of all currently installed image decoders

    STDMETHOD(GetInstalledEncoders)(
        OUT UINT* count,
        OUT ImageCodecInfo** encoders
        ) = 0;

    // Install an image encoder / decoder
    //  caller should do the regular COM component
    //  installation before calling this method

    STDMETHOD(InstallImageCodec)(
        IN const ImageCodecInfo* codecInfo
        ) = 0;

    // Uninstall an image encoder / decoder

    STDMETHOD(UninstallImageCodec)(
        IN const WCHAR* codecName,
        IN UINT flags
        ) = 0;
};


//--------------------------------------------------------------------------
// Image interface
//  bitmap image
//  vector image
//  procedural image
//--------------------------------------------------------------------------

#ifdef _WIN32_WCE
interface DECLSPEC_UUID("327ABDA9-072B-11D3-9D7B-0000F81EF32E")
#else
MIDL_INTERFACE("327ABDA9-072B-11D3-9D7B-0000F81EF32E")
#endif  // _WIN32_WCE
IImage : public IUnknown
{
public:

    // Get the device-independent physical dimension of the image
    //  in unit of 0.01mm

    STDMETHOD(GetPhysicalDimension)(
        OUT SIZE* size
        ) = 0;

    // Get basic image info

    STDMETHOD(GetImageInfo)(
        OUT ImageInfo* imageInfo
        ) = 0;

    // Set image flags

    STDMETHOD(SetImageFlags)(
        IN UINT flags
        ) = 0;

    // Display the image in a GDI device context

    STDMETHOD(Draw)(
        IN HDC hdc,
        IN const RECT* dstRect,
        IN OPTIONAL const RECT* srcRect
        ) = 0;

    // Push image data into an IImageSink

    STDMETHOD(PushIntoSink)(
        IN IImageSink* sink
        ) = 0;

    // Get a thumbnail representation for the image object

    STDMETHOD(GetThumbnail)(
        IN OPTIONAL UINT thumbWidth,
        IN OPTIONAL UINT thumbHeight,
        OUT IImage** thumbImage
        ) = 0;
};


//--------------------------------------------------------------------------
// Bitmap interface
//--------------------------------------------------------------------------

#ifdef _WIN32_WCE
interface DECLSPEC_UUID("327ABDAA-072B-11D3-9D7B-0000F81EF32E")
#else
MIDL_INTERFACE("327ABDAA-072B-11D3-9D7B-0000F81EF32E")
#endif  // !_WIN32_WCE
IBitmapImage : public IUnknown
{
public:

    // Get bitmap dimensions in pixels

    STDMETHOD(GetSize)(
        OUT SIZE* size
        ) = 0;

    // Get bitmap pixel format

    STDMETHOD(GetPixelFormatID)(
        OUT PixelFormatID* pixelFormat
        ) = 0;

    // Access bitmap data in the specified pixel format
    //  must support at least PIXFMT_DONTCARE and
    //  the caninocal formats.

    STDMETHOD(LockBits)(
        IN const RECT* rect,
        IN UINT flags,
        IN PixelFormatID pixelFormat,
        IN OUT BitmapData* lockedBitmapData
        ) = 0;

    STDMETHOD(UnlockBits)(
        IN const BitmapData* lockedBitmapData
        ) = 0;

    // Set/get palette associated with the bitmap image

    STDMETHOD(GetPalette)(
        OUT ColorPalette** palette
        ) = 0;

    STDMETHOD(SetPalette)(
        IN const ColorPalette* palette
        ) = 0;
};


//--------------------------------------------------------------------------
// Interface for performing basic operations on a bitmap image
//  This can be QI'ed from an IBitmapImage object.
//--------------------------------------------------------------------------

#ifdef _WIN32_WCE
interface DECLSPEC_UUID("327ABDAF-072B-11D3-9D7B-0000F81EF32E")
#else
MIDL_INTERFACE("327ABDAF-072B-11D3-9D7B-0000F81EF32E")
#endif  // _WIN32_WCE
IBasicBitmapOps : public IUnknown
{
public:

    // Clone an area of the bitmap image

    STDMETHOD(Clone)(
        IN OPTIONAL const RECT* rect,
        OUT IBitmapImage** outbmp,
        BOOL    bNeedCloneProperty
        ) = 0;

    // Flip the bitmap image in x- and/or y-direction

    STDMETHOD(Flip)(
        IN BOOL flipX,
        IN BOOL flipY,
        OUT IBitmapImage** outbmp
        ) = 0;

    // Resize the bitmap image

    STDMETHOD(Resize)(
        IN UINT newWidth,
        IN UINT newHeight,
        IN PixelFormatID pixelFormat,
        IN InterpolationHint hints,
        OUT IBitmapImage** outbmp
        ) = 0;

    // Rotate the bitmap image by the specified angle

    STDMETHOD(Rotate)(
        IN FLOAT angle,
        IN InterpolationHint hints,
        OUT IBitmapImage** outbmp
        ) = 0;

    // Adjust the brightness of the bitmap image

    STDMETHOD(AdjustBrightness)(
        IN FLOAT percent
        ) = 0;
    
    // Adjust the contrast of the bitmap image

    STDMETHOD(AdjustContrast)(
        IN FLOAT shadow,
        IN FLOAT highlight
        ) = 0;
    
    // Adjust the gamma of the bitmap image

    STDMETHOD(AdjustGamma)(
        IN FLOAT gamma
        ) = 0;
};


//--------------------------------------------------------------------------
// Image decoder interface
//--------------------------------------------------------------------------

#ifdef _WIN32_WCE
interface DECLSPEC_UUID("327ABDAB-072B-11D3-9D7B-0000F81EF32E")
#else
MIDL_INTERFACE("327ABDAB-072B-11D3-9D7B-0000F81EF32E")
#endif  // _WIN32_WCE
IImageDecoder : public IUnknown
{
public:

    // Initialize the image decoder object

    STDMETHOD(InitDecoder)(
        IN IStream* stream,
        IN DecoderInitFlag flags
        ) = 0;

    // Clean up the image decoder object

    STDMETHOD(TerminateDecoder)() = 0;

    // Start decoding the current frame

    STDMETHOD(BeginDecode)(
        IN IImageSink* sink,
        IN OPTIONAL IPropertySetStorage* newPropSet
        ) = 0;

    // Continue decoding

    STDMETHOD(Decode)() = 0;

    // Stop decoding the current frame

    STDMETHOD(EndDecode)(
        IN HRESULT statusCode
        ) = 0;

    // Query multi-frame dimensions

    STDMETHOD(GetFrameDimensionsCount)(
        OUT UINT* count
        ) = 0;

    STDMETHOD(GetFrameDimensionsList)(
        OUT GUID* dimensionIDs,
        IN OUT UINT count
        ) = 0;

    // Get number of frames for the specified dimension

    STDMETHOD(GetFrameCount)(
        IN const GUID* dimensionID,
        OUT UINT* count
        ) = 0;

    // Select currently active frame

    STDMETHOD(SelectActiveFrame)(
        IN const GUID* dimensionID,
        IN UINT frameIndex
        ) = 0;

    // Get basic information about the image

    STDMETHOD(GetImageInfo)(
        OUT ImageInfo* imageInfo
        ) = 0;

    // Get image thumbnail

    STDMETHOD(GetThumbnail)(
        IN OPTIONAL UINT thumbWidth,
        IN OPTIONAL UINT thumbHeight,
        OUT IImage** thumbImage
        ) = 0;

    // Query decoder parameters

    STDMETHOD(QueryDecoderParam)(
        IN GUID     Guid
        ) = 0;

    // Set decoder parameters

    STDMETHOD(SetDecoderParam)(
        IN GUID     Guid,
        IN UINT     Length,
        IN PVOID    Value
        ) = 0;
    
    // Property related functions

    STDMETHOD(GetPropertyCount)(
        OUT UINT* numOfProperty
        ) = 0;

    STDMETHOD(GetPropertyIdList)(
        IN UINT numOfProperty,
        IN OUT PROPID* list
        ) = 0;

    STDMETHOD(GetPropertyItemSize)(
        IN PROPID propId, 
        OUT UINT* size
        ) = 0;
    
    STDMETHOD(GetPropertyItem)(
        IN PROPID propId,
        IN UINT propSize,
        IN OUT PropertyItem* buffer
        ) = 0;

    STDMETHOD(GetPropertySize)(
        OUT UINT* totalBufferSize,
        OUT UINT* numProperties
        ) = 0;

    STDMETHOD(GetAllPropertyItems)(
        IN UINT totalBufferSize,
        IN UINT numProperties,
        IN OUT PropertyItem* allItems
        ) = 0;

    STDMETHOD(RemovePropertyItem)(
        IN PROPID   propId
        ) = 0;

    STDMETHOD(SetPropertyItem)(
        IN PropertyItem item
        ) = 0;
};


//--------------------------------------------------------------------------
// Image decode sink interface
//--------------------------------------------------------------------------

#ifdef _WIN32_WCE
interface DECLSPEC_UUID("327ABDAE-072B-11D3-9D7B-0000F81EF32E")
#else
MIDL_INTERFACE("327ABDAE-072B-11D3-9D7B-0000F81EF32E")
#endif  // _WIN32_WCE
IImageSink : public IUnknown
{
public:

    // Begin the sink process

    STDMETHOD(BeginSink)(
        IN OUT ImageInfo* imageInfo,
        OUT OPTIONAL RECT* subarea
        ) = 0;

    // End the sink process

    STDMETHOD(EndSink)(
        IN HRESULT statusCode
        ) = 0;

    // Pass the color palette to the image sink

    STDMETHOD(SetPalette)(
        IN const ColorPalette* palette
        ) = 0;

    // Ask the sink to allocate pixel data buffer

    STDMETHOD(GetPixelDataBuffer)(
        IN const RECT* rect,
        IN PixelFormatID pixelFormat,
        IN BOOL lastPass,
        OUT BitmapData* bitmapData
        ) = 0;

    // Give the sink pixel data and release data buffer

    STDMETHOD(ReleasePixelDataBuffer)(
        IN const BitmapData* bitmapData
        ) = 0;

    // Push pixel data

    STDMETHOD(PushPixelData)(
        IN const RECT* rect,
        IN const BitmapData* bitmapData,
        IN BOOL lastPass
        ) = 0;

    // Push raw image data

    STDMETHOD(PushRawData)(
        IN const VOID* buffer,
        IN UINT bufsize
        ) = 0;

    STDMETHOD(NeedTransform)(
        OUT UINT* rotation
        ) = 0;

    STDMETHOD(NeedRawProperty)(
        ) = 0;
    
    STDMETHOD(PushRawInfo)(
        IN OUT void* info
        ) = 0;

    STDMETHOD(GetPropertyBuffer)(
        IN     UINT            uiTotalBufferSize,
        IN OUT PropertyItem**  ppBuffer
        ) = 0;
    
    STDMETHOD(PushPropertyItems)(
        IN UINT             numOfItems,
        IN UINT             uiTotalBufferSize,
        IN PropertyItem*    item
        ) = 0;
};


//--------------------------------------------------------------------------
// Image encoder interface
//--------------------------------------------------------------------------

#ifdef _WIN32_WCE
interface DECLSPEC_UUID("327ABDAC-072B-11D3-9D7B-0000F81EF32E")
#else
MIDL_INTERFACE("327ABDAC-072B-11D3-9D7B-0000F81EF32E")
#endif  // _WIN32_WCE
IImageEncoder : public IUnknown
{
public:

    // Initialize the image encoder object

    STDMETHOD(InitEncoder)(
        IN IStream* stream
        ) = 0;
    
    // Clean up the image encoder object

    STDMETHOD(TerminateEncoder)() = 0;

    // Get an IImageSink interface for encoding the next frame

    STDMETHOD(GetEncodeSink)(
        OUT IImageSink** sink
        ) = 0;
    
    // Set active frame dimension

    STDMETHOD(SetFrameDimension)(
        IN const GUID* dimensionID
        ) = 0;
        
    STDMETHOD(GetEncoderParameterListSize)(
        OUT UINT* size
        ) = 0;

    STDMETHOD(GetEncoderParameterList)(
        IN UINT size,
        OUT EncoderParameters* Params
        ) = 0;

    STDMETHOD(SetEncoderParameters)(
        IN const EncoderParameters* Param
        ) = 0;
};


//--------------------------------------------------------------------------
// Imaging library error codes
//
// !!! TODO
//  How does one pick a facility code?
//
// Standard error code used:
//  E_INVALIDARG
//  E_OUTOFMEMORY
//  E_NOTIMPL
//  E_ACCESSDENIED
//  E_PENDING
//--------------------------------------------------------------------------

#define FACILITY_IMAGING        0x87b
#define MAKE_IMGERR(n)          MAKE_HRESULT(SEVERITY_ERROR, FACILITY_IMAGING, n)
#define IMGERR_OBJECTBUSY       MAKE_IMGERR(1)
#define IMGERR_NOPALETTE        MAKE_IMGERR(2)
#define IMGERR_BADLOCK          MAKE_IMGERR(3)
#define IMGERR_BADUNLOCK        MAKE_IMGERR(4)
#define IMGERR_NOCONVERSION     MAKE_IMGERR(5)
#define IMGERR_CODECNOTFOUND    MAKE_IMGERR(6)
#define IMGERR_NOFRAME          MAKE_IMGERR(7)
#define IMGERR_ABORT            MAKE_IMGERR(8)
#define IMGERR_FAILLOADCODEC    MAKE_IMGERR(9)
#define IMGERR_PROPERTYNOTFOUND MAKE_IMGERR(10)
#define IMGERR_PROPERTYNOTSUPPORTED MAKE_IMGERR(11)

#endif // !_IMAGING_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\imapi.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES.
//

#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0286 */
/* at Tue Jan 23 14:30:47 2007
 */
/* Compiler settings for ..\imapi.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __imapi_h__
#define __imapi_h__

/* Forward Declarations */ 

#ifndef __IDiscRecorder_FWD_DEFINED__
#define __IDiscRecorder_FWD_DEFINED__
typedef interface IDiscRecorder IDiscRecorder;
#endif 	/* __IDiscRecorder_FWD_DEFINED__ */


#ifndef __IEnumDiscRecorders_FWD_DEFINED__
#define __IEnumDiscRecorders_FWD_DEFINED__
typedef interface IEnumDiscRecorders IEnumDiscRecorders;
#endif 	/* __IEnumDiscRecorders_FWD_DEFINED__ */


#ifndef __IEnumDiscMasterFormats_FWD_DEFINED__
#define __IEnumDiscMasterFormats_FWD_DEFINED__
typedef interface IEnumDiscMasterFormats IEnumDiscMasterFormats;
#endif 	/* __IEnumDiscMasterFormats_FWD_DEFINED__ */


#ifndef __IRedbookDiscMaster_FWD_DEFINED__
#define __IRedbookDiscMaster_FWD_DEFINED__
typedef interface IRedbookDiscMaster IRedbookDiscMaster;
#endif 	/* __IRedbookDiscMaster_FWD_DEFINED__ */


#ifndef __IJolietDiscMaster_FWD_DEFINED__
#define __IJolietDiscMaster_FWD_DEFINED__
typedef interface IJolietDiscMaster IJolietDiscMaster;
#endif 	/* __IJolietDiscMaster_FWD_DEFINED__ */


#ifndef __IDiscMasterProgressEvents_FWD_DEFINED__
#define __IDiscMasterProgressEvents_FWD_DEFINED__
typedef interface IDiscMasterProgressEvents IDiscMasterProgressEvents;
#endif 	/* __IDiscMasterProgressEvents_FWD_DEFINED__ */


#ifndef __IDiscMaster_FWD_DEFINED__
#define __IDiscMaster_FWD_DEFINED__
typedef interface IDiscMaster IDiscMaster;
#endif 	/* __IDiscMaster_FWD_DEFINED__ */


#ifndef __MSDiscRecorderObj_FWD_DEFINED__
#define __MSDiscRecorderObj_FWD_DEFINED__

#ifdef __cplusplus
typedef class MSDiscRecorderObj MSDiscRecorderObj;
#else
typedef struct MSDiscRecorderObj MSDiscRecorderObj;
#endif /* __cplusplus */

#endif 	/* __MSDiscRecorderObj_FWD_DEFINED__ */


#ifndef __MSDiscMasterObj_FWD_DEFINED__
#define __MSDiscMasterObj_FWD_DEFINED__

#ifdef __cplusplus
typedef class MSDiscMasterObj MSDiscMasterObj;
#else
typedef struct MSDiscMasterObj MSDiscMasterObj;
#endif /* __cplusplus */

#endif 	/* __MSDiscMasterObj_FWD_DEFINED__ */


#ifndef __MSEnumDiscRecordersObj_FWD_DEFINED__
#define __MSEnumDiscRecordersObj_FWD_DEFINED__

#ifdef __cplusplus
typedef class MSEnumDiscRecordersObj MSEnumDiscRecordersObj;
#else
typedef struct MSEnumDiscRecordersObj MSEnumDiscRecordersObj;
#endif /* __cplusplus */

#endif 	/* __MSEnumDiscRecordersObj_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_imapi_0000 */
/* [local] */ 

// this assert will cause compilation breaks in clients whose code would cause stack corruption
// when writing to our boolean pointer
C_ASSERT(sizeof(boolean) == 1);


extern RPC_IF_HANDLE __MIDL_itf_imapi_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_imapi_0000_v0_0_s_ifspec;

#ifndef __IDiscRecorder_INTERFACE_DEFINED__
#define __IDiscRecorder_INTERFACE_DEFINED__

/* interface IDiscRecorder */
/* [unique][helpstring][uuid][object] */ 


enum MEDIA_TYPES
    {	MEDIA_CDDA_CDROM	= 1,
	MEDIA_CD_ROM_XA	= MEDIA_CDDA_CDROM + 1,
	MEDIA_CD_I	= MEDIA_CD_ROM_XA + 1,
	MEDIA_CD_EXTRA	= MEDIA_CD_I + 1,
	MEDIA_CD_OTHER	= MEDIA_CD_EXTRA + 1,
	MEDIA_SPECIAL	= MEDIA_CD_OTHER + 1
    };

enum MEDIA_FLAGS
    {	MEDIA_BLANK	= 0x1,
	MEDIA_RW	= 0x2,
	MEDIA_WRITABLE	= 0x4,
	MEDIA_FORMAT_UNUSABLE_BY_IMAPI	= 0x8
    };

enum RECORDER_TYPES
    {	RECORDER_CDR	= 0x1,
	RECORDER_CDRW	= 0x2
    };
#define	RECORDER_DOING_NOTHING	( 0 )

#define	RECORDER_OPENED	( 0x1 )

#define	RECORDER_BURNING	( 0x2 )


EXTERN_C const IID IID_IDiscRecorder;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("85AC9776-CA88-4cf2-894E-09598C078A41")
    IDiscRecorder : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Init( 
            /* [size_is][in] */ byte __RPC_FAR *pbyUniqueID,
            /* [in] */ ULONG nulIDSize,
            /* [in] */ ULONG nulDriveNumber) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetRecorderGUID( 
            /* [size_is][unique][out][in] */ byte __RPC_FAR *pbyUniqueID,
            /* [in] */ ULONG ulBufferSize,
            /* [out] */ ULONG __RPC_FAR *pulReturnSizeRequired) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetRecorderType( 
            /* [out] */ long __RPC_FAR *fTypeCode) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDisplayNames( 
            /* [unique][out][in] */ BSTR __RPC_FAR *pbstrVendorID,
            /* [unique][out][in] */ BSTR __RPC_FAR *pbstrProductID,
            /* [unique][out][in] */ BSTR __RPC_FAR *pbstrRevision) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetBasePnPID( 
            /* [out] */ BSTR __RPC_FAR *pbstrBasePnPID) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetPath( 
            /* [out] */ BSTR __RPC_FAR *pbstrPath) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetRecorderProperties( 
            /* [out] */ IPropertyStorage __RPC_FAR *__RPC_FAR *ppPropStg) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetRecorderProperties( 
            /* [in] */ IPropertyStorage __RPC_FAR *pPropStg) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetRecorderState( 
            /* [out] */ ULONG __RPC_FAR *pulDevStateFlags) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE OpenExclusive( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryMediaType( 
            /* [out] */ long __RPC_FAR *fMediaType,
            /* [out] */ long __RPC_FAR *fMediaFlags) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryMediaInfo( 
            /* [out] */ byte __RPC_FAR *pbSessions,
            /* [out] */ byte __RPC_FAR *pbLastTrack,
            /* [out] */ ULONG __RPC_FAR *ulStartAddress,
            /* [out] */ ULONG __RPC_FAR *ulNextWritable,
            /* [out] */ ULONG __RPC_FAR *ulFreeBlocks) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Eject( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Erase( 
            /* [in] */ boolean bFullErase) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Close( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiscRecorderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDiscRecorder __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDiscRecorder __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDiscRecorder __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Init )( 
            IDiscRecorder __RPC_FAR * This,
            /* [size_is][in] */ byte __RPC_FAR *pbyUniqueID,
            /* [in] */ ULONG nulIDSize,
            /* [in] */ ULONG nulDriveNumber);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRecorderGUID )( 
            IDiscRecorder __RPC_FAR * This,
            /* [size_is][unique][out][in] */ byte __RPC_FAR *pbyUniqueID,
            /* [in] */ ULONG ulBufferSize,
            /* [out] */ ULONG __RPC_FAR *pulReturnSizeRequired);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRecorderType )( 
            IDiscRecorder __RPC_FAR * This,
            /* [out] */ long __RPC_FAR *fTypeCode);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDisplayNames )( 
            IDiscRecorder __RPC_FAR * This,
            /* [unique][out][in] */ BSTR __RPC_FAR *pbstrVendorID,
            /* [unique][out][in] */ BSTR __RPC_FAR *pbstrProductID,
            /* [unique][out][in] */ BSTR __RPC_FAR *pbstrRevision);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBasePnPID )( 
            IDiscRecorder __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pbstrBasePnPID);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPath )( 
            IDiscRecorder __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pbstrPath);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRecorderProperties )( 
            IDiscRecorder __RPC_FAR * This,
            /* [out] */ IPropertyStorage __RPC_FAR *__RPC_FAR *ppPropStg);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetRecorderProperties )( 
            IDiscRecorder __RPC_FAR * This,
            /* [in] */ IPropertyStorage __RPC_FAR *pPropStg);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRecorderState )( 
            IDiscRecorder __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pulDevStateFlags);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OpenExclusive )( 
            IDiscRecorder __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryMediaType )( 
            IDiscRecorder __RPC_FAR * This,
            /* [out] */ long __RPC_FAR *fMediaType,
            /* [out] */ long __RPC_FAR *fMediaFlags);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryMediaInfo )( 
            IDiscRecorder __RPC_FAR * This,
            /* [out] */ byte __RPC_FAR *pbSessions,
            /* [out] */ byte __RPC_FAR *pbLastTrack,
            /* [out] */ ULONG __RPC_FAR *ulStartAddress,
            /* [out] */ ULONG __RPC_FAR *ulNextWritable,
            /* [out] */ ULONG __RPC_FAR *ulFreeBlocks);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Eject )( 
            IDiscRecorder __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Erase )( 
            IDiscRecorder __RPC_FAR * This,
            /* [in] */ boolean bFullErase);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Close )( 
            IDiscRecorder __RPC_FAR * This);
        
        END_INTERFACE
    } IDiscRecorderVtbl;

    interface IDiscRecorder
    {
        CONST_VTBL struct IDiscRecorderVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiscRecorder_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiscRecorder_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiscRecorder_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiscRecorder_Init(This,pbyUniqueID,nulIDSize,nulDriveNumber)	\
    (This)->lpVtbl -> Init(This,pbyUniqueID,nulIDSize,nulDriveNumber)

#define IDiscRecorder_GetRecorderGUID(This,pbyUniqueID,ulBufferSize,pulReturnSizeRequired)	\
    (This)->lpVtbl -> GetRecorderGUID(This,pbyUniqueID,ulBufferSize,pulReturnSizeRequired)

#define IDiscRecorder_GetRecorderType(This,fTypeCode)	\
    (This)->lpVtbl -> GetRecorderType(This,fTypeCode)

#define IDiscRecorder_GetDisplayNames(This,pbstrVendorID,pbstrProductID,pbstrRevision)	\
    (This)->lpVtbl -> GetDisplayNames(This,pbstrVendorID,pbstrProductID,pbstrRevision)

#define IDiscRecorder_GetBasePnPID(This,pbstrBasePnPID)	\
    (This)->lpVtbl -> GetBasePnPID(This,pbstrBasePnPID)

#define IDiscRecorder_GetPath(This,pbstrPath)	\
    (This)->lpVtbl -> GetPath(This,pbstrPath)

#define IDiscRecorder_GetRecorderProperties(This,ppPropStg)	\
    (This)->lpVtbl -> GetRecorderProperties(This,ppPropStg)

#define IDiscRecorder_SetRecorderProperties(This,pPropStg)	\
    (This)->lpVtbl -> SetRecorderProperties(This,pPropStg)

#define IDiscRecorder_GetRecorderState(This,pulDevStateFlags)	\
    (This)->lpVtbl -> GetRecorderState(This,pulDevStateFlags)

#define IDiscRecorder_OpenExclusive(This)	\
    (This)->lpVtbl -> OpenExclusive(This)

#define IDiscRecorder_QueryMediaType(This,fMediaType,fMediaFlags)	\
    (This)->lpVtbl -> QueryMediaType(This,fMediaType,fMediaFlags)

#define IDiscRecorder_QueryMediaInfo(This,pbSessions,pbLastTrack,ulStartAddress,ulNextWritable,ulFreeBlocks)	\
    (This)->lpVtbl -> QueryMediaInfo(This,pbSessions,pbLastTrack,ulStartAddress,ulNextWritable,ulFreeBlocks)

#define IDiscRecorder_Eject(This)	\
    (This)->lpVtbl -> Eject(This)

#define IDiscRecorder_Erase(This,bFullErase)	\
    (This)->lpVtbl -> Erase(This,bFullErase)

#define IDiscRecorder_Close(This)	\
    (This)->lpVtbl -> Close(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IDiscRecorder_Init_Proxy( 
    IDiscRecorder __RPC_FAR * This,
    /* [size_is][in] */ byte __RPC_FAR *pbyUniqueID,
    /* [in] */ ULONG nulIDSize,
    /* [in] */ ULONG nulDriveNumber);


void __RPC_STUB IDiscRecorder_Init_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IDiscRecorder_GetRecorderGUID_Proxy( 
    IDiscRecorder __RPC_FAR * This,
    /* [size_is][unique][out][in] */ byte __RPC_FAR *pbyUniqueID,
    /* [in] */ ULONG ulBufferSize,
    /* [out] */ ULONG __RPC_FAR *pulReturnSizeRequired);


void __RPC_STUB IDiscRecorder_GetRecorderGUID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IDiscRecorder_GetRecorderType_Proxy( 
    IDiscRecorder __RPC_FAR * This,
    /* [out] */ long __RPC_FAR *fTypeCode);


void __RPC_STUB IDiscRecorder_GetRecorderType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IDiscRecorder_GetDisplayNames_Proxy( 
    IDiscRecorder __RPC_FAR * This,
    /* [unique][out][in] */ BSTR __RPC_FAR *pbstrVendorID,
    /* [unique][out][in] */ BSTR __RPC_FAR *pbstrProductID,
    /* [unique][out][in] */ BSTR __RPC_FAR *pbstrRevision);


void __RPC_STUB IDiscRecorder_GetDisplayNames_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IDiscRecorder_GetBasePnPID_Proxy( 
    IDiscRecorder __RPC_FAR * This,
    /* [out] */ BSTR __RPC_FAR *pbstrBasePnPID);


void __RPC_STUB IDiscRecorder_GetBasePnPID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IDiscRecorder_GetPath_Proxy( 
    IDiscRecorder __RPC_FAR * This,
    /* [out] */ BSTR __RPC_FAR *pbstrPath);


void __RPC_STUB IDiscRecorder_GetPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IDiscRecorder_GetRecorderProperties_Proxy( 
    IDiscRecorder __RPC_FAR * This,
    /* [out] */ IPropertyStorage __RPC_FAR *__RPC_FAR *ppPropStg);


void __RPC_STUB IDiscRecorder_GetRecorderProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IDiscRecorder_SetRecorderProperties_Proxy( 
    IDiscRecorder __RPC_FAR * This,
    /* [in] */ IPropertyStorage __RPC_FAR *pPropStg);


void __RPC_STUB IDiscRecorder_SetRecorderProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IDiscRecorder_GetRecorderState_Proxy( 
    IDiscRecorder __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *pulDevStateFlags);


void __RPC_STUB IDiscRecorder_GetRecorderState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IDiscRecorder_OpenExclusive_Proxy( 
    IDiscRecorder __RPC_FAR * This);


void __RPC_STUB IDiscRecorder_OpenExclusive_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IDiscRecorder_QueryMediaType_Proxy( 
    IDiscRecorder __RPC_FAR * This,
    /* [out] */ long __RPC_FAR *fMediaType,
    /* [out] */ long __RPC_FAR *fMediaFlags);


void __RPC_STUB IDiscRecorder_QueryMediaType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IDiscRecorder_QueryMediaInfo_Proxy( 
    IDiscRecorder __RPC_FAR * This,
    /* [out] */ byte __RPC_FAR *pbSessions,
    /* [out] */ byte __RPC_FAR *pbLastTrack,
    /* [out] */ ULONG __RPC_FAR *ulStartAddress,
    /* [out] */ ULONG __RPC_FAR *ulNextWritable,
    /* [out] */ ULONG __RPC_FAR *ulFreeBlocks);


void __RPC_STUB IDiscRecorder_QueryMediaInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IDiscRecorder_Eject_Proxy( 
    IDiscRecorder __RPC_FAR * This);


void __RPC_STUB IDiscRecorder_Eject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IDiscRecorder_Erase_Proxy( 
    IDiscRecorder __RPC_FAR * This,
    /* [in] */ boolean bFullErase);


void __RPC_STUB IDiscRecorder_Erase_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IDiscRecorder_Close_Proxy( 
    IDiscRecorder __RPC_FAR * This);


void __RPC_STUB IDiscRecorder_Close_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiscRecorder_INTERFACE_DEFINED__ */


#ifndef __IEnumDiscRecorders_INTERFACE_DEFINED__
#define __IEnumDiscRecorders_INTERFACE_DEFINED__

/* interface IEnumDiscRecorders */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IEnumDiscRecorders;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9B1921E1-54AC-11d3-9144-00104BA11C5E")
    IEnumDiscRecorders : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG cRecorders,
            /* [length_is][size_is][out] */ IDiscRecorder __RPC_FAR *__RPC_FAR *ppRecorder,
            /* [out] */ ULONG __RPC_FAR *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG cRecorders) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumDiscRecorders __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumDiscRecordersVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumDiscRecorders __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumDiscRecorders __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumDiscRecorders __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumDiscRecorders __RPC_FAR * This,
            /* [in] */ ULONG cRecorders,
            /* [length_is][size_is][out] */ IDiscRecorder __RPC_FAR *__RPC_FAR *ppRecorder,
            /* [out] */ ULONG __RPC_FAR *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumDiscRecorders __RPC_FAR * This,
            /* [in] */ ULONG cRecorders);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumDiscRecorders __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumDiscRecorders __RPC_FAR * This,
            /* [out] */ IEnumDiscRecorders __RPC_FAR *__RPC_FAR *ppEnum);
        
        END_INTERFACE
    } IEnumDiscRecordersVtbl;

    interface IEnumDiscRecorders
    {
        CONST_VTBL struct IEnumDiscRecordersVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumDiscRecorders_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumDiscRecorders_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumDiscRecorders_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumDiscRecorders_Next(This,cRecorders,ppRecorder,pcFetched)	\
    (This)->lpVtbl -> Next(This,cRecorders,ppRecorder,pcFetched)

#define IEnumDiscRecorders_Skip(This,cRecorders)	\
    (This)->lpVtbl -> Skip(This,cRecorders)

#define IEnumDiscRecorders_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumDiscRecorders_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumDiscRecorders_Next_Proxy( 
    IEnumDiscRecorders __RPC_FAR * This,
    /* [in] */ ULONG cRecorders,
    /* [length_is][size_is][out] */ IDiscRecorder __RPC_FAR *__RPC_FAR *ppRecorder,
    /* [out] */ ULONG __RPC_FAR *pcFetched);


void __RPC_STUB IEnumDiscRecorders_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDiscRecorders_Skip_Proxy( 
    IEnumDiscRecorders __RPC_FAR * This,
    /* [in] */ ULONG cRecorders);


void __RPC_STUB IEnumDiscRecorders_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDiscRecorders_Reset_Proxy( 
    IEnumDiscRecorders __RPC_FAR * This);


void __RPC_STUB IEnumDiscRecorders_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDiscRecorders_Clone_Proxy( 
    IEnumDiscRecorders __RPC_FAR * This,
    /* [out] */ IEnumDiscRecorders __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IEnumDiscRecorders_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumDiscRecorders_INTERFACE_DEFINED__ */


#ifndef __IEnumDiscMasterFormats_INTERFACE_DEFINED__
#define __IEnumDiscMasterFormats_INTERFACE_DEFINED__

/* interface IEnumDiscMasterFormats */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IEnumDiscMasterFormats;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DDF445E1-54BA-11d3-9144-00104BA11C5E")
    IEnumDiscMasterFormats : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG cFormats,
            /* [length_is][size_is][out] */ LPIID lpiidFormatID,
            /* [out] */ ULONG __RPC_FAR *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG cFormats) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumDiscMasterFormats __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumDiscMasterFormatsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumDiscMasterFormats __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumDiscMasterFormats __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumDiscMasterFormats __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumDiscMasterFormats __RPC_FAR * This,
            /* [in] */ ULONG cFormats,
            /* [length_is][size_is][out] */ LPIID lpiidFormatID,
            /* [out] */ ULONG __RPC_FAR *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumDiscMasterFormats __RPC_FAR * This,
            /* [in] */ ULONG cFormats);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumDiscMasterFormats __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumDiscMasterFormats __RPC_FAR * This,
            /* [out] */ IEnumDiscMasterFormats __RPC_FAR *__RPC_FAR *ppEnum);
        
        END_INTERFACE
    } IEnumDiscMasterFormatsVtbl;

    interface IEnumDiscMasterFormats
    {
        CONST_VTBL struct IEnumDiscMasterFormatsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumDiscMasterFormats_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumDiscMasterFormats_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumDiscMasterFormats_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumDiscMasterFormats_Next(This,cFormats,lpiidFormatID,pcFetched)	\
    (This)->lpVtbl -> Next(This,cFormats,lpiidFormatID,pcFetched)

#define IEnumDiscMasterFormats_Skip(This,cFormats)	\
    (This)->lpVtbl -> Skip(This,cFormats)

#define IEnumDiscMasterFormats_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumDiscMasterFormats_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumDiscMasterFormats_Next_Proxy( 
    IEnumDiscMasterFormats __RPC_FAR * This,
    /* [in] */ ULONG cFormats,
    /* [length_is][size_is][out] */ LPIID lpiidFormatID,
    /* [out] */ ULONG __RPC_FAR *pcFetched);


void __RPC_STUB IEnumDiscMasterFormats_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDiscMasterFormats_Skip_Proxy( 
    IEnumDiscMasterFormats __RPC_FAR * This,
    /* [in] */ ULONG cFormats);


void __RPC_STUB IEnumDiscMasterFormats_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDiscMasterFormats_Reset_Proxy( 
    IEnumDiscMasterFormats __RPC_FAR * This);


void __RPC_STUB IEnumDiscMasterFormats_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDiscMasterFormats_Clone_Proxy( 
    IEnumDiscMasterFormats __RPC_FAR * This,
    /* [out] */ IEnumDiscMasterFormats __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IEnumDiscMasterFormats_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumDiscMasterFormats_INTERFACE_DEFINED__ */


#ifndef __IRedbookDiscMaster_INTERFACE_DEFINED__
#define __IRedbookDiscMaster_INTERFACE_DEFINED__

/* interface IRedbookDiscMaster */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IRedbookDiscMaster;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E3BC42CD-4E5C-11D3-9144-00104BA11C5E")
    IRedbookDiscMaster : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetTotalAudioTracks( 
            /* [retval][out] */ long __RPC_FAR *pnTracks) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetTotalAudioBlocks( 
            /* [retval][out] */ long __RPC_FAR *pnBlocks) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetUsedAudioBlocks( 
            /* [retval][out] */ long __RPC_FAR *pnBlocks) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetAvailableAudioTrackBlocks( 
            /* [retval][out] */ long __RPC_FAR *pnBlocks) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetAudioBlockSize( 
            /* [retval][out] */ long __RPC_FAR *pnBlockBytes) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateAudioTrack( 
            /* [in] */ long nBlocks) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddAudioTrackBlocks( 
            /* [size_is][in] */ byte __RPC_FAR *pby,
            /* [in] */ long cb) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CloseAudioTrack( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRedbookDiscMasterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRedbookDiscMaster __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRedbookDiscMaster __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRedbookDiscMaster __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTotalAudioTracks )( 
            IRedbookDiscMaster __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pnTracks);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTotalAudioBlocks )( 
            IRedbookDiscMaster __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pnBlocks);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetUsedAudioBlocks )( 
            IRedbookDiscMaster __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pnBlocks);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAvailableAudioTrackBlocks )( 
            IRedbookDiscMaster __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pnBlocks);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAudioBlockSize )( 
            IRedbookDiscMaster __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pnBlockBytes);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateAudioTrack )( 
            IRedbookDiscMaster __RPC_FAR * This,
            /* [in] */ long nBlocks);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddAudioTrackBlocks )( 
            IRedbookDiscMaster __RPC_FAR * This,
            /* [size_is][in] */ byte __RPC_FAR *pby,
            /* [in] */ long cb);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CloseAudioTrack )( 
            IRedbookDiscMaster __RPC_FAR * This);
        
        END_INTERFACE
    } IRedbookDiscMasterVtbl;

    interface IRedbookDiscMaster
    {
        CONST_VTBL struct IRedbookDiscMasterVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRedbookDiscMaster_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRedbookDiscMaster_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRedbookDiscMaster_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRedbookDiscMaster_GetTotalAudioTracks(This,pnTracks)	\
    (This)->lpVtbl -> GetTotalAudioTracks(This,pnTracks)

#define IRedbookDiscMaster_GetTotalAudioBlocks(This,pnBlocks)	\
    (This)->lpVtbl -> GetTotalAudioBlocks(This,pnBlocks)

#define IRedbookDiscMaster_GetUsedAudioBlocks(This,pnBlocks)	\
    (This)->lpVtbl -> GetUsedAudioBlocks(This,pnBlocks)

#define IRedbookDiscMaster_GetAvailableAudioTrackBlocks(This,pnBlocks)	\
    (This)->lpVtbl -> GetAvailableAudioTrackBlocks(This,pnBlocks)

#define IRedbookDiscMaster_GetAudioBlockSize(This,pnBlockBytes)	\
    (This)->lpVtbl -> GetAudioBlockSize(This,pnBlockBytes)

#define IRedbookDiscMaster_CreateAudioTrack(This,nBlocks)	\
    (This)->lpVtbl -> CreateAudioTrack(This,nBlocks)

#define IRedbookDiscMaster_AddAudioTrackBlocks(This,pby,cb)	\
    (This)->lpVtbl -> AddAudioTrackBlocks(This,pby,cb)

#define IRedbookDiscMaster_CloseAudioTrack(This)	\
    (This)->lpVtbl -> CloseAudioTrack(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IRedbookDiscMaster_GetTotalAudioTracks_Proxy( 
    IRedbookDiscMaster __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pnTracks);


void __RPC_STUB IRedbookDiscMaster_GetTotalAudioTracks_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IRedbookDiscMaster_GetTotalAudioBlocks_Proxy( 
    IRedbookDiscMaster __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pnBlocks);


void __RPC_STUB IRedbookDiscMaster_GetTotalAudioBlocks_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IRedbookDiscMaster_GetUsedAudioBlocks_Proxy( 
    IRedbookDiscMaster __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pnBlocks);


void __RPC_STUB IRedbookDiscMaster_GetUsedAudioBlocks_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IRedbookDiscMaster_GetAvailableAudioTrackBlocks_Proxy( 
    IRedbookDiscMaster __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pnBlocks);


void __RPC_STUB IRedbookDiscMaster_GetAvailableAudioTrackBlocks_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IRedbookDiscMaster_GetAudioBlockSize_Proxy( 
    IRedbookDiscMaster __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pnBlockBytes);


void __RPC_STUB IRedbookDiscMaster_GetAudioBlockSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IRedbookDiscMaster_CreateAudioTrack_Proxy( 
    IRedbookDiscMaster __RPC_FAR * This,
    /* [in] */ long nBlocks);


void __RPC_STUB IRedbookDiscMaster_CreateAudioTrack_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IRedbookDiscMaster_AddAudioTrackBlocks_Proxy( 
    IRedbookDiscMaster __RPC_FAR * This,
    /* [size_is][in] */ byte __RPC_FAR *pby,
    /* [in] */ long cb);


void __RPC_STUB IRedbookDiscMaster_AddAudioTrackBlocks_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IRedbookDiscMaster_CloseAudioTrack_Proxy( 
    IRedbookDiscMaster __RPC_FAR * This);


void __RPC_STUB IRedbookDiscMaster_CloseAudioTrack_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRedbookDiscMaster_INTERFACE_DEFINED__ */


#ifndef __IJolietDiscMaster_INTERFACE_DEFINED__
#define __IJolietDiscMaster_INTERFACE_DEFINED__

/* interface IJolietDiscMaster */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IJolietDiscMaster;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E3BC42CE-4E5C-11D3-9144-00104BA11C5E")
    IJolietDiscMaster : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetTotalDataBlocks( 
            /* [retval][out] */ long __RPC_FAR *pnBlocks) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetUsedDataBlocks( 
            /* [retval][out] */ long __RPC_FAR *pnBlocks) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDataBlockSize( 
            /* [retval][out] */ long __RPC_FAR *pnBlockBytes) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddData( 
            /* [in] */ IStorage __RPC_FAR *pStorage,
            long lFileOverwrite) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetJolietProperties( 
            /* [out] */ IPropertyStorage __RPC_FAR *__RPC_FAR *ppPropStg) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetJolietProperties( 
            /* [in] */ IPropertyStorage __RPC_FAR *pPropStg) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IJolietDiscMasterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IJolietDiscMaster __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IJolietDiscMaster __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IJolietDiscMaster __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTotalDataBlocks )( 
            IJolietDiscMaster __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pnBlocks);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetUsedDataBlocks )( 
            IJolietDiscMaster __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pnBlocks);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDataBlockSize )( 
            IJolietDiscMaster __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pnBlockBytes);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddData )( 
            IJolietDiscMaster __RPC_FAR * This,
            /* [in] */ IStorage __RPC_FAR *pStorage,
            long lFileOverwrite);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetJolietProperties )( 
            IJolietDiscMaster __RPC_FAR * This,
            /* [out] */ IPropertyStorage __RPC_FAR *__RPC_FAR *ppPropStg);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetJolietProperties )( 
            IJolietDiscMaster __RPC_FAR * This,
            /* [in] */ IPropertyStorage __RPC_FAR *pPropStg);
        
        END_INTERFACE
    } IJolietDiscMasterVtbl;

    interface IJolietDiscMaster
    {
        CONST_VTBL struct IJolietDiscMasterVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IJolietDiscMaster_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IJolietDiscMaster_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IJolietDiscMaster_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IJolietDiscMaster_GetTotalDataBlocks(This,pnBlocks)	\
    (This)->lpVtbl -> GetTotalDataBlocks(This,pnBlocks)

#define IJolietDiscMaster_GetUsedDataBlocks(This,pnBlocks)	\
    (This)->lpVtbl -> GetUsedDataBlocks(This,pnBlocks)

#define IJolietDiscMaster_GetDataBlockSize(This,pnBlockBytes)	\
    (This)->lpVtbl -> GetDataBlockSize(This,pnBlockBytes)

#define IJolietDiscMaster_AddData(This,pStorage,lFileOverwrite)	\
    (This)->lpVtbl -> AddData(This,pStorage,lFileOverwrite)

#define IJolietDiscMaster_GetJolietProperties(This,ppPropStg)	\
    (This)->lpVtbl -> GetJolietProperties(This,ppPropStg)

#define IJolietDiscMaster_SetJolietProperties(This,pPropStg)	\
    (This)->lpVtbl -> SetJolietProperties(This,pPropStg)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IJolietDiscMaster_GetTotalDataBlocks_Proxy( 
    IJolietDiscMaster __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pnBlocks);


void __RPC_STUB IJolietDiscMaster_GetTotalDataBlocks_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IJolietDiscMaster_GetUsedDataBlocks_Proxy( 
    IJolietDiscMaster __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pnBlocks);


void __RPC_STUB IJolietDiscMaster_GetUsedDataBlocks_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IJolietDiscMaster_GetDataBlockSize_Proxy( 
    IJolietDiscMaster __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pnBlockBytes);


void __RPC_STUB IJolietDiscMaster_GetDataBlockSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IJolietDiscMaster_AddData_Proxy( 
    IJolietDiscMaster __RPC_FAR * This,
    /* [in] */ IStorage __RPC_FAR *pStorage,
    long lFileOverwrite);


void __RPC_STUB IJolietDiscMaster_AddData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IJolietDiscMaster_GetJolietProperties_Proxy( 
    IJolietDiscMaster __RPC_FAR * This,
    /* [out] */ IPropertyStorage __RPC_FAR *__RPC_FAR *ppPropStg);


void __RPC_STUB IJolietDiscMaster_GetJolietProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IJolietDiscMaster_SetJolietProperties_Proxy( 
    IJolietDiscMaster __RPC_FAR * This,
    /* [in] */ IPropertyStorage __RPC_FAR *pPropStg);


void __RPC_STUB IJolietDiscMaster_SetJolietProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IJolietDiscMaster_INTERFACE_DEFINED__ */


#ifndef __IDiscMasterProgressEvents_INTERFACE_DEFINED__
#define __IDiscMasterProgressEvents_INTERFACE_DEFINED__

/* interface IDiscMasterProgressEvents */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDiscMasterProgressEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("EC9E51C1-4E5D-11D3-9144-00104BA11C5E")
    IDiscMasterProgressEvents : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryCancel( 
            /* [retval][out] */ boolean __RPC_FAR *pbCancel) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE NotifyPnPActivity( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE NotifyAddProgress( 
            /* [in] */ long nCompletedSteps,
            /* [in] */ long nTotalSteps) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE NotifyBlockProgress( 
            /* [in] */ long nCompleted,
            /* [in] */ long nTotal) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE NotifyTrackProgress( 
            /* [in] */ long nCurrentTrack,
            /* [in] */ long nTotalTracks) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE NotifyPreparingBurn( 
            /* [in] */ long nEstimatedSeconds) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE NotifyClosingDisc( 
            /* [in] */ long nEstimatedSeconds) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE NotifyBurnComplete( 
            /* [in] */ HRESULT status) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE NotifyEraseComplete( 
            /* [in] */ HRESULT status) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiscMasterProgressEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDiscMasterProgressEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDiscMasterProgressEvents __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDiscMasterProgressEvents __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryCancel )( 
            IDiscMasterProgressEvents __RPC_FAR * This,
            /* [retval][out] */ boolean __RPC_FAR *pbCancel);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NotifyPnPActivity )( 
            IDiscMasterProgressEvents __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NotifyAddProgress )( 
            IDiscMasterProgressEvents __RPC_FAR * This,
            /* [in] */ long nCompletedSteps,
            /* [in] */ long nTotalSteps);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NotifyBlockProgress )( 
            IDiscMasterProgressEvents __RPC_FAR * This,
            /* [in] */ long nCompleted,
            /* [in] */ long nTotal);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NotifyTrackProgress )( 
            IDiscMasterProgressEvents __RPC_FAR * This,
            /* [in] */ long nCurrentTrack,
            /* [in] */ long nTotalTracks);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NotifyPreparingBurn )( 
            IDiscMasterProgressEvents __RPC_FAR * This,
            /* [in] */ long nEstimatedSeconds);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NotifyClosingDisc )( 
            IDiscMasterProgressEvents __RPC_FAR * This,
            /* [in] */ long nEstimatedSeconds);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NotifyBurnComplete )( 
            IDiscMasterProgressEvents __RPC_FAR * This,
            /* [in] */ HRESULT status);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NotifyEraseComplete )( 
            IDiscMasterProgressEvents __RPC_FAR * This,
            /* [in] */ HRESULT status);
        
        END_INTERFACE
    } IDiscMasterProgressEventsVtbl;

    interface IDiscMasterProgressEvents
    {
        CONST_VTBL struct IDiscMasterProgressEventsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiscMasterProgressEvents_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiscMasterProgressEvents_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiscMasterProgressEvents_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiscMasterProgressEvents_QueryCancel(This,pbCancel)	\
    (This)->lpVtbl -> QueryCancel(This,pbCancel)

#define IDiscMasterProgressEvents_NotifyPnPActivity(This)	\
    (This)->lpVtbl -> NotifyPnPActivity(This)

#define IDiscMasterProgressEvents_NotifyAddProgress(This,nCompletedSteps,nTotalSteps)	\
    (This)->lpVtbl -> NotifyAddProgress(This,nCompletedSteps,nTotalSteps)

#define IDiscMasterProgressEvents_NotifyBlockProgress(This,nCompleted,nTotal)	\
    (This)->lpVtbl -> NotifyBlockProgress(This,nCompleted,nTotal)

#define IDiscMasterProgressEvents_NotifyTrackProgress(This,nCurrentTrack,nTotalTracks)	\
    (This)->lpVtbl -> NotifyTrackProgress(This,nCurrentTrack,nTotalTracks)

#define IDiscMasterProgressEvents_NotifyPreparingBurn(This,nEstimatedSeconds)	\
    (This)->lpVtbl -> NotifyPreparingBurn(This,nEstimatedSeconds)

#define IDiscMasterProgressEvents_NotifyClosingDisc(This,nEstimatedSeconds)	\
    (This)->lpVtbl -> NotifyClosingDisc(This,nEstimatedSeconds)

#define IDiscMasterProgressEvents_NotifyBurnComplete(This,status)	\
    (This)->lpVtbl -> NotifyBurnComplete(This,status)

#define IDiscMasterProgressEvents_NotifyEraseComplete(This,status)	\
    (This)->lpVtbl -> NotifyEraseComplete(This,status)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IDiscMasterProgressEvents_QueryCancel_Proxy( 
    IDiscMasterProgressEvents __RPC_FAR * This,
    /* [retval][out] */ boolean __RPC_FAR *pbCancel);


void __RPC_STUB IDiscMasterProgressEvents_QueryCancel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IDiscMasterProgressEvents_NotifyPnPActivity_Proxy( 
    IDiscMasterProgressEvents __RPC_FAR * This);


void __RPC_STUB IDiscMasterProgressEvents_NotifyPnPActivity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IDiscMasterProgressEvents_NotifyAddProgress_Proxy( 
    IDiscMasterProgressEvents __RPC_FAR * This,
    /* [in] */ long nCompletedSteps,
    /* [in] */ long nTotalSteps);


void __RPC_STUB IDiscMasterProgressEvents_NotifyAddProgress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IDiscMasterProgressEvents_NotifyBlockProgress_Proxy( 
    IDiscMasterProgressEvents __RPC_FAR * This,
    /* [in] */ long nCompleted,
    /* [in] */ long nTotal);


void __RPC_STUB IDiscMasterProgressEvents_NotifyBlockProgress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IDiscMasterProgressEvents_NotifyTrackProgress_Proxy( 
    IDiscMasterProgressEvents __RPC_FAR * This,
    /* [in] */ long nCurrentTrack,
    /* [in] */ long nTotalTracks);


void __RPC_STUB IDiscMasterProgressEvents_NotifyTrackProgress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IDiscMasterProgressEvents_NotifyPreparingBurn_Proxy( 
    IDiscMasterProgressEvents __RPC_FAR * This,
    /* [in] */ long nEstimatedSeconds);


void __RPC_STUB IDiscMasterProgressEvents_NotifyPreparingBurn_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IDiscMasterProgressEvents_NotifyClosingDisc_Proxy( 
    IDiscMasterProgressEvents __RPC_FAR * This,
    /* [in] */ long nEstimatedSeconds);


void __RPC_STUB IDiscMasterProgressEvents_NotifyClosingDisc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IDiscMasterProgressEvents_NotifyBurnComplete_Proxy( 
    IDiscMasterProgressEvents __RPC_FAR * This,
    /* [in] */ HRESULT status);


void __RPC_STUB IDiscMasterProgressEvents_NotifyBurnComplete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IDiscMasterProgressEvents_NotifyEraseComplete_Proxy( 
    IDiscMasterProgressEvents __RPC_FAR * This,
    /* [in] */ HRESULT status);


void __RPC_STUB IDiscMasterProgressEvents_NotifyEraseComplete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiscMasterProgressEvents_INTERFACE_DEFINED__ */


#ifndef __IDiscMaster_INTERFACE_DEFINED__
#define __IDiscMaster_INTERFACE_DEFINED__

/* interface IDiscMaster */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDiscMaster;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("520CCA62-51A5-11D3-9144-00104BA11C5E")
    IDiscMaster : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Open( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE EnumDiscMasterFormats( 
            /* [out] */ IEnumDiscMasterFormats __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetActiveDiscMasterFormat( 
            /* [out] */ LPIID lpiid) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetActiveDiscMasterFormat( 
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppUnk) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE EnumDiscRecorders( 
            /* [out] */ IEnumDiscRecorders __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetActiveDiscRecorder( 
            /* [out] */ IDiscRecorder __RPC_FAR *__RPC_FAR *ppRecorder) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetActiveDiscRecorder( 
            /* [in] */ IDiscRecorder __RPC_FAR *pRecorder) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ClearFormatContent( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ProgressAdvise( 
            /* [in] */ IDiscMasterProgressEvents __RPC_FAR *pEvents,
            /* [retval][out] */ UINT_PTR __RPC_FAR *pvCookie) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ProgressUnadvise( 
            /* [in] */ UINT_PTR vCookie) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RecordDisc( 
            /* [in] */ boolean bSimulate,
            /* [in] */ boolean bEjectAfterBurn) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Close( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiscMasterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDiscMaster __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDiscMaster __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDiscMaster __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Open )( 
            IDiscMaster __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumDiscMasterFormats )( 
            IDiscMaster __RPC_FAR * This,
            /* [out] */ IEnumDiscMasterFormats __RPC_FAR *__RPC_FAR *ppEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetActiveDiscMasterFormat )( 
            IDiscMaster __RPC_FAR * This,
            /* [out] */ LPIID lpiid);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetActiveDiscMasterFormat )( 
            IDiscMaster __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppUnk);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumDiscRecorders )( 
            IDiscMaster __RPC_FAR * This,
            /* [out] */ IEnumDiscRecorders __RPC_FAR *__RPC_FAR *ppEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetActiveDiscRecorder )( 
            IDiscMaster __RPC_FAR * This,
            /* [out] */ IDiscRecorder __RPC_FAR *__RPC_FAR *ppRecorder);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetActiveDiscRecorder )( 
            IDiscMaster __RPC_FAR * This,
            /* [in] */ IDiscRecorder __RPC_FAR *pRecorder);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ClearFormatContent )( 
            IDiscMaster __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ProgressAdvise )( 
            IDiscMaster __RPC_FAR * This,
            /* [in] */ IDiscMasterProgressEvents __RPC_FAR *pEvents,
            /* [retval][out] */ UINT_PTR __RPC_FAR *pvCookie);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ProgressUnadvise )( 
            IDiscMaster __RPC_FAR * This,
            /* [in] */ UINT_PTR vCookie);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RecordDisc )( 
            IDiscMaster __RPC_FAR * This,
            /* [in] */ boolean bSimulate,
            /* [in] */ boolean bEjectAfterBurn);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Close )( 
            IDiscMaster __RPC_FAR * This);
        
        END_INTERFACE
    } IDiscMasterVtbl;

    interface IDiscMaster
    {
        CONST_VTBL struct IDiscMasterVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiscMaster_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiscMaster_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiscMaster_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiscMaster_Open(This)	\
    (This)->lpVtbl -> Open(This)

#define IDiscMaster_EnumDiscMasterFormats(This,ppEnum)	\
    (This)->lpVtbl -> EnumDiscMasterFormats(This,ppEnum)

#define IDiscMaster_GetActiveDiscMasterFormat(This,lpiid)	\
    (This)->lpVtbl -> GetActiveDiscMasterFormat(This,lpiid)

#define IDiscMaster_SetActiveDiscMasterFormat(This,riid,ppUnk)	\
    (This)->lpVtbl -> SetActiveDiscMasterFormat(This,riid,ppUnk)

#define IDiscMaster_EnumDiscRecorders(This,ppEnum)	\
    (This)->lpVtbl -> EnumDiscRecorders(This,ppEnum)

#define IDiscMaster_GetActiveDiscRecorder(This,ppRecorder)	\
    (This)->lpVtbl -> GetActiveDiscRecorder(This,ppRecorder)

#define IDiscMaster_SetActiveDiscRecorder(This,pRecorder)	\
    (This)->lpVtbl -> SetActiveDiscRecorder(This,pRecorder)

#define IDiscMaster_ClearFormatContent(This)	\
    (This)->lpVtbl -> ClearFormatContent(This)

#define IDiscMaster_ProgressAdvise(This,pEvents,pvCookie)	\
    (This)->lpVtbl -> ProgressAdvise(This,pEvents,pvCookie)

#define IDiscMaster_ProgressUnadvise(This,vCookie)	\
    (This)->lpVtbl -> ProgressUnadvise(This,vCookie)

#define IDiscMaster_RecordDisc(This,bSimulate,bEjectAfterBurn)	\
    (This)->lpVtbl -> RecordDisc(This,bSimulate,bEjectAfterBurn)

#define IDiscMaster_Close(This)	\
    (This)->lpVtbl -> Close(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IDiscMaster_Open_Proxy( 
    IDiscMaster __RPC_FAR * This);


void __RPC_STUB IDiscMaster_Open_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IDiscMaster_EnumDiscMasterFormats_Proxy( 
    IDiscMaster __RPC_FAR * This,
    /* [out] */ IEnumDiscMasterFormats __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IDiscMaster_EnumDiscMasterFormats_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IDiscMaster_GetActiveDiscMasterFormat_Proxy( 
    IDiscMaster __RPC_FAR * This,
    /* [out] */ LPIID lpiid);


void __RPC_STUB IDiscMaster_GetActiveDiscMasterFormat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IDiscMaster_SetActiveDiscMasterFormat_Proxy( 
    IDiscMaster __RPC_FAR * This,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppUnk);


void __RPC_STUB IDiscMaster_SetActiveDiscMasterFormat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IDiscMaster_EnumDiscRecorders_Proxy( 
    IDiscMaster __RPC_FAR * This,
    /* [out] */ IEnumDiscRecorders __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IDiscMaster_EnumDiscRecorders_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IDiscMaster_GetActiveDiscRecorder_Proxy( 
    IDiscMaster __RPC_FAR * This,
    /* [out] */ IDiscRecorder __RPC_FAR *__RPC_FAR *ppRecorder);


void __RPC_STUB IDiscMaster_GetActiveDiscRecorder_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IDiscMaster_SetActiveDiscRecorder_Proxy( 
    IDiscMaster __RPC_FAR * This,
    /* [in] */ IDiscRecorder __RPC_FAR *pRecorder);


void __RPC_STUB IDiscMaster_SetActiveDiscRecorder_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IDiscMaster_ClearFormatContent_Proxy( 
    IDiscMaster __RPC_FAR * This);


void __RPC_STUB IDiscMaster_ClearFormatContent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IDiscMaster_ProgressAdvise_Proxy( 
    IDiscMaster __RPC_FAR * This,
    /* [in] */ IDiscMasterProgressEvents __RPC_FAR *pEvents,
    /* [retval][out] */ UINT_PTR __RPC_FAR *pvCookie);


void __RPC_STUB IDiscMaster_ProgressAdvise_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IDiscMaster_ProgressUnadvise_Proxy( 
    IDiscMaster __RPC_FAR * This,
    /* [in] */ UINT_PTR vCookie);


void __RPC_STUB IDiscMaster_ProgressUnadvise_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IDiscMaster_RecordDisc_Proxy( 
    IDiscMaster __RPC_FAR * This,
    /* [in] */ boolean bSimulate,
    /* [in] */ boolean bEjectAfterBurn);


void __RPC_STUB IDiscMaster_RecordDisc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IDiscMaster_Close_Proxy( 
    IDiscMaster __RPC_FAR * This);


void __RPC_STUB IDiscMaster_Close_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiscMaster_INTERFACE_DEFINED__ */



#ifndef __IMAPILib_LIBRARY_DEFINED__
#define __IMAPILib_LIBRARY_DEFINED__

/* library IMAPILib */
/* [helpstring][version][uuid] */ 





EXTERN_C const IID LIBID_IMAPILib;

EXTERN_C const CLSID CLSID_MSDiscRecorderObj;

#ifdef __cplusplus

class DECLSPEC_UUID("520CCA61-51A5-11D3-9144-00104BA11C5E")
MSDiscRecorderObj;
#endif

EXTERN_C const CLSID CLSID_MSDiscMasterObj;

#ifdef __cplusplus

class DECLSPEC_UUID("520CCA63-51A5-11D3-9144-00104BA11C5E")
MSDiscMasterObj;
#endif

EXTERN_C const CLSID CLSID_MSEnumDiscRecordersObj;

#ifdef __cplusplus

class DECLSPEC_UUID("8A03567A-63CB-4BA8-BAF6-52119816D1EF")
MSEnumDiscRecordersObj;
#endif
#endif /* __IMAPILib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\imgutil.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES.
//

#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0286 */
/* at Mon Jan 22 12:14:09 2007
 */
/* Compiler settings for ..\imgutil.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __imgutil_h__
#define __imgutil_h__

/* Forward Declarations */ 

#ifndef __ISniffStream_FWD_DEFINED__
#define __ISniffStream_FWD_DEFINED__
typedef interface ISniffStream ISniffStream;
#endif 	/* __ISniffStream_FWD_DEFINED__ */


#ifndef __IDithererImpl_FWD_DEFINED__
#define __IDithererImpl_FWD_DEFINED__
typedef interface IDithererImpl IDithererImpl;
#endif 	/* __IDithererImpl_FWD_DEFINED__ */


#ifndef __CoDitherToRGB8_FWD_DEFINED__
#define __CoDitherToRGB8_FWD_DEFINED__

#ifdef __cplusplus
typedef class CoDitherToRGB8 CoDitherToRGB8;
#else
typedef struct CoDitherToRGB8 CoDitherToRGB8;
#endif /* __cplusplus */

#endif 	/* __CoDitherToRGB8_FWD_DEFINED__ */


#ifndef __CoSniffStream_FWD_DEFINED__
#define __CoSniffStream_FWD_DEFINED__

#ifdef __cplusplus
typedef class CoSniffStream CoSniffStream;
#else
typedef struct CoSniffStream CoSniffStream;
#endif /* __cplusplus */

#endif 	/* __CoSniffStream_FWD_DEFINED__ */


#ifndef __CoMapMIMEToCLSID_FWD_DEFINED__
#define __CoMapMIMEToCLSID_FWD_DEFINED__

#ifdef __cplusplus
typedef class CoMapMIMEToCLSID CoMapMIMEToCLSID;
#else
typedef struct CoMapMIMEToCLSID CoMapMIMEToCLSID;
#endif /* __cplusplus */

#endif 	/* __CoMapMIMEToCLSID_FWD_DEFINED__ */


/* header files for imported files */
#include "ocmm.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_imgutil_0000 */
/* [local] */ 


STDAPI CreateMIMEMap( IMapMIMEToCLSID** ppMap );
STDAPI DecodeImage( IStream* pStream, IMapMIMEToCLSID* pMap,
   IUnknown* pEventSink );
STDAPI SniffStream( IStream* pInStream, UINT* pnFormat,
   IStream** ppOutStream );
STDAPI GetMaxMIMEIDBytes( ULONG* pnMaxBytes );
STDAPI IdentifyMIMEType( const BYTE* pbBytes, ULONG nBytes,
   UINT* pnFormat );
STDAPI ComputeInvCMAP(const RGBQUAD *pRGBColors, ULONG nColors, BYTE *pInvTable,
   ULONG cbTable);
STDAPI DitherTo8( BYTE * pDestBits, LONG nDestPitch, BYTE * pSrcBits, LONG nSrcPitch,
   REFGUID bfidSrc, RGBQUAD * prgbDestColors, RGBQUAD * prgbSrcColors, BYTE * pbDestInvMap,
   LONG x, LONG y, LONG cx, LONG cy, LONG lDestTrans, LONG lSrcTrans);
STDAPI CreateDDrawSurfaceOnDIB(HBITMAP hbmDib, IDirectDrawSurface **ppSurface);


extern RPC_IF_HANDLE __MIDL_itf_imgutil_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_imgutil_0000_v0_0_s_ifspec;

#ifndef __ISniffStream_INTERFACE_DEFINED__
#define __ISniffStream_INTERFACE_DEFINED__

/* interface ISniffStream */
/* [unique][helpstring][uuid][local][object] */ 


EXTERN_C const IID IID_ISniffStream;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4EF17940-30E0-11d0-B724-00AA006C1A01")
    ISniffStream : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Init( 
            IStream __RPC_FAR *pStream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Peek( 
            void __RPC_FAR *pBuffer,
            ULONG nBytes,
            ULONG __RPC_FAR *pnBytesRead) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISniffStreamVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISniffStream __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISniffStream __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISniffStream __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Init )( 
            ISniffStream __RPC_FAR * This,
            IStream __RPC_FAR *pStream);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Peek )( 
            ISniffStream __RPC_FAR * This,
            void __RPC_FAR *pBuffer,
            ULONG nBytes,
            ULONG __RPC_FAR *pnBytesRead);
        
        END_INTERFACE
    } ISniffStreamVtbl;

    interface ISniffStream
    {
        CONST_VTBL struct ISniffStreamVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISniffStream_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISniffStream_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISniffStream_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISniffStream_Init(This,pStream)	\
    (This)->lpVtbl -> Init(This,pStream)

#define ISniffStream_Peek(This,pBuffer,nBytes,pnBytesRead)	\
    (This)->lpVtbl -> Peek(This,pBuffer,nBytes,pnBytesRead)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISniffStream_Init_Proxy( 
    ISniffStream __RPC_FAR * This,
    IStream __RPC_FAR *pStream);


void __RPC_STUB ISniffStream_Init_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISniffStream_Peek_Proxy( 
    ISniffStream __RPC_FAR * This,
    void __RPC_FAR *pBuffer,
    ULONG nBytes,
    ULONG __RPC_FAR *pnBytesRead);


void __RPC_STUB ISniffStream_Peek_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISniffStream_INTERFACE_DEFINED__ */


#ifndef __IDithererImpl_INTERFACE_DEFINED__
#define __IDithererImpl_INTERFACE_DEFINED__

/* interface IDithererImpl */
/* [unique][helpstring][uuid][local][object] */ 


EXTERN_C const IID IID_IDithererImpl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7C48E840-3910-11d0-86FC-00A0C913F750")
    IDithererImpl : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetDestColorTable( 
            ULONG nColors,
            const RGBQUAD __RPC_FAR *prgbColors) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetEventSink( 
            IImageDecodeEventSink __RPC_FAR *pEventSink) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDithererImplVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDithererImpl __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDithererImpl __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDithererImpl __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDestColorTable )( 
            IDithererImpl __RPC_FAR * This,
            ULONG nColors,
            const RGBQUAD __RPC_FAR *prgbColors);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetEventSink )( 
            IDithererImpl __RPC_FAR * This,
            IImageDecodeEventSink __RPC_FAR *pEventSink);
        
        END_INTERFACE
    } IDithererImplVtbl;

    interface IDithererImpl
    {
        CONST_VTBL struct IDithererImplVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDithererImpl_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDithererImpl_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDithererImpl_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDithererImpl_SetDestColorTable(This,nColors,prgbColors)	\
    (This)->lpVtbl -> SetDestColorTable(This,nColors,prgbColors)

#define IDithererImpl_SetEventSink(This,pEventSink)	\
    (This)->lpVtbl -> SetEventSink(This,pEventSink)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDithererImpl_SetDestColorTable_Proxy( 
    IDithererImpl __RPC_FAR * This,
    ULONG nColors,
    const RGBQUAD __RPC_FAR *prgbColors);


void __RPC_STUB IDithererImpl_SetDestColorTable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDithererImpl_SetEventSink_Proxy( 
    IDithererImpl __RPC_FAR * This,
    IImageDecodeEventSink __RPC_FAR *pEventSink);


void __RPC_STUB IDithererImpl_SetEventSink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDithererImpl_INTERFACE_DEFINED__ */



#ifndef __ImgUtilLib_LIBRARY_DEFINED__
#define __ImgUtilLib_LIBRARY_DEFINED__

/* library ImgUtilLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_ImgUtilLib;

EXTERN_C const CLSID CLSID_CoDitherToRGB8;

#ifdef __cplusplus

class DECLSPEC_UUID("A860CE50-3910-11d0-86FC-00A0C913F750")
CoDitherToRGB8;
#endif

EXTERN_C const CLSID CLSID_CoSniffStream;

#ifdef __cplusplus

class DECLSPEC_UUID("6A01FDA0-30DF-11d0-B724-00AA006C1A01")
CoSniffStream;
#endif

EXTERN_C const CLSID CLSID_CoMapMIMEToCLSID;

#ifdef __cplusplus

class DECLSPEC_UUID("30C3B080-30FB-11d0-B724-00AA006C1A01")
CoMapMIMEToCLSID;
#endif
#endif /* __ImgUtilLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\imnact.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES.
//

#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0286 */
/* at Mon Jan 22 12:14:12 2007
 */
/* Compiler settings for ..\imnact.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __imnact_h__
#define __imnact_h__

/* Forward Declarations */ 

#ifndef __IImnAdviseAccount_FWD_DEFINED__
#define __IImnAdviseAccount_FWD_DEFINED__
typedef interface IImnAdviseAccount IImnAdviseAccount;
#endif 	/* __IImnAdviseAccount_FWD_DEFINED__ */


#ifndef __IImnAdviseMigrateServer_FWD_DEFINED__
#define __IImnAdviseMigrateServer_FWD_DEFINED__
typedef interface IImnAdviseMigrateServer IImnAdviseMigrateServer;
#endif 	/* __IImnAdviseMigrateServer_FWD_DEFINED__ */


#ifndef __IImnEnumAccounts_FWD_DEFINED__
#define __IImnEnumAccounts_FWD_DEFINED__
typedef interface IImnEnumAccounts IImnEnumAccounts;
#endif 	/* __IImnEnumAccounts_FWD_DEFINED__ */


#ifndef __IImnAccountManager_FWD_DEFINED__
#define __IImnAccountManager_FWD_DEFINED__
typedef interface IImnAccountManager IImnAccountManager;
#endif 	/* __IImnAccountManager_FWD_DEFINED__ */


#ifndef __IImnAccountManager2_FWD_DEFINED__
#define __IImnAccountManager2_FWD_DEFINED__
typedef interface IImnAccountManager2 IImnAccountManager2;
#endif 	/* __IImnAccountManager2_FWD_DEFINED__ */


#ifndef __IPropertyContainer_FWD_DEFINED__
#define __IPropertyContainer_FWD_DEFINED__
typedef interface IPropertyContainer IPropertyContainer;
#endif 	/* __IPropertyContainer_FWD_DEFINED__ */


#ifndef __IImnAccount_FWD_DEFINED__
#define __IImnAccount_FWD_DEFINED__
typedef interface IImnAccount IImnAccount;
#endif 	/* __IImnAccount_FWD_DEFINED__ */


/* header files for imported files */
#include "objidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_imnact_0000 */
/* [local] */ 


//=--------------------------------------------------------------------------=
// Imnact.h
//=--------------------------------------------------------------------------=
// (C) Copyright 1995-1998 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=

#pragma comment(lib,"uuid.lib")

//---------------------------------------------------------------------------=
// Internet Mail and News Account Manager Interfaces.

// --------------------------------------------------------------------------------
// GUIDS
// --------------------------------------------------------------------------------
#if !defined( WIN16 ) || defined( __cplusplus )
// {8D4B04E1-1331-11d0-81B8-00C04FD85AB4}
DEFINE_GUID(CLSID_ImnAccountManager, 0x8d4b04e1, 0x1331, 0x11d0, 0x81, 0xb8, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// {FD465484-1384-11d0-ABBD-0020AFDFD10A}
DEFINE_GUID(IID_IPropertyContainer, 0xfd465484, 0x1384, 0x11d0, 0xab, 0xbd, 0x0, 0x20, 0xaf, 0xdf, 0xd1, 0xa);

// {FD465481-1384-11d0-ABBD-0020AFDFD10A}
DEFINE_GUID(IID_IImnAccountManager, 0xfd465481, 0x1384, 0x11d0, 0xab, 0xbd, 0x0, 0x20, 0xaf, 0xdf, 0xd1, 0xa);

// {C43DFC6F-62BB-11d2-A727-00C04F79E7C8}
DEFINE_GUID(IID_IImnAccountManager2, 0xc43dfc6f, 0x62bb, 0x11d2, 0xa7, 0x27, 0x0, 0xc0, 0x4f, 0x79, 0xe7, 0xc8);

// {FD465482-1384-11d0-ABBD-0020AFDFD10A}
DEFINE_GUID(IID_IImnAccount, 0xfd465482, 0x1384, 0x11d0, 0xab, 0xbd, 0x0, 0x20, 0xaf, 0xdf, 0xd1, 0xa);

// {FD465483-1384-11d0-ABBD-0020AFDFD10A}
DEFINE_GUID(IID_IImnEnumAccounts, 0xfd465483, 0x1384, 0x11d0, 0xab, 0xbd, 0x0, 0x20, 0xaf, 0xdf, 0xd1, 0xa);

// {8D0AED11-1638-11d0-81B9-00C04FD85AB4}
DEFINE_GUID(IID_IImnAdviseMigrateServer, 0x8d0aed11, 0x1638, 0x11d0, 0x81, 0xb9, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// {0A06BD31-166F-11d0-81B9-00C04FD85AB4}
DEFINE_GUID(IID_IImnAdviseAccount, 0xa06bd31, 0x166f, 0x11d0, 0x81, 0xb9, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

#endif //!WIN16 || __cplusplus

// --------------------------------------------------------------------------------
// Exported C Functions
// --------------------------------------------------------------------------------
#if !defined(_IMNACCT_)
#define IMNACCTAPI DECLSPEC_IMPORT HRESULT WINAPI
#define IMNACCTAPI_(_type_) DECLSPEC_IMPORT _type_ WINAPI
#else
#define IMNACCTAPI HRESULT WINAPI
#define IMNACCTAPI_(_type_) _type_ WINAPI
#endif
#ifdef __cplusplus
extern "C" {
#endif

IMNACCTAPI HrCreateAccountManager(IImnAccountManager **ppAccountManager);
IMNACCTAPI ValidEmailAddress(LPCSTR lpAddress);

#ifdef __cplusplus
}
#endif

// --------------------------------------------------------------------------------
// Errors
// --------------------------------------------------------------------------------
#ifndef FACILITY_INTERNET
#define FACILITY_INTERNET 12
#endif
#ifndef HR_E
#define HR_E(n) MAKE_SCODE(SEVERITY_ERROR, FACILITY_INTERNET, n)
#endif
#ifndef HR_S
#define HR_S(n) MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_INTERNET, n)
#endif
#ifndef HR_CODE
#define HR_CODE(hr) (INT)(hr & 0xffff)
#endif

// --------------------------------------------------------------------------------
// General Errors
// --------------------------------------------------------------------------------
#define E_RegCreateKeyFailed         HR_E(0xCD00)
#define E_RegQueryInfoKeyFailed      HR_E(0xCD01)
#define E_UserCancel                 HR_E(0xCD02)
#define E_RegOpenKeyFailed           HR_E(0xCD03)
#define E_RegSetValueFailed          HR_E(0xCD04)
#define E_RegDeleteKeyFailed         HR_E(0xCD05)
#define E_DuplicateAccountName       HR_E(0xCD06)
#define S_NonStandardValue           HR_S(0xCD07)
#define E_InvalidValue               HR_E(0xCD08)
#define S_AlreadyInitialized         HR_S(0xCD09)

// --------------------------------------------------------------------------------
// IPropertyContainer Errors
// --------------------------------------------------------------------------------
#define E_NoPropData                 HR_E(0xCDA0)
#define E_BufferTooSmall             HR_E(0xCDA1)
#define E_BadPropType                HR_E(0xCDA2)
#define E_BufferSizeMismatch         HR_E(0xCDA3)
#define E_InvalidBooleanValue        HR_E(0xCDA4)
#define E_InvalidMinMaxValue         HR_E(0xCDA5)
#define E_PropNotFound               HR_E(0xCDA6)
#define E_InvalidPropTag             HR_E(0xCDA7)
#define E_InvalidPropertySet         HR_E(0xCDA8)
#define E_EnumFinished               HR_E(0xCDA9)
#define S_NoSaveNeeded               HR_S(0xCDAA)
#define S_PasswordDeleted            HR_S(0xCDAB)
#define S_PasswordNotFound           HR_S(0xCDAC)

// --------------------------------------------------------------------------------
// ImnAccountManager errors
// --------------------------------------------------------------------------------
#define E_NoAccounts                 HR_E(0xCDD0)
#define E_BadFriendlyName            HR_E(0xCDD1)
#define E_NoIdentities               HR_E(0xCDD2)

// --------------------------------------------------------------------------------
// RAS Connection Types
// --------------------------------------------------------------------------------
#define CF_AUTO_CONNECT          FLAG02 // Automatically connect

// --------------------------------------------------------------------------------
// Property Macros
// --------------------------------------------------------------------------------
#define PROPTAG_MASK                 ((ULONG)0x0000FFFF)
#define PROPTAG_TYPE(ulPropTag)      (PROPTYPE)(((ULONG)(ulPropTag)) & PROPTAG_MASK)
#define PROPTAG_ID(ulPropTag)        (((ULONG)(ulPropTag))>>16)
#define PROPTAG(ulPropType,ulPropID) ((((ULONG)(ulPropID))<<16)|((ULONG)(ulPropType)))
#define MAX_PROPID                   ((ULONG) 0xFFFF)

// --------------------------------------------------------------------------------
// IImnAccount Properties
// --------------------------------------------------------------------------------
#define AP_FIRST                    0X1234
// per account properties
#define AP_ACCOUNT_NAME             PROPTAG(TYPE_STRING,    AP_FIRST+1)
#define AP_ACCOUNT_FIRST            AP_ACCOUNT_NAME
#define AP_TEMP_ACCOUNT             PROPTAG(TYPE_DWORD,     AP_FIRST+3)
#define AP_LAST_UPDATED             PROPTAG(TYPE_FILETIME,  AP_FIRST+4)
#define AP_RAS_CONNECTION_TYPE      PROPTAG(TYPE_DWORD,     AP_FIRST+5)
#define AP_RAS_CONNECTOID           PROPTAG(TYPE_STRING,    AP_FIRST+6)
#define AP_RAS_CONNECTION_FLAGS     PROPTAG(TYPE_DWORD,     AP_FIRST+7)
#define AP_ACCOUNT_ID               PROPTAG(TYPE_STRING,    AP_FIRST+9)
#define AP_RAS_BACKUP_CONNECTOID    PROPTAG(TYPE_STRING,    AP_FIRST+10)
#define AP_SERVICE                  PROPTAG(TYPE_STRING,    AP_FIRST+11)
#define AP_AVAIL_OFFLINE            PROPTAG(TYPE_DWORD,     AP_FIRST+12)
#define AP_UNIQUE_ID                PROPTAG(TYPE_BINARY,    AP_FIRST+13)
#define AP_SERVER_READ_ONLY         PROPTAG(TYPE_BOOL,      AP_FIRST+14)
#define AP_ACCOUNT_LAST             AP_SERVER_READ_ONLY

// IMAP properties
#define AP_IMAP_SERVER              PROPTAG(TYPE_STRING,    AP_FIRST+100)
#define AP_IMAP_FIRST               AP_IMAP_SERVER
#define AP_IMAP_USERNAME            PROPTAG(TYPE_STRING,    AP_FIRST+101)
#define AP_IMAP_PASSWORD            PROPTAG(TYPE_PASS,      AP_FIRST+102)
#define AP_IMAP_USE_SICILY          PROPTAG(TYPE_BOOL,      AP_FIRST+104)
#define AP_IMAP_PORT                PROPTAG(TYPE_DWORD,     AP_FIRST+105)
#define AP_IMAP_SSL                 PROPTAG(TYPE_BOOL,      AP_FIRST+106)
#define AP_IMAP_TIMEOUT             PROPTAG(TYPE_DWORD,     AP_FIRST+107)
#define AP_IMAP_ROOT_FOLDER         PROPTAG(TYPE_STRING,    AP_FIRST+108)
#define AP_IMAP_DATA_DIR            PROPTAG(TYPE_STRING,    AP_FIRST+109)
#define AP_IMAP_USE_LSUB            PROPTAG(TYPE_BOOL,      AP_FIRST+111)
#define AP_IMAP_POLL                PROPTAG(TYPE_BOOL,      AP_FIRST+112)
#define AP_IMAP_FULL_LIST           PROPTAG(TYPE_BOOL,      AP_FIRST+113)
#define AP_IMAP_NOOP_INTERVAL       PROPTAG(TYPE_DWORD,     AP_FIRST+114)
#define AP_IMAP_SVRSPECIALFLDRS     PROPTAG(TYPE_BOOL,      AP_FIRST+116)
#define AP_IMAP_SENTITEMSFLDR       PROPTAG(TYPE_STRING,    AP_FIRST+117)
#define AP_IMAP_DRAFTSFLDR          PROPTAG(TYPE_STRING,    AP_FIRST+119)
#define AP_IMAP_PROMPT_PASSWORD     PROPTAG(TYPE_BOOL,      AP_FIRST+124)
#define AP_IMAP_DIRTY               PROPTAG(TYPE_DWORD,     AP_FIRST+125)
#define AP_IMAP_POLL_ALL_FOLDERS    PROPTAG(TYPE_BOOL,      AP_FIRST+126)
#define AP_IMAP_DELETEDITEMSFLDR    PROPTAG(TYPE_STRING,    AP_FIRST+127)
#define AP_IMAP_JUNKFLDR            PROPTAG(TYPE_STRING,    AP_FIRST+128)
#define AP_IMAP_LAST                AP_IMAP_JUNKFLDR

// LDAP properties
#define AP_LDAP_SERVER              PROPTAG(TYPE_STRING,    AP_FIRST+200)
#define AP_LDAP_FIRST               AP_LDAP_SERVER
#define AP_LDAP_USERNAME            PROPTAG(TYPE_STRING,    AP_FIRST+201)
#define AP_LDAP_PASSWORD            PROPTAG(TYPE_PASS,      AP_FIRST+202)
#define AP_LDAP_AUTHENTICATION      PROPTAG(TYPE_DWORD,     AP_FIRST+203)
#define AP_LDAP_TIMEOUT             PROPTAG(TYPE_DWORD,     AP_FIRST+204)
#define AP_LDAP_SEARCH_RETURN       PROPTAG(TYPE_DWORD,     AP_FIRST+205)
#define AP_LDAP_SEARCH_BASE         PROPTAG(TYPE_STRING,    AP_FIRST+206)
#define AP_LDAP_SERVER_ID           PROPTAG(TYPE_DWORD,     AP_FIRST+207)
#define AP_LDAP_RESOLVE_FLAG        PROPTAG(TYPE_DWORD,     AP_FIRST+208)
#define AP_LDAP_URL                 PROPTAG(TYPE_STRING,    AP_FIRST+209)
#define AP_LDAP_PORT                PROPTAG(TYPE_DWORD,     AP_FIRST+210)
#define AP_LDAP_SSL                 PROPTAG(TYPE_BOOL,      AP_FIRST+211)
#define AP_LDAP_LOGO                PROPTAG(TYPE_STRING,    AP_FIRST+212)
#define AP_LDAP_USE_BIND_DN         PROPTAG(TYPE_DWORD,     AP_FIRST+213)
#define AP_LDAP_SIMPLE_SEARCH       PROPTAG(TYPE_DWORD,     AP_FIRST+214)
#define AP_LDAP_ADVANCED_SEARCH_ATTR PROPTAG(TYPE_STRING,   AP_FIRST+215)
#define AP_LDAP_PAGED_RESULTS       PROPTAG(TYPE_DWORD,     AP_FIRST+216)
#define AP_LDAP_NTDS                PROPTAG(TYPE_DWORD,     AP_FIRST+217)
#define AP_LDAP_LAST                AP_LDAP_NTDS

// HTTPMail properties
#define AP_HTTPMAIL_SERVER           PROPTAG(TYPE_STRING,    AP_FIRST+250)
#define AP_HTTPMAIL_FIRST            AP_HTTPMAIL_SERVER
#define AP_HTTPMAIL_USERNAME         PROPTAG(TYPE_STRING,    AP_FIRST+251)
#define AP_HTTPMAIL_PASSWORD         PROPTAG(TYPE_PASS,      AP_FIRST+252)
#define AP_HTTPMAIL_PROMPT_PASSWORD  PROPTAG(TYPE_BOOL,      AP_FIRST+253)
#define AP_HTTPMAIL_USE_SICILY       PROPTAG(TYPE_DWORD,     AP_FIRST+254)
#define AP_HTTPMAIL_FRIENDLY_NAME    PROPTAG(TYPE_STRING,    AP_FIRST+255)
#define AP_HTTPMAIL_DOMAIN_MSN       PROPTAG(TYPE_BOOL,      AP_FIRST+256)
#define AP_HTTPMAIL_POLL             PROPTAG(TYPE_BOOL,      AP_FIRST+257)
#define AP_HTTPMAIL_ADURL              PROPTAG(TYPE_STRING,          AP_FIRST+258)
#define AP_HTTPMAIL_SHOW_ADBAR         PROPTAG(TYPE_BOOL,            AP_FIRST+259)
#define AP_HTTPMAIL_MINPOLLINGINTERVAL PROPTAG(TYPE_ULARGEINTEGER,   AP_FIRST+260)
#define AP_HTTPMAIL_GOTPOLLINGINTERVAL PROPTAG(TYPE_BOOL,            AP_FIRST+261)
#define AP_HTTPMAIL_LASTPOLLEDTIME     PROPTAG(TYPE_ULARGEINTEGER,   AP_FIRST+262)
#define AP_HTTPMAIL_ROOTTIMESTAMP      PROPTAG(TYPE_STRING,          AP_FIRST+263)
#define AP_HTTPMAIL_ROOTINBOXTIMESTAMP PROPTAG(TYPE_STRING,          AP_FIRST+264)
#define AP_HTTPMAIL_INBOXTIMESTAMP     PROPTAG(TYPE_STRING,          AP_FIRST+265)
#define AP_HTTPMAIL_MAXPOLLINGINTERVAL PROPTAG(TYPE_ULARGEINTEGER,   AP_FIRST+266)
#define AP_HTTPMAIL_ADBAR              PROPTAG(TYPE_STRING,          AP_FIRST+267)
#define AP_HTTPMAIL_CONTACTS           PROPTAG(TYPE_STRING,          AP_FIRST+268)
#define AP_HTTPMAIL_INBOX              PROPTAG(TYPE_STRING,          AP_FIRST+269)
#define AP_HTTPMAIL_OUTBOX             PROPTAG(TYPE_STRING,          AP_FIRST+270)
#define AP_HTTPMAIL_SENDMSG            PROPTAG(TYPE_STRING,          AP_FIRST+271)
#define AP_HTTPMAIL_SENTITEMS          PROPTAG(TYPE_STRING,          AP_FIRST+272)
#define AP_HTTPMAIL_DELETEDITEMS       PROPTAG(TYPE_STRING,          AP_FIRST+273)
#define AP_HTTPMAIL_DRAFTS             PROPTAG(TYPE_STRING,          AP_FIRST+274)
#define AP_HTTPMAIL_MSGFOLDERROOT      PROPTAG(TYPE_STRING,          AP_FIRST+275)
#define AP_HTTPMAIL_SIG                PROPTAG(TYPE_STRING,          AP_FIRST+276)
#define AP_HTTPMAIL_HASROOTPROPS       PROPTAG(TYPE_BOOL,            AP_FIRST+277)
#define AP_HTTPMAIL_LAST               AP_HTTPMAIL_HASROOTPROPS

// NNTP properties
#define AP_NNTP_SERVER              PROPTAG(TYPE_STRING,    AP_FIRST+300)
#define AP_NNTP_FIRST               AP_NNTP_SERVER
#define AP_NNTP_USERNAME            PROPTAG(TYPE_STRING,    AP_FIRST+301)
#define AP_NNTP_PASSWORD            PROPTAG(TYPE_PASS,      AP_FIRST+302)
#define AP_NNTP_USE_SICILY          PROPTAG(TYPE_BOOL,      AP_FIRST+304)
#define AP_NNTP_PORT                PROPTAG(TYPE_DWORD,     AP_FIRST+305)
#define AP_NNTP_SSL                 PROPTAG(TYPE_BOOL,      AP_FIRST+306)
#define AP_NNTP_TIMEOUT             PROPTAG(TYPE_DWORD,     AP_FIRST+307)
#define AP_NNTP_DISPLAY_NAME        PROPTAG(TYPE_STRING,    AP_FIRST+308)
#define AP_NNTP_ORG_NAME            PROPTAG(TYPE_STRING,    AP_FIRST+309)
#define AP_NNTP_EMAIL_ADDRESS       PROPTAG(TYPE_STRING,    AP_FIRST+310)
#define AP_NNTP_REPLY_EMAIL_ADDRESS PROPTAG(TYPE_STRING,    AP_FIRST+311)
#define AP_NNTP_SPLIT_MESSAGES      PROPTAG(TYPE_BOOL,      AP_FIRST+312)
#define AP_NNTP_SPLIT_SIZE          PROPTAG(TYPE_DWORD,     AP_FIRST+313)
#define AP_NNTP_USE_DESCRIPTIONS    PROPTAG(TYPE_BOOL,      AP_FIRST+314)
#define AP_NNTP_DATA_DIR            PROPTAG(TYPE_STRING,    AP_FIRST+315)
#define AP_NNTP_POLL                PROPTAG(TYPE_BOOL,      AP_FIRST+316)
#define AP_NNTP_POST_FORMAT         PROPTAG(TYPE_DWORD,     AP_FIRST+317)
#define AP_NNTP_SIGNATURE           PROPTAG(TYPE_STRING,    AP_FIRST+318)
#define AP_NNTP_PROMPT_PASSWORD     PROPTAG(TYPE_BOOL,      AP_FIRST+319)
#define AP_NNTP_COMMUNITIES         PROPTAG(TYPE_DWORD,     AP_FIRST+320)
#define AP_NNTP_PASSPORT_MEMBERNAME PROPTAG(TYPE_STRING,    AP_FIRST+321)
#define AP_NNTP_COMMUNITYSERVERDATA PROPTAG(TYPE_BINARY,    AP_FIRST+322)
#define AP_NNTP_PASSPORTSESSIONDATA PROPTAG(TYPE_BINARY,    AP_FIRST+323)
#define AP_NNTP_USER_INFORMATION    PROPTAG(TYPE_DWORD,     AP_FIRST+324)
#define AP_NNTP_LAST                AP_NNTP_USER_INFORMATION

// POP3 properties
#define AP_POP3_SERVER              PROPTAG(TYPE_STRING,    AP_FIRST+400)
#define AP_POP3_FIRST               AP_POP3_SERVER
#define AP_POP3_USERNAME            PROPTAG(TYPE_STRING,    AP_FIRST+401)
#define AP_POP3_PASSWORD            PROPTAG(TYPE_PASS,      AP_FIRST+402)
#define AP_POP3_USE_SICILY          PROPTAG(TYPE_BOOL,      AP_FIRST+404)
#define AP_POP3_PORT                PROPTAG(TYPE_DWORD,     AP_FIRST+405)
#define AP_POP3_SSL                 PROPTAG(TYPE_BOOL,      AP_FIRST+406)
#define AP_POP3_TIMEOUT             PROPTAG(TYPE_DWORD,     AP_FIRST+407)
#define AP_POP3_LEAVE_ON_SERVER     PROPTAG(TYPE_BOOL,      AP_FIRST+408)
#define AP_POP3_REMOVE_DELETED      PROPTAG(TYPE_BOOL,      AP_FIRST+409)
#define AP_POP3_REMOVE_EXPIRED      PROPTAG(TYPE_BOOL,      AP_FIRST+410)
#define AP_POP3_EXPIRE_DAYS         PROPTAG(TYPE_DWORD,     AP_FIRST+411)
#define AP_POP3_SKIP                PROPTAG(TYPE_BOOL,      AP_FIRST+412)
#define AP_POP3_OUTLOOK_CACHE_NAME  PROPTAG(TYPE_STRING,    AP_FIRST+413)
#define AP_POP3_PROMPT_PASSWORD     PROPTAG(TYPE_BOOL,      AP_FIRST+414)
#define AP_POP3_LAST                AP_POP3_PROMPT_PASSWORD

// SMTP properties
#define AP_SMTP_SERVER              PROPTAG(TYPE_STRING,    AP_FIRST+500)
#define AP_SMTP_FIRST               AP_SMTP_SERVER
#define AP_SMTP_USERNAME            PROPTAG(TYPE_STRING,    AP_FIRST+501)
#define AP_SMTP_PASSWORD            PROPTAG(TYPE_PASS,      AP_FIRST+502)
#define AP_SMTP_USE_SICILY          PROPTAG(TYPE_DWORD,     AP_FIRST+504) // SMTPAUTHTYEP
#define AP_SMTP_PORT                PROPTAG(TYPE_DWORD,     AP_FIRST+505)
#define AP_SMTP_SSL                 PROPTAG(TYPE_BOOL,      AP_FIRST+506)
#define AP_SMTP_TIMEOUT             PROPTAG(TYPE_DWORD,     AP_FIRST+507)
#define AP_SMTP_DISPLAY_NAME        PROPTAG(TYPE_STRING,    AP_FIRST+508)
#define AP_SMTP_ORG_NAME            PROPTAG(TYPE_STRING,    AP_FIRST+509)
#define AP_SMTP_EMAIL_ADDRESS       PROPTAG(TYPE_STRING,    AP_FIRST+510)
#define AP_SMTP_REPLY_EMAIL_ADDRESS PROPTAG(TYPE_STRING,    AP_FIRST+511)
#define AP_SMTP_SPLIT_MESSAGES      PROPTAG(TYPE_BOOL,      AP_FIRST+512)
#define AP_SMTP_SPLIT_SIZE          PROPTAG(TYPE_DWORD,     AP_FIRST+513)
#define AP_SMTP_CERTIFICATE         PROPTAG(TYPE_BINARY,    AP_FIRST+514)
#define AP_SMTP_SIGNATURE           PROPTAG(TYPE_STRING,    AP_FIRST+515)
#define AP_SMTP_PROMPT_PASSWORD     PROPTAG(TYPE_BOOL,      AP_FIRST+516)
#define AP_SMTP_ENCRYPT_CERT           PROPTAG(TYPE_BINARY,      AP_FIRST+517)
#define AP_SMTP_ENCRYPT_ALGTH       PROPTAG(TYPE_BINARY,      AP_FIRST+518)
#define AP_SMTP_LAST                AP_SMTP_ENCRYPT_ALGTH

// --------------------------------------------------------------------------------
// Account Flags
// --------------------------------------------------------------------------------
#define ACCT_FLAG_NEWS           ((DWORD)1)
#define ACCT_FLAG_MAIL           ((DWORD)2)
#define ACCT_FLAG_DIR_SERV       ((DWORD)4)
#define ACCT_FLAG_ALL            (ACCT_FLAG_NEWS | ACCT_FLAG_MAIL | ACCT_FLAG_DIR_SERV)

// --------------------------------------------------------------------------------
// Server Types
// --------------------------------------------------------------------------------
#define SRV_NNTP                 ((DWORD)1)
#define SRV_IMAP                 ((DWORD)2)
#define SRV_POP3                 ((DWORD)4)
#define SRV_SMTP                 ((DWORD)8)
#define SRV_LDAP                 ((DWORD)16)
#define SRV_HTTPMAIL             ((DWORD)32)
#define SRV_MAIL                 ((DWORD)(SRV_IMAP | SRV_POP3 | SRV_SMTP | SRV_HTTPMAIL))
#define SRV_ALL                  ((DWORD)(SRV_NNTP | SRV_IMAP | SRV_POP3 | SRV_SMTP | SRV_LDAP | SRV_HTTPMAIL))

// --------------------------------------------------------------------------------
// LDAP Authentication Types
// --------------------------------------------------------------------------------
#define LDAP_AUTH_ANONYMOUS      ((DWORD)0)
#define LDAP_AUTH_PASSWORD       ((DWORD)1)
#define LDAP_AUTH_MEMBER_SYSTEM  ((DWORD)2)
#define LDAP_AUTH_MAX            ((DWORD)2)

// --------------------------------------------------------------------------------
// LDAP Paged Result Support Types
// --------------------------------------------------------------------------------
#define LDAP_PRESULT_UNKNOWN         ((DWORD)0)
#define LDAP_PRESULT_SUPPORTED       ((DWORD)1)
#define LDAP_PRESULT_NOTSUPPORTED    ((DWORD)2)
#define LDAP_PRESULT_MAX             ((DWORD)2)

// --------------------------------------------------------------------------------
// LDAP NTDS Types
// --------------------------------------------------------------------------------
#define LDAP_NTDS_UNKNOWN      ((DWORD)0)
#define LDAP_NTDS_IS           ((DWORD)1)
#define LDAP_NTDS_ISNOT        ((DWORD)2)
#define LDAP_NTDS_MAX          ((DWORD)2)

// --------------------------------------------------------------------------------
// AP_NNTP_POST_FORMAT types
// --------------------------------------------------------------------------------
#define POST_USE_DEFAULT         ((DWORD)0)
#define POST_USE_PLAIN_TEXT      ((DWORD)1)
#define POST_USE_HTML            ((DWORD)2)

// --------------------------------------------------------------------------------
// AP_NNTP_USER_INFORMATION types
// --------------------------------------------------------------------------------
#define NNTP_USER_AUTOCONFIG     ((DWORD)0)
#define NNTP_USER_NOTIFIED       ((DWORD)1)
#define NNTP_USER_DONTSHOW       ((DWORD)2)
#define NNTP_USER_APPROVED       ((DWORD)3)

// -----------------------------------------------------------------------------
// Account Manager Notification Types
// -----------------------------------------------------------------------------
#define AN_ACCOUNT_DELETED           WM_USER + 1
#define AN_ACCOUNT_ADDED             WM_USER + 2
#define AN_ACCOUNT_CHANGED           WM_USER + 3
#define AN_DEFAULT_CHANGED           WM_USER + 4
#define AN_SERVERTYPES_CHANGED       WM_USER + 5
#define AN_ACCOUNT_PREDELETE         WM_USER + 6

// IImnAccountManager::AccountListDialog flags
// IImnAccount::ShowProperties flags
#define ACCTDLG_NO_IMAP          0x0001
#define ACCTDLG_NO_REMOVEDELETE  0x0002
#define ACCTDLG_NO_BREAKMESSAGES 0x0004
#define ACCTDLG_NO_REMOVEAFTER   0x0008
#define ACCTDLG_NO_SENDRECEIVE   0x0010
#define ACCTDLG_NO_NEWSPOLL      0x0020
#define ACCTDLG_NO_SECURITY      0x0040
#define ACCTDLG_BACKUP_CONNECT   0x0080
#define ACCTDLG_NO_IMAPPOLL      0x0100
#define ACCTDLG_NO_NEW_POP       0x0200
#define ACCTDLG_SHOWIMAPSPECIAL  0x0400
#define ACCTDLG_INTERNETCONNECTION   0x0800
#define ACCTDLG_HTTPMAIL             0x1000
#define ACCTDLG_REVOCATION           0x2000
#define ACCTDLG_OE                   0x4000
#define ACCTDLG_PASSPORT             0x8000
#define ACCTDLG_ALL                  0xffff

// AP_RAS_CONNECTION_TYPE            values
#define CONNECTION_TYPE_LAN               0
#define CONNECTION_TYPE_MANUAL            1
#define CONNECTION_TYPE_RAS               2
#define CONNECTION_TYPE_INETSETTINGS      3

// IImnAccount::DoWizard flags
#define ACCT_WIZ_MIGRATE             0x0001
#define ACCT_WIZ_MAILIMPORT          0x0002
#define ACCT_WIZ_OUTLOOK             0x0004
#define ACCT_WIZ_NEWSIMPORT          0x0008
#define ACCT_WIZ_NO_NEW_POP          0x0010
#define ACCT_WIZ_INTERNETCONNECTION  0x0020
#define ACCT_WIZ_HTTPMAIL            0x0040
#define ACCT_WIZ_OE                  0x0080
#define ACCT_WIZ_COMMUNITIES         0x0100

// IImnAccount::InitEx flags
#define ACCT_INIT_ATHENA         0x0001
#define ACCT_INIT_OUTLOOK        0x0002

 // AP_IMAP_DIRTY flags
#define IMAP_FLDRLIST_DIRTY      0x0001
#define IMAP_OE4MIGRATE_DIRTY    0x0002
#define IMAP_SENTITEMS_DIRTY     0x0004
#define IMAP_DRAFTS_DIRTY        0x0008
#define IMAP_DELETEDITEMS_DIRTY  0x0010
#define IMAP_JUNK_DIRTY          0x0020
typedef 
enum tagSMTPAUTHTYPE
    {	SMTP_AUTH_NONE	= 0,
	SMTP_AUTH_SICILY	= SMTP_AUTH_NONE + 1,
	SMTP_AUTH_USE_POP3ORIMAP_SETTINGS	= SMTP_AUTH_SICILY + 1,
	SMTP_AUTH_USE_SMTP_SETTINGS	= SMTP_AUTH_USE_POP3ORIMAP_SETTINGS + 1
    }	SMTPAUTHTYPE;

#define	CCHMAX_ORG_NAME	( 256 )

#define	CCHMAX_DISPLAY_NAME	( 256 )

#define	CCHMAX_ACCOUNT_NAME	( 256 )

#define	CCHMAX_SERVER_NAME	( 256 )

#define	CCHMAX_PASSWORD	( 256 )

#define	CCHMAX_USERNAME	( 256 )

#define	CCHMAX_EMAIL_ADDRESS	( 256 )

#define	CCHMAX_CONNECTOID	( 256 )

#define	CCHMAX_SEARCH_BASE	( 256 )

#define	CCHMAX_ROOT_FOLDER	( 256 )

#define	CCHMAX_SIGNATURE	( 16 )

#define	CCHMAX_SERVICE	( 256 )



extern RPC_IF_HANDLE __MIDL_itf_imnact_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_imnact_0000_v0_0_s_ifspec;

#ifndef __IImnAdviseAccount_INTERFACE_DEFINED__
#define __IImnAdviseAccount_INTERFACE_DEFINED__

/* interface IImnAdviseAccount */
/* [unique][uuid][object] */ 

typedef /* [public][public][public][public][public][public][public][public][public][public][public][public] */ 
enum __MIDL_IImnAdviseAccount_0001
    {	ACCT_NEWS	= 0,
	ACCT_MAIL	= ACCT_NEWS + 1,
	ACCT_DIR_SERV	= ACCT_MAIL + 1,
	ACCT_LAST	= ACCT_DIR_SERV + 1
    }	ACCTTYPE;

typedef struct tagAccountContext
    {
    ACCTTYPE AcctType;
    LPSTR pszAccountID;
    LPSTR pszOldName;
    DWORD dwServerType;
    }	ACTX;


EXTERN_C const IID IID_IImnAdviseAccount;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0A06BD31-166F-11d0-81B9-00C04FD85AB4")
    IImnAdviseAccount : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AdviseAccount( 
            /* [in] */ DWORD dwAdviseType,
            /* [in] */ ACTX __RPC_FAR *pAcctCtx) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IImnAdviseAccountVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IImnAdviseAccount __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IImnAdviseAccount __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IImnAdviseAccount __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AdviseAccount )( 
            IImnAdviseAccount __RPC_FAR * This,
            /* [in] */ DWORD dwAdviseType,
            /* [in] */ ACTX __RPC_FAR *pAcctCtx);
        
        END_INTERFACE
    } IImnAdviseAccountVtbl;

    interface IImnAdviseAccount
    {
        CONST_VTBL struct IImnAdviseAccountVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IImnAdviseAccount_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IImnAdviseAccount_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IImnAdviseAccount_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IImnAdviseAccount_AdviseAccount(This,dwAdviseType,pAcctCtx)	\
    (This)->lpVtbl -> AdviseAccount(This,dwAdviseType,pAcctCtx)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IImnAdviseAccount_AdviseAccount_Proxy( 
    IImnAdviseAccount __RPC_FAR * This,
    /* [in] */ DWORD dwAdviseType,
    /* [in] */ ACTX __RPC_FAR *pAcctCtx);


void __RPC_STUB IImnAdviseAccount_AdviseAccount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IImnAdviseAccount_INTERFACE_DEFINED__ */


#ifndef __IImnAdviseMigrateServer_INTERFACE_DEFINED__
#define __IImnAdviseMigrateServer_INTERFACE_DEFINED__

/* interface IImnAdviseMigrateServer */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IImnAdviseMigrateServer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8D0AED11-1638-11d0-81B9-00C04FD85AB4")
    IImnAdviseMigrateServer : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE MigrateServer( 
            /* [in] */ DWORD dwSrvType,
            /* [in] */ IImnAccount __RPC_FAR *pAccount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IImnAdviseMigrateServerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IImnAdviseMigrateServer __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IImnAdviseMigrateServer __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IImnAdviseMigrateServer __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MigrateServer )( 
            IImnAdviseMigrateServer __RPC_FAR * This,
            /* [in] */ DWORD dwSrvType,
            /* [in] */ IImnAccount __RPC_FAR *pAccount);
        
        END_INTERFACE
    } IImnAdviseMigrateServerVtbl;

    interface IImnAdviseMigrateServer
    {
        CONST_VTBL struct IImnAdviseMigrateServerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IImnAdviseMigrateServer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IImnAdviseMigrateServer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IImnAdviseMigrateServer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IImnAdviseMigrateServer_MigrateServer(This,dwSrvType,pAccount)	\
    (This)->lpVtbl -> MigrateServer(This,dwSrvType,pAccount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IImnAdviseMigrateServer_MigrateServer_Proxy( 
    IImnAdviseMigrateServer __RPC_FAR * This,
    /* [in] */ DWORD dwSrvType,
    /* [in] */ IImnAccount __RPC_FAR *pAccount);


void __RPC_STUB IImnAdviseMigrateServer_MigrateServer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IImnAdviseMigrateServer_INTERFACE_DEFINED__ */


#ifndef __IImnEnumAccounts_INTERFACE_DEFINED__
#define __IImnEnumAccounts_INTERFACE_DEFINED__

/* interface IImnEnumAccounts */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IImnEnumAccounts;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FD465483-1384-11d0-ABBD-0020AFDFD10A")
    IImnEnumAccounts : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ ULONG __RPC_FAR *pcItems) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SortByAccountName( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNext( 
            /* [out] */ IImnAccount __RPC_FAR *__RPC_FAR *ppAccount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IImnEnumAccountsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IImnEnumAccounts __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IImnEnumAccounts __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IImnEnumAccounts __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCount )( 
            IImnEnumAccounts __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pcItems);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SortByAccountName )( 
            IImnEnumAccounts __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNext )( 
            IImnEnumAccounts __RPC_FAR * This,
            /* [out] */ IImnAccount __RPC_FAR *__RPC_FAR *ppAccount);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IImnEnumAccounts __RPC_FAR * This);
        
        END_INTERFACE
    } IImnEnumAccountsVtbl;

    interface IImnEnumAccounts
    {
        CONST_VTBL struct IImnEnumAccountsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IImnEnumAccounts_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IImnEnumAccounts_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IImnEnumAccounts_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IImnEnumAccounts_GetCount(This,pcItems)	\
    (This)->lpVtbl -> GetCount(This,pcItems)

#define IImnEnumAccounts_SortByAccountName(This)	\
    (This)->lpVtbl -> SortByAccountName(This)

#define IImnEnumAccounts_GetNext(This,ppAccount)	\
    (This)->lpVtbl -> GetNext(This,ppAccount)

#define IImnEnumAccounts_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IImnEnumAccounts_GetCount_Proxy( 
    IImnEnumAccounts __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *pcItems);


void __RPC_STUB IImnEnumAccounts_GetCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImnEnumAccounts_SortByAccountName_Proxy( 
    IImnEnumAccounts __RPC_FAR * This);


void __RPC_STUB IImnEnumAccounts_SortByAccountName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImnEnumAccounts_GetNext_Proxy( 
    IImnEnumAccounts __RPC_FAR * This,
    /* [out] */ IImnAccount __RPC_FAR *__RPC_FAR *ppAccount);


void __RPC_STUB IImnEnumAccounts_GetNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImnEnumAccounts_Reset_Proxy( 
    IImnEnumAccounts __RPC_FAR * This);


void __RPC_STUB IImnEnumAccounts_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IImnEnumAccounts_INTERFACE_DEFINED__ */


#ifndef __IImnAccountManager_INTERFACE_DEFINED__
#define __IImnAccountManager_INTERFACE_DEFINED__

/* interface IImnAccountManager */
/* [unique][uuid][object] */ 

typedef struct tagACCTLISTINFO
    {
    DWORD cbSize;
    ACCTTYPE AcctTypeInit;
    DWORD dwAcctFlags;
    DWORD dwFlags;
    }	ACCTLISTINFO;




EXTERN_C const IID IID_IImnAccountManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FD465481-1384-11d0-ABBD-0020AFDFD10A")
    IImnAccountManager : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Init( 
            /* [in] */ IImnAdviseMigrateServer __RPC_FAR *pAdviseMigrateServer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateAccountObject( 
            /* [in] */ ACCTTYPE AcctType,
            /* [out] */ IImnAccount __RPC_FAR *__RPC_FAR *ppAccount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Enumerate( 
            /* [in] */ DWORD dwSrvTypes,
            /* [out] */ IImnEnumAccounts __RPC_FAR *__RPC_FAR *ppEnumAccounts) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAccountCount( 
            /* [in] */ ACCTTYPE AcctType,
            /* [out] */ ULONG __RPC_FAR *pcServers) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindAccount( 
            /* [in] */ DWORD dwPropTag,
            /* [in] */ LPCSTR pszSearchData,
            /* [out] */ IImnAccount __RPC_FAR *__RPC_FAR *ppAccount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDefaultAccount( 
            /* [in] */ ACCTTYPE AcctType,
            /* [out] */ IImnAccount __RPC_FAR *__RPC_FAR *ppAccount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDefaultAccountName( 
            /* [in] */ ACCTTYPE AcctType,
            /* [size_is][out] */ LPSTR pszAccount,
            /* [in] */ ULONG cchMax) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ProcessNotification( 
            /* [in] */ UINT uMsg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ValidateDefaultSendAccount( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AccountListDialog( 
            /* [in] */ HWND hwnd,
            /* [in] */ ACCTLISTINFO __RPC_FAR *pinfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Advise( 
            /* [in] */ IImnAdviseAccount __RPC_FAR *pAdviseAccount,
            /* [out] */ DWORD __RPC_FAR *pdwConnection) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Unadvise( 
            /* [in] */ DWORD dwConnection) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetUniqueAccountName( 
            /* [in] */ LPSTR szName,
            /* [in] */ UINT cch) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InitEx( 
            /* [in] */ IImnAdviseMigrateServer __RPC_FAR *pAdviseMigrateServer,
            /* [in] */ DWORD dwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IImnAccountManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IImnAccountManager __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IImnAccountManager __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IImnAccountManager __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Init )( 
            IImnAccountManager __RPC_FAR * This,
            /* [in] */ IImnAdviseMigrateServer __RPC_FAR *pAdviseMigrateServer);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateAccountObject )( 
            IImnAccountManager __RPC_FAR * This,
            /* [in] */ ACCTTYPE AcctType,
            /* [out] */ IImnAccount __RPC_FAR *__RPC_FAR *ppAccount);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Enumerate )( 
            IImnAccountManager __RPC_FAR * This,
            /* [in] */ DWORD dwSrvTypes,
            /* [out] */ IImnEnumAccounts __RPC_FAR *__RPC_FAR *ppEnumAccounts);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAccountCount )( 
            IImnAccountManager __RPC_FAR * This,
            /* [in] */ ACCTTYPE AcctType,
            /* [out] */ ULONG __RPC_FAR *pcServers);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindAccount )( 
            IImnAccountManager __RPC_FAR * This,
            /* [in] */ DWORD dwPropTag,
            /* [in] */ LPCSTR pszSearchData,
            /* [out] */ IImnAccount __RPC_FAR *__RPC_FAR *ppAccount);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDefaultAccount )( 
            IImnAccountManager __RPC_FAR * This,
            /* [in] */ ACCTTYPE AcctType,
            /* [out] */ IImnAccount __RPC_FAR *__RPC_FAR *ppAccount);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDefaultAccountName )( 
            IImnAccountManager __RPC_FAR * This,
            /* [in] */ ACCTTYPE AcctType,
            /* [size_is][out] */ LPSTR pszAccount,
            /* [in] */ ULONG cchMax);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ProcessNotification )( 
            IImnAccountManager __RPC_FAR * This,
            /* [in] */ UINT uMsg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ValidateDefaultSendAccount )( 
            IImnAccountManager __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AccountListDialog )( 
            IImnAccountManager __RPC_FAR * This,
            /* [in] */ HWND hwnd,
            /* [in] */ ACCTLISTINFO __RPC_FAR *pinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Advise )( 
            IImnAccountManager __RPC_FAR * This,
            /* [in] */ IImnAdviseAccount __RPC_FAR *pAdviseAccount,
            /* [out] */ DWORD __RPC_FAR *pdwConnection);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Unadvise )( 
            IImnAccountManager __RPC_FAR * This,
            /* [in] */ DWORD dwConnection);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetUniqueAccountName )( 
            IImnAccountManager __RPC_FAR * This,
            /* [in] */ LPSTR szName,
            /* [in] */ UINT cch);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InitEx )( 
            IImnAccountManager __RPC_FAR * This,
            /* [in] */ IImnAdviseMigrateServer __RPC_FAR *pAdviseMigrateServer,
            /* [in] */ DWORD dwFlags);
        
        END_INTERFACE
    } IImnAccountManagerVtbl;

    interface IImnAccountManager
    {
        CONST_VTBL struct IImnAccountManagerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IImnAccountManager_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IImnAccountManager_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IImnAccountManager_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IImnAccountManager_Init(This,pAdviseMigrateServer)	\
    (This)->lpVtbl -> Init(This,pAdviseMigrateServer)

#define IImnAccountManager_CreateAccountObject(This,AcctType,ppAccount)	\
    (This)->lpVtbl -> CreateAccountObject(This,AcctType,ppAccount)

#define IImnAccountManager_Enumerate(This,dwSrvTypes,ppEnumAccounts)	\
    (This)->lpVtbl -> Enumerate(This,dwSrvTypes,ppEnumAccounts)

#define IImnAccountManager_GetAccountCount(This,AcctType,pcServers)	\
    (This)->lpVtbl -> GetAccountCount(This,AcctType,pcServers)

#define IImnAccountManager_FindAccount(This,dwPropTag,pszSearchData,ppAccount)	\
    (This)->lpVtbl -> FindAccount(This,dwPropTag,pszSearchData,ppAccount)

#define IImnAccountManager_GetDefaultAccount(This,AcctType,ppAccount)	\
    (This)->lpVtbl -> GetDefaultAccount(This,AcctType,ppAccount)

#define IImnAccountManager_GetDefaultAccountName(This,AcctType,pszAccount,cchMax)	\
    (This)->lpVtbl -> GetDefaultAccountName(This,AcctType,pszAccount,cchMax)

#define IImnAccountManager_ProcessNotification(This,uMsg,wParam,lParam)	\
    (This)->lpVtbl -> ProcessNotification(This,uMsg,wParam,lParam)

#define IImnAccountManager_ValidateDefaultSendAccount(This)	\
    (This)->lpVtbl -> ValidateDefaultSendAccount(This)

#define IImnAccountManager_AccountListDialog(This,hwnd,pinfo)	\
    (This)->lpVtbl -> AccountListDialog(This,hwnd,pinfo)

#define IImnAccountManager_Advise(This,pAdviseAccount,pdwConnection)	\
    (This)->lpVtbl -> Advise(This,pAdviseAccount,pdwConnection)

#define IImnAccountManager_Unadvise(This,dwConnection)	\
    (This)->lpVtbl -> Unadvise(This,dwConnection)

#define IImnAccountManager_GetUniqueAccountName(This,szName,cch)	\
    (This)->lpVtbl -> GetUniqueAccountName(This,szName,cch)

#define IImnAccountManager_InitEx(This,pAdviseMigrateServer,dwFlags)	\
    (This)->lpVtbl -> InitEx(This,pAdviseMigrateServer,dwFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IImnAccountManager_Init_Proxy( 
    IImnAccountManager __RPC_FAR * This,
    /* [in] */ IImnAdviseMigrateServer __RPC_FAR *pAdviseMigrateServer);


void __RPC_STUB IImnAccountManager_Init_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImnAccountManager_CreateAccountObject_Proxy( 
    IImnAccountManager __RPC_FAR * This,
    /* [in] */ ACCTTYPE AcctType,
    /* [out] */ IImnAccount __RPC_FAR *__RPC_FAR *ppAccount);


void __RPC_STUB IImnAccountManager_CreateAccountObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImnAccountManager_Enumerate_Proxy( 
    IImnAccountManager __RPC_FAR * This,
    /* [in] */ DWORD dwSrvTypes,
    /* [out] */ IImnEnumAccounts __RPC_FAR *__RPC_FAR *ppEnumAccounts);


void __RPC_STUB IImnAccountManager_Enumerate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImnAccountManager_GetAccountCount_Proxy( 
    IImnAccountManager __RPC_FAR * This,
    /* [in] */ ACCTTYPE AcctType,
    /* [out] */ ULONG __RPC_FAR *pcServers);


void __RPC_STUB IImnAccountManager_GetAccountCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImnAccountManager_FindAccount_Proxy( 
    IImnAccountManager __RPC_FAR * This,
    /* [in] */ DWORD dwPropTag,
    /* [in] */ LPCSTR pszSearchData,
    /* [out] */ IImnAccount __RPC_FAR *__RPC_FAR *ppAccount);


void __RPC_STUB IImnAccountManager_FindAccount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImnAccountManager_GetDefaultAccount_Proxy( 
    IImnAccountManager __RPC_FAR * This,
    /* [in] */ ACCTTYPE AcctType,
    /* [out] */ IImnAccount __RPC_FAR *__RPC_FAR *ppAccount);


void __RPC_STUB IImnAccountManager_GetDefaultAccount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImnAccountManager_GetDefaultAccountName_Proxy( 
    IImnAccountManager __RPC_FAR * This,
    /* [in] */ ACCTTYPE AcctType,
    /* [size_is][out] */ LPSTR pszAccount,
    /* [in] */ ULONG cchMax);


void __RPC_STUB IImnAccountManager_GetDefaultAccountName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImnAccountManager_ProcessNotification_Proxy( 
    IImnAccountManager __RPC_FAR * This,
    /* [in] */ UINT uMsg,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam);


void __RPC_STUB IImnAccountManager_ProcessNotification_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImnAccountManager_ValidateDefaultSendAccount_Proxy( 
    IImnAccountManager __RPC_FAR * This);


void __RPC_STUB IImnAccountManager_ValidateDefaultSendAccount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImnAccountManager_AccountListDialog_Proxy( 
    IImnAccountManager __RPC_FAR * This,
    /* [in] */ HWND hwnd,
    /* [in] */ ACCTLISTINFO __RPC_FAR *pinfo);


void __RPC_STUB IImnAccountManager_AccountListDialog_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImnAccountManager_Advise_Proxy( 
    IImnAccountManager __RPC_FAR * This,
    /* [in] */ IImnAdviseAccount __RPC_FAR *pAdviseAccount,
    /* [out] */ DWORD __RPC_FAR *pdwConnection);


void __RPC_STUB IImnAccountManager_Advise_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImnAccountManager_Unadvise_Proxy( 
    IImnAccountManager __RPC_FAR * This,
    /* [in] */ DWORD dwConnection);


void __RPC_STUB IImnAccountManager_Unadvise_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImnAccountManager_GetUniqueAccountName_Proxy( 
    IImnAccountManager __RPC_FAR * This,
    /* [in] */ LPSTR szName,
    /* [in] */ UINT cch);


void __RPC_STUB IImnAccountManager_GetUniqueAccountName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImnAccountManager_InitEx_Proxy( 
    IImnAccountManager __RPC_FAR * This,
    /* [in] */ IImnAdviseMigrateServer __RPC_FAR *pAdviseMigrateServer,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IImnAccountManager_InitEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IImnAccountManager_INTERFACE_DEFINED__ */


#ifndef __IImnAccountManager2_INTERFACE_DEFINED__
#define __IImnAccountManager2_INTERFACE_DEFINED__

/* interface IImnAccountManager2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IImnAccountManager2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C43DFC6F-62BB-11d2-A727-00C04F79E7C8")
    IImnAccountManager2 : public IImnAccountManager
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InitUser( 
            /* [in] */ IImnAdviseMigrateServer __RPC_FAR *pAdviseMigrateServer,
            /* [in] */ REFGUID rguidID,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIncompleteAccount( 
            /* [in] */ ACCTTYPE AcctType,
            /* [ref][in] */ LPSTR pszAccountId,
            /* [in] */ ULONG cchMax) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetIncompleteAccount( 
            /* [in] */ ACCTTYPE AcctType,
            /* [unique][in] */ LPCSTR pszAccountId) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IImnAccountManager2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IImnAccountManager2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IImnAccountManager2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IImnAccountManager2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Init )( 
            IImnAccountManager2 __RPC_FAR * This,
            /* [in] */ IImnAdviseMigrateServer __RPC_FAR *pAdviseMigrateServer);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateAccountObject )( 
            IImnAccountManager2 __RPC_FAR * This,
            /* [in] */ ACCTTYPE AcctType,
            /* [out] */ IImnAccount __RPC_FAR *__RPC_FAR *ppAccount);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Enumerate )( 
            IImnAccountManager2 __RPC_FAR * This,
            /* [in] */ DWORD dwSrvTypes,
            /* [out] */ IImnEnumAccounts __RPC_FAR *__RPC_FAR *ppEnumAccounts);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAccountCount )( 
            IImnAccountManager2 __RPC_FAR * This,
            /* [in] */ ACCTTYPE AcctType,
            /* [out] */ ULONG __RPC_FAR *pcServers);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindAccount )( 
            IImnAccountManager2 __RPC_FAR * This,
            /* [in] */ DWORD dwPropTag,
            /* [in] */ LPCSTR pszSearchData,
            /* [out] */ IImnAccount __RPC_FAR *__RPC_FAR *ppAccount);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDefaultAccount )( 
            IImnAccountManager2 __RPC_FAR * This,
            /* [in] */ ACCTTYPE AcctType,
            /* [out] */ IImnAccount __RPC_FAR *__RPC_FAR *ppAccount);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDefaultAccountName )( 
            IImnAccountManager2 __RPC_FAR * This,
            /* [in] */ ACCTTYPE AcctType,
            /* [size_is][out] */ LPSTR pszAccount,
            /* [in] */ ULONG cchMax);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ProcessNotification )( 
            IImnAccountManager2 __RPC_FAR * This,
            /* [in] */ UINT uMsg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ValidateDefaultSendAccount )( 
            IImnAccountManager2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AccountListDialog )( 
            IImnAccountManager2 __RPC_FAR * This,
            /* [in] */ HWND hwnd,
            /* [in] */ ACCTLISTINFO __RPC_FAR *pinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Advise )( 
            IImnAccountManager2 __RPC_FAR * This,
            /* [in] */ IImnAdviseAccount __RPC_FAR *pAdviseAccount,
            /* [out] */ DWORD __RPC_FAR *pdwConnection);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Unadvise )( 
            IImnAccountManager2 __RPC_FAR * This,
            /* [in] */ DWORD dwConnection);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetUniqueAccountName )( 
            IImnAccountManager2 __RPC_FAR * This,
            /* [in] */ LPSTR szName,
            /* [in] */ UINT cch);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InitEx )( 
            IImnAccountManager2 __RPC_FAR * This,
            /* [in] */ IImnAdviseMigrateServer __RPC_FAR *pAdviseMigrateServer,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InitUser )( 
            IImnAccountManager2 __RPC_FAR * This,
            /* [in] */ IImnAdviseMigrateServer __RPC_FAR *pAdviseMigrateServer,
            /* [in] */ REFGUID rguidID,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIncompleteAccount )( 
            IImnAccountManager2 __RPC_FAR * This,
            /* [in] */ ACCTTYPE AcctType,
            /* [ref][in] */ LPSTR pszAccountId,
            /* [in] */ ULONG cchMax);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetIncompleteAccount )( 
            IImnAccountManager2 __RPC_FAR * This,
            /* [in] */ ACCTTYPE AcctType,
            /* [unique][in] */ LPCSTR pszAccountId);
        
        END_INTERFACE
    } IImnAccountManager2Vtbl;

    interface IImnAccountManager2
    {
        CONST_VTBL struct IImnAccountManager2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IImnAccountManager2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IImnAccountManager2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IImnAccountManager2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IImnAccountManager2_Init(This,pAdviseMigrateServer)	\
    (This)->lpVtbl -> Init(This,pAdviseMigrateServer)

#define IImnAccountManager2_CreateAccountObject(This,AcctType,ppAccount)	\
    (This)->lpVtbl -> CreateAccountObject(This,AcctType,ppAccount)

#define IImnAccountManager2_Enumerate(This,dwSrvTypes,ppEnumAccounts)	\
    (This)->lpVtbl -> Enumerate(This,dwSrvTypes,ppEnumAccounts)

#define IImnAccountManager2_GetAccountCount(This,AcctType,pcServers)	\
    (This)->lpVtbl -> GetAccountCount(This,AcctType,pcServers)

#define IImnAccountManager2_FindAccount(This,dwPropTag,pszSearchData,ppAccount)	\
    (This)->lpVtbl -> FindAccount(This,dwPropTag,pszSearchData,ppAccount)

#define IImnAccountManager2_GetDefaultAccount(This,AcctType,ppAccount)	\
    (This)->lpVtbl -> GetDefaultAccount(This,AcctType,ppAccount)

#define IImnAccountManager2_GetDefaultAccountName(This,AcctType,pszAccount,cchMax)	\
    (This)->lpVtbl -> GetDefaultAccountName(This,AcctType,pszAccount,cchMax)

#define IImnAccountManager2_ProcessNotification(This,uMsg,wParam,lParam)	\
    (This)->lpVtbl -> ProcessNotification(This,uMsg,wParam,lParam)

#define IImnAccountManager2_ValidateDefaultSendAccount(This)	\
    (This)->lpVtbl -> ValidateDefaultSendAccount(This)

#define IImnAccountManager2_AccountListDialog(This,hwnd,pinfo)	\
    (This)->lpVtbl -> AccountListDialog(This,hwnd,pinfo)

#define IImnAccountManager2_Advise(This,pAdviseAccount,pdwConnection)	\
    (This)->lpVtbl -> Advise(This,pAdviseAccount,pdwConnection)

#define IImnAccountManager2_Unadvise(This,dwConnection)	\
    (This)->lpVtbl -> Unadvise(This,dwConnection)

#define IImnAccountManager2_GetUniqueAccountName(This,szName,cch)	\
    (This)->lpVtbl -> GetUniqueAccountName(This,szName,cch)

#define IImnAccountManager2_InitEx(This,pAdviseMigrateServer,dwFlags)	\
    (This)->lpVtbl -> InitEx(This,pAdviseMigrateServer,dwFlags)


#define IImnAccountManager2_InitUser(This,pAdviseMigrateServer,rguidID,dwFlags)	\
    (This)->lpVtbl -> InitUser(This,pAdviseMigrateServer,rguidID,dwFlags)

#define IImnAccountManager2_GetIncompleteAccount(This,AcctType,pszAccountId,cchMax)	\
    (This)->lpVtbl -> GetIncompleteAccount(This,AcctType,pszAccountId,cchMax)

#define IImnAccountManager2_SetIncompleteAccount(This,AcctType,pszAccountId)	\
    (This)->lpVtbl -> SetIncompleteAccount(This,AcctType,pszAccountId)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IImnAccountManager2_InitUser_Proxy( 
    IImnAccountManager2 __RPC_FAR * This,
    /* [in] */ IImnAdviseMigrateServer __RPC_FAR *pAdviseMigrateServer,
    /* [in] */ REFGUID rguidID,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IImnAccountManager2_InitUser_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImnAccountManager2_GetIncompleteAccount_Proxy( 
    IImnAccountManager2 __RPC_FAR * This,
    /* [in] */ ACCTTYPE AcctType,
    /* [ref][in] */ LPSTR pszAccountId,
    /* [in] */ ULONG cchMax);


void __RPC_STUB IImnAccountManager2_GetIncompleteAccount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImnAccountManager2_SetIncompleteAccount_Proxy( 
    IImnAccountManager2 __RPC_FAR * This,
    /* [in] */ ACCTTYPE AcctType,
    /* [unique][in] */ LPCSTR pszAccountId);


void __RPC_STUB IImnAccountManager2_SetIncompleteAccount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IImnAccountManager2_INTERFACE_DEFINED__ */


#ifndef __IPropertyContainer_INTERFACE_DEFINED__
#define __IPropertyContainer_INTERFACE_DEFINED__

/* interface IPropertyContainer */
/* [unique][uuid][object] */ 

typedef /* [public] */ 
enum __MIDL_IPropertyContainer_0001
    {	TYPE_ERROR	= 1000,
	TYPE_DWORD	= TYPE_ERROR + 1,
	TYPE_LONG	= TYPE_DWORD + 1,
	TYPE_WORD	= TYPE_LONG + 1,
	TYPE_SHORT	= TYPE_WORD + 1,
	TYPE_BYTE	= TYPE_SHORT + 1,
	TYPE_CHAR	= TYPE_BYTE + 1,
	TYPE_FILETIME	= TYPE_CHAR + 1,
	TYPE_STRING	= TYPE_FILETIME + 1,
	TYPE_BINARY	= TYPE_STRING + 1,
	TYPE_FLAGS	= TYPE_BINARY + 1,
	TYPE_STREAM	= TYPE_FLAGS + 1,
	TYPE_WSTRING	= TYPE_STREAM + 1,
	TYPE_BOOL	= TYPE_WSTRING + 1,
	TYPE_PASS	= TYPE_BOOL + 1,
	TYPE_ULARGEINTEGER	= TYPE_PASS + 1,
	TYPE_LAST	= TYPE_ULARGEINTEGER + 1
    }	PROPTYPE;






EXTERN_C const IID IID_IPropertyContainer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FD465484-1384-11d0-ABBD-0020AFDFD10A")
    IPropertyContainer : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetProp( 
            /* [in] */ DWORD dwPropTag,
            /* [unique][ref][size_is][in] */ BYTE __RPC_FAR *pb,
            /* [in] */ ULONG __RPC_FAR *pcb) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPropDw( 
            /* [in] */ DWORD dwPropTag,
            /* [out] */ DWORD __RPC_FAR *pdw) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPropSz( 
            /* [in] */ DWORD dwPropTag,
            /* [size_is][out] */ LPSTR psz,
            /* [in] */ ULONG cchMax) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProp( 
            /* [in] */ DWORD dwPropTag,
            /* [unique][size_is][in] */ BYTE __RPC_FAR *pb,
            /* [in] */ ULONG cb) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPropDw( 
            /* [in] */ DWORD dwPropTag,
            /* [in] */ DWORD dw) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPropSz( 
            /* [in] */ DWORD dwPropTag,
            /* [unique][in] */ LPSTR psz) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPropertyContainerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IPropertyContainer __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IPropertyContainer __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IPropertyContainer __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProp )( 
            IPropertyContainer __RPC_FAR * This,
            /* [in] */ DWORD dwPropTag,
            /* [unique][ref][size_is][in] */ BYTE __RPC_FAR *pb,
            /* [in] */ ULONG __RPC_FAR *pcb);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPropDw )( 
            IPropertyContainer __RPC_FAR * This,
            /* [in] */ DWORD dwPropTag,
            /* [out] */ DWORD __RPC_FAR *pdw);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPropSz )( 
            IPropertyContainer __RPC_FAR * This,
            /* [in] */ DWORD dwPropTag,
            /* [size_is][out] */ LPSTR psz,
            /* [in] */ ULONG cchMax);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetProp )( 
            IPropertyContainer __RPC_FAR * This,
            /* [in] */ DWORD dwPropTag,
            /* [unique][size_is][in] */ BYTE __RPC_FAR *pb,
            /* [in] */ ULONG cb);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPropDw )( 
            IPropertyContainer __RPC_FAR * This,
            /* [in] */ DWORD dwPropTag,
            /* [in] */ DWORD dw);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPropSz )( 
            IPropertyContainer __RPC_FAR * This,
            /* [in] */ DWORD dwPropTag,
            /* [unique][in] */ LPSTR psz);
        
        END_INTERFACE
    } IPropertyContainerVtbl;

    interface IPropertyContainer
    {
        CONST_VTBL struct IPropertyContainerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPropertyContainer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPropertyContainer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPropertyContainer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPropertyContainer_GetProp(This,dwPropTag,pb,pcb)	\
    (This)->lpVtbl -> GetProp(This,dwPropTag,pb,pcb)

#define IPropertyContainer_GetPropDw(This,dwPropTag,pdw)	\
    (This)->lpVtbl -> GetPropDw(This,dwPropTag,pdw)

#define IPropertyContainer_GetPropSz(This,dwPropTag,psz,cchMax)	\
    (This)->lpVtbl -> GetPropSz(This,dwPropTag,psz,cchMax)

#define IPropertyContainer_SetProp(This,dwPropTag,pb,cb)	\
    (This)->lpVtbl -> SetProp(This,dwPropTag,pb,cb)

#define IPropertyContainer_SetPropDw(This,dwPropTag,dw)	\
    (This)->lpVtbl -> SetPropDw(This,dwPropTag,dw)

#define IPropertyContainer_SetPropSz(This,dwPropTag,psz)	\
    (This)->lpVtbl -> SetPropSz(This,dwPropTag,psz)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IPropertyContainer_GetProp_Proxy( 
    IPropertyContainer __RPC_FAR * This,
    /* [in] */ DWORD dwPropTag,
    /* [unique][ref][size_is][in] */ BYTE __RPC_FAR *pb,
    /* [in] */ ULONG __RPC_FAR *pcb);


void __RPC_STUB IPropertyContainer_GetProp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPropertyContainer_GetPropDw_Proxy( 
    IPropertyContainer __RPC_FAR * This,
    /* [in] */ DWORD dwPropTag,
    /* [out] */ DWORD __RPC_FAR *pdw);


void __RPC_STUB IPropertyContainer_GetPropDw_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPropertyContainer_GetPropSz_Proxy( 
    IPropertyContainer __RPC_FAR * This,
    /* [in] */ DWORD dwPropTag,
    /* [size_is][out] */ LPSTR psz,
    /* [in] */ ULONG cchMax);


void __RPC_STUB IPropertyContainer_GetPropSz_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPropertyContainer_SetProp_Proxy( 
    IPropertyContainer __RPC_FAR * This,
    /* [in] */ DWORD dwPropTag,
    /* [unique][size_is][in] */ BYTE __RPC_FAR *pb,
    /* [in] */ ULONG cb);


void __RPC_STUB IPropertyContainer_SetProp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPropertyContainer_SetPropDw_Proxy( 
    IPropertyContainer __RPC_FAR * This,
    /* [in] */ DWORD dwPropTag,
    /* [in] */ DWORD dw);


void __RPC_STUB IPropertyContainer_SetPropDw_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPropertyContainer_SetPropSz_Proxy( 
    IPropertyContainer __RPC_FAR * This,
    /* [in] */ DWORD dwPropTag,
    /* [unique][in] */ LPSTR psz);


void __RPC_STUB IPropertyContainer_SetPropSz_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPropertyContainer_INTERFACE_DEFINED__ */


#ifndef __IImnAccount_INTERFACE_DEFINED__
#define __IImnAccount_INTERFACE_DEFINED__

/* interface IImnAccount */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IImnAccount;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FD465482-1384-11d0-ABBD-0020AFDFD10A")
    IImnAccount : public IPropertyContainer
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Exist( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAsDefault( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Delete( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SaveChanges( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAccountType( 
            /* [out] */ ACCTTYPE __RPC_FAR *pAcctType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetServerTypes( 
            /* [out] */ DWORD __RPC_FAR *pdwSrvTypes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ShowProperties( 
            /* [in] */ HWND hwnd,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ValidateProperty( 
            /* [in] */ DWORD dwPropTag,
            /* [size_is][in] */ BYTE __RPC_FAR *pb,
            /* [in] */ ULONG cb) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DoWizard( 
            /* [in] */ HWND hwnd,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DoImportWizard( 
            /* [in] */ HWND hwnd,
            /* [in] */ CLSID clsid,
            /* [in] */ DWORD dwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IImnAccountVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IImnAccount __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IImnAccount __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IImnAccount __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProp )( 
            IImnAccount __RPC_FAR * This,
            /* [in] */ DWORD dwPropTag,
            /* [unique][ref][size_is][in] */ BYTE __RPC_FAR *pb,
            /* [in] */ ULONG __RPC_FAR *pcb);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPropDw )( 
            IImnAccount __RPC_FAR * This,
            /* [in] */ DWORD dwPropTag,
            /* [out] */ DWORD __RPC_FAR *pdw);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPropSz )( 
            IImnAccount __RPC_FAR * This,
            /* [in] */ DWORD dwPropTag,
            /* [size_is][out] */ LPSTR psz,
            /* [in] */ ULONG cchMax);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetProp )( 
            IImnAccount __RPC_FAR * This,
            /* [in] */ DWORD dwPropTag,
            /* [unique][size_is][in] */ BYTE __RPC_FAR *pb,
            /* [in] */ ULONG cb);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPropDw )( 
            IImnAccount __RPC_FAR * This,
            /* [in] */ DWORD dwPropTag,
            /* [in] */ DWORD dw);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPropSz )( 
            IImnAccount __RPC_FAR * This,
            /* [in] */ DWORD dwPropTag,
            /* [unique][in] */ LPSTR psz);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Exist )( 
            IImnAccount __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAsDefault )( 
            IImnAccount __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Delete )( 
            IImnAccount __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SaveChanges )( 
            IImnAccount __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAccountType )( 
            IImnAccount __RPC_FAR * This,
            /* [out] */ ACCTTYPE __RPC_FAR *pAcctType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetServerTypes )( 
            IImnAccount __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwSrvTypes);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ShowProperties )( 
            IImnAccount __RPC_FAR * This,
            /* [in] */ HWND hwnd,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ValidateProperty )( 
            IImnAccount __RPC_FAR * This,
            /* [in] */ DWORD dwPropTag,
            /* [size_is][in] */ BYTE __RPC_FAR *pb,
            /* [in] */ ULONG cb);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DoWizard )( 
            IImnAccount __RPC_FAR * This,
            /* [in] */ HWND hwnd,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DoImportWizard )( 
            IImnAccount __RPC_FAR * This,
            /* [in] */ HWND hwnd,
            /* [in] */ CLSID clsid,
            /* [in] */ DWORD dwFlags);
        
        END_INTERFACE
    } IImnAccountVtbl;

    interface IImnAccount
    {
        CONST_VTBL struct IImnAccountVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IImnAccount_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IImnAccount_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IImnAccount_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IImnAccount_GetProp(This,dwPropTag,pb,pcb)	\
    (This)->lpVtbl -> GetProp(This,dwPropTag,pb,pcb)

#define IImnAccount_GetPropDw(This,dwPropTag,pdw)	\
    (This)->lpVtbl -> GetPropDw(This,dwPropTag,pdw)

#define IImnAccount_GetPropSz(This,dwPropTag,psz,cchMax)	\
    (This)->lpVtbl -> GetPropSz(This,dwPropTag,psz,cchMax)

#define IImnAccount_SetProp(This,dwPropTag,pb,cb)	\
    (This)->lpVtbl -> SetProp(This,dwPropTag,pb,cb)

#define IImnAccount_SetPropDw(This,dwPropTag,dw)	\
    (This)->lpVtbl -> SetPropDw(This,dwPropTag,dw)

#define IImnAccount_SetPropSz(This,dwPropTag,psz)	\
    (This)->lpVtbl -> SetPropSz(This,dwPropTag,psz)


#define IImnAccount_Exist(This)	\
    (This)->lpVtbl -> Exist(This)

#define IImnAccount_SetAsDefault(This)	\
    (This)->lpVtbl -> SetAsDefault(This)

#define IImnAccount_Delete(This)	\
    (This)->lpVtbl -> Delete(This)

#define IImnAccount_SaveChanges(This)	\
    (This)->lpVtbl -> SaveChanges(This)

#define IImnAccount_GetAccountType(This,pAcctType)	\
    (This)->lpVtbl -> GetAccountType(This,pAcctType)

#define IImnAccount_GetServerTypes(This,pdwSrvTypes)	\
    (This)->lpVtbl -> GetServerTypes(This,pdwSrvTypes)

#define IImnAccount_ShowProperties(This,hwnd,dwFlags)	\
    (This)->lpVtbl -> ShowProperties(This,hwnd,dwFlags)

#define IImnAccount_ValidateProperty(This,dwPropTag,pb,cb)	\
    (This)->lpVtbl -> ValidateProperty(This,dwPropTag,pb,cb)

#define IImnAccount_DoWizard(This,hwnd,dwFlags)	\
    (This)->lpVtbl -> DoWizard(This,hwnd,dwFlags)

#define IImnAccount_DoImportWizard(This,hwnd,clsid,dwFlags)	\
    (This)->lpVtbl -> DoImportWizard(This,hwnd,clsid,dwFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IImnAccount_Exist_Proxy( 
    IImnAccount __RPC_FAR * This);


void __RPC_STUB IImnAccount_Exist_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImnAccount_SetAsDefault_Proxy( 
    IImnAccount __RPC_FAR * This);


void __RPC_STUB IImnAccount_SetAsDefault_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImnAccount_Delete_Proxy( 
    IImnAccount __RPC_FAR * This);


void __RPC_STUB IImnAccount_Delete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImnAccount_SaveChanges_Proxy( 
    IImnAccount __RPC_FAR * This);


void __RPC_STUB IImnAccount_SaveChanges_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImnAccount_GetAccountType_Proxy( 
    IImnAccount __RPC_FAR * This,
    /* [out] */ ACCTTYPE __RPC_FAR *pAcctType);


void __RPC_STUB IImnAccount_GetAccountType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImnAccount_GetServerTypes_Proxy( 
    IImnAccount __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwSrvTypes);


void __RPC_STUB IImnAccount_GetServerTypes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImnAccount_ShowProperties_Proxy( 
    IImnAccount __RPC_FAR * This,
    /* [in] */ HWND hwnd,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IImnAccount_ShowProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImnAccount_ValidateProperty_Proxy( 
    IImnAccount __RPC_FAR * This,
    /* [in] */ DWORD dwPropTag,
    /* [size_is][in] */ BYTE __RPC_FAR *pb,
    /* [in] */ ULONG cb);


void __RPC_STUB IImnAccount_ValidateProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImnAccount_DoWizard_Proxy( 
    IImnAccount __RPC_FAR * This,
    /* [in] */ HWND hwnd,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IImnAccount_DoWizard_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImnAccount_DoImportWizard_Proxy( 
    IImnAccount __RPC_FAR * This,
    /* [in] */ HWND hwnd,
    /* [in] */ CLSID clsid,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IImnAccount_DoImportWizard_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IImnAccount_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_imnact_0070 */
/* [local] */ 

#if defined( WIN16 ) && !defined( __cplusplus )
// {8D4B04E1-1331-11d0-81B8-00C04FD85AB4}
EXTERN_C const IID CLSID_ImnAccountManager =
    { 0x8d4b04e1, 0x1331, 0x11d0, { 0x81, 0xb8, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4 } };

// {FD465484-1384-11d0-ABBD-0020AFDFD10A}
EXTERN_C const IID IID_IPropertyContainer =
    { 0xfd465484, 0x1384, 0x11d0, { 0xab, 0xbd, 0x0, 0x20, 0xaf, 0xdf, 0xd1, 0xa } };

// {FD465481-1384-11d0-ABBD-0020AFDFD10A}
EXTERN_C const IID IID_IImnAccountManager =
    { 0xfd465481, 0x1384, 0x11d0, { 0xab, 0xbd, 0x0, 0x20, 0xaf, 0xdf, 0xd1, 0xa } };

// {C43DFC6F-62BB-11d2-A727-00C04F79E7C8}
EXTERN_C const IID IID_IImnAccountManager2 =
    { 0xc43dfc6f, 0x62bb, 0x11d2, { 0xa7, 0x27, 0x0, 0xc0, 0x4f, 0x79, 0xe7, 0xc8 } };

// {FD465482-1384-11d0-ABBD-0020AFDFD10A}
EXTERN_C const IID IID_IImnAccount =
    { 0xfd465482, 0x1384, 0x11d0, { 0xab, 0xbd, 0x0, 0x20, 0xaf, 0xdf, 0xd1, 0xa } };

// {FD465483-1384-11d0-ABBD-0020AFDFD10A}
EXTERN_C const IID IID_IImnEnumAccounts =
    { 0xfd465483, 0x1384, 0x11d0, { 0xab, 0xbd, 0x0, 0x20, 0xaf, 0xdf, 0xd1, 0xa } };

// {8D0AED11-1638-11d0-81B9-00C04FD85AB4}
EXTERN_C const IID IID_IImnAdviseMigrateServer =
    { 0x8d0aed11, 0x1638, 0x11d0, { 0x81, 0xb9, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4 } };

// {0A06BD31-166F-11d0-81B9-00C04FD85AB4}
EXTERN_C const IID IID_IImnAdviseAccount =
    { 0xa06bd31, 0x166f, 0x11d0, { 0x81, 0xb9, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4 } };

#endif //WIN16 && !__cplusplus


extern RPC_IF_HANDLE __MIDL_itf_imnact_0070_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_imnact_0070_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  HWND_UserSize(     unsigned long __RPC_FAR *, unsigned long            , HWND __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  HWND_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, HWND __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  HWND_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, HWND __RPC_FAR * ); 
void                      __RPC_USER  HWND_UserFree(     unsigned long __RPC_FAR *, HWND __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\imm.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/**********************************************************************/
/*      IMM.H - Input Method Manager definitions                      */
/*                                                                    */
/**********************************************************************/

#ifndef _IMM_
#define _IMM_        // defined if IMM.H has been included

#ifdef __cplusplus
extern "C" {
#endif


typedef DWORD     HIMC;
typedef DWORD     HIMCC;

#define NULLIMC	((HIMC)0)

typedef HKL FAR  *LPHKL;
typedef UINT FAR *LPUINT;


typedef struct tagCOMPOSITIONFORM {
    DWORD dwStyle;
    POINT ptCurrentPos;
    RECT  rcArea;
} COMPOSITIONFORM, *PCOMPOSITIONFORM, NEAR *NPCOMPOSITIONFORM, FAR *LPCOMPOSITIONFORM;


typedef struct tagCANDIDATEFORM {
    DWORD dwIndex;
    DWORD dwStyle;
    POINT ptCurrentPos;
    RECT  rcArea;
} CANDIDATEFORM, *PCANDIDATEFORM, NEAR *NPCANDIDATEFORM, FAR *LPCANDIDATEFORM;


typedef struct tagCANDIDATELIST {
    DWORD dwSize;
    DWORD dwStyle;
    DWORD dwCount;
    DWORD dwSelection;
    DWORD dwPageStart;
    DWORD dwPageSize;
    DWORD dwOffset[1];
} CANDIDATELIST, *PCANDIDATELIST, NEAR *NPCANDIDATELIST, FAR *LPCANDIDATELIST;

typedef struct tagREGISTERWORDA {
    LPSTR  lpReading;
    LPSTR  lpWord;
} REGISTERWORDA, *PREGISTERWORDA, NEAR *NPREGISTERWORDA, FAR *LPREGISTERWORDA;
typedef struct tagREGISTERWORDW {
    LPWSTR  lpReading;
    LPWSTR  lpWord;
} REGISTERWORDW, *PREGISTERWORDW, NEAR *NPREGISTERWORDW, FAR *LPREGISTERWORDW;

#ifdef UNICODE
typedef REGISTERWORDW REGISTERWORD;
typedef PREGISTERWORDW PREGISTERWORD;
typedef NPREGISTERWORDW NPREGISTERWORD;
typedef LPREGISTERWORDW LPREGISTERWORD;
#else
typedef REGISTERWORDA REGISTERWORD;
typedef PREGISTERWORDA PREGISTERWORD;
typedef NPREGISTERWORDA NPREGISTERWORD;
typedef LPREGISTERWORDA LPREGISTERWORD;
#endif // UNICODE



#define STYLE_DESCRIPTION_SIZE  32

typedef struct tagSTYLEBUFA {
    DWORD       dwStyle;
    CHAR        szDescription[STYLE_DESCRIPTION_SIZE];
} STYLEBUFA, *PSTYLEBUFA, NEAR *NPSTYLEBUFA, FAR *LPSTYLEBUFA;
typedef struct tagSTYLEBUFW {
    DWORD       dwStyle;
    WCHAR       szDescription[STYLE_DESCRIPTION_SIZE];
} STYLEBUFW, *PSTYLEBUFW, NEAR *NPSTYLEBUFW, FAR *LPSTYLEBUFW;

#ifdef UNICODE
typedef STYLEBUFW STYLEBUF;
typedef PSTYLEBUFW PSTYLEBUF;
typedef NPSTYLEBUFW NPSTYLEBUF;
typedef LPSTYLEBUFW LPSTYLEBUF;
#else
typedef STYLEBUFA STYLEBUF;
typedef PSTYLEBUFA PSTYLEBUF;
typedef NPSTYLEBUFA NPSTYLEBUF;
typedef LPSTYLEBUFA LPSTYLEBUF;
#endif // UNICODE



#define IMEMENUITEM_STRING_SIZE 80

typedef struct tagIMEMENUITEMINFOA {
    UINT        cbSize;
    UINT        fType;
    UINT        fState;
    UINT        wID;
    HBITMAP     hbmpChecked;
    HBITMAP     hbmpUnchecked;
    DWORD       dwItemData;
    CHAR        szString[IMEMENUITEM_STRING_SIZE];
    HBITMAP     hbmpItem;
} IMEMENUITEMINFOA, *PIMEMENUITEMINFOA, NEAR *NPIMEMENUITEMINFOA, FAR *LPIMEMENUITEMINFOA;
typedef struct tagIMEMENUITEMINFOW {
    UINT        cbSize;
    UINT        fType;
    UINT        fState;
    UINT        wID;
    HBITMAP     hbmpChecked;
    HBITMAP     hbmpUnchecked;
    DWORD       dwItemData;
    WCHAR       szString[IMEMENUITEM_STRING_SIZE];
    HBITMAP     hbmpItem;
} IMEMENUITEMINFOW, *PIMEMENUITEMINFOW, NEAR *NPIMEMENUITEMINFOW, FAR *LPIMEMENUITEMINFOW;
#ifdef UNICODE
typedef IMEMENUITEMINFOW IMEMENUITEMINFO;
typedef PIMEMENUITEMINFOW PIMEMENUITEMINFO;
typedef NPIMEMENUITEMINFOW NPIMEMENUITEMINFO;
typedef LPIMEMENUITEMINFOW LPIMEMENUITEMINFO;
#else
typedef IMEMENUITEMINFOA IMEMENUITEMINFO;
typedef PIMEMENUITEMINFOA PIMEMENUITEMINFO;
typedef NPIMEMENUITEMINFOA NPIMEMENUITEMINFO;
typedef LPIMEMENUITEMINFOA LPIMEMENUITEMINFO;
#endif // UNICODE

typedef struct tagIMECHARPOSITION {
    DWORD       dwSize;
    DWORD       dwCharPos;
    POINT       pt;
    UINT        cLineHeight;
    RECT        rcDocument;
} IMECHARPOSITION, *PIMECHARPOSITION, NEAR *NPIMECHARPOSITION, FAR *LPIMECHARPOSITION;




// prototype of IMM API

HKL  WINAPI ImmInstallIMEW(LPCWSTR lpszIMEFileName, LPCWSTR lpszLayoutText);
#ifdef UNICODE
#define ImmInstallIME  ImmInstallIMEW
#else
#define ImmInstallIME  ImmInstallIMEA
#endif // !UNICODE

HWND WINAPI ImmGetDefaultIMEWnd(HWND);

UINT WINAPI ImmGetDescriptionW(HKL, LPWSTR, UINT uBufLen);
#ifdef UNICODE
#define ImmGetDescription  ImmGetDescriptionW
#else
#define ImmGetDescription  ImmGetDescriptionA
#endif // !UNICODE

UINT WINAPI ImmGetIMEFileNameW(HKL, LPWSTR, UINT uBufLen);
#ifdef UNICODE
#define ImmGetIMEFileName  ImmGetIMEFileNameW
#else
#define ImmGetIMEFileName  ImmGetIMEFileNameA
#endif // !UNICODE

DWORD WINAPI ImmGetProperty(HKL, DWORD);


BOOL WINAPI ImmIsIME(HKL);

BOOL WINAPI ImmSimulateHotKey(HWND, DWORD);

HIMC WINAPI ImmCreateContext(void);
BOOL WINAPI ImmDestroyContext(HIMC);
HIMC WINAPI ImmGetContext(HWND);
BOOL WINAPI ImmReleaseContext(HWND, HIMC);
HIMC WINAPI ImmAssociateContext(HWND, HIMC);
BOOL WINAPI ImmAssociateContextEx(HWND, HIMC, DWORD);

LONG  WINAPI ImmGetCompositionStringW(HIMC, DWORD, LPVOID, DWORD);
#ifdef UNICODE
#define ImmGetCompositionString  ImmGetCompositionStringW
#else
#define ImmGetCompositionString  ImmGetCompositionStringA
#endif // !UNICODE

BOOL  WINAPI ImmSetCompositionStringW(HIMC, DWORD dwIndex, LPCVOID lpComp, DWORD, LPCVOID lpRead, DWORD);
#ifdef UNICODE
#define ImmSetCompositionString  ImmSetCompositionStringW
#else
#define ImmSetCompositionString  ImmSetCompositionStringA
#endif // !UNICODE

DWORD WINAPI ImmGetCandidateListCountW(HIMC, LPDWORD lpdwListCount);
#ifdef UNICODE
#define ImmGetCandidateListCount  ImmGetCandidateListCountW
#else
#define ImmGetCandidateListCount  ImmGetCandidateListCountA
#endif // !UNICODE

DWORD WINAPI ImmGetCandidateListW(HIMC, DWORD deIndex, LPCANDIDATELIST, DWORD dwBufLen);
#ifdef UNICODE
#define ImmGetCandidateList  ImmGetCandidateListW
#else
#define ImmGetCandidateList  ImmGetCandidateListA
#endif // !UNICODE

DWORD WINAPI ImmGetGuideLineW(HIMC, DWORD dwIndex, LPWSTR, DWORD dwBufLen);
#ifdef UNICODE
#define ImmGetGuideLine  ImmGetGuideLineW
#else
#define ImmGetGuideLine  ImmGetGuideLineA
#endif // !UNICODE

BOOL WINAPI ImmGetConversionStatus(HIMC, LPDWORD, LPDWORD);
BOOL WINAPI ImmSetConversionStatus(HIMC, DWORD, DWORD);
BOOL WINAPI ImmGetOpenStatus(HIMC);
BOOL WINAPI ImmSetOpenStatus(HIMC, BOOL);

BOOL WINAPI ImmGetCompositionFontW(HIMC, LPLOGFONTW);
#ifdef UNICODE
#define ImmGetCompositionFont  ImmGetCompositionFontW
#else
#define ImmGetCompositionFont  ImmGetCompositionFontA
#endif // !UNICODE

BOOL WINAPI ImmSetCompositionFontW(HIMC, LPLOGFONTW);
#ifdef UNICODE
#define ImmSetCompositionFont  ImmSetCompositionFontW
#else
#define ImmSetCompositionFont  ImmSetCompositionFontA
#endif // !UNICODE

BOOL    WINAPI ImmConfigureIMEW(HKL, HWND, DWORD, LPVOID);
#ifdef UNICODE
#define ImmConfigureIME  ImmConfigureIMEW
#else
#define ImmConfigureIME  ImmConfigureIMEA
#endif // !UNICODE

LRESULT WINAPI ImmEscapeW(HKL, HIMC, UINT, LPVOID);
#ifdef UNICODE
#define ImmEscape  ImmEscapeW
#else
#define ImmEscape  ImmEscapeA
#endif // !UNICODE

DWORD   WINAPI ImmGetConversionListW(HKL, HIMC, LPCWSTR, LPCANDIDATELIST, DWORD dwBufLen, UINT uFlag);
#ifdef UNICODE
#define ImmGetConversionList  ImmGetConversionListW
#else
#define ImmGetConversionList  ImmGetConversionListA
#endif // !UNICODE

BOOL    WINAPI ImmNotifyIME(HIMC, DWORD dwAction, DWORD dwIndex, DWORD dwValue);

BOOL	WINAPI ImmActivateLayout(HKL hSelKL);

BOOL WINAPI ImmSendNotification(void);
BOOL WINAPI ImmGetStatusWindowPos(HIMC, LPPOINT);
BOOL WINAPI ImmSetStatusWindowPos(HIMC, LPPOINT);
BOOL WINAPI ImmGetCompositionWindow(HIMC, LPCOMPOSITIONFORM);
BOOL WINAPI ImmSetCompositionWindow(HIMC, LPCOMPOSITIONFORM);
BOOL WINAPI ImmGetCandidateWindow(HIMC, DWORD, LPCANDIDATEFORM);
BOOL WINAPI ImmSetCandidateWindow(HIMC, LPCANDIDATEFORM);

BOOL WINAPI ImmIsUIMessageW(HWND, UINT, WPARAM, LPARAM);
#ifdef UNICODE
#define ImmIsUIMessage  ImmIsUIMessageW
#else
#define ImmIsUIMessage  ImmIsUIMessageA
#endif // !UNICODE

UINT WINAPI ImmGetVirtualKey(HWND);

typedef int (CALLBACK *REGISTERWORDENUMPROCA)(LPCSTR, DWORD, LPCSTR, LPVOID);
typedef int (CALLBACK *REGISTERWORDENUMPROCW)(LPCWSTR, DWORD, LPCWSTR, LPVOID);
#ifdef UNICODE
#define REGISTERWORDENUMPROC  REGISTERWORDENUMPROCW
#else
#define REGISTERWORDENUMPROC  REGISTERWORDENUMPROCA
#endif // !UNICODE

BOOL WINAPI ImmRegisterWordW(HKL, LPCWSTR lpszReading, DWORD, LPCWSTR lpszRegister);
#ifdef UNICODE
#define ImmRegisterWord  ImmRegisterWordW
#else
#define ImmRegisterWord  ImmRegisterWordA
#endif // !UNICODE

BOOL WINAPI ImmUnregisterWordW(HKL, LPCWSTR lpszReading, DWORD, LPCWSTR lpszUnregister);
#ifdef UNICODE
#define ImmUnregisterWord  ImmUnregisterWordW
#else
#define ImmUnregisterWord  ImmUnregisterWordA
#endif // !UNICODE

UINT WINAPI ImmGetRegisterWordStyleW(HKL, UINT nItem, LPSTYLEBUFW);
#ifdef UNICODE
#define ImmGetRegisterWordStyle  ImmGetRegisterWordStyleW
#else
#define ImmGetRegisterWordStyle  ImmGetRegisterWordStyleA
#endif // !UNICODE

UINT WINAPI ImmEnumRegisterWordW(HKL, REGISTERWORDENUMPROCW, LPCWSTR lpszReading, DWORD, LPCWSTR lpszRegister, LPVOID);
#ifdef UNICODE
#define ImmEnumRegisterWord  ImmEnumRegisterWordW
#else
#define ImmEnumRegisterWord  ImmEnumRegisterWordA
#endif // !UNICODE

BOOL WINAPI ImmDisableIME(DWORD);
DWORD WINAPI ImmGetImeMenuItemsA(HIMC, DWORD, DWORD, LPIMEMENUITEMINFOA, LPIMEMENUITEMINFOA, DWORD);
DWORD WINAPI ImmGetImeMenuItemsW(HIMC, DWORD, DWORD, LPIMEMENUITEMINFOW, LPIMEMENUITEMINFOW, DWORD);
#ifdef UNICODE
#define ImmGetImeMenuItems  ImmGetImeMenuItemsW
#else
#define ImmGetImeMenuItems  ImmGetImeMenuItemsA
#endif // !UNICODE



// wParam for WM_IME_CONTROL
#define IMC_GETCANDIDATEPOS             0x0007
#define IMC_SETCANDIDATEPOS             0x0008
#define IMC_GETCOMPOSITIONFONT          0x0009
#define IMC_SETCOMPOSITIONFONT          0x000A
#define IMC_GETCOMPOSITIONWINDOW        0x000B
#define IMC_SETCOMPOSITIONWINDOW        0x000C
#define IMC_GETSTATUSWINDOWPOS          0x000F
#define IMC_SETSTATUSWINDOWPOS          0x0010
#define IMC_CLOSESTATUSWINDOW           0x0021
#define IMC_OPENSTATUSWINDOW            0x0022







// dwAction for ImmNotifyIME
#define NI_OPENCANDIDATE                0x0010
#define NI_CLOSECANDIDATE               0x0011
#define NI_SELECTCANDIDATESTR           0x0012
#define NI_CHANGECANDIDATELIST          0x0013
#define NI_FINALIZECONVERSIONRESULT     0x0014
#define NI_COMPOSITIONSTR               0x0015
#define NI_SETCANDIDATE_PAGESTART       0x0016
#define NI_SETCANDIDATE_PAGESIZE        0x0017


// lParam for WM_IME_SETCONTEXT
#define ISC_SHOWUICANDIDATEWINDOW       0x00000001
#define ISC_SHOWUICOMPOSITIONWINDOW     0x80000000
#define ISC_SHOWUIGUIDELINE             0x40000000
#define ISC_SHOWUIALLCANDIDATEWINDOW    0x0000000F
#define ISC_SHOWUIALL                   0xC000000F


// dwIndex for ImmNotifyIME/NI_COMPOSITIONSTR
#define CPS_COMPLETE                    0x0001
#define CPS_CONVERT                     0x0002
#define CPS_REVERT                      0x0003
#define CPS_CANCEL                      0x0004


// the modifiers of hot key
#define MOD_ALT                         0x0001
#define MOD_CONTROL                     0x0002
#define MOD_SHIFT                       0x0004


#define MOD_LEFT                        0x8000
#define MOD_RIGHT                       0x4000

#define MOD_ON_KEYUP                    0x0800
#define MOD_IGNORE_ALL_MODIFIER         0x0400


// Windows for Simplified Chinese Edition hot key ID from 0x10 - 0x2F
#define IME_CHOTKEY_FIRST						0x10
#define IME_CHOTKEY_IME_NONIME_TOGGLE           0x10
#define IME_CHOTKEY_SHAPE_TOGGLE                0x11
#define IME_CHOTKEY_SYMBOL_TOGGLE               0x12
#define IME_CHOTKEY_LAST						0x2f

// Windows for Japanese Edition hot key ID from 0x30 - 0x4F
#define IME_JHOTKEY_FIRST						0x30
#define IME_JHOTKEY_CLOSE_OPEN                  0x30
#define IME_JHOTKEY_LAST						0x4f

// Windows for Korean Edition hot key ID from 0x50 - 0x6F
#define IME_KHOTKEY_FIRST						0x50
#define IME_KHOTKEY_SHAPE_TOGGLE                0x50
#define IME_KHOTKEY_HANJACONVERT                0x51
#define IME_KHOTKEY_ENGLISH                     0x52
#define IME_KHOTKEY_LAST						0x6f

// Windows for Traditional Chinese Edition hot key ID from 0x70 - 0x8F
#define IME_THOTKEY_FIRST						0x70
#define IME_THOTKEY_IME_NONIME_TOGGLE           0x70
#define IME_THOTKEY_SHAPE_TOGGLE                0x71
#define IME_THOTKEY_SYMBOL_TOGGLE               0x72
#define IME_THOTKEY_LAST						0x8f

// direct switch hot key ID from 0x100 - 0x11F
#define IME_HOTKEY_DSWITCH_FIRST                0x100
#define IME_HOTKEY_DSWITCH_LAST                 0x11F

// IME private hot key from 0x200 - 0x21F
#define IME_HOTKEY_PRIVATE_FIRST                0x200
#define IME_ITHOTKEY_RESEND_RESULTSTR           0x200
#define IME_ITHOTKEY_PREVIOUS_COMPOSITION       0x201
#define IME_ITHOTKEY_UISTYLE_TOGGLE             0x202
#define IME_HOTKEY_PRIVATE_LAST                 0x21F


// dwSystemInfoFlags bits

// parameter of ImmGetCompositionString
#define GCS_COMPREADSTR                 0x0001
#define GCS_COMPREADATTR                0x0002
#define GCS_COMPREADCLAUSE              0x0004
#define GCS_COMPSTR                     0x0008
#define GCS_COMPATTR                    0x0010
#define GCS_COMPCLAUSE                  0x0020
#define GCS_CURSORPOS                   0x0080
#define GCS_DELTASTART                  0x0100
#define GCS_RESULTREADSTR               0x0200
#define GCS_RESULTREADCLAUSE            0x0400
#define GCS_RESULTSTR                   0x0800
#define GCS_RESULTCLAUSE                0x1000

// style bit flags for WM_IME_COMPOSITION
#define CS_INSERTCHAR                   0x2000
#define CS_NOMOVECARET                  0x4000



// bits of fdwInit of INPUTCONTEXT
// IME version constants
#define IMEVER_0310                     0x0003000A
#define IMEVER_0400                     0x00040000


// IME property bits
#define IME_PROP_END_UNLOAD             0x00000001
#define IME_PROP_KBD_CHAR_FIRST         0x00000002
#define IME_PROP_IGNORE_UPKEYS          0x00000004
#define IME_PROP_NEED_ALTKEY            0x00000008
#define IME_PROP_NO_KEYS_ON_CLOSE       0x00000010
#define IME_PROP_AT_CARET               0x00010000
#define IME_PROP_SPECIAL_UI             0x00020000
#define IME_PROP_CANDLIST_START_FROM_1  0x00040000
#define IME_PROP_UNICODE                0x00080000
#define IME_PROP_COMPLETE_ON_UNSELECT   0x00100000
// IME property bits, anyone adding a new bit must update this
#define IME_PROP_ALL                    0x001F001F


// IME UICapability bits
#define UI_CAP_2700                     0x00000001
#define UI_CAP_ROT90                    0x00000002
#define UI_CAP_ROTANY                   0x00000004


// ImmSetCompositionString Capability bits
#define SCS_CAP_COMPSTR                 0x00000001
#define SCS_CAP_MAKEREAD                0x00000002
#define SCS_CAP_SETRECONVERTSTRING      0x00000004


// IME WM_IME_SELECT inheritance Capability bits
#define SELECT_CAP_CONVERSION           0x00000001
#define SELECT_CAP_SENTENCE             0x00000002


// ID for deIndex of ImmGetGuideLine
#define GGL_LEVEL                       0x00000001
#define GGL_INDEX                       0x00000002
#define GGL_STRING                      0x00000003
#define GGL_PRIVATE                     0x00000004


// ID for dwLevel of GUIDELINE Structure
#define GL_LEVEL_NOGUIDELINE            0x00000000
#define GL_LEVEL_FATAL                  0x00000001
#define GL_LEVEL_ERROR                  0x00000002
#define GL_LEVEL_WARNING                0x00000003
#define GL_LEVEL_INFORMATION            0x00000004


// ID for dwIndex of GUIDELINE Structure
#define GL_ID_UNKNOWN                   0x00000000
#define GL_ID_NOMODULE                  0x00000001
#define GL_ID_NODICTIONARY              0x00000010
#define GL_ID_CANNOTSAVE                0x00000011
#define GL_ID_NOCONVERT                 0x00000020
#define GL_ID_TYPINGERROR               0x00000021
#define GL_ID_TOOMANYSTROKE             0x00000022
#define GL_ID_READINGCONFLICT           0x00000023
#define GL_ID_INPUTREADING              0x00000024
#define GL_ID_INPUTRADICAL              0x00000025
#define GL_ID_INPUTCODE                 0x00000026
#define GL_ID_INPUTSYMBOL               0x00000027
#define GL_ID_CHOOSECANDIDATE           0x00000028
#define GL_ID_REVERSECONVERSION         0x00000029
#define GL_ID_PRIVATE_FIRST             0x00008000
#define GL_ID_PRIVATE_LAST              0x0000FFFF


// ID for dwIndex of ImmGetProperty
#define IGP_GETIMEVERSION               (DWORD)(-4)
#define IGP_PROPERTY                    0x00000004
#define IGP_CONVERSION                  0x00000008
#define IGP_SENTENCE                    0x0000000c
#define IGP_UI                          0x00000010
#define IGP_SETCOMPSTR                  0x00000014
#define IGP_SELECT                      0x00000018
#define IGP_PRIVATEDATASIZE				0x0000001c
// last property index, anyone adding a new property index must update this
#define IGP_LAST                        IGP_PRIVATEDATASIZE


// dwIndex for ImmSetCompositionString API
#define SCS_SETSTR                      (GCS_COMPREADSTR|GCS_COMPSTR)
#define SCS_CHANGEATTR                  (GCS_COMPREADATTR|GCS_COMPATTR)
#define SCS_CHANGECLAUSE                (GCS_COMPREADCLAUSE|GCS_COMPCLAUSE)
#define SCS_SETRECONVERTSTRING          0x00010000
#define SCS_QUERYRECONVERTSTRING        0x00020000


// attribute for COMPOSITIONSTRING Structure
#define ATTR_INPUT                      0x00
#define ATTR_TARGET_CONVERTED           0x01
#define ATTR_CONVERTED                  0x02
#define ATTR_TARGET_NOTCONVERTED        0x03
#define ATTR_INPUT_ERROR                0x04


// bit field for IMC_SETCOMPOSITIONWINDOW, IMC_SETCANDIDATEWINDOW
#define CFS_DEFAULT                     0x0000
#define CFS_RECT                        0x0001
#define CFS_POINT                       0x0002
#define CFS_FORCE_POSITION              0x0020
#define CFS_CANDIDATEPOS                0x0040
#define CFS_EXCLUDE                     0x0080


// conversion direction for ImmGetConversionList
#define GCL_CONVERSION                  0x0001
#define GCL_REVERSECONVERSION           0x0002
#define GCL_REVERSE_LENGTH              0x0003


// bit field for conversion mode
#define IME_CMODE_ALPHANUMERIC          0x0000
#define IME_CMODE_NATIVE                0x0001
#define IME_CMODE_CHINESE               IME_CMODE_NATIVE
// IME_CMODE_HANGEUL is old name of IME_CMODE_HANGUL. It will be gone eventually.
#define IME_CMODE_HANGEUL               IME_CMODE_NATIVE
#define IME_CMODE_HANGUL                IME_CMODE_NATIVE
#define IME_CMODE_JAPANESE              IME_CMODE_NATIVE
#define IME_CMODE_KATAKANA              0x0002  // only effect under IME_CMODE_NATIVE
#define IME_CMODE_LANGUAGE              0x0003
#define IME_CMODE_FULLSHAPE             0x0008
#define IME_CMODE_ROMAN                 0x0010
#define IME_CMODE_CHARCODE              0x0020
#define IME_CMODE_HANJACONVERT          0x0040
#define IME_CMODE_SOFTKBD               0x0080
#define IME_CMODE_NOCONVERSION          0x0100
#define IME_CMODE_EUDC                  0x0200
#define IME_CMODE_SYMBOL                0x0400
#define IME_CMODE_PASSWORD				0x80000000


#define IME_SMODE_NONE                  0x0000
#define IME_SMODE_PLAURALCLAUSE         0x0001
#define IME_SMODE_SINGLECONVERT         0x0002
#define IME_SMODE_AUTOMATIC             0x0004
#define IME_SMODE_PHRASEPREDICT         0x0008


// style of candidate
#define IME_CAND_UNKNOWN                0x0000
#define IME_CAND_READ                   0x0001
#define IME_CAND_CODE                   0x0002
#define IME_CAND_MEANING                0x0003
#define IME_CAND_RADICAL                0x0004
#define IME_CAND_STROKE                 0x0005


// wParam of report message WM_IME_NOTIFY
#define IMN_CLOSESTATUSWINDOW           0x0001
#define IMN_OPENSTATUSWINDOW            0x0002
#define IMN_CHANGECANDIDATE             0x0003
#define IMN_CLOSECANDIDATE              0x0004
#define IMN_OPENCANDIDATE               0x0005
#define IMN_SETCONVERSIONMODE           0x0006
#define IMN_SETSENTENCEMODE             0x0007
#define IMN_SETOPENSTATUS               0x0008
#define IMN_SETCANDIDATEPOS             0x0009
#define IMN_SETCOMPOSITIONFONT          0x000A
#define IMN_SETCOMPOSITIONWINDOW        0x000B
#define IMN_SETSTATUSWINDOWPOS          0x000C
#define IMN_GUIDELINE                   0x000D
#define IMN_PRIVATE                     0x000E


// error code of ImmGetCompositionString
#define IMM_ERROR_NODATA                (-1)
#define IMM_ERROR_GENERAL               (-2)


// dialog mode of ImmConfigureIME
#define IME_CONFIG_GENERAL              1
#define IME_CONFIG_REGISTERWORD         2
#define IME_CONFIG_SELECTDICTIONARY     3


// dialog mode of ImmEscape
#define IME_ESC_QUERY_SUPPORT           0x0003
#define IME_ESC_RESERVED_FIRST          0x0004
#define IME_ESC_RESERVED_LAST           0x07FF
#define IME_ESC_PRIVATE_FIRST           0x0800
#define IME_ESC_PRIVATE_LAST            0x0FFF
#define IME_ESC_SEQUENCE_TO_INTERNAL    0x1001
#define IME_ESC_GET_EUDC_DICTIONARY     0x1003
#define IME_ESC_SET_EUDC_DICTIONARY     0x1004
#define IME_ESC_MAX_KEY                 0x1005
#define IME_ESC_IME_NAME                0x1006
#define IME_ESC_SYNC_HOTKEY             0x1007
#define IME_ESC_HANJA_MODE              0x1008
#define IME_ESC_AUTOMATA                0x1009
#define IME_ESC_PRIVATE_HOTKEY          0x100a
//0x100b is occupied by IME_ESC_GETHELPFILENAME
#define IME_ESC_DOCKEDCAND_RECT         0x100c


// style of word registration
#define IME_REGWORD_STYLE_EUDC          0x00000001
#define IME_REGWORD_STYLE_USER_FIRST    0x80000000
#define IME_REGWORD_STYLE_USER_LAST     0xFFFFFFFF

// dwFlags for ImmAssociateContextEx
#define IACE_CHILDREN                   0x0001
#define IACE_DEFAULT                    0x0010
#define IACE_IGNORENOCONTEXT            0x0020

// dwFlags for ImmGetImeMenuItems
#define IGIMIF_RIGHTMENU                0x0001

// dwType for ImmGetImeMenuItems
#define IGIMII_CMODE                    0x0001
#define IGIMII_SMODE                    0x0002
#define IGIMII_CONFIGURE                0x0004
#define IGIMII_TOOLS                    0x0008
#define IGIMII_HELP                     0x0010
#define IGIMII_OTHER                    0x0020
#define IGIMII_INPUTTOOLS               0x0040

// fType of IMEMENUITEMINFO structure
#define IMFT_RADIOCHECK 0x00001
#define IMFT_SEPARATOR  0x00002
#define IMFT_SUBMENU    0x00004

// fState of IMEMENUITEMINFO structure
#define IMFS_GRAYED          MF_GRAYED
#define IMFS_DISABLED        MFS_DISABLED
#define IMFS_CHECKED         MFS_CHECKED
#define IMFS_HILITE          MFS_HILITE
#define IMFS_ENABLED         MFS_ENABLED
#define IMFS_UNCHECKED       MFS_UNCHECKED
#define IMFS_UNHILITE        MFS_UNHILITE
#define IMFS_DEFAULT         MFS_DEFAULT



// type of soft keyboard
// for Windows Traditional Chinese Edition
#define SOFTKEYBOARD_TYPE_T1            0x0001
// for Windows Simplified Chinese Edition
#define SOFTKEYBOARD_TYPE_C1            0x0002




//	Windows CE immp.h merged into imm.h


typedef struct tagCOMPOSITIONSTRING {
    DWORD dwSize;
    DWORD dwCompReadAttrLen;
    DWORD dwCompReadAttrOffset;
    DWORD dwCompReadClauseLen;
    DWORD dwCompReadClauseOffset;
    DWORD dwCompReadStrLen;
    DWORD dwCompReadStrOffset;
    DWORD dwCompAttrLen;
    DWORD dwCompAttrOffset;
    DWORD dwCompClauseLen;
    DWORD dwCompClauseOffset;
    DWORD dwCompStrLen;
    DWORD dwCompStrOffset;
    DWORD dwCursorPos;
    DWORD dwDeltaStart;
    DWORD dwResultReadClauseLen;
    DWORD dwResultReadClauseOffset;
    DWORD dwResultReadStrLen;
    DWORD dwResultReadStrOffset;
    DWORD dwResultClauseLen;
    DWORD dwResultClauseOffset;
    DWORD dwResultStrLen;
    DWORD dwResultStrOffset;
    DWORD dwPrivateSize;
    DWORD dwPrivateOffset;
} COMPOSITIONSTRING, *PCOMPOSITIONSTRING, NEAR *NPCOMPOSITIONSTRING, FAR  *LPCOMPOSITIONSTRING;


typedef struct tagGUIDELINE {
    DWORD dwSize;
    DWORD dwLevel;
    DWORD dwIndex;
    DWORD dwStrLen;
    DWORD dwStrOffset;
    DWORD dwPrivateSize;
    DWORD dwPrivateOffset;
} GUIDELINE, *PGUIDELINE, NEAR *NPGUIDELINE, FAR *LPGUIDELINE;

typedef struct tagRECONVERTSTRING {
    DWORD dwSize;
    DWORD dwVersion;
    DWORD dwStrLen;
    DWORD dwStrOffset;
    DWORD dwCompStrLen;
    DWORD dwCompStrOffset;
    DWORD dwTargetStrLen;
    DWORD dwTargetStrOffset;
} RECONVERTSTRING, *PRECONVERTSTRING, NEAR *NPRECONVERTSTRING, FAR *LPRECONVERTSTRING;

typedef struct tagCANDIDATEINFO {
    DWORD               dwSize;
    DWORD               dwCount;
    DWORD               dwOffset[32];
    DWORD               dwPrivateSize;
    DWORD               dwPrivateOffset;
} CANDIDATEINFO, *PCANDIDATEINFO, NEAR *NPCANDIDATEINFO, FAR *LPCANDIDATEINFO;


typedef struct tagINPUTCONTEXT {
    HWND                hWnd;
    BOOL                fOpen;
	DWORD				fdwClient;		//	Windows CE addition.
	HWND				hwndImeInUse;	//	Windows CE addition.
    POINT               ptStatusWndPos;
    POINT               ptSoftKbdPos;
    DWORD               fdwConversion;
    DWORD               fdwSentence;
    union   {
        LOGFONTA        A;
        LOGFONTW        W;
    } lfFont;
    COMPOSITIONFORM     cfCompForm;
    CANDIDATEFORM       cfCandForm[4];
    HIMCC               hCompStr;
    HIMCC               hCandInfo;
    HIMCC               hGuideLine;
    HIMCC               hPrivate;
    DWORD               dwNumMsgBuf;
    HIMCC               hMsgBuf;
    DWORD               fdwInit;
    DWORD               dwReserve[3];
    UINT                uSavedVKey;
    BOOL                fChgMsg;
    DWORD               fdwFlags;
    DWORD               fdw31Compat;
    DWORD               dwRefCount;

    PVOID               pImeModeSaver;
    DWORD               fdwDirty;
} INPUTCONTEXT, *PINPUTCONTEXT, NEAR *NPINPUTCONTEXT, FAR *LPINPUTCONTEXT;


typedef struct tagIMEINFO {
    DWORD       dwPrivateDataSize;
    DWORD       fdwProperty;
    DWORD       fdwConversionCaps;
    DWORD       fdwSentenceCaps;
    DWORD       fdwUICaps;
    DWORD       fdwSCSCaps;
    DWORD       fdwSelectCaps;
} IMEINFO, *PIMEINFO, NEAR *NPIMEINFO, FAR *LPIMEINFO;


typedef struct tagSOFTKBDDATA {
    UINT        uCount;
    WORD        wCode[1][256];
} SOFTKBDDATA, *PSOFTKBDDATA, NEAR *NPSOFTKBDDATA, FAR * LPSOFTKBDDATA;


BOOL WINAPI ImmGetHotKey(DWORD, LPUINT lpuModifiers, LPUINT lpuVKey, LPHKL);
BOOL WINAPI ImmSetHotKey(DWORD, UINT, UINT, HKL);
BOOL WINAPI ImmGenerateMessage(HIMC);

LRESULT WINAPI ImmRequestMessageA(HIMC, WPARAM, LPARAM);
LRESULT WINAPI ImmRequestMessageW(HIMC, WPARAM, LPARAM);
#ifdef UNICODE
#define ImmRequestMessage  ImmRequestMessageW
#else
#define ImmRequestMessage  ImmRequestMessageA
#endif // !UNICODE
//
// Prototype of soft keyboard APIs
//

HWND WINAPI ImmCreateSoftKeyboard(UINT, HWND, int, int);
BOOL WINAPI ImmDestroySoftKeyboard(HWND);
BOOL WINAPI ImmShowSoftKeyboard(HWND, int);


LPINPUTCONTEXT WINAPI ImmLockIMC(HIMC);
BOOL  WINAPI ImmUnlockIMC(HIMC);
DWORD WINAPI ImmGetIMCLockCount(HIMC);

HIMCC  WINAPI ImmCreateIMCC(DWORD);
HIMCC  WINAPI ImmDestroyIMCC(HIMCC);
LPVOID WINAPI ImmLockIMCC(HIMCC);
BOOL   WINAPI ImmUnlockIMCC(HIMCC);
DWORD  WINAPI ImmGetIMCCLockCount(HIMCC);
HIMCC  WINAPI ImmReSizeIMCC(HIMCC, DWORD);
DWORD  WINAPI ImmGetIMCCSize(HIMCC);


// the window extra offset
#define IMMGWL_IMC                      0
#define IMMGWL_PRIVATE                  (sizeof(LONG))


// 0x11 - 0x20 is reserved for soft keyboard
// wParam for WM_IME_SYSTEM
#define IMS_DESTROYWINDOW               0x0001
#define IMS_IME31COMPATIBLE             0x0002
#define IMS_SETOPENSTATUS               0x0003
#define IMS_SETACTIVECONTEXT            0x0004
#define IMS_CHANGE_SHOWSTAT             0x0005
#define IMS_WINDOWPOS                   0x0006

#define IMS_SENDIMEMSG                  0x0007
#define IMS_SENDIMEMSGEX                0x0008
#define IMS_SETCANDIDATEPOS             0x0009
#define IMS_SETCOMPOSITIONFONT          0x000A
#define IMS_SETCOMPOSITIONWINDOW        0x000B
#define IMS_CHECKENABLE                 0x000C
#define IMS_CONFIGUREIME                0x000D
#define IMS_CONTROLIMEMSG               0x000E
#define IMS_SETOPENCLOSE                0x000F
#define IMS_ISACTIVATED                 0x0010
#define IMS_UNLOADTHREADLAYOUT          0x0011
#define IMS_LCHGREQUEST                 0x0012
#define IMS_SETSOFTKBDONOFF             0x0013
#define IMS_GETCONVERSIONMODE           0x0014
#define IMS_IMEHELP                     0x0015

#define IMS_IMENT35SENDAPPMSG           0x0016
#define IMS_ACTIVATECONTEXT             0x0017
#define IMS_DEACTIVATECONTEXT           0x0018
#define IMS_ACTIVATETHREADLAYOUT        0x0019
#define IMS_CLOSEPROPERTYWINDOW         0x001a
#define IMS_OPENPROPERTYWINDOW          0x001b

#define IMS_GETIMEMENU                  0x001c
#define IMS_ENDIMEMENU                  0x001d

#define IMS_SENDNOTIFICATION            0x001f
// IMS_SENDNOTIFICATION dirty bits for INPUTCONTEXT
#define IMSS_UPDATE_OPEN               	0x0001
#define IMSS_UPDATE_CONVERSION         	0x0002
#define IMSS_UPDATE_SENTENCE           	0x0004
#define IMSS_INIT_OPEN                 	0x0100

// These two msgs are CE only & on desktop IMS_XXX msgs range till 
// 0x0024 - so these two msgs are defined from 0x0030.
#define IMS_SETCONVERSIONSTATUS         0x0030
#define IMS_SETSENTENCEMODE             0x0031

// for NI_CONTEXTUPDATED
#define IMC_GETCONVERSIONMODE           0x0001
#define IMC_SETCONVERSIONMODE           0x0002
#define IMC_GETSENTENCEMODE             0x0003
#define IMC_SETSENTENCEMODE             0x0004
#define IMC_GETOPENSTATUS               0x0005
#define IMC_SETOPENSTATUS               0x0006
// wParam for WM_IME_CONTROL to the soft keyboard
#define IMC_GETSOFTKBDFONT              0x0011
#define IMC_SETSOFTKBDFONT              0x0012
#define IMC_GETSOFTKBDPOS               0x0013
#define IMC_SETSOFTKBDPOS               0x0014
#define IMC_GETSOFTKBDSUBTYPE           0x0015
#define IMC_SETSOFTKBDSUBTYPE           0x0016
#define IMC_SETSOFTKBDDATA              0x0018


#define NI_CONTEXTUPDATED               0x0003
// the return bits of ImmProcessHotKey
#define IPHK_HOTKEY                     0x0001
#define IPHK_PROCESSBYIME               0x0002
#define IPHK_CHECKCTRL                  0x0004
// NT only
#define IPHK_SKIPTHISKEY                0x0010


#define MOD_WIN                         0x0008
#define IME_INVALID_HOTKEY                      0xffffffff
#define IME_SYSINFO_WINLOGON            0x0001
#define IME_SYSINFO_WOW16               0x0002
#define GCS_COMP                        (GCS_COMPSTR|GCS_COMPATTR|GCS_COMPCLAUSE)
#define GCS_COMPREAD                    (GCS_COMPREADSTR|GCS_COMPREADATTR |GCS_COMPREADCLAUSE)
#define GCS_RESULT                      (GCS_RESULTSTR|GCS_RESULTCLAUSE)
#define GCS_RESULTREAD                  (GCS_RESULTREADSTR|GCS_RESULTREADCLAUSE)
#define INIT_STATUSWNDPOS               0x00000001
#define INIT_CONVERSION                 0x00000002
#define INIT_SENTENCE                   0x00000004
#define INIT_LOGFONT                    0x00000008
#define INIT_COMPFORM                   0x00000010
#define INIT_SOFTKBDPOS                 0x00000020


// fdw31Compat of INPUTCONTEXT
#define F31COMPAT_NOKEYTOIME     0x00000001
#define F31COMPAT_MCWHIDDEN      0x00000002
#define F31COMPAT_MCWVERTICAL    0x00000004
#define F31COMPAT_CALLFROMWINNLS 0x00000008
#define F31COMPAT_SAVECTRL       0x00010000
#define F31COMPAT_PROCESSEVENT   0x00020000
#define F31COMPAT_ECSETCFS       0x00040000


// the return value of ImmGetAppIMECompatFlags
#define IMECOMPAT_UNSYNC31IMEMSG 0x00000001
// the meaning of this bit depend on the same bit in
// IMELinkHdr.ctCountry.fdFlags
#define IMECOMPAT_DUMMYTASK      0x00000002
// For Japanese and Hangeul versions, this bit on
// indicates no dummy task is needed
#define IMECOMPAT_NODUMMYTASK    IMECOMPAT_DUMMYTASK
// For Chinese and PRC versions, this bit on indicates
// a dummy tasked is needed
#define IMECOMPAT_NEEDDUMMYTASK  IMECOMPAT_DUMMYTASK
#define IMECOMPAT_POSTDUMMY      0x00000004
#define IMECOMPAT_ECNOFLUSH      0x00000008
#define IMECOMPAT_NOINPUTLANGCHGTODLG   0x00000010
#define IMECOMPAT_ECREDRAWPARENT        0x00000020
#define IMECOMPAT_SENDOLDSBM            0x00000040
#define IMECOMPAT_UNSYNC31IMEMSG2       0x00000080
#define IMECOMPAT_NOIMEMSGINTERTASK     0x00000100
#define IMECOMPAT_USEXWANSUNG           0x00000200
#define IMECOMPAT_JXWFORATOK            0x00000400
#define IMECOMPAT_NOIME                 0x00000800
#define IMECOMPAT_NOKBDHOOK             0x00001000
#define IMECOMPAT_APPWNDREMOVEIMEMSGS   0x00002000
#define IMECOMPAT_LSTRCMP31COMPATIBLE   0x00004000
#define IMECOMPAT_USEALTSTKFORSHLEXEC   0x00008000
#define IMECOMPAT_NOVKPROCESSKEY        0x00010000
#define IMECOMPAT_NOYIELDWMCHAR         0x00020000
#define IMECOMPAT_SENDSC_RESTORE        0x00040000
#define IMECOMPAT_NOSENDLANGCHG         0x00080000
#define IMECOMPAT_FORCEUNSYNC31IMEMSG   0x00100000
#define IMECOMPAT_CONSOLEIMEPROCESS     0x00200000

#define IMGTF_CANT_SWITCH_LAYOUT        0x00000001
#define IMGTF_CANT_UNLOAD_IME           0x00000002

#define UI_CAP_SOFTKBD                  0x00010000
// all IME UICapability bits, anyone adding a new bit must update this mask
#define UI_CAP_ALL                      0x00010007
// all ImmSetCompositionString Capability bits, anyone adding a new bit must update this mask
#define SCS_CAP_ALL                     0x00000007
// all IME WM_IME_SELECT inheritance Capability bits, anyone adding a new bit must update this mask
#define SELECT_CAP_ALL                  0x00000003
#define CFS_SCREEN                      0x0004
#define CFS_VERTICAL                    0x0008
#define CFS_HIDDEN                      0x0010
// all conversion mode bits, anyone adding a new bit must update this mask
#define IME_CMODE_ALL                   0x0FFF
// all sentence mode bits, anyone adding a new bit must update this mask
#define IME_SMODE_ALL                   0x001F
#define IMN_SOFTKBDDESTROYED            0x0011



// protype of IME APIs
BOOL    WINAPI ImeInquire(LPIMEINFO, LPWSTR lpszUIClass, DWORD dwSystemInfoFlags);
BOOL    WINAPI ImeConfigure(HKL, HWND, DWORD, LPVOID);
DWORD   WINAPI ImeConversionListW(HIMC, LPCWSTR, LPCANDIDATELIST, DWORD dwBufLen, UINT uFlag);
BOOL    WINAPI ImeDestroy(UINT);
LRESULT WINAPI ImeEscape(HIMC, UINT, LPVOID);
BOOL    WINAPI ImeProcessKey(HIMC, UINT, LPARAM, CONST LPBYTE);
BOOL    WINAPI ImeSelect(HIMC, BOOL);
BOOL    WINAPI ImeSetActiveContext(HIMC, BOOL);
UINT    WINAPI ImeToAsciiEx(UINT uVirtKey, UINT uScaCode, CONST LPBYTE lpbKeyState, LPDWORD lpdwTransBuf, UINT fuState, HIMC);
BOOL    WINAPI NotifyIME(HIMC, DWORD, DWORD, DWORD);
BOOL    WINAPI ImeRegisterWord(LPCWSTR, DWORD, LPCWSTR);
BOOL    WINAPI ImeUnregisterWord(LPCWSTR, DWORD, LPCWSTR);
UINT	WINAPI ImeGetRegisterWordStyle(UINT nItem, LPSTYLEBUF);
UINT    WINAPI ImeEnumRegisterWord(REGISTERWORDENUMPROC, LPCWSTR, DWORD, LPCWSTR, LPVOID);
BOOL    WINAPI ImeSetCompositionString(HIMC, DWORD dwIndex, LPCVOID lpComp, DWORD, LPCVOID lpRead, DWORD);
DWORD	WINAPI ImeGetImeMenuItems(HIMC hIMC, DWORD dwFlags, DWORD dwType, LPIMEMENUITEMINFO lpParentMenu, LPIMEMENUITEMINFO lpMenu, DWORD dwSize);





//	Windows CE additions


BOOL WINAPI ImmIsValidIMC (
	HIMC hIMC
	);

//*****************************************
// Messages From Parent window
//  wParam : 0
//  lParam : appropriate value for Message
//*****************************************

#define CLM_START       0x00001000

#define CLM_SETCANDLIST    (CLM_START + 0) // lParam : LPCANDIDATELIST
#define CLM_SETWNDPOS      (CLM_START + 1) // lParam : MAKELONG(POINT)
#define CLM_GETCURSEL      (CLM_START + 2) // lParam : 0 ; return : current selection
#define CLM_GETPAGESTART   (CLM_START + 3) // lParam : 0 ; return : current page start

// Internal for CANDLIST window
//*****************************************
// Special window styles for candidate list
//*****************************************
#define CLS_BUTTONS     0x00000001
#define CLS_FRACTION 0x00000002
#define CLS_ACTIVATE 0x00000004
#define WS_NOTIFY    0x00000008


//*****************************************
// Notification from Candidate list window
//  wParam for WM_CAND_NOTIFY message
//*****************************************

#define CLN_NOTIFYCODE  0x0100
#define CLN_DETERMINE   (CLN_NOTIFYCODE + 0)
#define CLN_SELECTION   (CLN_NOTIFYCODE + 1)
#define CLN_PAGESTART   (CLN_NOTIFYCODE + 2)


//*****************************************
// Structure for Globaled candidate proc
//*****************************************
typedef struct _MYCANDLIST {
    HWND             ParentWnd;  // Parent window handle.
    LPCANDIDATELIST  CandList;   // Candidate list structure.
} MYCANDLIST;


/*
 * Handwriting pad specific structures
 */
typedef struct _tagHWXRESULT
{
   WORD     cbCount;          // Number of candidates in the list
   WORD     iSelection;      // Current selection
   WORD     iPosition;       // cursor position
   TCHAR    chCandidate[1];   // The array of candidates
} HWXRESULT, *PHWXRESULT;

// Internal window style
#define ES_COMPWND                  0x4000L

// Internal defines and API
#define WM_IME_CONTROL_EDIT         0x1000L
#define IMC_EDIT_CONVERT            0x0001L
#define IMC_EDIT_DETERMINE          0x0002L
#define IMC_EDIT_CANCELCONVERT      0x0003L
#define IMC_EDIT_GETSTATUS          0x0004L
#define IMC_EDIT_UNDO               0x0005L
#define IMC_EDIT_CANUNDO            0x0006L
#define IMC_EDIT_EMPTYUNDOBUFFER    0x0007L
#define IMC_EDIT_REPLACESEL         0x0008L
#define IMC_EDIT_CLEARALL           0x0009L
#define IMC_EDIT_SETIMC             0x000AL
#define IMC_EDIT_GETCANDIDATEPOS    0x000BL
#define IMC_EDIT_UPDATEPROP         0x000CL
#define IMC_EDIT_HALFWIDTH          0x000DL
#define IMC_EDIT_UPDATECLIST        0x000EL

// Edit control is in input mode, no IME is involved
#define IMCR_INPUT                  0x0001
// Edit control is in conversion mode.
#define IMCR_CONVERT                0x0002
// Edit control is in conversion mode, the current clauses is un-converted
// and the cursor is within current clause
#define IMCR_UNCONVERT              0x0003
// Edit control is in composition mode, but not in conversion mode.
#define IMCR_COMPOSITION            0x0004

// For set cursor posision on composition string ( Internal )
#define IME_ESC_SETCURSOR               0x100A


#define SIP_QUERY_STATE             0x2000
#define SIP_SET_STATE               0x2001
#define SIP_STATE_HDKB              0x0001
#define SIP_STATE_NOHDKB			0x0002

#define SIP_QUERY_RCMASK            0x3000
#define SIP_SET_RCMASK              0x3001

#define SIP_SET_OPENCANDWND			0x5000
#define SIP_SET_CLOSECANDWND		0x5001

#define SIP_QUERY_HALFWIDTH			0x6000
#define SIP_SET_HALFWIDTH			0x6001
#define SIP_WIDTHSETTING_HALF       0x01				

#define SIP_QUERY_MODE				0x8000
#define SIP_SET_MODE				0x8001
#define	SIP_MODE_MINIMAL			0x0000
#define	SIP_MODE_REDUCED			0x0001
#define	SIP_MODE_FULL				0x0002
#define	SIP_MODE_FULL_HIDDEN		0x0003

#define SIP_NOTIFY_FOCUS_CHANGE     0xFFFB
#define SIP_RELEASE_STICKY_KEYS     0xFFFC
#define SIP_CONFIG_CHANGED          0xFFFD
#define SIP_SHOW_WARNING			0xFFFE
#define SIP_KILL_MENU				0xFFFF




// wIndex value of ImmSIPanelState
#define SIP_QUERY_LOCATION          0x1000
#define SIP_SET_LOCATION            0x1001
#define SIP_INPUT_ATTRIBUTES		0x7000
#define SIP_INPUT_NUMERIC 			0x00000004L
#define SIP_INPUT_ALPHANUMERIC		0x00000008L
#define SIP_INPUT_HIRAGANA			0x00000010L
#define SIP_INPUT_KATAKANA			0x00000100L
#define SIP_INPUT_EVERYTHING		0x00000000L
#define SIP_INPUT_PASSWORD          0x00000020L
#define SIP_INPUT_HALFWIDTH			0x00000001L
#define SIP_INPUT_FULLWIDTH			0x00000002L
BOOL WINAPI ImmSIPanelState(
    UINT    dwCmd,
    LPVOID  pValue
    );


// wParam of report message WM_IME_REQUEST
#define IMR_COMPOSITIONWINDOW           0x0001
#define IMR_CANDIDATEWINDOW             0x0002
#define IMR_COMPOSITIONFONT             0x0003
#define IMR_RECONVERTSTRING             0x0004
#define IMR_CONFIRMRECONVERTSTRING      0x0005
#define IMR_QUERYCHARPOSITION           0x0006
#define IMR_DOCUMENTFEED                0x0007
// reserved value
#define IMR_RESERVED0x1000              0x1000 

#ifdef __cplusplus
}
#endif


#ifdef WINCEOEM
#include <pimm.h>	// internal defines
#endif




#endif  // _IMM_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\imnxport.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES.
//

#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0286 */
/* at Mon Jan 22 12:14:13 2007
 */
/* Compiler settings for ..\imnxport.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __imnxport_h__
#define __imnxport_h__

/* Forward Declarations */ 

#ifndef __ITransportCallbackService_FWD_DEFINED__
#define __ITransportCallbackService_FWD_DEFINED__
typedef interface ITransportCallbackService ITransportCallbackService;
#endif 	/* __ITransportCallbackService_FWD_DEFINED__ */


#ifndef __ITransportCallback_FWD_DEFINED__
#define __ITransportCallback_FWD_DEFINED__
typedef interface ITransportCallback ITransportCallback;
#endif 	/* __ITransportCallback_FWD_DEFINED__ */


#ifndef __IInternetTransport_FWD_DEFINED__
#define __IInternetTransport_FWD_DEFINED__
typedef interface IInternetTransport IInternetTransport;
#endif 	/* __IInternetTransport_FWD_DEFINED__ */


#ifndef __ISMTPCallback_FWD_DEFINED__
#define __ISMTPCallback_FWD_DEFINED__
typedef interface ISMTPCallback ISMTPCallback;
#endif 	/* __ISMTPCallback_FWD_DEFINED__ */


#ifndef __ISMTPTransport_FWD_DEFINED__
#define __ISMTPTransport_FWD_DEFINED__
typedef interface ISMTPTransport ISMTPTransport;
#endif 	/* __ISMTPTransport_FWD_DEFINED__ */


#ifndef __ISMTPTransport2_FWD_DEFINED__
#define __ISMTPTransport2_FWD_DEFINED__
typedef interface ISMTPTransport2 ISMTPTransport2;
#endif 	/* __ISMTPTransport2_FWD_DEFINED__ */


#ifndef __IDAVNamespaceArbiter_FWD_DEFINED__
#define __IDAVNamespaceArbiter_FWD_DEFINED__
typedef interface IDAVNamespaceArbiter IDAVNamespaceArbiter;
#endif 	/* __IDAVNamespaceArbiter_FWD_DEFINED__ */


#ifndef __IPropPatchRequest_FWD_DEFINED__
#define __IPropPatchRequest_FWD_DEFINED__
typedef interface IPropPatchRequest IPropPatchRequest;
#endif 	/* __IPropPatchRequest_FWD_DEFINED__ */


#ifndef __IPropFindRequest_FWD_DEFINED__
#define __IPropFindRequest_FWD_DEFINED__
typedef interface IPropFindRequest IPropFindRequest;
#endif 	/* __IPropFindRequest_FWD_DEFINED__ */


#ifndef __IPropFindMultiResponse_FWD_DEFINED__
#define __IPropFindMultiResponse_FWD_DEFINED__
typedef interface IPropFindMultiResponse IPropFindMultiResponse;
#endif 	/* __IPropFindMultiResponse_FWD_DEFINED__ */


#ifndef __IPropFindResponse_FWD_DEFINED__
#define __IPropFindResponse_FWD_DEFINED__
typedef interface IPropFindResponse IPropFindResponse;
#endif 	/* __IPropFindResponse_FWD_DEFINED__ */


#ifndef __IHTTPMailCallback_FWD_DEFINED__
#define __IHTTPMailCallback_FWD_DEFINED__
typedef interface IHTTPMailCallback IHTTPMailCallback;
#endif 	/* __IHTTPMailCallback_FWD_DEFINED__ */


#ifndef __IHTTPMailTransport_FWD_DEFINED__
#define __IHTTPMailTransport_FWD_DEFINED__
typedef interface IHTTPMailTransport IHTTPMailTransport;
#endif 	/* __IHTTPMailTransport_FWD_DEFINED__ */


#ifndef __IHTTPMailTransport2_FWD_DEFINED__
#define __IHTTPMailTransport2_FWD_DEFINED__
typedef interface IHTTPMailTransport2 IHTTPMailTransport2;
#endif 	/* __IHTTPMailTransport2_FWD_DEFINED__ */


#ifndef __IPOP3Callback_FWD_DEFINED__
#define __IPOP3Callback_FWD_DEFINED__
typedef interface IPOP3Callback IPOP3Callback;
#endif 	/* __IPOP3Callback_FWD_DEFINED__ */


#ifndef __IPOP3Transport_FWD_DEFINED__
#define __IPOP3Transport_FWD_DEFINED__
typedef interface IPOP3Transport IPOP3Transport;
#endif 	/* __IPOP3Transport_FWD_DEFINED__ */


#ifndef __INNTPCallback_FWD_DEFINED__
#define __INNTPCallback_FWD_DEFINED__
typedef interface INNTPCallback INNTPCallback;
#endif 	/* __INNTPCallback_FWD_DEFINED__ */


#ifndef __INNTPTransport_FWD_DEFINED__
#define __INNTPTransport_FWD_DEFINED__
typedef interface INNTPTransport INNTPTransport;
#endif 	/* __INNTPTransport_FWD_DEFINED__ */


#ifndef __INNTPTransport2_FWD_DEFINED__
#define __INNTPTransport2_FWD_DEFINED__
typedef interface INNTPTransport2 INNTPTransport2;
#endif 	/* __INNTPTransport2_FWD_DEFINED__ */


#ifndef __IRASCallback_FWD_DEFINED__
#define __IRASCallback_FWD_DEFINED__
typedef interface IRASCallback IRASCallback;
#endif 	/* __IRASCallback_FWD_DEFINED__ */


#ifndef __IRASTransport_FWD_DEFINED__
#define __IRASTransport_FWD_DEFINED__
typedef interface IRASTransport IRASTransport;
#endif 	/* __IRASTransport_FWD_DEFINED__ */


#ifndef __IRangeList_FWD_DEFINED__
#define __IRangeList_FWD_DEFINED__
typedef interface IRangeList IRangeList;
#endif 	/* __IRangeList_FWD_DEFINED__ */


#ifndef __IIMAPCallback_FWD_DEFINED__
#define __IIMAPCallback_FWD_DEFINED__
typedef interface IIMAPCallback IIMAPCallback;
#endif 	/* __IIMAPCallback_FWD_DEFINED__ */


#ifndef __IIMAPTransport_FWD_DEFINED__
#define __IIMAPTransport_FWD_DEFINED__
typedef interface IIMAPTransport IIMAPTransport;
#endif 	/* __IIMAPTransport_FWD_DEFINED__ */


#ifndef __IIMAPTransport2_FWD_DEFINED__
#define __IIMAPTransport2_FWD_DEFINED__
typedef interface IIMAPTransport2 IIMAPTransport2;
#endif 	/* __IIMAPTransport2_FWD_DEFINED__ */


/* header files for imported files */
#include "imnact.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_imnxport_0000 */
/* [local] */ 









#if 0
typedef HANDLE HDPA;

#endif
//--------------------------------------------------------------------------------
// IMNXPORT.H
//--------------------------------------------------------------------------------
// (C) Copyright 1995-1998 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//--------------------------------------------------------------------------------

#pragma comment(lib,"uuid.lib")
// --------------------------------------------------------------------------------
// Dependencies
// --------------------------------------------------------------------------------
#include <ras.h>
#include <raserror.h>

#ifdef IEMOBILE
#include <pcommctr.h>
#else
#include <commctrl.h>
#endif


// --------------------------------------------------------------------------------
// GUIDS
// --------------------------------------------------------------------------------
// {CA30CC91-B1B3-11d0-85D0-00C04FD85AB4}
DEFINE_GUID(CLSID_IInternetMessageUrl, 0xca30cc91, 0xb1b3, 0x11d0, 0x85, 0xd0, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// {0DF2C7E1-3435-11d0-81D0-00C04FD85AB4}
DEFINE_GUID(IID_ITransportCallback, 0xdf2c7e1, 0x3435, 0x11d0, 0x81, 0xd0, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// {1F636C01-364E-11d0-81D3-00C04FD85AB4}
DEFINE_GUID(IID_IInternetTransport, 0x1f636c01, 0x364e, 0x11d0, 0x81, 0xd3, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// {1F636C02-364E-11d0-81D3-00C04FD85AB4}
DEFINE_GUID(IID_ISMTPCallback, 0x1f636c02, 0x364e, 0x11d0, 0x81, 0xd3, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// {FD853CE6-7F86-11d0-8252-00C04FD85AB4}
DEFINE_GUID(CLSID_ISMTPTransport, 0xfd853ce6, 0x7f86, 0x11d0, 0x82, 0x52, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);
// {0DF2C7E2-3435-11d0-81D0-00C04FD85AB4}
DEFINE_GUID(IID_ISMTPTransport, 0xdf2c7e2, 0x3435, 0x11d0, 0x81, 0xd0, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);
// {0DF2C7EC-3435-11d0-81D0-00C04FD85AB4}
DEFINE_GUID(IID_ISMTPTransport2, 0xdf2c7eC, 0x3435, 0x11d0, 0x81, 0xd0, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// {0DF2C7E3-3435-11d0-81D0-00C04FD85AB4}
DEFINE_GUID(IID_IPOP3Callback, 0xdf2c7e3, 0x3435, 0x11d0, 0x81, 0xd0, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// {FD853CE7-7F86-11d0-8252-00C04FD85AB4}
DEFINE_GUID(CLSID_IPOP3Transport, 0xfd853ce7, 0x7f86, 0x11d0, 0x82, 0x52, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);
// {0DF2C7E4-3435-11d0-81D0-00C04FD85AB4}
DEFINE_GUID(IID_IPOP3Transport, 0xdf2c7e4, 0x3435, 0x11d0, 0x81, 0xd0, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// {0DF2C7E5-3435-11d0-81D0-00C04FD85AB4}
DEFINE_GUID(IID_INNTPCallback, 0xdf2c7e5, 0x3435, 0x11d0, 0x81, 0xd0, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// {FD853CE8-7F86-11d0-8252-00C04FD85AB4}
DEFINE_GUID(CLSID_INNTPTransport, 0xfd853ce8, 0x7f86, 0x11d0, 0x82, 0x52, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);
// {0DF2C7E6-3435-11d0-81D0-00C04FD85AB4}
DEFINE_GUID(IID_INNTPTransport, 0xdf2c7e6, 0x3435, 0x11d0, 0x81, 0xd0, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);
// {0DF2C7ED-3435-11d0-81D0-00C04FD85AB4}
DEFINE_GUID(IID_INNTPTransport2, 0xdf2c7eD, 0x3435, 0x11d0, 0x81, 0xd0, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// {36D88911-3CD6-11d0-81DF-00C04FD85AB4}
DEFINE_GUID(IID_IRASCallback, 0x36d88911, 0x3cd6, 0x11d0, 0x81, 0xdf, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// {FD853CE9-7F86-11d0-8252-00C04FD85AB4}
DEFINE_GUID(CLSID_IRASTransport, 0xfd853ce9, 0x7f86, 0x11d0, 0x82, 0x52, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);
// {8A950001-3CCF-11d0-81DF-00C04FD85AB4}
DEFINE_GUID(IID_IRASTransport, 0x8a950001, 0x3ccf, 0x11d0, 0x81, 0xdf, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// {FD853CEA-7F86-11d0-8252-00C04FD85AB4}
DEFINE_GUID(CLSID_IRangeList, 0xfd853cea, 0x7f86, 0x11d0, 0x82, 0x52, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);
// {8C438160-4EF6-11d0-874F-00AA00530EE9}
DEFINE_GUID(IID_IRangeList, 0x8c438160, 0x4ef6, 0x11d0, 0x87, 0x4f, 0x0, 0xaa, 0x0, 0x53, 0xe, 0xe9);

// {E9E9D8A3-4EDD-11d0-874F-00AA00530EE9}
DEFINE_GUID(IID_IIMAPCallback, 0xe9e9d8a3, 0x4edd, 0x11d0, 0x87, 0x4f, 0x0, 0xaa, 0x0, 0x53, 0xe, 0xe9);

// {FD853CEB-7F86-11d0-8252-00C04FD85AB4}
DEFINE_GUID(CLSID_IIMAPTransport, 0xfd853ceb, 0x7f86, 0x11d0, 0x82, 0x52, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);
// {E9E9D8A8-4EDD-11d0-874F-00AA00530EE9}
DEFINE_GUID(IID_IIMAPTransport, 0xe9e9d8a8, 0x4edd, 0x11d0, 0x87, 0x4f, 0x0, 0xaa, 0x0, 0x53, 0xe, 0xe9);

// {DA8283C0-37C5-11d2-ACD9-0080C7B6E3C5}
DEFINE_GUID(IID_IIMAPTransport2, 0xda8283c0, 0x37c5, 0x11d2, 0xac, 0xd9, 0x0, 0x80, 0xc7, 0xb6, 0xe3, 0xc5);

// {07849A11-B520-11d0-85D5-00C04FD85AB4}
DEFINE_GUID(IID_IBindMessageStream, 0x7849a11, 0xb520, 0x11d0, 0x85, 0xd5, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// {CA30F3FF-C9AC-11d1-9A3A-00C04FA309D4}
DEFINE_GUID(IID_ITransportCallbackService, 0xca30f3ff, 0xc9ac, 0x11d1, 0x9a, 0x3a, 0x0, 0xc0, 0x4f, 0xa3, 0x9, 0xd4);

// {19F6481C-E5F0-11d1-A86E-0000F8084F96}
DEFINE_GUID(IID_IHTTPMailCallback, 0x19f6481c, 0xe5f0, 0x11d1, 0xa8, 0x6e, 0x0, 0x0, 0xf8, 0x8, 0x4f, 0x96);

// {5A580C11-E5EB-11d1-A86E-0000F8084F96}
DEFINE_GUID(CLSID_IHTTPMailTransport,0x5a580c11, 0xe5eb, 0x11d1, 0xa8, 0x6e, 0x0, 0x0, 0xf8, 0x8, 0x4f, 0x96);
// {B8BDE03C-E548-11d1-A86E-0000F8084F96}
DEFINE_GUID(IID_IHTTPMailTransport, 0xb8bde03c, 0xe548, 0x11d1, 0xa8, 0x6e, 0x0, 0x0, 0xf8, 0x8, 0x4f, 0x96);

// {82758005-D38A-11d3-8E81-00C04F79E13B}
DEFINE_GUID(IID_IHTTPMailTransport2, 0x82758005, 0xd38a, 0x11d3, 0x8e, 0x81, 0x0, 0xc0, 0x4f, 0x79, 0xe1, 0x3b);

// {BB847B8A-054A-11d2-A894-0000F8084F96}
DEFINE_GUID(CLSID_IPropFindRequest, 0xbb847b8a, 0x54a, 0x11d2, 0xa8, 0x94, 0x0, 0x0, 0xf8, 0x8, 0x4f, 0x96);
// {5CFC6308-0544-11d2-A894-0000F8084F96}
DEFINE_GUID(IID_IPropFindRequest, 0x5cfc6308, 0x544, 0x11d2, 0xa8, 0x94, 0x0, 0x0, 0xf8, 0x8, 0x4f, 0x96);

// {0DEE87DE-0547-11d2-A894-0000F8084F96}
DEFINE_GUID(IID_IPropFindMultiResponse, 0xdee87de, 0x547, 0x11d2, 0xa8, 0x94, 0x0, 0x0, 0xf8, 0x8, 0x4f, 0x96);

// {8A523716-0548-11d2-A894-0000F8084F96}
DEFINE_GUID(IID_IPropFindResponse, 0x8a523716, 0x548, 0x11d2, 0xa8, 0x94, 0x0, 0x0, 0xf8, 0x8, 0x4f, 0x96);

// {72A58FF8-227D-11d2-A8B5-0000F8084F96}
DEFINE_GUID(IID_IDAVNamespaceArbiter, 0x72a58ff8, 0x227d, 0x11d2, 0xa8, 0xb5, 0x0, 0x0, 0xf8, 0x8, 0x4f, 0x96);

// {EA678830-235D-11d2-A8B6-0000F8084F96}
DEFINE_GUID(CLSID_IPropPatchRequest, 0xea678830, 0x235d, 0x11d2, 0xa8, 0xb6, 0x0, 0x0, 0xf8, 0x8, 0x4f, 0x96);
// {AB8B8D2A-227F-11d2-A8B5-0000F8084F96}
DEFINE_GUID(IID_IPropPatchRequest, 0xab8b8d2a, 0x227f, 0x11d2, 0xa8, 0xb5, 0x0, 0x0, 0xf8, 0x8, 0x4f, 0x96);

// --------------------------------------------------------------------------------
// Errors
// --------------------------------------------------------------------------------
#ifndef FACILITY_INTERNET
#define FACILITY_INTERNET 12
#endif
#ifndef HR_E
#define HR_E(n) MAKE_SCODE(SEVERITY_ERROR, FACILITY_INTERNET, n)
#endif
#ifndef HR_S
#define HR_S(n) MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_INTERNET, n)
#endif
#ifndef HR_CODE
#define HR_CODE(hr) (INT)(hr & 0xffff)
#endif

// --------------------------------------------------------------------------------
// General Imnxport Return Values
// --------------------------------------------------------------------------------
#define IXP_E_LOAD_SICILY_FAILED             HR_E(0xCC00)
#define IXP_E_INVALID_CERT_CN                HR_E(0xCC01)
#define IXP_E_INVALID_CERT_DATE              HR_E(0xCC02)
#define IXP_E_ALREADY_CONNECTED              HR_E(0xCC03)
#define IXP_E_CONN                           HR_E(0xCC04)
#define IXP_E_NOT_CONNECTED                  HR_E(0xCC05)
#define IXP_E_CONN_SEND                      HR_E(0xCC06)
#define IXP_E_WOULD_BLOCK                    HR_E(0xCC07)
#define IXP_E_INVALID_STATE                  HR_E(0xCC08)
#define IXP_E_CONN_RECV                      HR_E(0xCC09)
#define IXP_E_INCOMPLETE                     HR_E(0xCC0A)
#define IXP_E_BUSY                           HR_E(0xCC0B)
#define IXP_E_NOT_INIT                       HR_E(0xCC0C)
#define IXP_E_CANT_FIND_HOST                 HR_E(0xCC0D)
#define IXP_E_FAILED_TO_CONNECT              HR_E(0xCC0E)
#define IXP_E_CONNECTION_DROPPED             HR_E(0xCC0F)
#define IXP_E_INVALID_ADDRESS                HR_E(0xCC10)
#define IXP_E_INVALID_ADDRESS_LIST           HR_E(0xCC11)
#define IXP_E_SOCKET_READ_ERROR              HR_E(0xCC12)
#define IXP_E_SOCKET_WRITE_ERROR             HR_E(0xCC13)
#define IXP_E_SOCKET_INIT_ERROR              HR_E(0xCC14)
#define IXP_E_SOCKET_CONNECT_ERROR           HR_E(0xCC15)
#define IXP_E_INVALID_ACCOUNT                HR_E(0xCC16)
#define IXP_E_USER_CANCEL                    HR_E(0xCC17)
#define IXP_E_SICILY_LOGON_FAILED            HR_E(0xCC18)
#define IXP_E_TIMEOUT                        HR_E(0xCC19)
#define IXP_E_SECURE_CONNECT_FAILED			HR_E(0xCC1A)

// --------------------------------------------------------------------------------
// WINSOCK Errors
// --------------------------------------------------------------------------------
#define IXP_E_WINSOCK_WSASYSNOTREADY         HR_E(0xCC40)
#define IXP_E_WINSOCK_WSAVERNOTSUPPORTED     HR_E(0xCC41)
#define IXP_E_WINSOCK_WSAEPROCLIM            HR_E(0xCC42)
#define IXP_E_WINSOCK_WSAEFAULT              HR_E(0xCC43)
#define IXP_E_WINSOCK_FAILED_WSASTARTUP      HR_E(0xCC44)
#define IXP_E_WINSOCK_WSAEINPROGRESS         HR_E(0xCC45)

// --------------------------------------------------------------------------------
// SMTP Command Response Values
//--------------------------------------------------------------------------------
#define IXP_E_SMTP_RESPONSE_ERROR            HR_E(0xCC60)
#define IXP_E_SMTP_UNKNOWN_RESPONSE_CODE     HR_E(0xCC61)
#define IXP_E_SMTP_500_SYNTAX_ERROR          HR_E(0xCC62)
#define IXP_E_SMTP_501_PARAM_SYNTAX          HR_E(0xCC63)
#define IXP_E_SMTP_502_COMMAND_NOTIMPL       HR_E(0xCC64)
#define IXP_E_SMTP_503_COMMAND_SEQ           HR_E(0xCC65)
#define IXP_E_SMTP_504_COMMAND_PARAM_NOTIMPL HR_E(0xCC66)
#define IXP_E_SMTP_421_NOT_AVAILABLE         HR_E(0xCC67)
#define IXP_E_SMTP_450_MAILBOX_BUSY          HR_E(0xCC68)
#define IXP_E_SMTP_550_MAILBOX_NOT_FOUND     HR_E(0xCC69)
#define IXP_E_SMTP_451_ERROR_PROCESSING      HR_E(0xCC6A)
#define IXP_E_SMTP_551_USER_NOT_LOCAL        HR_E(0xCC6B)
#define IXP_E_SMTP_452_NO_SYSTEM_STORAGE     HR_E(0xCC6C)
#define IXP_E_SMTP_552_STORAGE_OVERFLOW      HR_E(0xCC6D)
#define IXP_E_SMTP_553_MAILBOX_NAME_SYNTAX   HR_E(0xCC6E)
#define IXP_E_SMTP_554_TRANSACT_FAILED       HR_E(0xCC6F)

#define IXP_S_SMTP_211_SYSTEM_STATUS         HR_S(0xCC70)
#define IXP_S_SMTP_214_HELP_MESSAGE          HR_S(0xCC71)
#define IXP_S_SMTP_220_READY                 HR_S(0xCC72)
#define IXP_S_SMTP_221_CLOSING               HR_S(0xCC73)
#define IXP_S_SMTP_250_MAIL_ACTION_OKAY      HR_S(0xCC74)
#define IXP_S_SMTP_251_FORWARDING_MAIL       HR_S(0xCC75)
#define IXP_S_SMTP_354_START_MAIL_INPUT      HR_S(0xCC76)
#define IXP_S_SMTP_CONTINUE                  HR_S(0xCC77)
#define IXP_S_SMTP_334_AUTH_READY_RESPONSE   HR_S(0xCC78)
#define IXP_S_SMTP_245_AUTH_SUCCESS          HR_S(0xCC79)

#define IXP_E_SMTP_REJECTED_SENDER           HR_E(0xCC78)
#define IXP_E_SMTP_REJECTED_RECIPIENTS       HR_E(0xCC79)
#define IXP_E_SMTP_NO_SENDER                 HR_E(0xCC7A)
#define IXP_E_SMTP_NO_RECIPIENTS             HR_E(0xCC7B)
#define IXP_E_SMTP_530_STARTTLS_REQUIRED      HR_E(0xCC7C)
#define IXP_E_SMTP_NO_STARTTLS_SUPPORT       HR_E(0xCC7D)
#define IXP_S_SMTP_NO_DSN_SUPPORT            HR_E(0xCC7E)
#define IXP_E_SMTP_454_STARTTLS_FAILED       HR_E(0xCC7F)

// --------------------------------------------------------------------------------
// POP3 Command Response Values
// --------------------------------------------------------------------------------
#define IXP_E_POP3_RESPONSE_ERROR            HR_E(0xCC90)
#define IXP_E_POP3_INVALID_USER_NAME         HR_E(0xCC91)
#define IXP_E_POP3_INVALID_PASSWORD          HR_E(0xCC92)
#define IXP_E_POP3_PARSE_FAILURE             HR_E(0xCC93)
#define IXP_E_POP3_NEED_STAT                 HR_E(0xCC94)
#define IXP_E_POP3_NO_MESSAGES               HR_E(0xCC95)
#define IXP_E_POP3_NO_MARKED_MESSAGES        HR_E(0xCC96)
#define IXP_E_POP3_POPID_OUT_OF_RANGE        HR_E(0xCC97)

// --------------------------------------------------------------------------------
// NNTP Command Response Values
// --------------------------------------------------------------------------------
#define IXP_E_NNTP_RESPONSE_ERROR            HR_E(0xCCA0)
#define IXP_E_NNTP_NEWGROUPS_FAILED          HR_E(0xCCA1)
#define IXP_E_NNTP_LIST_FAILED               HR_E(0xCCA2)
#define IXP_E_NNTP_LISTGROUP_FAILED          HR_E(0xCCA3)
#define IXP_E_NNTP_GROUP_FAILED              HR_E(0xCCA4)
#define IXP_E_NNTP_GROUP_NOTFOUND            HR_E(0xCCA5)
#define IXP_E_NNTP_ARTICLE_FAILED            HR_E(0xCCA6)
#define IXP_E_NNTP_HEAD_FAILED               HR_E(0xCCA7)
#define IXP_E_NNTP_BODY_FAILED               HR_E(0xCCA8)
#define IXP_E_NNTP_POST_FAILED               HR_E(0xCCA9)
#define IXP_E_NNTP_NEXT_FAILED               HR_E(0xCCAA)
#define IXP_E_NNTP_DATE_FAILED               HR_E(0xCCAB)
#define IXP_E_NNTP_HEADERS_FAILED            HR_E(0xCCAC)
#define IXP_E_NNTP_XHDR_FAILED               HR_E(0xCCAD)
#define IXP_E_NNTP_INVALID_USERPASS          HR_E(0xCCAE)

// --------------------------------------------------------------------------------
// NNTP Server Response Values
// --------------------------------------------------------------------------------
#define IXP_NNTP_DATE_RESPONSE               111
#define IXP_NNTP_POST_ALLOWED                200
#define IXP_NNTP_POST_NOTALLOWED             201
#define IXP_NNTP_GROUP_SELECTED              211
#define IXP_NNTP_LIST_DATA_FOLLOWS           215
#define IXP_NNTP_ARTICLE_FOLLOWS             220
#define IXP_NNTP_HEAD_FOLLOWS                221
#define IXP_NNTP_BODY_FOLLOWS                222
#define IXP_NNTP_ARTICLE_RETRIEVED           223
#define IXP_NNTP_OVERVIEW_FOLLOWS            224
#define IXP_NNTP_NEWNEWSGROUPS_FOLLOWS       231
#define IXP_NNTP_ARTICLE_POSTED_OK           240
#define IXP_NNTP_AUTHORIZATION_ACCEPTED      250
#define IXP_NNTP_AUTH_OK                     281
#define IXP_NNTP_SEND_ARTICLE_TO_POST        340
#define IXP_NNTP_CONTINUE_AUTHORIZATION      350
#define IXP_NNTP_PASSWORD_REQUIRED           381
#define IXP_NNTP_NO_SUCH_NEWSGROUP           411
#define IXP_NNTP_NO_NEXT_ARTICLE             421
#define IXP_NNTP_NO_PREV_ARTICLE             422
#define IXP_NNTP_NO_SUCH_ARTICLE_NUM         423
#define IXP_NNTP_NO_SUCH_ARTICLE_FOUND       430
#define IXP_NNTP_POSTING_NOT_ALLOWED         441
#define IXP_NNTP_PROTOCOLS_SUPPORTED         485

// --------------------------------------------------------------------------------
// RAS Errors
// --------------------------------------------------------------------------------
#define IXP_S_RAS_NOT_NEEDED                 HR_S(0xCCC0)
#define IXP_S_RAS_USING_CURRENT              HR_S(0xCCC1)
#define IXP_E_RAS_NOT_INSTALLED              HR_E(0xCCC2)
#define IXP_E_RAS_PROCS_NOT_FOUND            HR_E(0xCCC3)
#define IXP_E_RAS_ERROR                      HR_E(0xCCC4)
#define IXP_E_RAS_INVALID_CONNECTOID         HR_E(0xCCC5)
#define IXP_E_RAS_GET_DIAL_PARAMS            HR_E(0xCCC6)

// --------------------------------------------------------------------------------
// IMAP Return Codes
// --------------------------------------------------------------------------------
#define IXP_S_IMAP_UNRECOGNIZED_RESP         HR_S(0xCCD0) // Did not recognize IMAP response CODE
#define IXP_S_IMAP_VERBATIM_MBOX             HR_S(0xCCE1) // Could not xlate mbox to target CP (or it's disabled): copying verbatim

#define IXP_E_IMAP_LOGINFAILURE              HR_E(0xCCD1) // LOGIN cmd failed
#define IXP_E_IMAP_TAGGED_NO_RESPONSE        HR_E(0xCCD2) // Received tagged NO response
#define IXP_E_IMAP_BAD_RESPONSE              HR_E(0xCCD3) // Received tagged BAD response
#define IXP_E_IMAP_SVR_SYNTAXERR             HR_E(0xCCD4) // Syntax error in svr response
#define IXP_E_IMAP_NOTIMAPSERVER             HR_E(0xCCD5) // This is not an IMAP server
#define IXP_E_IMAP_BUFFER_OVERFLOW           HR_E(0xCCD6) // Buffer overflow occurred
#define IXP_E_IMAP_RECVR_ERROR               HR_E(0xCCD7) // An error occurred in the recvr code
#define IXP_E_IMAP_INCOMPLETE_LINE           HR_E(0xCCD8) // Received incomplete line
#define IXP_E_IMAP_CONNECTION_REFUSED        HR_E(0xCCD9) // Received BYE on greeting
#define IXP_E_IMAP_UNRECOGNIZED_RESP         HR_E(0xCCDA) // Did not recognize IMAP response
#define IXP_E_IMAP_CHANGEDUID                HR_E(0xCCDB) // UID changed unexpectedly!
#define IXP_E_IMAP_UIDORDER                  HR_E(0xCCDC) // UIDs not strictly ascending!
#define IXP_E_IMAP_UNSOLICITED_BYE           HR_E(0xCCDD) // Server issued UNSOLICITED BYE
#define IXP_E_IMAP_IMPROPER_SVRSTATE			HR_E(0xCCDE) // eg, Attempt to send FETCH before SELECT finishes
#define IXP_E_IMAP_AUTH_NOT_POSSIBLE			HR_E(0xCCDF) // No common authentication methods btwn client/svr
#define IXP_E_IMAP_OUT_OF_AUTH_METHODS		HR_E(0xCCE0) // We tried >= 1 auth method, no more left to try

// --------------------------------------------------------------------------------
// HTTPMail Return Codes
// --------------------------------------------------------------------------------
// http errors are discontiguous.
#define IXP_E_HTTP_USE_PROXY                 HR_E(0xCC30) // http status 305
#define IXP_E_HTTP_BAD_REQUEST               HR_E(0xCC31) // http status 400
#define IXP_E_HTTP_UNAUTHORIZED              HR_E(0xCC32) // http status 401
#define IXP_E_HTTP_FORBIDDEN                 HR_E(0xCC33) // http status 403
#define IXP_E_HTTP_NOT_FOUND                 HR_E(0xCC34) // http status 404
#define IXP_E_HTTP_METHOD_NOT_ALLOW          HR_E(0xCC35) // http status 405
#define IXP_E_HTTP_NOT_ACCEPTABLE            HR_E(0xCC36) // http status 406
#define IXP_E_HTTP_PROXY_AUTH_REQ            HR_E(0xCC37) // http status 407
#define IXP_E_HTTP_REQUEST_TIMEOUT           HR_E(0xCC38) // http status 408
#define IXP_E_HTTP_CONFLICT                  HR_E(0xCC39) // http status 409
#define IXP_E_HTTP_GONE                      HR_E(0xCC3A) // http status 410
#define IXP_E_HTTP_LENGTH_REQUIRED           HR_E(0xCC3B) // http status 411
#define IXP_E_HTTP_PRECOND_FAILED            HR_E(0xCC3C) // http status 412
#define IXP_E_HTTP_INTERNAL_ERROR            HR_E(0xCC3D) // http status 500
#define IXP_E_HTTP_NOT_IMPLEMENTED           HR_E(0xCC3E) // http status 501
#define IXP_E_HTTP_BAD_GATEWAY               HR_E(0xCC3F) // http status 502
// begin second range
#define IXP_E_HTTP_SERVICE_UNAVAIL           HR_E(0xCCF0) // http status 503
#define IXP_E_HTTP_GATEWAY_TIMEOUT           HR_E(0xCCF1) // http status 504
#define IXP_E_HTTP_VERS_NOT_SUP              HR_E(0xCCF2) // http status 505
#define IXP_E_HTTP_INSUFFICIENT_STORAGE      HR_E(0xCCF3) // http status 425 or 507
#define IXP_E_HTTP_ROOT_PROP_NOT_FOUND       HR_E(0xCCF4) // see IHTTPMailTransport::GetProperty
#define IXP_E_HTTP_NOT_MODIFIED              HR_E(0xCCF5) // http status 304
#define IXP_E_HTTP_PAYMENT_REQUIRED          HR_E(0xCCF6) // http status 402

// --------------------------------------------------------------------------------
// String Length Constants
// --------------------------------------------------------------------------------

#define	CCHMAX_DOMAIN	( 256 )

#define	CCHMAX_PHONE_NUMBER	( 128 )

#define	DEFAULT_IMAP_PORT	( 143 )

#define	DEFAULT_POP3_PORT	( 110 )

#define	DEFAULT_SMTP_PORT	( 25 )

#define	DEFAULT_NNTP_PORT	( 119 )

typedef 
enum tagINETADDRTYPE
    {	ADDR_TO	= 0,
	ADDR_FROM	= ADDR_TO + 1,
	ADDR_DSN_NEVER	= 16,
	ADDR_DSN_SUCCESS	= 32,
	ADDR_DSN_FAILURE	= 64,
	ADDR_DSN_DELAY	= 128
    }	INETADDRTYPE;

#define	ADDR_TOFROM_MASK	( 0x1 )

#define	ADDR_DSN_MASK	( 0xf0 )

typedef 
enum tagDSNRET
    {	DSNRET_DEFAULT	= 0,
	DSNRET_HDRS	= DSNRET_DEFAULT + 1,
	DSNRET_FULL	= DSNRET_HDRS + 1
    }	DSNRET;

typedef struct tagINETADDR
    {
    INETADDRTYPE addrtype;
    CHAR szEmail[ 256 ];
    }	INETADDR;

typedef struct tagINETADDR __RPC_FAR *LPINETADDR;

typedef struct tagINETADDRLIST
    {
    ULONG cAddress;
    LPINETADDR prgAddress;
    }	INETADDRLIST;

typedef struct tagINETADDRLIST __RPC_FAR *LPINETADDRLIST;

typedef 
enum tagRASCONNTYPE
    {	RAS_CONNECT_LAN	= 0,
	RAS_CONNECT_MANUAL	= RAS_CONNECT_LAN + 1,
	RAS_CONNECT_RAS	= RAS_CONNECT_MANUAL + 1
    }	RASCONNTYPE;

typedef 
enum tagHTTPMAILPROPTYPE
    {	HTTPMAIL_PROP_INVALID	= 0,
	HTTPMAIL_PROP_ADBAR	= HTTPMAIL_PROP_INVALID + 1,
	HTTPMAIL_PROP_CONTACTS	= HTTPMAIL_PROP_ADBAR + 1,
	HTTPMAIL_PROP_INBOX	= HTTPMAIL_PROP_CONTACTS + 1,
	HTTPMAIL_PROP_OUTBOX	= HTTPMAIL_PROP_INBOX + 1,
	HTTPMAIL_PROP_SENDMSG	= HTTPMAIL_PROP_OUTBOX + 1,
	HTTPMAIL_PROP_SENTITEMS	= HTTPMAIL_PROP_SENDMSG + 1,
	HTTPMAIL_PROP_DELETEDITEMS	= HTTPMAIL_PROP_SENTITEMS + 1,
	HTTPMAIL_PROP_DRAFTS	= HTTPMAIL_PROP_DELETEDITEMS + 1,
	HTTPMAIL_PROP_MSGFOLDERROOT	= HTTPMAIL_PROP_DRAFTS + 1,
	HTTPMAIL_PROP_SIG	= HTTPMAIL_PROP_MSGFOLDERROOT + 1,
	HTTPMAIL_PROP_MAXPOLLINGINTERVAL	= HTTPMAIL_PROP_SIG + 1,
	HTTPMAIL_PROP_LAST	= HTTPMAIL_PROP_MAXPOLLINGINTERVAL + 1
    }	HTTPMAILPROPTYPE;

typedef 
enum tagHTTPMAILSPECIALFOLDER
    {	HTTPMAIL_SF_NONE	= 0,
	HTTPMAIL_SF_UNRECOGNIZED	= HTTPMAIL_SF_NONE + 1,
	HTTPMAIL_SF_INBOX	= HTTPMAIL_SF_UNRECOGNIZED + 1,
	HTTPMAIL_SF_DELETEDITEMS	= HTTPMAIL_SF_INBOX + 1,
	HTTPMAIL_SF_DRAFTS	= HTTPMAIL_SF_DELETEDITEMS + 1,
	HTTPMAIL_SF_OUTBOX	= HTTPMAIL_SF_DRAFTS + 1,
	HTTPMAIL_SF_SENTITEMS	= HTTPMAIL_SF_OUTBOX + 1,
	HTTPMAIL_SF_CONTACTS	= HTTPMAIL_SF_SENTITEMS + 1,
	HTTPMAIL_SF_CALENDAR	= HTTPMAIL_SF_CONTACTS + 1,
	HTTPMAIL_SF_MSNPROMO	= HTTPMAIL_SF_CALENDAR + 1,
	HTTPMAIL_SF_BULKMAIL	= HTTPMAIL_SF_MSNPROMO + 1,
	HTTPMAIL_SF_LAST	= HTTPMAIL_SF_BULKMAIL + 1
    }	HTTPMAILSPECIALFOLDER;

typedef 
enum tagHTTPMAILCONTACTTYPE
    {	HTTPMAIL_CT_CONTACT	= 0,
	HTTPMAIL_CT_GROUP	= HTTPMAIL_CT_CONTACT + 1,
	HTTPMAIL_CT_LAST	= HTTPMAIL_CT_GROUP + 1
    }	HTTPMAILCONTACTTYPE;

#define	DAVNAMESPACE_UNKNOWN	( 0xffffffff )

#define	DAVNAMESPACE_DAV	( 0 )

#define	DAVNAMESPACE_HOTMAIL	( 1 )

#define	DAVNAMESPACE_HTTPMAIL	( 2 )

#define	DAVNAMESPACE_MAIL	( 3 )

#define	DAVNAMESPACE_CONTACTS	( 4 )

#define      ISF_SMTP_USEIPFORHELO           0x00000001 // For HELO or EHLO Command
#define      ISF_ALWAYSPROMPTFORPASSWORD     0x00000002 // For HELO or EHLO Command
#define      ISF_SSLONSAMEPORT               0x00000004 // For SMTP Only - use STARTTLS
#define      ISF_QUERYDSNSUPPORT             0x00000008 // For SMTP Only - issue EHLO on connect and check for DSN
#define      ISF_QUERYAUTHSUPPORT            0x00000010 // For SMTP Only - issue EHLO on connect and check for AUTH
typedef struct INETSERVER
    {
    CHAR szAccount[ 256 ];
    CHAR szUserName[ 256 ];
    CHAR szPassword[ 256 ];
    CHAR szServerName[ 256 ];
    CHAR szConnectoid[ 256 ];
    RASCONNTYPE rasconntype;
    DWORD dwPort;
    BOOL fSSL;
    BOOL fTrySicily;
    DWORD dwTimeout;
    DWORD dwFlags;
    }	INETSERVER;

typedef struct INETSERVER __RPC_FAR *LPINETSERVER;

typedef 
enum tagIXPTYPE
    {	IXP_NNTP	= 0,
	IXP_SMTP	= IXP_NNTP + 1,
	IXP_POP3	= IXP_SMTP + 1,
	IXP_IMAP	= IXP_POP3 + 1,
	IXP_RAS	= IXP_IMAP + 1,
	IXP_HTTPMail	= IXP_RAS + 1,
	IXP_HTTP	= IXP_HTTPMail + 1
    }	IXPTYPE;

typedef 
enum tagIXPSTATUS
    {	IXP_FINDINGHOST	= 0,
	IXP_CONNECTING	= IXP_FINDINGHOST + 1,
	IXP_SECURING	= IXP_CONNECTING + 1,
	IXP_CONNECTED	= IXP_SECURING + 1,
	IXP_AUTHORIZING	= IXP_CONNECTED + 1,
	IXP_AUTHRETRY	= IXP_AUTHORIZING + 1,
	IXP_AUTHORIZED	= IXP_AUTHRETRY + 1,
	IXP_DISCONNECTING	= IXP_AUTHORIZED + 1,
	IXP_DISCONNECTED	= IXP_DISCONNECTING + 1,
	IXP_SENDING	= IXP_DISCONNECTED + 1,
	IXP_SENT	= IXP_SENDING + 1,
	IXP_RECEIVING	= IXP_SENT + 1,
	IXP_RECEIVED	= IXP_RECEIVING + 1,
	IXP_COMPLETE	= IXP_RECEIVED + 1,
	IXP_LAST	= IXP_COMPLETE + 1
    }	IXPSTATUS;

#define	DEPTH_INFINITY	( 0xfffffffe )

typedef DWORD MEMBERINFOFLAGS;

#define	HTTP_MEMBERINFO_COMMONPROPS	( 0 )

#define	HTTP_MEMBERINFO_FOLDERPROPS	( 0x1 )

#define	HTTP_MEMBERINFO_MESSAGEPROPS	( 0x2 )

#define	HTTP_MEMBERINFO_ALLPROPS	( HTTP_MEMBERINFO_FOLDERPROPS | HTTP_MEMBERINFO_MESSAGEPROPS )

typedef DWORD IMAP_MSGFLAGS;

#define	IMAP_MSG_NOFLAGS	( 0 )

#define	IMAP_MSG_ANSWERED	( 0x1 )

#define	IMAP_MSG_FLAGGED	( 0x2 )

#define	IMAP_MSG_DELETED	( 0x4 )

#define	IMAP_MSG_SEEN	( 0x8 )

#define	IMAP_MSG_DRAFT	( 0x10 )

#define	IMAP_MSG_ALLFLAGS	( 0x1f )



extern RPC_IF_HANDLE __MIDL_itf_imnxport_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_imnxport_0000_v0_0_s_ifspec;

#ifndef __ITransportCallbackService_INTERFACE_DEFINED__
#define __ITransportCallbackService_INTERFACE_DEFINED__

/* interface ITransportCallbackService */
/* [object][local][uuid] */ 


EXTERN_C const IID IID_ITransportCallbackService;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CA30F3FF-C9AC-11d1-9A3A-00C04FA309D4")
    ITransportCallbackService : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetParentWindow( 
            /* [in] */ DWORD dwReserved,
            /* [out] */ HWND __RPC_FAR *phwndParent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAccount( 
            /* [out] */ LPDWORD pdwServerType,
            /* [out] */ IImnAccount __RPC_FAR *__RPC_FAR *ppAccount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITransportCallbackServiceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITransportCallbackService __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITransportCallbackService __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITransportCallbackService __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetParentWindow )( 
            ITransportCallbackService __RPC_FAR * This,
            /* [in] */ DWORD dwReserved,
            /* [out] */ HWND __RPC_FAR *phwndParent);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAccount )( 
            ITransportCallbackService __RPC_FAR * This,
            /* [out] */ LPDWORD pdwServerType,
            /* [out] */ IImnAccount __RPC_FAR *__RPC_FAR *ppAccount);
        
        END_INTERFACE
    } ITransportCallbackServiceVtbl;

    interface ITransportCallbackService
    {
        CONST_VTBL struct ITransportCallbackServiceVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITransportCallbackService_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITransportCallbackService_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITransportCallbackService_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITransportCallbackService_GetParentWindow(This,dwReserved,phwndParent)	\
    (This)->lpVtbl -> GetParentWindow(This,dwReserved,phwndParent)

#define ITransportCallbackService_GetAccount(This,pdwServerType,ppAccount)	\
    (This)->lpVtbl -> GetAccount(This,pdwServerType,ppAccount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITransportCallbackService_GetParentWindow_Proxy( 
    ITransportCallbackService __RPC_FAR * This,
    /* [in] */ DWORD dwReserved,
    /* [out] */ HWND __RPC_FAR *phwndParent);


void __RPC_STUB ITransportCallbackService_GetParentWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITransportCallbackService_GetAccount_Proxy( 
    ITransportCallbackService __RPC_FAR * This,
    /* [out] */ LPDWORD pdwServerType,
    /* [out] */ IImnAccount __RPC_FAR *__RPC_FAR *ppAccount);


void __RPC_STUB ITransportCallbackService_GetAccount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITransportCallbackService_INTERFACE_DEFINED__ */


#ifndef __ITransportCallback_INTERFACE_DEFINED__
#define __ITransportCallback_INTERFACE_DEFINED__

/* interface ITransportCallback */
/* [object][local][helpstring][uuid] */ 

typedef struct tagIXPRESULT
    {
    HRESULT hrResult;
    LPSTR pszResponse;
    UINT uiServerError;
    HRESULT hrServerError;
    DWORD dwSocketError;
    LPSTR pszProblem;
    }	IXPRESULT;

typedef struct tagIXPRESULT __RPC_FAR *LPIXPRESULT;

typedef 
enum tagCMDTYPE
    {	CMD_SEND	= 0,
	CMD_RESP	= CMD_SEND + 1
    }	CMDTYPE;


EXTERN_C const IID IID_ITransportCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0DF2C7E1-3435-11d0-81D0-00C04FD85AB4")
    ITransportCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnTimeout( 
            /* [out][in] */ DWORD __RPC_FAR *pdwTimeout,
            /* [in] */ IInternetTransport __RPC_FAR *pTransport) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnLogonPrompt( 
            /* [out][in] */ LPINETSERVER pInetServer,
            /* [in] */ IInternetTransport __RPC_FAR *pTransport) = 0;
        
        virtual INT STDMETHODCALLTYPE OnPrompt( 
            /* [in] */ HRESULT hrError,
            /* [in] */ LPCTSTR pszText,
            /* [in] */ LPCTSTR pszCaption,
            /* [in] */ UINT uType,
            /* [in] */ IInternetTransport __RPC_FAR *pTransport) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnStatus( 
            /* [in] */ IXPSTATUS ixpstatus,
            /* [in] */ IInternetTransport __RPC_FAR *pTransport) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnError( 
            /* [in] */ IXPSTATUS ixpstatus,
            /* [in] */ LPIXPRESULT pResult,
            /* [in] */ IInternetTransport __RPC_FAR *pTransport) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnCommand( 
            /* [in] */ CMDTYPE cmdtype,
            /* [in] */ LPSTR pszLine,
            /* [in] */ HRESULT hrResponse,
            /* [in] */ IInternetTransport __RPC_FAR *pTransport) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITransportCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITransportCallback __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITransportCallback __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITransportCallback __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnTimeout )( 
            ITransportCallback __RPC_FAR * This,
            /* [out][in] */ DWORD __RPC_FAR *pdwTimeout,
            /* [in] */ IInternetTransport __RPC_FAR *pTransport);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnLogonPrompt )( 
            ITransportCallback __RPC_FAR * This,
            /* [out][in] */ LPINETSERVER pInetServer,
            /* [in] */ IInternetTransport __RPC_FAR *pTransport);
        
        INT ( STDMETHODCALLTYPE __RPC_FAR *OnPrompt )( 
            ITransportCallback __RPC_FAR * This,
            /* [in] */ HRESULT hrError,
            /* [in] */ LPCTSTR pszText,
            /* [in] */ LPCTSTR pszCaption,
            /* [in] */ UINT uType,
            /* [in] */ IInternetTransport __RPC_FAR *pTransport);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnStatus )( 
            ITransportCallback __RPC_FAR * This,
            /* [in] */ IXPSTATUS ixpstatus,
            /* [in] */ IInternetTransport __RPC_FAR *pTransport);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnError )( 
            ITransportCallback __RPC_FAR * This,
            /* [in] */ IXPSTATUS ixpstatus,
            /* [in] */ LPIXPRESULT pResult,
            /* [in] */ IInternetTransport __RPC_FAR *pTransport);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnCommand )( 
            ITransportCallback __RPC_FAR * This,
            /* [in] */ CMDTYPE cmdtype,
            /* [in] */ LPSTR pszLine,
            /* [in] */ HRESULT hrResponse,
            /* [in] */ IInternetTransport __RPC_FAR *pTransport);
        
        END_INTERFACE
    } ITransportCallbackVtbl;

    interface ITransportCallback
    {
        CONST_VTBL struct ITransportCallbackVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITransportCallback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITransportCallback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITransportCallback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITransportCallback_OnTimeout(This,pdwTimeout,pTransport)	\
    (This)->lpVtbl -> OnTimeout(This,pdwTimeout,pTransport)

#define ITransportCallback_OnLogonPrompt(This,pInetServer,pTransport)	\
    (This)->lpVtbl -> OnLogonPrompt(This,pInetServer,pTransport)

#define ITransportCallback_OnPrompt(This,hrError,pszText,pszCaption,uType,pTransport)	\
    (This)->lpVtbl -> OnPrompt(This,hrError,pszText,pszCaption,uType,pTransport)

#define ITransportCallback_OnStatus(This,ixpstatus,pTransport)	\
    (This)->lpVtbl -> OnStatus(This,ixpstatus,pTransport)

#define ITransportCallback_OnError(This,ixpstatus,pResult,pTransport)	\
    (This)->lpVtbl -> OnError(This,ixpstatus,pResult,pTransport)

#define ITransportCallback_OnCommand(This,cmdtype,pszLine,hrResponse,pTransport)	\
    (This)->lpVtbl -> OnCommand(This,cmdtype,pszLine,hrResponse,pTransport)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITransportCallback_OnTimeout_Proxy( 
    ITransportCallback __RPC_FAR * This,
    /* [out][in] */ DWORD __RPC_FAR *pdwTimeout,
    /* [in] */ IInternetTransport __RPC_FAR *pTransport);


void __RPC_STUB ITransportCallback_OnTimeout_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITransportCallback_OnLogonPrompt_Proxy( 
    ITransportCallback __RPC_FAR * This,
    /* [out][in] */ LPINETSERVER pInetServer,
    /* [in] */ IInternetTransport __RPC_FAR *pTransport);


void __RPC_STUB ITransportCallback_OnLogonPrompt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


INT STDMETHODCALLTYPE ITransportCallback_OnPrompt_Proxy( 
    ITransportCallback __RPC_FAR * This,
    /* [in] */ HRESULT hrError,
    /* [in] */ LPCTSTR pszText,
    /* [in] */ LPCTSTR pszCaption,
    /* [in] */ UINT uType,
    /* [in] */ IInternetTransport __RPC_FAR *pTransport);


void __RPC_STUB ITransportCallback_OnPrompt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITransportCallback_OnStatus_Proxy( 
    ITransportCallback __RPC_FAR * This,
    /* [in] */ IXPSTATUS ixpstatus,
    /* [in] */ IInternetTransport __RPC_FAR *pTransport);


void __RPC_STUB ITransportCallback_OnStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITransportCallback_OnError_Proxy( 
    ITransportCallback __RPC_FAR * This,
    /* [in] */ IXPSTATUS ixpstatus,
    /* [in] */ LPIXPRESULT pResult,
    /* [in] */ IInternetTransport __RPC_FAR *pTransport);


void __RPC_STUB ITransportCallback_OnError_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITransportCallback_OnCommand_Proxy( 
    ITransportCallback __RPC_FAR * This,
    /* [in] */ CMDTYPE cmdtype,
    /* [in] */ LPSTR pszLine,
    /* [in] */ HRESULT hrResponse,
    /* [in] */ IInternetTransport __RPC_FAR *pTransport);


void __RPC_STUB ITransportCallback_OnCommand_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITransportCallback_INTERFACE_DEFINED__ */


#ifndef __IInternetTransport_INTERFACE_DEFINED__
#define __IInternetTransport_INTERFACE_DEFINED__

/* interface IInternetTransport */
/* [object][local][helpstring][uuid] */ 

#define	iitAUTHENTICATE	( TRUE )

#define	iitDONT_AUTHENTICATE	( FALSE )

#define	iitENABLE_ONCOMMAND	( TRUE )

#define	iitDISABLE_ONCOMMAND	( FALSE )

typedef 
enum tagIXPISSTATE
    {	IXP_IS_CONNECTED	= 0,
	IXP_IS_BUSY	= IXP_IS_CONNECTED + 1,
	IXP_IS_READY	= IXP_IS_BUSY + 1,
	IXP_IS_AUTHENTICATED	= IXP_IS_READY + 1
    }	IXPISSTATE;


EXTERN_C const IID IID_IInternetTransport;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1F636C01-364E-11d0-81D3-00C04FD85AB4")
    IInternetTransport : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetServerInfo( 
            /* [out][in] */ LPINETSERVER pInetServer) = 0;
        
        virtual IXPTYPE STDMETHODCALLTYPE GetIXPType( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsState( 
            /* [in] */ IXPISSTATE isstate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InetServerFromAccount( 
            /* [in] */ IImnAccount __RPC_FAR *pAccount,
            /* [out][in] */ LPINETSERVER pInetServer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Connect( 
            /* [in] */ LPINETSERVER pInetServer,
            /* [in] */ boolean fAuthenticate,
            /* [in] */ boolean fCommandLogging) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HandsOffCallback( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Disconnect( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DropConnection( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStatus( 
            /* [out] */ IXPSTATUS __RPC_FAR *pCurrentStatus) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInternetTransportVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IInternetTransport __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IInternetTransport __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IInternetTransport __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetServerInfo )( 
            IInternetTransport __RPC_FAR * This,
            /* [out][in] */ LPINETSERVER pInetServer);
        
        IXPTYPE ( STDMETHODCALLTYPE __RPC_FAR *GetIXPType )( 
            IInternetTransport __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsState )( 
            IInternetTransport __RPC_FAR * This,
            /* [in] */ IXPISSTATE isstate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InetServerFromAccount )( 
            IInternetTransport __RPC_FAR * This,
            /* [in] */ IImnAccount __RPC_FAR *pAccount,
            /* [out][in] */ LPINETSERVER pInetServer);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Connect )( 
            IInternetTransport __RPC_FAR * This,
            /* [in] */ LPINETSERVER pInetServer,
            /* [in] */ boolean fAuthenticate,
            /* [in] */ boolean fCommandLogging);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *HandsOffCallback )( 
            IInternetTransport __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Disconnect )( 
            IInternetTransport __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DropConnection )( 
            IInternetTransport __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStatus )( 
            IInternetTransport __RPC_FAR * This,
            /* [out] */ IXPSTATUS __RPC_FAR *pCurrentStatus);
        
        END_INTERFACE
    } IInternetTransportVtbl;

    interface IInternetTransport
    {
        CONST_VTBL struct IInternetTransportVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInternetTransport_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IInternetTransport_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IInternetTransport_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IInternetTransport_GetServerInfo(This,pInetServer)	\
    (This)->lpVtbl -> GetServerInfo(This,pInetServer)

#define IInternetTransport_GetIXPType(This)	\
    (This)->lpVtbl -> GetIXPType(This)

#define IInternetTransport_IsState(This,isstate)	\
    (This)->lpVtbl -> IsState(This,isstate)

#define IInternetTransport_InetServerFromAccount(This,pAccount,pInetServer)	\
    (This)->lpVtbl -> InetServerFromAccount(This,pAccount,pInetServer)

#define IInternetTransport_Connect(This,pInetServer,fAuthenticate,fCommandLogging)	\
    (This)->lpVtbl -> Connect(This,pInetServer,fAuthenticate,fCommandLogging)

#define IInternetTransport_HandsOffCallback(This)	\
    (This)->lpVtbl -> HandsOffCallback(This)

#define IInternetTransport_Disconnect(This)	\
    (This)->lpVtbl -> Disconnect(This)

#define IInternetTransport_DropConnection(This)	\
    (This)->lpVtbl -> DropConnection(This)

#define IInternetTransport_GetStatus(This,pCurrentStatus)	\
    (This)->lpVtbl -> GetStatus(This,pCurrentStatus)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IInternetTransport_GetServerInfo_Proxy( 
    IInternetTransport __RPC_FAR * This,
    /* [out][in] */ LPINETSERVER pInetServer);


void __RPC_STUB IInternetTransport_GetServerInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


IXPTYPE STDMETHODCALLTYPE IInternetTransport_GetIXPType_Proxy( 
    IInternetTransport __RPC_FAR * This);


void __RPC_STUB IInternetTransport_GetIXPType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInternetTransport_IsState_Proxy( 
    IInternetTransport __RPC_FAR * This,
    /* [in] */ IXPISSTATE isstate);


void __RPC_STUB IInternetTransport_IsState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInternetTransport_InetServerFromAccount_Proxy( 
    IInternetTransport __RPC_FAR * This,
    /* [in] */ IImnAccount __RPC_FAR *pAccount,
    /* [out][in] */ LPINETSERVER pInetServer);


void __RPC_STUB IInternetTransport_InetServerFromAccount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInternetTransport_Connect_Proxy( 
    IInternetTransport __RPC_FAR * This,
    /* [in] */ LPINETSERVER pInetServer,
    /* [in] */ boolean fAuthenticate,
    /* [in] */ boolean fCommandLogging);


void __RPC_STUB IInternetTransport_Connect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInternetTransport_HandsOffCallback_Proxy( 
    IInternetTransport __RPC_FAR * This);


void __RPC_STUB IInternetTransport_HandsOffCallback_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInternetTransport_Disconnect_Proxy( 
    IInternetTransport __RPC_FAR * This);


void __RPC_STUB IInternetTransport_Disconnect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInternetTransport_DropConnection_Proxy( 
    IInternetTransport __RPC_FAR * This);


void __RPC_STUB IInternetTransport_DropConnection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInternetTransport_GetStatus_Proxy( 
    IInternetTransport __RPC_FAR * This,
    /* [out] */ IXPSTATUS __RPC_FAR *pCurrentStatus);


void __RPC_STUB IInternetTransport_GetStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IInternetTransport_INTERFACE_DEFINED__ */


#ifndef __ISMTPCallback_INTERFACE_DEFINED__
#define __ISMTPCallback_INTERFACE_DEFINED__

/* interface ISMTPCallback */
/* [object][local][helpstring][uuid] */ 

typedef 
enum tagSMTPCOMMAND
    {	SMTP_NONE	= 0,
	SMTP_BANNER	= SMTP_NONE + 1,
	SMTP_CONNECTED	= SMTP_BANNER + 1,
	SMTP_SEND_MESSAGE	= SMTP_CONNECTED + 1,
	SMTP_AUTH	= SMTP_SEND_MESSAGE + 1,
	SMTP_EHLO	= SMTP_AUTH + 1,
	SMTP_HELO	= SMTP_EHLO + 1,
	SMTP_MAIL	= SMTP_HELO + 1,
	SMTP_RCPT	= SMTP_MAIL + 1,
	SMTP_RSET	= SMTP_RCPT + 1,
	SMTP_QUIT	= SMTP_RSET + 1,
	SMTP_DATA	= SMTP_QUIT + 1,
	SMTP_DOT	= SMTP_DATA + 1,
	SMTP_SEND_STREAM	= SMTP_DOT + 1,
	SMTP_CUSTOM	= SMTP_SEND_STREAM + 1
    }	SMTPCOMMAND;

typedef struct tagSMTPSTREAM
    {
    DWORD cbIncrement;
    DWORD cbCurrent;
    DWORD cbTotal;
    }	SMTPSTREAM;

typedef struct tagSMTPSTREAM __RPC_FAR *LPSMTPSTREAM;

typedef struct tagSMTPRESPONSE
    {
    SMTPCOMMAND command;
    BOOL fDone;
    IXPRESULT rIxpResult;
    ISMTPTransport __RPC_FAR *pTransport;
    /* [switch_is][switch_type] */ union 
        {
        /* [case()] */ SMTPSTREAM rStreamInfo;
        /* [default] */  /* Empty union arm */ 
        }	;
    }	SMTPRESPONSE;

typedef struct tagSMTPRESPONSE __RPC_FAR *LPSMTPRESPONSE;


EXTERN_C const IID IID_ISMTPCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1F636C02-364E-11d0-81D3-00C04FD85AB4")
    ISMTPCallback : public ITransportCallback
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnResponse( 
            /* [in] */ LPSMTPRESPONSE pResponse) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISMTPCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISMTPCallback __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISMTPCallback __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISMTPCallback __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnTimeout )( 
            ISMTPCallback __RPC_FAR * This,
            /* [out][in] */ DWORD __RPC_FAR *pdwTimeout,
            /* [in] */ IInternetTransport __RPC_FAR *pTransport);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnLogonPrompt )( 
            ISMTPCallback __RPC_FAR * This,
            /* [out][in] */ LPINETSERVER pInetServer,
            /* [in] */ IInternetTransport __RPC_FAR *pTransport);
        
        INT ( STDMETHODCALLTYPE __RPC_FAR *OnPrompt )( 
            ISMTPCallback __RPC_FAR * This,
            /* [in] */ HRESULT hrError,
            /* [in] */ LPCTSTR pszText,
            /* [in] */ LPCTSTR pszCaption,
            /* [in] */ UINT uType,
            /* [in] */ IInternetTransport __RPC_FAR *pTransport);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnStatus )( 
            ISMTPCallback __RPC_FAR * This,
            /* [in] */ IXPSTATUS ixpstatus,
            /* [in] */ IInternetTransport __RPC_FAR *pTransport);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnError )( 
            ISMTPCallback __RPC_FAR * This,
            /* [in] */ IXPSTATUS ixpstatus,
            /* [in] */ LPIXPRESULT pResult,
            /* [in] */ IInternetTransport __RPC_FAR *pTransport);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnCommand )( 
            ISMTPCallback __RPC_FAR * This,
            /* [in] */ CMDTYPE cmdtype,
            /* [in] */ LPSTR pszLine,
            /* [in] */ HRESULT hrResponse,
            /* [in] */ IInternetTransport __RPC_FAR *pTransport);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnResponse )( 
            ISMTPCallback __RPC_FAR * This,
            /* [in] */ LPSMTPRESPONSE pResponse);
        
        END_INTERFACE
    } ISMTPCallbackVtbl;

    interface ISMTPCallback
    {
        CONST_VTBL struct ISMTPCallbackVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISMTPCallback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISMTPCallback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISMTPCallback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISMTPCallback_OnTimeout(This,pdwTimeout,pTransport)	\
    (This)->lpVtbl -> OnTimeout(This,pdwTimeout,pTransport)

#define ISMTPCallback_OnLogonPrompt(This,pInetServer,pTransport)	\
    (This)->lpVtbl -> OnLogonPrompt(This,pInetServer,pTransport)

#define ISMTPCallback_OnPrompt(This,hrError,pszText,pszCaption,uType,pTransport)	\
    (This)->lpVtbl -> OnPrompt(This,hrError,pszText,pszCaption,uType,pTransport)

#define ISMTPCallback_OnStatus(This,ixpstatus,pTransport)	\
    (This)->lpVtbl -> OnStatus(This,ixpstatus,pTransport)

#define ISMTPCallback_OnError(This,ixpstatus,pResult,pTransport)	\
    (This)->lpVtbl -> OnError(This,ixpstatus,pResult,pTransport)

#define ISMTPCallback_OnCommand(This,cmdtype,pszLine,hrResponse,pTransport)	\
    (This)->lpVtbl -> OnCommand(This,cmdtype,pszLine,hrResponse,pTransport)


#define ISMTPCallback_OnResponse(This,pResponse)	\
    (This)->lpVtbl -> OnResponse(This,pResponse)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISMTPCallback_OnResponse_Proxy( 
    ISMTPCallback __RPC_FAR * This,
    /* [in] */ LPSMTPRESPONSE pResponse);


void __RPC_STUB ISMTPCallback_OnResponse_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISMTPCallback_INTERFACE_DEFINED__ */


#ifndef __ISMTPTransport_INTERFACE_DEFINED__
#define __ISMTPTransport_INTERFACE_DEFINED__

/* interface ISMTPTransport */
/* [object][local][helpstring][uuid] */ 

typedef struct tagSMTPMESSAGE
    {
    ULONG cbSize;
    LPSTREAM pstmMsg;
    INETADDRLIST rAddressList;
    }	SMTPMESSAGE;

typedef struct tagSMTPMESSAGE __RPC_FAR *LPSMTPMESSAGE;


EXTERN_C const IID IID_ISMTPTransport;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0DF2C7E2-3435-11d0-81D0-00C04FD85AB4")
    ISMTPTransport : public IInternetTransport
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InitNew( 
            /* [in] */ LPSTR pszLogFilePath,
            /* [in] */ ISMTPCallback __RPC_FAR *pCallback) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SendMessage( 
            /* [in] */ LPSMTPMESSAGE pMessage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CommandMAIL( 
            /* [in] */ LPSTR pszEmailFrom) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CommandRCPT( 
            /* [in] */ LPSTR pszEmailTo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CommandEHLO( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CommandHELO( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CommandAUTH( 
            /* [in] */ LPSTR pszAuthType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CommandQUIT( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CommandRSET( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CommandDATA( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CommandDOT( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SendDataStream( 
            /* [in] */ IStream __RPC_FAR *pStream,
            /* [in] */ ULONG cbSize) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISMTPTransportVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISMTPTransport __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISMTPTransport __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISMTPTransport __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetServerInfo )( 
            ISMTPTransport __RPC_FAR * This,
            /* [out][in] */ LPINETSERVER pInetServer);
        
        IXPTYPE ( STDMETHODCALLTYPE __RPC_FAR *GetIXPType )( 
            ISMTPTransport __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsState )( 
            ISMTPTransport __RPC_FAR * This,
            /* [in] */ IXPISSTATE isstate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InetServerFromAccount )( 
            ISMTPTransport __RPC_FAR * This,
            /* [in] */ IImnAccount __RPC_FAR *pAccount,
            /* [out][in] */ LPINETSERVER pInetServer);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Connect )( 
            ISMTPTransport __RPC_FAR * This,
            /* [in] */ LPINETSERVER pInetServer,
            /* [in] */ boolean fAuthenticate,
            /* [in] */ boolean fCommandLogging);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *HandsOffCallback )( 
            ISMTPTransport __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Disconnect )( 
            ISMTPTransport __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DropConnection )( 
            ISMTPTransport __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStatus )( 
            ISMTPTransport __RPC_FAR * This,
            /* [out] */ IXPSTATUS __RPC_FAR *pCurrentStatus);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InitNew )( 
            ISMTPTransport __RPC_FAR * This,
            /* [in] */ LPSTR pszLogFilePath,
            /* [in] */ ISMTPCallback __RPC_FAR *pCallback);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SendMessage )( 
            ISMTPTransport __RPC_FAR * This,
            /* [in] */ LPSMTPMESSAGE pMessage);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CommandMAIL )( 
            ISMTPTransport __RPC_FAR * This,
            /* [in] */ LPSTR pszEmailFrom);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CommandRCPT )( 
            ISMTPTransport __RPC_FAR * This,
            /* [in] */ LPSTR pszEmailTo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CommandEHLO )( 
            ISMTPTransport __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CommandHELO )( 
            ISMTPTransport __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CommandAUTH )( 
            ISMTPTransport __RPC_FAR * This,
            /* [in] */ LPSTR pszAuthType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CommandQUIT )( 
            ISMTPTransport __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CommandRSET )( 
            ISMTPTransport __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CommandDATA )( 
            ISMTPTransport __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CommandDOT )( 
            ISMTPTransport __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SendDataStream )( 
            ISMTPTransport __RPC_FAR * This,
            /* [in] */ IStream __RPC_FAR *pStream,
            /* [in] */ ULONG cbSize);
        
        END_INTERFACE
    } ISMTPTransportVtbl;

    interface ISMTPTransport
    {
        CONST_VTBL struct ISMTPTransportVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISMTPTransport_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISMTPTransport_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISMTPTransport_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISMTPTransport_GetServerInfo(This,pInetServer)	\
    (This)->lpVtbl -> GetServerInfo(This,pInetServer)

#define ISMTPTransport_GetIXPType(This)	\
    (This)->lpVtbl -> GetIXPType(This)

#define ISMTPTransport_IsState(This,isstate)	\
    (This)->lpVtbl -> IsState(This,isstate)

#define ISMTPTransport_InetServerFromAccount(This,pAccount,pInetServer)	\
    (This)->lpVtbl -> InetServerFromAccount(This,pAccount,pInetServer)

#define ISMTPTransport_Connect(This,pInetServer,fAuthenticate,fCommandLogging)	\
    (This)->lpVtbl -> Connect(This,pInetServer,fAuthenticate,fCommandLogging)

#define ISMTPTransport_HandsOffCallback(This)	\
    (This)->lpVtbl -> HandsOffCallback(This)

#define ISMTPTransport_Disconnect(This)	\
    (This)->lpVtbl -> Disconnect(This)

#define ISMTPTransport_DropConnection(This)	\
    (This)->lpVtbl -> DropConnection(This)

#define ISMTPTransport_GetStatus(This,pCurrentStatus)	\
    (This)->lpVtbl -> GetStatus(This,pCurrentStatus)


#define ISMTPTransport_InitNew(This,pszLogFilePath,pCallback)	\
    (This)->lpVtbl -> InitNew(This,pszLogFilePath,pCallback)

#define ISMTPTransport_SendMessage(This,pMessage)	\
    (This)->lpVtbl -> SendMessage(This,pMessage)

#define ISMTPTransport_CommandMAIL(This,pszEmailFrom)	\
    (This)->lpVtbl -> CommandMAIL(This,pszEmailFrom)

#define ISMTPTransport_CommandRCPT(This,pszEmailTo)	\
    (This)->lpVtbl -> CommandRCPT(This,pszEmailTo)

#define ISMTPTransport_CommandEHLO(This)	\
    (This)->lpVtbl -> CommandEHLO(This)

#define ISMTPTransport_CommandHELO(This)	\
    (This)->lpVtbl -> CommandHELO(This)

#define ISMTPTransport_CommandAUTH(This,pszAuthType)	\
    (This)->lpVtbl -> CommandAUTH(This,pszAuthType)

#define ISMTPTransport_CommandQUIT(This)	\
    (This)->lpVtbl -> CommandQUIT(This)

#define ISMTPTransport_CommandRSET(This)	\
    (This)->lpVtbl -> CommandRSET(This)

#define ISMTPTransport_CommandDATA(This)	\
    (This)->lpVtbl -> CommandDATA(This)

#define ISMTPTransport_CommandDOT(This)	\
    (This)->lpVtbl -> CommandDOT(This)

#define ISMTPTransport_SendDataStream(This,pStream,cbSize)	\
    (This)->lpVtbl -> SendDataStream(This,pStream,cbSize)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISMTPTransport_InitNew_Proxy( 
    ISMTPTransport __RPC_FAR * This,
    /* [in] */ LPSTR pszLogFilePath,
    /* [in] */ ISMTPCallback __RPC_FAR *pCallback);


void __RPC_STUB ISMTPTransport_InitNew_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISMTPTransport_SendMessage_Proxy( 
    ISMTPTransport __RPC_FAR * This,
    /* [in] */ LPSMTPMESSAGE pMessage);


void __RPC_STUB ISMTPTransport_SendMessage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISMTPTransport_CommandMAIL_Proxy( 
    ISMTPTransport __RPC_FAR * This,
    /* [in] */ LPSTR pszEmailFrom);


void __RPC_STUB ISMTPTransport_CommandMAIL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISMTPTransport_CommandRCPT_Proxy( 
    ISMTPTransport __RPC_FAR * This,
    /* [in] */ LPSTR pszEmailTo);


void __RPC_STUB ISMTPTransport_CommandRCPT_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISMTPTransport_CommandEHLO_Proxy( 
    ISMTPTransport __RPC_FAR * This);


void __RPC_STUB ISMTPTransport_CommandEHLO_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISMTPTransport_CommandHELO_Proxy( 
    ISMTPTransport __RPC_FAR * This);


void __RPC_STUB ISMTPTransport_CommandHELO_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISMTPTransport_CommandAUTH_Proxy( 
    ISMTPTransport __RPC_FAR * This,
    /* [in] */ LPSTR pszAuthType);


void __RPC_STUB ISMTPTransport_CommandAUTH_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISMTPTransport_CommandQUIT_Proxy( 
    ISMTPTransport __RPC_FAR * This);


void __RPC_STUB ISMTPTransport_CommandQUIT_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISMTPTransport_CommandRSET_Proxy( 
    ISMTPTransport __RPC_FAR * This);


void __RPC_STUB ISMTPTransport_CommandRSET_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISMTPTransport_CommandDATA_Proxy( 
    ISMTPTransport __RPC_FAR * This);


void __RPC_STUB ISMTPTransport_CommandDATA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISMTPTransport_CommandDOT_Proxy( 
    ISMTPTransport __RPC_FAR * This);


void __RPC_STUB ISMTPTransport_CommandDOT_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISMTPTransport_SendDataStream_Proxy( 
    ISMTPTransport __RPC_FAR * This,
    /* [in] */ IStream __RPC_FAR *pStream,
    /* [in] */ ULONG cbSize);


void __RPC_STUB ISMTPTransport_SendDataStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISMTPTransport_INTERFACE_DEFINED__ */


#ifndef __ISMTPTransport2_INTERFACE_DEFINED__
#define __ISMTPTransport2_INTERFACE_DEFINED__

/* interface ISMTPTransport2 */
/* [object][local][helpstring][uuid] */ 

typedef struct tagSMTPMESSAGE2
    {
    SMTPMESSAGE smtpMsg;
    LPSTR pszDSNENVID;
    DSNRET dsnRet;
    DWORD dwReserved;
    DWORD dwReserved2;
    }	SMTPMESSAGE2;

typedef struct tagSMTPMESSAGE2 __RPC_FAR *LPSMTPMESSAGE2;


EXTERN_C const IID IID_ISMTPTransport2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0DF2C7EC-3435-11d0-81D0-00C04FD85AB4")
    ISMTPTransport2 : public ISMTPTransport
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetWindow( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ResetWindow( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SendMessage2( 
            /* [in] */ LPSMTPMESSAGE2 pMessage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CommandRCPT2( 
            /* [in] */ LPSTR pszEmailTo,
            /* [in] */ INETADDRTYPE atDSN) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISMTPTransport2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISMTPTransport2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISMTPTransport2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISMTPTransport2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetServerInfo )( 
            ISMTPTransport2 __RPC_FAR * This,
            /* [out][in] */ LPINETSERVER pInetServer);
        
        IXPTYPE ( STDMETHODCALLTYPE __RPC_FAR *GetIXPType )( 
            ISMTPTransport2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsState )( 
            ISMTPTransport2 __RPC_FAR * This,
            /* [in] */ IXPISSTATE isstate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InetServerFromAccount )( 
            ISMTPTransport2 __RPC_FAR * This,
            /* [in] */ IImnAccount __RPC_FAR *pAccount,
            /* [out][in] */ LPINETSERVER pInetServer);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Connect )( 
            ISMTPTransport2 __RPC_FAR * This,
            /* [in] */ LPINETSERVER pInetServer,
            /* [in] */ boolean fAuthenticate,
            /* [in] */ boolean fCommandLogging);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *HandsOffCallback )( 
            ISMTPTransport2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Disconnect )( 
            ISMTPTransport2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DropConnection )( 
            ISMTPTransport2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStatus )( 
            ISMTPTransport2 __RPC_FAR * This,
            /* [out] */ IXPSTATUS __RPC_FAR *pCurrentStatus);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InitNew )( 
            ISMTPTransport2 __RPC_FAR * This,
            /* [in] */ LPSTR pszLogFilePath,
            /* [in] */ ISMTPCallback __RPC_FAR *pCallback);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SendMessage )( 
            ISMTPTransport2 __RPC_FAR * This,
            /* [in] */ LPSMTPMESSAGE pMessage);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CommandMAIL )( 
            ISMTPTransport2 __RPC_FAR * This,
            /* [in] */ LPSTR pszEmailFrom);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CommandRCPT )( 
            ISMTPTransport2 __RPC_FAR * This,
            /* [in] */ LPSTR pszEmailTo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CommandEHLO )( 
            ISMTPTransport2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CommandHELO )( 
            ISMTPTransport2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CommandAUTH )( 
            ISMTPTransport2 __RPC_FAR * This,
            /* [in] */ LPSTR pszAuthType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CommandQUIT )( 
            ISMTPTransport2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CommandRSET )( 
            ISMTPTransport2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CommandDATA )( 
            ISMTPTransport2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CommandDOT )( 
            ISMTPTransport2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SendDataStream )( 
            ISMTPTransport2 __RPC_FAR * This,
            /* [in] */ IStream __RPC_FAR *pStream,
            /* [in] */ ULONG cbSize);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetWindow )( 
            ISMTPTransport2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ResetWindow )( 
            ISMTPTransport2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SendMessage2 )( 
            ISMTPTransport2 __RPC_FAR * This,
            /* [in] */ LPSMTPMESSAGE2 pMessage);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CommandRCPT2 )( 
            ISMTPTransport2 __RPC_FAR * This,
            /* [in] */ LPSTR pszEmailTo,
            /* [in] */ INETADDRTYPE atDSN);
        
        END_INTERFACE
    } ISMTPTransport2Vtbl;

    interface ISMTPTransport2
    {
        CONST_VTBL struct ISMTPTransport2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISMTPTransport2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISMTPTransport2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISMTPTransport2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISMTPTransport2_GetServerInfo(This,pInetServer)	\
    (This)->lpVtbl -> GetServerInfo(This,pInetServer)

#define ISMTPTransport2_GetIXPType(This)	\
    (This)->lpVtbl -> GetIXPType(This)

#define ISMTPTransport2_IsState(This,isstate)	\
    (This)->lpVtbl -> IsState(This,isstate)

#define ISMTPTransport2_InetServerFromAccount(This,pAccount,pInetServer)	\
    (This)->lpVtbl -> InetServerFromAccount(This,pAccount,pInetServer)

#define ISMTPTransport2_Connect(This,pInetServer,fAuthenticate,fCommandLogging)	\
    (This)->lpVtbl -> Connect(This,pInetServer,fAuthenticate,fCommandLogging)

#define ISMTPTransport2_HandsOffCallback(This)	\
    (This)->lpVtbl -> HandsOffCallback(This)

#define ISMTPTransport2_Disconnect(This)	\
    (This)->lpVtbl -> Disconnect(This)

#define ISMTPTransport2_DropConnection(This)	\
    (This)->lpVtbl -> DropConnection(This)

#define ISMTPTransport2_GetStatus(This,pCurrentStatus)	\
    (This)->lpVtbl -> GetStatus(This,pCurrentStatus)


#define ISMTPTransport2_InitNew(This,pszLogFilePath,pCallback)	\
    (This)->lpVtbl -> InitNew(This,pszLogFilePath,pCallback)

#define ISMTPTransport2_SendMessage(This,pMessage)	\
    (This)->lpVtbl -> SendMessage(This,pMessage)

#define ISMTPTransport2_CommandMAIL(This,pszEmailFrom)	\
    (This)->lpVtbl -> CommandMAIL(This,pszEmailFrom)

#define ISMTPTransport2_CommandRCPT(This,pszEmailTo)	\
    (This)->lpVtbl -> CommandRCPT(This,pszEmailTo)

#define ISMTPTransport2_CommandEHLO(This)	\
    (This)->lpVtbl -> CommandEHLO(This)

#define ISMTPTransport2_CommandHELO(This)	\
    (This)->lpVtbl -> CommandHELO(This)

#define ISMTPTransport2_CommandAUTH(This,pszAuthType)	\
    (This)->lpVtbl -> CommandAUTH(This,pszAuthType)

#define ISMTPTransport2_CommandQUIT(This)	\
    (This)->lpVtbl -> CommandQUIT(This)

#define ISMTPTransport2_CommandRSET(This)	\
    (This)->lpVtbl -> CommandRSET(This)

#define ISMTPTransport2_CommandDATA(This)	\
    (This)->lpVtbl -> CommandDATA(This)

#define ISMTPTransport2_CommandDOT(This)	\
    (This)->lpVtbl -> CommandDOT(This)

#define ISMTPTransport2_SendDataStream(This,pStream,cbSize)	\
    (This)->lpVtbl -> SendDataStream(This,pStream,cbSize)


#define ISMTPTransport2_SetWindow(This)	\
    (This)->lpVtbl -> SetWindow(This)

#define ISMTPTransport2_ResetWindow(This)	\
    (This)->lpVtbl -> ResetWindow(This)

#define ISMTPTransport2_SendMessage2(This,pMessage)	\
    (This)->lpVtbl -> SendMessage2(This,pMessage)

#define ISMTPTransport2_CommandRCPT2(This,pszEmailTo,atDSN)	\
    (This)->lpVtbl -> CommandRCPT2(This,pszEmailTo,atDSN)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISMTPTransport2_SetWindow_Proxy( 
    ISMTPTransport2 __RPC_FAR * This);


void __RPC_STUB ISMTPTransport2_SetWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISMTPTransport2_ResetWindow_Proxy( 
    ISMTPTransport2 __RPC_FAR * This);


void __RPC_STUB ISMTPTransport2_ResetWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISMTPTransport2_SendMessage2_Proxy( 
    ISMTPTransport2 __RPC_FAR * This,
    /* [in] */ LPSMTPMESSAGE2 pMessage);


void __RPC_STUB ISMTPTransport2_SendMessage2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISMTPTransport2_CommandRCPT2_Proxy( 
    ISMTPTransport2 __RPC_FAR * This,
    /* [in] */ LPSTR pszEmailTo,
    /* [in] */ INETADDRTYPE atDSN);


void __RPC_STUB ISMTPTransport2_CommandRCPT2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISMTPTransport2_INTERFACE_DEFINED__ */


#ifndef __IDAVNamespaceArbiter_INTERFACE_DEFINED__
#define __IDAVNamespaceArbiter_INTERFACE_DEFINED__

/* interface IDAVNamespaceArbiter */
/* [object][local][helpstring][uuid] */ 


EXTERN_C const IID IID_IDAVNamespaceArbiter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("72A58FF8-227D-11d2-A8B5-0000F8084F96")
    IDAVNamespaceArbiter : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddNamespace( 
            /* [in] */ LPCSTR pszNamespace,
            /* [out] */ DWORD __RPC_FAR *pdwNamespaceID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNamespaceID( 
            /* [in] */ LPCSTR pszNamespace,
            /* [out] */ DWORD __RPC_FAR *pdwNamespaceID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNamespacePrefix( 
            /* [in] */ DWORD dwNamespaceID,
            /* [out] */ LPSTR __RPC_FAR *ppszNamespacePrefix) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDAVNamespaceArbiterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDAVNamespaceArbiter __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDAVNamespaceArbiter __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDAVNamespaceArbiter __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddNamespace )( 
            IDAVNamespaceArbiter __RPC_FAR * This,
            /* [in] */ LPCSTR pszNamespace,
            /* [out] */ DWORD __RPC_FAR *pdwNamespaceID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNamespaceID )( 
            IDAVNamespaceArbiter __RPC_FAR * This,
            /* [in] */ LPCSTR pszNamespace,
            /* [out] */ DWORD __RPC_FAR *pdwNamespaceID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNamespacePrefix )( 
            IDAVNamespaceArbiter __RPC_FAR * This,
            /* [in] */ DWORD dwNamespaceID,
            /* [out] */ LPSTR __RPC_FAR *ppszNamespacePrefix);
        
        END_INTERFACE
    } IDAVNamespaceArbiterVtbl;

    interface IDAVNamespaceArbiter
    {
        CONST_VTBL struct IDAVNamespaceArbiterVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDAVNamespaceArbiter_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDAVNamespaceArbiter_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDAVNamespaceArbiter_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDAVNamespaceArbiter_AddNamespace(This,pszNamespace,pdwNamespaceID)	\
    (This)->lpVtbl -> AddNamespace(This,pszNamespace,pdwNamespaceID)

#define IDAVNamespaceArbiter_GetNamespaceID(This,pszNamespace,pdwNamespaceID)	\
    (This)->lpVtbl -> GetNamespaceID(This,pszNamespace,pdwNamespaceID)

#define IDAVNamespaceArbiter_GetNamespacePrefix(This,dwNamespaceID,ppszNamespacePrefix)	\
    (This)->lpVtbl -> GetNamespacePrefix(This,dwNamespaceID,ppszNamespacePrefix)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDAVNamespaceArbiter_AddNamespace_Proxy( 
    IDAVNamespaceArbiter __RPC_FAR * This,
    /* [in] */ LPCSTR pszNamespace,
    /* [out] */ DWORD __RPC_FAR *pdwNamespaceID);


void __RPC_STUB IDAVNamespaceArbiter_AddNamespace_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDAVNamespaceArbiter_GetNamespaceID_Proxy( 
    IDAVNamespaceArbiter __RPC_FAR * This,
    /* [in] */ LPCSTR pszNamespace,
    /* [out] */ DWORD __RPC_FAR *pdwNamespaceID);


void __RPC_STUB IDAVNamespaceArbiter_GetNamespaceID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDAVNamespaceArbiter_GetNamespacePrefix_Proxy( 
    IDAVNamespaceArbiter __RPC_FAR * This,
    /* [in] */ DWORD dwNamespaceID,
    /* [out] */ LPSTR __RPC_FAR *ppszNamespacePrefix);


void __RPC_STUB IDAVNamespaceArbiter_GetNamespacePrefix_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDAVNamespaceArbiter_INTERFACE_DEFINED__ */


#ifndef __IPropPatchRequest_INTERFACE_DEFINED__
#define __IPropPatchRequest_INTERFACE_DEFINED__

/* interface IPropPatchRequest */
/* [object][local][helpstring][uuid] */ 


EXTERN_C const IID IID_IPropPatchRequest;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AB8B8D2A-227F-11d2-A8B5-0000F8084F96")
    IPropPatchRequest : public IDAVNamespaceArbiter
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetProperty( 
            /* [in] */ DWORD dwNamespaceID,
            /* [in] */ LPCSTR pszPropertyName,
            /* [in] */ LPCSTR pszNewValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveProperty( 
            /* [in] */ DWORD dwNamespaceID,
            /* [in] */ LPCSTR pszPropertyName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GenerateXML( 
            /* [out] */ LPSTR __RPC_FAR *pszXML) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPropPatchRequestVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IPropPatchRequest __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IPropPatchRequest __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IPropPatchRequest __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddNamespace )( 
            IPropPatchRequest __RPC_FAR * This,
            /* [in] */ LPCSTR pszNamespace,
            /* [out] */ DWORD __RPC_FAR *pdwNamespaceID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNamespaceID )( 
            IPropPatchRequest __RPC_FAR * This,
            /* [in] */ LPCSTR pszNamespace,
            /* [out] */ DWORD __RPC_FAR *pdwNamespaceID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNamespacePrefix )( 
            IPropPatchRequest __RPC_FAR * This,
            /* [in] */ DWORD dwNamespaceID,
            /* [out] */ LPSTR __RPC_FAR *ppszNamespacePrefix);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetProperty )( 
            IPropPatchRequest __RPC_FAR * This,
            /* [in] */ DWORD dwNamespaceID,
            /* [in] */ LPCSTR pszPropertyName,
            /* [in] */ LPCSTR pszNewValue);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveProperty )( 
            IPropPatchRequest __RPC_FAR * This,
            /* [in] */ DWORD dwNamespaceID,
            /* [in] */ LPCSTR pszPropertyName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GenerateXML )( 
            IPropPatchRequest __RPC_FAR * This,
            /* [out] */ LPSTR __RPC_FAR *pszXML);
        
        END_INTERFACE
    } IPropPatchRequestVtbl;

    interface IPropPatchRequest
    {
        CONST_VTBL struct IPropPatchRequestVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPropPatchRequest_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPropPatchRequest_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPropPatchRequest_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPropPatchRequest_AddNamespace(This,pszNamespace,pdwNamespaceID)	\
    (This)->lpVtbl -> AddNamespace(This,pszNamespace,pdwNamespaceID)

#define IPropPatchRequest_GetNamespaceID(This,pszNamespace,pdwNamespaceID)	\
    (This)->lpVtbl -> GetNamespaceID(This,pszNamespace,pdwNamespaceID)

#define IPropPatchRequest_GetNamespacePrefix(This,dwNamespaceID,ppszNamespacePrefix)	\
    (This)->lpVtbl -> GetNamespacePrefix(This,dwNamespaceID,ppszNamespacePrefix)


#define IPropPatchRequest_SetProperty(This,dwNamespaceID,pszPropertyName,pszNewValue)	\
    (This)->lpVtbl -> SetProperty(This,dwNamespaceID,pszPropertyName,pszNewValue)

#define IPropPatchRequest_RemoveProperty(This,dwNamespaceID,pszPropertyName)	\
    (This)->lpVtbl -> RemoveProperty(This,dwNamespaceID,pszPropertyName)

#define IPropPatchRequest_GenerateXML(This,pszXML)	\
    (This)->lpVtbl -> GenerateXML(This,pszXML)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IPropPatchRequest_SetProperty_Proxy( 
    IPropPatchRequest __RPC_FAR * This,
    /* [in] */ DWORD dwNamespaceID,
    /* [in] */ LPCSTR pszPropertyName,
    /* [in] */ LPCSTR pszNewValue);


void __RPC_STUB IPropPatchRequest_SetProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPropPatchRequest_RemoveProperty_Proxy( 
    IPropPatchRequest __RPC_FAR * This,
    /* [in] */ DWORD dwNamespaceID,
    /* [in] */ LPCSTR pszPropertyName);


void __RPC_STUB IPropPatchRequest_RemoveProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPropPatchRequest_GenerateXML_Proxy( 
    IPropPatchRequest __RPC_FAR * This,
    /* [out] */ LPSTR __RPC_FAR *pszXML);


void __RPC_STUB IPropPatchRequest_GenerateXML_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPropPatchRequest_INTERFACE_DEFINED__ */


#ifndef __IPropFindRequest_INTERFACE_DEFINED__
#define __IPropFindRequest_INTERFACE_DEFINED__

/* interface IPropFindRequest */
/* [object][local][helpstring][uuid] */ 


EXTERN_C const IID IID_IPropFindRequest;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5CFC6308-0544-11d2-A894-0000F8084F96")
    IPropFindRequest : public IDAVNamespaceArbiter
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddProperty( 
            /* [in] */ DWORD dwNamespaceID,
            /* [in] */ LPCSTR pszPropertyName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GenerateXML( 
            /* [out] */ LPSTR __RPC_FAR *pszXML) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPropFindRequestVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IPropFindRequest __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IPropFindRequest __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IPropFindRequest __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddNamespace )( 
            IPropFindRequest __RPC_FAR * This,
            /* [in] */ LPCSTR pszNamespace,
            /* [out] */ DWORD __RPC_FAR *pdwNamespaceID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNamespaceID )( 
            IPropFindRequest __RPC_FAR * This,
            /* [in] */ LPCSTR pszNamespace,
            /* [out] */ DWORD __RPC_FAR *pdwNamespaceID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNamespacePrefix )( 
            IPropFindRequest __RPC_FAR * This,
            /* [in] */ DWORD dwNamespaceID,
            /* [out] */ LPSTR __RPC_FAR *ppszNamespacePrefix);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddProperty )( 
            IPropFindRequest __RPC_FAR * This,
            /* [in] */ DWORD dwNamespaceID,
            /* [in] */ LPCSTR pszPropertyName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GenerateXML )( 
            IPropFindRequest __RPC_FAR * This,
            /* [out] */ LPSTR __RPC_FAR *pszXML);
        
        END_INTERFACE
    } IPropFindRequestVtbl;

    interface IPropFindRequest
    {
        CONST_VTBL struct IPropFindRequestVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPropFindRequest_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPropFindRequest_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPropFindRequest_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPropFindRequest_AddNamespace(This,pszNamespace,pdwNamespaceID)	\
    (This)->lpVtbl -> AddNamespace(This,pszNamespace,pdwNamespaceID)

#define IPropFindRequest_GetNamespaceID(This,pszNamespace,pdwNamespaceID)	\
    (This)->lpVtbl -> GetNamespaceID(This,pszNamespace,pdwNamespaceID)

#define IPropFindRequest_GetNamespacePrefix(This,dwNamespaceID,ppszNamespacePrefix)	\
    (This)->lpVtbl -> GetNamespacePrefix(This,dwNamespaceID,ppszNamespacePrefix)


#define IPropFindRequest_AddProperty(This,dwNamespaceID,pszPropertyName)	\
    (This)->lpVtbl -> AddProperty(This,dwNamespaceID,pszPropertyName)

#define IPropFindRequest_GenerateXML(This,pszXML)	\
    (This)->lpVtbl -> GenerateXML(This,pszXML)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IPropFindRequest_AddProperty_Proxy( 
    IPropFindRequest __RPC_FAR * This,
    /* [in] */ DWORD dwNamespaceID,
    /* [in] */ LPCSTR pszPropertyName);


void __RPC_STUB IPropFindRequest_AddProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPropFindRequest_GenerateXML_Proxy( 
    IPropFindRequest __RPC_FAR * This,
    /* [out] */ LPSTR __RPC_FAR *pszXML);


void __RPC_STUB IPropFindRequest_GenerateXML_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPropFindRequest_INTERFACE_DEFINED__ */


#ifndef __IPropFindMultiResponse_INTERFACE_DEFINED__
#define __IPropFindMultiResponse_INTERFACE_DEFINED__

/* interface IPropFindMultiResponse */
/* [object][local][helpstring][uuid] */ 


EXTERN_C const IID IID_IPropFindMultiResponse;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0DEE87DE-0547-11d2-A894-0000F8084F96")
    IPropFindMultiResponse : public IUnknown
    {
    public:
        virtual BOOL STDMETHODCALLTYPE IsComplete( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLength( 
            /* [out] */ ULONG __RPC_FAR *pulLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetResponse( 
            /* [in] */ ULONG ulIndex,
            /* [out] */ IPropFindResponse __RPC_FAR *__RPC_FAR *ppResponse) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPropFindMultiResponseVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IPropFindMultiResponse __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IPropFindMultiResponse __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IPropFindMultiResponse __RPC_FAR * This);
        
        BOOL ( STDMETHODCALLTYPE __RPC_FAR *IsComplete )( 
            IPropFindMultiResponse __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLength )( 
            IPropFindMultiResponse __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pulLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetResponse )( 
            IPropFindMultiResponse __RPC_FAR * This,
            /* [in] */ ULONG ulIndex,
            /* [out] */ IPropFindResponse __RPC_FAR *__RPC_FAR *ppResponse);
        
        END_INTERFACE
    } IPropFindMultiResponseVtbl;

    interface IPropFindMultiResponse
    {
        CONST_VTBL struct IPropFindMultiResponseVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPropFindMultiResponse_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPropFindMultiResponse_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPropFindMultiResponse_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPropFindMultiResponse_IsComplete(This)	\
    (This)->lpVtbl -> IsComplete(This)

#define IPropFindMultiResponse_GetLength(This,pulLength)	\
    (This)->lpVtbl -> GetLength(This,pulLength)

#define IPropFindMultiResponse_GetResponse(This,ulIndex,ppResponse)	\
    (This)->lpVtbl -> GetResponse(This,ulIndex,ppResponse)

#endif /* COBJMACROS */


#endif 	/* C style interface */



BOOL STDMETHODCALLTYPE IPropFindMultiResponse_IsComplete_Proxy( 
    IPropFindMultiResponse __RPC_FAR * This);


void __RPC_STUB IPropFindMultiResponse_IsComplete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPropFindMultiResponse_GetLength_Proxy( 
    IPropFindMultiResponse __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *pulLength);


void __RPC_STUB IPropFindMultiResponse_GetLength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPropFindMultiResponse_GetResponse_Proxy( 
    IPropFindMultiResponse __RPC_FAR * This,
    /* [in] */ ULONG ulIndex,
    /* [out] */ IPropFindResponse __RPC_FAR *__RPC_FAR *ppResponse);


void __RPC_STUB IPropFindMultiResponse_GetResponse_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPropFindMultiResponse_INTERFACE_DEFINED__ */


#ifndef __IPropFindResponse_INTERFACE_DEFINED__
#define __IPropFindResponse_INTERFACE_DEFINED__

/* interface IPropFindResponse */
/* [object][local][helpstring][uuid] */ 


EXTERN_C const IID IID_IPropFindResponse;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8A523716-0548-11d2-A894-0000F8084F96")
    IPropFindResponse : public IUnknown
    {
    public:
        virtual BOOL STDMETHODCALLTYPE IsComplete( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetHref( 
            /* [out] */ LPSTR __RPC_FAR *ppszHref) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProperty( 
            /* [in] */ DWORD dwNamespaceID,
            /* [in] */ LPCSTR pszPropertyName,
            /* [out] */ LPSTR __RPC_FAR *ppszPropertyValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPropFindResponseVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IPropFindResponse __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IPropFindResponse __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IPropFindResponse __RPC_FAR * This);
        
        BOOL ( STDMETHODCALLTYPE __RPC_FAR *IsComplete )( 
            IPropFindResponse __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetHref )( 
            IPropFindResponse __RPC_FAR * This,
            /* [out] */ LPSTR __RPC_FAR *ppszHref);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProperty )( 
            IPropFindResponse __RPC_FAR * This,
            /* [in] */ DWORD dwNamespaceID,
            /* [in] */ LPCSTR pszPropertyName,
            /* [out] */ LPSTR __RPC_FAR *ppszPropertyValue);
        
        END_INTERFACE
    } IPropFindResponseVtbl;

    interface IPropFindResponse
    {
        CONST_VTBL struct IPropFindResponseVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPropFindResponse_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPropFindResponse_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPropFindResponse_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPropFindResponse_IsComplete(This)	\
    (This)->lpVtbl -> IsComplete(This)

#define IPropFindResponse_GetHref(This,ppszHref)	\
    (This)->lpVtbl -> GetHref(This,ppszHref)

#define IPropFindResponse_GetProperty(This,dwNamespaceID,pszPropertyName,ppszPropertyValue)	\
    (This)->lpVtbl -> GetProperty(This,dwNamespaceID,pszPropertyName,ppszPropertyValue)

#endif /* COBJMACROS */


#endif 	/* C style interface */



BOOL STDMETHODCALLTYPE IPropFindResponse_IsComplete_Proxy( 
    IPropFindResponse __RPC_FAR * This);


void __RPC_STUB IPropFindResponse_IsComplete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPropFindResponse_GetHref_Proxy( 
    IPropFindResponse __RPC_FAR * This,
    /* [out] */ LPSTR __RPC_FAR *ppszHref);


void __RPC_STUB IPropFindResponse_GetHref_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPropFindResponse_GetProperty_Proxy( 
    IPropFindResponse __RPC_FAR * This,
    /* [in] */ DWORD dwNamespaceID,
    /* [in] */ LPCSTR pszPropertyName,
    /* [out] */ LPSTR __RPC_FAR *ppszPropertyValue);


void __RPC_STUB IPropFindResponse_GetProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPropFindResponse_INTERFACE_DEFINED__ */


#ifndef __IHTTPMailCallback_INTERFACE_DEFINED__
#define __IHTTPMailCallback_INTERFACE_DEFINED__

/* interface IHTTPMailCallback */
/* [object][local][helpstring][uuid] */ 

typedef 
enum tagHTTPMAILCOMMAND
    {	HTTPMAIL_NONE	= 0,
	HTTPMAIL_GETPROP	= HTTPMAIL_NONE + 1,
	HTTPMAIL_GET	= HTTPMAIL_GETPROP + 1,
	HTTPMAIL_PUT	= HTTPMAIL_GET + 1,
	HTTPMAIL_POST	= HTTPMAIL_PUT + 1,
	HTTPMAIL_DELETE	= HTTPMAIL_POST + 1,
	HTTPMAIL_BDELETE	= HTTPMAIL_DELETE + 1,
	HTTPMAIL_PROPFIND	= HTTPMAIL_BDELETE + 1,
	HTTPMAIL_PROPPATCH	= HTTPMAIL_PROPFIND + 1,
	HTTPMAIL_MKCOL	= HTTPMAIL_PROPPATCH + 1,
	HTTPMAIL_COPY	= HTTPMAIL_MKCOL + 1,
	HTTPMAIL_BCOPY	= HTTPMAIL_COPY + 1,
	HTTPMAIL_MOVE	= HTTPMAIL_BCOPY + 1,
	HTTPMAIL_BMOVE	= HTTPMAIL_MOVE + 1,
	HTTPMAIL_MEMBERINFO	= HTTPMAIL_BMOVE + 1,
	HTTPMAIL_FINDFOLDERS	= HTTPMAIL_MEMBERINFO + 1,
	HTTPMAIL_MARKREAD	= HTTPMAIL_FINDFOLDERS + 1,
	HTTPMAIL_SENDMESSAGE	= HTTPMAIL_MARKREAD + 1,
	HTTPMAIL_LISTCONTACTS	= HTTPMAIL_SENDMESSAGE + 1,
	HTTPMAIL_CONTACTINFO	= HTTPMAIL_LISTCONTACTS + 1,
	HTTPMAIL_POSTCONTACT	= HTTPMAIL_CONTACTINFO + 1,
	HTTPMAIL_PATCHCONTACT	= HTTPMAIL_POSTCONTACT + 1,
	HTTPMAIL_WAITROOTPROP	= HTTPMAIL_PATCHCONTACT + 1
    }	HTTPMAILCOMMAND;

typedef struct tagHTTPMAILGETPROP
    {
    HTTPMAILPROPTYPE type;
    LPSTR pszProp;
    DWORD dwProp;
    }	HTTPMAILGETPROP;

typedef struct tagHTTPMAILGETPROP __RPC_FAR *LPHTTPMAILGETPROP;

typedef struct tagHTTPMAILGET
    {
    BOOL fTotalKnown;
    DWORD cbIncrement;
    DWORD cbCurrent;
    DWORD cbTotal;
    LPVOID pvBody;
    LPSTR pszContentType;
    }	HTTPMAILGET;

typedef struct tagHTTPMAILGET __RPC_FAR *LPHTTPMAILGET;

typedef struct tagHTTPMAILPOST
    {
    LPSTR pszLocation;
    BOOL fResend;
    DWORD cbIncrement;
    DWORD cbCurrent;
    DWORD cbTotal;
    }	HTTPMAILPOST;

typedef struct tagHTTPMAILPOST __RPC_FAR *LPHTTPMAILPOST;

typedef struct tagHTTPMAILPROPFIND
    {
    IPropFindMultiResponse __RPC_FAR *pMultiResponse;
    }	HTTPMAILPROPFIND;

typedef struct tagHTTPMAILPROPFIND __RPC_FAR *LPHTTPMAILPROPFIND;

typedef struct tagHTTPMAILLOCATION
    {
    LPSTR pszLocation;
    }	HTTPMAILLOCATION;

typedef struct tagHTTPMAILLOCATION __RPC_FAR *LPHTTPMAILLOCATION;

typedef struct tagHTTPMAILBCOPYMOVE
    {
    LPSTR pszHref;
    LPSTR pszLocation;
    HRESULT hrResult;
    }	HTTPMAILBCOPYMOVE;

typedef struct tagHTTPMAILBCOPYMOVE __RPC_FAR *LPHTTPMAILBCOPYMOVE;

typedef struct tagHTTPMAILBCOPYMOVELIST
    {
    ULONG cBCopyMove;
    LPHTTPMAILBCOPYMOVE prgBCopyMove;
    }	HTTPMAILBCOPYMOVELIST;

typedef struct tagHTTPMAILBCOPYMOVELIST __RPC_FAR *LPHTTPMAILBCOPYMOVELIST;

typedef struct tagHTTPMEMBERINFO
    {
    LPSTR pszHref;
    BOOL fIsFolder;
    LPSTR pszDisplayName;
    BOOL fHasSubs;
    BOOL fNoSubs;
    DWORD dwUnreadCount;
    DWORD dwVisibleCount;
    HTTPMAILSPECIALFOLDER tySpecial;
    BOOL fRead;
    BOOL fHasAttachment;
    LPSTR pszTo;
    LPSTR pszFrom;
    LPSTR pszSubject;
    LPSTR pszDate;
    DWORD dwContentLength;
    }	HTTPMEMBERINFO;

typedef struct tagHTTPMEMBERINFO __RPC_FAR *LPHTTPMEMBERINFO;

typedef struct tagHTTPMEMBERINFOLIST
    {
    ULONG cMemberInfo;
    LPHTTPMEMBERINFO prgMemberInfo;
    LPSTR pszRootTimeStamp;
    LPSTR pszFolderTimeStamp;
    }	HTTPMEMBERINFOLIST;

typedef struct tagHTTPMEMBERINFOLIST __RPC_FAR *LPHTTPMEMBERINFOLIST;

typedef struct tagHTTPMEMBERERROR
    {
    LPSTR pszHref;
    HRESULT hrResult;
    }	HTTPMEMBERERROR;

typedef struct tagHTTPMEMBERERROR __RPC_FAR *LPHTTPMEMBERERROR;

typedef struct tagHTTPMEMBERERRORLIST
    {
    ULONG cMemberError;
    LPHTTPMEMBERERROR prgMemberError;
    }	HTTPMEMBERERRORLIST;

typedef struct tagHTTPMEMBERERRORLIST __RPC_FAR *LPHTTPMEMBERERRORLIST;

typedef struct tagHTTPCONTACTID
    {
    LPSTR pszHref;
    LPSTR pszId;
    HTTPMAILCONTACTTYPE tyContact;
    LPSTR pszModified;
    }	HTTPCONTACTID;

typedef struct tagHTTPCONTACTID __RPC_FAR *LPHTTPCONTACTID;

typedef struct tagHTTPCONTACTIDLIST
    {
    ULONG cContactId;
    LPHTTPCONTACTID prgContactId;
    }	HTTPCONTACTIDLIST;

typedef struct tagHTTPCONTACTIDLIST __RPC_FAR *LPHTTPCONTACTIDLIST;

typedef struct tagHTTPCONTACTINFO
    {
    LPSTR pszHref;
    LPSTR pszId;
    HTTPMAILCONTACTTYPE tyContact;
    LPSTR pszModified;
    LPSTR pszDisplayName;
    LPSTR pszGivenName;
    LPSTR pszSurname;
    LPSTR pszNickname;
    LPSTR pszEmail;
    LPSTR pszHomeStreet;
    LPSTR pszHomeCity;
    LPSTR pszHomeState;
    LPSTR pszHomePostalCode;
    LPSTR pszHomeCountry;
    LPSTR pszCompany;
    LPSTR pszWorkStreet;
    LPSTR pszWorkCity;
    LPSTR pszWorkState;
    LPSTR pszWorkPostalCode;
    LPSTR pszWorkCountry;
    LPSTR pszHomePhone;
    LPSTR pszHomeFax;
    LPSTR pszWorkPhone;
    LPSTR pszWorkFax;
    LPSTR pszMobilePhone;
    LPSTR pszOtherPhone;
    LPSTR pszBday;
    LPSTR pszPager;
    }	HTTPCONTACTINFO;

typedef struct tagHTTPCONTACTINFO __RPC_FAR *LPHTTPCONTACTINFO;

typedef struct tagHTTPCONTACTINFOLIST
    {
    ULONG cContactInfo;
    LPHTTPCONTACTINFO prgContactInfo;
    }	HTTPCONTACTINFOLIST;

typedef struct tagHTTPCONTACTINFOLIST __RPC_FAR *LPHTTPCONTACTINFOLIST;

typedef struct tagHTTPMAILRESPONSE
    {
    HTTPMAILCOMMAND command;
    DWORD dwContext;
    BOOL fDone;
    IXPRESULT rIxpResult;
    IHTTPMailTransport __RPC_FAR *pTransport;
    /* [switch_is][switch_type] */ union 
        {
        /* [case()] */ HTTPMAILGETPROP rGetPropInfo;
        /* [case()] */ HTTPMAILGET rGetInfo;
        /* [case()] */ HTTPMAILPOST rPutInfo;
        /* [case()] */ HTTPMAILPOST rPostInfo;
        /* [case()] */ HTTPMAILPROPFIND rPropFindInfo;
        /* [case()] */ HTTPMAILLOCATION rMkColInfo;
        /* [case()] */ HTTPMAILLOCATION rCopyMoveInfo;
        /* [case()] */ HTTPMAILBCOPYMOVELIST rBCopyMoveList;
        /* [case()] */ HTTPMEMBERINFOLIST rMemberInfoList;
        /* [case()] */ HTTPMEMBERERRORLIST rMemberErrorList;
        /* [case()] */ HTTPMAILPOST rSendMessageInfo;
        /* [case()] */ HTTPCONTACTIDLIST rContactIdList;
        /* [case()] */ HTTPCONTACTINFOLIST rContactInfoList;
        /* [case()] */ HTTPCONTACTID rPostContactInfo;
        /* [case()] */ HTTPCONTACTID rPatchContactInfo;
        /* [default] */  /* Empty union arm */ 
        }	;
    }	HTTPMAILRESPONSE;

typedef struct tagHTTPMAILRESPONSE __RPC_FAR *LPHTTPMAILRESPONSE;


EXTERN_C const IID IID_IHTTPMailCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("19F6481C-E5F0-11d1-A86E-0000F8084F96")
    IHTTPMailCallback : public ITransportCallback
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnResponse( 
            /* [in] */ LPHTTPMAILRESPONSE pResponse) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetParentWindow( 
            /* [out] */ HWND __RPC_FAR *phwndParent) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHTTPMailCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IHTTPMailCallback __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IHTTPMailCallback __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IHTTPMailCallback __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnTimeout )( 
            IHTTPMailCallback __RPC_FAR * This,
            /* [out][in] */ DWORD __RPC_FAR *pdwTimeout,
            /* [in] */ IInternetTransport __RPC_FAR *pTransport);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnLogonPrompt )( 
            IHTTPMailCallback __RPC_FAR * This,
            /* [out][in] */ LPINETSERVER pInetServer,
            /* [in] */ IInternetTransport __RPC_FAR *pTransport);
        
        INT ( STDMETHODCALLTYPE __RPC_FAR *OnPrompt )( 
            IHTTPMailCallback __RPC_FAR * This,
            /* [in] */ HRESULT hrError,
            /* [in] */ LPCTSTR pszText,
            /* [in] */ LPCTSTR pszCaption,
            /* [in] */ UINT uType,
            /* [in] */ IInternetTransport __RPC_FAR *pTransport);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnStatus )( 
            IHTTPMailCallback __RPC_FAR * This,
            /* [in] */ IXPSTATUS ixpstatus,
            /* [in] */ IInternetTransport __RPC_FAR *pTransport);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnError )( 
            IHTTPMailCallback __RPC_FAR * This,
            /* [in] */ IXPSTATUS ixpstatus,
            /* [in] */ LPIXPRESULT pResult,
            /* [in] */ IInternetTransport __RPC_FAR *pTransport);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnCommand )( 
            IHTTPMailCallback __RPC_FAR * This,
            /* [in] */ CMDTYPE cmdtype,
            /* [in] */ LPSTR pszLine,
            /* [in] */ HRESULT hrResponse,
            /* [in] */ IInternetTransport __RPC_FAR *pTransport);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnResponse )( 
            IHTTPMailCallback __RPC_FAR * This,
            /* [in] */ LPHTTPMAILRESPONSE pResponse);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetParentWindow )( 
            IHTTPMailCallback __RPC_FAR * This,
            /* [out] */ HWND __RPC_FAR *phwndParent);
        
        END_INTERFACE
    } IHTTPMailCallbackVtbl;

    interface IHTTPMailCallback
    {
        CONST_VTBL struct IHTTPMailCallbackVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHTTPMailCallback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHTTPMailCallback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHTTPMailCallback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHTTPMailCallback_OnTimeout(This,pdwTimeout,pTransport)	\
    (This)->lpVtbl -> OnTimeout(This,pdwTimeout,pTransport)

#define IHTTPMailCallback_OnLogonPrompt(This,pInetServer,pTransport)	\
    (This)->lpVtbl -> OnLogonPrompt(This,pInetServer,pTransport)

#define IHTTPMailCallback_OnPrompt(This,hrError,pszText,pszCaption,uType,pTransport)	\
    (This)->lpVtbl -> OnPrompt(This,hrError,pszText,pszCaption,uType,pTransport)

#define IHTTPMailCallback_OnStatus(This,ixpstatus,pTransport)	\
    (This)->lpVtbl -> OnStatus(This,ixpstatus,pTransport)

#define IHTTPMailCallback_OnError(This,ixpstatus,pResult,pTransport)	\
    (This)->lpVtbl -> OnError(This,ixpstatus,pResult,pTransport)

#define IHTTPMailCallback_OnCommand(This,cmdtype,pszLine,hrResponse,pTransport)	\
    (This)->lpVtbl -> OnCommand(This,cmdtype,pszLine,hrResponse,pTransport)


#define IHTTPMailCallback_OnResponse(This,pResponse)	\
    (This)->lpVtbl -> OnResponse(This,pResponse)

#define IHTTPMailCallback_GetParentWindow(This,phwndParent)	\
    (This)->lpVtbl -> GetParentWindow(This,phwndParent)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IHTTPMailCallback_OnResponse_Proxy( 
    IHTTPMailCallback __RPC_FAR * This,
    /* [in] */ LPHTTPMAILRESPONSE pResponse);


void __RPC_STUB IHTTPMailCallback_OnResponse_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTTPMailCallback_GetParentWindow_Proxy( 
    IHTTPMailCallback __RPC_FAR * This,
    /* [out] */ HWND __RPC_FAR *phwndParent);


void __RPC_STUB IHTTPMailCallback_GetParentWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHTTPMailCallback_INTERFACE_DEFINED__ */


#ifndef __IHTTPMailTransport_INTERFACE_DEFINED__
#define __IHTTPMailTransport_INTERFACE_DEFINED__

/* interface IHTTPMailTransport */
/* [object][local][helpstring][uuid] */ 

typedef struct tagHTTPTARGETLIST
    {
    ULONG cTarget;
    LPCSTR __RPC_FAR *prgTarget;
    }	HTTPTARGETLIST;

typedef struct tagHTTPTARGETLIST __RPC_FAR *LPHTTPTARGETLIST;


EXTERN_C const IID IID_IHTTPMailTransport;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B8BDE03C-E548-11d1-A86E-0000F8084F96")
    IHTTPMailTransport : public IInternetTransport
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InitNew( 
            /* [in] */ LPCSTR pszUserAgent,
            /* [in] */ LPCSTR pszLogFilePath,
            /* [in] */ IHTTPMailCallback __RPC_FAR *pCallback) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CommandGET( 
            /* [in] */ LPCSTR pszPath,
            /* [in] */ LPCSTR __RPC_FAR *rgszAcceptTypes,
            /* [in] */ BOOL fTranslate,
            /* [in] */ DWORD dwContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CommandPUT( 
            /* [in] */ LPCSTR pszPath,
            /* [in] */ LPVOID lpvData,
            /* [in] */ ULONG cbSize,
            /* [in] */ DWORD dwContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CommandPOST( 
            /* [in] */ LPCSTR pszPath,
            /* [in] */ IStream __RPC_FAR *pStream,
            /* [in] */ LPCSTR pszContentType,
            /* [in] */ DWORD dwContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CommandDELETE( 
            /* [in] */ LPCSTR pszPath,
            /* [in] */ DWORD dwContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CommandBDELETE( 
            /* [in] */ LPCSTR pszSourceCollection,
            /* [in] */ LPHTTPTARGETLIST pTargets,
            /* [in] */ DWORD dwContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CommandPROPFIND( 
            /* [in] */ LPCSTR pszPath,
            /* [in] */ IPropFindRequest __RPC_FAR *pRequest,
            /* [in] */ DWORD dwDepth,
            /* [in] */ DWORD dwContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CommandPROPPATCH( 
            /* [in] */ LPCSTR pszPath,
            /* [in] */ IPropPatchRequest __RPC_FAR *pRequest,
            /* [in] */ DWORD dwContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CommandMKCOL( 
            /* [in] */ LPCSTR pszPath,
            /* [in] */ DWORD dwContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CommandCOPY( 
            /* [in] */ LPCSTR pszPath,
            /* [in] */ LPCSTR pszDestination,
            /* [in] */ BOOL fAllowRename,
            /* [in] */ DWORD dwContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CommandBCOPY( 
            /* [in] */ LPCSTR pszSourceCollection,
            /* [in] */ LPHTTPTARGETLIST pTargets,
            /* [in] */ LPCSTR pszDestCollection,
            /* [in] */ LPHTTPTARGETLIST pDestinations,
            /* [in] */ BOOL fAllowRename,
            /* [in] */ DWORD dwContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CommandMOVE( 
            /* [in] */ LPCSTR pszPath,
            /* [in] */ LPCSTR pszDestination,
            /* [in] */ BOOL fAllowRename,
            /* [in] */ DWORD dwContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CommandBMOVE( 
            /* [in] */ LPCSTR pszSourceCollection,
            /* [in] */ LPHTTPTARGETLIST pTargets,
            /* [in] */ LPCSTR pszDestCollection,
            /* [in] */ LPHTTPTARGETLIST pDestinations,
            /* [in] */ BOOL fAllowRename,
            /* [in] */ DWORD dwContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProperty( 
            /* [in] */ HTTPMAILPROPTYPE proptype,
            /* [out] */ LPSTR __RPC_FAR *ppszProp) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MemberInfo( 
            /* [in] */ LPCSTR pszPath,
            /* [in] */ MEMBERINFOFLAGS flags,
            /* [in] */ DWORD dwDepth,
            /* [in] */ BOOL fIncludeRoot,
            /* [in] */ DWORD dwContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindFolders( 
            /* [in] */ LPCSTR pszPath,
            /* [in] */ DWORD dwContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MarkRead( 
            /* [in] */ LPCSTR pszPath,
            /* [in] */ LPHTTPTARGETLIST pTargets,
            /* [in] */ BOOL fMarkRead,
            /* [in] */ DWORD dwContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SendMessage( 
            /* [in] */ LPCSTR pszPath,
            /* [in] */ LPCSTR pszFrom,
            /* [in] */ LPHTTPTARGETLIST pTargets,
            /* [in] */ BOOL fSaveInSent,
            /* [in] */ IStream __RPC_FAR *pMessageStream,
            /* [in] */ DWORD dwContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ListContacts( 
            /* [in] */ LPCSTR pszPath,
            /* [in] */ DWORD dwContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ListContactInfos( 
            /* [in] */ LPCSTR pszCollectionPath,
            /* [in] */ DWORD dwContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ContactInfo( 
            /* [in] */ LPCSTR pszPath,
            /* [in] */ DWORD dwContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PostContact( 
            /* [in] */ LPCSTR pszPath,
            /* [in] */ LPHTTPCONTACTINFO pciInfo,
            /* [in] */ DWORD dwContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PatchContact( 
            /* [in] */ LPCSTR pszPath,
            /* [in] */ LPHTTPCONTACTINFO pciInfo,
            /* [in] */ DWORD dwContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHTTPMailTransportVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IHTTPMailTransport __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IHTTPMailTransport __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IHTTPMailTransport __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetServerInfo )( 
            IHTTPMailTransport __RPC_FAR * This,
            /* [out][in] */ LPINETSERVER pInetServer);
        
        IXPTYPE ( STDMETHODCALLTYPE __RPC_FAR *GetIXPType )( 
            IHTTPMailTransport __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsState )( 
            IHTTPMailTransport __RPC_FAR * This,
            /* [in] */ IXPISSTATE isstate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InetServerFromAccount )( 
            IHTTPMailTransport __RPC_FAR * This,
            /* [in] */ IImnAccount __RPC_FAR *pAccount,
            /* [out][in] */ LPINETSERVER pInetServer);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Connect )( 
            IHTTPMailTransport __RPC_FAR * This,
            /* [in] */ LPINETSERVER pInetServer,
            /* [in] */ boolean fAuthenticate,
            /* [in] */ boolean fCommandLogging);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *HandsOffCallback )( 
            IHTTPMailTransport __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Disconnect )( 
            IHTTPMailTransport __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DropConnection )( 
            IHTTPMailTransport __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStatus )( 
            IHTTPMailTransport __RPC_FAR * This,
            /* [out] */ IXPSTATUS __RPC_FAR *pCurrentStatus);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InitNew )( 
            IHTTPMailTransport __RPC_FAR * This,
            /* [in] */ LPCSTR pszUserAgent,
            /* [in] */ LPCSTR pszLogFilePath,
            /* [in] */ IHTTPMailCallback __RPC_FAR *pCallback);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CommandGET )( 
            IHTTPMailTransport __RPC_FAR * This,
            /* [in] */ LPCSTR pszPath,
            /* [in] */ LPCSTR __RPC_FAR *rgszAcceptTypes,
            /* [in] */ BOOL fTranslate,
            /* [in] */ DWORD dwContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CommandPUT )( 
            IHTTPMailTransport __RPC_FAR * This,
            /* [in] */ LPCSTR pszPath,
            /* [in] */ LPVOID lpvData,
            /* [in] */ ULONG cbSize,
            /* [in] */ DWORD dwContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CommandPOST )( 
            IHTTPMailTransport __RPC_FAR * This,
            /* [in] */ LPCSTR pszPath,
            /* [in] */ IStream __RPC_FAR *pStream,
            /* [in] */ LPCSTR pszContentType,
            /* [in] */ DWORD dwContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CommandDELETE )( 
            IHTTPMailTransport __RPC_FAR * This,
            /* [in] */ LPCSTR pszPath,
            /* [in] */ DWORD dwContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CommandBDELETE )( 
            IHTTPMailTransport __RPC_FAR * This,
            /* [in] */ LPCSTR pszSourceCollection,
            /* [in] */ LPHTTPTARGETLIST pTargets,
            /* [in] */ DWORD dwContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CommandPROPFIND )( 
            IHTTPMailTransport __RPC_FAR * This,
            /* [in] */ LPCSTR pszPath,
            /* [in] */ IPropFindRequest __RPC_FAR *pRequest,
            /* [in] */ DWORD dwDepth,
            /* [in] */ DWORD dwContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CommandPROPPATCH )( 
            IHTTPMailTransport __RPC_FAR * This,
            /* [in] */ LPCSTR pszPath,
            /* [in] */ IPropPatchRequest __RPC_FAR *pRequest,
            /* [in] */ DWORD dwContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CommandMKCOL )( 
            IHTTPMailTransport __RPC_FAR * This,
            /* [in] */ LPCSTR pszPath,
            /* [in] */ DWORD dwContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CommandCOPY )( 
            IHTTPMailTransport __RPC_FAR * This,
            /* [in] */ LPCSTR pszPath,
            /* [in] */ LPCSTR pszDestination,
            /* [in] */ BOOL fAllowRename,
            /* [in] */ DWORD dwContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CommandBCOPY )( 
            IHTTPMailTransport __RPC_FAR * This,
            /* [in] */ LPCSTR pszSourceCollection,
            /* [in] */ LPHTTPTARGETLIST pTargets,
            /* [in] */ LPCSTR pszDestCollection,
            /* [in] */ LPHTTPTARGETLIST pDestinations,
            /* [in] */ BOOL fAllowRename,
            /* [in] */ DWORD dwContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CommandMOVE )( 
            IHTTPMailTransport __RPC_FAR * This,
            /* [in] */ LPCSTR pszPath,
            /* [in] */ LPCSTR pszDestination,
            /* [in] */ BOOL fAllowRename,
            /* [in] */ DWORD dwContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CommandBMOVE )( 
            IHTTPMailTransport __RPC_FAR * This,
            /* [in] */ LPCSTR pszSourceCollection,
            /* [in] */ LPHTTPTARGETLIST pTargets,
            /* [in] */ LPCSTR pszDestCollection,
            /* [in] */ LPHTTPTARGETLIST pDestinations,
            /* [in] */ BOOL fAllowRename,
            /* [in] */ DWORD dwContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProperty )( 
            IHTTPMailTransport __RPC_FAR * This,
            /* [in] */ HTTPMAILPROPTYPE proptype,
            /* [out] */ LPSTR __RPC_FAR *ppszProp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MemberInfo )( 
            IHTTPMailTransport __RPC_FAR * This,
            /* [in] */ LPCSTR pszPath,
            /* [in] */ MEMBERINFOFLAGS flags,
            /* [in] */ DWORD dwDepth,
            /* [in] */ BOOL fIncludeRoot,
            /* [in] */ DWORD dwContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindFolders )( 
            IHTTPMailTransport __RPC_FAR * This,
            /* [in] */ LPCSTR pszPath,
            /* [in] */ DWORD dwContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MarkRead )( 
            IHTTPMailTransport __RPC_FAR * This,
            /* [in] */ LPCSTR pszPath,
            /* [in] */ LPHTTPTARGETLIST pTargets,
            /* [in] */ BOOL fMarkRead,
            /* [in] */ DWORD dwContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SendMessage )( 
            IHTTPMailTransport __RPC_FAR * This,
            /* [in] */ LPCSTR pszPath,
            /* [in] */ LPCSTR pszFrom,
            /* [in] */ LPHTTPTARGETLIST pTargets,
            /* [in] */ BOOL fSaveInSent,
            /* [in] */ IStream __RPC_FAR *pMessageStream,
            /* [in] */ DWORD dwContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ListContacts )( 
            IHTTPMailTransport __RPC_FAR * This,
            /* [in] */ LPCSTR pszPath,
            /* [in] */ DWORD dwContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ListContactInfos )( 
            IHTTPMailTransport __RPC_FAR * This,
            /* [in] */ LPCSTR pszCollectionPath,
            /* [in] */ DWORD dwContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ContactInfo )( 
            IHTTPMailTransport __RPC_FAR * This,
            /* [in] */ LPCSTR pszPath,
            /* [in] */ DWORD dwContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PostContact )( 
            IHTTPMailTransport __RPC_FAR * This,
            /* [in] */ LPCSTR pszPath,
            /* [in] */ LPHTTPCONTACTINFO pciInfo,
            /* [in] */ DWORD dwContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PatchContact )( 
            IHTTPMailTransport __RPC_FAR * This,
            /* [in] */ LPCSTR pszPath,
            /* [in] */ LPHTTPCONTACTINFO pciInfo,
            /* [in] */ DWORD dwContext);
        
        END_INTERFACE
    } IHTTPMailTransportVtbl;

    interface IHTTPMailTransport
    {
        CONST_VTBL struct IHTTPMailTransportVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHTTPMailTransport_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHTTPMailTransport_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHTTPMailTransport_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHTTPMailTransport_GetServerInfo(This,pInetServer)	\
    (This)->lpVtbl -> GetServerInfo(This,pInetServer)

#define IHTTPMailTransport_GetIXPType(This)	\
    (This)->lpVtbl -> GetIXPType(This)

#define IHTTPMailTransport_IsState(This,isstate)	\
    (This)->lpVtbl -> IsState(This,isstate)

#define IHTTPMailTransport_InetServerFromAccount(This,pAccount,pInetServer)	\
    (This)->lpVtbl -> InetServerFromAccount(This,pAccount,pInetServer)

#define IHTTPMailTransport_Connect(This,pInetServer,fAuthenticate,fCommandLogging)	\
    (This)->lpVtbl -> Connect(This,pInetServer,fAuthenticate,fCommandLogging)

#define IHTTPMailTransport_HandsOffCallback(This)	\
    (This)->lpVtbl -> HandsOffCallback(This)

#define IHTTPMailTransport_Disconnect(This)	\
    (This)->lpVtbl -> Disconnect(This)

#define IHTTPMailTransport_DropConnection(This)	\
    (This)->lpVtbl -> DropConnection(This)

#define IHTTPMailTransport_GetStatus(This,pCurrentStatus)	\
    (This)->lpVtbl -> GetStatus(This,pCurrentStatus)


#define IHTTPMailTransport_InitNew(This,pszUserAgent,pszLogFilePath,pCallback)	\
    (This)->lpVtbl -> InitNew(This,pszUserAgent,pszLogFilePath,pCallback)

#define IHTTPMailTransport_CommandGET(This,pszPath,rgszAcceptTypes,fTranslate,dwContext)	\
    (This)->lpVtbl -> CommandGET(This,pszPath,rgszAcceptTypes,fTranslate,dwContext)

#define IHTTPMailTransport_CommandPUT(This,pszPath,lpvData,cbSize,dwContext)	\
    (This)->lpVtbl -> CommandPUT(This,pszPath,lpvData,cbSize,dwContext)

#define IHTTPMailTransport_CommandPOST(This,pszPath,pStream,pszContentType,dwContext)	\
    (This)->lpVtbl -> CommandPOST(This,pszPath,pStream,pszContentType,dwContext)

#define IHTTPMailTransport_CommandDELETE(This,pszPath,dwContext)	\
    (This)->lpVtbl -> CommandDELETE(This,pszPath,dwContext)

#define IHTTPMailTransport_CommandBDELETE(This,pszSourceCollection,pTargets,dwContext)	\
    (This)->lpVtbl -> CommandBDELETE(This,pszSourceCollection,pTargets,dwContext)

#define IHTTPMailTransport_CommandPROPFIND(This,pszPath,pRequest,dwDepth,dwContext)	\
    (This)->lpVtbl -> CommandPROPFIND(This,pszPath,pRequest,dwDepth,dwContext)

#define IHTTPMailTransport_CommandPROPPATCH(This,pszPath,pRequest,dwContext)	\
    (This)->lpVtbl -> CommandPROPPATCH(This,pszPath,pRequest,dwContext)

#define IHTTPMailTransport_CommandMKCOL(This,pszPath,dwContext)	\
    (This)->lpVtbl -> CommandMKCOL(This,pszPath,dwContext)

#define IHTTPMailTransport_CommandCOPY(This,pszPath,pszDestination,fAllowRename,dwContext)	\
    (This)->lpVtbl -> CommandCOPY(This,pszPath,pszDestination,fAllowRename,dwContext)

#define IHTTPMailTransport_CommandBCOPY(This,pszSourceCollection,pTargets,pszDestCollection,pDestinations,fAllowRename,dwContext)	\
    (This)->lpVtbl -> CommandBCOPY(This,pszSourceCollection,pTargets,pszDestCollection,pDestinations,fAllowRename,dwContext)

#define IHTTPMailTransport_CommandMOVE(This,pszPath,pszDestination,fAllowRename,dwContext)	\
    (This)->lpVtbl -> CommandMOVE(This,pszPath,pszDestination,fAllowRename,dwContext)

#define IHTTPMailTransport_CommandBMOVE(This,pszSourceCollection,pTargets,pszDestCollection,pDestinations,fAllowRename,dwContext)	\
    (This)->lpVtbl -> CommandBMOVE(This,pszSourceCollection,pTargets,pszDestCollection,pDestinations,fAllowRename,dwContext)

#define IHTTPMailTransport_GetProperty(This,proptype,ppszProp)	\
    (This)->lpVtbl -> GetProperty(This,proptype,ppszProp)

#define IHTTPMailTransport_MemberInfo(This,pszPath,flags,dwDepth,fIncludeRoot,dwContext)	\
    (This)->lpVtbl -> MemberInfo(This,pszPath,flags,dwDepth,fIncludeRoot,dwContext)

#define IHTTPMailTransport_FindFolders(This,pszPath,dwContext)	\
    (This)->lpVtbl -> FindFolders(This,pszPath,dwContext)

#define IHTTPMailTransport_MarkRead(This,pszPath,pTargets,fMarkRead,dwContext)	\
    (This)->lpVtbl -> MarkRead(This,pszPath,pTargets,fMarkRead,dwContext)

#define IHTTPMailTransport_SendMessage(This,pszPath,pszFrom,pTargets,fSaveInSent,pMessageStream,dwContext)	\
    (This)->lpVtbl -> SendMessage(This,pszPath,pszFrom,pTargets,fSaveInSent,pMessageStream,dwContext)

#define IHTTPMailTransport_ListContacts(This,pszPath,dwContext)	\
    (This)->lpVtbl -> ListContacts(This,pszPath,dwContext)

#define IHTTPMailTransport_ListContactInfos(This,pszCollectionPath,dwContext)	\
    (This)->lpVtbl -> ListContactInfos(This,pszCollectionPath,dwContext)

#define IHTTPMailTransport_ContactInfo(This,pszPath,dwContext)	\
    (This)->lpVtbl -> ContactInfo(This,pszPath,dwContext)

#define IHTTPMailTransport_PostContact(This,pszPath,pciInfo,dwContext)	\
    (This)->lpVtbl -> PostContact(This,pszPath,pciInfo,dwContext)

#define IHTTPMailTransport_PatchContact(This,pszPath,pciInfo,dwContext)	\
    (This)->lpVtbl -> PatchContact(This,pszPath,pciInfo,dwContext)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IHTTPMailTransport_InitNew_Proxy( 
    IHTTPMailTransport __RPC_FAR * This,
    /* [in] */ LPCSTR pszUserAgent,
    /* [in] */ LPCSTR pszLogFilePath,
    /* [in] */ IHTTPMailCallback __RPC_FAR *pCallback);


void __RPC_STUB IHTTPMailTransport_InitNew_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTTPMailTransport_CommandGET_Proxy( 
    IHTTPMailTransport __RPC_FAR * This,
    /* [in] */ LPCSTR pszPath,
    /* [in] */ LPCSTR __RPC_FAR *rgszAcceptTypes,
    /* [in] */ BOOL fTranslate,
    /* [in] */ DWORD dwContext);


void __RPC_STUB IHTTPMailTransport_CommandGET_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTTPMailTransport_CommandPUT_Proxy( 
    IHTTPMailTransport __RPC_FAR * This,
    /* [in] */ LPCSTR pszPath,
    /* [in] */ LPVOID lpvData,
    /* [in] */ ULONG cbSize,
    /* [in] */ DWORD dwContext);


void __RPC_STUB IHTTPMailTransport_CommandPUT_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTTPMailTransport_CommandPOST_Proxy( 
    IHTTPMailTransport __RPC_FAR * This,
    /* [in] */ LPCSTR pszPath,
    /* [in] */ IStream __RPC_FAR *pStream,
    /* [in] */ LPCSTR pszContentType,
    /* [in] */ DWORD dwContext);


void __RPC_STUB IHTTPMailTransport_CommandPOST_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTTPMailTransport_CommandDELETE_Proxy( 
    IHTTPMailTransport __RPC_FAR * This,
    /* [in] */ LPCSTR pszPath,
    /* [in] */ DWORD dwContext);


void __RPC_STUB IHTTPMailTransport_CommandDELETE_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTTPMailTransport_CommandBDELETE_Proxy( 
    IHTTPMailTransport __RPC_FAR * This,
    /* [in] */ LPCSTR pszSourceCollection,
    /* [in] */ LPHTTPTARGETLIST pTargets,
    /* [in] */ DWORD dwContext);


void __RPC_STUB IHTTPMailTransport_CommandBDELETE_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTTPMailTransport_CommandPROPFIND_Proxy( 
    IHTTPMailTransport __RPC_FAR * This,
    /* [in] */ LPCSTR pszPath,
    /* [in] */ IPropFindRequest __RPC_FAR *pRequest,
    /* [in] */ DWORD dwDepth,
    /* [in] */ DWORD dwContext);


void __RPC_STUB IHTTPMailTransport_CommandPROPFIND_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTTPMailTransport_CommandPROPPATCH_Proxy( 
    IHTTPMailTransport __RPC_FAR * This,
    /* [in] */ LPCSTR pszPath,
    /* [in] */ IPropPatchRequest __RPC_FAR *pRequest,
    /* [in] */ DWORD dwContext);


void __RPC_STUB IHTTPMailTransport_CommandPROPPATCH_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTTPMailTransport_CommandMKCOL_Proxy( 
    IHTTPMailTransport __RPC_FAR * This,
    /* [in] */ LPCSTR pszPath,
    /* [in] */ DWORD dwContext);


void __RPC_STUB IHTTPMailTransport_CommandMKCOL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTTPMailTransport_CommandCOPY_Proxy( 
    IHTTPMailTransport __RPC_FAR * This,
    /* [in] */ LPCSTR pszPath,
    /* [in] */ LPCSTR pszDestination,
    /* [in] */ BOOL fAllowRename,
    /* [in] */ DWORD dwContext);


void __RPC_STUB IHTTPMailTransport_CommandCOPY_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTTPMailTransport_CommandBCOPY_Proxy( 
    IHTTPMailTransport __RPC_FAR * This,
    /* [in] */ LPCSTR pszSourceCollection,
    /* [in] */ LPHTTPTARGETLIST pTargets,
    /* [in] */ LPCSTR pszDestCollection,
    /* [in] */ LPHTTPTARGETLIST pDestinations,
    /* [in] */ BOOL fAllowRename,
    /* [in] */ DWORD dwContext);


void __RPC_STUB IHTTPMailTransport_CommandBCOPY_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTTPMailTransport_CommandMOVE_Proxy( 
    IHTTPMailTransport __RPC_FAR * This,
    /* [in] */ LPCSTR pszPath,
    /* [in] */ LPCSTR pszDestination,
    /* [in] */ BOOL fAllowRename,
    /* [in] */ DWORD dwContext);


void __RPC_STUB IHTTPMailTransport_CommandMOVE_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTTPMailTransport_CommandBMOVE_Proxy( 
    IHTTPMailTransport __RPC_FAR * This,
    /* [in] */ LPCSTR pszSourceCollection,
    /* [in] */ LPHTTPTARGETLIST pTargets,
    /* [in] */ LPCSTR pszDestCollection,
    /* [in] */ LPHTTPTARGETLIST pDestinations,
    /* [in] */ BOOL fAllowRename,
    /* [in] */ DWORD dwContext);


void __RPC_STUB IHTTPMailTransport_CommandBMOVE_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTTPMailTransport_GetProperty_Proxy( 
    IHTTPMailTransport __RPC_FAR * This,
    /* [in] */ HTTPMAILPROPTYPE proptype,
    /* [out] */ LPSTR __RPC_FAR *ppszProp);


void __RPC_STUB IHTTPMailTransport_GetProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTTPMailTransport_MemberInfo_Proxy( 
    IHTTPMailTransport __RPC_FAR * This,
    /* [in] */ LPCSTR pszPath,
    /* [in] */ MEMBERINFOFLAGS flags,
    /* [in] */ DWORD dwDepth,
    /* [in] */ BOOL fIncludeRoot,
    /* [in] */ DWORD dwContext);


void __RPC_STUB IHTTPMailTransport_MemberInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTTPMailTransport_FindFolders_Proxy( 
    IHTTPMailTransport __RPC_FAR * This,
    /* [in] */ LPCSTR pszPath,
    /* [in] */ DWORD dwContext);


void __RPC_STUB IHTTPMailTransport_FindFolders_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTTPMailTransport_MarkRead_Proxy( 
    IHTTPMailTransport __RPC_FAR * This,
    /* [in] */ LPCSTR pszPath,
    /* [in] */ LPHTTPTARGETLIST pTargets,
    /* [in] */ BOOL fMarkRead,
    /* [in] */ DWORD dwContext);


void __RPC_STUB IHTTPMailTransport_MarkRead_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTTPMailTransport_SendMessage_Proxy( 
    IHTTPMailTransport __RPC_FAR * This,
    /* [in] */ LPCSTR pszPath,
    /* [in] */ LPCSTR pszFrom,
    /* [in] */ LPHTTPTARGETLIST pTargets,
    /* [in] */ BOOL fSaveInSent,
    /* [in] */ IStream __RPC_FAR *pMessageStream,
    /* [in] */ DWORD dwContext);


void __RPC_STUB IHTTPMailTransport_SendMessage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTTPMailTransport_ListContacts_Proxy( 
    IHTTPMailTransport __RPC_FAR * This,
    /* [in] */ LPCSTR pszPath,
    /* [in] */ DWORD dwContext);


void __RPC_STUB IHTTPMailTransport_ListContacts_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTTPMailTransport_ListContactInfos_Proxy( 
    IHTTPMailTransport __RPC_FAR * This,
    /* [in] */ LPCSTR pszCollectionPath,
    /* [in] */ DWORD dwContext);


void __RPC_STUB IHTTPMailTransport_ListContactInfos_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTTPMailTransport_ContactInfo_Proxy( 
    IHTTPMailTransport __RPC_FAR * This,
    /* [in] */ LPCSTR pszPath,
    /* [in] */ DWORD dwContext);


void __RPC_STUB IHTTPMailTransport_ContactInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTTPMailTransport_PostContact_Proxy( 
    IHTTPMailTransport __RPC_FAR * This,
    /* [in] */ LPCSTR pszPath,
    /* [in] */ LPHTTPCONTACTINFO pciInfo,
    /* [in] */ DWORD dwContext);


void __RPC_STUB IHTTPMailTransport_PostContact_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTTPMailTransport_PatchContact_Proxy( 
    IHTTPMailTransport __RPC_FAR * This,
    /* [in] */ LPCSTR pszPath,
    /* [in] */ LPHTTPCONTACTINFO pciInfo,
    /* [in] */ DWORD dwContext);


void __RPC_STUB IHTTPMailTransport_PatchContact_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHTTPMailTransport_INTERFACE_DEFINED__ */


#ifndef __IHTTPMailTransport2_INTERFACE_DEFINED__
#define __IHTTPMailTransport2_INTERFACE_DEFINED__

/* interface IHTTPMailTransport2 */
/* [object][helpstring][uuid] */ 


EXTERN_C const IID IID_IHTTPMailTransport2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("82758005-D38A-11d3-8E81-00C04F79E13B")
    IHTTPMailTransport2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RootMemberInfo( 
            /* [in] */ LPCSTR pszPath,
            /* [in] */ MEMBERINFOFLAGS flags,
            /* [in] */ DWORD dwDepth,
            /* [in] */ BOOL fIncludeRoot,
            /* [in] */ DWORD dwContext,
            /* [in] */ LPSTR pszRootTimeStamp,
            /* [in] */ LPSTR pszInboxTimeStamp) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FolderMemberInfo( 
            /* [in] */ LPCSTR pszPath,
            /* [in] */ MEMBERINFOFLAGS flags,
            /* [in] */ DWORD dwDepth,
            /* [in] */ BOOL fIncludeRoot,
            /* [in] */ DWORD dwContext,
            /* [in] */ LPSTR pszFolderTimeStamp,
            /* [in] */ LPSTR pszFolderName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPropertyDw( 
            /* [in] */ HTTPMAILPROPTYPE proptype,
            /* [out] */ LPDWORD lpdwProp) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHTTPMailTransport2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IHTTPMailTransport2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IHTTPMailTransport2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IHTTPMailTransport2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RootMemberInfo )( 
            IHTTPMailTransport2 __RPC_FAR * This,
            /* [in] */ LPCSTR pszPath,
            /* [in] */ MEMBERINFOFLAGS flags,
            /* [in] */ DWORD dwDepth,
            /* [in] */ BOOL fIncludeRoot,
            /* [in] */ DWORD dwContext,
            /* [in] */ LPSTR pszRootTimeStamp,
            /* [in] */ LPSTR pszInboxTimeStamp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FolderMemberInfo )( 
            IHTTPMailTransport2 __RPC_FAR * This,
            /* [in] */ LPCSTR pszPath,
            /* [in] */ MEMBERINFOFLAGS flags,
            /* [in] */ DWORD dwDepth,
            /* [in] */ BOOL fIncludeRoot,
            /* [in] */ DWORD dwContext,
            /* [in] */ LPSTR pszFolderTimeStamp,
            /* [in] */ LPSTR pszFolderName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPropertyDw )( 
            IHTTPMailTransport2 __RPC_FAR * This,
            /* [in] */ HTTPMAILPROPTYPE proptype,
            /* [out] */ LPDWORD lpdwProp);
        
        END_INTERFACE
    } IHTTPMailTransport2Vtbl;

    interface IHTTPMailTransport2
    {
        CONST_VTBL struct IHTTPMailTransport2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHTTPMailTransport2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHTTPMailTransport2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHTTPMailTransport2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHTTPMailTransport2_RootMemberInfo(This,pszPath,flags,dwDepth,fIncludeRoot,dwContext,pszRootTimeStamp,pszInboxTimeStamp)	\
    (This)->lpVtbl -> RootMemberInfo(This,pszPath,flags,dwDepth,fIncludeRoot,dwContext,pszRootTimeStamp,pszInboxTimeStamp)

#define IHTTPMailTransport2_FolderMemberInfo(This,pszPath,flags,dwDepth,fIncludeRoot,dwContext,pszFolderTimeStamp,pszFolderName)	\
    (This)->lpVtbl -> FolderMemberInfo(This,pszPath,flags,dwDepth,fIncludeRoot,dwContext,pszFolderTimeStamp,pszFolderName)

#define IHTTPMailTransport2_GetPropertyDw(This,proptype,lpdwProp)	\
    (This)->lpVtbl -> GetPropertyDw(This,proptype,lpdwProp)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IHTTPMailTransport2_RootMemberInfo_Proxy( 
    IHTTPMailTransport2 __RPC_FAR * This,
    /* [in] */ LPCSTR pszPath,
    /* [in] */ MEMBERINFOFLAGS flags,
    /* [in] */ DWORD dwDepth,
    /* [in] */ BOOL fIncludeRoot,
    /* [in] */ DWORD dwContext,
    /* [in] */ LPSTR pszRootTimeStamp,
    /* [in] */ LPSTR pszInboxTimeStamp);


void __RPC_STUB IHTTPMailTransport2_RootMemberInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTTPMailTransport2_FolderMemberInfo_Proxy( 
    IHTTPMailTransport2 __RPC_FAR * This,
    /* [in] */ LPCSTR pszPath,
    /* [in] */ MEMBERINFOFLAGS flags,
    /* [in] */ DWORD dwDepth,
    /* [in] */ BOOL fIncludeRoot,
    /* [in] */ DWORD dwContext,
    /* [in] */ LPSTR pszFolderTimeStamp,
    /* [in] */ LPSTR pszFolderName);


void __RPC_STUB IHTTPMailTransport2_FolderMemberInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTTPMailTransport2_GetPropertyDw_Proxy( 
    IHTTPMailTransport2 __RPC_FAR * This,
    /* [in] */ HTTPMAILPROPTYPE proptype,
    /* [out] */ LPDWORD lpdwProp);


void __RPC_STUB IHTTPMailTransport2_GetPropertyDw_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHTTPMailTransport2_INTERFACE_DEFINED__ */


#ifndef __IPOP3Callback_INTERFACE_DEFINED__
#define __IPOP3Callback_INTERFACE_DEFINED__

/* interface IPOP3Callback */
/* [object][local][helpstring][uuid] */ 

typedef 
enum tagPOP3COMMAND
    {	POP3_NONE	= 0,
	POP3_BANNER	= POP3_NONE + 1,
	POP3_CONNECTED	= POP3_BANNER + 1,
	POP3_USER	= POP3_CONNECTED + 1,
	POP3_PASS	= POP3_USER + 1,
	POP3_AUTH	= POP3_PASS + 1,
	POP3_UIDL	= POP3_AUTH + 1,
	POP3_STAT	= POP3_UIDL + 1,
	POP3_LIST	= POP3_STAT + 1,
	POP3_DELE	= POP3_LIST + 1,
	POP3_RETR	= POP3_DELE + 1,
	POP3_TOP	= POP3_RETR + 1,
	POP3_NOOP	= POP3_TOP + 1,
	POP3_QUIT	= POP3_NOOP + 1,
	POP3_RSET	= POP3_QUIT + 1,
	POP3_CUSTOM	= POP3_RSET + 1
    }	POP3COMMAND;

typedef struct tagPOP3RETR
    {
    BOOL fHeader;
    BOOL fBody;
    DWORD dwPopId;
    DWORD cbSoFar;
    LPSTR pszLines;
    ULONG cbLines;
    }	POP3RETR;

typedef struct tagPOP3RETR __RPC_FAR *LPPOP3RETR;

typedef struct tagPOP3TOP
    {
    BOOL fHeader;
    BOOL fBody;
    DWORD dwPopId;
    DWORD cPreviewLines;
    DWORD cbSoFar;
    LPSTR pszLines;
    ULONG cbLines;
    }	POP3TOP;

typedef struct tagPOP3TOP __RPC_FAR *LPPOP3TOP;

typedef struct tagPOP3LIST
    {
    DWORD dwPopId;
    DWORD cbSize;
    }	POP3LIST;

typedef struct tagPOP3LIST __RPC_FAR *LPPOP3LIST;

typedef struct tagPOP3UIDL
    {
    DWORD dwPopId;
    LPSTR pszUidl;
    }	POP3UIDL;

typedef struct tagPOP3UIDL __RPC_FAR *LPPOP3UIDL;

typedef struct tagPOP3STAT
    {
    DWORD cMessages;
    DWORD cbMessages;
    }	POP3STAT;

typedef struct tagPOP3STAT __RPC_FAR *LPPOP3STAT;

typedef struct tagPOP3RESPONSE
    {
    POP3COMMAND command;
    BOOL fDone;
    IXPRESULT rIxpResult;
    IPOP3Transport __RPC_FAR *pTransport;
    BOOL fValidInfo;
    /* [switch_is][switch_type] */ union 
        {
        /* [case()] */ POP3UIDL rUidlInfo;
        /* [case()] */ POP3STAT rStatInfo;
        /* [case()] */ POP3LIST rListInfo;
        /* [case()] */ DWORD dwPopId;
        /* [case()] */ POP3RETR rRetrInfo;
        /* [case()] */ POP3TOP rTopInfo;
        /* [default] */  /* Empty union arm */ 
        }	;
    }	POP3RESPONSE;

typedef struct tagPOP3RESPONSE __RPC_FAR *LPPOP3RESPONSE;


EXTERN_C const IID IID_IPOP3Callback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0DF2C7E3-3435-11d0-81D0-00C04FD85AB4")
    IPOP3Callback : public ITransportCallback
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnResponse( 
            /* [in] */ LPPOP3RESPONSE pResponse) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPOP3CallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IPOP3Callback __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IPOP3Callback __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IPOP3Callback __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnTimeout )( 
            IPOP3Callback __RPC_FAR * This,
            /* [out][in] */ DWORD __RPC_FAR *pdwTimeout,
            /* [in] */ IInternetTransport __RPC_FAR *pTransport);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnLogonPrompt )( 
            IPOP3Callback __RPC_FAR * This,
            /* [out][in] */ LPINETSERVER pInetServer,
            /* [in] */ IInternetTransport __RPC_FAR *pTransport);
        
        INT ( STDMETHODCALLTYPE __RPC_FAR *OnPrompt )( 
            IPOP3Callback __RPC_FAR * This,
            /* [in] */ HRESULT hrError,
            /* [in] */ LPCTSTR pszText,
            /* [in] */ LPCTSTR pszCaption,
            /* [in] */ UINT uType,
            /* [in] */ IInternetTransport __RPC_FAR *pTransport);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnStatus )( 
            IPOP3Callback __RPC_FAR * This,
            /* [in] */ IXPSTATUS ixpstatus,
            /* [in] */ IInternetTransport __RPC_FAR *pTransport);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnError )( 
            IPOP3Callback __RPC_FAR * This,
            /* [in] */ IXPSTATUS ixpstatus,
            /* [in] */ LPIXPRESULT pResult,
            /* [in] */ IInternetTransport __RPC_FAR *pTransport);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnCommand )( 
            IPOP3Callback __RPC_FAR * This,
            /* [in] */ CMDTYPE cmdtype,
            /* [in] */ LPSTR pszLine,
            /* [in] */ HRESULT hrResponse,
            /* [in] */ IInternetTransport __RPC_FAR *pTransport);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnResponse )( 
            IPOP3Callback __RPC_FAR * This,
            /* [in] */ LPPOP3RESPONSE pResponse);
        
        END_INTERFACE
    } IPOP3CallbackVtbl;

    interface IPOP3Callback
    {
        CONST_VTBL struct IPOP3CallbackVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPOP3Callback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPOP3Callback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPOP3Callback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPOP3Callback_OnTimeout(This,pdwTimeout,pTransport)	\
    (This)->lpVtbl -> OnTimeout(This,pdwTimeout,pTransport)

#define IPOP3Callback_OnLogonPrompt(This,pInetServer,pTransport)	\
    (This)->lpVtbl -> OnLogonPrompt(This,pInetServer,pTransport)

#define IPOP3Callback_OnPrompt(This,hrError,pszText,pszCaption,uType,pTransport)	\
    (This)->lpVtbl -> OnPrompt(This,hrError,pszText,pszCaption,uType,pTransport)

#define IPOP3Callback_OnStatus(This,ixpstatus,pTransport)	\
    (This)->lpVtbl -> OnStatus(This,ixpstatus,pTransport)

#define IPOP3Callback_OnError(This,ixpstatus,pResult,pTransport)	\
    (This)->lpVtbl -> OnError(This,ixpstatus,pResult,pTransport)

#define IPOP3Callback_OnCommand(This,cmdtype,pszLine,hrResponse,pTransport)	\
    (This)->lpVtbl -> OnCommand(This,cmdtype,pszLine,hrResponse,pTransport)


#define IPOP3Callback_OnResponse(This,pResponse)	\
    (This)->lpVtbl -> OnResponse(This,pResponse)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IPOP3Callback_OnResponse_Proxy( 
    IPOP3Callback __RPC_FAR * This,
    /* [in] */ LPPOP3RESPONSE pResponse);


void __RPC_STUB IPOP3Callback_OnResponse_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPOP3Callback_INTERFACE_DEFINED__ */


#ifndef __IPOP3Transport_INTERFACE_DEFINED__
#define __IPOP3Transport_INTERFACE_DEFINED__

/* interface IPOP3Transport */
/* [object][local][helpstring][uuid] */ 

typedef 
enum tagPOP3CMDTYPE
    {	POP3CMD_GET_POPID	= 0,
	POP3CMD_GET_MARKED	= POP3CMD_GET_POPID + 1,
	POP3CMD_GET_ALL	= POP3CMD_GET_MARKED + 1
    }	POP3CMDTYPE;

typedef 
enum tagPOP3MARKTYPE
    {	POP3_MARK_FOR_TOP	= 0x1,
	POP3_MARK_FOR_RETR	= 0x2,
	POP3_MARK_FOR_DELE	= 0x4,
	POP3_MARK_FOR_UIDL	= 0x8,
	POP3_MARK_FOR_LIST	= 0x10
    }	POP3MARKTYPE;


EXTERN_C const IID IID_IPOP3Transport;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0DF2C7E4-3435-11d0-81D0-00C04FD85AB4")
    IPOP3Transport : public IInternetTransport
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InitNew( 
            /* [in] */ LPSTR pszLogFilePath,
            /* [in] */ IPOP3Callback __RPC_FAR *pCallback) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MarkItem( 
            /* [in] */ POP3MARKTYPE marktype,
            /* [in] */ DWORD dwPopId,
            /* [in] */ boolean fMarked) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CommandAUTH( 
            /* [in] */ LPSTR pszAuthType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CommandUSER( 
            /* [in] */ LPSTR pszUserName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CommandPASS( 
            /* [in] */ LPSTR pszPassword) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CommandLIST( 
            /* [in] */ POP3CMDTYPE cmdtype,
            /* [in] */ DWORD dwPopId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CommandTOP( 
            /* [in] */ POP3CMDTYPE cmdtype,
            /* [in] */ DWORD dwPopId,
            /* [in] */ DWORD cPreviewLines) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CommandQUIT( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CommandSTAT( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CommandNOOP( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CommandRSET( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CommandUIDL( 
            /* [in] */ POP3CMDTYPE cmdtype,
            /* [in] */ DWORD dwPopId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CommandDELE( 
            /* [in] */ POP3CMDTYPE cmdtype,
            /* [in] */ DWORD dwPopId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CommandRETR( 
            /* [in] */ POP3CMDTYPE cmdtype,
            /* [in] */ DWORD dwPopId) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPOP3TransportVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IPOP3Transport __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IPOP3Transport __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IPOP3Transport __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetServerInfo )( 
            IPOP3Transport __RPC_FAR * This,
            /* [out][in] */ LPINETSERVER pInetServer);
        
        IXPTYPE ( STDMETHODCALLTYPE __RPC_FAR *GetIXPType )( 
            IPOP3Transport __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsState )( 
            IPOP3Transport __RPC_FAR * This,
            /* [in] */ IXPISSTATE isstate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InetServerFromAccount )( 
            IPOP3Transport __RPC_FAR * This,
            /* [in] */ IImnAccount __RPC_FAR *pAccount,
            /* [out][in] */ LPINETSERVER pInetServer);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Connect )( 
            IPOP3Transport __RPC_FAR * This,
            /* [in] */ LPINETSERVER pInetServer,
            /* [in] */ boolean fAuthenticate,
            /* [in] */ boolean fCommandLogging);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *HandsOffCallback )( 
            IPOP3Transport __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Disconnect )( 
            IPOP3Transport __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DropConnection )( 
            IPOP3Transport __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStatus )( 
            IPOP3Transport __RPC_FAR * This,
            /* [out] */ IXPSTATUS __RPC_FAR *pCurrentStatus);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InitNew )( 
            IPOP3Transport __RPC_FAR * This,
            /* [in] */ LPSTR pszLogFilePath,
            /* [in] */ IPOP3Callback __RPC_FAR *pCallback);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MarkItem )( 
            IPOP3Transport __RPC_FAR * This,
            /* [in] */ POP3MARKTYPE marktype,
            /* [in] */ DWORD dwPopId,
            /* [in] */ boolean fMarked);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CommandAUTH )( 
            IPOP3Transport __RPC_FAR * This,
            /* [in] */ LPSTR pszAuthType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CommandUSER )( 
            IPOP3Transport __RPC_FAR * This,
            /* [in] */ LPSTR pszUserName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CommandPASS )( 
            IPOP3Transport __RPC_FAR * This,
            /* [in] */ LPSTR pszPassword);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CommandLIST )( 
            IPOP3Transport __RPC_FAR * This,
            /* [in] */ POP3CMDTYPE cmdtype,
            /* [in] */ DWORD dwPopId);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CommandTOP )( 
            IPOP3Transport __RPC_FAR * This,
            /* [in] */ POP3CMDTYPE cmdtype,
            /* [in] */ DWORD dwPopId,
            /* [in] */ DWORD cPreviewLines);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CommandQUIT )( 
            IPOP3Transport __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CommandSTAT )( 
            IPOP3Transport __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CommandNOOP )( 
            IPOP3Transport __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CommandRSET )( 
            IPOP3Transport __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CommandUIDL )( 
            IPOP3Transport __RPC_FAR * This,
            /* [in] */ POP3CMDTYPE cmdtype,
            /* [in] */ DWORD dwPopId);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CommandDELE )( 
            IPOP3Transport __RPC_FAR * This,
            /* [in] */ POP3CMDTYPE cmdtype,
            /* [in] */ DWORD dwPopId);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CommandRETR )( 
            IPOP3Transport __RPC_FAR * This,
            /* [in] */ POP3CMDTYPE cmdtype,
            /* [in] */ DWORD dwPopId);
        
        END_INTERFACE
    } IPOP3TransportVtbl;

    interface IPOP3Transport
    {
        CONST_VTBL struct IPOP3TransportVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPOP3Transport_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPOP3Transport_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPOP3Transport_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPOP3Transport_GetServerInfo(This,pInetServer)	\
    (This)->lpVtbl -> GetServerInfo(This,pInetServer)

#define IPOP3Transport_GetIXPType(This)	\
    (This)->lpVtbl -> GetIXPType(This)

#define IPOP3Transport_IsState(This,isstate)	\
    (This)->lpVtbl -> IsState(This,isstate)

#define IPOP3Transport_InetServerFromAccount(This,pAccount,pInetServer)	\
    (This)->lpVtbl -> InetServerFromAccount(This,pAccount,pInetServer)

#define IPOP3Transport_Connect(This,pInetServer,fAuthenticate,fCommandLogging)	\
    (This)->lpVtbl -> Connect(This,pInetServer,fAuthenticate,fCommandLogging)

#define IPOP3Transport_HandsOffCallback(This)	\
    (This)->lpVtbl -> HandsOffCallback(This)

#define IPOP3Transport_Disconnect(This)	\
    (This)->lpVtbl -> Disconnect(This)

#define IPOP3Transport_DropConnection(This)	\
    (This)->lpVtbl -> DropConnection(This)

#define IPOP3Transport_GetStatus(This,pCurrentStatus)	\
    (This)->lpVtbl -> GetStatus(This,pCurrentStatus)


#define IPOP3Transport_InitNew(This,pszLogFilePath,pCallback)	\
    (This)->lpVtbl -> InitNew(This,pszLogFilePath,pCallback)

#define IPOP3Transport_MarkItem(This,marktype,dwPopId,fMarked)	\
    (This)->lpVtbl -> MarkItem(This,marktype,dwPopId,fMarked)

#define IPOP3Transport_CommandAUTH(This,pszAuthType)	\
    (This)->lpVtbl -> CommandAUTH(This,pszAuthType)

#define IPOP3Transport_CommandUSER(This,pszUserName)	\
    (This)->lpVtbl -> CommandUSER(This,pszUserName)

#define IPOP3Transport_CommandPASS(This,pszPassword)	\
    (This)->lpVtbl -> CommandPASS(This,pszPassword)

#define IPOP3Transport_CommandLIST(This,cmdtype,dwPopId)	\
    (This)->lpVtbl -> CommandLIST(This,cmdtype,dwPopId)

#define IPOP3Transport_CommandTOP(This,cmdtype,dwPopId,cPreviewLines)	\
    (This)->lpVtbl -> CommandTOP(This,cmdtype,dwPopId,cPreviewLines)

#define IPOP3Transport_CommandQUIT(This)	\
    (This)->lpVtbl -> CommandQUIT(This)

#define IPOP3Transport_CommandSTAT(This)	\
    (This)->lpVtbl -> CommandSTAT(This)

#define IPOP3Transport_CommandNOOP(This)	\
    (This)->lpVtbl -> CommandNOOP(This)

#define IPOP3Transport_CommandRSET(This)	\
    (This)->lpVtbl -> CommandRSET(This)

#define IPOP3Transport_CommandUIDL(This,cmdtype,dwPopId)	\
    (This)->lpVtbl -> CommandUIDL(This,cmdtype,dwPopId)

#define IPOP3Transport_CommandDELE(This,cmdtype,dwPopId)	\
    (This)->lpVtbl -> CommandDELE(This,cmdtype,dwPopId)

#define IPOP3Transport_CommandRETR(This,cmdtype,dwPopId)	\
    (This)->lpVtbl -> CommandRETR(This,cmdtype,dwPopId)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IPOP3Transport_InitNew_Proxy( 
    IPOP3Transport __RPC_FAR * This,
    /* [in] */ LPSTR pszLogFilePath,
    /* [in] */ IPOP3Callback __RPC_FAR *pCallback);


void __RPC_STUB IPOP3Transport_InitNew_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPOP3Transport_MarkItem_Proxy( 
    IPOP3Transport __RPC_FAR * This,
    /* [in] */ POP3MARKTYPE marktype,
    /* [in] */ DWORD dwPopId,
    /* [in] */ boolean fMarked);


void __RPC_STUB IPOP3Transport_MarkItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPOP3Transport_CommandAUTH_Proxy( 
    IPOP3Transport __RPC_FAR * This,
    /* [in] */ LPSTR pszAuthType);


void __RPC_STUB IPOP3Transport_CommandAUTH_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPOP3Transport_CommandUSER_Proxy( 
    IPOP3Transport __RPC_FAR * This,
    /* [in] */ LPSTR pszUserName);


void __RPC_STUB IPOP3Transport_CommandUSER_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPOP3Transport_CommandPASS_Proxy( 
    IPOP3Transport __RPC_FAR * This,
    /* [in] */ LPSTR pszPassword);


void __RPC_STUB IPOP3Transport_CommandPASS_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPOP3Transport_CommandLIST_Proxy( 
    IPOP3Transport __RPC_FAR * This,
    /* [in] */ POP3CMDTYPE cmdtype,
    /* [in] */ DWORD dwPopId);


void __RPC_STUB IPOP3Transport_CommandLIST_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPOP3Transport_CommandTOP_Proxy( 
    IPOP3Transport __RPC_FAR * This,
    /* [in] */ POP3CMDTYPE cmdtype,
    /* [in] */ DWORD dwPopId,
    /* [in] */ DWORD cPreviewLines);


void __RPC_STUB IPOP3Transport_CommandTOP_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPOP3Transport_CommandQUIT_Proxy( 
    IPOP3Transport __RPC_FAR * This);


void __RPC_STUB IPOP3Transport_CommandQUIT_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPOP3Transport_CommandSTAT_Proxy( 
    IPOP3Transport __RPC_FAR * This);


void __RPC_STUB IPOP3Transport_CommandSTAT_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPOP3Transport_CommandNOOP_Proxy( 
    IPOP3Transport __RPC_FAR * This);


void __RPC_STUB IPOP3Transport_CommandNOOP_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPOP3Transport_CommandRSET_Proxy( 
    IPOP3Transport __RPC_FAR * This);


void __RPC_STUB IPOP3Transport_CommandRSET_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPOP3Transport_CommandUIDL_Proxy( 
    IPOP3Transport __RPC_FAR * This,
    /* [in] */ POP3CMDTYPE cmdtype,
    /* [in] */ DWORD dwPopId);


void __RPC_STUB IPOP3Transport_CommandUIDL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPOP3Transport_CommandDELE_Proxy( 
    IPOP3Transport __RPC_FAR * This,
    /* [in] */ POP3CMDTYPE cmdtype,
    /* [in] */ DWORD dwPopId);


void __RPC_STUB IPOP3Transport_CommandDELE_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPOP3Transport_CommandRETR_Proxy( 
    IPOP3Transport __RPC_FAR * This,
    /* [in] */ POP3CMDTYPE cmdtype,
    /* [in] */ DWORD dwPopId);


void __RPC_STUB IPOP3Transport_CommandRETR_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPOP3Transport_INTERFACE_DEFINED__ */


#ifndef __INNTPCallback_INTERFACE_DEFINED__
#define __INNTPCallback_INTERFACE_DEFINED__

/* interface INNTPCallback */
/* [object][local][helpstring][uuid] */ 

typedef 
enum tagNNTPSTATE
    {	NS_DISCONNECTED	= 0,
	NS_CONNECT	= NS_DISCONNECTED + 1,
	NS_AUTHINFO	= NS_CONNECT + 1,
	NS_POST	= NS_AUTHINFO + 1,
	NS_IDLE	= NS_POST + 1,
	NS_LIST	= NS_IDLE + 1,
	NS_LISTGROUP	= NS_LIST + 1,
	NS_NEWGROUPS	= NS_LISTGROUP + 1,
	NS_GROUP	= NS_NEWGROUPS + 1,
	NS_LAST	= NS_GROUP + 1,
	NS_NEXT	= NS_LAST + 1,
	NS_STAT	= NS_NEXT + 1,
	NS_ARTICLE	= NS_STAT + 1,
	NS_HEAD	= NS_ARTICLE + 1,
	NS_BODY	= NS_HEAD + 1,
	NS_DATE	= NS_BODY + 1,
	NS_MODE	= NS_DATE + 1,
	NS_QUIT	= NS_MODE + 1,
	NS_HEADERS	= NS_QUIT + 1,
	NS_XHDR	= NS_HEADERS + 1
    }	NNTPSTATE;

typedef struct tagNNTPGROUP
    {
    DWORD dwCount;
    DWORD dwFirst;
    DWORD dwLast;
    LPSTR pszGroup;
    }	NNTPGROUP;

typedef struct tagNNTPGROUP __RPC_FAR *LPNNTPGROUP;

typedef struct tagNNTPNEXT
    {
    DWORD dwArticleNum;
    LPSTR pszMessageId;
    }	NNTPNEXT;

typedef struct tagNNTPNEXT __RPC_FAR *LPNNTPNEXT;

typedef struct tagNNTPARTICLE
    {
    DWORD dwArticleNum;
    LPSTR pszMessageId;
    LPSTR pszLines;
    ULONG cbLines;
    ULONG cLines;
    DWORD dwReserved;
    }	NNTPARTICLE;

typedef struct tagNNTPARTICLE __RPC_FAR *LPNNTPARTICLE;

typedef struct tagNNTPLIST
    {
    DWORD cLines;
    LPSTR __RPC_FAR *rgszLines;
    }	NNTPLIST;

typedef struct tagNNTPLIST __RPC_FAR *LPNNTPLIST;

typedef struct tagNNTPLISTGROUP
    {
    DWORD cArticles;
    DWORD __RPC_FAR *rgArticles;
    }	NNTPLISTGROUP;

typedef struct tagNNTPLISTGROUP __RPC_FAR *LPNNTPLISTGROUP;

typedef struct tagNNTPHEADER
    {
    DWORD dwArticleNum;
    LPSTR pszSubject;
    LPSTR pszFrom;
    LPSTR pszDate;
    LPSTR pszMessageId;
    LPSTR pszReferences;
    DWORD dwBytes;
    DWORD dwLines;
    LPSTR pszXref;
    }	NNTPHEADER;

typedef struct tagNNTPHEADER __RPC_FAR *LPNNTPHEADER;

typedef struct tagNNTPHEADERRESP
    {
    DWORD cHeaders;
    LPNNTPHEADER rgHeaders;
    BOOL fSupportsXRef;
    DWORD_PTR dwReserved;
    }	NNTPHEADERRESP;

typedef struct tagNNTPHEADERRESP __RPC_FAR *LPNNTPHEADERRESP;

typedef struct tagNNTPXHDR
    {
    DWORD dwArticleNum;
    LPSTR pszHeader;
    }	NNTPXHDR;

typedef struct tagNNTPXHDR __RPC_FAR *LPNNTPXHDR;

typedef struct tagNNTPXHDRRESP
    {
    DWORD cHeaders;
    LPNNTPXHDR rgHeaders;
    DWORD_PTR dwReserved;
    }	NNTPXHDRRESP;

typedef struct tagNNTPXHDRRESP __RPC_FAR *LPNNTPXHDRRESP;

typedef struct tagNNTPRESPONSE
    {
    NNTPSTATE state;
    BOOL fMustRelease;
    BOOL fDone;
    IXPRESULT rIxpResult;
    INNTPTransport __RPC_FAR *pTransport;
    /* [switch_is][switch_type] */ union 
        {
        /* [case()] */ NNTPGROUP rGroup;
        /* [case()] */ NNTPNEXT rLast;
        /* [case()] */ NNTPNEXT rNext;
        /* [case()] */ NNTPNEXT rStat;
        /* [case()] */ NNTPARTICLE rArticle;
        /* [case()] */ NNTPARTICLE rHead;
        /* [case()] */ NNTPARTICLE rBody;
        /* [case()] */ NNTPLIST rList;
        /* [case()] */ NNTPLISTGROUP rListGroup;
        /* [case()] */ NNTPLIST rNewgroups;
        /* [case()] */ SYSTEMTIME rDate;
        /* [case()] */ NNTPHEADERRESP rHeaders;
        /* [case()] */ NNTPXHDRRESP rXhdr;
        /* [default] */  /* Empty union arm */ 
        }	;
    }	NNTPRESPONSE;

typedef struct tagNNTPRESPONSE __RPC_FAR *LPNNTPRESPONSE;


EXTERN_C const IID IID_INNTPCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0DF2C7E6-3435-11d0-81D0-00C04FD85AB4")
    INNTPCallback : public ITransportCallback
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnResponse( 
            /* [in] */ LPNNTPRESPONSE pResponse) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INNTPCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            INNTPCallback __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            INNTPCallback __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            INNTPCallback __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnTimeout )( 
            INNTPCallback __RPC_FAR * This,
            /* [out][in] */ DWORD __RPC_FAR *pdwTimeout,
            /* [in] */ IInternetTransport __RPC_FAR *pTransport);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnLogonPrompt )( 
            INNTPCallback __RPC_FAR * This,
            /* [out][in] */ LPINETSERVER pInetServer,
            /* [in] */ IInternetTransport __RPC_FAR *pTransport);
        
        INT ( STDMETHODCALLTYPE __RPC_FAR *OnPrompt )( 
            INNTPCallback __RPC_FAR * This,
            /* [in] */ HRESULT hrError,
            /* [in] */ LPCTSTR pszText,
            /* [in] */ LPCTSTR pszCaption,
            /* [in] */ UINT uType,
            /* [in] */ IInternetTransport __RPC_FAR *pTransport);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnStatus )( 
            INNTPCallback __RPC_FAR * This,
            /* [in] */ IXPSTATUS ixpstatus,
            /* [in] */ IInternetTransport __RPC_FAR *pTransport);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnError )( 
            INNTPCallback __RPC_FAR * This,
            /* [in] */ IXPSTATUS ixpstatus,
            /* [in] */ LPIXPRESULT pResult,
            /* [in] */ IInternetTransport __RPC_FAR *pTransport);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnCommand )( 
            INNTPCallback __RPC_FAR * This,
            /* [in] */ CMDTYPE cmdtype,
            /* [in] */ LPSTR pszLine,
            /* [in] */ HRESULT hrResponse,
            /* [in] */ IInternetTransport __RPC_FAR *pTransport);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnResponse )( 
            INNTPCallback __RPC_FAR * This,
            /* [in] */ LPNNTPRESPONSE pResponse);
        
        END_INTERFACE
    } INNTPCallbackVtbl;

    interface INNTPCallback
    {
        CONST_VTBL struct INNTPCallbackVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INNTPCallback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INNTPCallback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INNTPCallback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INNTPCallback_OnTimeout(This,pdwTimeout,pTransport)	\
    (This)->lpVtbl -> OnTimeout(This,pdwTimeout,pTransport)

#define INNTPCallback_OnLogonPrompt(This,pInetServer,pTransport)	\
    (This)->lpVtbl -> OnLogonPrompt(This,pInetServer,pTransport)

#define INNTPCallback_OnPrompt(This,hrError,pszText,pszCaption,uType,pTransport)	\
    (This)->lpVtbl -> OnPrompt(This,hrError,pszText,pszCaption,uType,pTransport)

#define INNTPCallback_OnStatus(This,ixpstatus,pTransport)	\
    (This)->lpVtbl -> OnStatus(This,ixpstatus,pTransport)

#define INNTPCallback_OnError(This,ixpstatus,pResult,pTransport)	\
    (This)->lpVtbl -> OnError(This,ixpstatus,pResult,pTransport)

#define INNTPCallback_OnCommand(This,cmdtype,pszLine,hrResponse,pTransport)	\
    (This)->lpVtbl -> OnCommand(This,cmdtype,pszLine,hrResponse,pTransport)


#define INNTPCallback_OnResponse(This,pResponse)	\
    (This)->lpVtbl -> OnResponse(This,pResponse)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INNTPCallback_OnResponse_Proxy( 
    INNTPCallback __RPC_FAR * This,
    /* [in] */ LPNNTPRESPONSE pResponse);


void __RPC_STUB INNTPCallback_OnResponse_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INNTPCallback_INTERFACE_DEFINED__ */


#ifndef __INNTPTransport_INTERFACE_DEFINED__
#define __INNTPTransport_INTERFACE_DEFINED__

/* interface INNTPTransport */
/* [object][local][helpstring][uuid] */ 

typedef 
enum tagAUTHTYPE
    {	AUTHTYPE_USERPASS	= 0,
	AUTHTYPE_SIMPLE	= AUTHTYPE_USERPASS + 1,
	AUTHTYPE_SASL	= AUTHTYPE_SIMPLE + 1
    }	AUTHTYPE;

typedef struct tagNNTPAUTHINFO
    {
    AUTHTYPE authtype;
    LPSTR pszUser;
    LPSTR pszPass;
    }	NNTPAUTHINFO;

typedef struct tagNNTPAUTHINFO __RPC_FAR *LPNNTPAUTHINFO;

typedef 
enum tagARTICLEIDTYPE
    {	AID_MSGID	= 0,
	AID_ARTICLENUM	= AID_MSGID + 1
    }	ARTICLEIDTYPE;

typedef struct ARTICLEID
    {
    ARTICLEIDTYPE idType;
    /* [switch_is][switch_type] */ union 
        {
        /* [case()] */ LPSTR pszMessageId;
        /* [case()] */ DWORD_PTR dwArticleNum;
        /* [default] */  /* Empty union arm */ 
        }	;
    }	ARTICLEID;

typedef struct ARTICLEID __RPC_FAR *LPARTICLEID;

typedef struct tagNNTPMESSAGE
    {
    ULONG cbSize;
    LPSTREAM pstmMsg;
    }	NNTPMESSAGE;

typedef struct tagNNTPMESSAGE __RPC_FAR *LPNNTPMESSAGE;

typedef 
enum tagRANGETYPE
    {	RT_SINGLE	= 0,
	RT_RANGE	= RT_SINGLE + 1
    }	RANGETYPE;

typedef struct tagRANGE
    {
    RANGETYPE idType;
    DWORD dwFirst;
    DWORD dwLast;
    }	RANGE;

typedef struct tagRANGE __RPC_FAR *LPRANGE;


EXTERN_C const IID IID_INNTPTransport;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0DF2C7E5-3435-11d0-81D0-00C04FD85AB4")
    INNTPTransport : public IInternetTransport
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InitNew( 
            /* [in] */ LPSTR pszLogFilePath,
            /* [in] */ INNTPCallback __RPC_FAR *pCallback) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CommandAUTHINFO( 
            /* [in] */ LPNNTPAUTHINFO pAuthInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CommandGROUP( 
            /* [in] */ LPSTR pszGroup) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CommandLAST( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CommandNEXT( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CommandSTAT( 
            /* [in] */ LPARTICLEID pArticleId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CommandARTICLE( 
            /* [in] */ LPARTICLEID pArticleId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CommandHEAD( 
            /* [in] */ LPARTICLEID pArticleId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CommandBODY( 
            /* [in] */ LPARTICLEID pArticleId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CommandPOST( 
            /* [in] */ LPNNTPMESSAGE pMessage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CommandLIST( 
            /* [in] */ LPSTR pszArgs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CommandLISTGROUP( 
            /* [in] */ LPSTR pszGroup) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CommandNEWGROUPS( 
            /* [in] */ SYSTEMTIME __RPC_FAR *pstLast,
            /* [in] */ LPSTR pszDist) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CommandDATE( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CommandMODE( 
            /* [in] */ LPSTR pszMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CommandXHDR( 
            /* [in] */ LPSTR pszHeader,
            /* [in] */ LPRANGE pRange,
            /* [in] */ LPSTR pszMessageId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CommandQUIT( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetHeaders( 
            /* [in] */ LPRANGE pRange) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReleaseResponse( 
            /* [in] */ LPNNTPRESPONSE pResponse) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INNTPTransportVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            INNTPTransport __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            INNTPTransport __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            INNTPTransport __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetServerInfo )( 
            INNTPTransport __RPC_FAR * This,
            /* [out][in] */ LPINETSERVER pInetServer);
        
        IXPTYPE ( STDMETHODCALLTYPE __RPC_FAR *GetIXPType )( 
            INNTPTransport __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsState )( 
            INNTPTransport __RPC_FAR * This,
            /* [in] */ IXPISSTATE isstate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InetServerFromAccount )( 
            INNTPTransport __RPC_FAR * This,
            /* [in] */ IImnAccount __RPC_FAR *pAccount,
            /* [out][in] */ LPINETSERVER pInetServer);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Connect )( 
            INNTPTransport __RPC_FAR * This,
            /* [in] */ LPINETSERVER pInetServer,
            /* [in] */ boolean fAuthenticate,
            /* [in] */ boolean fCommandLogging);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *HandsOffCallback )( 
            INNTPTransport __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Disconnect )( 
            INNTPTransport __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DropConnection )( 
            INNTPTransport __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStatus )( 
            INNTPTransport __RPC_FAR * This,
            /* [out] */ IXPSTATUS __RPC_FAR *pCurrentStatus);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InitNew )( 
            INNTPTransport __RPC_FAR * This,
            /* [in] */ LPSTR pszLogFilePath,
            /* [in] */ INNTPCallback __RPC_FAR *pCallback);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CommandAUTHINFO )( 
            INNTPTransport __RPC_FAR * This,
            /* [in] */ LPNNTPAUTHINFO pAuthInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CommandGROUP )( 
            INNTPTransport __RPC_FAR * This,
            /* [in] */ LPSTR pszGroup);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CommandLAST )( 
            INNTPTransport __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CommandNEXT )( 
            INNTPTransport __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CommandSTAT )( 
            INNTPTransport __RPC_FAR * This,
            /* [in] */ LPARTICLEID pArticleId);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CommandARTICLE )( 
            INNTPTransport __RPC_FAR * This,
            /* [in] */ LPARTICLEID pArticleId);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CommandHEAD )( 
            INNTPTransport __RPC_FAR * This,
            /* [in] */ LPARTICLEID pArticleId);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CommandBODY )( 
            INNTPTransport __RPC_FAR * This,
            /* [in] */ LPARTICLEID pArticleId);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CommandPOST )( 
            INNTPTransport __RPC_FAR * This,
            /* [in] */ LPNNTPMESSAGE pMessage);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CommandLIST )( 
            INNTPTransport __RPC_FAR * This,
            /* [in] */ LPSTR pszArgs);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CommandLISTGROUP )( 
            INNTPTransport __RPC_FAR * This,
            /* [in] */ LPSTR pszGroup);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CommandNEWGROUPS )( 
            INNTPTransport __RPC_FAR * This,
            /* [in] */ SYSTEMTIME __RPC_FAR *pstLast,
            /* [in] */ LPSTR pszDist);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CommandDATE )( 
            INNTPTransport __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CommandMODE )( 
            INNTPTransport __RPC_FAR * This,
            /* [in] */ LPSTR pszMode);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CommandXHDR )( 
            INNTPTransport __RPC_FAR * This,
            /* [in] */ LPSTR pszHeader,
            /* [in] */ LPRANGE pRange,
            /* [in] */ LPSTR pszMessageId);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CommandQUIT )( 
            INNTPTransport __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetHeaders )( 
            INNTPTransport __RPC_FAR * This,
            /* [in] */ LPRANGE pRange);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReleaseResponse )( 
            INNTPTransport __RPC_FAR * This,
            /* [in] */ LPNNTPRESPONSE pResponse);
        
        END_INTERFACE
    } INNTPTransportVtbl;

    interface INNTPTransport
    {
        CONST_VTBL struct INNTPTransportVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INNTPTransport_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INNTPTransport_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INNTPTransport_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INNTPTransport_GetServerInfo(This,pInetServer)	\
    (This)->lpVtbl -> GetServerInfo(This,pInetServer)

#define INNTPTransport_GetIXPType(This)	\
    (This)->lpVtbl -> GetIXPType(This)

#define INNTPTransport_IsState(This,isstate)	\
    (This)->lpVtbl -> IsState(This,isstate)

#define INNTPTransport_InetServerFromAccount(This,pAccount,pInetServer)	\
    (This)->lpVtbl -> InetServerFromAccount(This,pAccount,pInetServer)

#define INNTPTransport_Connect(This,pInetServer,fAuthenticate,fCommandLogging)	\
    (This)->lpVtbl -> Connect(This,pInetServer,fAuthenticate,fCommandLogging)

#define INNTPTransport_HandsOffCallback(This)	\
    (This)->lpVtbl -> HandsOffCallback(This)

#define INNTPTransport_Disconnect(This)	\
    (This)->lpVtbl -> Disconnect(This)

#define INNTPTransport_DropConnection(This)	\
    (This)->lpVtbl -> DropConnection(This)

#define INNTPTransport_GetStatus(This,pCurrentStatus)	\
    (This)->lpVtbl -> GetStatus(This,pCurrentStatus)


#define INNTPTransport_InitNew(This,pszLogFilePath,pCallback)	\
    (This)->lpVtbl -> InitNew(This,pszLogFilePath,pCallback)

#define INNTPTransport_CommandAUTHINFO(This,pAuthInfo)	\
    (This)->lpVtbl -> CommandAUTHINFO(This,pAuthInfo)

#define INNTPTransport_CommandGROUP(This,pszGroup)	\
    (This)->lpVtbl -> CommandGROUP(This,pszGroup)

#define INNTPTransport_CommandLAST(This)	\
    (This)->lpVtbl -> CommandLAST(This)

#define INNTPTransport_CommandNEXT(This)	\
    (This)->lpVtbl -> CommandNEXT(This)

#define INNTPTransport_CommandSTAT(This,pArticleId)	\
    (This)->lpVtbl -> CommandSTAT(This,pArticleId)

#define INNTPTransport_CommandARTICLE(This,pArticleId)	\
    (This)->lpVtbl -> CommandARTICLE(This,pArticleId)

#define INNTPTransport_CommandHEAD(This,pArticleId)	\
    (This)->lpVtbl -> CommandHEAD(This,pArticleId)

#define INNTPTransport_CommandBODY(This,pArticleId)	\
    (This)->lpVtbl -> CommandBODY(This,pArticleId)

#define INNTPTransport_CommandPOST(This,pMessage)	\
    (This)->lpVtbl -> CommandPOST(This,pMessage)

#define INNTPTransport_CommandLIST(This,pszArgs)	\
    (This)->lpVtbl -> CommandLIST(This,pszArgs)

#define INNTPTransport_CommandLISTGROUP(This,pszGroup)	\
    (This)->lpVtbl -> CommandLISTGROUP(This,pszGroup)

#define INNTPTransport_CommandNEWGROUPS(This,pstLast,pszDist)	\
    (This)->lpVtbl -> CommandNEWGROUPS(This,pstLast,pszDist)

#define INNTPTransport_CommandDATE(This)	\
    (This)->lpVtbl -> CommandDATE(This)

#define INNTPTransport_CommandMODE(This,pszMode)	\
    (This)->lpVtbl -> CommandMODE(This,pszMode)

#define INNTPTransport_CommandXHDR(This,pszHeader,pRange,pszMessageId)	\
    (This)->lpVtbl -> CommandXHDR(This,pszHeader,pRange,pszMessageId)

#define INNTPTransport_CommandQUIT(This)	\
    (This)->lpVtbl -> CommandQUIT(This)

#define INNTPTransport_GetHeaders(This,pRange)	\
    (This)->lpVtbl -> GetHeaders(This,pRange)

#define INNTPTransport_ReleaseResponse(This,pResponse)	\
    (This)->lpVtbl -> ReleaseResponse(This,pResponse)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INNTPTransport_InitNew_Proxy( 
    INNTPTransport __RPC_FAR * This,
    /* [in] */ LPSTR pszLogFilePath,
    /* [in] */ INNTPCallback __RPC_FAR *pCallback);


void __RPC_STUB INNTPTransport_InitNew_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INNTPTransport_CommandAUTHINFO_Proxy( 
    INNTPTransport __RPC_FAR * This,
    /* [in] */ LPNNTPAUTHINFO pAuthInfo);


void __RPC_STUB INNTPTransport_CommandAUTHINFO_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INNTPTransport_CommandGROUP_Proxy( 
    INNTPTransport __RPC_FAR * This,
    /* [in] */ LPSTR pszGroup);


void __RPC_STUB INNTPTransport_CommandGROUP_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INNTPTransport_CommandLAST_Proxy( 
    INNTPTransport __RPC_FAR * This);


void __RPC_STUB INNTPTransport_CommandLAST_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INNTPTransport_CommandNEXT_Proxy( 
    INNTPTransport __RPC_FAR * This);


void __RPC_STUB INNTPTransport_CommandNEXT_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INNTPTransport_CommandSTAT_Proxy( 
    INNTPTransport __RPC_FAR * This,
    /* [in] */ LPARTICLEID pArticleId);


void __RPC_STUB INNTPTransport_CommandSTAT_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INNTPTransport_CommandARTICLE_Proxy( 
    INNTPTransport __RPC_FAR * This,
    /* [in] */ LPARTICLEID pArticleId);


void __RPC_STUB INNTPTransport_CommandARTICLE_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INNTPTransport_CommandHEAD_Proxy( 
    INNTPTransport __RPC_FAR * This,
    /* [in] */ LPARTICLEID pArticleId);


void __RPC_STUB INNTPTransport_CommandHEAD_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INNTPTransport_CommandBODY_Proxy( 
    INNTPTransport __RPC_FAR * This,
    /* [in] */ LPARTICLEID pArticleId);


void __RPC_STUB INNTPTransport_CommandBODY_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INNTPTransport_CommandPOST_Proxy( 
    INNTPTransport __RPC_FAR * This,
    /* [in] */ LPNNTPMESSAGE pMessage);


void __RPC_STUB INNTPTransport_CommandPOST_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INNTPTransport_CommandLIST_Proxy( 
    INNTPTransport __RPC_FAR * This,
    /* [in] */ LPSTR pszArgs);


void __RPC_STUB INNTPTransport_CommandLIST_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INNTPTransport_CommandLISTGROUP_Proxy( 
    INNTPTransport __RPC_FAR * This,
    /* [in] */ LPSTR pszGroup);


void __RPC_STUB INNTPTransport_CommandLISTGROUP_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INNTPTransport_CommandNEWGROUPS_Proxy( 
    INNTPTransport __RPC_FAR * This,
    /* [in] */ SYSTEMTIME __RPC_FAR *pstLast,
    /* [in] */ LPSTR pszDist);


void __RPC_STUB INNTPTransport_CommandNEWGROUPS_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INNTPTransport_CommandDATE_Proxy( 
    INNTPTransport __RPC_FAR * This);


void __RPC_STUB INNTPTransport_CommandDATE_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INNTPTransport_CommandMODE_Proxy( 
    INNTPTransport __RPC_FAR * This,
    /* [in] */ LPSTR pszMode);


void __RPC_STUB INNTPTransport_CommandMODE_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INNTPTransport_CommandXHDR_Proxy( 
    INNTPTransport __RPC_FAR * This,
    /* [in] */ LPSTR pszHeader,
    /* [in] */ LPRANGE pRange,
    /* [in] */ LPSTR pszMessageId);


void __RPC_STUB INNTPTransport_CommandXHDR_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INNTPTransport_CommandQUIT_Proxy( 
    INNTPTransport __RPC_FAR * This);


void __RPC_STUB INNTPTransport_CommandQUIT_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INNTPTransport_GetHeaders_Proxy( 
    INNTPTransport __RPC_FAR * This,
    /* [in] */ LPRANGE pRange);


void __RPC_STUB INNTPTransport_GetHeaders_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INNTPTransport_ReleaseResponse_Proxy( 
    INNTPTransport __RPC_FAR * This,
    /* [in] */ LPNNTPRESPONSE pResponse);


void __RPC_STUB INNTPTransport_ReleaseResponse_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INNTPTransport_INTERFACE_DEFINED__ */


#ifndef __INNTPTransport2_INTERFACE_DEFINED__
#define __INNTPTransport2_INTERFACE_DEFINED__

/* interface INNTPTransport2 */
/* [object][local][helpstring][uuid] */ 


EXTERN_C const IID IID_INNTPTransport2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0DF2C7ED-3435-11d0-81D0-00C04FD85AB4")
    INNTPTransport2 : public INNTPTransport
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetWindow( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ResetWindow( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INNTPTransport2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            INNTPTransport2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            INNTPTransport2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            INNTPTransport2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetServerInfo )( 
            INNTPTransport2 __RPC_FAR * This,
            /* [out][in] */ LPINETSERVER pInetServer);
        
        IXPTYPE ( STDMETHODCALLTYPE __RPC_FAR *GetIXPType )( 
            INNTPTransport2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsState )( 
            INNTPTransport2 __RPC_FAR * This,
            /* [in] */ IXPISSTATE isstate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InetServerFromAccount )( 
            INNTPTransport2 __RPC_FAR * This,
            /* [in] */ IImnAccount __RPC_FAR *pAccount,
            /* [out][in] */ LPINETSERVER pInetServer);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Connect )( 
            INNTPTransport2 __RPC_FAR * This,
            /* [in] */ LPINETSERVER pInetServer,
            /* [in] */ boolean fAuthenticate,
            /* [in] */ boolean fCommandLogging);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *HandsOffCallback )( 
            INNTPTransport2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Disconnect )( 
            INNTPTransport2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DropConnection )( 
            INNTPTransport2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStatus )( 
            INNTPTransport2 __RPC_FAR * This,
            /* [out] */ IXPSTATUS __RPC_FAR *pCurrentStatus);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InitNew )( 
            INNTPTransport2 __RPC_FAR * This,
            /* [in] */ LPSTR pszLogFilePath,
            /* [in] */ INNTPCallback __RPC_FAR *pCallback);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CommandAUTHINFO )( 
            INNTPTransport2 __RPC_FAR * This,
            /* [in] */ LPNNTPAUTHINFO pAuthInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CommandGROUP )( 
            INNTPTransport2 __RPC_FAR * This,
            /* [in] */ LPSTR pszGroup);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CommandLAST )( 
            INNTPTransport2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CommandNEXT )( 
            INNTPTransport2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CommandSTAT )( 
            INNTPTransport2 __RPC_FAR * This,
            /* [in] */ LPARTICLEID pArticleId);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CommandARTICLE )( 
            INNTPTransport2 __RPC_FAR * This,
            /* [in] */ LPARTICLEID pArticleId);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CommandHEAD )( 
            INNTPTransport2 __RPC_FAR * This,
            /* [in] */ LPARTICLEID pArticleId);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CommandBODY )( 
            INNTPTransport2 __RPC_FAR * This,
            /* [in] */ LPARTICLEID pArticleId);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CommandPOST )( 
            INNTPTransport2 __RPC_FAR * This,
            /* [in] */ LPNNTPMESSAGE pMessage);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CommandLIST )( 
            INNTPTransport2 __RPC_FAR * This,
            /* [in] */ LPSTR pszArgs);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CommandLISTGROUP )( 
            INNTPTransport2 __RPC_FAR * This,
            /* [in] */ LPSTR pszGroup);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CommandNEWGROUPS )( 
            INNTPTransport2 __RPC_FAR * This,
            /* [in] */ SYSTEMTIME __RPC_FAR *pstLast,
            /* [in] */ LPSTR pszDist);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CommandDATE )( 
            INNTPTransport2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CommandMODE )( 
            INNTPTransport2 __RPC_FAR * This,
            /* [in] */ LPSTR pszMode);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CommandXHDR )( 
            INNTPTransport2 __RPC_FAR * This,
            /* [in] */ LPSTR pszHeader,
            /* [in] */ LPRANGE pRange,
            /* [in] */ LPSTR pszMessageId);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CommandQUIT )( 
            INNTPTransport2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetHeaders )( 
            INNTPTransport2 __RPC_FAR * This,
            /* [in] */ LPRANGE pRange);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReleaseResponse )( 
            INNTPTransport2 __RPC_FAR * This,
            /* [in] */ LPNNTPRESPONSE pResponse);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetWindow )( 
            INNTPTransport2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ResetWindow )( 
            INNTPTransport2 __RPC_FAR * This);
        
        END_INTERFACE
    } INNTPTransport2Vtbl;

    interface INNTPTransport2
    {
        CONST_VTBL struct INNTPTransport2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INNTPTransport2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INNTPTransport2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INNTPTransport2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INNTPTransport2_GetServerInfo(This,pInetServer)	\
    (This)->lpVtbl -> GetServerInfo(This,pInetServer)

#define INNTPTransport2_GetIXPType(This)	\
    (This)->lpVtbl -> GetIXPType(This)

#define INNTPTransport2_IsState(This,isstate)	\
    (This)->lpVtbl -> IsState(This,isstate)

#define INNTPTransport2_InetServerFromAccount(This,pAccount,pInetServer)	\
    (This)->lpVtbl -> InetServerFromAccount(This,pAccount,pInetServer)

#define INNTPTransport2_Connect(This,pInetServer,fAuthenticate,fCommandLogging)	\
    (This)->lpVtbl -> Connect(This,pInetServer,fAuthenticate,fCommandLogging)

#define INNTPTransport2_HandsOffCallback(This)	\
    (This)->lpVtbl -> HandsOffCallback(This)

#define INNTPTransport2_Disconnect(This)	\
    (This)->lpVtbl -> Disconnect(This)

#define INNTPTransport2_DropConnection(This)	\
    (This)->lpVtbl -> DropConnection(This)

#define INNTPTransport2_GetStatus(This,pCurrentStatus)	\
    (This)->lpVtbl -> GetStatus(This,pCurrentStatus)


#define INNTPTransport2_InitNew(This,pszLogFilePath,pCallback)	\
    (This)->lpVtbl -> InitNew(This,pszLogFilePath,pCallback)

#define INNTPTransport2_CommandAUTHINFO(This,pAuthInfo)	\
    (This)->lpVtbl -> CommandAUTHINFO(This,pAuthInfo)

#define INNTPTransport2_CommandGROUP(This,pszGroup)	\
    (This)->lpVtbl -> CommandGROUP(This,pszGroup)

#define INNTPTransport2_CommandLAST(This)	\
    (This)->lpVtbl -> CommandLAST(This)

#define INNTPTransport2_CommandNEXT(This)	\
    (This)->lpVtbl -> CommandNEXT(This)

#define INNTPTransport2_CommandSTAT(This,pArticleId)	\
    (This)->lpVtbl -> CommandSTAT(This,pArticleId)

#define INNTPTransport2_CommandARTICLE(This,pArticleId)	\
    (This)->lpVtbl -> CommandARTICLE(This,pArticleId)

#define INNTPTransport2_CommandHEAD(This,pArticleId)	\
    (This)->lpVtbl -> CommandHEAD(This,pArticleId)

#define INNTPTransport2_CommandBODY(This,pArticleId)	\
    (This)->lpVtbl -> CommandBODY(This,pArticleId)

#define INNTPTransport2_CommandPOST(This,pMessage)	\
    (This)->lpVtbl -> CommandPOST(This,pMessage)

#define INNTPTransport2_CommandLIST(This,pszArgs)	\
    (This)->lpVtbl -> CommandLIST(This,pszArgs)

#define INNTPTransport2_CommandLISTGROUP(This,pszGroup)	\
    (This)->lpVtbl -> CommandLISTGROUP(This,pszGroup)

#define INNTPTransport2_CommandNEWGROUPS(This,pstLast,pszDist)	\
    (This)->lpVtbl -> CommandNEWGROUPS(This,pstLast,pszDist)

#define INNTPTransport2_CommandDATE(This)	\
    (This)->lpVtbl -> CommandDATE(This)

#define INNTPTransport2_CommandMODE(This,pszMode)	\
    (This)->lpVtbl -> CommandMODE(This,pszMode)

#define INNTPTransport2_CommandXHDR(This,pszHeader,pRange,pszMessageId)	\
    (This)->lpVtbl -> CommandXHDR(This,pszHeader,pRange,pszMessageId)

#define INNTPTransport2_CommandQUIT(This)	\
    (This)->lpVtbl -> CommandQUIT(This)

#define INNTPTransport2_GetHeaders(This,pRange)	\
    (This)->lpVtbl -> GetHeaders(This,pRange)

#define INNTPTransport2_ReleaseResponse(This,pResponse)	\
    (This)->lpVtbl -> ReleaseResponse(This,pResponse)


#define INNTPTransport2_SetWindow(This)	\
    (This)->lpVtbl -> SetWindow(This)

#define INNTPTransport2_ResetWindow(This)	\
    (This)->lpVtbl -> ResetWindow(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INNTPTransport2_SetWindow_Proxy( 
    INNTPTransport2 __RPC_FAR * This);


void __RPC_STUB INNTPTransport2_SetWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INNTPTransport2_ResetWindow_Proxy( 
    INNTPTransport2 __RPC_FAR * This);


void __RPC_STUB INNTPTransport2_ResetWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INNTPTransport2_INTERFACE_DEFINED__ */


#ifndef __IRASCallback_INTERFACE_DEFINED__
#define __IRASCallback_INTERFACE_DEFINED__

/* interface IRASCallback */
/* [object][local][helpstring][uuid] */ 

typedef struct tagIXPRASLOGON
    {
    CHAR szConnectoid[ 256 ];
    CHAR szUserName[ 256 ];
    CHAR szPassword[ 256 ];
    CHAR szDomain[ 256 ];
    CHAR szPhoneNumber[ 128 ];
    BOOL fSavePassword;
    }	IXPRASLOGON;

typedef struct tagIXPRASLOGON __RPC_FAR *LPIXPRASLOGON;

#ifndef RASCONNSTATE
typedef DWORD RASCONNSTATE;

#endif

EXTERN_C const IID IID_IRASCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("36D88911-3CD6-11d0-81DF-00C04FD85AB4")
    IRASCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnReconnect( 
            /* [in] */ LPSTR pszCurrentConnectoid,
            /* [in] */ LPSTR pszNewConnectoid,
            /* [in] */ IRASTransport __RPC_FAR *pTransport) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnLogonPrompt( 
            /* [out][in] */ LPIXPRASLOGON pRasLogon,
            /* [in] */ IRASTransport __RPC_FAR *pTransport) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnRasDialStatus( 
            /* [in] */ RASCONNSTATE rasconnstate,
            /* [in] */ DWORD dwError,
            /* [in] */ IRASTransport __RPC_FAR *pTransport) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnDisconnect( 
            /* [in] */ LPSTR pszCurrentConnectoid,
            /* [in] */ boolean fConnectionOwner,
            /* [in] */ IRASTransport __RPC_FAR *pTransport) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRASCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRASCallback __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRASCallback __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRASCallback __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnReconnect )( 
            IRASCallback __RPC_FAR * This,
            /* [in] */ LPSTR pszCurrentConnectoid,
            /* [in] */ LPSTR pszNewConnectoid,
            /* [in] */ IRASTransport __RPC_FAR *pTransport);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnLogonPrompt )( 
            IRASCallback __RPC_FAR * This,
            /* [out][in] */ LPIXPRASLOGON pRasLogon,
            /* [in] */ IRASTransport __RPC_FAR *pTransport);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnRasDialStatus )( 
            IRASCallback __RPC_FAR * This,
            /* [in] */ RASCONNSTATE rasconnstate,
            /* [in] */ DWORD dwError,
            /* [in] */ IRASTransport __RPC_FAR *pTransport);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnDisconnect )( 
            IRASCallback __RPC_FAR * This,
            /* [in] */ LPSTR pszCurrentConnectoid,
            /* [in] */ boolean fConnectionOwner,
            /* [in] */ IRASTransport __RPC_FAR *pTransport);
        
        END_INTERFACE
    } IRASCallbackVtbl;

    interface IRASCallback
    {
        CONST_VTBL struct IRASCallbackVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRASCallback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRASCallback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRASCallback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRASCallback_OnReconnect(This,pszCurrentConnectoid,pszNewConnectoid,pTransport)	\
    (This)->lpVtbl -> OnReconnect(This,pszCurrentConnectoid,pszNewConnectoid,pTransport)

#define IRASCallback_OnLogonPrompt(This,pRasLogon,pTransport)	\
    (This)->lpVtbl -> OnLogonPrompt(This,pRasLogon,pTransport)

#define IRASCallback_OnRasDialStatus(This,rasconnstate,dwError,pTransport)	\
    (This)->lpVtbl -> OnRasDialStatus(This,rasconnstate,dwError,pTransport)

#define IRASCallback_OnDisconnect(This,pszCurrentConnectoid,fConnectionOwner,pTransport)	\
    (This)->lpVtbl -> OnDisconnect(This,pszCurrentConnectoid,fConnectionOwner,pTransport)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRASCallback_OnReconnect_Proxy( 
    IRASCallback __RPC_FAR * This,
    /* [in] */ LPSTR pszCurrentConnectoid,
    /* [in] */ LPSTR pszNewConnectoid,
    /* [in] */ IRASTransport __RPC_FAR *pTransport);


void __RPC_STUB IRASCallback_OnReconnect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRASCallback_OnLogonPrompt_Proxy( 
    IRASCallback __RPC_FAR * This,
    /* [out][in] */ LPIXPRASLOGON pRasLogon,
    /* [in] */ IRASTransport __RPC_FAR *pTransport);


void __RPC_STUB IRASCallback_OnLogonPrompt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRASCallback_OnRasDialStatus_Proxy( 
    IRASCallback __RPC_FAR * This,
    /* [in] */ RASCONNSTATE rasconnstate,
    /* [in] */ DWORD dwError,
    /* [in] */ IRASTransport __RPC_FAR *pTransport);


void __RPC_STUB IRASCallback_OnRasDialStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRASCallback_OnDisconnect_Proxy( 
    IRASCallback __RPC_FAR * This,
    /* [in] */ LPSTR pszCurrentConnectoid,
    /* [in] */ boolean fConnectionOwner,
    /* [in] */ IRASTransport __RPC_FAR *pTransport);


void __RPC_STUB IRASCallback_OnDisconnect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRASCallback_INTERFACE_DEFINED__ */


#ifndef __IRASTransport_INTERFACE_DEFINED__
#define __IRASTransport_INTERFACE_DEFINED__

/* interface IRASTransport */
/* [object][local][helpstring][uuid] */ 


EXTERN_C const IID IID_IRASTransport;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8A950001-3CCF-11d0-81DF-00C04FD85AB4")
    IRASTransport : public IInternetTransport
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InitNew( 
            /* [in] */ IRASCallback __RPC_FAR *pCallback) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentConnectoid( 
            /* [ref][in] */ LPSTR pszConnectoid,
            /* [in] */ ULONG cchMax) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRasErrorString( 
            /* [in] */ UINT uRasErrorValue,
            /* [ref][in] */ LPSTR pszErrorString,
            /* [in] */ ULONG cchMax,
            /* [out] */ DWORD __RPC_FAR *pdwRASResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FillConnectoidCombo( 
            /* [in] */ HWND hwndComboBox,
            /* [in] */ boolean fUpdateOnly,
            /* [out] */ DWORD __RPC_FAR *pdwRASResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EditConnectoid( 
            /* [in] */ HWND hwndParent,
            /* [in] */ LPSTR pszConnectoid,
            /* [out] */ DWORD __RPC_FAR *pdwRASResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateConnectoid( 
            /* [in] */ HWND hwndParent,
            /* [out] */ DWORD __RPC_FAR *pdwRASResult) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRASTransportVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRASTransport __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRASTransport __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRASTransport __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetServerInfo )( 
            IRASTransport __RPC_FAR * This,
            /* [out][in] */ LPINETSERVER pInetServer);
        
        IXPTYPE ( STDMETHODCALLTYPE __RPC_FAR *GetIXPType )( 
            IRASTransport __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsState )( 
            IRASTransport __RPC_FAR * This,
            /* [in] */ IXPISSTATE isstate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InetServerFromAccount )( 
            IRASTransport __RPC_FAR * This,
            /* [in] */ IImnAccount __RPC_FAR *pAccount,
            /* [out][in] */ LPINETSERVER pInetServer);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Connect )( 
            IRASTransport __RPC_FAR * This,
            /* [in] */ LPINETSERVER pInetServer,
            /* [in] */ boolean fAuthenticate,
            /* [in] */ boolean fCommandLogging);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *HandsOffCallback )( 
            IRASTransport __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Disconnect )( 
            IRASTransport __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DropConnection )( 
            IRASTransport __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStatus )( 
            IRASTransport __RPC_FAR * This,
            /* [out] */ IXPSTATUS __RPC_FAR *pCurrentStatus);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InitNew )( 
            IRASTransport __RPC_FAR * This,
            /* [in] */ IRASCallback __RPC_FAR *pCallback);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCurrentConnectoid )( 
            IRASTransport __RPC_FAR * This,
            /* [ref][in] */ LPSTR pszConnectoid,
            /* [in] */ ULONG cchMax);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRasErrorString )( 
            IRASTransport __RPC_FAR * This,
            /* [in] */ UINT uRasErrorValue,
            /* [ref][in] */ LPSTR pszErrorString,
            /* [in] */ ULONG cchMax,
            /* [out] */ DWORD __RPC_FAR *pdwRASResult);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FillConnectoidCombo )( 
            IRASTransport __RPC_FAR * This,
            /* [in] */ HWND hwndComboBox,
            /* [in] */ boolean fUpdateOnly,
            /* [out] */ DWORD __RPC_FAR *pdwRASResult);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EditConnectoid )( 
            IRASTransport __RPC_FAR * This,
            /* [in] */ HWND hwndParent,
            /* [in] */ LPSTR pszConnectoid,
            /* [out] */ DWORD __RPC_FAR *pdwRASResult);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateConnectoid )( 
            IRASTransport __RPC_FAR * This,
            /* [in] */ HWND hwndParent,
            /* [out] */ DWORD __RPC_FAR *pdwRASResult);
        
        END_INTERFACE
    } IRASTransportVtbl;

    interface IRASTransport
    {
        CONST_VTBL struct IRASTransportVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRASTransport_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRASTransport_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRASTransport_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRASTransport_GetServerInfo(This,pInetServer)	\
    (This)->lpVtbl -> GetServerInfo(This,pInetServer)

#define IRASTransport_GetIXPType(This)	\
    (This)->lpVtbl -> GetIXPType(This)

#define IRASTransport_IsState(This,isstate)	\
    (This)->lpVtbl -> IsState(This,isstate)

#define IRASTransport_InetServerFromAccount(This,pAccount,pInetServer)	\
    (This)->lpVtbl -> InetServerFromAccount(This,pAccount,pInetServer)

#define IRASTransport_Connect(This,pInetServer,fAuthenticate,fCommandLogging)	\
    (This)->lpVtbl -> Connect(This,pInetServer,fAuthenticate,fCommandLogging)

#define IRASTransport_HandsOffCallback(This)	\
    (This)->lpVtbl -> HandsOffCallback(This)

#define IRASTransport_Disconnect(This)	\
    (This)->lpVtbl -> Disconnect(This)

#define IRASTransport_DropConnection(This)	\
    (This)->lpVtbl -> DropConnection(This)

#define IRASTransport_GetStatus(This,pCurrentStatus)	\
    (This)->lpVtbl -> GetStatus(This,pCurrentStatus)


#define IRASTransport_InitNew(This,pCallback)	\
    (This)->lpVtbl -> InitNew(This,pCallback)

#define IRASTransport_GetCurrentConnectoid(This,pszConnectoid,cchMax)	\
    (This)->lpVtbl -> GetCurrentConnectoid(This,pszConnectoid,cchMax)

#define IRASTransport_GetRasErrorString(This,uRasErrorValue,pszErrorString,cchMax,pdwRASResult)	\
    (This)->lpVtbl -> GetRasErrorString(This,uRasErrorValue,pszErrorString,cchMax,pdwRASResult)

#define IRASTransport_FillConnectoidCombo(This,hwndComboBox,fUpdateOnly,pdwRASResult)	\
    (This)->lpVtbl -> FillConnectoidCombo(This,hwndComboBox,fUpdateOnly,pdwRASResult)

#define IRASTransport_EditConnectoid(This,hwndParent,pszConnectoid,pdwRASResult)	\
    (This)->lpVtbl -> EditConnectoid(This,hwndParent,pszConnectoid,pdwRASResult)

#define IRASTransport_CreateConnectoid(This,hwndParent,pdwRASResult)	\
    (This)->lpVtbl -> CreateConnectoid(This,hwndParent,pdwRASResult)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRASTransport_InitNew_Proxy( 
    IRASTransport __RPC_FAR * This,
    /* [in] */ IRASCallback __RPC_FAR *pCallback);


void __RPC_STUB IRASTransport_InitNew_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRASTransport_GetCurrentConnectoid_Proxy( 
    IRASTransport __RPC_FAR * This,
    /* [ref][in] */ LPSTR pszConnectoid,
    /* [in] */ ULONG cchMax);


void __RPC_STUB IRASTransport_GetCurrentConnectoid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRASTransport_GetRasErrorString_Proxy( 
    IRASTransport __RPC_FAR * This,
    /* [in] */ UINT uRasErrorValue,
    /* [ref][in] */ LPSTR pszErrorString,
    /* [in] */ ULONG cchMax,
    /* [out] */ DWORD __RPC_FAR *pdwRASResult);


void __RPC_STUB IRASTransport_GetRasErrorString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRASTransport_FillConnectoidCombo_Proxy( 
    IRASTransport __RPC_FAR * This,
    /* [in] */ HWND hwndComboBox,
    /* [in] */ boolean fUpdateOnly,
    /* [out] */ DWORD __RPC_FAR *pdwRASResult);


void __RPC_STUB IRASTransport_FillConnectoidCombo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRASTransport_EditConnectoid_Proxy( 
    IRASTransport __RPC_FAR * This,
    /* [in] */ HWND hwndParent,
    /* [in] */ LPSTR pszConnectoid,
    /* [out] */ DWORD __RPC_FAR *pdwRASResult);


void __RPC_STUB IRASTransport_EditConnectoid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRASTransport_CreateConnectoid_Proxy( 
    IRASTransport __RPC_FAR * This,
    /* [in] */ HWND hwndParent,
    /* [out] */ DWORD __RPC_FAR *pdwRASResult);


void __RPC_STUB IRASTransport_CreateConnectoid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRASTransport_INTERFACE_DEFINED__ */


#ifndef __IRangeList_INTERFACE_DEFINED__
#define __IRangeList_INTERFACE_DEFINED__

/* interface IRangeList */
/* [object][local][helpstring][uuid] */ 

#define	RL_RANGE_ERROR	( ( ULONG  )-1 )

#define	RL_LAST_MESSAGE	( ( ULONG  )-1 )


EXTERN_C const IID IID_IRangeList;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8C438160-4EF6-11d0-874F-00AA00530EE9")
    IRangeList : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Clear( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsInRange( 
            /* [in] */ const ULONG value) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Min( 
            /* [out] */ ULONG __RPC_FAR *pulMin) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Max( 
            /* [out] */ ULONG __RPC_FAR *pulMax) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Save( 
            /* [out] */ byte __RPC_FAR *__RPC_FAR *ppbDestination,
            /* [out] */ ULONG __RPC_FAR *pulSizeOfDestination) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Load( 
            /* [size_is][in] */ byte __RPC_FAR *pbSource,
            /* [in] */ const ULONG ulSizeOfSource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddRange( 
            /* [in] */ const ULONG low,
            /* [in] */ const ULONG high) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddSingleValue( 
            /* [in] */ const ULONG value) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddRangeList( 
            /* [in] */ const IRangeList __RPC_FAR *prl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteRange( 
            /* [in] */ const ULONG low,
            /* [in] */ const ULONG high) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteSingleValue( 
            /* [in] */ const ULONG value) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteRangeList( 
            /* [in] */ const IRangeList __RPC_FAR *prl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MinOfRange( 
            /* [in] */ const ULONG value,
            /* [out] */ ULONG __RPC_FAR *pulMinOfRange) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MaxOfRange( 
            /* [in] */ const ULONG value,
            /* [out] */ ULONG __RPC_FAR *pulMaxOfRange) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RangeToIMAPString( 
            /* [out] */ LPSTR __RPC_FAR *ppszDestination,
            /* [out] */ LPDWORD pdwLengthOfDestination) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ const ULONG current,
            /* [out] */ ULONG __RPC_FAR *pulNext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Prev( 
            /* [in] */ const ULONG current,
            /* [out] */ ULONG __RPC_FAR *pulPrev) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Cardinality( 
            ULONG __RPC_FAR *pulCardinality) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CardinalityFrom( 
            /* [in] */ const ULONG ulStartPoint,
            /* [out] */ ULONG __RPC_FAR *pulCardinalityFrom) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRangeListVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRangeList __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRangeList __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRangeList __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clear )( 
            IRangeList __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsInRange )( 
            IRangeList __RPC_FAR * This,
            /* [in] */ const ULONG value);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Min )( 
            IRangeList __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pulMin);
        
        HRESULT ( STDMETHODCALLTYPE __R